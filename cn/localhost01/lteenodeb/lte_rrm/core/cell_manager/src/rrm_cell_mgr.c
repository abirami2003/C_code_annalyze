/* vim: ts=4:et:ai:ci:sw=4
*/
/*****************************************************************************
 *
 * ARICENT -
 *
 * Copyright (C) 2012 Aricent Inc . All Rights Reserved.
 *
 ****************************************************************************
 *
 * $$Id: rrm_cell_mgr.c$
 *
 *****************************************************************************
 *
 * File Description:  
 *      This file contains contains the functionality of cell Manager.
 *      
 *
 *
 *****************************************************************************
 *Revision Details
 *----------------------
 *   DATE            AUTHOR      REFERENCE       REASON
 *   Feb,2012                    Initial
 *   May,2012        gur30784                    removed rrm_l2_process_msg and
 *                                               setting ret_val as SUCCESS after
 *                                               rrm_cellm_update_prb_process_msg
 *   Apr,2014        gur27356    SPR-10397       Updated for PDCP KPI stat.
 *   29 Apr 2014    gur35095      SPR 10779      RRM not doing handover on Intra freq on Inter cell
 *   29 Apr 2014    gur35095      SPR 10782      RRM was not automatically detecting new Intra eNodeB cells 
 *   27 May 2014    gur29831  Valgrind Crash fix ue index was being limited to 255    
 *   30 May 2014    gur29831  SPR 11495          Fix added for SPR 11495    
 *   30 May 2014    gur13083     SPR 11490       RRM was not sending RSU in case
 *                                               of MACRO cells
 *   28 May,2014     gur26515    SPR-10749       Updated for Fromat2/2a/2b Multiplexing.
 *   28 May, 2014    gur27356    SPR-11383       Cell Unavailability KPI compliance
 *   26 Jun, 2014    gur29990    SPR-11848       Cell Stop Handling done
 *   1  May, 2014    gur26515                    Added code changes for SPR 10730
 *   20 June 2014    gur34951    SPR 10329       Enhancement of GU GROUP ID
 *   18 June 2014    gur31264    SPR 11740       Updated fill PLMN-ID function for SPR-11740 
 *   23 June 2014    gur13083    SPR 12036       Removed unnecessary loop trace
 *   23 June 2014    gur29831    SPR 12036       Fix done for spr 12036
 *   02 July 2014    gur26515    SPR 10450       Implemented DRX Staggering.
 *   14 Jul,2014     gur27356    SPR-12550       Delete the timer id "x2ap_icic_info_rpt_tmr.
 *   21 Jul,2014     gur30784    SPR-12707       KPI stats getting updated at timer expiry
 *   04 Aug,2014     gur13083    SPR 12910       RRM hash function was not passing correct eNB Id for calculation
 *   14 Aug,2014     gur13083    SPR 13040       RRM crashed due incase failure response is received twice
 *   18 Sep,2014     gur29831    SPR 13531       Checking for Access mode to differ b/w closed/open cells
 *   17 Sep,2014     gur35933    eICIC Changes   Handling of timers for eICIC feature was added.
 *****************************************************************************/

/***********************************************************************
 * Project Includes
 ************************************************************************/
#include "rrm_stats.h"
#include "rrm_cell_context.h"
#include "rrm_cell_mgr.h"
#include "rrm_cell_rrmim_intf.h"
#include "rrm_cell_fsm.h"
#include "rrm_utils.h"
#include <cspl.h>
#include "l3_api_parser.h"
#include "rrm_rrc_cell_intf.h"
#include "x2ap_api.h"
#include "rrc_x2apRrm_intf.h"
#include "x2ap_rrm_parser.h"
#include "s1ap_api.h"
#include "s1ap_rrm_parser.h"
#include "s1ap_rrm_composer.h"
#include "rrc_s1apRrm_intf.h"
#include "x2ap_rrm_composer.h"


/* SRS_FREQ_HOPPING_START */
#include "rrm_ue_context.h"
/* SRS_FREQ_HOPPING_END */
#include "rrm_son_composer.h"
#include "rrm_events.h"
#include "rrm_event_defines.h"
#include "rrm_ue_mgr.h"
/* SPR 9463 Fix-2 Start */
#include "rrm_mem_utils.h"
/* SPR 9463 Fix-2 End */
#ifdef LTE_EMBMS_SUPPORTED
#include "m2ap_api.h"
#include "rrm_cell_embms.h"
#endif
#define LTE_RRM_CELL_INFO_LOG	"cell_info_log.txt"

#define RI_COINCIDE_WITH_CQI
#define PUCCH_RES_GAP
#ifdef LTE_EMBMS_SUPPORTED
/****************************************************************************
 * Exported Variables/Functions
 ****************************************************************************/

extern
rrm_void_t
rrm_maps_frame_allocation_period_for_cellm
(
 rrmcm_mif_frame_allocation_period_et   *p_frame_allocation_period_to_cellm,
 U8                                      radio_frame_allocation_period
 );

extern
rrm_return_et
rrm_process_mtch_info_with_broadcasted_info
(
 rrm_cell_context_t  *p_cell_ctx,
 S32                   flag,
 rrm_bool_t           updated_ncl_received_from_son,
 U8                   *new_neigh_cell_config
 );

U8 mbms_sf_list_tdd[RRM_FIVE] = { RRM_THREE, RRM_FOUR , RRM_SEVEN, RRM_EIGHT , RRM_NINE };
U8 mbms_sf_list_fdd[RRM_SIX] = { RRM_ONE, RRM_TWO , RRM_THREE , RRM_SIX, RRM_SEVEN, RRM_EIGHT};
#endif

/* function prototype of event raise function start*/
/* + SPR 17439 */
void rrm_raise_event_enb_config_transfer(void);
void rrm_raise_event_mme_config_transfer(void);
/* - SPR 17439 */
/* function prototype of event raise function end*/

U16 max_num_of_resources_for_assigned_periodicity(U16    sr_periodicity);
U16 max_num_of_resources_for_assigned_periodicity_cqi(U16    cqi_periodicity);
rrm_return_et prepare_cqi_ri_resource_list
(
 rrm_cell_context_t      *p_cell_context,
 cqi_ri_map_info_per_ue  *p_outgoing_map,
 U16                     cqi_periodicity_val,
 U16                      *p_alloc_cqi_ri_from_algo_val
 );
rrm_void_t  shuffle_ri_indexes(U16      *ri_index, U16      size);



#ifndef TDD_MODE_FLAG
rrm_void_t call_function_to_map_indexes(U16                  *cqi_indexval_for_configured_periodicity, 
		U16                        *ri_index,
		cqi_ri_map_info_per_ue     *cqi_ri_table_map,
		U16                        num_of_cqi_indexws,
		U16                        ri_periodicity,
		U16                        cqi_start_index,
		U16                        ri_start_index
        /*SPR 17777 +-*/
#ifdef LTE_EMBMS_SUPPORTED
       , U16                      cqi_periodicity                        
#endif
		);
#else
rrm_void_t call_function_to_map_indexes(U16                  *cqi_indexval_for_configured_periodicity, 
		U16                        *ri_index,
		cqi_ri_map_info_per_ue     *cqi_ri_table_map,
		U16                        num_of_cqi_indexws,
		U16                        cqi_periodicity,
		U16                        ri_periodicity,
		U16                        cqi_start_index,
		U16                        ri_start_index,
		U8                        tdd_subfrm_config
		);

#endif
#ifndef TDD_MODE_FLAG
rrm_return_et 
prepare_sr_resource_list
(
        /*SPR 17777 +-*/
 U16                     *p_outgoing_map,
 U16                     sr_periodicity_val,
 U8                      *alloc_sr_from_algo_val
 );
#else
rrm_return_et 
prepare_sr_resource_list
(
 rrm_cell_context_t      *p_cell_context,
 U16                     *p_outgoing_map,
 U16                     sr_periodicity_val,
 U8                      *alloc_sr_from_algo_val
 );

#endif

#ifdef TDD_MODE_FLAG

rrm_bool_et 
check_for_valid_cqi_periodicity_for_tdd
(
 U16 cqi_periodicity,
 U8 tdd_subfrm_config
 );

rrm_void_t 
find_new_cqi_periodicity
(
 U16 cqi_periodicity,
 U8 tdd_subfrm_config,
 U16 *p_cqi_periodicity_tdd
 );

rrm_void_t
get_dl_subfrm_count_for_tdd_config
(
 U8 tdd_subfrm_config ,
 U16 *p_max_dl_sbfrme_count
 );

rrm_bool_et
check_cqi_collision_wd_dl_sbfrm
(
 U16 cqi_offset,
 U8 tdd_subfrm_config
 );

rrm_bool_et
rrm_check_subfrm_offset_is_valid
(
 U16 subfrm_offset,
 U8 tdd_subfrm_config ,
 U8  periodicity
 );

rrm_bool_et
rrm_check_subfrm_offset_is_for_ul
(
 U16 cqi_sbfrm,
 U8 tdd_subfrm_config
 );

rrm_void_t
prepare_srs_index_list
(
 U16 srs_start_index,
 U16 srs_periodicity_in_ms,
 rrm_bool_t spcl_sf_valid_for_srs,
 U8 tdd_spcl_sf_pattern,
 U8 tdd_sbfrm_config,
 U8 srs_subframe_config,
 U16 *p_srs_index_list_as_per_periodicity,
 U16 *p_srs_index_count
 );
U8 tdd_config_subfrm_pattern[MAX_TDD_UL_DL_CONFIG][SUBFRAMES_IN_ONE_FRAME];
U8 valid_sf_offset_for_srs_config [MAX_SRS_SF_CONFIG][MAX_OFFSETS_IN_SRS_SF_CONFIG];
U8 valid_offsets_for_2ms_srs_periodicity[SUBFRAMES_IN_ONE_FRAME][MAX_SRS_OFFSETS_FOR_2MS];

#endif

/* SRS_FREQ_HOPPING_START */
/*SPR 21223 START*/ 
rrm_return_et
rrm_initialize_srs_parameters_for_ue
/*SPR 21223 END*/ 
(
 rrm_cell_context_t *p_cell_context
 );

rrm_void_t
find_srs_index_limit_for_wb_and_sb
(
 U16 srs_subframes_max_count,
 U16 *p_wb_srs_max_index 
 );
/* SPR_8391_CHANGES_START*/
rrm_void_t
populate_wideband_srs_res_list
(
 rrm_wb_srs_table_t *rrm_wb_srs_table,
 U16 *p_srs_subframes_list,
 U16 wb_srs_max_index,
 U16 *p_res_anchor,
 U8 srs_bw,
 /*SPR 21223 START*/
 U8 srs_hopping_bw,
 rrm_bool_et completely_wideband,
 U16 max_num_ue_per_cell
 /*SPR 21223 END*/
 );

rrm_void_t
populate_subband_srs_res_list
(
 rrm_sb_srs_table_t *rrm_sb_srs_table,
 U16 *p_srs_subframes_list,
 U16 wb_srs_max_index,
 U16 srs_subframes_max_count,
 U8 n_rrc_min_index,
 U8 n_rrc_max_count,
 U8 n_rb_hopping_bw,
 U16 *p_res_anchor,
 U8 wb_hopping_bw_for_ce,
/*SPR 21223 START*/
 U8 srs_bw,
 U16 max_num_ue_per_cell
/*SPR 21223 END*/
 );
/* SPR_8391_CHANGES_END*/
U8 srs_rb_allocation_tbl_bw_10[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_15[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_20[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_upto_5[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];

rrm_void_t
get_the_n_rrc_index_max_limit
(
 rrm_oam_band_width_et channel_bandwidth,
 U8 subframe_bw_config,
 U8 srs_bandwidth,
 U8 srs_hopping_bw,
/* SPR_8391_CHANGES_START*/
 U8 *p_n_rrc_max_count,
 U8 *p_rb_count_hopping_bw
 );

rrm_void_t
get_sub_band_data_sets_for_icic
(
 rrm_oam_band_width_et      channel_bandwidth,
 rrm_bool_et                hopping_enable,
 U8                         subframe_bw_config,
 rrm_dynamic_icic_info_t    *p_dynamic_icic_info,
 U8                         *p_wb_srs_bw_for_ce,
 U8                         *p_wb_hopping_bw_for_ce,
 U8                         *p_n_rrc_min_index
 );
/* SPR_8391_CHANGES_END*/
U8 srs_rb_allocation_tbl_bw_10[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_15[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_20[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];
U8 srs_rb_allocation_tbl_bw_upto_5[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO];

/* SRS_FREQ_HOPPING_END */
/***********************************************************************
 * Global variables
 ************************************************************************/
rrm_global_context_t *p_g_rrm_cell_ctx;
/* UE MEAS CHANGES : STARTS */
rrm_void_t
rrm_cellm_cell_init_meas_context_list
(
 rrm_cell_context_t *p_cell_context
 );
/* X2AP START */
rrm_void_t
rrm_cellm_cell_init_x2_enb_list
(
 rrm_global_context_t *p_g_rrm_cell_ctx
 );
/* X2AP END */
/* UE MEAS CHANGES : ENDS */

/* Fix 960 Start */
rrm_void_t
rrm_init_tnl_discovery_trans_id_list(
 rrm_global_context_t *p_g_rrm_cell_ctx
);
/* Fix 960 End */

/*DYNAMIC SIB SCHEDULING START*/
rrm_void_t
rrm_cellm_init_si_segment_data
(
 rrm_cell_context_t *p_cell_context
 );
/*DYNAMIC SIB SCHEDULING END*/
rrm_void_t
rrm_cellm_cell_init_etws_cmas_list
(
 rrm_cell_context_t *p_cell_context
 );
void rrm_populate_enb_context
(
 rrm_enb_context_t  *p_enb_context,
 void               *p_api
 );
/*RCC_LOAD_IND*/
const S8 * CELL_LOAD_TYPE_STATE[]=
{
	(const S8 *)"RRM_LOW",
	(const S8 *)"RRM_MEDIUM",
	(const S8 *)"RRM_HIGH",
	(const S8 *)"RRM_OVERLOAD",
	(const S8 *)"INVALID_LOAD",
};

const S8 * CELL_LOAD_SRC[]=
{
	(const S8 *)"TNL",
	(const S8 *)"MEMORY",
	(const S8 *)"CPU",
	(const S8 *)"RCC",
	(const S8 *)"INVALID_SRC",

};

/*RCC_LOAD_IND*/

/*SPR_12535_FIX_START*/
#ifdef TDD_MODE_FLAG

/* SubFrameAssignment */  /*SpecialSubframePatterns */ 
rrm_prb_usage_factor_t  num_dl_ul_scdeulable[MAX_SUB_FRAME_ASSIGNMENTS_COUNT][MAX_SPECIAL_SUBFRAME_PATTERNS_COUNT] = 
{
  /* TDD Config  0 */
  {{2, 6},{4, 6},{4, 6},{4, 6},{4, 6},{2, 6},{4, 6},{4, 6},{4, 6}},
  /* TDD Config  1 */
  {{4, 4},{6, 4},{6, 4},{6, 4},{6, 4},{4, 4},{6, 4},{6, 4},{6, 4}},
  /* TDD Config  2 */
  {{6, 2},{8, 2},{8, 2},{8, 2},{8, 2},{6, 2},{8, 2},{8, 2},{8, 2}},
  /* TDD Config 3 */
  {{6, 3},{7, 3},{7, 3},{7, 3},{7, 3},{6, 3},{7, 3},{7, 3},{7, 3}},
  /* TDD Config 4 */
  {{7, 2},{8, 2},{8, 2},{8, 2},{8, 2},{7, 2},{8, 2},{8, 2},{8, 2}},
  /* TDD Config 5 */
  {{8, 1},{9, 1},{9, 1},{9, 1},{9, 1},{8, 1},{9, 1},{9, 1},{9, 1}},
  /* TDD Config 6 */
  {{3, 5},{5, 5},{5, 5},{5, 5},{5, 5},{3, 5},{5, 5},{5, 5},{5, 5}} 
};

#endif
/* SPR 13383 changes start */

/********************** Carrier Aggregation Table Start **************************/

/******************************************************
          Intra Band Non contigious Table
*******************************************************/
/*SPR 21878 Start*/
/*As per spec 36.101 R12v12.14.1 Support is added for only bandwidth combination set 0
 * for all CA configurations and only those combinations are added that are for only 
 * two CC's
 */
U8 rrm_ca_intra_band_non_contigious_table[] =
     {
/*num of band combination */    11,
/*band combination 1 start */  /*{*/
     /*carrier component band*/    25,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
 /*bandwidth combination start *//* { */
 /*carrier component 1 allowed bandwidths */ RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ,
 /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ,
                                /*  } */
/*band combination 1 end   */  /*},*/
/*band combination 2 start */ /* {*/
/*carrier component band*/         41,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
                                /* } */
/*band combination 3 start */ /* {*/
/*carrier component band*/         3,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
                                /* } */
/*band combination 3 end   */  /*},*/
/*band combination 4 start */ /* {*/
/*carrier component band*/         2,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
                                /* } */
/*band combination 4 end   */  /*},*/
/*band combination 5 start */ /* {*/
/*carrier component band*/         4,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
                                /* } */
/*band combination 5 end   */  /*},*/
/*band combination 6 start */ /* {*/
/*carrier component band*/         7,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_15MHZ ,
                                /* } */
/*band combination 6 end   */  /*},*/
/*band combination 7 start */ /* {*/
/*carrier component band*/         7,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_10MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ ,
                                /* } */
/*band combination 7 end   */  /*},*/
/*band combination 8 start */ /* {*/
/*carrier component band*/         7,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_15MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ ,
                                /* } */
/*band combination 8 end   */  /*},*/
/*band combination 9 start */ /* {*/
/*carrier component band*/         7,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
                                /* } */
/*band combination 9 end   */  /*},*/
/*band combination 10 start */ /* {*/
/*carrier component band*/         23,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_10MHZ,
                                /* } */
/*band combination 10 end   */  /*},*/
/*band combination 11 start */ /* {*/
/*carrier component band*/         42,
     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /* Carrier component class*/  RRM_BANDWIDTH_CLASS_A,
     /*bandwidth combination set*/ 1,
/*bandwidth combination start *//* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ
                                /* } */
/*band combination 11 end   */  /*},*/
     };

/*SPR 21878 End*/



/******************************************************
          Intra Band contigious Table
*******************************************************/
/* Help : entry addition

   num of band combiantion : specifies the number of combination present in table
   carrier component band  : This comment specifies the carrier component band
   combiantoin start       : This comments specifies start of combiantion
   bandwidth class         : This tag specifies the bandwidth class used for combiantion like :  1C
   number of bandwidth comb: This tag specifies the number of bandwidth combination currenty in table for this band combiantion

   carrier component 1 allowed bandwidth : This tags specify the carrier component's allowed bandwidth
   carrier component 2 allowed bandwidths: This tags specify the carrier component's allowed bandwidth

   Note : Entry are added in ascending order
   for eg :     Ist band-> 1
 combination starts        {

                           }

                2nd band-> 7
                           {

                           }

   if entry of band is less than 7 and greator than 1 then entry should come in between of these two entry
   to keep the format of table consistent. 

   for addition of new entry : first increase the num of band combination count according to added count.

   add the entry for band 2:

   {
    /num of band combination/ 6,
    /carrier component band/     1,
    / combination starts          { /
    / bandwidth class /           RRM_BANDWIDTH_CLASS_C,
                                   .....
                                   .....
   /combiantion end               }/

    /carrier component band/      2,              ///////// NEW ENTRY 
    / combination starts          { /
    / bandwidth class /           RRM_BANDWIDTH_CLASS_XYZ,
                                  ......
                                  ......
    /combiantion end              }/

    /carrier component band/      7,              
    / combination starts          { /
    / bandwidth class /           RRM_BANDWIDTH_CLASS_XYZ,
                                  ......
                                  ......
    /combiantion end              }/

   }

*/
   


U8 rrm_ca_intra_band_contigious_table[] = 
     {
/*num of band combination */5,
/*carrier component band*/     1,
/* combination starts          { */
      /* bandwidth  class*/    RRM_BANDWIDTH_CLASS_C,
 /*bandwidth combination set*/ 1,
/*number of bandwidth combination*/  2,
/*bandwidth combination start */     /* { */
 /*carrier component 1 allowed bandwidths */ RRM_BANDWIDTH_15MHZ,
 /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_15MHZ,
                                     /* } */
                                     /* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
/*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
                                     /* } */
/* combination ends            }, */
/*carrier component band*/     7,
/* combination starts          { */
     /* bandwidth  class*/     RRM_BANDWIDTH_CLASS_C,
 /*bandwidth combination set*/ 1,
/*number of bandwidth combination*/  2,
/*bandwidth combination start */     /* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_15MHZ,
 /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_15MHZ,
                                     /* } */
                                     /* { */
/*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
 /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_20MHZ ,
                                     /* } */
 /* combination ends            }, */
 /*carrier component band*/     38,
 /* combination starts          { */
      /* bandwidth  class*/     RRM_BANDWIDTH_CLASS_C,
 /*bandwidth combination set*/  1,
/*number of bandwidth combination*/  2,
 /*bandwidth combination start */     /* { */
  /*carrier component 1 allowed bandwidths */ RRM_BANDWIDTH_15MHZ,
  /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_15MHZ,
                                     /* } */
                                     /* { */
/*carrier component 1 allowed bandwidths */   RRM_BANDWIDTH_20MHZ ,
/*carrier component 2 allowed bandwidths */   RRM_BANDWIDTH_20MHZ ,
                                     /* } */
 /* combination ends            }, */
  /*carrier component band*/    40,
 /* combination starts          { */
       /* bandwidth  class*/    RRM_BANDWIDTH_CLASS_C,
 /*bandwidth combination set*/  1,
/*number of bandwidth combination*/  3,
 /*bandwidth combination start */     /* { */
 /*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_10MHZ,
  /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_20MHZ,
                                      /* } */
                                     /*  { */
 /*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_15MHZ ,
 /*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_15MHZ ,
                                     /*  } */
                                     /*  { */
 /*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_20MHZ ,
 /*carrier component 2 allowed bandwidths */  RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_20MHZ,
                                     /*  } */
 /* combination ends            }, */
   /*carrier component band*/   41,
 /* combination starts          { */
        /* bandwidth  class*/   RRM_BANDWIDTH_CLASS_C,
 /*bandwidth combination set*/  1,
 /*number of bandwidth combination*/ 3,
 /*bandwidth combination start */     /* { */
 /*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_10MHZ,
  /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_20MHZ,
                                     /*  } */
                                     /* { */
 /*carrier component 1 allowed bandwidths */  RRM_BANDWIDTH_15MHZ ,
  /*carrier component 2 allowed bandwidths */ RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ ,
                                     /* } */
                                     /* { */
  /*carrier component 1 allowed bandwidths */ RRM_BANDWIDTH_20MHZ ,
   /*carrier component 2 allowed bandwidths */RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ
                                     /* } */
                     /*         }, */

     };




/******************** Inter Band Table **********************/


/* Help :
   /num of band combination/ : Tag specify the number of combination exist in table
   /carrier component 1/     : Tag specify the carrier component value.
   /number of combination/   : Tag specify the number of combination with other carrier components
   /bandwidthcombination set/: Tag specify the combination set exist in table

   /carrier component 1 allowed bandwidths/ : Tag specify the allowed bandwidth for first carrier component
   /carrier component 2 allowed bandwidths/ : Tag specify the allowed bandwidth for second carrier component

   Example : for adding new entry , developer must keep the ascending order of entry in Table.
   
   in addition of new entry, developer first should increase the num of band combiantion value by one.

   /num of band combination/  8,
                         {/Carrier component 1st combination start /
                     /carrier component 1/    1,
                     /number of combination / 4,
                                              {
                  /carrier component 2 /          5,
                  / bandwidth com set /           0,
                                                  ....
                                                  ....
                                              }   
                         }/Carrier component 1st combination end /

                         ...................................
                         ...................................
                         ...................................
                         { /Carrier component 6th combination start / ////// NEW entry
                         /carrier component 1/6,
                     /number of combination / 4,
                                              {
                  /carrier component 2 /          7,
                  / bandwidth com set /           0,
                                                  ....
                                                  ....
                                              }   
                         }/Carrier component 6th combination end /
                         
 */
/*SPR 20234 Start*/
U8 rrm_ca_interband_comb_table[] =
     {
        /*  {*/
/* LAA Rel13 Code + */ 
/*num of band combination*/8,
/* LAA Rel13 Code - */ 
                  /*{*//*Carrier component 1st combination start */
            /*carrier component 1*/    1,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
/* LAA Rel13 Code + */ 
            /*number of combination  */4,   	
/* LAA Rel13 Code - */ 
                       /* { */
                        /*carrier component 2 */   5,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                      /*bandwidthcombination set*/ 1,
  /*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_10MHZ,    
  /*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_10MHZ,
                       /* }*/
                       /* {*/
                          /*carrier component 2*/  18,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                       /*bandwidthcombination set*/1,
/*carrier component 1 allowed bandwidths */       RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,    
/*carrier component 2 allowed bandwidths */       RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ,
                       /* }*/
                       /* {*/
                        /*carrier component 2 */   19,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                      /*bandwidthcombination set*/  1,
/*carrier component 1 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ,    
/*carrier component 2 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ, 
                       /* }*/
                       /* {*/
                      /*carrier component 2 */     21,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                      /*bandwidthcombination set*/  1,
/*carrier component 1 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ, 
                       /* }*/
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
                   /* },*//*Carrier component 1st combination end */
                   /* { *//*Carrier component 2nd combination start */
               /*carrier component 1*/ 2,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
/* LAA Rel13 Code + */ 
            /*number of combination  */2,   
/* LAA Rel13 Code - */ 
                       /* { */
                 /*carrier component 2 */          17,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                 /*bandwidthcombination set*/       1,
/*carrier component 1 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */      RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* {*/
                 /*carrier component 2 */          29,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                 /*bandwidthcombination set*/       1,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_3MHZ | RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
                   /* },*//*Carrier component 2nd combination end   */
                   /* {*/ /*Carrier component 3rd combination start */
               /*carrier component 1*/ 3,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
/* LAA Rel13 Code + */ 
           /*number of combination  */ 4,   
/* LAA Rel13 Code - */ 
                       /* {*/
                  /*carrier component 2 */          5,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                  /*bandwidthcombination set*/      2,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ , 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_10MHZ , 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ,
                       /* }*/
                       /* { */
               /*carrier component 2*/              7,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
             /*bandwidthcombination set*/            1,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
                       /* }*/
                       /* {*/
                  /*carrier component 2 */          8,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                  /*bandwidthcombination set*/      2,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ |  RRM_BANDWIDTH_10MHZ, 
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ |  RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* {*/
                  /*carrier component 2 */         20,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                   /*bandwidthcombination set*/     1,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ |  RRM_BANDWIDTH_10MHZ, 
                      /*  }*/
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
                   /* },*/ /*Carrier component 3rd combination end   */
        
                   /* {*/ /*Carrier component 4th combination start */
             /*carrier component 1*/   4,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
/* LAA Rel13 Code + */ 
           /*number of combination  */ 6,
/* LAA Rel13 Code - */ 
                       /* {*/
                        /*carrier component 2*/     5,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                        /*bandwidthcombination set*/1,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ , 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* { */
                    /*carrier component 2*/         7,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                    /*bandwidthcombination set*/    1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ , 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
                       /* }*/
                       /* {*/
                   /*carrier component 2*/         12,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                    /*bandwidthcombination set*/    1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_1_4MHZ | RRM_BANDWIDTH_3MHZ | RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ |  RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* {*/
                    /*carrier component 2*/        13,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                     /*bandwidthcombination set*/   2,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_10MHZ, 
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_10MHZ, 
                      /*  }*/
                       /* {*/
                    /*carrier component 2*/        17, 
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                    /*bandwidthcombination set*/    1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* {*/
                   /*carrier component 2*/         29, 
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                    /*bandwidthcombination set*/    1,
/*carrier component 1 allowed bandwidths */     RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */     RRM_BANDWIDTH_3MHZ | RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 

                    /* },*//*Carrier component 4th combination end   */

                   /* { *//*Carrier component 5th combination start */
              /*carrier component 1*/  5,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
       /*number of combination  */     2,   
                       /* { */
                         /*carrier component 2*/   12,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                       /*bandwidthcombination set*/ 1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                       /* {*/
                        /*carrier component 2*/    17,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                       /*bandwidthcombination set*/ 1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
                        
                    /* },*/ /*Carrier component 5th combination end   */

                   /* { *//*Carrier component 6th combination start */
              /*carrier component 1*/  7,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
        /*number of combination  */    1,   
                       /* { */
                         /*carrier component 2*/   20,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                  /*bandwidthcombination set*/      1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ | RRM_BANDWIDTH_20MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ,
                       /* }*/
                       
                    /* },*//*Carrier component 6th combination end   */

                   /* { *//*Carrier component 7th combination start */
              /*carrier component 1*/  8,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
/* LAA Rel13 Code + */ 
           /*number of combination  */ 1,   
/* LAA Rel13 Code - */ 
                       /* { */
                    /*carrier component 2*/        20,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                    /*bandwidthcombination set*/    1,
/*carrier component 1 allowed bandwidths */   RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */   RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
                       /* }*/
/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
                       
                    /* },*/ /*Carrier component 7th combination end   */

                   /* { *//*Carrier component 8th combination start */
              /*carrier component 1*/  11,
         /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
           /*number of combination  */  1,   
                       /* { */
                      /*carrier component 2*/      18,
                     /* carrier component class*/  RRM_BANDWIDTH_CLASS_A,
                  /*bandwidthcombination set*/      1,
/*carrier component 1 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ, 
/*carrier component 2 allowed bandwidths */    RRM_BANDWIDTH_5MHZ | RRM_BANDWIDTH_10MHZ | RRM_BANDWIDTH_15MHZ ,
                       /* }*/
                       
                    /* },*/ /*Carrier component 8th combination end   */

/* LAA Rel13 Code + */ 
/* LAA Rel13 Code - */ 
               /* }*/
     };

/********************** Carrier Aggregation Table End ****************************/

/****************************************************************************
 * Function Name  : rrm_function_create_sband_index 
 * Inputs         : Pointer to rrm_interband_table_t structure
 * Outputs        : 
 * Returns        : void
 * Description    : This function create the indexes of inter band table's 
                    sband array for given pband
 ****************************************************************************/
rrm_void_t
rrm_function_create_sband_index( rrm_interband_table_t   *p_rrm_inter_band_tb )
{
	U16    i = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
	
   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
   "Number of Inter bands = %d " , p_rrm_inter_band_tb->num );

	for( i = RRM_ZERO; i < p_rrm_inter_band_tb->num ; i++ )
	{
		p_rrm_inter_band_tb->ptr_band[i].num_of_bands_sub_table =
                        (p_rrm_inter_band_tb->ptr_band[i].band)[RRM_ONE];

		p_rrm_inter_band_tb->ptr_band[i].band_comb_sub_table = 
                        &((p_rrm_inter_band_tb->ptr_band[i].band)[RRM_TWO]);

        RRM_TRACE( g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "Pcell band = %d at index = %d, Number of scell band combinations = %d" ,
        (p_rrm_inter_band_tb->ptr_band[i].band)[RRM_ZERO],i,
         p_rrm_inter_band_tb->ptr_band[i].num_of_bands_sub_table );

	}

    RRM_UT_TRACE_EXIT();
}

/*EICIC_TDD_CHANGES_START*/
/****************************************************************************
 * Function Name  : rrm_validate_abs_pattern_for_tdd 
 * Inputs         : U8 *abs_pattern
 *                  U8    abs_size
 * Outputs        : 
 * Returns        : success/failure
 * Description    : This function validated the abs pattern as per tdd config
 ****************************************************************************/
rrm_return_et
rrm_validate_abs_pattern_for_tdd
(
U8   *abs_pattern,
U8    abs_size
)
{
   U8 abs_count   = RRM_ZERO;
   U8 abs_bit = RRM_ZERO;
   U8 bits_to_be_checked = RRM_ZERO;
   rrm_return_et ret_val = RRM_SUCCESS;

   RRM_UT_TRACE_ENTER();
   
   if( RRM_MAX_ABS_PATTERN_BYTE_TDD_0 == abs_size )
   {
       bits_to_be_checked = RRM_TWO;
   }
   if( (RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 == abs_size) || (RRM_MAX_ABS_PATTERN_BYTE_TDD_6 == abs_size) )
   {
       bits_to_be_checked = RRM_FOUR;
   }    
   for(abs_count = RRM_ZERO ; abs_count < RRM_MAX_PATTERN_BYTE ; abs_count++)
   {
       if(abs_count == (abs_size-RRM_ONE))
       {
           for(abs_bit = RRM_ZERO;abs_bit < bits_to_be_checked;abs_bit++) 
           {
               /*SPR 14634 start*/
               if( (RRM_ONE << abs_bit) == ((abs_pattern[abs_count]) & (RRM_ONE << abs_bit)))
               {
                  RRM_TRACE( g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                      "Incorrect bit which is set is = %d",((abs_size * RRM_EIGHT)-abs_bit));
                  ret_val = RRM_FAILURE ;
                   break;
               }
               /*SPR 14634 end*/
           }    
       }    
       /*14516_FIX_START*/
       else if(abs_count > (abs_size-RRM_ONE))
       {
           if( RRM_ZERO != (abs_pattern[abs_count]))
           {
               /* SPR 21251 Start */
               RRM_TRACE( g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                   "abs pattern should be set only from 0 to %d, but set on incorrect index: %d",
                                   abs_size-RRM_ONE, abs_count);
               /* SPR 21251 End */
               ret_val = RRM_FAILURE ;
               break;
           }
       }
       /*14516_FIX_END*/
  }
  RRM_UT_TRACE_EXIT();
  return ret_val;
}    
/*EICIC_TDD_CHANGES_END*/
/****************************************************************************
 * Function Name  : rrm_calculate_sband_offset 
 * Inputs         : Pointer to U8 band of carrier component band 
 * Outputs        : It returns the calculated offset value
 * Returns        : U16
 * Description    : This function calculate the offset for each pcell band 
 ****************************************************************************/
U16 rrm_calculate_sband_offset( U8 *pband )
{
    U8  index = RRM_ZERO;
    U8  offset = RRM_ZERO;
    U8  num_of_bands_sub_table = pband[RRM_TWO];
    U8  band_set = pband[RRM_FIVE];
   /*SPR 16255 FIX START*/
   U8 noofItems=sizeof(rrm_ca_interband_comb_table)/sizeof(rrm_ca_interband_comb_table[0]);
   /*SPR 16255 FIX STOP*/

    RRM_UT_TRACE_ENTER();

    /* num_of_bands_sub_table specifies the number of combination with other component carriers*/
    for( index = RRM_ZERO ;index < num_of_bands_sub_table ; index++ )
    {
        /* one sband size = (RRM_ONE + ( band_set * 2)) + 2 +1 */
        /* offset  = X + Y + Z */
        /* X = ( ( RRM_ONE + ( band_set * RRM_TWO )) ) =--> default size of combination set + number of combination set * 2 */
        /* Y = size for bandwidth class */
        /* Z = size of carrier component 2*/


        offset += ( RRM_ONE + ( band_set * RRM_TWO )) +  RRM_ONE + RRM_ONE;
        /*SPR 16255 FIX START*/
        if(&rrm_ca_interband_comb_table[noofItems-1]< &pband[ RRM_FIVE + offset])
            return RRM_ZERO; 
       /*SPR 16255 FIX STOP*/
        band_set = pband[ RRM_FIVE + offset]; 
    }

    RRM_UT_TRACE_EXIT();

    return offset;
}



/****************************************************************************
 * Function Name  : rrm_create_ca_inter_band_table_index 
 * Inputs         : Pointer to the rrm_global_context_t
 * Outputs        : 
 * Returns        : void
 * Description    : This function create the inter band ca table indexes
 ****************************************************************************/
rrm_void_t
rrm_create_ca_inter_band_table_index(
                      rrm_global_context_t    *p_cell_gb_context )
{
	U8                          i = RRM_ZERO;
	U16                         band_offset = RRM_ZERO;
    U8                          num_of_band_arr = rrm_ca_interband_comb_table[RRM_ZERO];
    rrm_interband_table_t       *p_inter_band_tb = RRM_NULL;
   
    RRM_UT_TRACE_ENTER();

    p_inter_band_tb = &(p_cell_gb_context->rrm_ca_band_table.rrm_inter_band_tb);

    /* allocate the memory */
	p_inter_band_tb->ptr_band = 
                       (rrm_sband_table_t*)rrm_mem_get(num_of_band_arr  * sizeof(rrm_sband_table_t));

    /* Coverity 93965 Fix Start */
    if ( RRM_PNULL == p_inter_band_tb->ptr_band )
    {
       /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_inter_band_tb->ptr_band failed" );
       /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return;
    }
    /* Coverity 93965 Fix end */
    /* assert if memory allocation is failed */
    RRM_ASSERT( RRM_PNULL != p_inter_band_tb->ptr_band );

    /* num of band array in row */
    p_inter_band_tb->num = num_of_band_arr;
   
	p_inter_band_tb->ptr_band[i].band = &(rrm_ca_interband_comb_table[RRM_ONE]);

	p_inter_band_tb->ptr_band[i].num_of_bands_sub_table =
                        (p_inter_band_tb->ptr_band[i].band)[RRM_TWO];

	p_inter_band_tb->ptr_band[i].band_comb_sub_table = 
                        &((p_inter_band_tb->ptr_band[i].band)[RRM_THREE]);

    band_offset = rrm_calculate_sband_offset( p_inter_band_tb->ptr_band[i].band );
	
	for( i = RRM_ONE ; i < num_of_band_arr ; i++ ) 
	{

        /* next pband  = last_pand + sizeof(band_comb_sub_table) + sizeof(num_of_bands_sub_table) + 1  */
		p_inter_band_tb->ptr_band[i].band = 
        p_inter_band_tb->ptr_band[i-RRM_ONE].band + RRM_ONE + RRM_ONE + RRM_ONE + band_offset;

        p_inter_band_tb->ptr_band[i].num_of_bands_sub_table =
                            (p_inter_band_tb->ptr_band[i].band)[RRM_TWO];

        p_inter_band_tb->ptr_band[i].band_comb_sub_table = 
                            &((p_inter_band_tb->ptr_band[i].band)[RRM_THREE]);

        /* function calculates the offset for next sub table */
        band_offset = rrm_calculate_sband_offset( p_inter_band_tb->ptr_band[i].band );
        /*SPR 16255 FIX START*/
        if(RRM_ZERO==band_offset)
            break;
       /*SPR 16255 FIX STOP*/

	} 


    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : rrm_get_matched_sband_info 
 * Inputs         : Pointer to rrm_sband_table_t and sband value 
 * Outputs        : return the sband matched in table 
 * Returns        : U8*
 * Description    : This function match the band value of given band array 
                    information of band combination
 ****************************************************************************/
U8*
rrm_get_matched_sband_info( rrm_sband_table_t  *pband , U8 sband )
{
    U8    i = RRM_ZERO;
    U16   num_of_sband_comb = pband->num_of_bands_sub_table;
    U8    *sband_table = RRM_NULL;
    U8    found = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    sband_table = pband->band_comb_sub_table;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
    "Number of Carrier combination = %d " , num_of_sband_comb );

    for( i = RRM_ZERO ; i < num_of_sband_comb ; i++ )
    {
        RRM_TRACE( g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
        "Carrier 2 band value =%d at index = %d of table",*sband_table, i );
        /*match the first entry of band sub table , which contains the band */
        if( sband == *sband_table )
        {
            found = RRM_ONE;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Carrier 2 band %d matched in sub Table of band at index %d ", sband , i );
            break;
        }
        else
        {
            /* moving to location of next sub table of combination. 
               position index 1 of sub table specify the comination set.
               if combination set is zero then sub table would have one pair
               of bandwidth combination . if combination set is one then sub table 
               would have two pair of bandwidth combination */
               /* 0->[band] , 1->[ combination set ] , 2->[ bandwith pair ] , 3->[ optional bandwith pair depens on set ]  */
            sband_table = sband_table + ( RRM_ONE + (sband_table[RRM_TWO] * RRM_TWO ) ) + RRM_ONE + RRM_ONE; 
        }
        
    }

    if( RRM_ZERO == found )
        sband_table = RRM_NULL;

    RRM_UT_TRACE_EXIT();

    return sband_table;
}


/****************************************************************************
 * Function Name  : rrm_get_bitmask_corresponding_class
 * Inputs         : rrm_ca_band_width_class_r10_et bandwidth class value 
 * Outputs        : return the corresponding bitmask value of bandwidth class
 * Returns        : U8
 * Description    : This function returns the bitmask corresponding to class
 ****************************************************************************/
U8
rrm_get_bitmask_corresponding_class( rrm_ca_band_width_class_r10_et  bandwidth_class )
{
    U8 bitmask = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch(bandwidth_class)
    {
        case rrm_bw_a:
        {
            bitmask = RRM_BANDWIDTH_CLASS_A;
            break;
        }
        case rrm_bw_b:
        {
            bitmask = RRM_BANDWIDTH_CLASS_B;
            break;
        }
        case rrm_bw_c:
        {
            bitmask = RRM_BANDWIDTH_CLASS_C;
            break;
        }    
        case rrm_bw_d:
        {
            bitmask = RRM_BANDWIDTH_CLASS_D;
            break;
        }    
        case rrm_bw_e:
        {
            bitmask = RRM_BANDWIDTH_CLASS_E;
            break;
        }
        case rrm_bw_f:
        {
            bitmask = RRM_BANDWIDTH_CLASS_F;
            break;
        }   
        default:
        {
            /*error*/
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Wrong bandwidth class = %d is passed as argument in function ",bandwidth_class);
        }
    }

    RRM_UT_TRACE_EXIT();
    return bitmask;
}


/****************************************************************************
 * Function Name  : rrm_get_bitmask_correspoding_bandwidth
 * Inputs         : rrm_oam_band_width_et cell_bandwidth
 * Outputs        : returns the corresponding bitmask value of bandwidth
 * Returns        : U8
 * Description    : This function returns the bitmask corresponding bandwidth
 ****************************************************************************/
U8
rrm_get_bitmask_correspoding_bandwidth( rrm_oam_band_width_et  cell_bandwidth )
{
    U8 bitmask = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    switch( cell_bandwidth )
    {
        case RRM_OAM_BW_N_6:
        {
            bitmask = RRM_BANDWIDTH_1_4MHZ;
            break;
        }
        case RRM_OAM_BW_N_15:
        {
            bitmask = RRM_BANDWIDTH_3MHZ;
            break;
        }
        case RRM_OAM_BW_N_25:
        {
            bitmask = RRM_BANDWIDTH_5MHZ;
            break;
        }
        case RRM_OAM_BW_N_50:
        {
            bitmask = RRM_BANDWIDTH_10MHZ;
            break;
        }
        case RRM_OAM_BW_N_75:
        {
            bitmask = RRM_BANDWIDTH_15MHZ;
            break;
        }
        case RRM_OAM_BW_N_100:
        {
            bitmask = RRM_BANDWIDTH_20MHZ;
            break;
        }
        default:
        {
            /*error condition*/
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Wrong bandwidth = %d is passed as argument in function ", cell_bandwidth );
        }
    }

    RRM_UT_TRACE_EXIT();
    return bitmask;
}

/****************************************************************************
 * Function Name  : rrm_calculate_intra_band_cont_offset 
 * Inputs         : Pointer to the band array of intra band table
 * Outputs        : return the calculated offset for intra band table 
 * Returns        : U16
 * Description    : This function constructs the Interface header
 ****************************************************************************/
U16
rrm_calculate_intra_band_cont_offset( U8  *p_pband )
{
     U16  offset = RRM_ZERO;
     U8   num_of_comb = RRM_ZERO;

     RRM_UT_TRACE_ENTER();

     num_of_comb = p_pband[RRM_THREE];

    /* offset = sizeof(band) + sizeof(class) + sizeof(num_of_comb) + (num_of_comb * 2) */
     offset = RRM_FOUR  + (num_of_comb * RRM_TWO) ;

     RRM_UT_TRACE_EXIT();

     return offset;
}


/****************************************************************************
 * Function Name  : rrm_create_ca_intra_band_contigious_table_index 
 * Inputs         : Pointer to rrm_global_context_t
 * Outputs        : 
 * Returns        : void
 * Description    : This function create the indexes of intra band ca table
                    and store the indexes in global context to be accessed
                    by all cells
 ****************************************************************************/
rrm_void_t
rrm_create_ca_intra_band_contigious_table_index(
                              rrm_global_context_t    *p_cell_gb_context )
{
	U8                          i = RRM_ZERO;
    U16                         offset = RRM_ZERO;
    U8                          *p_band = RRM_NULL;
    U8                          num_of_band_arr = rrm_ca_intra_band_contigious_table[RRM_ZERO];
    rrm_intra_band_contigious_table_t     
                                *p_intra_band_cont_tb = RRM_NULL;
   
    RRM_UT_TRACE_ENTER();

    p_intra_band_cont_tb = &(p_cell_gb_context->rrm_ca_band_table.rrm_inta_band_cont_tb );

    /* allocate the memory */
	p_intra_band_cont_tb->ptr_band = 
                       (rrm_intra_band_t *)rrm_mem_get(num_of_band_arr  * sizeof(rrm_intra_band_t));

    /* assert if memory allocation is failed */
    RRM_ASSERT( RRM_PNULL != p_intra_band_cont_tb->ptr_band );
  
    /* Coverity 93945 Fix Start */
    if ( RRM_PNULL == p_intra_band_cont_tb->ptr_band )
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_intra_band_cont_tb->ptr_band failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return;
    }
    /* Coverity 93945 Fix end */
    p_band = &rrm_ca_intra_band_contigious_table[RRM_ONE];

    p_intra_band_cont_tb->num_of_band = num_of_band_arr;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
    "Number of band combination = %d in Intra Band Table  ",num_of_band_arr );

    for( i = RRM_ZERO ; i < num_of_band_arr ; i++ )
    {
        /* Intra band table { 1->[band] , 2->[class] , 3->[num_of_bandwidth_comb] , 4->[bandwith_combination_array]}*/
        p_intra_band_cont_tb->ptr_band[i].band = p_band[RRM_ZERO];
        p_intra_band_cont_tb->ptr_band[i].bandwidth_class = p_band[RRM_ONE];
        p_intra_band_cont_tb->ptr_band[i].bandwidth_comb_set = p_band[RRM_TWO];
        p_intra_band_cont_tb->ptr_band[i].num_of_bw_combination = p_band[RRM_THREE];
        p_intra_band_cont_tb->ptr_band[i].bandwidth_combination_tbl = &p_band[RRM_FOUR];

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "Number of bandwidth combination = %d for Band = %d , Bandwidth class = %d at index = %d",
        p_intra_band_cont_tb->ptr_band[i].num_of_bw_combination, p_intra_band_cont_tb->ptr_band[i].band,
        p_intra_band_cont_tb->ptr_band[i].bandwidth_class, i );

        /* fucntion specify the current table size offset */
        offset = rrm_calculate_intra_band_cont_offset( p_band );
        p_band += offset ;
          
    }

    RRM_UT_TRACE_EXIT();
}


/**********************************************************************************
 * Function Name  : rrm_find_entry_of_carrier_component_in_ca_intra_band_cont_table
 * Inputs         : band ,cc_1_bandwidth, cc_2_bandwidth  
 * Outputs        : p_carrier_bw_class , p_combination_set 
 * Returns        : S8
 * Description    : This function finds the entry in table for intra band 
                    and cc 1 bw and scell bandwidth combination
 **********************************************************************************/
S8
rrm_find_entry_of_carrier_component_in_ca_intra_band_cont_table( U8                    band,
                                                                 rrm_oam_band_width_et cc_1_bandwidth,
                                                                 rrm_oam_band_width_et cc_2_bandwidth,
                                                                 U8                    *p_carrier_bw_class,
                                                                 U32                   *p_combination_set)
{
    S8                                 found = RRM_MINUS_ONE;
    U8                                 i = RRM_ZERO;
    U8                                 j = RRM_ONE;
    U8                                 k = RRM_ZERO;
    rrm_intra_band_contigious_table_t  *p_inta_band_cont_tb = RRM_NULL;
    U8                                 *p_bandwidth_comb = RRM_NULL;
    U8                                  bandwidth_com_set = RRM_ZERO;
    U8                                  cc_1_bw_bitmask = rrm_get_bitmask_correspoding_bandwidth(cc_1_bandwidth); 
    U8                                  cc_2_bw_bitmask = rrm_get_bitmask_correspoding_bandwidth(cc_2_bandwidth);

    RRM_UT_TRACE_ENTER();

    /*Initializing the bitmask */
    *p_combination_set = RRM_ZERO;

    p_inta_band_cont_tb = &(p_g_rrm_cell_ctx->rrm_ca_band_table.rrm_inta_band_cont_tb );

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
    "Number of band combination = %d in Intra Band Table  ",p_inta_band_cont_tb->num_of_band );

    for( i = RRM_ZERO ; i < p_inta_band_cont_tb->num_of_band ; i++ )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "Band value = %d at index = %d of Intra band Table",
        p_inta_band_cont_tb->ptr_band[i].band , i );

        /*first match the band value in table */
        if ( band == p_inta_band_cont_tb->ptr_band[i].band )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Band = %d is matched at index = %d ",p_inta_band_cont_tb->ptr_band[i].band , i );

            /*bandwidth class */
            *p_carrier_bw_class = p_inta_band_cont_tb->ptr_band[i].bandwidth_class;
            bandwidth_com_set = p_inta_band_cont_tb->ptr_band[i].bandwidth_comb_set;

            
            /* this loop for number of bandwidth combination set */
            for( j = RRM_ONE; j <= bandwidth_com_set; j++ )
            {

                /* assign the very first entry of bands bandwidth combination array */
                p_bandwidth_comb = p_inta_band_cont_tb->ptr_band[i].bandwidth_combination_tbl ;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                " Number of Bandwidth combination  = %d at index = %d ",
                p_inta_band_cont_tb->ptr_band[i].num_of_bw_combination , i );

                /* run the loop for num_of_bandwidth_combination for matched band */
                for( k = RRM_ZERO; k < p_inta_band_cont_tb->ptr_band[i].num_of_bw_combination; k++ )
                {
                    /* matched the bandwidth combination for pcell and scell */
                    if( ((p_bandwidth_comb[RRM_ZERO]) & cc_1_bw_bitmask ) &&
                        ((p_bandwidth_comb[RRM_ONE]) & cc_2_bw_bitmask ) )
                    {

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Pcell bandwidth =%d , Scell bandwidth = %d combination is found at index = %d",
                        p_bandwidth_comb[RRM_ZERO] , p_bandwidth_comb[RRM_ONE] , i );

                        found = RRM_ONE ;
                        /*bandwidth combination set bitmask */
                        *p_combination_set |= (found << (RRM_THIRTY_TWO - j));
                        break;
                    }
                    p_bandwidth_comb += RRM_TWO;
                    
                }

            }  
           /*break the loop if band is found in table: because
             intra band table can not have multiple entry for same band
             according to specification 36.101 table 5.6A.1-1. but in 
             future Table can have multiple entry of band with combination
             of different class value. in that case we should remove the
             break statement to find the entry in different row*/
            break;

        }
    }

    RRM_UT_TRACE_EXIT();

    return found;
}



/********************************************************************************
 * Function Name  : rrm_find_entry_of_carrier_component_in_ca_inter_band_table
 * Inputs         : carrier_1 , carrier_2 , cc_1_bandwidth , cc_2_bandwidth
 * Outputs        : Out Params p_carrier_1_bw_class , p_carrier_2_bw_class
                    bandwidth_comb_set and returns non zero value if entry is found 
 * Returns        : S8
 * Description    : This function returns the non zero value if entry is found 
                    in interband table of CA
 ********************************************************************************/
S8
rrm_find_entry_of_carrier_component_in_ca_inter_band_table( U8                    carrier_1, 
                                                            U8                    carrier_2,
                                                            rrm_oam_band_width_et cc_1_bandwidth,
                                                            rrm_oam_band_width_et cc_2_bandwidth,
                                                            U8                    *p_carrier_1_bw_class,
                                                            U8                    *p_carrier_2_bw_class,
                                                            U32                   *bandwidth_comb_set)
{
    rrm_interband_table_t    *ptr_inter_band_tb = RRM_NULL;
    U8                        no_of_pband = RRM_ZERO;
    U8                        index = RRM_ZERO;
    U8                       *sband_table = RRM_NULL;
    S8                        found_set = RRM_MINUS_ONE;
    U8                        cc_1_bandwidth_mask = RRM_ZERO;
    U8                        cc_2_bandwidth_mask = RRM_ZERO;
    U8                        i = RRM_ONE;
    
    RRM_UT_TRACE_ENTER();

    ptr_inter_band_tb = &(p_g_rrm_cell_ctx->rrm_ca_band_table.rrm_inter_band_tb);

    /*get the bandwith bitmask for each cc's */
    cc_1_bandwidth_mask = rrm_get_bitmask_correspoding_bandwidth( cc_1_bandwidth );
    cc_2_bandwidth_mask = rrm_get_bitmask_correspoding_bandwidth( cc_2_bandwidth );

    /* number of combination  */
    no_of_pband = ptr_inter_band_tb->num;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
    "Number of Band combination = %d ", ptr_inter_band_tb->num );
    /* iterate the loop for number of band are kept in row in acsending order
       every combination should be searched in table in acesnding order form*/
    for( index = RRM_ZERO ; index < no_of_pband; index++ )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "Carrier X = %d at index = %d of Table",*(ptr_inter_band_tb->ptr_band[index].band), index);

        /* match the carrier 1 in ascending order in Table */
        if ( carrier_1 == *(ptr_inter_band_tb->ptr_band[index].band) )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Carrier 1 = %d is matched at index = %d of Table",*(ptr_inter_band_tb->ptr_band[index].band), index);

            /* get for carrier_2 band info in table */
            sband_table = rrm_get_matched_sband_info( &(ptr_inter_band_tb->ptr_band[index]) ,carrier_2 );

            if( RRM_NULL == sband_table )
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Carrier 2 band = %d match is not found in sub table at index = %d of Table",
                carrier_2 , index );

                break;
            }     
            
            *p_carrier_1_bw_class = ptr_inter_band_tb->ptr_band[index].band[RRM_ONE];
            *p_carrier_2_bw_class = sband_table[RRM_ONE];
            /* bitmask intialization */
            *bandwidth_comb_set = RRM_ZERO;

            /* now check the bandwidth combination of carrier 1 & carrier 2 
               and check this bandwidth combination on bandset value
               provided by UE capability */
             
             /* sub tables 2nd onwards entry contains the bandwidth bitmask for pcell and scell */
             /* sub table position -> {  0->[band] , 1->[combination set] , 2->[bandwidth bitmask pair],4->[optional] }*/
             while( i <= sband_table[RRM_TWO] )
             {
                 if( ( sband_table[(i*RRM_TWO)+RRM_ONE] & cc_1_bandwidth_mask ) && 
                     ( sband_table[(i*RRM_TWO)+RRM_TWO] & cc_2_bandwidth_mask ) )
                 {
                    
                     found_set = RRM_ONE;

                     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                     "Bandwidth combination for both Carrier is found at combination set ZERO");

                     *bandwidth_comb_set |= ( found_set << ( RRM_THIRTY_TWO - i  ));


                 }
                 i++;

             }

             break;
        }
    }

    RRM_UT_TRACE_EXIT();

    return found_set;
}


/****************************************************************************
 * Function Name  : rrm_calculate_intra_band_non_contigious_offset
 * Inputs         : U8 *p_band
 * Outputs        : Returns the calculated offset values
 * Returns        : U16
 * Description    : This function retuns the next bandwith class & combination 
                    in intraband table of CA
 ****************************************************************************/
U16
rrm_calculate_intra_band_non_contigious_offset( U8 *p_band )
{

    U16  offset = RRM_ZERO;
    U8   bandwidth_comb_set = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    bandwidth_comb_set = p_band[RRM_THREE];

    offset = RRM_FOUR + ( bandwidth_comb_set * RRM_TWO ) ;

    RRM_UT_TRACE_EXIT();

    return offset;
}


/****************************************************************************
 * Function Name  : rrm_function_create_intra_band_non_contigious_index
 * Inputs         : p_cell_gb_context
 * Outputs        : rrm_void_t 
 * Returns        : rrm_void_t
 * Description    : This function create the indexes of intra band non contigious 
                    table of CA
 ****************************************************************************/
rrm_void_t
rrm_function_create_intra_band_non_contigious_index( rrm_global_context_t    *p_cell_gb_context )
{
    U8                                  i = RRM_ZERO;
    U16                                 offset = RRM_ZERO;
    U8                                  num_of_comb = rrm_ca_intra_band_non_contigious_table[RRM_ZERO];
    U8                                 *p_band = RRM_NULL;
    rrm_intra_non_contigious_table_t   *p_intra_band_non_conti = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_intra_band_non_conti = &(p_cell_gb_context->rrm_ca_band_table.rrm_intra_band_non_cont_tb);

       /* allocate the memory */
    p_intra_band_non_conti->p_intra_non_cont_band =
                            (rrm_intra_non_conti_band_t *)rrm_mem_get(num_of_comb  * sizeof(rrm_intra_non_conti_band_t));

    /* Coverity 93967 Fix Start */
    if ( RRM_PNULL == p_intra_band_non_conti->p_intra_non_cont_band )
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_intra_band_non_conti->p_intra_non_cont_band failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return;
    }
    /* Coverity 93967 Fix end */
    /* assert if memory allocation is failed */
    RRM_ASSERT( RRM_PNULL != p_intra_band_non_conti->p_intra_non_cont_band );

    /* num of band array in row */
    p_intra_band_non_conti->number_of_combination = num_of_comb;
   
	p_band = &(rrm_ca_intra_band_non_contigious_table[RRM_ONE]);

    for( i = RRM_ZERO ; i < num_of_comb ; i++ )
    {
        /* Intra band table { 1->[band] , 2,3->[class] , 4->[bandwidth_comb_set] , 5->[bandwith_combination_array]}*/
        p_intra_band_non_conti->p_intra_non_cont_band[i].band = p_band[RRM_ZERO];
        p_intra_band_non_conti->p_intra_non_cont_band[i].bandwidth_class[RRM_ZERO] = p_band[RRM_ONE];
        p_intra_band_non_conti->p_intra_non_cont_band[i].bandwidth_class[RRM_ONE] = p_band[RRM_TWO];
        p_intra_band_non_conti->p_intra_non_cont_band[i].bandwidth_combination_set = p_band[RRM_THREE];
        p_intra_band_non_conti->p_intra_non_cont_band[i].bandwidth_combination_tbl = &p_band[RRM_FOUR];

        /* fucntion specify the current table size offset */
        offset = rrm_calculate_intra_band_non_contigious_offset( p_band );
        p_band += offset ;
          
    }
    RRM_UT_TRACE_EXIT();
}



/*****************************************************************************
 * Function Name  : rrm_find_intra_band_non_contigious_entry
 * Inputs         : band,cc_1_bandwidth,cc_2_bandwidth
 * Outputs        : carrier_1_bw_class, carrier_2_bw_class, bandwidth_comb_set
 * Returns        : S8
 * Description    : This function retuns the positive value if entry is found 
                    in intraband table of CA
 ****************************************************************************/
S8
rrm_find_intra_band_non_contigious_entry( U8                    band,
                                          rrm_oam_band_width_et cc_1_bandwidth,
                                          rrm_oam_band_width_et cc_2_bandwidth,
                                          U8                    *carrier_1_bw_class ,
                                          U8                    *carrier_2_bw_class ,
                                          U32                   *bandwidth_comb_set )
{

    rrm_intra_non_contigious_table_t       *p_intra_band_non_conti_tb = RRM_NULL;
    U8                                      num_of_comb = RRM_ZERO;
    U8                                      i = RRM_ZERO;
    S8                                      found_set = RRM_MINUS_ONE;
    U8                                      cc_1_bandwidth_bitmask = rrm_get_bitmask_correspoding_bandwidth(cc_1_bandwidth );
    U8                                      cc_2_bandwidth_bitmask = rrm_get_bitmask_correspoding_bandwidth(cc_2_bandwidth );
    U8                                      j = RRM_ONE;
    U8                                      band_comb_set = RRM_ZERO;

    /* intialize the bandwidth combination ste bitmask by zero */
    *bandwidth_comb_set = RRM_ZERO;

    p_intra_band_non_conti_tb = &(p_g_rrm_cell_ctx->rrm_ca_band_table.rrm_intra_band_non_cont_tb );

    num_of_comb = p_intra_band_non_conti_tb->number_of_combination;

    for( i = RRM_ZERO; i < num_of_comb ; i++ )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
        "Band value = %d at index = %d ",p_intra_band_non_conti_tb->p_intra_non_cont_band[i].band, i );

        if( p_intra_band_non_conti_tb->p_intra_non_cont_band[i].band == band )
        {
            band_comb_set = p_intra_band_non_conti_tb->p_intra_non_cont_band[i].bandwidth_combination_set;

            *carrier_1_bw_class =  p_intra_band_non_conti_tb->p_intra_non_cont_band[i].bandwidth_class[RRM_ZERO];
            *carrier_2_bw_class =  p_intra_band_non_conti_tb->p_intra_non_cont_band[i].bandwidth_class[RRM_ONE];

            while( j <= band_comb_set )
            {
                if( ( p_intra_band_non_conti_tb->p_intra_non_cont_band[i].
                      bandwidth_combination_tbl[RRM_ZERO] & cc_1_bandwidth_bitmask ) &&
                    ( p_intra_band_non_conti_tb->p_intra_non_cont_band[i].
                      bandwidth_combination_tbl[RRM_ONE] & cc_2_bandwidth_bitmask) )
                {
                    found_set = RRM_ONE;

                    *bandwidth_comb_set |= ( found_set << ( RRM_THIRTY_TWO - j  ));
                }
                j++;
            }

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Bandwidth combiantion is found  value = %d, bandwidth comb set = %u ",
            found_set , *bandwidth_comb_set );

            break;
        }
    }

    RRM_UT_TRACE_EXIT();

    return found_set;

}


/*fucntion will be updated later on */
/****************************************************************************
 * Function Name  : rrm_is_band_intra_contigious 
 * Inputs         : 
 * Outputs        : one 
 * Returns        : rrm_bool_et
 * Description    : This function retuns the band contigious 
 ****************************************************************************/
rrm_bool_et
rrm_is_band_intra_contigious( rrm_cell_context_t *p_carrier_1_cell_ctxt,
                              rrm_cell_context_t *p_carrier_2_cell_ctxt )
{
   U32 		           dl_earfcn_cc1 = p_carrier_1_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
   U32 		           dl_earfcn_cc2 = p_carrier_2_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;
   rrm_oam_band_width_et   dl_bw_cc_1 = p_carrier_1_cell_ctxt->ran_info.rf_params.rf_configurations.dl_bandwidth;
   rrm_oam_band_width_et   dl_bw_cc_2 = p_carrier_2_cell_ctxt->ran_info.rf_params.rf_configurations.dl_bandwidth;
   rrm_bool_et             ret_val = RRM_FALSE;
   U8                   five_times_combined_bandwidth = RRM_ZERO;
   U8                   cell_index = RRM_ZERO;
   U8                   dl_bandwidth = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    if( p_carrier_1_cell_ctxt->ran_info.rf_params.rf_configurations.frequency_band_indicator ==
        p_carrier_2_cell_ctxt->ran_info.rf_params.rf_configurations.frequency_band_indicator ) 
    {
        /* CCs are contiguous if (0.1)*(earfcn1-earfcn2) = (bw1+bw2)/2
         * To avoid floating calculation, the above equation can be re-written
         * as: earfcn1-earfcn2 = 5*(bw1+bw2)
         */
        
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Cell%d:DL_BW[%d], Cell%d:DL_BW[%d]",
                 p_carrier_1_cell_ctxt->cell_index, dl_bw_cc_1,
                 p_carrier_2_cell_ctxt->cell_index, dl_bw_cc_2);
        dl_bandwidth = dl_bw_cc_1;
        for(cell_index = RRM_ZERO; cell_index < RRM_TWO; cell_index++)
        {
            switch(dl_bandwidth)
            {
                case RRM_OAM_BW_N_6:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(1.4);
                    break;
                case RRM_OAM_BW_N_15:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(3);
                    break;
                case RRM_OAM_BW_N_25:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(5);
                    break;
                case RRM_OAM_BW_N_50:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(10);
                    break;
                case RRM_OAM_BW_N_75:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(15);
                    break;
                case RRM_OAM_BW_N_100:
                    five_times_combined_bandwidth =
                        five_times_combined_bandwidth + RRM_FIVE*(20);
                    break;
            }
            dl_bandwidth = dl_bw_cc_2;
        }

        if(dl_earfcn_cc1 == dl_earfcn_cc2 )
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
            "Bandwidth are not contigious for two cells. Cell%d:Earfcn[%d], Cell%d:Earfcn[%d]",
            p_carrier_1_cell_ctxt->cell_index, dl_earfcn_cc1, p_carrier_2_cell_ctxt->cell_index, dl_earfcn_cc2);
            /* SPR 21251 End */

            ret_val = RRM_FALSE;
        }
        else if (dl_earfcn_cc1 > dl_earfcn_cc2 )
        {
        /*SPR 17239 start*/
            if(((dl_earfcn_cc1 - dl_earfcn_cc2)  <= five_times_combined_bandwidth)
                && (RRM_ZERO == (dl_earfcn_cc1 - dl_earfcn_cc2 )% RRM_THREE ))
        /*SPR 17239 end*/
	        {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Bandwidth are contigious for two cells cell index %d, cell index = %d ",
                p_carrier_1_cell_ctxt->cell_index, p_carrier_2_cell_ctxt->cell_index );
                ret_val = RRM_TRUE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Bandwidth are not contigious for two cells. Cell%d:Earfcn[%d], Cell%d:Earfcn[%d]",
                        p_carrier_1_cell_ctxt->cell_index, dl_earfcn_cc1,
                        p_carrier_2_cell_ctxt->cell_index, dl_earfcn_cc2);
            }
        }         
        else
        {
        /*SPR 17239 start*/
            if(((dl_earfcn_cc2 - dl_earfcn_cc1)  <= five_times_combined_bandwidth)
                    &&  (RRM_ZERO == (dl_earfcn_cc2 - dl_earfcn_cc1)% RRM_THREE))
            {
        /*SPR 17239 end*/
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Bandwidth are contigious for two cells cell index %d, cell index = %d ",
                p_carrier_1_cell_ctxt->cell_index, p_carrier_2_cell_ctxt->cell_index );

                ret_val = RRM_TRUE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Bandwidth are not contigious for two cells. Cell%d:Earfcn[%d], Cell%d:Earfcn[%d]",
                p_carrier_1_cell_ctxt->cell_index, dl_earfcn_cc1,
                p_carrier_2_cell_ctxt->cell_index, dl_earfcn_cc2);
            }
        }
 
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Bandwidth indicator are not same for two cells. Cell%d:BandIndicator[%d], Cell%d:BandIndicator[%d]",
                p_carrier_1_cell_ctxt->cell_index,
                p_carrier_1_cell_ctxt->ran_info.rf_params.rf_configurations.frequency_band_indicator,
                p_carrier_2_cell_ctxt->cell_index,
                p_carrier_2_cell_ctxt->ran_info.rf_params.rf_configurations.frequency_band_indicator);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val ;
}

/* SPR 13383 changes end */

/****************************************************************************
 *   FUNCTION NAME       :   get_dl_res_block_from_dl_bandwidth
 *
 *   DESCRIPTION :
 *       This function will calculate the value of dl_res_blocks from 
 *		dl_bandwidth
 *
 *   RETURNS     :
 *       U8 value
 *****************************************************************************/
U8
get_dl_res_block_from_dl_bandwidth
(
 rrm_cell_context_t *p_cell_context
 )
{
    U8           value = RRM_ZERO;
#ifdef TDD_MODE_FLAG
    U8 num_dl_schedulable = RRM_ZERO;
#endif
    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            value = RRM_BW_N6;
            break;
        case RRM_OAM_BW_N_15:
            value = RRM_BW_N15;
            break;
        case RRM_OAM_BW_N_25:
            value = RRM_BW_N25;
            break;
        case RRM_OAM_BW_N_50:
            value = RRM_BW_N50;
            break;
        case RRM_OAM_BW_N_75:
            value = RRM_BW_N75;
            break;
        case RRM_OAM_BW_N_100:
            value = RRM_BW_N100;
            break;
        default :
            value = p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " dl_bandwith = %u",
                    p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth);
            break;
    }

#ifdef TDD_MODE_FLAG
    num_dl_schedulable = num_dl_ul_scdeulable[p_cell_context->ran_info.physical_layer_params.\
                         physical_layer_param_tdd_frame_structure.sub_frame_assignment][p_cell_context->ran_info.physical_layer_params.\
                         physical_layer_param_tdd_frame_structure.special_sub_frame_patterns].num_dl_schedulable; 
    value = (value * num_dl_schedulable) / SUBFRAMES_IN_ONE_FRAME; 

#endif

    RRM_UT_TRACE_EXIT();
    return value;
}

/****************************************************************************
 *   FUNCTION NAME       :   get_ul_res_block_from_ul_bandwidth
 *   INPUT       : cell_context
 *   OUTPUT      : 
 *   DESCRIPTION :
 *       This function will calculate the value of ul_res_blocks from
 *       ul_bandwidth
 *
 *   RETURNS     :
 *       RRM_SUCCESS     on Success.
 *       RRM_FAILURE     on Failure.
 *****************************************************************************/
U8
get_ul_res_block_from_ul_bandwidth
(
 rrm_cell_context_t *p_cell_context
 )
{
    U8          value = RRM_ZERO;
#ifdef TDD_MODE_FLAG
    U8 num_ul_schedulable = RRM_ZERO;
#endif

    RRM_UT_TRACE_ENTER();

    switch(p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            value = RRM_BW_N6;
            break;
        case RRM_OAM_BW_N_15:
            value = RRM_BW_N15;
            break;
        case RRM_OAM_BW_N_25:
            value = RRM_BW_N25;
            break;
        case RRM_OAM_BW_N_50:
            value = RRM_BW_N50;
            break;
        case RRM_OAM_BW_N_75:
            value = RRM_BW_N75;
            break;
        case RRM_OAM_BW_N_100:
            value = RRM_BW_N100;
            break;
        default :
            value = p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING, "Incorrect value received for"\
                    " ul_bandwith = %u",
                    p_cell_context->ran_info.rf_params.rf_configurations.ul_bandwidth);
            break;
    }
#ifdef TDD_MODE_FLAG
    num_ul_schedulable = num_dl_ul_scdeulable[p_cell_context->ran_info.physical_layer_params.\
                         physical_layer_param_tdd_frame_structure.sub_frame_assignment][p_cell_context->ran_info.physical_layer_params.\
                         physical_layer_param_tdd_frame_structure.special_sub_frame_patterns].num_ul_schedulable;

    value = (value * num_ul_schedulable)/ SUBFRAMES_IN_ONE_FRAME; 
#endif

    RRM_UT_TRACE_EXIT();
    return value;
}
/*SPR_12535_FIX_END*/

/*SPR 20856 +-*/
/**CLPC_MR_START*/
/******************************************************************************
 *   FUNCTION NAME:rrm_allocate_tpc_rnti_table_pucch
 *   DESCRIPTION:
 *        Allocates the tpc rnti alocation table for pucch
 *   RETURNS: rrm_return_et
 *****************************************************************************/
rrm_return_et
rrm_allocate_tpc_rnti_table_pucch(
		rrm_cell_context_t
		*p_rrm_cell_ctx
		)
{
	U16 start_tpc_rnti_pucch = RRM_ZERO;
	U16 end_tpc_rnti_pucch = RRM_ZERO;
	U16 tpc_rnti_range = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	start_tpc_rnti_pucch = p_rrm_cell_ctx->operator_info.
		rrm_mac_config.mac_tpc_rnti_range.startTpcRntiPucch;
	end_tpc_rnti_pucch =  p_rrm_cell_ctx->operator_info.
		rrm_mac_config.mac_tpc_rnti_range.endTpcRntiPucch;
	tpc_rnti_range = (end_tpc_rnti_pucch - start_tpc_rnti_pucch)+RRM_ONE;

	/* Allocate number of rows in the pusch table
	 * depending upon configured pusch tpc rnti range.
	 * Each row pointer will be allocated
	 * during tpc rnti allocation procedure
	 */
	p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch =
		(rrm_ue_tpc_rnti_row_pucch_t**)
		rrm_mem_get(sizeof(rrm_ue_tpc_rnti_row_pucch_t *)*tpc_rnti_range);
    if ( p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pucch.num_of_row = RRM_ZERO;
	RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS; /* Coverity: CID 58746 */
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME:rrm_assign_num_tpc_id_dci_3_3a
 *   DESCRIPTION:
 *        determines num tpc id depending upon bw
 *   RETURNS:
 *      void
 *****************************************************************************/
void
rrm_assign_num_tpc_id_dci_3_3a_tdd(rrm_cell_context_t    *p_rrm_cell_ctx ,
                                   U8                    *num_tpc_id_dci_3 ,
                                   U8                    *num_tpc_id_dci_3a)
{
    RRM_UT_TRACE_ENTER();
    switch(p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            *num_tpc_id_dci_3 =11;
            *num_tpc_id_dci_3a =23;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        case RRM_OAM_BW_N_15:
            *num_tpc_id_dci_3 =13;
            *num_tpc_id_dci_3a =25;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        case RRM_OAM_BW_N_25:
            *num_tpc_id_dci_3 =13;
            *num_tpc_id_dci_3a =27;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        case RRM_OAM_BW_N_50:
            *num_tpc_id_dci_3 =15;
            *num_tpc_id_dci_3a =29;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        case RRM_OAM_BW_N_75:
            *num_tpc_id_dci_3 =15;
            *num_tpc_id_dci_3a =30;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        case RRM_OAM_BW_N_100:
            *num_tpc_id_dci_3 =15;
            *num_tpc_id_dci_3a =31;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
            break;
        default:
            *num_tpc_id_dci_3 =15;
            *num_tpc_id_dci_3a =31;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                    RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                    "num_tpc_id_dci_3=%d",*num_tpc_id_dci_3a,*num_tpc_id_dci_3);
    }
    RRM_UT_TRACE_EXIT();
}        
/*Klockwork_fix_end*/
/*Start:SPR 8715*/
/******************************************************************************
 *   FUNCTION NAME:rrm_assign_num_tpc_id_dci_3_3a
 *   DESCRIPTION:
 *        determines num tpc id depending upon bw
 *   RETURNS:
 *      void
 *****************************************************************************/
void
rrm_assign_num_tpc_id_dci_3_3a(
   rrm_cell_context_t *p_rrm_cell_ctx
)
{
    RRM_UT_TRACE_ENTER();
    U8 num_tpc_id_dci_3a = RRM_ZERO;
    U8 num_tpc_id_dci_3 = RRM_ZERO;
#ifdef TDD_MODE_FLAG

    /*Klockwork_fix_start*/
    rrm_assign_num_tpc_id_dci_3_3a_tdd(p_rrm_cell_ctx ,
                                       &num_tpc_id_dci_3,
                                       &num_tpc_id_dci_3a);
    /*Klockwork_fix_end*/

#else
    switch(p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
             num_tpc_id_dci_3 =10;
             num_tpc_id_dci_3a =21;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        case RRM_OAM_BW_N_15:
             num_tpc_id_dci_3 =11;
             num_tpc_id_dci_3a =22;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        case RRM_OAM_BW_N_25:
             num_tpc_id_dci_3 =12;
             num_tpc_id_dci_3a =25;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        case RRM_OAM_BW_N_50:
             num_tpc_id_dci_3 =13;
             num_tpc_id_dci_3a =27;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        case RRM_OAM_BW_N_75:
             num_tpc_id_dci_3 =13;
             num_tpc_id_dci_3a =27;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        case RRM_OAM_BW_N_100:
             num_tpc_id_dci_3 =14;
             num_tpc_id_dci_3a =28;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
        break;
        default:
             num_tpc_id_dci_3 =14;
             num_tpc_id_dci_3a =28;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                     RRM_DETAILED,"allocated num_tpc_id_dci_3a=%d, "
                     "num_tpc_id_dci_3=%d",num_tpc_id_dci_3a,num_tpc_id_dci_3);
    }
#endif
    p_rrm_cell_ctx->num_tpc_id_dci_3=num_tpc_id_dci_3;
    p_rrm_cell_ctx->num_tpc_id_dci_3a=num_tpc_id_dci_3a;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
              RRM_DETAILED,"In cell context num_tpc_id_dci_3a=%d, "
              "num_tpc_id_dci_3=%d",p_rrm_cell_ctx->num_tpc_id_dci_3a,
              p_rrm_cell_ctx->num_tpc_id_dci_3);
    RRM_UT_TRACE_EXIT();
}
/*End:SPR 8715*/

/******************************************************************************
 *   FUNCTION NAME:rrm_allocate_tpc_rnti_table_pusch
 *   DESCRIPTION:
 *        Allocates the tpc rnti alocation table for pusch
 *   RETURNS: rrm_return_et
 *****************************************************************************/
rrm_return_et
rrm_allocate_tpc_rnti_table_pusch(
		rrm_cell_context_t
		*p_rrm_cell_ctx
		)
{
	U16 start_tpc_rnti_pusch = RRM_ZERO;
	U16 end_tpc_rnti_pusch = RRM_ZERO;
	U16 tpc_rnti_range_pusch = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	start_tpc_rnti_pusch = p_rrm_cell_ctx->operator_info.
		rrm_mac_config.mac_tpc_rnti_range.startTpcRntiPusch;
	end_tpc_rnti_pusch =  p_rrm_cell_ctx->operator_info.
		rrm_mac_config.mac_tpc_rnti_range.endTpcRntiPusch;
	tpc_rnti_range_pusch = (end_tpc_rnti_pusch - start_tpc_rnti_pusch)+RRM_ONE;

	/* Allocate number of rows in the pusch table 
	 * depending upon configured pusch tpc rnti range.
	 * Each row pointer will be allocated  
	 * during tpc rnti allocation procedure
	 */
	p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch =
		(rrm_ue_tpc_rnti_row_pusch_t**)
		rrm_mem_get(sizeof(rrm_ue_tpc_rnti_row_pusch_t*)* tpc_rnti_range_pusch);
    if ( p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	p_rrm_cell_ctx->rrm_ue_tpc_rnti_tbl_pusch.num_of_row = RRM_ZERO;
	RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS; /* Coverity: CID 58747 */
}
/**CLPC_MR_END*/
/**************************************************************************
 * Function Name  : rrm_rrc_cell_setup_resp_process_msg
 * Inputs         : p_api_buf , api_id, msg_size, rrm_global_context_t *
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 **************************************************************************/

rrm_return_et
rrm_rrc_cell_setup_resp_process_msg
(
 U8 *p_api, /*pointer to input API buffer*/
 U16 api_id, /*Api id*/
 U16 data_len,/*length of data*/
 U16 trans_id /*transaction id*/
 )
{
	S32	length = RRM_ZERO;
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_FAILURE;
	rrc_rrm_cell_setup_resp_t 	*p_rrc_cell_setup_resp = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	p_rrc_cell_setup_resp = (rrc_rrm_cell_setup_resp_t *)rrm_mem_get(sizeof
			(rrc_rrm_cell_setup_resp_t));
    if (p_rrc_cell_setup_resp == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_cell_setup_resp failed" );
        /* SPR 21251 End */
                /* SPR 13040 fix: Removed */
        /*De allocate trans_id */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_cell_setup_resp(
				p_rrc_cell_setup_resp,
				p_api,
				data_len,
				&length))
	{
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	      	    "RRC->RRM:RRC_RRM_CELL_SETUP_RESP unable to parse");
		ret_val = RRM_FAILURE;
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_setup_resp_F);
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_setup_resp_F_parse_err);
#endif        
	}
	else
	{
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
	      	    "RRC->RRM:RRC_RRM_CELL_SETUP_RESP:[CELL:%d] with response: %d",
                p_rrc_cell_setup_resp->cell_index, p_rrc_cell_setup_resp->response);
		cell_index =  p_rrc_cell_setup_resp->cell_index; 

		RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
		if (RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
		{
            /* SPR 21251 Start */
		    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Cell Context not found for Cell Index :%d",
				cell_index);
            /* SPR 21251 End */
            /* COVERITY : RESOURCE LEAK : CID : 54346 fix start*/
            RRM_MEM_FREE(p_rrc_cell_setup_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54346 fix end*/
            /* BUG_11576_FIX_START */
            /*De allocate trans_id */
            /* SPR 13040 fix: Removed */
            RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
			(void *)p_rrc_cell_setup_resp;
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = RRC_RRM_CELL_SETUP_RESP;  
/* SPR 11681 Fix Start */
/* Code Deleted */
/* SPR 11681 Fix ENd */
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;

			if (RRM_SUCCESS == cellm_fsm_process_event(
						RRC_RRM_CELL_SETUP_RESP_EVENT,
						p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
			{

				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix ENd */
	}
	if((RRM_FAILURE == ret_val)&& (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
				cell_reconfig_deletion_required == RRM_FALSE))
	{
		RRM_MEM_FREE(p_rrc_cell_setup_resp);

		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info 
			= RRM_PNULL;
/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */
		RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]= RRM_PNULL;
		/*SPR 17777 +-*/
	}
	else
	{
		RRM_MEM_FREE(p_rrc_cell_setup_resp);
/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info 
			= RRM_PNULL;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}




/****************************************************************************
 * Function Name  : rrm_cellm_init_cell_context
 * Inputs         : rrm_global_context_t *p_g_rrm_cell_ctx, :global context
 *	              : rrm_cell_index_t cell_index  : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : Initialises the cell context cell_resource 
 *                : and other parameters
 ****************************************************************************/

rrm_void_t 
rrm_cellm_init_cell_context(
		rrm_cell_index_t 	cell_index /*cell index*/
		)
{

	RRM_UT_TRACE_ENTER();

    U8                          prb_count = RRM_ZERO;
    U8                          sample_count = RRM_ZERO;
    /* CSR_00077458_CHANGES_START */
    U16                         index =  RRM_ZERO;
    /* CSR_00077458_CHANGES_END */
    U8                          scell_list_count = RRM_ZERO;
    

	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_index
		= cell_index;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state
		= CELL_STATE_IDLE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_adm_flag = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_reconfig_fail = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_update_fail = RRM_FALSE;
	/* enable_rac_flag: 1 for disable 
	 * UE admission is allowed 
	 */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->enable_rac_flag = RRM_TRUE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->deletion_flag = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->immediate_cell_start = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_adm_flag = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_already_register_es= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_already_register_anr= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
		cell_resource_info.num_active_ue = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_usable_bw_prb_for_bearers = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_usable_bw_prb_for_bearers = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_srb_budget_prb = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_srb_budget_prb = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_prb_budget_gbr_ngnr_combined = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_prb_budget_gbr_ngnr_combined = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_gbr_prb_in_use = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_gbr_prb_in_use = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_ngbr_prb_in_use= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_ngbr_prb_in_use= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_allocated_gbr_prb= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_allocated_gbr_prb= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.dl_allocated_ngbr_prb= RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.ul_allocated_ngbr_prb= RRM_ZERO;
	/*start csg*/
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.admitted_csg_user = RRM_ZERO;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.admitted_non_csg_user = RRM_ZERO;
	/*end csg*/
	rrm_cellm_init_rac_rbc_params(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_reconfig_deletion_required = RRM_FALSE;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = CELLM_PROC_TRIGGERRED_SET_TO_NONE;
	/* UE MEAS CHEANGES : STARTS */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ue_meas_cnt = RRM_ZERO; 
	rrm_cellm_cell_init_meas_context_list(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
	/* MEAS CONFIG REL1.2: START*/
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig = RRM_PNULL;
	/* MEAS CONFIG REL1.2: END*/
	/*X2AP START */
	rrm_cellm_cell_init_x2_enb_list(p_g_rrm_cell_ctx);
	/*X2AP END */
    /* Fix 960 Start */
    rrm_init_tnl_discovery_trans_id_list(p_g_rrm_cell_ctx);
    /* Fix 960 End */
	/* UE MEAS CHEANGES : ENDS */
/* SPR 12387 Fix Start */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sr_data.allocated_sr_perodicity_max_val = RRM_ZERO;
/* SPR 12387 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->allocated_cqi_perodicity_max_val = RRM_ZERO;
	/* SRS Start */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->allocated_srs_max_anchor_val = RRM_ZERO;
	/* SRS End */
	/* SPR 21446 start */
	/* Code removed */
	/* SPR 21446 end */

	/*BUG:102 start*/
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_stop_not_send_active_ue_count = RRM_FALSE;
	/*BUG:102 end*/
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_stop_ongoing_del_ue_ctxt = RRM_FALSE;
	/*ETWS CMAS START*/ 
	rrm_cellm_cell_init_etws_cmas_list(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->pws_substate = PWS_IDLE;
	/*ETWS CMAS END*/ 
    /*DYNAMIC SIB SCHEDULING START*/
    rrm_cellm_init_si_segment_data(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]); 
    /*DYNAMIC SIB SCHEDULING END*/

    /* uplink mu mimo chnage start*/
    /* Coverity_ID : 53593 */
       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ue_mac_reconfig_mutex = MAC_UE_RECONF_NOT_ONGOING;
    /* uplink mu mimo chnage end */

    /*SPR 5676 Fix Start*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->system_info_tag_counter = RRM_ZERO;
    /* SPR 17728 Fix Start */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->system_info_tag_counter = RRM_THIRTY_ONE;
    /* SPR 17728 Fix End */
    /* DYNAMIC ICIC CHANGES START */
    /*
    ** Initialize the Dynamic ICIC related data in cell context
    */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.pdsch_config_params.
                pdsch_common_config.ref_sig_powr_ramping_step = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.pdsch_config_params.
               pdsch_dedicated_config.p_a_ramping_step = RRM_ZERO;
    
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_edge
                                               = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_center
                                               = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_handout_in_olpc
                                               = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_vd_max_p_a_val
                                               = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.cell_reconfigured_for_icic
                                               = RRM_CELLM_REF_SIG_PWR_NOT_UPDATED ;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.cell_reconfig_time_for_icic
                                               = RRM_ZERO;
    /* Location update fix in UE RECONFIG*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.mac_loc_update_triggrd_aftr_ue_reconfig
                                         = RRM_FALSE;

    /*Location update fix in UE RECONFIG*/
    /*SPR 5676 Fix End*/
    /* SPR-12550-fix start */
    /* code deleted */
    /* SPR-12550-fix end */
    for (prb_count = RRM_ZERO; prb_count < RRM_MAX_PRBS_COUNT; prb_count++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
            ul_intf_overload_ind.ul_intf_overload_indication[prb_count] = RRM_ZERO;
    }
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
                            ul_high_interference_info.prb_count = RRM_ZERO;
    for (prb_count = RRM_ZERO; prb_count < RRM_MAX_PRBS_COUNT; prb_count++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
            ul_high_interference_info.hii[prb_count] = RRM_ZERO;
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
                            relative_narrowband_tx_power.prb_count = RRM_ZERO;
    for (prb_count = RRM_ZERO; prb_count < RRM_MAX_PRBS_COUNT; prb_count++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
            relative_narrowband_tx_power.rntp_per_prb[prb_count] = RRM_ZERO;
    }
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.num_ce_samples = RRM_ZERO;
    for (sample_count = RRM_ZERO; sample_count < MAX_NUM_OF_CE_PRB_SAMPLES; sample_count++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->icic_l1_l2_report_info.
            ul_ce_prb_usage_array[sample_count] = RRM_ZERO;
    }
    /* DYNAMIC ICIC CHANGES END */
    /* CSR 00051178 CHANGES START */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sib_present_at_cell_config_time_bitmask = RRM_ZERO;
    /* CSR 00051178 CHANGES END */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sib_present_at_cell_reconfig_time_bitmask = RRM_ZERO; 
    /* RACH_OPTIMIZATION_CHANGES_START */
    RRM_MEMSET(&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_rach_info), 
                RRM_ZERO, sizeof(rrm_cellm_rach_info_t));
    /* RACH_OPTIMIZATION_CHANGES_END */

    /** Dynamic UE Scheduling Start **/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_ue_scheduling_info.bitmask = 0x00;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_dl = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_ul = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_ue_scheduling_info.ue_scheduling_hysteresis = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->mac_perfs_stats_bitmap.uePerfStatsToReportBitMap = 0x00;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->mac_perfs_stats_bitmap.cellPerfStatsToReportBitMap = 0x00;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ue_scheduling_perfs.ue_scheduling = RRM_FALSE;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ue_scheduling_perfs.active_ue_ul_dl_stats.totalActiveUEsInDl = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ue_scheduling_perfs.active_ue_ul_dl_stats.totalActiveUEsInUl = RRM_ZERO;
    /** Dynamic UE Scheduling End **/ 
   
    /* SPR-10397-fix start */ 
    RRM_MEMSET(&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->max_thp), 
            RRM_ZERO, sizeof(rrm_max_thp_t)); 
    /* CSR_00077458_CHANGES_START */
    for (index = RRM_ZERO; index < MAX_UE_SUPPORTED; index++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->max_thp.ue_index[index] = RRM_INVALID_UE_ID;
    }
    /* CSR_00077458_CHANGES_END */
    /* SPR-10397-fix end */
   /* Carrier Aggregation start*/
     /* CID : 62114 */
    for( scell_list_count = RRM_ZERO ; scell_list_count < RRM_MAX_NUM_CELLS ; scell_list_count++ )
    {
        ylInit( &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scell_info[scell_list_count].list));
    }
   /* Carrier Aggregation end*/

    /* SPR 12971 Start */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->starting_rat_type_for_anr = EUTRAN_RAT;
    /* SPR 12971 End */
    /* Start fix for SPR 14987 */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->num_anr_strong_cell_req_sent = RRM_ZERO;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->apply_anr_to_all_ue = RRM_TRUE;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->apply_anr_on_ue_attach_in_all_cycles = RRM_TRUE;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->is_anr_first_cycle = RRM_TRUE;
    /* End fix for SPR 14987 */

    #ifdef LTE_EMBMS_SUPPORTED
    RRM_MEMSET(&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_cell_embms_data),
                 RRM_ZERO, sizeof(rrm_cell_embms_data_t));
    /* SPR 18435: Fix Start*/
    for (index = RRM_ZERO; index < MAX_SI_MESSAGE; index++)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
            rrm_cell_embms_data.si_start_offset[index] = RRM_ONE; 

    }
    /* SPR 18435: Fix End*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_cell_embms_data.
        current_sibs_on_boradcast |= MBMS_SIBS_NOT_ON_BROADCAST;;
    #endif
}
/****************************************************************************
 * Function Name  : fre_cell_index
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : free the cell index
 ****************************************************************************/

/*SPR 17777 +-*/
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_cellm_cell_config_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Processes cell_config_req from Interface handler
 ****************************************************************************/
rrm_return_et
rrm_cell_config_req_process_msg(rrm_cell_context_t         *p_cell_context ,
                                void                       *p_api ,
                                /* SPR_13889_Start */
                                /*Code Removed*/
                                /* SPR_13889_End */
                                rrm_cell_index_t           cell_index ,
                                U16                        api_id)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    RRM_MEMSET(p_cell_context, RRM_ZERO, sizeof(rrm_cell_context_t));

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index] = p_cell_context;
    RRM_MEMCPY(&(p_cell_context->global_cell_id),
            &(p_g_rrm_cell_ctx->arr_rrm_global_cell_index[cell_index].global_cell_id),
            sizeof(rrm_global_cell_id_t));

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;

    /* Initalizing the cell state and some cell context parameters 
     */
    rrm_cellm_init_cell_context (cell_index);
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
    /* message processing to FSM
     */

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
        RRMCM_RMIF_CELL_CONFIG_REQ;  
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
        ((rrmcm_rmif_cell_config_req_t *)p_api)->transaction_id;

    rrm_populate_enb_context(&p_g_rrm_cell_ctx->enb_context,p_api);
    /* CID 81650 Fix Start */
    if(ret_val == cellm_fsm_process_event (
    /* CID 81650 Fix Stop */
                RRMCM_RMIF_CONFIG_REQ_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    { 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED,"cellm_fsm_process_event:" 
                "Successfully processed api:%d",api_id);
/* SPR 20636 Changes Start*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_DETAILED,"cellm_fsm_process_event:Add= 0x%u",
                (U32_U32Long_Bit)p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
/* SPR 20636 Changes End*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_ERROR,"cellm_fsm_process_event:" 
                "Failed to processed api:%d",api_id);
        /* SPR_13889_Start */
        /*Code Removed*/
        /* SPR_13889_End */
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrm_cellm_cell_config_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_g_rrm_cell_ctx : cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Processes cell_config_req from Interface handler
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_config_req_process_msg (
		void *p_api /*Pointer to input api buffer*/,
		U16 api_id /*incoming API id*/
        /*SPR 17777 +-*/
		)
{
    /* CID 81650 Fix Start */
    rrm_return_et ret_val = RRM_FAILURE;
    /* CID 81650 Fix Stop */
    rrm_cell_context_t *p_cell_context = RRM_PNULL;
    /* SPR_13889_Start */
    /* Code Deleted */
    /* Coverity_fix_94914_start */
    rrm_error_et fail_cause = RRM_NO_ERROR;
    /* Coverity_fix_94914_end */
    /* SPR_13889_End */
    /* cell_index_from_api_header_start */
    rrm_cell_index_t        cell_index = RRM_INVALID_CELL_ID;
    /* cell_index_from_api_header_end */
   
    /*SPR 10329:start*/
    U8          max_num_cell       = RRM_ZERO;
    rrm_bool_et cell_configured    = RRM_FALSE;
    rrmcm_rmif_cell_config_resp  cell_config_resp;
    RRM_MEMSET (&cell_config_resp, RRM_ZERO, sizeof(rrmcm_rmif_cell_config_resp));
    /*SPR 10329:end*/
 
    RRM_UT_TRACE_ENTER();

    /* cell_index_from_api_header_start */
    cell_index = ((rrmcm_rmif_cell_config_req_t *)p_api)->cell_index;
    /* cell_index_from_api_header_end */
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->CellM:RRMCM_RMIF_CELL_CONFIG_REQ");
    if ((cell_index >= RRM_MAX_NUM_CELLS) || (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,"Cell Index:%d already allocated ",cell_index);
#ifdef RRM_UT_FLAG        
	RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_F);
	RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_F_cell_already_config);
#endif        
        /*++ coverity Fix 94907 */
        cell_config_resp.cellindex = cell_index;
        cell_config_resp.transaction_id =
            ((rrmcm_rmif_cell_config_req_t *)p_api)->transaction_id;
        cell_config_resp.response = RRM_FAILURE;
        cell_config_resp.fail_cause = RRM_ERR_CELL_ALREADY_CONFIGURED ;
        RRM_MEMCPY(&(cell_config_resp.global_cell_id) ,
                (&((rrmcm_rmif_cell_config_req_t *)p_api)->global_cell_id),
                sizeof(rrm_global_cell_id_t));
        if (RRM_SUCCESS == rrm_send_internal_msg(RRM_MIF_MODULE_ID,
                    RRMCM_RMIF_CELL_CONFIG_RESP,
                    sizeof(rrmcm_rmif_cell_config_resp),
                    (void *)&cell_config_resp))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "build_and_send_cell_config_resp_resp_to_mif: successfully for cell index:%d",
                    cell_config_resp.cellindex);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "build_and_send_cell_config_resp: failure in send config response  for cell index:   %d",
                    cell_config_resp.cellindex);
        }
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "either cell index not valid or cell context not found for cell index:%d",
                cell_index);
        /* SPR 21251 End */
        return RRM_FAILURE;
        /*-- coverity Fix 94907 */
	}    
	else
    {
        /*SPR 10329:start*/
        if ((p_g_rrm_cell_ctx->enb_context.bitmask & RRM_GLOBAL_ENB_ID_PRESENT) &&
                (p_g_rrm_cell_ctx->enb_context.enb_id.enb_type ==  RRM_ENB_TYPE_HOME))
        {
            for (max_num_cell = RRM_ZERO; max_num_cell < RRM_MAX_NUM_CELLS; max_num_cell++)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[max_num_cell])
                {
                    cell_configured = RRM_TRUE;
                    break;
                }
            }
            if(cell_configured == RRM_TRUE)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                        RRM_ERROR,"ENB type is[%d] cell at index[%d]is configured on ENB",
                        p_g_rrm_cell_ctx->enb_context.enb_id.enb_type, max_num_cell);
                cell_config_resp.cellindex = cell_index;
                cell_config_resp.transaction_id =
                    ((rrmcm_rmif_cell_config_req_t *)p_api)->transaction_id;
                cell_config_resp.response = RRM_FAILURE;
                cell_config_resp.fail_cause = RRM_ERR_CELL_CONFIG_FAILURE;
                RRM_MEMCPY(&(cell_config_resp.global_cell_id) ,
                        (&((rrmcm_rmif_cell_config_req_t *)p_api)->global_cell_id),
                        sizeof(rrm_global_cell_id_t));
                if (RRM_SUCCESS == rrm_send_internal_msg(RRM_MIF_MODULE_ID,
                            RRMCM_RMIF_CELL_CONFIG_RESP,
                            sizeof(rrmcm_rmif_cell_config_resp),
                            (void *)&cell_config_resp))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "build_and_send_cell_config_resp_resp_to_mif: successfully for cell index:%d",
                            cell_config_resp.cellindex);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "build_and_send_cell_config_resp: failure in send config response  for cell index:   %d",
                            cell_config_resp.cellindex);
                }
                /* SPR 21251 Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "cell is already configured for cell index:%d",
                        cell_index);
                /* SPR 21251 End */
                return RRM_FAILURE;
            }

        }

        /*SPR 10329:end*/

        /*Memory allocation for the cell context*/
        p_cell_context = (rrm_cell_context_t *)rrm_mem_get (sizeof(rrm_cell_context_t));
        /* SPR 21852 Fix Start */
        if (p_cell_context != RRM_PNULL)
        {
            /*Klockwork_fix_start*/
            /* SPR_13889_Start */
            ret_val = rrm_cell_config_req_process_msg(p_cell_context ,p_api,cell_index ,api_id);
            /* SPR_13889_End */
            /*Klockwork_fix_end*/
            if (RRM_FAILURE == ret_val)
            {
                if((cell_index < RRM_MAX_NUM_CELLS) && (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
                {
                    RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]= RRM_PNULL;
                }
            }
        }
        else
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_context failed" );
            /* SPR 21251 End */
            /* SPR_13889_Start */
            fail_cause = RRM_ERR_SYS_MEM_ALLOC_FAILURE;
            ret_val = RRM_FAILURE;
            /* SPR_13889_End */ 
            if(RRM_FAILURE == rmcm_rmif_send_config_resp(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index],
                        RRM_FAILURE,
                        fail_cause))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"cellm_fsm_process_event: "
                        "Failed to send generic response to MIF");
            }
            /* SPR 21251 End */
            RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]= RRM_PNULL;
            return ret_val;
        }
        /* SPR 21852 Fix Stop */

    }

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/*klock_works_changes_start*/

rrm_return_et 
rrm_rrm_reconfig_resp_cell_state_default_case_process_msg
(
 rrm_cell_index_t              cell_index,
 rrc_rrm_cell_reconfig_resp_t  *p_reconfig_resp,
 U16                           trans_id,
 U16                           api_id
)
{
    rrm_return_et ret_val;
    RRM_UT_TRACE_ENTER();
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
        (void *)p_reconfig_resp;

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
        RRC_RRM_CELL_RECONFIG_RESP; 

    /*Cell update start*/
    if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state ==
            CELL_STATE_W_FOR_CELL_UPDATE_ONGOING_UPDATE_RESP)
    {
        if (RRM_FAILURE == cellm_fsm_process_event
                (RRC_RRM_CELL_UPDATE_RESP_EVENT,
                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "unable to process cell reconfig in cell update for cell_index: %d", cell_index);
            /* SPR 21251 End */
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "successfully processed cell reconfig in cell update");
            ret_val = RRM_SUCCESS;
        }             
    }
    /*Cell update end*/
    else
    {
        if(RRM_FAILURE == cellm_fsm_process_event
                (RRC_RRM_CELL_RECONFIG_RESP_EVENT,
                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "unable to process api:%d ",api_id);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "successfully processed api:%d ",api_id);
            ret_val = RRM_SUCCESS;
        }
    }

    if((p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_reconfig_fail &
                RRM_RECONFIG_ONGOING) ||
            /*Cell update start*/
            (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_update_fail &
             RRM_UPDATE_ONGOING))
        /*Cell update end*/
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,"No need to deallocate TCB block");
    }
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
    RRM_UT_TRACE_EXIT();
    return ret_val;
        
}

rrm_return_et
rrc_rrm_reconfig_resp_cell_state_process_msg
(
 rrm_cell_index_t               cell_index, 
 rrc_rrm_cell_reconfig_resp_t  *p_reconfig_resp, 
 U16                            trans_id,
 U16                            api_id
) 
{
    rrm_return_et ret_val;
    RRM_UT_TRACE_ENTER();

    switch (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state)
    {
        case CELL_STATE_MLB_W_FOR_CELL_RECONFIG_RESP:
            {
                /* MLB Ph2 SSAC Start */
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
                    (void *)p_reconfig_resp;
                /* SPR-22532 START */
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
                /* SPR-22532 END */

                if(RRM_FAILURE == cellm_fsm_process_event
                        (RRC_RRM_MLB_CELL_RECONFIG_RESP_EVENT,
                         p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "MLB: Unable to process Cell Reconfig resp api:%d ",api_id);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "MLB: Successfully processed Cell reconfig resp api:%d ",api_id);
                    ret_val = RRM_SUCCESS;
                }     
                /* MLB Ph2 SSAC End */
            }
            break;

        case CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP:

            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
                (void *)p_reconfig_resp;
            /* SPR-22532 START */
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
            /* SPR-22532 END */

            if(RRM_FAILURE == cellm_fsm_process_event
                    (RRC_RRM_BLOCK_CELL_RECONFIG_RESP_EVENT,
                     p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " Unable to process Cell Reconfig resp for cell block api:%d ",api_id);
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " Successfully processed Cell reconfig resp for cell block api:%d ",api_id);
                ret_val = RRM_SUCCESS;
            }
            break;

        #ifdef LTE_EMBMS_SUPPORTED
        case CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_MBMS:
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
                (void *)p_reconfig_resp;
            if(RRM_FAILURE == cellm_fsm_process_event
                    (RRC_RRM_CELL_RECONFIG_RESP_EVENT,
                     p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " Unable to process Cell Reconfig resp for cell block api:%d ",api_id);
                ret_val = RRM_FAILURE;
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        " Successfully processed Cell reconfig resp for cell block api:%d ",api_id);
                ret_val = RRM_SUCCESS;
            }
            break;
        #endif

        default :
          /*klock_works_changes_start*/  
            ret_val=rrm_rrm_reconfig_resp_cell_state_default_case_process_msg(cell_index, p_reconfig_resp, trans_id, api_id);
          /*klock_works_changes_end*/  
            break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}    

/*klock_works_changes_end*/

/****************************************************************************
 * Function Name  : rrm_rrc_cell_reconfig_resp_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell_reconfig_resp from RRC
 ****************************************************************************/

rrm_return_et
rrm_rrc_cell_reconfig_resp_process_msg (
		U8 *p_api, /*Input Api buffer*/
		U16 api_id, /*Incoming Api id*/
		U16 data_len,/* Incoming data length*/
		U16 trans_id/*transaction id*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrc_rrm_cell_reconfig_resp_t  *p_reconfig_resp = RRM_PNULL;
	S32               length = RRM_ZERO;
/* SPR 11681 Fix Start */
   /* Code deleted */
    /* SPR 11681 Fix ENd */

	RRM_UT_TRACE_ENTER();

	p_reconfig_resp = (rrc_rrm_cell_reconfig_resp_t *)rrm_mem_get
		(sizeof(rrc_rrm_cell_reconfig_resp_t));
    if (p_reconfig_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_reconfig_resp failed" );
        /* BUG_11576_FIX_START */
        /*De allocate trans_id */
        ret_val = de_allocate_tcb_from_cell_ctxt(
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index],
                trans_id);
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                    RRM_ERROR, "CELLM: TCB De-Allocation Failed dealloc");
        }
        /* BUG_11576_FIX_END */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_cell_reconfig_resp(
				p_reconfig_resp,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"RRC->RRM:RRC_RRM_CELL_RECONFIG_RESP unable to parse");
		ret_val = RRM_FAILURE;
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_reconfig_resp_F);
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_reconfig_resp_F_parse_err);
#endif        
	}
	else      
	{
		cell_index = p_reconfig_resp->cell_index;
        SET_CELL_INDEX(cell_index);
		RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"RRC->RRM:RRC_RRM_CELL_RECONFIG_RESP:[CELL:%d] with response: %d ",
                p_reconfig_resp->cell_index, p_reconfig_resp->response);

		if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
		{
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "cell context not found for cell_index: %d", cell_index);
            /* SPR 21251 End */
            /* COVERITY : RESOURCE LEAK : CID : 54345 fix start */
            RRM_MEM_FREE(p_reconfig_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54345 fix end */
            /* BUG_11576_FIX_START */
            /*De allocate trans_id */
            ret_val = de_allocate_tcb_from_cell_ctxt(
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index],
                    trans_id);
            if(RRM_FAILURE == ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                        RRM_ERROR, "CELLM: TCB De-Allocation Failed dealloc");
            }
            /* BUG_11576_FIX_END */
            RRM_UT_TRACE_EXIT();
            /* COVERITY : RESOURCE LEAK : CID : 54345 fix start */
            RRM_MEM_FREE(p_reconfig_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54345 fix end */
            RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
       /*klock_works_changes_start*/ 
       ret_val=rrc_rrm_reconfig_resp_cell_state_process_msg(cell_index, p_reconfig_resp, trans_id, api_id );    
       /*klock_works_changes_end*/ 
    
    }
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	RRM_MEM_FREE(p_reconfig_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_set_attr_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell deregister equest 
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_set_attr_req_process_msg(
		U8 *p_api, /*Input Api buffer*/
		U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_cell_set_attr_req *rrmcm_rmif_cell_set_attr = RRM_PNULL;
	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_set_attr =
		(rrmcm_rmif_cell_set_attr_req *)p_api;
	/*21481:Need to check the cell index for which reconfig has come
	 */
	cell_index = rrmcm_rmif_cell_set_attr->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Set Attr Req For Cell Index :%d",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell index:%d",
                cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
	if (RRM_FAILURE == cellm_fsm_process_event (
				RRMCM_RMIF_SON_CELL_SET_ATTR_REQ_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d with cell index :%d in fsm",api_id,cell_index);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Successfully process api id %d in fsm",api_id);
		ret_val = RRM_SUCCESS;
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_deregister_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell deregister equest 
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_deregister_req_process_msg(
		void *p_api, /*Input Api buffer*/
		U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_cell_son_register_deregister_req_t 
		*rrmcm_rmif_cell_reg_dereg_req =RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	rrmcm_rmif_cell_reg_dereg_req =
		(rrmcm_rmif_cell_son_register_deregister_req_t *)p_api;

	cell_index = rrmcm_rmif_cell_reg_dereg_req->cellindex;
	RRM_ASSERT(cell_index < RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"DeRegister Req For Cell Index :%d",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell_index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
		rrmcm_rmif_cell_reg_dereg_req->transaction_id;

	if (RRM_FAILURE == cellm_fsm_process_event (
				RRMCM_RMIF_CELL_SON_DEREGISTER_REQ_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "successfully process api id %d in fsm",api_id);
		ret_val = RRM_SUCCESS;
	}

	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* UE MEAS CHANGES : STARTS */
/****************************************************************************
 * Function Name  : rrm_cellm_meas_config_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes UE MEAS CONFIG Request 
 ****************************************************************************/
rrm_return_et
rrm_cellm_meas_config_req_process_msg(
		void *p_api, /*Input Api buffer*/
		U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t         cell_index   = RRM_ZERO;
	rrm_return_et            ret_val      = RRM_FAILURE;

	rrmcm_rmif_cell_son_meas_config_req_t 
		*rrmcm_rmif_meas_config_req = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_meas_config_req =
		(rrmcm_rmif_cell_son_meas_config_req_t *)p_api;  

	cell_index = rrmcm_rmif_meas_config_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);

    SET_CELL_INDEX(cell_index);

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->CellM:RRMCM_RMIF_MEAS_CONFIG_FROM_ANR_REQ");

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell_index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = 
		(void *)p_api; 

	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
		rrmcm_rmif_meas_config_req->transaction_id;

	if (RRM_FAILURE == cellm_fsm_process_event (
				RRMCM_RMIF_MEAS_CONFIG_REQ_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				RRM_ERROR, "Failure to process api id %d with cell index %d",api_id,cell_index);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				RRM_DETAILED, "Success to process api id %d",api_id); 

		ret_val = RRM_SUCCESS;
	}

	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	RRM_UT_TRACE_EXIT();

	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_meas_config_obj_remove_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes UE MEAS CONFIG OBJ REMOVE Request
 ****************************************************************************/
rrm_return_et
rrm_cellm_meas_config_obj_remove_req_process_msg(
    void *p_api, /*Input Api buffer*/
    U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
)
{
    rrm_cell_index_t         cell_index   = RRM_ZERO;
    rrm_return_et            ret_val      = RRM_FAILURE;

    rrmcm_rmif_cell_son_meas_config_obj_remove_req_t
                      *rrmcm_rmif_meas_config_obj_remove_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrmcm_rmif_meas_config_obj_remove_req =
                 (rrmcm_rmif_cell_son_meas_config_obj_remove_req_t *)p_api;

    cell_index = rrmcm_rmif_meas_config_obj_remove_req->cellindex;
    if (cell_index< RRM_MAX_NUM_CELLS)
    {
        SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
          "MIF->RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ->CellM");

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell_index: %d", cell_index);
        /* SPR 21251 End */
        return RRM_FAILURE;
    }
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
              (void *)p_api;

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id =
                         rrmcm_rmif_meas_config_obj_remove_req->transaction_id;

    if (RRM_FAILURE == cellm_fsm_process_event (
                    RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_ERROR, "Failure to process api id %d",api_id);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
            RRM_DETAILED, "Success to process api id %d",api_id);

        ret_val = RRM_SUCCESS;
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
    }
    else   /*- Coverity: CID 11169 -*/
    {
        RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    }
    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/* UE MEAS CHANGES : ENDS */

/****************************************************************************
 * Function Name  : rrm_cellm_cell_register_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell register request 
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_register_req_process_msg(
		void *p_api, /*Input Api buffer*/
		U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_cell_son_register_deregister_req_t 
		*rrmcm_rmif_cell_reg_dereg_req = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_reg_dereg_req =
		(rrmcm_rmif_cell_son_register_deregister_req_t *)p_api;  

	cell_index = rrmcm_rmif_cell_reg_dereg_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Register Req For Cell Index :%d",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell_index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
		rrmcm_rmif_cell_reg_dereg_req->transaction_id;

	if (RRM_FAILURE == cellm_fsm_process_event (
				RRMCM_RMIF_CELL_SON_REGISTER_REQ_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				RRM_ERROR, "Failure to process api id %d and cell index %d",api_id,cell_index);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
				"Success to process api id %d",api_id);
		ret_val = RRM_SUCCESS;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_set_log_level_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes set log level request 
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_set_log_level_req_process_msg(
		void *p_api /*Input Api buffer*/
        /*SPR 17777 +-*/
		)
{
	rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_set_log_level_req_t *rrmcm_rmif_set_log_lvl = RRM_PNULL;
	rrmcm_rmif_generic_non_cell_specific_api_resp_t *p_resp = RRM_PNULL;
	RRM_UT_TRACE_ENTER();

	rrmcm_rmif_set_log_lvl =(rrmcm_rmif_set_log_level_req_t *)p_api;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_SET_LOG_LEVEL_REQ->CellM");
	/*call set log level function*/
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"log_level is:%d",rrmcm_rmif_set_log_lvl->log_level);

    /* SPR_13117_FIX_START */
    p_g_rrm_cell_ctx->log_level = rrmcm_rmif_set_log_lvl->log_level;
    /* SPR_13117_FIX_END */

	if (RRM_TRUE == g_cellm_log_on_off)
	{
		rrm_cell_log_enable_disable_cmd(
				p_g_rrm_cell_ctx->log_enabled,
				rrmcm_rmif_set_log_lvl->log_level);

	}

	p_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t));
    if ( p_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	p_resp->transaction_id = rrmcm_rmif_set_log_lvl->transaction_id;
	p_resp->response = RRM_SUCCESS;
	if(RRM_FALSE == g_cellm_log_on_off)
	{
		p_resp->fail_cause = RRM_ERR_LOG_ENABLE_FAILURE; 
	}
	else
	{
		p_resp->fail_cause = RRM_NO_ERROR;
	}
	ret_val = rrm_send_internal_msg(
			RRM_MIF_MODULE_ID,
			RRMCM_RMIF_SET_LOG_LEVEL_RESP,
			sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t),
			(void *)p_resp);
	if(ret_val == RRM_SUCCESS)
	{
		RRM_TRACE(RRM_OAM_LOG_ON, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Successfully set log_level:%d",rrmcm_rmif_set_log_lvl->log_level);

	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Failed to set log_level:%d",rrmcm_rmif_set_log_lvl->log_level);
	}
	RRM_MEM_FREE(p_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*****************************************************************************
 * Function Name  : rrm_cell_log_enable_disable_cmd
 * Inputs         : Log Enable/Disable
 *                  Log Level to be set
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes RRM_OAM_LOG_ENABLE_DISABLE_REQ msg
 *                  to set the logging parameters for RRM MgmtIfH
 ****************************************************************************/
void rrm_cell_log_enable_disable_cmd (
		rrm_oam_log_on_off_et log_on_off,
		rrm_oam_log_level_et log_level)
{
	RRM_UT_TRACE_ENTER();
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"Rcvd log level as %d, logonoff = %d", log_level, log_on_off);
	if(RRM_OAM_LOG_OFF == log_on_off)
	{   
		log_level = RRM_OAM_NONE;
	}   
	SET_MODULE_LOG_LEVEL(log_level);
    /* coverity : CID 29646,29645*/
    g_cellm_log_on_off = (rrm_bool_et) log_on_off;
    p_g_rrm_cell_ctx->log_enabled = (rrm_oam_log_on_off_et) g_cellm_log_on_off;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Log enable/disable = %d",
			log_on_off);

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_log_enb_dis_req_process_msg 
 * Inputs         : void *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes init cell config request 
 *******************************************************************************/
rrm_return_et
rrm_cellm_cell_log_enb_dis_req_process_msg
(
 void *p_api, /*Input Api buffer*/
 U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
 )
{

	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_log_enable_disable_req_t *p_init_config = RRM_PNULL;
	rrmcm_rmif_generic_non_cell_specific_api_resp_t *p_resp = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_init_config =(rrmcm_rmif_log_enable_disable_req_t *)p_api;

	p_g_rrm_cell_ctx->log_enabled = p_init_config->log_on_off;
	p_g_rrm_cell_ctx->log_level = p_init_config->log_level;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_LOG_ENABLE_DISABLE_REQ->CellM");
	rrm_cell_log_enable_disable_cmd(
			p_g_rrm_cell_ctx->log_enabled, 
			p_g_rrm_cell_ctx->log_level);
	/*21481:start*/
	p_resp = rrm_mem_get(sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t));
    if ( p_resp == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_resp failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

	p_resp->transaction_id = p_init_config->transaction_id;
	p_resp->response = RRM_SUCCESS;
	p_resp->fail_cause = RRM_NO_ERROR;
	/*
	 * sending response to MIF
	 */
	if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				RRMCM_RMIF_LOG_ENABLE_DISABLE_RESP,
				sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t),
				(void *)p_resp))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "send reponse for api:%d",api_id);
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "failure in sending reponse for api:%d",api_id);
		ret_val = RRM_FAILURE;
	}
	RRM_MEM_FREE(p_resp);

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_init_config_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes init cell config request 
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_init_config_req_process_msg(
		void *p_api, /*Input Api buffer*/
		U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
		)
{
	rrm_return_et ret_val = RRM_FAILURE;
	rrmcm_rmif_init_config_req_t *p_init_config = RRM_PNULL;
	rrmcm_rmif_generic_non_cell_specific_api_resp_t *p_init_config_resp = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	p_init_config =(rrmcm_rmif_init_config_req_t *)p_api;

	p_g_rrm_cell_ctx->log_enabled = p_init_config->log_on_off;
	p_g_rrm_cell_ctx->log_level= p_init_config->log_level;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->CellM:RRMCM_RMIF_INIT_CONFIG_REQ");
	rrm_cell_log_enable_disable_cmd(
			p_g_rrm_cell_ctx->log_enabled, 
			p_g_rrm_cell_ctx->log_level);
	/*21481:start*/
	p_init_config_resp  = rrm_mem_get(sizeof
			(rrmcm_rmif_generic_non_cell_specific_api_resp_t));
    if ( p_init_config_resp == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_init_config_resp failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* Spr 16211 Changes Start*/
    /*CID 97129 Start*/
    if(p_init_config->bitmask & RRMCM_RMIF_INIT_RIM_INFO_PRESENT) 
    /*CID 97129 End*/
    {
        p_g_rrm_cell_ctx->enb_context.rim_feature_enable = 
            p_init_config->rim_enable_disable;
    }
    else
    {
        p_g_rrm_cell_ctx->enb_context.rim_feature_enable = RRM_FALSE; 
    }
    /* Spr 16211 Changes End*/


	p_init_config_resp->transaction_id = p_init_config->transaction_id;
	p_init_config_resp->response = RRM_SUCCESS;
#ifdef RRM_UT_FLAG        
	RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.init_config_resp_S_cm);
#endif        
	/*
	 * sending response to MIF
	 */
	if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				RRMCM_RMIF_INIT_CONFIG_RESP,
				sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t),
				(void *)p_init_config_resp))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "send reponse for api:%d",api_id);
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "failure in sending reponse for api:%d",api_id);
		ret_val = RRM_FAILURE;
	}
	RRM_MEM_FREE(p_init_config_resp);

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_cell_delete_resp_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 * 		          : U16 api_id : api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_g_rrm_cell_ctx : 
 *                : cell global context 
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell delete request from Interface handler
 ****************************************************************************/

rrm_return_et
rrm_rrc_cell_delete_resp_process_msg(
		U8 *p_api, /*Incoming API buffer*/
		U16 api_id, /*incoming API id*/
		U16 data_len,/*incoming data length*/
		U16 trans_id /*incoming trans id*/
		)
{
    rrm_cell_index_t  cell_index=RRM_ZERO;
    S32 length = RRM_ZERO;
    rrm_rrc_cell_del_resp_t *p_rrc_cell_del_resp = RRM_PNULL;
    rrm_return_et	ret_val = RRM_FAILURE;
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    RRM_UT_TRACE_ENTER();
    p_rrc_cell_del_resp = (rrm_rrc_cell_del_resp_t *)rrm_mem_get(
            sizeof(rrm_rrc_cell_del_resp_t));
    if ( p_rrc_cell_del_resp == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_cell_del_resp failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }	
    /* Parse  the incoming message from RRC 
     */
    if (RRM_FAILURE == rrm_il_parse_rrm_rrc_cell_del_resp(
                p_rrc_cell_del_resp,
                (U8  *)p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"RRC->RRM:RRC_RRM_CELL_DELETE_RESP unable to parse");
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_delete_resp_F_parse_err_cm);
#endif        
        ret_val = RRM_FAILURE;
    }
    else
    {
        cell_index = p_rrc_cell_del_resp->cell_index;
        RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"RRC->RRM:RRC_RRM_CELL_DELETE_RESP:[CELL:%d] with response: %d",
                p_rrc_cell_del_resp->cell_index, p_rrc_cell_del_resp->response);
        if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "cell context not found for cell index: %d",cell_index);
            /* SPR 21251 End */
        SET_CELL_INDEX(cell_index);
            /* COVERITY : RESOURCE LEAK : CID : 54344 fix start */
            RRM_MEM_FREE(p_rrc_cell_del_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54344 fix end*/
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
            (void *)p_rrc_cell_del_resp;

        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
            RRC_RRM_CELL_DELETE_RESP;  
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id
            = trans_id;
        /* SPR 11681 Fix Start */
        /* Code deleted */
        /* SPR 11681 Fix End */
        if(RRM_FAILURE == cellm_fsm_process_event( 
                    RRC_RRM_CELL_DELETE_RESP_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"unable to process api:%d ",api_id);
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"successfully processed api:%d ",api_id);
            ret_val = RRM_SUCCESS;
        }
        /* SPR 11681 Fix Start */
        /* Code deleted */
        /* SPR 11681 Fix End */
    }
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
    RRM_MEM_FREE(p_rrc_cell_del_resp); 
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*IPv6 changes begin*/
/*code cleaned : There is no need for TNL address conversion .
  RRM shall forward what is coming from L3 to SON*/
/*IPv6 changes end*/

/* Fix 960 Start */
/* SPR 9463 Fix-2 Start */
rrm_bool_et
rrm_memcmp_oam_cell_plmn_info(
   rrm_oam_cell_plmn_info_t     *p_plmn_1,
   rrm_oam_cell_plmn_info_t     *p_plmn_2
   )
{
    RRM_UT_TRACE_ENTER();
    U8 counter = RRM_ZERO;

    for( counter = RRM_ZERO; counter < p_plmn_2->num_mnc_digit; counter++)
    {
        if(p_plmn_1->mcc[counter] != p_plmn_2->mcc[counter])
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_plmn_1->mcc[%d] = %d, p_plmn_2->mcc[%d] = %d",
                counter, p_plmn_1->mcc[counter], counter, p_plmn_2->mcc[counter]);
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
    }
    if(p_plmn_1->num_mnc_digit != p_plmn_2->num_mnc_digit)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "p_plmn_1->num_mnc_digit = %d, p_plmn_2->num_mnc_digit = %d",
            p_plmn_1->num_mnc_digit, p_plmn_2->num_mnc_digit);
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
    }
    for( counter = RRM_ZERO; counter < p_plmn_1->num_mnc_digit; counter++)
    {
        if(p_plmn_1->mnc[counter] != p_plmn_2->mnc[counter])
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_plmn_1->mnc[%d] = %d, p_plmn_2->mnc[%d] = %d",
                counter, p_plmn_1->mnc[counter], counter, p_plmn_2->mnc[counter]);
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}
/*klock_works_changes_start*/
rrm_bool_et
rrm_memcmp_enb_id(
        rrm_global_enb_id_t     *p_enb_id_1,
        rrm_global_enb_id_t     *p_enb_id_2
        )

{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for(count=RRM_ZERO; count<HOME_ENB_ID_OCTET_SIZE; count++)
    {
        if(p_enb_id_1->eNb_id[count] != p_enb_id_2->eNb_id[count])
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                    "p_enb_id_1.eNb_id[%d] = %d, p_enb_id_2.eNb_id[%d] = %d",
                    count, p_enb_id_1->eNb_id[count], count, p_enb_id_2->eNb_id[count]);
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;

}
/*klock_works_changes_end*/

rrm_bool_et
rrm_memcmp_global_enb_id(
    rrm_global_enb_id_t     *p_enb_id_1,
    rrm_global_enb_id_t     *p_enb_id_2
    )
{
    RRM_UT_TRACE_ENTER();

    if(p_enb_id_1->enb_type != p_enb_id_2->enb_type)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "p_enb_id_1->enb_type = %d, p_enb_id_2->enb_type = %d",
                p_enb_id_1->enb_type, p_enb_id_2->enb_type);
        RRM_UT_TRACE_EXIT();
        return RRM_TRUE;
    }
    if(RRM_TRUE == rrm_memcmp_oam_cell_plmn_info(&p_enb_id_1->plmn_id, &p_enb_id_2->plmn_id))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "PLMN Mismatch");
        RRM_UT_TRACE_EXIT();
        return RRM_TRUE;
    }
    
    /*klock_works_changes_start*/
    if(RRM_TRUE==rrm_memcmp_enb_id( p_enb_id_1, p_enb_id_2))
    {
        RRM_UT_TRACE_EXIT();
        return RRM_TRUE;
    }
    /*klock_works_changes_end*/
    /* Coverity 22 May : 60718 Start */
    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
    /* Coverity 22 May : 60718 End */
}




rrm_void_t
rrm_memcpy_gl_enb_id(
    rrm_global_enb_id_t     *p_dst,
    rrm_global_enb_id_t     *p_src
)
{
    U8 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_dst->enb_type = p_src->enb_type;

    rrm_memcpy_rrm_oam_cell_plmn_info(&p_dst->plmn_id,
            &p_src->plmn_id);

    for(count=RRM_ZERO; count<HOME_ENB_ID_OCTET_SIZE; count++)
    {
        p_dst->eNb_id[count] = p_src->eNb_id[count];
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 9463 Fix-2 End */

static rrm_return_et
rrm_retreive_tnl_discovery_trans_id
(
    rrm_global_enb_id_t     target_enb_id,
    U16                     *p_trans_id
)
{
    rrm_tnl_discovery_trans_id_list_t       *p_tnl_discovery_trans_id_list = RRM_PNULL;
    rrm_tnl_discovery_trans_id_node_t       *p_tnl_discovery_trans_id_node = RRM_PNULL;
    YLNODE                              *p_node                        = RRM_PNULL;
    U8                                  index                          = RRM_NULL;
    rrm_return_et                       ret_val                        = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    p_tnl_discovery_trans_id_list = &(p_g_rrm_cell_ctx->rrm_tnl_discovery_trans_id_list);

    /* SPR 9463 Fix-2 Start */
    if(RRM_PNULL != p_tnl_discovery_trans_id_list)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
            "Enb-Trans list size = %d", ylCount(p_tnl_discovery_trans_id_list));
        p_node = rrm_get_first_list_node(p_tnl_discovery_trans_id_list);
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "Enb-Trans list size = 0");
    }
    for(index = 0; RRM_PNULL != p_node; index++)
    {
        p_tnl_discovery_trans_id_node =  YMEMBEROF(rrm_tnl_discovery_trans_id_node_t, sNode, p_node);

        if(RRM_FALSE == rrm_memcmp_global_enb_id(&p_tnl_discovery_trans_id_node->enb_id,
            &target_enb_id))
        /* SPR 9463 Fix-2 End */
        {
            *p_trans_id = p_tnl_discovery_trans_id_node->trans_id;
            rrm_list_delete_node(p_tnl_discovery_trans_id_list, (YLNODE *)p_tnl_discovery_trans_id_node);
            RRM_MEM_FREE(p_tnl_discovery_trans_id_node);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Target ENB found in list. Transaction ID of TNL discovery Req was = %d",
                *p_trans_id);
            break;
        }
        /* SPR 9463 Fix-2 Start */
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "gl_enb_id of current node (with Trans ID = %d) did not match, node_index = %d",
                p_tnl_discovery_trans_id_node->trans_id, index);
        }
        /* SPR 9463 Fix-2 End */
        p_node = rrm_get_next_list_node(p_node);
    }

    if(RRM_PNULL == p_node)
    {
        *p_trans_id = RRM_NULL;
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Target ENB not found in TNL Discovery Req list at RRM");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Fix 960 End */

/****************************************************************************
 * Function Name  : rrm_rrc_tnl_discovery_resp_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : trans_id : Transaction ID
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes TNL DISCOVERY response 
 ****************************************************************************/
rrm_return_et
rrm_rrc_tnl_discovery_resp_process_msg(
		U8 *p_api, /*Incoming API buffer*/
		U16 api_id, /*incoming API id*/
		U16 data_len,/*incoming data length*/
		U16 trans_id /*incoming trans id*/
		)
{
	S32 length = RRM_ZERO;
	rrm_return_et   ret_val = RRM_FAILURE;
	s1ap_rrm_mme_config_transfer_t *p_mme_config_transfer = RRM_PNULL;
	U8 index = RRM_NULL ;
	U8 index2 = RRM_NULL ; /*IPv6 change*/
	rrmcm_rmif_son_tnl_discovery_resp_t tnl_res = {RRM_NULL};

	RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"RRC->RRM:S1AP_RRM_MME_CONFIG_TRANSFER");
	p_mme_config_transfer = (s1ap_rrm_mme_config_transfer_t *)rrm_mem_get(sizeof
			(s1ap_rrm_mme_config_transfer_t));
	if ( p_mme_config_transfer == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_mme_config_transfer failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_mme_config_transfer(
				p_mme_config_transfer,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"RRC->UEM:S1AP_RRM_MME_CONFIG_TRANSFER failed to process");
		ret_val = RRM_FAILURE;
	}
	else
	{
		/*Raising event LOCAL_MME_CONFIGURATION_TRANSFER
		  RRM shall send this event when the S1 message
		  "MME CONFIGURATION TRANSFER" is received
		 */
		rrm_raise_event_mme_config_transfer();

		if(MME_CONFIG_TRANSFER_SON_INFO_RESP & p_mme_config_transfer->bitmask)
		{
            /* Fix 960 Delete */

			rrm_fill_plmn_identity_from_config_transfer(&tnl_res.tnl_discovery_resp.target_enb_id.plmn_id,
					&p_mme_config_transfer->gb_enb_id.plmn_identity);

			if (p_mme_config_transfer->gb_enb_id.enb_id.presence_bitmask & S1AP_OAM_MACRO_ENB_ID_PRESENT )
			{
				tnl_res.tnl_discovery_resp.target_enb_id.enb_type = RRM_ENB_TYPE_MACRO;
				for (index = RRM_NULL; MACRO_ENB_ID_OCTET_SIZE > index; index++)
				{
					tnl_res.tnl_discovery_resp.target_enb_id.eNb_id[index] = p_mme_config_transfer->gb_enb_id.enb_id.macro_enb_id.eNB_id[index];
				}
			}
			else if (p_mme_config_transfer->gb_enb_id.enb_id.presence_bitmask & S1AP_OAM_HOME_ENB_ID_PRESENT )
            {
                tnl_res.tnl_discovery_resp.target_enb_id.enb_type = RRM_ENB_TYPE_HOME;
                /* SPR 9463 Fix-2 Start */
                for(index = RRM_ZERO; index < HOME_ENB_ID_OCTET_SIZE; index++)
                {
                    tnl_res.tnl_discovery_resp.target_enb_id.eNb_id[index] = 
                        p_mme_config_transfer->gb_enb_id.enb_id.home_enb_id.eNB_id[index];
                }
                /* SPR 9463 Fix-2 End */
            }
        
            /* Fix 960 Start */
            if(RRM_SUCCESS == rrm_retreive_tnl_discovery_trans_id(tnl_res.tnl_discovery_resp.target_enb_id, &trans_id))
            {
    			tnl_res.transaction_id = trans_id;
	    		tnl_res.tnl_discovery_resp.result = RRM_SUCCESS;
		    	/* coverity : CID 29635*/
                tnl_res.tnl_discovery_resp.error_code = RRM_NO_ERROR;
            /* Fix 960 End */

			/*IPv6 changes begin*/
			if(MME_CONFIG_TRANSFER_X2TNL_IPv6 & p_mme_config_transfer->bitmask)
			{
				/* This block supports the case where TNL address has both Ipv4 and Ipv6 */
				tnl_res.tnl_discovery_resp.enb_tnl_address_list_size =
					p_mme_config_transfer->number_of_addr +
					p_mme_config_transfer->number_of_ipv6_addr;
				/*The max number of TNL address are limited to 2 as per specs*/
				if(MAX_NO_ENB_X2_TLAS < tnl_res.tnl_discovery_resp.enb_tnl_address_list_size)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Invalid number [%u] of TNL addresses recived ",
							tnl_res.tnl_discovery_resp.enb_tnl_address_list_size);
					RRM_MEM_FREE(p_mme_config_transfer);
					RRM_UT_TRACE_EXIT();
					return RRM_FAILURE ;
				}
				for (index = RRM_NULL; p_mme_config_transfer->number_of_ipv6_addr > index; index++)
				{
					tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].bitmask |= RRM_IPV6_ADD_PRESENT;
					RRM_MEMCPY(&tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].ipv6_add,
							p_mme_config_transfer->ip_v6_addr[index].ip_addr,RRM_IPV6_SIZE);
				}
				for (index2 = RRM_NULL ; p_mme_config_transfer->number_of_addr > index2; index2++)
				{
					tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].bitmask |= RRM_IPV4_ADD_PRESENT;
					RRM_MEMCPY(&tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].ipv4_add,
							p_mme_config_transfer->ip_addr[index2].ip_addr,RRM_IPV4_SIZE);
				}
			}
			else
			{
				tnl_res.tnl_discovery_resp.enb_tnl_address_list_size = p_mme_config_transfer->number_of_addr;
				for (index = RRM_NULL; tnl_res.tnl_discovery_resp.enb_tnl_address_list_size > index; index++)
				{
					tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].bitmask |= RRM_IPV4_ADD_PRESENT;
					RRM_MEMCPY(&tnl_res.tnl_discovery_resp.enb_tnl_address_list[index].ipv4_add,
							p_mme_config_transfer->ip_addr[index].ip_addr,RRM_IPV4_SIZE);
				} 
			}
			/*IPv6 changes end*/
			if(RRM_FAILURE ==  build_and_send_tnl_discovery_resp_to_mif(&tnl_res,RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_RES))
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"unable to send tnl discovery response to mif ");
				ret_val = RRM_FAILURE;
			}
            /* Fix 960 Start */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "MME Config Tranfer could not be mapped to any TNL discovery Req recvd from SON");
                ret_val = RRM_FAILURE;
            }
            /* Fix 960 End */
		}
		else if(MME_CONFIG_TRANSFER_SON_INFO_REQ & p_mme_config_transfer->bitmask)
		{
			/*IPv6 changes begin*/
			/*Build and send enb_config_transfer_resp to L3:As TNL address is unknown
			  at RRM and maintained at L3 so L3 shall fill it appropiately*/ 
			if(RRM_FAILURE == rrm_build_and_send_enb_config_tranfer_resp(p_mme_config_transfer,trans_id))
			{
                /* SPR 21251 Start */
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"failed to send enb_config_tranfer_resp ");
                /* SPR 21251 End */
				ret_val = RRM_FAILURE;
			}
			/*IPv6 changes end*/
		}

	}
	RRM_MEM_FREE(p_mme_config_transfer);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_rrc_cell_stop_resp_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          : U16 api_id :api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell_stop_resp from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_cell_stop_resp_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len, /* incoming data length*/
		U16 trans_id /* Incoming transaction Id*/
		)
{
	rrm_cell_index_t  cell_index=RRM_ZERO;
	S32  length = RRM_ZERO;
	rrm_return_et	ret_val = RRM_FAILURE;
	rrc_rrm_cell_stop_resp_t *p_stop_resp = RRM_PNULL;
/* SPR 11681 Fix Start */
   /* Code deleted */
    /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();
	p_stop_resp = (rrc_rrm_cell_stop_resp_t *)rrm_mem_get(sizeof
			(rrc_rrm_cell_stop_resp_t));
    if ( p_stop_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_stop_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_cell_stop_resp(
				p_stop_resp,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"RRC->RRM:RRC_RRM_CELL_STOP_RESP unable to parse");
		ret_val = RRM_FAILURE;
		if(RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data)
		{
            /* BUG_11576_FIX_START */
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx
					[cell_index]->p_new_reconfig_data);
            /* BUG_11576_FIX_END */
		}
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_stop_resp_F);
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_stop_resp_F_parse_err);
#endif        
	}else
	{
		cell_index = p_stop_resp->cell_index;
        SET_CELL_INDEX(cell_index);
		RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"RRC->RRM:RRC_RRM_CELL_STOP_RESP:[CELL:%d] with response: %d",
                p_stop_resp->cell_index, p_stop_resp->response);

		if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
		{
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "cell context not found for cell index: %d", cell_index);
            /* SPR 21251 End */
            /* COVERITY : RESOURCE LEAK : CID : 54348 fix start*/
            RRM_MEM_FREE(p_stop_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54348 fix end*/
            RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = 
			(void *)p_stop_resp;


/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
				RRC_RRM_CELL_STOP_RESP; 
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
			if (RRM_FAILURE == cellm_fsm_process_event(   
						RRC_RRM_CELL_STOP_RESP_EVENT,
						p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"unable to process api:%d ",api_id);
				ret_val = RRM_FAILURE;
			}else
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"successfully processed api:%d ",api_id);
				ret_val = RRM_SUCCESS;
			}

/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */

   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	RRM_MEM_FREE(p_stop_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_rrc_cell_start_resp_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_g_rrm_cell_ctx : pointer to
 *                : global cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cell_start_resp from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_cell_start_resp_process_msg(
		U8 *p_api, /*Input API buffer*/
		U16 api_id, /*Incoming Api Id*/
		U16 data_len, /*incoming data length*/
		U16 trans_id /* Incoming transaction Id*/
		)
{
	rrm_cell_index_t  cell_index=RRM_ZERO;
	rrm_return_et ret_val = RRM_FAILURE;
	rrc_rrm_cell_start_resp_t *p_start_resp = RRM_PNULL;
	S32  length = RRM_ZERO;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
    /* Coverity_ID : 30998 */
    cell_timer_buf_t timer_buf = {CELL_PERIODIC_TIMER_FOR_ANR,RRM_ZERO,RRM_ZERO,RRM_ZERO};

	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(RRM_PNULL != p_api);
	RRM_ASSERT(RRM_PNULL != p_g_rrm_cell_ctx);

	p_start_resp = (rrc_rrm_cell_start_resp_t *)rrm_mem_get(
			sizeof(rrc_rrm_cell_start_resp_t));
	if ( p_start_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_start_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_cell_start_resp(
				p_start_resp,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"RRC->RRM:RRC_RRM_CELL_START_RESP unable to parse");
#ifdef RRM_UT_FLAG        
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_start_resp_F);
		RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmRrcDebugStats.cell_start_resp_F_parse_err);
#endif        
		ret_val = RRM_FAILURE;
	}
	else
	{
		cell_index = p_start_resp->cell_index; 
        SET_CELL_INDEX(cell_index);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"RRC->RRM:RRC_RRM_CELL_START_RESP:[CELL:%d] with response: %d",
                p_start_resp->cell_index, p_start_resp->response);
		RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"Cell Start Resp For Cell Index :%d",
				cell_index);

		if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
		{
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "cell context not found for cell_index: %d", cell_index);
            /* SPR 21251 End */
            /* COVERITY : RESOURCE LEAK : CID : 54347 fix start*/
            RRM_MEM_FREE(p_start_resp);
            /* COVERITY : RESOURCE LEAK : CID : 54347 fix end*/
            RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
			(void *)p_start_resp;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
				RRC_RRM_CELL_START_RESP;  
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
			if (RRM_FAILURE == cellm_fsm_process_event (
						RRC_RRM_CELL_START_RESP_EVENT,
						p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "unable to process api:%d",api_id);
				/*CID 75358*/
			}else
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "successfully processed api:%d",api_id);
				/*CID 75358*/
			}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
		/* False reconfig ongoing flag */
		/*De allocate trans_id */
		if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_reconfig_fail & RRM_RECONFIG_ONGOING)
		{
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_reconfig_fail &= 
				RRM_RECONFIG_ONGOING;
		}

		/*Cell update start*/
		/* False update ongoing flag */
		if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_update_fail & RRM_UPDATE_ONGOING)
		{
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->stop_update_fail &=
				RRM_UPDATE_ONGOING;
		}
		/*Cell update start*/
        /*KPI chnage start the timer*/
        if (RRM_ZERO != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.duration)
        {
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_KPI;
            timer_buf.cell_index = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_index;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "cell index[%u] start timer CELL_PERIODIC_TIMER_FOR_KPI duration[%u]", 
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_index,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.duration);
                         /* CID : 60714 fix start */ 
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.kpi_periodic_timer = 
                        cell_start_timer( CELL_PERIODIC_TIMER_FOR_KPI ,(rrm_void_t *)&timer_buf,
                        sizeof(cell_timer_buf_t),p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
                         /* CID : 60714 fix end */

        }
        /* SPR_17763 Changes Start*/
		ret_val = de_allocate_tcb_from_cell_ctxt(
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index],
                trans_id);
        /* SPR_17763 Changes Stop */

   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
	}
	RRM_MEM_FREE(p_start_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_link_up_ind_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          : U16 api_id :api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes x2ap link_up indicaton from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_link_up_ind_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len /* incoming data length*/
        /*SPR 17777 +-*/
		)
{
	S32  length                     = RRM_ZERO;
	rrm_return_et	ret_val     = RRM_SUCCESS;
	x2ap_rrm_x2_link_up_ind_st  *p_x2ap_link_up_ind = RRM_PNULL;
	rrm_x2ap_enb_node_t         *p_x2ap_enb_node = RRM_PNULL;    
	rrm_x2ap_enb_list_t          *p_x2ap_enb_list = RRM_PNULL;
	U8                           counter = RRM_ZERO;
    #ifdef ENDC_ENABLED
    /* MENB CHANGES - START */
    U8                           index = RRM_ZERO;
    U8                           count = RRM_ZERO;
    rrm_x2ap_ss_rssi_measurement_t *p_rrm_ss_rssi_meas_config = RRM_PNULL;
    x2ap_ss_rssi_measurement_t *p_x2ap_ss_rssi_meas_config = RRM_PNULL;
    x2ap_ssb_mtc_t *p_x2ap_ssb_meas_config = RRM_PNULL;
    rrm_x2ap_ssb_mtc_t *p_rrm_ssb_meas_config = RRM_PNULL;
    x2ap_nr_tx_bandwidth_t *p_x2ap_nr_dl_tx_bdwidth = RRM_PNULL;
    rrm_nr_tx_bandwidth_t *p_rrm_nr_dl_tx_bdwidth = RRM_PNULL;
    x2ap_nr_tx_bandwidth_t *p_x2ap_nr_ul_tx_bdwidth = RRM_PNULL;
    rrm_nr_tx_bandwidth_t  *p_rrm_nr_ul_tx_bdwidth = RRM_PNULL;
    x2ap_nr_freq_info_t *p_x2ap_nr_dl_freq_info = RRM_PNULL;
    rrm_nr_freq_info_t *p_rrm_nr_dl_freq_info = RRM_PNULL;
    x2ap_nr_freq_info_t *p_x2ap_nr_ul_freq_info = RRM_PNULL;
    rrm_nr_freq_info_t *p_rrm_nr_ul_freq_info = RRM_PNULL;
    U8 num_freq_band = RRM_ZERO;
    /* MENB CHANGES - END */
    #endif

	RRM_UT_TRACE_ENTER();
	p_x2ap_enb_list = &(p_g_rrm_cell_ctx->rrm_x2_enb_list);
	p_x2ap_link_up_ind = (x2ap_rrm_x2_link_up_ind_st *)rrm_mem_get(sizeof
			(x2ap_rrm_x2_link_up_ind_st));
	if (p_x2ap_link_up_ind == RRM_PNULL)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Memory Allocation Failure for p_x2ap_link_up_ind");
		ret_val = RRM_FAILURE;
		return ret_val;
	}
	RRM_MEMSET(p_x2ap_link_up_ind, RRM_ZERO, sizeof(x2ap_rrm_x2_link_up_ind_st));

	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_parse_x2ap_rrm_x2_link_up_ind_st(
				p_x2ap_link_up_ind,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
				"RRC->RRM:X2AP_RRM_LINK_UP_IND: failed to parsed");
		ret_val = RRM_FAILURE;
	}else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
				"RRC->RRM:X2AP_RRM_LINK_UP_IND: successfully processed");
		p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)rrm_mem_get(sizeof(rrm_x2ap_enb_node_t));
		if (RRM_PNULL == p_x2ap_enb_node)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Mem allocation fail for p_x2ap_enb_node");
            /* BUG_11576_FIX_START */
            /* Code Deleted */
            /* BUG_11576_FIX_END */
			ret_val = RRM_FAILURE;
		}
		else
		{
            #ifdef ENDC_ENABLED
            /* MENB CHANGES - START */
            if ( RRM_X2AP_EUTRA_CELL_INFO_PRESENT &
                p_x2ap_link_up_ind->bitmask )
            {
                p_x2ap_enb_node->link_up_data.bitmask |= RRM_EUTRA_CELL_INFO_PRESENT;
            /* MENB CHANGES - START */
            #endif
                if(p_x2ap_link_up_ind->eutra_cell_info.global_enb_id.enb_id.presence_bitmask &\
					X2AP_OAM_MACRO_ENB_ID_PRESENT)
			{
/* SPR 20636 Changes Start*/
                    p_x2ap_enb_node->enb_id = (U32_U32Long_Bit)p_x2ap_link_up_ind->eutra_cell_info.global_enb_id.\
							  enb_id.macro_enb_id.eNB_id;
/* SPR 20636 Changes End*/
			}
			else 
			{
/* SPR 20636 Changes Start*/
                    p_x2ap_enb_node->enb_id = (U32_U32Long_Bit)p_x2ap_link_up_ind->eutra_cell_info.global_enb_id.\
							  enb_id.home_enb_id.eNB_id;
/* SPR 20636 Changes End*/
			}
                p_x2ap_enb_node->link_up_data.eutra_cell_info.num_served_cell = \
                                                                                p_x2ap_link_up_ind->eutra_cell_info.num_served_cell;
                for(counter = RRM_ZERO;counter < p_x2ap_link_up_ind->eutra_cell_info.num_served_cell;counter++)
			{
                    p_x2ap_enb_node->link_up_data.eutra_cell_info.cell_info[counter].ngh_dir_cell_arr.\
                        served_cell_info.pci = p_x2ap_link_up_ind->eutra_cell_info.cell_info[counter].\
					ngh_dir_cell_arr.served_cell_info.pci;
			}

			ylPushTail(p_x2ap_enb_list, &(p_x2ap_enb_node->sNode));
                rrm_update_link_status_ind(p_x2ap_link_up_ind, &p_x2ap_link_up_ind->eutra_cell_info.global_enb_id, api_id);
            #ifdef ENDC_ENABLED
            /* MENB CHANGES - START */
            }
            else if ( RRM_X2AP_NR_CELL_INFO_PRESENT &
                p_x2ap_link_up_ind->bitmask )
            {
                p_x2ap_enb_node->link_up_data.bitmask |= RRM_NR_CELL_INFO_PRESENT;
                p_x2ap_enb_node->enb_id = (U32_U32Long_Bit)p_x2ap_link_up_ind->nr_cell_info.global_gnb_id.\
                    x2_en_gnb_id.x2_gnb_id;

                /* copy global_gnb_id */
                 RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.\
                  plmn_identity.plmn_id, p_x2ap_link_up_ind->nr_cell_info.global_gnb_id.\
                 plmn_identity.plmn_id, sizeof(U8) * MAX_PLMN_ID_BYTES);

                 RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.\
                  gNB_id, p_x2ap_link_up_ind->nr_cell_info.global_gnb_id.\
                 x2_en_gnb_id.x2_gnb_id, sizeof(U8) * NR_GNB_ID_OCTET_SIZE);

                p_x2ap_enb_node->link_up_data.nr_cell_info.num_served_nr_cell = \
                    p_x2ap_link_up_ind->nr_cell_info.num_served_cell;
                    /* coverity_<280093>_fix_start */
                p_x2ap_enb_node->link_up_data.nr_cell_info.default_sgnb = \
                              (rrm_bool_et)p_x2ap_link_up_ind->nr_cell_info.default_sgnb;
              /* coverity_<280093>_fix_end */
                for ( count = RRM_ZERO; count < p_x2ap_link_up_ind->nr_cell_info.num_served_cell; count++ )
                {
                    p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].\
                        served_cell_info.nr_pci = p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                        nr_pci;

/* NR_REP_CONFIG_FIX_START */
                    if(RRM_ONE == p_x2ap_enb_node->link_up_data.nr_cell_info.default_sgnb)
                    {
                        rrm_update_cellm_update_peer_gnb_pci_list(p_x2ap_link_up_ind->\
                         nr_cell_info.served_cell_info[count].nr_pci);
                    }
/* NR_REP_CONFIG_FIX_END */
                    /* ENDC_MEAS_CHANGES_START */
                    RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].\
                            served_cell_info.nr_cell_id.nr_cell_id,
                            p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                            nr_cell_id.nr_cell_id,sizeof(U8) * NR_CELL_ID_OCTET_SIZE);

                    RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].\
                            served_cell_info.nr_cell_id.plmn_identity.plmn_id,
                            p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                            nr_cell_id.plmn_identity.plmn_id,
                            sizeof(U8) * MAX_PLMN_ID_BYTES);
                        p_x2ap_enb_node->link_up_data.nr_cell_info.\
                        cell_info[count].served_cell_info.choice_nr_mode.bitmask  = 0x00;

                    if(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                            choice_nr_mode.bitmask & X2AP_NR_MODE_FDD_PRESENT)
                    {
                        /* Fill nr_ul_freq_info */
                        p_x2ap_nr_ul_freq_info = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                choice_nr_mode.nr_fdd_info.nr_ul_freq_info);
                        p_rrm_nr_ul_freq_info = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.choice_nr_mode.\
                                fdd_info.nr_ul_freq_info);
                        p_x2ap_enb_node->link_up_data.nr_cell_info.\
                        cell_info[count].served_cell_info.choice_nr_mode.bitmask |= RRM_X2AP_NR_MODE_FDD_PRESENT;

                        p_rrm_nr_ul_freq_info->nr_earfcn = p_x2ap_nr_ul_freq_info->nr_earfcn;
                        p_rrm_nr_ul_freq_info->num_freq_nr = p_x2ap_nr_ul_freq_info->num_freq_bands;
                        for( num_freq_band= RRM_ZERO ; 
                                num_freq_band < p_rrm_nr_ul_freq_info->num_freq_nr; 
                                num_freq_band++ )
                        {
                            p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].\
                                freq_band_indicator_nr = 
                                p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].\
                                freq_band_indicator_nr;

                            p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].\
                                num_supported_sul_band = 
                                p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].\
                                num_supported_sul_band;

                            RRM_MEMCPY(p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].\
                                    supported_sul_freq_band_indicator_nr,
                                    p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].\
                                    supported_sul_freq_band_indicator_nr,
                                    sizeof(U16)*NR_MAX_FREQ_BANDS);
                        }
                        /* Fill nr_dl_freq_info */
                        p_x2ap_nr_dl_freq_info = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                choice_nr_mode.nr_fdd_info.nr_dl_freq_info);
                        p_rrm_nr_dl_freq_info = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.choice_nr_mode.\
                                fdd_info.nr_dl_freq_info);

                        p_rrm_nr_dl_freq_info->nr_earfcn = p_x2ap_nr_dl_freq_info->nr_earfcn;
                        p_rrm_nr_dl_freq_info->num_freq_nr = p_x2ap_nr_dl_freq_info->num_freq_bands;
                        for( num_freq_band= RRM_ZERO ; 
                                num_freq_band < p_rrm_nr_dl_freq_info->num_freq_nr; 
                                num_freq_band++ )
                        {
                            p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].\
                                freq_band_indicator_nr = 
                                p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].\
                                freq_band_indicator_nr;

                            p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].\
                                num_supported_sul_band = 
                                p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].\
                                num_supported_sul_band;

                            RRM_MEMCPY(p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].\
                                    supported_sul_freq_band_indicator_nr,
                                    p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].\
                                    supported_sul_freq_band_indicator_nr,
                                    sizeof(U16)*NR_MAX_FREQ_BANDS);
                        }

                        /* Fill nr_ul_tx_bdwidth */
                        p_x2ap_nr_ul_tx_bdwidth = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                choice_nr_mode.nr_fdd_info.nr_ul_tx_bdwidth);
                        p_rrm_nr_ul_tx_bdwidth = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.choice_nr_mode.\
                                fdd_info.nr_ul_tx_bdwidth);

                        p_rrm_nr_ul_tx_bdwidth->nrscs = p_x2ap_nr_ul_tx_bdwidth->nr_scs;
                        p_rrm_nr_ul_tx_bdwidth->nrnrb = p_x2ap_nr_ul_tx_bdwidth->nr_nrb;

                        /* Fill nr_dl_tx_bdwidth */
                        p_x2ap_nr_dl_tx_bdwidth = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                choice_nr_mode.nr_fdd_info.nr_dl_tx_bdwidth);
                        p_rrm_nr_dl_tx_bdwidth = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.choice_nr_mode.\
                                fdd_info.nr_dl_tx_bdwidth);

                        p_rrm_nr_dl_tx_bdwidth->nrscs = p_x2ap_nr_dl_tx_bdwidth->nr_scs;
                        p_rrm_nr_dl_tx_bdwidth->nrnrb = p_x2ap_nr_dl_tx_bdwidth->nr_nrb;
                }
                    /* Fill meas timing config */
#ifndef LINUX_PC_TEST
                    p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].served_cell_info.
                        meas_timing_config_len =
                        p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].meas_timing_config_count;

                    for ( index = 0; index < p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].
                        meas_timing_config_count; index++ )
                    {
                        p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].served_cell_info.\
                            meas_timing_config[index].carrier_freq = 
                            p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                            x2ap_meas_timing_config[index].carrier_freq;

                        p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].served_cell_info.\
                            meas_timing_config[index].ssb_subcarrier_spacing = 
                            p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                            x2ap_meas_timing_config[index].ssb_subcarrier_spacing;

                        p_x2ap_ssb_meas_config = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                x2ap_meas_timing_config[index].ssb_meas_timimg_configuration);
                        p_rrm_ssb_meas_config = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.meas_timing_config[index].\
                                ssb_meas_timimg_configuration);

                        p_rrm_ssb_meas_config->periodicity_and_offset.bitmask = 0x00;
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF5_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf5 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf5;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF5_PRESENT;
                        }
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF10_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf10 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf10;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF10_PRESENT;
                        }
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF20_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf20 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf20;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF20_PRESENT;
                        }
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF40_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf40 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf40;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF40_PRESENT;
                        }
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF80_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf80 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf80;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF80_PRESENT;
                        }
                        if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & 
                                X2AP_PERIODICTY_OFFSET_SF160_PRESENT)
                        {
                            p_rrm_ssb_meas_config->periodicity_and_offset.sf160 = 
                                p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf160;
                            p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |=
                                RRM_X2AP_PERIODICTY_OFFSET_SF160_PRESENT;
                        }

                        p_rrm_ssb_meas_config->mtc_duration = 
                            p_x2ap_ssb_meas_config->x2ap_mtc_duration;

                        p_x2ap_ss_rssi_meas_config = &(p_x2ap_link_up_ind->nr_cell_info.served_cell_info[count].\
                                x2ap_meas_timing_config[index].ss_rssi_measurement);
                        p_rrm_ss_rssi_meas_config = &(p_x2ap_enb_node->link_up_data.nr_cell_info.\
                                cell_info[count].served_cell_info.meas_timing_config[index].\
                                ss_rssi_measurement);

                        p_rrm_ss_rssi_meas_config->measurement_slots.numbits =
                            p_x2ap_ss_rssi_meas_config->x2ap_measurement_slots.numbits;
                        RRM_MEMCPY(p_rrm_ss_rssi_meas_config->measurement_slots.meas_slots,
                                p_x2ap_ss_rssi_meas_config->x2ap_measurement_slots.meas_slots,
                                sizeof(U8)* p_rrm_ss_rssi_meas_config->measurement_slots.numbits);
                        p_rrm_ss_rssi_meas_config->end_synmbol = p_x2ap_ss_rssi_meas_config->end_synmbol;

                    }
                    /* ENDC_MEAS_CHANGES_END */
#else//TBD
#endif
                }
                ylPushTail(p_x2ap_enb_list, &(p_x2ap_enb_node->sNode));
            }
            /* MENB CHANGES - END */
            #endif
		}
	}
	RRM_MEM_FREE(p_x2ap_link_up_ind);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_link_down_ind_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          : U16 api_id :api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes x2ap link down indicaton from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_link_down_ind_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len /* incoming data length*/
        /*SPR 17777 +-*/
		)
{
	RRM_UT_TRACE_ENTER();
	S32  length = RRM_ZERO;
	U32  link_down_enb_id = RRM_ZERO;
	rrm_return_et	ret_val = RRM_SUCCESS;
	x2ap_rrm_x2_link_down_ind_t *p_x2ap_link_down_ind = PNULL;
	YLNODE *p_node = RRM_PNULL;
	YLNODE *p_tmp_node = RRM_PNULL;                  

	p_x2ap_link_down_ind = (x2ap_rrm_x2_link_down_ind_t *)rrm_mem_get(sizeof
			(x2ap_rrm_x2_link_down_ind_t));
    if ( p_x2ap_link_down_ind == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_link_down_ind failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }    
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_parse_x2ap_rrm_x2_link_down_ind(
				p_x2ap_link_down_ind,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"RRC->RRM:X2AP_RRM_LINK_DOWN_IND failed to parse ");
		ret_val = RRM_FAILURE;
	}else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"RRC->RRM:X2AP_RRM_LINK_DOWN_IND successfully parsed");
        p_node = ylFirst(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));

		while (p_node)
		{
			p_tmp_node = p_node;

            #ifdef ENDC_ENABLED
            /* MENB CHANGES - START */
            if ( X2AP_RRM_LINK_DOWN_GB_ENB_ID_PRESENT &
                p_x2ap_link_down_ind->bitmask )
            {
            /* MENB CHANGES - END */
            #endif
                rrm_x2ap_enb_node_t         *p_x2ap_enb_node = RRM_PNULL;
			p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;

			if((p_x2ap_link_down_ind->peer_gb_enb_id.enb_id.presence_bitmask &
						X2AP_OAM_MACRO_ENB_ID_PRESENT))
			{
                /* SPR 20430 Changes Start*/
				link_down_enb_id = (U32Long)p_x2ap_link_down_ind->peer_gb_enb_id.
						   enb_id.macro_enb_id.eNB_id;
                           /* SPR 20430 Changes End*/
				if(link_down_enb_id == p_x2ap_enb_node->enb_id)
				{

					ylDelete(&(p_g_rrm_cell_ctx->rrm_x2_enb_list),p_tmp_node);
                    RRM_MEM_FREE(p_tmp_node);
					break;
				}
			}
			else if((p_x2ap_link_down_ind->peer_gb_enb_id.enb_id.presence_bitmask &
						X2AP_OAM_HOME_ENB_ID_PRESENT))
			{

                /* SPR 20430 Changes Start*/
				link_down_enb_id = (U32Long)p_x2ap_link_down_ind->peer_gb_enb_id.
						   enb_id.home_enb_id.eNB_id;
                /* SPR 20430 Changes End*/
				if(link_down_enb_id == p_x2ap_enb_node->enb_id)
				{

					ylDelete(&(p_g_rrm_cell_ctx->rrm_x2_enb_list),p_tmp_node);
                    RRM_MEM_FREE(p_tmp_node);
					break;
				}
			}
            #ifdef ENDC_ENABLED
            /* MENB CHANGES - START */
            }
            else if ( X2AP_RRM_LINK_DOWN_GB_GNB_ID_PRESENT &
                p_x2ap_link_down_ind->bitmask )
            {
                rrm_x2ap_enb_node_t         *p_x2ap_enb_node = RRM_PNULL;
                p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;
                link_down_enb_id = (U32Long)p_x2ap_link_down_ind->peer_gb_gnb_id.
                    x2_en_gnb_id.x2_gnb_id;
                if ( link_down_enb_id == p_x2ap_enb_node->enb_id )
                {
                    ylDelete(&(p_g_rrm_cell_ctx->rrm_x2_enb_list),p_tmp_node);
                    RRM_MEM_FREE(p_tmp_node);
                    break;
                }
            }
            /* MENB CHANGES - END */
            #endif
			p_node = ylNext(p_node);
		}
        #ifdef ENDC_ENABLED
        /* MENB CHANGES - START */
        if ( X2AP_RRM_LINK_DOWN_GB_ENB_ID_PRESENT &
            p_x2ap_link_down_ind->bitmask )
        {
        /* MENB CHANGES - END */
        #endif
            rrm_update_link_status_ind(RRM_PNULL, &p_x2ap_link_down_ind->peer_gb_enb_id, api_id);
        #ifdef ENDC_ENABLED
        /* MENB CHANGES - START */
        }
#if 0
        else if ( X2AP_RRM_LINK_DOWN_GB_GNB_ID_PRESENT &
            p_x2ap_link_down_ind->bitmask )
        {
		rrm_update_link_status_ind(RRM_PNULL, &p_x2ap_link_down_ind->peer_gb_enb_id, api_id);
	}
#endif
        /* MENB CHANGES - END */
        #endif
	}

	RRM_MEM_FREE(p_x2ap_link_down_ind);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* mod by yhliu 20191015 for ENDC config update --start */
#ifdef ENDC_ENABLED

rrm_bool_et
rrm_endc_update_gnb_cell_info(
    x2ap_rrm_srvd_nr_cell_info_t    *p_x2ap_gnb_cell,
    rrm_x2ap_srvd_nr_cell_info_t    *p_rrm_gnb_cell
    )
{
	rrm_return_et	ret_val 	= RRM_SUCCESS;
	U32 num_freq_band			= RRM_ZERO;
	U32	index					= RRM_ZERO;

	rrm_x2ap_ss_rssi_measurement_t 	*p_rrm_ss_rssi_meas_config = RRM_PNULL;
    x2ap_ss_rssi_measurement_t 		*p_x2ap_ss_rssi_meas_config = RRM_PNULL;
    x2ap_ssb_mtc_t 					*p_x2ap_ssb_meas_config = RRM_PNULL;
    rrm_x2ap_ssb_mtc_t 				*p_rrm_ssb_meas_config = RRM_PNULL;
    x2ap_nr_tx_bandwidth_t 			*p_x2ap_nr_dl_tx_bdwidth = RRM_PNULL;
    rrm_nr_tx_bandwidth_t 			*p_rrm_nr_dl_tx_bdwidth = RRM_PNULL;
    x2ap_nr_tx_bandwidth_t 			*p_x2ap_nr_ul_tx_bdwidth = RRM_PNULL;
    rrm_nr_tx_bandwidth_t  			*p_rrm_nr_ul_tx_bdwidth = RRM_PNULL;
    x2ap_nr_freq_info_t 			*p_x2ap_nr_dl_freq_info = RRM_PNULL;
    rrm_nr_freq_info_t 				*p_rrm_nr_dl_freq_info = RRM_PNULL;
    x2ap_nr_freq_info_t 			*p_x2ap_nr_ul_freq_info = RRM_PNULL;
    rrm_nr_freq_info_t 				*p_rrm_nr_ul_freq_info = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_rrm_gnb_cell->nr_pci = p_x2ap_gnb_cell->nr_pci;
	   
	RRM_MEMCPY(p_rrm_gnb_cell->nr_cell_id.nr_cell_id,\
		p_x2ap_gnb_cell->nr_cell_id.nr_cell_id,\
		sizeof(U8) * NR_CELL_ID_OCTET_SIZE);
	
	RRM_MEMCPY(p_rrm_gnb_cell->nr_cell_id.plmn_identity.plmn_id,\
		p_x2ap_gnb_cell->nr_cell_id.plmn_identity.plmn_id,\
		sizeof(U8) * MAX_PLMN_ID_BYTES);
			   
	
	p_rrm_gnb_cell->choice_nr_mode.bitmask = 0x00;
	
	if(X2AP_NR_MODE_FDD_PRESENT & p_x2ap_gnb_cell->choice_nr_mode.bitmask)
	{
		/* Fill nr_ul_freq_info */
		p_x2ap_nr_ul_freq_info = \
			&(p_x2ap_gnb_cell->choice_nr_mode.nr_fdd_info.nr_ul_freq_info);
		p_rrm_nr_ul_freq_info = \
				&(p_rrm_gnb_cell->choice_nr_mode.fdd_info.nr_ul_freq_info);
		
		p_rrm_gnb_cell->choice_nr_mode.bitmask |= RRM_X2AP_NR_MODE_FDD_PRESENT;
	
		p_rrm_nr_ul_freq_info->nr_earfcn = p_x2ap_nr_ul_freq_info->nr_earfcn;
		p_rrm_nr_ul_freq_info->num_freq_nr = p_x2ap_nr_ul_freq_info->num_freq_bands;
		
		for( num_freq_band= RRM_ZERO ; 
			num_freq_band < p_rrm_nr_ul_freq_info->num_freq_nr; 
			num_freq_band++ )
		{
			p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].freq_band_indicator_nr = \
				p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].freq_band_indicator_nr;
	
			p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].num_supported_sul_band = \
				p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].num_supported_sul_band;
	
			RRM_MEMCPY(p_rrm_nr_ul_freq_info->freq_band_nr_info[num_freq_band].supported_sul_freq_band_indicator_nr,\
				p_x2ap_nr_ul_freq_info->freq_band_info[num_freq_band].supported_sul_freq_band_indicator_nr,\
				sizeof(U16)*NR_MAX_FREQ_BANDS);
		}
			
		/* Fill nr_dl_freq_info */
		p_x2ap_nr_dl_freq_info = \
			&(p_x2ap_gnb_cell->choice_nr_mode.nr_fdd_info.nr_dl_freq_info);
		p_rrm_nr_dl_freq_info = \
				&(p_rrm_gnb_cell->choice_nr_mode.fdd_info.nr_dl_freq_info);
	
		p_rrm_nr_dl_freq_info->nr_earfcn = p_x2ap_nr_dl_freq_info->nr_earfcn;
		p_rrm_nr_dl_freq_info->num_freq_nr = p_x2ap_nr_dl_freq_info->num_freq_bands;
		
		for( num_freq_band= RRM_ZERO ; 
				num_freq_band < p_rrm_nr_dl_freq_info->num_freq_nr; 
				num_freq_band++ )
		{
			p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].freq_band_indicator_nr = \
				p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].freq_band_indicator_nr;
	
			p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].num_supported_sul_band = \
				p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].num_supported_sul_band;
	
			RRM_MEMCPY(p_rrm_nr_dl_freq_info->freq_band_nr_info[num_freq_band].supported_sul_freq_band_indicator_nr,\
				 p_x2ap_nr_dl_freq_info->freq_band_info[num_freq_band].supported_sul_freq_band_indicator_nr,\
				 sizeof(U16)*NR_MAX_FREQ_BANDS);
		}
	
		/* Fill nr_ul_tx_bdwidth */
		p_x2ap_nr_ul_tx_bdwidth = \
			&(p_x2ap_gnb_cell->choice_nr_mode.nr_fdd_info.nr_ul_tx_bdwidth);
		p_rrm_nr_ul_tx_bdwidth = \
			&(p_rrm_gnb_cell->choice_nr_mode.fdd_info.nr_ul_tx_bdwidth);
	
		p_rrm_nr_ul_tx_bdwidth->nrscs = p_x2ap_nr_ul_tx_bdwidth->nr_scs;
		p_rrm_nr_ul_tx_bdwidth->nrnrb = p_x2ap_nr_ul_tx_bdwidth->nr_nrb;
	
		/* Fill nr_dl_tx_bdwidth */
		p_x2ap_nr_dl_tx_bdwidth = \
			&(p_x2ap_gnb_cell->choice_nr_mode.nr_fdd_info.nr_dl_tx_bdwidth);
		p_rrm_nr_dl_tx_bdwidth = \
			&(p_rrm_gnb_cell->choice_nr_mode.fdd_info.nr_dl_tx_bdwidth);
	
		p_rrm_nr_dl_tx_bdwidth->nrscs = p_x2ap_nr_dl_tx_bdwidth->nr_scs;
		p_rrm_nr_dl_tx_bdwidth->nrnrb = p_x2ap_nr_dl_tx_bdwidth->nr_nrb;
	}
	
	
	/* Fill meas timing config */
#ifndef LINUX_PC_TEST
	p_rrm_gnb_cell->meas_timing_config_len = p_x2ap_gnb_cell->meas_timing_config_count;
	
	for (index = 0; \
		index < p_x2ap_gnb_cell->meas_timing_config_count;\
		index++ )
	{
		p_rrm_gnb_cell->meas_timing_config[index].carrier_freq = \
			p_x2ap_gnb_cell->x2ap_meas_timing_config[index].carrier_freq;
	
		p_rrm_gnb_cell->meas_timing_config[index].ssb_subcarrier_spacing = \
			p_x2ap_gnb_cell->x2ap_meas_timing_config[index].ssb_subcarrier_spacing;
	
		p_x2ap_ssb_meas_config = \
			&(p_x2ap_gnb_cell->x2ap_meas_timing_config[index].ssb_meas_timimg_configuration);
		p_rrm_ssb_meas_config = \
			&(p_rrm_gnb_cell->meas_timing_config[index].ssb_meas_timimg_configuration);
	
		p_rrm_ssb_meas_config->periodicity_and_offset.bitmask = 0x00;
		
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF5_PRESENT) 
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf5 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf5;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF5_PRESENT;
		}
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF10_PRESENT)
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf10 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf10;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF10_PRESENT;
		}
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF20_PRESENT)
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf20 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf20;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF20_PRESENT;
		}
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF40_PRESENT)
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf40 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf40;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF40_PRESENT;
		}
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF80_PRESENT)
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf80 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf80;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF80_PRESENT;
		}
		if(p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.bitmask & \
				X2AP_PERIODICTY_OFFSET_SF160_PRESENT)
		{
			p_rrm_ssb_meas_config->periodicity_and_offset.sf160 = \
				p_x2ap_ssb_meas_config->x2ap_periodicity_and_offset.sf160;
			p_rrm_ssb_meas_config->periodicity_and_offset.bitmask |= \
				RRM_X2AP_PERIODICTY_OFFSET_SF160_PRESENT;
		}
	
		p_rrm_ssb_meas_config->mtc_duration = p_x2ap_ssb_meas_config->x2ap_mtc_duration;
	
		p_x2ap_ss_rssi_meas_config = \
			&(p_x2ap_gnb_cell->x2ap_meas_timing_config[index].ss_rssi_measurement);
		p_rrm_ss_rssi_meas_config = \
			&(p_rrm_gnb_cell->meas_timing_config[index].ss_rssi_measurement);
	
		p_rrm_ss_rssi_meas_config->measurement_slots.numbits = \
			p_x2ap_ss_rssi_meas_config->x2ap_measurement_slots.numbits;
		
		RRM_MEMCPY(p_rrm_ss_rssi_meas_config->measurement_slots.meas_slots,\
			p_x2ap_ss_rssi_meas_config->x2ap_measurement_slots.meas_slots,\
			sizeof(U8)* p_rrm_ss_rssi_meas_config->measurement_slots.numbits);
		
		p_rrm_ss_rssi_meas_config->end_synmbol = p_x2ap_ss_rssi_meas_config->end_synmbol;
	}
#else
#endif
	RRM_UT_TRACE_EXIT();

	return ret_val;
}
	
rrm_bool_et
rrm_compare_rrm_x2ap_cgi(
	x2ap_nr_ecgi_t 			*p_x2ap_cgi,
	rrm_x2ap_nr_ecgi_t 		*p_rrm_cgi)
{	
	U32 count 			= RRM_ZERO;
	
	RRM_UT_TRACE_ENTER();

	for(count = RRM_ZERO;\
		count < MAX_PLMN_ID_BYTES;\
		count++)
	{
		if(p_x2ap_cgi->plmn_identity.plmn_id[count] != \
			p_rrm_cgi->plmn_identity.plmn_id[count])
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
					"plmn is not match for rrm_compare_rrm_x2ap_cgi");
			return RRM_FALSE;
		}
	}

	for(count = RRM_ZERO;\
		count < NR_CELL_ID_OCTET_SIZE;\
		count++)
	{
		if(p_x2ap_cgi->nr_cell_id[count] != \
			p_rrm_cgi->nr_cell_id[count])
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
					"cell Is is not match for rrm_compare_rrm_x2ap_cgi");
			return RRM_FALSE;
		}
	}
	
	RRM_UT_TRACE_EXIT();
	
	return RRM_TRUE;

}
    	

rrm_return_et
rrm_endc_delete_gnb_cell_info(
    x2ap_nr_ecgi_t    *p_x2ap_gnb_cgi,
    rrm_x2ap_link_up_ind_t    *p_rrm_link
    )
{

	rrm_return_et	ret_val 						= RRM_SUCCESS;
	
	U16 	count 									= RRM_ZERO;
	U16		cell_num								= RRM_ZERO;
	rrm_bool_et	deact_cell_list[MAX_SERVED_CELLS]   = {RRM_FALSE};
	
	RRM_UT_TRACE_ENTER();

	for(count = RRM_ZERO;\
		count < p_rrm_link->nr_cell_info.num_served_nr_cell;\
		count++)
	{
		if(rrm_compare_rrm_x2ap_cgi(p_x2ap_gnb_cgi,\
			&(p_rrm_link->nr_cell_info.cell_info[count].served_cell_info.nr_cell_id)) == RRM_TRUE)
		{
			deact_cell_list[count] = RRM_TRUE;
		}
	}

    /* relist cell array */
	cell_num = RRM_ZERO;
	for(count = 0;\
		count < p_rrm_link->nr_cell_info.num_served_nr_cell;\
		count++)
	{
		if(deact_cell_list[count] == RRM_FALSE)
		{
			if(cell_num != count)
			{
				RRM_MEMCPY((rrm_void_t *)(&(p_rrm_link->nr_cell_info.cell_info[cell_num])),\
					(rrm_void_t *)(&(p_rrm_link->nr_cell_info.cell_info[count])),\
					sizeof(rrm_x2ap_nr_cell_info_t));
				cell_num++;
			}
			
		}
	}
	p_rrm_link->nr_cell_info.num_served_nr_cell = cell_num;
		
	RRM_UT_TRACE_EXIT();
	
	return ret_val;

}

rrm_return_et
rrm_endc_modify_gnb_cell_info(
	x2ap_nr_srvd_cell_modify_arr_t	  *p_x2ap_gnb_mod_cell,
	rrm_x2ap_link_up_ind_t	  *p_rrm_link
	)
{
		rrm_return_et	ret_val 						= RRM_SUCCESS;
		
		U32 	count									= RRM_ZERO;
		
		RRM_UT_TRACE_ENTER();
		
		for(count = RRM_ZERO;\
			count < p_rrm_link->nr_cell_info.num_served_nr_cell;\
			count++)
		{
			if(rrm_compare_rrm_x2ap_cgi(&(p_x2ap_gnb_mod_cell->old_nr_cgi),\
				&(p_rrm_link->nr_cell_info.cell_info[count].served_cell_info.nr_cell_id)) == RRM_TRUE)
			{
				rrm_endc_update_gnb_cell_info(&(p_x2ap_gnb_mod_cell->served_cell_info),&(p_rrm_link->nr_cell_info.cell_info[count].served_cell_info));

			}
		}
	
		RRM_UT_TRACE_EXIT();
		
		return ret_val;

}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_endc_config_update_en_gnb_ind_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          	  : U16 api_id :api id
 *		  		  : U16 data_len : data length

 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes x2ap endc config update indicaton from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_endc_config_update_en_gnb_ind_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len /* incoming data length*/
		)
{
	rrm_return_et	ret_val 	= RRM_SUCCESS;
	x2ap_endc_config_update_en_gnb_ind_t	*p_x2ap_endc_config_update_ind = RRM_PNULL;
	rrm_x2ap_enb_node_t 			*p_x2ap_enb_node = RRM_PNULL;	 
	rrm_x2ap_enb_list_t 			*p_x2ap_enb_list = RRM_PNULL;
	rrm_x2ap_srvd_nr_cell_info_t	*p_rrm_nr_cell_info = RRM_PNULL;
	x2ap_rrm_srvd_nr_cell_info_t	*p_x2ap_nr_cell_info = RRM_PNULL;

	x2ap_nr_srvd_cell_modify_arr_t	*p_x2ap_nr_cell_mod = RRM_PNULL;

	YLNODE *p_node 				= RRM_PNULL;
	U32 count 					= RRM_ZERO;
	S32 length					= RRM_ZERO;
	
	RRM_UT_TRACE_ENTER();
	
	p_x2ap_enb_list = &(p_g_rrm_cell_ctx->rrm_x2_enb_list);
	
	p_x2ap_endc_config_update_ind = (x2ap_endc_config_update_en_gnb_ind_t *)rrm_mem_get(sizeof
				(x2ap_endc_config_update_en_gnb_ind_t));
	if (p_x2ap_endc_config_update_ind == RRM_PNULL)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Memory Allocation Failure for p_x2ap_endc_config_update_ind");
		ret_val = RRM_FAILURE;
		return ret_val;
	}

	RRM_MEMSET(p_x2ap_endc_config_update_ind, RRM_ZERO, sizeof(x2ap_endc_config_update_en_gnb_ind_t));
	
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_parse_x2_endc_config_update_en_gnb_ind(\
			p_x2ap_endc_config_update_ind,\
			p_api,\
			(U32)data_len,\
			&length \
			))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
				"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_IND: failed to parsed");
		ret_val = RRM_FAILURE;
		return ret_val;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
					"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_IND: successfully processed");

		if(p_x2ap_endc_config_update_ind->bitmask == 0x00)
		{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
				"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_IND:bitmask is zero");
			ret_val = RRM_FAILURE;
			return ret_val;
		}

		/* server cell info */
		if(X2AP_ENDC_CONFIGUPDATE_GNB_SERVEDNRCELL_MANAGEMENTLIST_PRESENT& p_x2ap_endc_config_update_ind->bitmask)
		{
			p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)rrm_mem_get(sizeof(rrm_x2ap_enb_node_t));
			if (RRM_PNULL == p_x2ap_enb_node)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Mem allocation fail for p_x2ap_enb_node");
				ret_val = RRM_FAILURE;
				return ret_val;
			}
			p_x2ap_enb_node->enb_id = (U32_U32Long_Bit)p_x2ap_endc_config_update_ind->global_en_gnb_id.x2_en_gnb_id.x2_gnb_id;
			p_x2ap_enb_node->link_up_data.bitmask |= RRM_NR_CELL_INFO_PRESENT;
         
            /* copy global_gnb_id */
            RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.plmn_identity.plmn_id,\
             	p_x2ap_endc_config_update_ind->global_en_gnb_id.plmn_identity.plmn_id,\
             	sizeof(U8) * MAX_PLMN_ID_BYTES);

            RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id,\
             	p_x2ap_endc_config_update_ind->global_en_gnb_id.x2_en_gnb_id.x2_gnb_id,\
              	sizeof(U8) * NR_GNB_ID_OCTET_SIZE);
			

            p_x2ap_enb_node->link_up_data.nr_cell_info.num_served_nr_cell = \
             	p_x2ap_endc_config_update_ind->eutra_nr_cell_management.num_nr_srvd_cell_to_management;

			for ( count = RRM_ZERO; \
				count < p_x2ap_endc_config_update_ind->eutra_nr_cell_management.num_nr_srvd_cell_to_management && \
				count < MAX_SERVED_CELLS; \
				count++ )
            {
				p_rrm_nr_cell_info  = \
					&(p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].served_cell_info);
				p_x2ap_nr_cell_info = \
					&(p_x2ap_endc_config_update_ind->eutra_nr_cell_management.nr_served_cell_management_list[count].served_cell_info);
								
				rrm_endc_update_gnb_cell_info(p_x2ap_nr_cell_info,p_rrm_nr_cell_info);
			}
			ylPushTail(p_x2ap_enb_list, &(p_x2ap_enb_node->sNode));
			
			rrm_mem_free(p_x2ap_enb_node);	
			p_x2ap_enb_node = RRM_PNULL;
			
		}

		
		if(X2AP_ENDC_CONFIGUPDATE_GNB_SERVEDNRCELL_MODIFYLIST_PRESENT& p_x2ap_endc_config_update_ind->bitmask)
		{

            p_node = ylFirst(p_x2ap_enb_list);
			while(p_node)
			{
				p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;
					
				if(p_x2ap_enb_node->enb_id == (U32_U32Long_Bit)p_x2ap_endc_config_update_ind->global_en_gnb_id.x2_en_gnb_id.x2_gnb_id)
				{
					for ( count = RRM_ZERO; \
						count < p_x2ap_endc_config_update_ind->eutra_nr_cell_modify.num_nr_srvd_cell_to_modify && \
						count < MAX_SERVED_CELLS; \
						count++ )
            		{	
						p_x2ap_nr_cell_mod = \
							&(p_x2ap_endc_config_update_ind->eutra_nr_cell_modify.nr_served_cell_modify_list[count]);
							
						if(p_x2ap_nr_cell_mod->bitmask &RRC_ENDC_X2_NR_DEACT_IND_PRESENT)
						{
							rrm_endc_delete_gnb_cell_info(&(p_x2ap_nr_cell_mod->old_nr_cgi), &(p_x2ap_enb_node->link_up_data));
						}
						else
						{
							rrm_endc_modify_gnb_cell_info(p_x2ap_nr_cell_mod, &(p_x2ap_enb_node->link_up_data));
						}
					}
					break;
				}
				p_node = ylNext(p_node);
					
			}
			
		}
		if(X2AP_ENDC_CONFIGUPDATE_GNB_SERVEDNRCELL_DELETELIST_PRESENT& p_x2ap_endc_config_update_ind->bitmask)
		{
            p_node = ylFirst(p_x2ap_enb_list);
			
			while(p_node)
			{
				p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)p_node;

				for ( count = RRM_ZERO; \
					count < p_x2ap_endc_config_update_ind->eutra_nr_cell_delete.num_nr_srvd_cell_delete && \
					count < MAX_SERVED_CELLS; \
					count++ )
				{
					rrm_endc_delete_gnb_cell_info(&(p_x2ap_endc_config_update_ind->eutra_nr_cell_delete.nr_served_cell_delete_list[count]), \
						&(p_x2ap_enb_node->link_up_data));	
				}

				p_node = ylNext(p_node);
			}
			
		}
					
	}
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_endc_config_update_res_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          	  : U16 api_id :api id
 *		  		  : U16 data_len : data length

 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes x2ap endc config update request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_endc_config_update_res_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len /* incoming data length*/
		)
{
	rrm_return_et	ret_val 	= RRM_SUCCESS;
	x2ap_endc_config_update_resp_t	*p_x2ap_endc_config_update_res = RRM_PNULL;

	rrm_x2ap_enb_node_t 			*p_x2ap_enb_node = RRM_PNULL;	 
	rrm_x2ap_enb_list_t 			*p_x2ap_enb_list = RRM_PNULL;
	rrm_x2ap_srvd_nr_cell_info_t	*p_rrm_nr_cell_info = RRM_PNULL;
	x2ap_rrm_srvd_nr_cell_info_t	*p_x2ap_nr_cell_info = RRM_PNULL;

	U32  count						= RRM_ZERO;
	S32	 length						= RRM_ZERO;		
	
	RRM_UT_TRACE_ENTER();
				
	p_x2ap_enb_list = &(p_g_rrm_cell_ctx->rrm_x2_enb_list);
			
	p_x2ap_endc_config_update_res = (x2ap_endc_config_update_resp_t *)rrm_mem_get(sizeof
						(x2ap_endc_config_update_resp_t));
	
	if (p_x2ap_endc_config_update_res == RRM_PNULL)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			"Memory Allocation Failure for p_x2ap_endc_config_update_res");
		ret_val = RRM_FAILURE;
		return ret_val;
	}
	
	RRM_MEMSET(p_x2ap_endc_config_update_res, RRM_ZERO, sizeof(x2ap_endc_config_update_resp_t));
	
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_parse_x2ap_endc_config_update_resp(\
				p_x2ap_endc_config_update_res,\
				p_api,\
				(U32)data_len,\
				&length
				))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
				"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: failed to parsed");
		ret_val = RRM_FAILURE;
		return ret_val;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
					"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: successfully processed");

		if(p_x2ap_endc_config_update_res->response == 0x00)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
					"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: failed response");
			ret_val = RRM_FAILURE;
			return ret_val;
		}

		if(p_x2ap_endc_config_update_res->bitmask & X2AP_CAUSE_PRESENT)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
					"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: failed cause %d",p_x2ap_endc_config_update_res->cause);	
		}
		if(p_x2ap_endc_config_update_res->bitmask & X2AP_NR_CELL_INFOMATION_PRESENT)
		{
			p_x2ap_enb_node = (rrm_x2ap_enb_node_t *)rrm_mem_get(sizeof(rrm_x2ap_enb_node_t));
			if (RRM_PNULL == p_x2ap_enb_node)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Mem allocation fail for p_x2ap_enb_node");
				ret_val = RRM_FAILURE;
				return ret_val;
			}
			p_x2ap_enb_node->enb_id = (U32_U32Long_Bit)p_x2ap_endc_config_update_res->gnb_gb_id.x2_en_gnb_id.x2_gnb_id;
			p_x2ap_enb_node->link_up_data.bitmask |= RRM_NR_CELL_INFO_PRESENT;
         
            /* copy global_gnb_id */
            RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.plmn_identity.plmn_id,\
             	p_x2ap_endc_config_update_res->gnb_gb_id.plmn_identity.plmn_id,\
             	sizeof(U8) * MAX_PLMN_ID_BYTES);

            RRM_MEMCPY(p_x2ap_enb_node->link_up_data.nr_cell_info.global_gnb_id.gNB_id,\
             	p_x2ap_endc_config_update_res->gnb_gb_id.x2_en_gnb_id.x2_gnb_id,\
              	sizeof(U8) * NR_GNB_ID_OCTET_SIZE);
			

            p_x2ap_enb_node->link_up_data.nr_cell_info.num_served_nr_cell = \
             	p_x2ap_endc_config_update_res->nr_cell_information.num_nr_srvd_cell_to_management;

			for ( count = RRM_ZERO; \
				count < p_x2ap_endc_config_update_res->nr_cell_information.num_nr_srvd_cell_to_management && \
				count < MAX_SERVED_CELLS; \
				count++ )
            {
				p_rrm_nr_cell_info  = \
					&(p_x2ap_enb_node->link_up_data.nr_cell_info.cell_info[count].served_cell_info);
				p_x2ap_nr_cell_info = \
					&(p_x2ap_endc_config_update_res->nr_cell_information.nr_served_cell_management_list[count].served_cell_info);
								
				rrm_endc_update_gnb_cell_info(p_x2ap_nr_cell_info,p_rrm_nr_cell_info);
			}
			ylPushTail(p_x2ap_enb_list, &(p_x2ap_enb_node->sNode));
				
			RRM_MEM_FREE(p_x2ap_enb_node);	
			p_x2ap_enb_node = RRM_PNULL;	
		}

	}
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_endc_config_update_wait_ind_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	          	  : U16 api_id :api id
 *		  		  : U16 data_len : data length

 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes x2ap endc config update wait indicaton from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_endc_config_update_wait_ind_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len /* incoming data length*/
		)
{
		rrm_return_et	ret_val 	= RRM_SUCCESS;
		x2ap_endc_config_update_wait_ind_t	*p_x2ap_endc_config_update_wait_ind = RRM_PNULL;

		S32	 length						= RRM_ZERO;	
		
		RRM_UT_TRACE_ENTER();
						
		p_x2ap_endc_config_update_wait_ind = (x2ap_endc_config_update_wait_ind_t *)rrm_mem_get(sizeof
							(x2ap_endc_config_update_wait_ind_t));
		
		if (p_x2ap_endc_config_update_wait_ind == RRM_PNULL)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Memory Allocation Failure for p_x2ap_endc_config_update_res");
			ret_val = RRM_FAILURE;
			return ret_val;
		}
		
		RRM_MEMSET(p_x2ap_endc_config_update_wait_ind, RRM_ZERO, sizeof(p_x2ap_endc_config_update_wait_ind));
		
		/* Parse  the incoming message from RRC */
		if (RRM_FAILURE == rrm_parse_x2ap_endc_config_update_wait_ind(\
					p_x2ap_endc_config_update_wait_ind,\
					p_api,\
					(U32)data_len,\
					&length
					))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
					"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: failed to parsed");
			ret_val = RRM_FAILURE;
			return ret_val;
		}
		else
		{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
							"RRC->RRM:X2AP_RRM_ENDC_CONFIG_UPDATE_RES: successfully processed");

				//update endc req timer 
				
		}

}
#endif
/* mod by yhliu 20191015 for ENDC config update --end */

		
/****************************ETWS/CMAS**********************************/
/*****************************************************************************
 * Function Name  : print_cell_informaton_for_pws
 * Inputs         : rrm_cell_context_t
 * Outputs        : None
 * Returns        :
 * Description    : Prints the information related to PWS 
 *                  
 ****************************************************************************/
rrm_void_t print_cell_informaton_for_pws
(
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();
	YLNODE *p_ylnode = RRM_PNULL; 

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Cell Main State = %d", p_cell_context->cell_state);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Cell PWS substate = %d", p_cell_context->pws_substate);


	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"ETWS node count = %d", p_cell_context->scheduled_etws_warning_list.count);

	p_ylnode = p_cell_context->scheduled_etws_warning_list.node.next;

	while(p_ylnode)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Msg Id = %s", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sched_data_key.msg_id);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				" Serial Number = %s", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sched_data_key.serial_number);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				" Si periodicity = %d",((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_periodicity );
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Num of sib segments = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.num_of_sib_segments);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"current_start_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"current_end_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"prev_start_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"prev_end_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX]);

		if(RRM_PWS_SIB_TYPE_10 == ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sib_type )
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"sib type = %d", RRM_TEN);
		}
		else if (RRM_PWS_SIB_TYPE_11 == ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sib_type)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"sib type = %d", RRM_ELEVEN);
		}
		else 
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"sib type = %d", RRM_TEN);
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"sib type = %d", RRM_ELEVEN);
		}

		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Broadcast status = %d",((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status);

		p_ylnode = ((scheduled_pws_data_node_t *)p_ylnode)->pNode.next;
	}


	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"CMAS node count = %d", p_cell_context->scheduled_cmas_warning_list.count);
	p_ylnode = p_cell_context->scheduled_cmas_warning_list.node.next;

	while(p_ylnode)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Msg Id = %s", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sched_data_key.msg_id);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				" Serial Number = %s", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sched_data_key.serial_number);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				" Si periodicity = %d",((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_periodicity );
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Num of sib segments = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.num_of_sib_segments);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"current_start_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"current_end_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"prev_start_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX]);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"prev_end_si index = %d", ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX]);

		if(RRM_PWS_SIB_TYPE_12 == ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sib_type )
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"sib type = %d", RRM_TWELVE);
		}
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Broadcast status = %d",((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status);

		p_ylnode = ((scheduled_pws_data_node_t *)p_ylnode)->pNode.next;
	}
	RRM_UT_TRACE_EXIT();
}


/*****************************************************************************
 * Function Name  : rrm_cellm_pws_request_sched_data_key
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        :
 * Description    : This function is the keyof function for the scheduled_pws_data  
 *                  linked list.
 ****************************************************************************/
const rrm_void_t * rrm_cellm_pws_request_sched_data_key(const YLNODE *p_ylnode)
{
	return  (&(((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.sched_data_key));
}

/*****************************************************************************
 * Function Name  : rrm_cellm_pws_request_sched_data_sib_type_key
 * Inputs         : p_ylnode - Pointer to scan data.
 * Outputs        : None
 * Returns        :
 * Description    : This function is the keyof function for the scheduled_pws_data
 *                  linked list.
 ****************************************************************************/
const rrm_void_t * rrm_cellm_pws_request_sched_data_sib_type_key(const YLNODE *p_ylnode)
{
	return  (&(((scheduled_pws_data_node_t *) p_ylnode)->scheduled_pws_data.sib_type));
}

/*****************************************************************************
 * Function Name  : rrm_cellm_shed_data_key_compare
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : RRM_ZERO if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
int rrm_cellm_shed_data_key_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
	if (!RRM_MEMCMP((scheduling_data_key_t*)p_key1, (scheduling_data_key_t *)p_key2, sizeof(scheduling_data_key_t)))
	{
		return (RRM_FAILURE);
	}
	else
	{
		return (RRM_SUCCESS);
	}
}

/*****************************************************************************
 * Function Name  : rrm_cellm_shed_data_sib_type_key_compare
 * Inputs         : p_key1 - Pointer to the data1 to be compaired
 *                  p_key2 - Pointer to the data2 to be compaired
 * Outputs        : None
 * Returns        : 0 if data1 is same as data2
 *                  1 if data1 is not same as data2
 * Description    : This function compares the key passed to retrieve correct
 *                  node from linked list.
 ****************************************************************************/
int rrm_cellm_shed_data_sib_type_key_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
	if (!RRM_MEMCMP((U8 *)p_key1, (U8 *)p_key2, sizeof(U8)))
	{
		return (RRM_FAILURE);
	}
	else
	{
		return (RRM_SUCCESS);
	}
}
/*csg start*/
/**************************************************************************
 * Function Name  : rrm_cellm_get_cell_resource_info
 * Inputs         : cell_index
 * Outputs        : cell_resource_info
 * Returns        : address of cell_resource_info within cell_context
 * Description    : returns address of cell_resource_info within cell_context
 ****************************************************************************/
rrm_cell_info_for_ue_mgr_t*
rrm_cellm_get_cell_resource_info(
		rrm_cell_index_t cell_index
		)
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info);
}

/*TM mode 7/8 start*/
/**************************************************************************
 * Function Name  : rrm_cellm_get_antenna_info
 * Inputs         : antenna_info
 * Outputs        : antenna_info_t
 * Returns        : address of antenna_info_t within cell_context
 * Description    : returns address of antenna_info_t within cell_context
 ****************************************************************************/
antenna_info_t*
rrm_cellm_get_antenna_info(
        rrm_cell_index_t cell_index
        )
{
    return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.antenna_info);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_fdd_tdd_mode
 * Inputs         : cell_index
 * Outputs        : fdd/tdd mode of the enb
 * Returns        : fdd/tdd mode of the enb 
 * Description    : fdd/tdd mode of the enb
 ****************************************************************************/
rrm_enb_mode_t
rrm_cellm_get_fdd_tdd_mode(
    rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_enb_mode_t mode;
    if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.
       physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT )
    {
        mode = TDD_MODE;
    }
    else
    {
        mode = FDD_MODE;
    }
    RRM_UT_TRACE_EXIT();
    return mode;
}

/*Start:SPR 8715*/
/**************************************************************************
 * Function Name  : rrm_cm_get_num_tpc_id_dci3
 * Inputs         : cell_index
 * Outputs        : num_tpc_id_dci_3
 * Returns        : num_tpc_id_dci_3
 * Description    : returns number of tpc id for dci 3
 ****************************************************************************/
U8
rrm_cm_get_num_tpc_id_dci3(
    rrm_cell_index_t cell_index
)
{
    return p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->num_tpc_id_dci_3;
}

/**************************************************************************
 * Function Name  : rrm_cm_get_num_tpc_id_dci3a
 * Inputs         : cell_index
 * Outputs        : num_tpc_id_dci_3a
 * Returns        : num_tpc_id_dci_3a 
 * Description    : returns number of tpc id for dci 3a
 ****************************************************************************/
U8
rrm_cm_get_num_tpc_id_dci3a(
    rrm_cell_index_t cell_index
)
{
    return p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->num_tpc_id_dci_3a;
}
/*End:SPR 8715*/

/**************************************************************************
 * Function Name  : rrm_cm_get_mac_beam_forming_info
 * Inputs         : cell_index
 * Outputs        : rrm_mac_beam_forming_info_t
 * Returns        : address of mac_beam_forming_info within cell_context
 * Description    : returns address of mac_beam_forming_info within cell_context
 ****************************************************************************/

const rrm_mac_beam_forming_info_t*
rrm_cm_get_mac_beam_forming_info(
        rrm_cell_index_t cell_index 
                                 )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.mac_beam_forming_info);
}

/**************************************************************************
 * Function Name  : rrm_cm_get_mrrm_tm_mode_additional_info
 * Inputs         : cell_index
 * Outputs        : rrm_tm_mode_additional_info_t
 * Returns        : address of rrm_tm_mode_additional_info within cell_context
 * Description    : returns address of rrm_tm_mode_additional_info within cell_context
 ****************************************************************************/
const rrm_tm_mode_additional_info_t*
rrm_cm_get_mrrm_tm_mode_additional_info(
        rrm_cell_index_t cell_index
        )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_tm_mode_additional_info);
}
/*TM mode 7/8 start*/
/* For limiting UE meas start */
/**************************************************************************
 * Function Name  : rrm_cellm_get_meas_config_info
 * Inputs         : cell_context
 * Outputs        : meas_config_info
 * Returns        : address of meas_config_info within cell_context
 * Description    : returns address of meas_config_info within cell_context
 ****************************************************************************/
rrm_meas_config_info_t*
rrm_cellm_get_meas_config_info(
		rrm_cell_index_t cell_index          
		)
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.meas_config_info);
}
/* For limiting UE meas end */

/* HO retry params start*/

/**************************************************************************
 * Function Name  : rrm_cellm_get_ho_config_params
 * Inputs         : cell_context
 * Outputs        : meas_config_info
 * Returns        : address of meas_config_info within cell_context
 * Description    : returns address of meas_config_info within cell_context
 ****************************************************************************/
rrm_ho_config_params_t *rrm_cellm_get_ho_config_params
(
        rrm_cell_index_t cell_index          
)
{
        
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
     return  &(p_rrm_cell_ctx->operator_info.ho_config_params);
}
/* HO retry params end */

/*TM mode 7-8 start*/
/**************************************************************************
 * Function Name  : rrm_get_tm_mode_table
 * Inputs         : cell_index
 * Outputs        : tm_mode_table
 * Returns        : address of tm_mode_table within cell_context
 * Description    : returns address of tm_mode_table within cell_context
 ****************************************************************************/
const rrm_transmission_mode_table_t* 
rrm_get_tm_mode_table( rrm_cell_index_t cell_index )
{
    RRM_UT_TRACE_ENTER();
    rrm_transmission_mode_table_t *p_rrm_tm_mode;
    if( RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT &
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask )
    {
        p_rrm_tm_mode = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_tm_mode_table);
    }
    else
    {
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		      "Transmission mode table is not present");
        /* SPR 21251 End */
        p_rrm_tm_mode = RRM_NULL;
    }
    RRM_UT_TRACE_EXIT();
    return p_rrm_tm_mode;
}

/**************************************************************************
 * Function Name  : rrm_get_tm_sinr_threshold
 * Inputs         : cell_index
 * Outputs        : tm_sinr_threshold
 * Returns        : tm_sinr_threshold
 * Description    : returns tm_sinr_threshold
 ****************************************************************************/
U32 
rrm_get_tm_sinr_threshold
(
    rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.antenna_info.sinr_threshold;
}

/**************************************************************************
 * Function Name  : rrm_get_tm_pathloss_threshold
 * Inputs         : cell_index
 * Outputs        : tm_pathloss_threshold
 * Returns        : tm_pathloss_threshold
 * Description    : returns tm_sinr_threshold
 ****************************************************************************/
U32
rrm_get_tm_pathloss_threshold
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.antenna_info.pathloss_threshold;
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_access_mgmt_params
 * Inputs         : cell_index
 * Outputs        : access_mgmt_params
 * Returns        : address of access_mgmt_params within cell_context
 * Description    : returns address of access_mgmt_params within cell_context
 ****************************************************************************/
access_mgmt_params_t*
rrm_cellm_get_access_mgmt_params(
		rrm_cell_index_t cell_index
		)
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->access_mgmt_params);
}
/*csg end*/

/*****************************************************************************
 * Function Name  : rrm_cellm_get_scheduling_info_si_index
 * Inputs         : p_list_to_be_searched [etws or cmas list to be searched]
 *                  sib_type[type of sib to be scheduled]
 *                  p_current_scheduling_list[copy of cells scheduling info
 *                                            list]
 * Outputs        : p_si_index[SI idex to place the SIB in scheduling info list]
 *                  p_shed_pws_node[Not Null if same type warning is to 
 *                                 be scheduled]
 * Returns        : None 
 * Description    : This function finds the SI index to place the SIB for the
 *                  new ETWS/CMAS warning. 
 ****************************************************************************/
rrm_void_t 
rrm_cellm_get_scheduling_info_si_index (
		rrm_cell_context_t             *p_cell_ctx,
		rrm_pws_sib_type_scheduled_et  sib_type,	
		S8 		                       *p_si_index,	
		rrm_bool_et                    *shed_pws_data_node_exists,
		rrm_scheduling_info_list_t     *p_current_scheduling_list,
		scheduling_data_key_t          sched_data_key,
		U8                             *p_num_sibs_to_be_scheduled 
		)
{
	YLNODE *p_ylnode = RRM_PNULL; 
	U8 etws_pri_sib_type = RRM_PWS_SIB_TYPE_10;
	U8 etws_sec_sib_type = RRM_PWS_SIB_TYPE_11;
	U8 etws_pri_sec_sib_type = RRM_PWS_SIB_TYPE_10_11;
	U8 num_sibs_already_scheduled = RRM_ZERO;
	YLNODE *p_temp = RRM_PNULL;
	U8 cmas_idx = RRM_ZERO;
	U8 etws_idx = RRM_ZERO;

	/*
	 ** Get the number of SIBS to be scheduled for the new PWS warning request
	 ** - for ETWS Primary notification : 1 SIB i.e. SIB 10 is scheduled
	 ** - for ETWS Secondary notification : 1 SIB i.e. SIB 11 is scheduled
	 ** - for ETWS Primary and Secondary notification : 2 SIBs 
	 **   i.e. SIB 10 and SIB 11 are scheduled.
	 ** - for CMAS notification : 1 SIB i.e. SIB 12 is scheduled
	 */
	if(sib_type != RRM_PWS_SIB_TYPE_10_11)
	{
		*p_num_sibs_to_be_scheduled = RRM_ONE;
	}
	else
	{
		*p_num_sibs_to_be_scheduled = RRM_TWO;
	}

	/*
	 ** Get the SI indexes , for ETWS PRIMARY OR/AND SECONDARY notification.
	 */
	if(sib_type != RRM_PWS_SIB_TYPE_12)
	{
		/*
		 ** If the Same warning msg (i.e. with the same Message Id and Serial Num ) is not
		 ** already scheduled.
		 */
		if((RRM_ZERO == ylFind(&p_cell_ctx->scheduled_etws_warning_list,&sched_data_key,
						rrm_cellm_pws_request_sched_data_key ,rrm_cellm_shed_data_key_compare)))
		{
			/*
			 ** If already an ETWS Notification is scheduled for the cell.
			 */
			if((RRM_ZERO != ( p_ylnode =ylFind(&p_cell_ctx->scheduled_etws_warning_list, &etws_pri_sib_type, 
								rrm_cellm_pws_request_sched_data_sib_type_key ,rrm_cellm_shed_data_sib_type_key_compare)))
					|| (RRM_ZERO != ( p_ylnode =ylFind(&p_cell_ctx->scheduled_etws_warning_list, &etws_sec_sib_type,
								rrm_cellm_pws_request_sched_data_sib_type_key ,rrm_cellm_shed_data_sib_type_key_compare)))
					|| (RRM_ZERO != ( p_ylnode =ylFind(&p_cell_ctx->scheduled_etws_warning_list, &etws_pri_sec_sib_type,
								rrm_cellm_pws_request_sched_data_sib_type_key ,rrm_cellm_shed_data_sib_type_key_compare))))
			{
				*shed_pws_data_node_exists = RRM_TRUE;
				num_sibs_already_scheduled = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.
					num_of_sibs_scheduled;

				/*
				 ** If an ETWS (either Primary or Secondary) notification is scheduled 
				 ** for the cell and NEW ETWS warning request for both Primary & Secondary
				 ** notication is recieved.
				 */
				if( ( *p_num_sibs_to_be_scheduled == RRM_TWO )&&
						( num_sibs_already_scheduled == RRM_ONE ) )
				{
					/*
					 ** Check if CMAS warning is already scheduled with ETWS warning
					 */
					if(p_cell_ctx->scheduled_cmas_warning_list.count)
					{
						p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
						cmas_idx =  ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						etws_idx = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];

						/*
						 ** If ETWS warning is scheduled before CMAS warning , then if the SI indexes for ETWS 
						 ** warning is changed it will also impact the SI indexes for the CMAS warning.
						 */
						if( etws_idx < cmas_idx)
						{  
							/*
							 ** Change the CUREENT SI indexes for the already scheduled CMAS warning,due to the
							 ** shifting of ETWS type of warning.
							 ** - Change the SI indexes of CMAS warning to the SI indexes ,occupied by ETWS warning. 
							 */
							while(p_temp)
              {
                      ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]
                              = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] + RRM_ONE;

                      ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]
                              = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ; 

                      /* DYNAMIC SIB SCHEDULING START */
                      ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity =
                              p_cell_ctx->si_segment_data_sib_scheduling[((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.  
                              si_index[RRM_SI_CURR_START_IDX]].si_segment_periodicity;             
                      /* DYNAMIC SIB SCHEDULING END */
                      p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
              }

							/*
							 ** SI indexes earlier occupied by ETWS type of warning msg are kept in PREV indexes
							 ** and NEW Currently used SI indexes are assigned
							 */
							p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
							p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] + RRM_ONE;
						}
						else
						{
							/*
							 ** SI indexes earlier occupied by ETWS type of warning msg are kept in PREV indexes
							 ** and NEW Currently used SI indexes are assigned
							 */
							p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
							p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
							p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] + RRM_ONE;
						}
					}
					else
					{
						/*
						 ** SI indexes earlier occupied by ETWS type of warning msg are kept in PREV indexes
						 ** and NEW Currently used SI indexes are assigned
						 */
						p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
						p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
						p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] + RRM_ONE;
					}

				}
				/*
				 ** If ETWS warning for both Primary or Secondary notification is scheduled 
				 ** for the cell and NEW ETWS warning request for either Primary or Secondary
				 ** notication is recieved.
				 */
				else if( ( *p_num_sibs_to_be_scheduled == RRM_ONE )&&
						( num_sibs_already_scheduled == RRM_TWO ) )
				{
					if(p_cell_ctx->scheduled_cmas_warning_list.count)
					{
						p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
						cmas_idx =  ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						etws_idx = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];

						if( etws_idx < cmas_idx)
						{  
							while(p_temp)
							{
								((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]
										= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] - RRM_ONE; 

                                ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]
										= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];  

                                /* DYNAMIC SIB SCHEDULING START */
                                ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity =
                                      p_cell_ctx->si_segment_data_sib_scheduling[((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.  
                                                                si_index[RRM_SI_CURR_START_IDX]].si_segment_periodicity;             
                                /* DYNAMIC SIB SCHEDULING END */
								p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
							}

							p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
							p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						}
						else
						{
							p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
							p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
							p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						}
					}
					else
					{
						p_si_index[RRM_SI_PREV_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
						p_si_index[RRM_SI_PREV_END_IDX] =  ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]; 
						p_si_index[RRM_SI_CURR_START_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
						p_si_index[RRM_SI_CURR_END_IDX] = ((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
					}

				}
				/*
				 ** If similar type of ETWS warning request is recived same as the ETWS  
				 ** warning already scheduled for the cell.
				 */
				else
				{
					RRM_MEMCPY(p_si_index,((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index,RRM_FOUR);              
				}
			}
			/*
			 ** First ETWS warning request is recieved for the cell.
			 */
			else
			{
				if( RRM_PWS_SIB_TYPE_10_11 == sib_type )
				{
					p_si_index[RRM_SI_CURR_START_IDX] = p_current_scheduling_list->count; 
					p_si_index[RRM_SI_CURR_END_IDX] = (p_current_scheduling_list->count+RRM_ONE); 
					p_si_index[RRM_SI_PREV_START_IDX] = p_si_index[RRM_SI_CURR_START_IDX]; 
					p_si_index[RRM_SI_PREV_END_IDX] =  p_si_index[RRM_SI_CURR_END_IDX]; 
				}
				else
				{
					p_si_index[RRM_SI_CURR_START_IDX] = p_current_scheduling_list->count;
					p_si_index[RRM_SI_CURR_END_IDX] = p_current_scheduling_list->count;
					p_si_index[RRM_SI_PREV_START_IDX] = p_current_scheduling_list->count;
					p_si_index[RRM_SI_PREV_END_IDX] = p_current_scheduling_list->count;
				}
			}
		}
		/*
		 ** Duplicate ETWS warning request is recieved for the cell.
		 */
		else
		{
			*p_num_sibs_to_be_scheduled = RRM_ZERO;
		}
	}
	else
	{ 
		if((RRM_ZERO == ylFind(&p_cell_ctx->scheduled_cmas_warning_list,&sched_data_key,
						rrm_cellm_pws_request_sched_data_key ,rrm_cellm_shed_data_key_compare)))
		{
			/*
			 ** If already an CMAS Notification is scheduled for the cell.
			 */
			if((RRM_ZERO != ( p_ylnode =ylFind(&p_cell_ctx->scheduled_cmas_warning_list, &sib_type, 
								rrm_cellm_pws_request_sched_data_sib_type_key ,rrm_cellm_shed_data_sib_type_key_compare))))
			{

				RRM_MEMCPY(p_si_index,((scheduled_pws_data_node_t*)p_ylnode)->scheduled_pws_data.si_index,RRM_FOUR);              
				*shed_pws_data_node_exists = RRM_TRUE;
			}
			/*
			 ** First CMAS warning request is recieved for the cell.
			 */
			else
			{
				p_si_index[RRM_SI_CURR_START_IDX] = p_current_scheduling_list->count;
				p_si_index[RRM_SI_CURR_END_IDX] = p_current_scheduling_list->count;
				p_si_index[RRM_SI_PREV_START_IDX] = p_current_scheduling_list->count;
				p_si_index[RRM_SI_PREV_END_IDX] = p_current_scheduling_list->count;
			}
		}
		/*
		 ** Duplicate CMAS warning request is recieved for the cell.
		 */
		else
		{
			*p_num_sibs_to_be_scheduled = RRM_ZERO;
		}
	}
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_scheduling_info_si_periodicity
 * Inputs         : p_sib_sheduling_periodicity_data [data required to
 *                   calculate the periodicty for the ETWS/CMAS SIB]
 * Outputs        : si_periodicity [ perioicty to broadcast the SIB]
 * Returns        : None
 * Description    : Calculates the periodicity for the new ETWS/CMAS 
 *                  SIB10/11/12
 ****************************************************************************/
rrm_void_t rrm_cellm_calculate_si_periodicity(
		sib_sheduling_periodicity_data_t    *p_sib_sheduling_periodicity_data,
		U8					                *p_si_periodicity
		)
{
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(p_sib_sheduling_periodicity_data != RRM_PNULL);
	RRM_ASSERT(p_si_periodicity != RRM_PNULL);

	U32	time_transmit_all_segments = RRM_ZERO;
	U64	max_frequency_of_warning = RRM_ZERO;
	U8 calculated_periodicity = RRM_ZERO; 

	/*
	 ** Get the total time required to transimit the SIB if all the SIB segments 
	 ** are transmiited in consecutive radio frames.
	 ** -- if 2 SIB segments are there , then 2 RF are required for the complete SIB transmission.
	 **    i.e. it will take 20 ms.
	 */   
	time_transmit_all_segments = p_sib_sheduling_periodicity_data->num_of_sib_segments * RRM_FRAME_PERIOD;

	/*
	 ** Get the maximum number of times we can transmit the complete warning message 
	 ** (i.e. all the segments of the SIB) in the configured repetition period for the warning.
	 ** -- if repetition period configured is 1 sec (1000 ms) , Comlete warning message i.e 2 segments
	 **    of SIB can be transmiited 50 times in one repetition period.
	 */  
	max_frequency_of_warning = ((( U64)(p_sib_sheduling_periodicity_data->repetition_period) )*RRM_SEC_TO_MILLI_SEC_CONV)/(time_transmit_all_segments);

	/*
	 ** Convert the max_frequency_of_warning into the power of 2.
	 ** -- 2^5 is approxmately equal to 50 , so calculated periodicity will be 5.
	 */ 
	calculated_periodicity = (U8)(RRM_MATH_LOG(max_frequency_of_warning)/RRM_MATH_LOG(RRM_TWO));

	/*
	 ** Get the periodicty in terms of 0 to 6 as allowed range of periodicity 
	 ** is 0 to 6 i.e. 8RF(2^3) to 512 RF (2^9).
	 ** -- (2^5) will correspond to Periodicty 2 .
	 */
	if( calculated_periodicity >= RRM_THREE )
	{
		*p_si_periodicity = calculated_periodicity - RRM_THREE;
	}
	else
	{
		*p_si_periodicity = RRM_ONE; 
	}

	/*
	 ** Keep the dervied si periodicty within the allowed range
	 */
	if(*p_si_periodicity > RRM_SIX )
	{
		*p_si_periodicity = RRM_SIX;
	}
	if(!(*p_si_periodicity))
	{
		*p_si_periodicity = RRM_ONE;
	}
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cellm_prepare_pws_response
 * Inputs         : p_cell_ctx [Cells context for which PWS response
 *                  is tobe prepared]
 * Outputs        : p_s1ap_rrm_pws_response [Response to be filled]
 * Returns        : rrm_return_et 
 * Description    : Prepares the PWS reponse for the particular cell
 ****************************************************************************/
rrm_return_et
rrm_cellm_prepare_pws_response(
		rrm_cell_context_t          *p_cell_ctx,
		s1ap_rrm_pws_response_t	    *p_s1ap_rrm_pws_response
		)
{
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(p_s1ap_rrm_pws_response != RRM_PNULL);
	RRM_ASSERT(p_cell_ctx != RRM_PNULL);

	rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};	
	U8 cmas_warn_count = RRM_ZERO;
	U8 cell_count = RRM_ZERO; 
	YLNODE *p_temp = RRM_PNULL;
	rrm_pws_sib_type_scheduled_et latest_warning_type = RRM_PWS_SIB_TYPE_UNDEF;
	rrm_bool_et scheduling_updated_for_cmas = RRM_FALSE;
	U8 last_si_idx_range = RRM_ZERO;
	U8  curr_si_idx_range = RRM_ZERO;
	p_cell_ctx->scheduling_info_list_for_pws = (rrm_scheduling_info_list_t*)
		rrm_mem_get(sizeof(rrm_scheduling_info_list_t)); 
    if ( p_cell_ctx->scheduling_info_list_for_pws == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctx->scheduling_info_list_for_pws failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	/*
	 ** Get the copy of the scheduling info present in the cell context.
	 ** Perform all the updations in this list only for the new  
	 ** PWS warnings (ETWS/CMAS).
	 */
	RRM_MEMCPY(&current_sched_info_list, &p_cell_ctx->operator_info.sib_1_info.scheduling_info_list,
			sizeof(rrm_scheduling_info_list_t));
	/*
	 ** Set the bitmask and the response in PWS response structure as PWS 
	 ** request is successfull for at least one cell 
	 */
	p_s1ap_rrm_pws_response->bitmask |= S1AP_RRM_PWS_CONTENTS_LIST_PRESENT; 
	p_s1ap_rrm_pws_response->response = RRM_SUCCESS;

	/*
	 ** Index at whcih the repnse for the particular cell is to be updated. 
	 */
	cell_count = p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.cell_count++;
	p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
		cell_index = p_cell_ctx->cell_index;

	/*
	 ** Get the type of the latest warning request recived.
	 ** Whether its for SIB 10 , SIB 11 , SIB 12 or SIB 10 and SIB 11
	 */
	if(RRM_PNULL != p_cell_ctx->to_be_scheduled_pws_warning)
	{
		latest_warning_type = p_cell_ctx->to_be_scheduled_pws_warning->sib_type;
	}
    else
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                         "to_be_scheduled_pws_warning is null");
    }

    /* SPR 7513 FIX START */
    if(latest_warning_type != RRM_PWS_SIB_TYPE_UNDEF)
    /* SPR 7513 FIX END */
    {
        p_temp = p_cell_ctx->scheduled_etws_warning_list.node.next;
        /*
         ** Set the bitmask for the etws conents if at least one node is present in
         ** the ETWS list or the newly recieved warning request is of ETWS notification 
         */
        if(p_cell_ctx->scheduled_etws_warning_list.count || (latest_warning_type != RRM_PWS_SIB_TYPE_12)) 
        {
            p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
                rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_ETWS_SCHEDULING_INFO_PRESENT;
        }

        /*
         ** If the latest recived PWS request is for ETWS type of warning , then make ETWS related 
         ** PWS response using the "to_be_scheduled_pws_warning" structure.
         */
        if( latest_warning_type != RRM_PWS_SIB_TYPE_12 )
        {
            /*
             ** If 2 SIBS are to be scheduled for ETWS warning i.e. if current 
             ** SI end index is greater than the current SI start index
             */
            if(RRM_PNULL != p_cell_ctx->to_be_scheduled_pws_warning)
            {
                if( p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_END_IDX] >
                        p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX] )
                {
                    if((p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX])
                            >= current_sched_info_list.count )
                    {
                        current_sched_info_list.count++;
                    }

                    if( p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_END_IDX] 
                            >= current_sched_info_list.count  ) 
                    {
                        current_sched_info_list.count++;
                    }
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX]].
                        si_periodicity = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity;
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                        RRM_RRC_SIB_TYPE_10; 

                    /*DYNAMIC SIB SCHEDULING START*/
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_END_IDX]].si_periodicity = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity_second_sib;
                    /*DYNAMIC SIB SCHEDULING END*/
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_END_IDX]].sib_mapping_info.count = RRM_ONE;
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_END_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                        RRM_RRC_SIB_TYPE_11; 
                }
                else
                {
                    /*
                     ** If only 1 SIBS is to be scheduled for ETWS warning i.e. if current 
                     ** SI end index is same as the current SI start index
                     */
                    if((p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX])
                            >= current_sched_info_list.count )
                    {
                        current_sched_info_list.count++;
                    }
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_START_IDX]].si_periodicity = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity;
                    current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                        si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                    if(RRM_PWS_SIB_TYPE_10 == p_cell_ctx->to_be_scheduled_pws_warning->sib_type )
                    {
                        current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->
                            si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                            RRM_RRC_SIB_TYPE_10; 
                    }
                    else
                    {
                        current_sched_info_list.scheduling_info[ p_cell_ctx->to_be_scheduled_pws_warning->
                            si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                            RRM_RRC_SIB_TYPE_11; 
                    }
                }
                /*
                 ** Fill the contents of the scheduled ETWS warning for a particular cell
                 ** - Message Id
                 ** - Serial Number
                 ** - Number of sib segnments
                 */
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.message_identifier,p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.msg_id,
                        (MSG_ID_OCTET_SIZE));
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.serial_number,p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.serial_number,
                        (SERIAL_NUMBER_OCTET_SIZE));

                if(p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments > RRM_ONE)
                {
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.bitmask |= 
                        RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT;
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.num_of_segments 
                        = p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments;
                }

                /*
                 ** Get how many indexes were used by an ETWS warning request earlier then the new ETWS 
                 ** warning request , for which response is being made.
                 ** if earlier , two SI indexes were occupied by ETWS type of warning and now only one
                 ** then decrement the scheduling info list count by 1
                 */
                last_si_idx_range  = ( p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_END_IDX] 
                        - p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_START_IDX] );
                curr_si_idx_range =  (p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_END_IDX] -
                        p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX] );

                if( last_si_idx_range  > curr_si_idx_range) 
                {
                    current_sched_info_list.count--;
                }
            }
        }
        else
        {
            /*
             ** If the latest recived PWS request is NOT for ETWS type of warning , then make ETWS related 
             ** PWS response using the ETWS warning list updated for the last ETWS warning request.
             ** Traverse the ETWS warning list updated for the last ETWS warning request
             ** and update the scheduling info and the ETWS contens in the reponse
             */
            while(p_temp)
            {
                /* 
                 ** Update the scheduling info list with the SIB specified  the new ETWS warning
                 ** 1. If the SI index derived for the new ETWS warning is with in the existing 
                 **    scheduling info lis ,Replace the scheduling info and the etws contents of 
                 **    the existing warning with the new warning.
                 ** 2. Else update the new warning at the end of existing scheduling info list
                 */     

                if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] >
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX])
                {

                    if((((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX])
                            >= current_sched_info_list.count )
                    {
                        current_sched_info_list.count++;
                    }

                    if( ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] 
                            >= current_sched_info_list.count  ) 
                    {
                        current_sched_info_list.count++;
                    }
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].si_periodicity = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity;
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                        RRM_RRC_SIB_TYPE_10; 

                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]].si_periodicity = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity;
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]].sib_mapping_info.count = RRM_ONE;
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                        RRM_RRC_SIB_TYPE_11; 
                }
                else
                {

                    if((((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX])
                            >= current_sched_info_list.count )
                    {
                        current_sched_info_list.count++;
                    }
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].si_periodicity = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity;
                    current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                        scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                    if(RRM_PWS_SIB_TYPE_10 == ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sib_type )
                    {
                        current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                            scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                            RRM_RRC_SIB_TYPE_10; 
                    }
                    else
                    {
                        current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->
                            scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.sib_type[RRM_ZERO] =
                            RRM_RRC_SIB_TYPE_11; 
                    }
                }
                /*
                 ** Fill the contents of the scheduled ETWS warning for a particular cell
                 ** - Message Id
                 ** - Serial Number
                 ** - Number of sib segnments
                 */
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.message_identifier,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,
                        (MSG_ID_OCTET_SIZE));
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.serial_number,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,
                        (SERIAL_NUMBER_OCTET_SIZE));

                if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments > RRM_ONE)
                {
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.bitmask |= 
                        RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT;
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.num_of_segments 
                        = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments;
                }

                last_si_idx_range  = ( ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX] 
                        - ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX] );
                curr_si_idx_range =  (((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] -
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] );

                if( last_si_idx_range  > curr_si_idx_range) 
                {
                    current_sched_info_list.count--;
                }
                p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
            }
        }


        /*
         ** If the latest recived PWS request is for CMAS type of warning , then make CAMS related 
         ** PWS response using the "to_be_scheduled_pws_warning" structure and the CMAS warning list
         ** if 2 CMAS warnings are scheduled.
         */
        if(latest_warning_type == RRM_PWS_SIB_TYPE_12) 
        {
            if(RRM_PNULL != p_cell_ctx->to_be_scheduled_pws_warning)
            {
                if(p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX] >= current_sched_info_list.count)	
                {
                    current_sched_info_list.count++;
                }

                current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX]].si_periodicity 
                    = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity;


                current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                current_sched_info_list.scheduling_info[p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX]].
                    sib_mapping_info.sib_type[RRM_ZERO] = RRM_RRC_SIB_TYPE_12;

                /* 
                 ** scheduling info is updated with cmas warning , no need to further update it 
                 ** for the 2nd CMAS warning
                 */
                scheduling_updated_for_cmas = RRM_TRUE;
                /*
                 ** Fill the contents of all the scheduled CMAS warning for a particular cell
                 ** - Message Id
                 ** - Serial Number
                 ** - Number of sib segnments
                 ** - Number of repettions
                 */
                cmas_warn_count =  p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_warning_count++;

                RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                            cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].message_identifier),
                        p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.msg_id,(MSG_ID_OCTET_SIZE));

                RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                            cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].serial_number),
                        p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));

                p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_segments = 
                    p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments; 
                /* SPR 7523 FIX START*/
                if((p_cell_ctx->scheduled_cmas_warning_list.count == RRM_ONE) && (latest_warning_type == RRM_PWS_SIB_TYPE_12))
                /* SPR 7523 FIX START*/
                {

                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_FOUR; 

                }
                else
                {

                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_ONE; 

                }
            }
        }

        p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
        /*
         ** Set the bitmask for the cmas conents if at least one node is present in
         ** the CMAS list 
         */
        if((latest_warning_type == RRM_PWS_SIB_TYPE_12) || p_cell_ctx->scheduled_cmas_warning_list.count)
        {
            p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
                rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_CMAS_SCHEDULING_INFO_LIST_PRESENT;
        }
        /** Traverse the CMAS warning list updated for the new CMAS warning request
         ** and update the scheduling info and the CMAS contens in the reponse
         */
        while(p_temp)
        {
            /* 
             ** Update the scheduling info list with the SIB specified  the new CMAS warning
             ** 1. If the SI index derived for the new CMAS warning is with in the existing 
             **    scheduling info list ,Replace the scheduling info of the existing warning 
             **    with the new warning ,But cmas contents will have the contents for all the 
             **    CMAS warnings whose broadcast is scheduled.
             ** 2. Else update the new warning at the end of existing scheduling info list
             */     
            if(!scheduling_updated_for_cmas)
            {
                if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] >= current_sched_info_list.count)	
                {
                    current_sched_info_list.count++;
                }

                current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.
                    si_index[RRM_SI_CURR_START_IDX]].si_periodicity 
                    = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity;

                current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].sib_mapping_info.count = RRM_ONE;
                current_sched_info_list.scheduling_info[((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].
                    sib_mapping_info.sib_type[RRM_ZERO] = RRM_RRC_SIB_TYPE_12;
            }

            /*
             ** Fill the contents of all the scheduled CMAS warning for a particular cell
             ** - Message Id
             ** - Serial Number
             ** - Number of sib segnments
             ** - Number of repettions
             */
            cmas_warn_count =  p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                cmas_scheduling_info_list.cmas_warning_count++;

            RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].message_identifier),
                    ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,(MSG_ID_OCTET_SIZE));

            RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].serial_number),
                    ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));

            p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_segments = 
                ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments; 
            /* SPR 7523 FIX START*/
            if((p_cell_ctx->scheduled_cmas_warning_list.count == RRM_ONE) && (latest_warning_type == RRM_PWS_SIB_TYPE_12))
            /* SPR 7523 FIX START*/
            {

                p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_FOUR; 

            }
            else
            {

                p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_ONE; 

            }        
            p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
        }

        /*
         ** Copy the updated Scheduling info list for the cell in the PWS response structure.
         */
        RRM_MEMCPY(&(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list),
                &current_sched_info_list, sizeof(rrm_scheduling_info_list_t));

        /* PWS_SI_TRANSMISSION_OFFSET_CHANGES_START */
        fill_mac_config_scheduling_info_list(p_cell_ctx->operator_info.sib_1_info.si_window_length,
                &(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].si_transmission_info),
                (rrm_scheduling_info_list_t *)&(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list) );

        p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
            rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_SI_TRANSMISSION_INFO_PRESENT ;
        /* PWS_SI_TRANSMISSION_OFFSET_CHANGES_END*/

        /*
         ** Keep the copy of the PWS response being sent to L3 to be used at the time of the 
         ** PWS confirmation
         */
        RRM_MEMCPY(p_cell_ctx->scheduling_info_list_for_pws,&current_sched_info_list ,sizeof(rrm_scheduling_info_list_t));
    }
    /* SPR 7513 FIX START */
    /*
    ** Prepare PWS response in case of DUPLICATE PWS (ETWS/CMAS) warning.
    */
    else
    {
        p_temp = p_cell_ctx->scheduled_etws_warning_list.node.next;

        if(p_cell_ctx->scheduled_etws_warning_list.count) 
        {
            p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
                rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_ETWS_SCHEDULING_INFO_PRESENT;
            while(p_temp)
            {
                /*
                 ** Fill the contents of the scheduled ETWS warning for a particular cell
                 ** - Message Id
                 ** - Serial Number
                 ** - Number of sib segnments
                 */
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.message_identifier,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,
                        (MSG_ID_OCTET_SIZE));
                RRM_MEMCPY(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        etws_scheduling_info.serial_number,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,
                        (SERIAL_NUMBER_OCTET_SIZE));

                if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments > RRM_ONE)
                {
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.bitmask |= 
                        RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT;
                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.num_of_segments 
                        = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments;
                }


                p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
            }
        }

        p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
        if(p_cell_ctx->scheduled_cmas_warning_list.count)
        {
            p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
                rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_CMAS_SCHEDULING_INFO_LIST_PRESENT;
            while(p_temp)
            {
                /*
                 ** Fill the contents of all the scheduled CMAS warning for a particular cell
                 ** - Message Id
                 ** - Serial Number
                 ** - Number of sib segnments
                 ** - Number of repettions
                 */
                cmas_warn_count =  p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_warning_count++;

                RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                            cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].message_identifier),
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,(MSG_ID_OCTET_SIZE));

                RRM_MEMCPY((p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                            cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].serial_number),
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));

                p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                    cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_segments = 
                    ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments; 
                if(p_cell_ctx->scheduled_cmas_warning_list.count > RRM_ONE)
                {

                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_FOUR; 

                }
                else
                {

                    p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
                        cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_ONE; 

                }        
                p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
            }
        }

        /*
         ** Copy the updated Scheduling info list for the cell in the PWS response structure.
         */
        RRM_MEMCPY(&(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list),
                &current_sched_info_list, sizeof(rrm_scheduling_info_list_t));

        /* coverity : CID 41543 */
        /* PWS_SI_TRANSMISSION_OFFSET_CHANGES_START */
        fill_mac_config_scheduling_info_list( (rrm_si_window_length_et)p_cell_ctx->operator_info.sib_1_info.si_window_length,
                &(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].si_transmission_info),
                (rrm_scheduling_info_list_t *)&(p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list) );

        p_s1ap_rrm_pws_response->rrc_rrm_pws_contents_list.
            rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_SI_TRANSMISSION_INFO_PRESENT ;
        /* PWS_SI_TRANSMISSION_OFFSET_CHANGES_END*/
    }

	RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrm_cellm_update_scheduling_info_list
 * Inputs         : p_s1ap_rrm_pws_request [PWS request]
 *		            p_cell_ctx [Global cell Context]
 *                  sib_type [Type of SIB to carry the warning msg]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Updates the scheduling info list
 ****************************************************************************/
rrm_return_et 
rrm_cellm_update_scheduling_info_list(
		s1ap_rrm_pws_request_t      *p_s1ap_rrm_pws_request,
		rrm_cell_context_t          *p_cell_ctx,
		rrm_pws_sib_type_scheduled_et    sib_type
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et ret_val = RRM_SUCCESS;
	RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_request);
	U8 si_periodicity = RRM_ZERO;
/*DYNAMIC SIB SCHEDULING START*/
	U8 si_periodicity_second_sib = RRM_ZERO;
/*DYNAMIC SIB SCHEDULING END*/
	U16 num_of_sib_segments = RRM_ONE;
	S8 si_index[RRM_FOUR] = {RRM_ZERO};
	U8 num_of_sibs_to_be_scheduled = RRM_ZERO;
	sib_sheduling_periodicity_data_t sib_sheduling_periodicity_data = {RRM_ZERO};
	scheduling_data_key_t sched_data_key;
	rrm_bool_et shed_pws_data_node_exists = RRM_FALSE;

	/*
	 ** Prepare a key consisting of Message Id and Serial Nuber to perform the search operations for
	 ** the duplicate scenarios
	 */
	RRM_MEMCPY((sched_data_key.msg_id),p_s1ap_rrm_pws_request->message_identifier,MSG_ID_OCTET_SIZE);
	RRM_MEMCPY((sched_data_key.serial_number),p_s1ap_rrm_pws_request->serial_number,SERIAL_NUMBER_OCTET_SIZE);

	/* 
	 ** Get the SI index to update the scheduling info list for an appropriate
	 ** type of ETWS/CMAS notification. 
	 ** -SIB 10 is for ETWS Primary Notification 
	 ** -SIB 11 is for ETWS Secondary Notification 
	 ** -SIB 10 and SIB 11 for ETWS Primary and Secondary Notification 
	 ** -SIB 10 is for CMAS notification.
	 */
	rrm_cellm_get_scheduling_info_si_index(p_cell_ctx,sib_type,
			si_index, &shed_pws_data_node_exists,
			&(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list), 
			sched_data_key,&num_of_sibs_to_be_scheduled);
    /*
     * ETWS/CMAS request is Duplicate. As per RP-110226(852),
     * SUCCESS to be send in this case.
     */

	if( RRM_ZERO == num_of_sibs_to_be_scheduled )
	{
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                     "Duplicate ETWS/CMAS scheduling Request");
	}
	else /*ETWS /CMAS request is not dupilcate ,will process it further */
	{
		/*
		 ** Calculate number of sib segments required to broadcast the 
		 ** complete warning
		 */
		if(S1AP_RRM_PWS_WARNING_MESSAGE_SIZE & p_s1ap_rrm_pws_request->bitmask)
		{
			num_of_sib_segments = ((p_s1ap_rrm_pws_request->warning_message_size)%SIB_SIZE)?
				(p_s1ap_rrm_pws_request->warning_message_size)/SIB_SIZE + RRM_ONE:
				(p_s1ap_rrm_pws_request->warning_message_size)/SIB_SIZE ;
		}

		/* 
		 ** Gather all the  data required in "sib_sheduling_periodicity_data"
		 ** to  calculate the SI periodicity for a particular SIB
		 */
		sib_sheduling_periodicity_data.sib_type = sib_type;
		sib_sheduling_periodicity_data.bitmask |= NUM_OF_SIB_SEGMENTS_PRESENT;
		sib_sheduling_periodicity_data.num_of_sib_segments = RRM_ONE;
		if(num_of_sib_segments > RRM_ONE)
		{
			sib_sheduling_periodicity_data.num_of_sib_segments = num_of_sib_segments; 
		}

		/* 
		 ** Repetition period is used for the periodicty calculation if 
		 ** Extended repetition period is not specified ,else Extended repetition
		 ** period is used 
		 */
		sib_sheduling_periodicity_data.bitmask |= REPETITION_PERIOD_PRESENT;
		if(p_s1ap_rrm_pws_request->bitmask & S1AP_RRM_PWS_EXTENDED_REPETITION_PERIOD)
		{
			sib_sheduling_periodicity_data.repetition_period = p_s1ap_rrm_pws_request->extended_repetition_period; 
		}
		else
		{
			sib_sheduling_periodicity_data.repetition_period = p_s1ap_rrm_pws_request->repetition_period;
		}
		sib_sheduling_periodicity_data.number_of_broadcast_requested=p_s1ap_rrm_pws_request->number_of_broadcast_requested;
		sib_sheduling_periodicity_data.bitmask |= NUMBER_OF_BROADCAST_REQ_PRESENT;

		/* 
		 ** Pass the gathered data in the below function to
		 ** calculate the periodicity for the sib type 10/11/12
		 */
		//rrm_cellm_calculate_si_periodicity(&sib_sheduling_periodicity_data, &si_periodicity); 
        /* DYNAMIC SIB SCHEDULING START */
        si_periodicity = p_cell_ctx->si_segment_data_sib_scheduling[si_index[RRM_SI_CURR_START_IDX]].si_segment_periodicity;
    
        if( num_of_sibs_to_be_scheduled == RRM_TWO)
        {
           si_periodicity_second_sib = p_cell_ctx->si_segment_data_sib_scheduling[si_index[RRM_SI_CURR_END_IDX]].si_segment_periodicity;
        }
        else
        {
           si_periodicity_second_sib = RRM_OUT_OF_RANGE ;
        }   
        /* DYNAMIC SIB SCHEDULING END */
   
		/*
		 ** Prepare the temp structure to update the list of the  ETWS/CMAS warnings (whose broadcast
		 ** is scheduled) maintained for each cell.
		 */  
		p_cell_ctx->to_be_scheduled_pws_warning = (scheduled_pws_data_t*)
			rrm_mem_get(sizeof(scheduled_pws_data_t)); 
        if ( p_cell_ctx->to_be_scheduled_pws_warning == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_ctx->to_be_scheduled_pws_warning failed" );
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
		RRM_MEMCPY( p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.msg_id, 
				sched_data_key.msg_id, (MSG_ID_OCTET_SIZE));
		RRM_MEMCPY( p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.serial_number, 
				sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));

		p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments = num_of_sib_segments;
		p_cell_ctx->to_be_scheduled_pws_warning->sib_type = sib_type;
		p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity = si_periodicity;
/*DYNAMIC SIB SCHEDULING START*/
		p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity_second_sib = si_periodicity_second_sib ;
/*DYNAMIC SIB SCHEDULING END*/
		p_cell_ctx->to_be_scheduled_pws_warning->broadcast_status = PWS_BROADCAST_UNDEFINED;
		p_cell_ctx->to_be_scheduled_pws_warning->num_of_sibs_scheduled = num_of_sibs_to_be_scheduled;
		RRM_MEMCPY(p_cell_ctx->to_be_scheduled_pws_warning->si_index , si_index ,
				RRM_FOUR);

		if(MAX_CMAS_WARNING_COUNT == p_cell_ctx->scheduled_cmas_warning_list.count && 
				(p_cell_ctx->to_be_scheduled_pws_warning->sib_type == RRM_PWS_SIB_TYPE_12))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Third CMAS warning is not allowed for cell = %d !!!! More than 2 CMAS warnins are not supported",
					p_cell_ctx->cell_index);
			ret_val = RRM_FAILURE;                  
		}
	}
	if (RRM_FAILURE == ret_val)
{
RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "rrm_cellm_update_scheduling_info_list: updation of info list failed ");
}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_process_etws_scheduling_req 
 * Inputs         : p_s1ap_rrm_pws_request [pointer to input PWS Request]
 *                  p_cell_ctx [Cell context for whic request is recieved]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes etws scheduling 
 ****************************************************************************/
rrm_return_et 
rrm_cellm_process_etws_scheduling_req(
		s1ap_rrm_pws_request_t	*p_s1ap_rrm_pws_request, /* Pointer to incoming pws data*/
		rrm_cell_context_t      *p_cell_ctx
		)
{
	RRM_UT_TRACE_ENTER();	
	rrm_return_et ret_val = RRM_SUCCESS;
    /* coverity : CID 29664*/
    rrm_pws_sib_type_scheduled_et  sib_type = RRM_PWS_SIB_TYPE_UNDEF;
	RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_request);

	if ((S1AP_RRM_PWS_WARNING_TYPE & p_s1ap_rrm_pws_request->bitmask) &&
			!(S1AP_RRM_PWS_WARNING_MESSAGE_SIZE & p_s1ap_rrm_pws_request->bitmask))
	{
		/* ETWS primary notification */
		sib_type = RRM_PWS_SIB_TYPE_10;
	}
	else if (!(S1AP_RRM_PWS_WARNING_TYPE & p_s1ap_rrm_pws_request->bitmask) &&
			(S1AP_RRM_PWS_WARNING_MESSAGE_SIZE & p_s1ap_rrm_pws_request->bitmask))
	{
		/* ETWS secondary notification */
		sib_type = RRM_PWS_SIB_TYPE_11;
	}
	else if ((S1AP_RRM_PWS_WARNING_TYPE & p_s1ap_rrm_pws_request->bitmask) &&
			(S1AP_RRM_PWS_WARNING_MESSAGE_SIZE & p_s1ap_rrm_pws_request->bitmask))
	{
		sib_type = RRM_PWS_SIB_TYPE_10_11;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"INVALID ETWS type of warning , neither Primary nor secondary!!!");
	}

	if(RRM_FAILURE == rrm_cellm_update_scheduling_info_list(p_s1ap_rrm_pws_request,p_cell_ctx,sib_type))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Failed to update the scheduling info list of cell = %d !!!! ",
				p_cell_ctx->cell_index);
		ret_val = RRM_FAILURE;
	}
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_process_cmas_scheduling_req
 * Inputs         : p_s1ap_rrm_pws_request[ pointer to input PWS Request]
 *                  p_cell_ctx [Cell context for whic request is recieved]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cmas scheduling
 ****************************************************************************/
rrm_return_et
rrm_cellm_process_cmas_scheduling_req(
		s1ap_rrm_pws_request_t  *p_s1ap_rrm_pws_request, /* Pointer to incoming pws data*/
		rrm_cell_context_t      *p_cell_ctx
		)
{
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_request);
    /* Coverity_ID : 29662 */
	rrm_return_et ret_val = RRM_SUCCESS;

	if(RRM_FAILURE == rrm_cellm_update_scheduling_info_list(p_s1ap_rrm_pws_request,p_cell_ctx,RRM_PWS_SIB_TYPE_12))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Failed to update the scheduling info list of cell = %d!!!! ",
				p_cell_ctx->cell_index);

		ret_val = RRM_FAILURE;
	}
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_update_etws_scheduling_info_list
 * Inputs         : p_s1ap_rrm_pws_cnf[pointer to cnf recieved for PWS Resp]
 *                  p_cell_ctx [Cell context for whic cnf is recieved]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cmas scheduling
 ****************************************************************************/
rrm_return_et
rrm_cellm_update_etws_scheduling_info_list(
		s1ap_rrm_pws_cnf_t  *p_s1ap_rrm_pws_cnf, /* Pointer to incoming pws data*/
		rrm_cell_context_t      *p_cell_ctx
		)
{
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_cnf);
	RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_cnf);
	/* coverity : CID 29662*/
    rrm_return_et ret_val = RRM_FAILURE;
	scheduling_data_key_t shed_data_key;
	U8 res_cell_index = RRM_ZERO;
	YLNODE *p_temp = RRM_PNULL;
	rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};
	scheduled_pws_data_node_t *p_curr_shed_pws_data_node = RRM_PNULL; 
    /*
	 ** Get the copy of the scheduling info present in the cell context.
	 ** Update this list with the PWS warnings (ETWS/CMAS)whose 
	 ** successful confirmation is recieved.
	 */

	RRM_MEMCPY(&shed_data_key.msg_id, p_s1ap_rrm_pws_cnf->message_identifier, (MSG_ID_OCTET_SIZE));
	RRM_MEMCPY(&shed_data_key.serial_number, p_s1ap_rrm_pws_cnf->serial_number, (SERIAL_NUMBER_OCTET_SIZE));

	for(res_cell_index = RRM_ZERO;res_cell_index < p_s1ap_rrm_pws_cnf->pws_broadcast_list.count; res_cell_index++)
	{
		if(p_cell_ctx->cell_index  == p_s1ap_rrm_pws_cnf->pws_broadcast_list.pws_broadcast_cell_resp[res_cell_index].cell_index)
		{
			if(p_cell_ctx->to_be_scheduled_pws_warning && (p_cell_ctx->to_be_scheduled_pws_warning->sib_type != RRM_PWS_SIB_TYPE_12))
			{
				if(!RRM_MEMCMP(&shed_data_key,&(p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key),sizeof(scheduling_data_key_t)))
				{
					/*
					 ** Failure is recived in the confirmation from L3, for the particular warning.
					 ** Remove the warning from the temp structure "to_be_scheduled_pws_warning"
					 ** and no impact is done on the previously scheduled ETWS warnings and
					 ** scheduling info
					 */
					if(RRM_FAILURE == p_s1ap_rrm_pws_cnf->pws_broadcast_list.pws_broadcast_cell_resp[res_cell_index].response)	
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
								"[PWS CNF with FAILURE for ETWS Msg Id [%s] and Serial Num [%s]",
								p_s1ap_rrm_pws_cnf->message_identifier , p_s1ap_rrm_pws_cnf->serial_number);

                        RRM_MEM_FREE(p_cell_ctx->to_be_scheduled_pws_warning);  
						p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					}
					else 
					{	
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
								"[PWS CNF with SUCCESS for ETWS Msg Id [%s] and Serial Num [%s]",
								p_s1ap_rrm_pws_cnf->message_identifier , p_s1ap_rrm_pws_cnf->serial_number);
						/*
						 ** Success is recived in the confirmation from L3, for the particular warning. 
						 ** - Set the braodcast status of the warning in the ETWS list of warnings as broadcast ongoing 
						 ** - Copy the updated scheduling info , of kept at the time of sending response to
						 **   L3 , in the cell's global context
						 ** - Update the PREV SI indexes for the warning with the CURR SI indexes for both
						 **   ETWS and CMAS warnings.
						 ** - ADD the new ETWS warning into the ETWS warning list.
						 ** - Free the temp structure used for storing the new warning request info
						 */
						p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_START_IDX] = 
							p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX] ; 

						p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_END_IDX] = 
							p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_END_IDX] ; 

						RRM_MEMCPY(&current_sched_info_list,p_cell_ctx->scheduling_info_list_for_pws,sizeof(rrm_scheduling_info_list_t));
                        /* Coverity fix 54343 */
                        p_curr_shed_pws_data_node = (scheduled_pws_data_node_t *) rrm_mem_get(sizeof(scheduled_pws_data_node_t));
                        if (p_curr_shed_pws_data_node == RRM_PNULL)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Memory allocation to p_curr_shed_pws_data_node failed" );
                            RRM_UT_TRACE_EXIT();
                            return RRM_FAILURE;
                        }	

						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.sched_data_key.msg_id, 
								p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.msg_id, (MSG_ID_OCTET_SIZE));
						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.sched_data_key.serial_number, 
								p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));
						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.si_index , p_cell_ctx->to_be_scheduled_pws_warning->si_index ,
								RRM_FOUR);
						p_curr_shed_pws_data_node->scheduled_pws_data.num_of_sib_segments = p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments;
						p_curr_shed_pws_data_node->scheduled_pws_data.sib_type = p_cell_ctx->to_be_scheduled_pws_warning->sib_type;
						p_curr_shed_pws_data_node->scheduled_pws_data.si_periodicity = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity;
/*DYNAMIC SIB SCHEDULING START*/
						p_curr_shed_pws_data_node->scheduled_pws_data.si_periodicity_second_sib = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity_second_sib;
/*DYNAMIC SIB SCHEDULING END*/
						p_curr_shed_pws_data_node->scheduled_pws_data.broadcast_status = PWS_BROADCAST_ONGOING;
						p_curr_shed_pws_data_node->scheduled_pws_data.num_of_sibs_scheduled = p_cell_ctx->to_be_scheduled_pws_warning->num_of_sibs_scheduled;

						if(p_cell_ctx->scheduled_etws_warning_list.count)
						{
							ylDelete(&(p_cell_ctx->scheduled_etws_warning_list),
									(YLNODE *)p_cell_ctx->scheduled_etws_warning_list.node.next);
							RRM_MEM_FREE(p_cell_ctx->scheduled_etws_warning_list.node.next);
							ylPushHead(&(p_cell_ctx->scheduled_etws_warning_list),
									(YLNODE *)p_curr_shed_pws_data_node );
						}
						else
						{
							ylPushHead(&(p_cell_ctx->scheduled_etws_warning_list),
									(YLNODE *)p_curr_shed_pws_data_node );
						}

						p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
						while(p_temp)
						{
							((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX]
								= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
							((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX]
								= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] ;
							p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
						}

                        RRM_MEM_FREE(p_cell_ctx->to_be_scheduled_pws_warning);  
						p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					} 
					ret_val = RRM_SUCCESS;

				}
				else 
				{ 
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,"Scheduling not processed successfully");
					if( p_cell_ctx->to_be_scheduled_pws_warning)
					{
                        RRM_MEM_FREE( p_cell_ctx->to_be_scheduled_pws_warning);
						p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					}
					ret_val = RRM_FAILURE;

				}
			}
		}
	}
	/*
	 ** Copy the updated scheduling info list in the cell's global context .
	 */
	if(ret_val)
		RRM_MEMCPY(&(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list),&current_sched_info_list, 
				sizeof(rrm_scheduling_info_list_t));
    /*SPR 17927 Fix Start*/
    /*Code Removed*/
    /*SPR 17927 Fix End*/

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_cellm_update_cmas_scheduling_info
 * Inputs         : p_s1ap_rrm_pws_cnf[pointer to cnf recieved for PWS Resp]
 *                  p_cell_ctx [Cell context for whic cnf is recieved]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cmas scheduling
 ****************************************************************************/
rrm_return_et
rrm_cellm_update_cmas_scheduling_info( s1ap_rrm_pws_cnf_t          *p_s1ap_rrm_pws_cnf, 
                                       rrm_cell_context_t          *p_cell_ctx ,
                                       rrm_scheduling_info_list_t  *current_sched_info_list,
                                       U8                           res_cell_index)
{
    /*Coverity 82805 Fix Start*/
    /*rrm_return_et ret_val = RRM_SUCCESS;*/
    /*Coverity 82805 Fix End*/
	scheduled_pws_data_node_t *p_curr_shed_pws_data_node = RRM_PNULL; 
	YLNODE *p_temp = RRM_PNULL;
    RRM_UT_TRACE_ENTER();    
	//rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};
    if(RRM_FAILURE == p_s1ap_rrm_pws_cnf->pws_broadcast_list.pws_broadcast_cell_resp[res_cell_index].response)	
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
								"[PWS CNF with FAILURE for CMAS Msg Id [%s] and Serial Num [%s]",
								p_s1ap_rrm_pws_cnf->message_identifier , p_s1ap_rrm_pws_cnf->serial_number);
                        RRM_MEM_FREE(p_cell_ctx->to_be_scheduled_pws_warning);  
						p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					}
					else 
					{
						/*
						 ** Success is recived in the confirmation from L3, for the particular warning. 
						 ** - Set the braodcast status of the warning in the CMAS list of warnings as broadcast ongoing 
						 ** - Copy the updated scheduling info , of kept at the time of sending response to
						 **   L3 , in the cell's global context
						 ** - Update the PREV SI indexes for the warning with the CURR SI indexes for
						 **   CMAS warning.
						 ** - ADD the new CMAS warning into the CMAS warning list.
						 ** - Free the temp structure used for storing the new warning request info
						 */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
								"[PWS CNF with SUCCESS for CMAS Msg Id [%s] and Serial Num [%s]",
								p_s1ap_rrm_pws_cnf->message_identifier , p_s1ap_rrm_pws_cnf->serial_number);

						p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_START_IDX] = 
							p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_START_IDX] ;

						p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_PREV_END_IDX] = 
							p_cell_ctx->to_be_scheduled_pws_warning->si_index[RRM_SI_CURR_END_IDX] ;
        RRM_MEMCPY(current_sched_info_list,p_cell_ctx->scheduling_info_list_for_pws,sizeof(rrm_scheduling_info_list_t));

                        /* Coverity fix 54342 start */
                        p_curr_shed_pws_data_node = (scheduled_pws_data_node_t *) rrm_mem_get(sizeof(scheduled_pws_data_node_t));
                        if (p_curr_shed_pws_data_node == RRM_PNULL)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "Memory allocation to p_curr_shed_pws_data_node failed" );
                            RRM_UT_TRACE_EXIT();
                            return RRM_FAILURE;
                        }
                        /* Coverity fix 54342 end */
						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.sched_data_key.msg_id, 
								p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.msg_id, (MSG_ID_OCTET_SIZE));
						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.sched_data_key.serial_number, 
								p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));
						RRM_MEMCPY(p_curr_shed_pws_data_node->scheduled_pws_data.si_index , p_cell_ctx->to_be_scheduled_pws_warning->si_index ,
								RRM_FOUR);
						p_curr_shed_pws_data_node->scheduled_pws_data.num_of_sib_segments = p_cell_ctx->to_be_scheduled_pws_warning->num_of_sib_segments;
						p_curr_shed_pws_data_node->scheduled_pws_data.sib_type = p_cell_ctx->to_be_scheduled_pws_warning->sib_type;
						p_curr_shed_pws_data_node->scheduled_pws_data.si_periodicity = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity;
/*DYNAMIC SIB SCHEDULING START*/
						p_curr_shed_pws_data_node->scheduled_pws_data.si_periodicity_second_sib = p_cell_ctx->to_be_scheduled_pws_warning->si_periodicity_second_sib;
/*DYNAMIC SIB SCHEDULING END*/
						p_curr_shed_pws_data_node->scheduled_pws_data.broadcast_status = PWS_BROADCAST_ONGOING;
						p_curr_shed_pws_data_node->scheduled_pws_data.num_of_sibs_scheduled = p_cell_ctx->to_be_scheduled_pws_warning->num_of_sibs_scheduled;


						p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
						while(p_temp)
						{
							((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX]
								= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
							((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX]
								= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] ;
							p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
						}


						ylPushHead(&(p_cell_ctx->scheduled_cmas_warning_list),
								(YLNODE *)p_curr_shed_pws_data_node );

                        RRM_MEM_FREE(p_cell_ctx->to_be_scheduled_pws_warning);  
						p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					}
  RRM_UT_TRACE_EXIT();
  /*Coverity 82805 Fix Start*/
  return RRM_SUCCESS;
  /*Coverity 82805 Fix End*/
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrm_cellm_update_cmas_scheduling_info_list
 * Inputs         : p_s1ap_rrm_pws_cnf[pointer to cnf recieved for PWS Resp]
 *                  p_cell_ctx [Cell context for whic cnf is recieved]
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes cmas scheduling
 ****************************************************************************/
rrm_return_et
rrm_cellm_update_cmas_scheduling_info_list(
        s1ap_rrm_pws_cnf_t  *p_s1ap_rrm_pws_cnf, /* Pointer to incoming pws data*/
        rrm_cell_context_t      *p_cell_ctx
        )
{
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_cnf);
    RRM_ASSERT(RRM_PNULL != p_s1ap_rrm_pws_cnf);
    rrm_return_et ret_val = RRM_FAILURE;
    scheduling_data_key_t shed_data_key;
    U8 res_cell_index = RRM_ZERO;

	rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};
    /*
	 ** Get the copy of the scheduling info present in the cell context.
	 ** Update this list with the new  PWS warnings (ETWS/CMAS) and copy
	 ** this list in the reponse for a particular cell
	 */

	RRM_MEMCPY(&shed_data_key.msg_id, p_s1ap_rrm_pws_cnf->message_identifier,(MSG_ID_OCTET_SIZE));
	RRM_MEMCPY(&shed_data_key.serial_number, p_s1ap_rrm_pws_cnf->serial_number,(SERIAL_NUMBER_OCTET_SIZE));

	for(res_cell_index = RRM_ZERO ;res_cell_index < p_s1ap_rrm_pws_cnf->pws_broadcast_list.count; res_cell_index++)
	{
		if(p_cell_ctx->cell_index  == p_s1ap_rrm_pws_cnf->pws_broadcast_list.pws_broadcast_cell_resp[res_cell_index].cell_index)
		{
			if(p_cell_ctx->to_be_scheduled_pws_warning && (p_cell_ctx->to_be_scheduled_pws_warning->sib_type == RRM_PWS_SIB_TYPE_12))
			{
				if(!RRM_MEMCMP(&shed_data_key,&(p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key),sizeof(scheduling_data_key_t)))
				{
					/*
					 ** Failure is recived in the confirmation from L3, for the particular warning.
					 ** Remove the warning from the temp structure "to_be_scheduled_pws_warning"
					 ** and no impact is done on the previously scheduled CMAS warnings and
                     ** scheduling info
                     */

                    /*Klockwork_fix_start*/
                    ret_val = rrm_cellm_update_cmas_scheduling_info( p_s1ap_rrm_pws_cnf ,p_cell_ctx ,
                                                           &current_sched_info_list, res_cell_index);
                    if(ret_val == RRM_FAILURE)
                    {
                        /* SPR 21251 Start */
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "unable to update cmas scheduling info for cell_index: %d", p_cell_ctx->cell_index);
                        /* SPR 21251 End */
                        RRM_UT_TRACE_EXIT();
                        return RRM_FAILURE;

                    }  
                    /*Klockwork_fix_end*/
					ret_val = RRM_SUCCESS;
				}
				else
				{
					/* SPR 21251 Start */
                    			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    				"shed_data_key received in incoming pws warning: %d is not equal to the shed_data_key stored in cell context: %d",
                    				shed_data_key, p_cell_ctx->to_be_scheduled_pws_warning->sched_data_key);
                    			/* SPR 21251 End */

					/* Confirmation came for wrong MSG iD and Serial num */	
					if(p_cell_ctx->to_be_scheduled_pws_warning)
					{
               				         RRM_MEM_FREE( p_cell_ctx->to_be_scheduled_pws_warning);
						 p_cell_ctx->to_be_scheduled_pws_warning = RRM_PNULL;
					}
          				ret_val = RRM_FAILURE;
				}
			}	
			break;
		}
	}
	/*
	 ** Copy the updated scheduling info list in the cell's global context .
	 */
	if(ret_val)
		RRM_MEMCPY(&(p_cell_ctx->operator_info.sib_1_info.scheduling_info_list),&current_sched_info_list, 
				sizeof(rrm_scheduling_info_list_t));

    /*SPR 17927 Fix Start*/
    /*Code Removed*/
    /*SPR 17927 Fix End*/
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

rrm_void_t
rrm_cellm_revert_requested_pws_req(
		scheduling_data_key_t *p_shed_data_key
		)
{
	RRM_UT_TRACE_ENTER();
	U8 context_index = RRM_ZERO;

	while (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
	{
		if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->to_be_scheduled_pws_warning)
		{
			if(!RRM_MEMCMP(p_shed_data_key,&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->to_be_scheduled_pws_warning->sched_data_key),sizeof(scheduling_data_key_t)))
			{
				RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->to_be_scheduled_pws_warning);  
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->to_be_scheduled_pws_warning = RRM_PNULL;
			}

		}
        /* SPR 7513 FIX START */
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Confirmation recieved for Duplicate ETWS/CMAS warning request.No need to revert the scheduling data");
        }
        /* SPR 7513 FIX START */

		if(!((p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])->scheduled_etws_warning_list.count) 
				&&!((p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])->scheduled_cmas_warning_list.count))
		{
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate = PWS_IDLE;
			CELL_M_FSM_SET_STATE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index], CELL_STATE_ACTIVE);

			RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->scheduling_info_list_for_pws);  
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->scheduling_info_list_for_pws = RRM_PNULL;
		}
		else
		{
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate = PWS_ONGOING_ACTIVE;
		}

		context_index++;
	}/*end of while*/
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_rrc_s1ap_pws_cnf_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes pws request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_pws_cnf_process_msg(
		U8      *p_api, /* Pointer to incoming Api buffer*/
		U16     api_id, /* incoming api id*/
		U16     data_len, /* incoming data length*/
		U16     trans_id /* Incoming transaction Id*/
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et ret_val = RRM_SUCCESS;
    /* Coverity_ID : 16363 */
	rrm_return_et response = RRM_FAILURE;
	s1ap_rrm_pws_cnf_t *p_s1ap_rrm_pws_cnf = RRM_PNULL;
    /* BUG_11576_FIX_START */
    /* Code Deleted */
    /* BUG_11576_FIX_END */

    U8 cell_index_loop = RRM_ZERO;
    U8 in_cell_index = RRM_ZERO;
    U8	context_index = RRM_ZERO;
    S32 length =  RRM_ZERO;
    scheduling_data_key_t shed_data_key;

    /* BUG_11576_FIX_START */
	p_s1ap_rrm_pws_cnf = (s1ap_rrm_pws_cnf_t *)rrm_mem_get(sizeof(s1ap_rrm_pws_cnf_t));

    if(RRM_PNULL == p_s1ap_rrm_pws_cnf) /* Coverity: CID 16291 */
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
            "Unable to allocate memory to p_s1ap_rrm_pws_cnf");
        return RRM_FAILURE;
    }
    /* BUG_11576_FIX_END */
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_pws_cnf(
				p_s1ap_rrm_pws_cnf,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"RRC->RRM:S1AP_RRM_PWS_CNF failed to parse");
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"RRC->RRM:S1AP_RRM_PWS_CNF successfully parsed");

		if(S1AP_RRM_PWS_BROADCAST_LIST_PRESENCE_FLAG & p_s1ap_rrm_pws_cnf->bitmask)
		{
			for(cell_index_loop = RRM_ZERO ;cell_index_loop < p_s1ap_rrm_pws_cnf->pws_broadcast_list.count; cell_index_loop++)
			{
				in_cell_index = p_s1ap_rrm_pws_cnf->pws_broadcast_list.pws_broadcast_cell_resp[cell_index_loop].cell_index;

				/* Finding the context of the cell in accordence with cell_index */
				context_index = RRM_ZERO;
			    /* SPR 10812 FIX START */
                while(context_index < RRM_MAX_NUM_CELLS )
                {
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
                    {
                        SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "PWS_CNF: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);

                        if(in_cell_index == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_CNF: cell ID [%d] matches with broadcast_cancellation_list id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    in_cell_index);
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_pws_cnf;
/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->api_id = S1AP_RRM_PWS_CNF;
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->ongoing_trans_id = trans_id;
                            print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                            if (PWS_W_FOR_PWS_CNF == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate)
						{
							if(RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_PWS_CNF_EVENT,
                                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])))
							{
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
										"[PWS CNF with unexpexted msg_id and serial num received ] Invalid Cnf for Cell Index : %d",
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);            
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
							}
							else if(response == RRM_CELL_INVALID_STATE_FOR_PWS )
							{
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
										" PWS response RRM_CELL_INVALID_STATE_FOR_PWS received for cell index: %d",
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);            
								return RRM_FAILURE;                     
							}
							else
							{

                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
										"Cell [%d] is in substate [%d] after successfull PWS CNF AND API ID %d is processed!!",
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate,api_id);
							}
						}
						else
						{
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
									"Invalid cell substate for PWS CNF -> cell id [%d] cell_state[%d]",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
						}
						//}
                            print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                            break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_CNF: cell ID [%d] Does Not match with broadcast_cancellation_list id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    in_cell_index);
                        }
                    }
                    else
                    {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_CNF: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
                    } 
                    context_index ++;	
				}
			    /* SPR 10812 FIX END */
			}
		}
		else
		{
			RRM_MEMCPY(&shed_data_key.msg_id, p_s1ap_rrm_pws_cnf->message_identifier,(MSG_ID_OCTET_SIZE));
			RRM_MEMCPY(&shed_data_key.serial_number, p_s1ap_rrm_pws_cnf->serial_number,(SERIAL_NUMBER_OCTET_SIZE));
			/* failure scenario */
			rrm_cellm_revert_requested_pws_req(&shed_data_key);
		}
	}

    RRM_MEM_FREE(p_s1ap_rrm_pws_cnf);
	RRM_UT_TRACE_EXIT();
	return ret_val;

}

/****************************************************************************
 * Function Name  : rrm_cellm_get_plmn_info_from_plmn_id 
 * Inputs         : s1ap_plmn_id [3 bytes PLMN id recieved from S1AP]
 * Outputs        : p_rrm_s1ap_plmn_info  [converted PLMN id in mcc,mnc format]
 * Returns        : None 
 * Description    : This function converts 3 bytes the PLMN id in MCC , MNC
 *                  format.
 ****************************************************************************/
rrm_void_t
rrm_cellm_get_plmn_info_from_plmn_id(
		U8 *s1ap_plmn_id,
		rrm_oam_cell_plmn_info_t *p_rrm_s1ap_plmn_info
		)
{
	RRM_UT_TRACE_ENTER();

	/* *
	 * -The Selected PLMN identity consists of 3 digits from MCC
	 * followed by either
	 * -a filler digit plus 2 digits from MNC (in case of 2 digit MNC) or
	 * -3 digits from MNC (in case of a 3 digit MNC).
	 * */

	/* PLMN Identity 1st octet : Pack first 2 digits of MCC */
	p_rrm_s1ap_plmn_info->mcc[RRM_ZERO] =
		(s1ap_plmn_id[RRM_ZERO] & RRM_LOW_NIBBLE);
	p_rrm_s1ap_plmn_info->mcc[RRM_ONE] =
		(s1ap_plmn_id[RRM_ZERO] & RRM_HIGH_NIBBLE) >> RRM_FOUR;

	/* PLMN Identity 2nd octet: Pack 3rd digit of MCC */
	p_rrm_s1ap_plmn_info->mcc[RRM_TWO] =
		(s1ap_plmn_id[RRM_ONE] & RRM_LOW_NIBBLE);

	/* if filler digit */
	if ((s1ap_plmn_id[RRM_ONE] & RRM_HIGH_NIBBLE) == RRM_HIGH_NIBBLE)
	{
		p_rrm_s1ap_plmn_info->num_mnc_digit = RRM_TWO;

		/* PLMN Identity 3rd octet : 1st and 2nd digit of MNC */
		p_rrm_s1ap_plmn_info->mnc[RRM_ZERO] =
			(s1ap_plmn_id[RRM_TWO] & RRM_LOW_NIBBLE);
		p_rrm_s1ap_plmn_info->mnc[RRM_ONE] =
			(s1ap_plmn_id[RRM_TWO] & RRM_HIGH_NIBBLE) >> RRM_FOUR ;
		p_rrm_s1ap_plmn_info->mnc[RRM_TWO] =RRM_ZERO;

	}
	else
	{
		/* PLMN Identity 3rd octet : Pack 1st digit of MNC */
		p_rrm_s1ap_plmn_info->num_mnc_digit = RRM_THREE;

		p_rrm_s1ap_plmn_info->mnc[RRM_ZERO] =
			(s1ap_plmn_id[RRM_ONE] & RRM_HIGH_NIBBLE) >> RRM_FOUR;
		/* PLMN Identity 3rd octet : 2nd and 3rd digit of MNC */
		p_rrm_s1ap_plmn_info->mnc[RRM_ONE] =
			(s1ap_plmn_id[RRM_TWO] & RRM_LOW_NIBBLE);
		p_rrm_s1ap_plmn_info->mnc[RRM_TWO] =
			(s1ap_plmn_id[RRM_TWO] & RRM_HIGH_NIBBLE) >> RRM_FOUR;
	}
}

/****************************************************************************
 * Function Name  : rrm_cellm_match_plmn_with_s1ap 
 * Inputs         : p_rrm_s1ap_plmn_info [PLMN id recieved from s1ap in any
 *                  pws request]
 *                  p_rrm_cell_plmn_info [PLMN id maintained at RRM for a
 *                  particular cell]
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE 
 * Description    : This function compares the PLMN info from S1AP with the 
 *                  PLMN info of the cell.
 ****************************************************************************/
rrm_bool_et
rrm_cellm_match_plmn_with_s1ap( 
		rrm_oam_cell_plmn_info_t *p_rrm_s1ap_plmn_info, 
		rrm_oam_cell_plmn_info_t *p_rrm_cell_plmn_info
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_bool_et ret_val = RRM_FALSE;

	/* SPR 11228 Fix Start */
	if(!RRM_MEMCMP(p_rrm_s1ap_plmn_info ,p_rrm_cell_plmn_info ,sizeof(rrm_oam_cell_plmn_info_t)))
	{
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			     " PLMN ID in PWS req is same as S1AP PLMID ");
		ret_val = RRM_TRUE;
	}
	else
    {
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			     " PLMN ID in PWS req is NOT same as S1AP PLMID ");
        /* SPR 21251 End */
    }
    /* SPR 11228 Fix End */

	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_cell_index_for_pws_cell_id 
 * Inputs         : p_cell_id_list [ list of cell Ids 
 *                  the request is to be processed]
 * Outputs        : p_requested_cell_list [ List of cells with the cell
 *                  ids and plmn id same as requested cell ids and PLMN id]
 *                  p_requested_cell_count [no. of requested cells]
 * Returns        : rrm_return_et 
 * Description    : Prepares a list of cells corresponding to the the 
 *                  requested cell Ids and PLMN id's.
 ****************************************************************************/
rrm_return_et rrm_cellm_get_cell_index_for_pws_cell_id(
		cell_id_list_t *p_cell_id_list,
		U8 *p_requested_cell_list,
		U8 *p_requested_cell_count
		)
{
	RRM_UT_TRACE_ENTER();
	U8 cell_count    =  RRM_ZERO;
	U8 context_index = RRM_ZERO;
	U8 valid_cell_count = RRM_ZERO;
	U8 requested_cell_id[MAX_CELL_IDENTITY_OCTETS] = {RRM_ZERO};
	U8 existing_cell_id[MAX_CELL_IDENTITY_OCTETS] = {RRM_ZERO};
	rrm_oam_cell_plmn_info_t *p_rrm_s1ap_plmn_info = RRM_PNULL;
    /* SPR 11228 Fix Start */
	rrm_oam_cell_plmn_info_t *p_rrm_cell_plmn_info = RRM_PNULL; 
    /* SPR 11228 Fix End */

	p_rrm_s1ap_plmn_info = (rrm_oam_cell_plmn_info_t *)rrm_mem_get(sizeof(rrm_oam_cell_plmn_info_t));
    if (p_rrm_s1ap_plmn_info == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation for p_rrm_s1ap_plmn_info failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

	for(cell_count = RRM_ZERO ; cell_count < (p_cell_id_list->count) ; cell_count++)
	{
		RRM_MEMCPY(requested_cell_id , p_cell_id_list->eutran_cgi[cell_count].cell_identity ,
				sizeof(requested_cell_id));
		context_index = RRM_ZERO;
	    
        /* SPR 11228 Fix Start */
        while(context_index  < RRM_MAX_NUM_CELLS)
        {
            if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_REQ_CELL_ID_LIST: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                RRM_MEMCPY(existing_cell_id ,(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->global_cell_id.cell_identity)
					,sizeof(requested_cell_id));

			if(!RRM_MEMCMP(requested_cell_id , existing_cell_id , MAX_CELL_IDENTITY_OCTETS))        
			{
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "CELL ID in PWS request Matched with cell index %d at RRM",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
               
                    p_rrm_cell_plmn_info = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->global_cell_id.
                                                                                              primary_plmn_id);
 
				rrm_cellm_get_plmn_info_from_plmn_id(p_cell_id_list->eutran_cgi[cell_count].plmn_identity.plmn_id ,
						p_rrm_s1ap_plmn_info); 
				if( RRM_TRUE == rrm_cellm_match_plmn_with_s1ap(p_rrm_s1ap_plmn_info, p_rrm_cell_plmn_info) )
				{
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "CELL found with cell index %d ",p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
					p_requested_cell_list[valid_cell_count] = context_index;
					valid_cell_count++;
					break;          
				}
			}
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PWS_REQ_CELL_ID_LIST: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
            }
            context_index++;
        }

        if(!valid_cell_count)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Requested Cell in PWS CELL ID list at pos [%d] is not configured...",cell_count);
		}
	    /* SPR 11228 Fix End */
	}
	*p_requested_cell_count = valid_cell_count;
    RRM_MEM_FREE(p_rrm_s1ap_plmn_info);
    return RRM_SUCCESS;
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_cell_index_for_pws_tac_id
 * Inputs         : tracking_area_id_list [ list of tracking area Ids 
 *                  the request is to be processed]
 * Outputs        : p_requested_cell_list [ List of cells with the tac 
 *                  ids and PLMN id same as requested tac and plmn ids]
 *                  p_requested_cell_count [no. of requested cells]
 * Returns        : rrm_return_et 
 * Description    : Prepares a list of cells corresponding to the the 
 *                  requested Tac Ids and PLMN id's.
 ****************************************************************************/
rrm_return_et rrm_cellm_get_cell_index_for_pws_tac_id(
		tracking_area_id_list_t *tracking_area_id_list,
		U8 *p_requested_cell_list,
		U8 *p_requested_cell_count
		)
{
	RRM_UT_TRACE_ENTER();
	U8 cell_count    =  RRM_ZERO;
	U8 context_index = RRM_ZERO;
	U8 valid_cell_count = RRM_ZERO;
	U8 requested_tac_id[MAX_TAC_SIZE] = {RRM_ZERO};
	U8 existing_tac_id[MAX_TAC_SIZE] = {RRM_ZERO};
	rrm_oam_cell_plmn_info_t *p_rrm_s1ap_plmn_info = RRM_PNULL;
	/* SPR 11228 Fix Start */
	rrm_oam_cell_plmn_info_t *p_rrm_cell_plmn_info = RRM_PNULL; 
	/* SPR 11228 Fix End */

	p_rrm_s1ap_plmn_info = (rrm_oam_cell_plmn_info_t*)rrm_mem_get(sizeof(rrm_oam_cell_plmn_info_t));
    if ( p_rrm_s1ap_plmn_info == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation for p_rrm_s1ap_plmn_info failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

	for(cell_count = RRM_ZERO ; cell_count < (tracking_area_id_list->count) ; cell_count++)
	{
		RRM_MEMCPY(requested_tac_id ,tracking_area_id_list->tracking_area_identifier[cell_count].tracking_area_code,
				sizeof(requested_tac_id));
		context_index = RRM_ZERO;
	    /* SPR 11228 Fix Start */
        while(context_index  < RRM_MAX_NUM_CELLS)
        {
            if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_REQ_TAC_ID_LIST: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
	
                RRM_MEMCPY(existing_tac_id ,p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->epc_info
					.epc_params.general_epc_params.tac,sizeof(existing_tac_id));

			if(!RRM_MEMCMP(requested_tac_id ,existing_tac_id ,MAX_TAC_SIZE))        
			{
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "TAC ID in PWS request Matched with cell index %d at RRM",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                    p_rrm_cell_plmn_info = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->global_cell_id.primary_plmn_id);

				rrm_cellm_get_plmn_info_from_plmn_id((tracking_area_id_list->tracking_area_identifier[cell_count].plmn_identity.plmn_id),
						p_rrm_s1ap_plmn_info); 
				if( RRM_TRUE == rrm_cellm_match_plmn_with_s1ap(p_rrm_s1ap_plmn_info, p_rrm_cell_plmn_info) )
				{
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "CELL found with cell index %d ",p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
					p_requested_cell_list[valid_cell_count] = context_index;
					valid_cell_count++;
					break;          
				}
			}
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PWS_REQ_TAC_ID_LIST: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
            }
            context_index++;
        }
		if(!valid_cell_count)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Requested TAC ID in PWS TAC ID list at pos [%d] is not configured...",cell_count);
		}
	    /* SPR 11228 Fix End */
	}
	*p_requested_cell_count = valid_cell_count;
    RRM_MEM_FREE(p_rrm_s1ap_plmn_info);
    return RRM_SUCCESS;
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_cell_index_for_pws_emrgncy_id
 * Inputs         : emergency_area_id_list [ list of emergency area Ids 
 *                  the request is to be processed ]
 * Outputs        : p_requested_cell_list [ List of cells with the emergency
 *                  ids same as requested emergency ids]
 *                  p_requested_cell_count [no. of requested cells]
 * Returns        : None 
 * Description    : Prepares a list of cells corresponding to the the 
 *                  requested emergency area Ids.
 ****************************************************************************/
rrm_void_t rrm_cellm_get_cell_index_for_pws_emrgncy_id(
		emergency_area_id_list_t *emergency_area_id_list,
		U8 *p_requested_cell_list,
		U8 *p_requested_cell_count
		)
{
	RRM_UT_TRACE_ENTER();

	U8 context_index = RRM_ZERO;
	U8 valid_cell_count = RRM_ZERO;
	U8 requested_ea_id[MAX_EAID] = {RRM_NULL};
	U8 emergency_area_count = RRM_ZERO;
	U8 existing_ea_id[MAX_EAID] = {RRM_NULL};
	U8 max_no_emergency_area = RRM_ZERO;

	max_no_emergency_area = emergency_area_id_list->count;
	for(emergency_area_count = RRM_ZERO ; emergency_area_count < max_no_emergency_area ; emergency_area_count++)
	{
		RRM_MEMCPY(requested_ea_id ,emergency_area_id_list->emer_id[emergency_area_count].emergency_area_id,
				sizeof(requested_ea_id));
		context_index = RRM_ZERO;
	    /* SPR 11228 Fix Start */
        while(context_index  < RRM_MAX_NUM_CELLS)
        {
            if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_REQ_EA_ID_LIST: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                RRM_MEMCPY(existing_ea_id ,p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->epc_info.epc_params.general_epc_params.eaid,
					sizeof(existing_ea_id));
			if (!(RRM_MEMCMP(requested_ea_id, existing_ea_id, MAX_EAID)))
			{

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "CELL found with cell index %d ",p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
				p_requested_cell_list[valid_cell_count] = context_index;
				valid_cell_count++;
				break;          
			}
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PWS_REQ_EA_ID_LIST: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
            }
            context_index++;
        }
        if(!valid_cell_count)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Requested EA ID in PWS EA ID list at pos [%d] is not configured...",emergency_area_count);
		}
	    /* SPR 11228 Fix End */
	}
	*p_requested_cell_count = valid_cell_count;
}

rrm_return_et
rrm_cellm_check_for_no_broadcast(
		s1ap_rrm_pws_request_t *p_s1ap_rrm_pws_request
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et ret_val = RRM_FAILURE;


	if(!(p_s1ap_rrm_pws_request->bitmask & S1AP_RRM_PWS_WARNING_TYPE))
	{
		if((p_s1ap_rrm_pws_request->repetition_period == RRM_ZERO) &&
				(p_s1ap_rrm_pws_request->number_of_broadcast_requested == RRM_ZERO))
		{
			ret_val = RRM_SUCCESS;
		}
		else if((p_s1ap_rrm_pws_request->repetition_period)
				&& (p_s1ap_rrm_pws_request->number_of_broadcast_requested == RRM_ZERO)
				&& !(p_s1ap_rrm_pws_request->bitmask & S1AP_RRM_PWS_CONCURRENT_WARNING_MSG_INDICATOR))
		{
			ret_val = RRM_SUCCESS; 
		}
		else
		{
			/* DO Nothing*/
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					" Broadcast is required!! ");
		}
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_rrc_s1ap_pws_req_process_msg_area_list
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes pws request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_pws_req_process_msg_area_list( U8                      *requested_cell_index_list ,
                                            U8                      requested_cell_count ,
                                            U8                      *cell_context_index ,
                                            U8                      *success_cell_index_list ,
                                            U8                      *success_cell_index_count ,
                                            /*SPR FIX 12567 START*/
                                            s1ap_rrm_pws_request_t  **p_s1ap_rrm_pws_request ,
                                            /*SPR FIX 12567 END*/
                                            s1ap_rrm_pws_response_t *p_s1ap_rrm_pws_response ,
                                            U16                     trans_id ,
                                            U16                     api_id )
{
    U8 valid_cell_count = RRM_ZERO;
    rrm_return_et response = RRM_FAILURE;
    rrm_return_et  ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    for(valid_cell_count = RRM_ZERO ;
            (valid_cell_count < (requested_cell_count)) && ((*success_cell_index_count) < RRM_MAX_NUM_CELLS);
            valid_cell_count++)
    {
        (*cell_context_index) = requested_cell_index_list[valid_cell_count];
        /*SPR FIX 12567 START*/
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->p_incoming_api_info = (rrm_void_t *) (*p_s1ap_rrm_pws_request);
        /*SPR FIX 12567 END*/

        p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->api_id = S1AP_RRM_PWS_REQ;
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->ongoing_trans_id = trans_id;	

        print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]);
        if((PWS_W_FOR_KILL_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->pws_substate )
                && (PWS_W_FOR_UPDATE_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->pws_substate )
                && (PWS_W_FOR_PWS_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->pws_substate)) 
        {
            response = cellm_fsm_process_event( RRC_RRM_PWS_REQ_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]);
            if(RRM_FAILURE == response)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "Failure in processing request[%u] received",
                        api_id);
                /*SPR FIX 12567 START*/
                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->p_incoming_api_info = RRM_PNULL;
                 /*SPR FIX 12567 END*/

            }
            else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
            {
                /*SPR FIX 12567 START*/
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        " Due to invalid state of cell,failure response is sent by rrm for cell index[%d]",
                        *cell_context_index);
                *p_s1ap_rrm_pws_request = RRM_PNULL;
                p_s1ap_rrm_pws_response->bitmask = RRM_ZERO;
                break;
                /*SPR FIX 12567 END*/
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                        "successfully processed api:%d",api_id);
                success_cell_index_list[(*success_cell_index_count)++] = (*cell_context_index);  	
                /*Prepare response for particular cell*/
                rrm_cellm_prepare_pws_response(p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)], 
                        p_s1ap_rrm_pws_response);
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                    "Invalid cell substate for PWS req-> cell id [%d] cell_state[%d]",
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->cell_index,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->pws_substate);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[(*cell_context_index)]->p_incoming_api_info = RRM_PNULL;
            ret_val = RRM_FAILURE;
        }
    }
    RRM_UT_TRACE_EXIT();
    return  ret_val; 
}
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrm_rrc_s1ap_pws_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	              : U16 api_id :api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes pws request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_pws_req_process_msg(
		U8      *p_api, /* Pointer to incoming Api buffer*/
		U16      api_id, /* incoming api id*/
		U16      data_len, /* incoming data length*/
		U16      trans_id /* Incoming transaction Id*/
		)
{
	RRM_UT_TRACE_ENTER();
	S32  length = RRM_ZERO;
    /* Coverity_ID : 16363 */
	rrm_return_et response = RRM_FAILURE;
	rrm_return_et  ret_val = RRM_SUCCESS;
	U8 cell_context_index = RRM_ZERO;
	U8 success_cell_index_count = RRM_ZERO;
	U8 success_cell_index_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};
	U8 requested_cell_index_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};
	U8 requested_cell_count = RRM_ZERO;
	U8 valid_cell_count = RRM_ZERO;
	s1ap_rrm_pws_response_t *p_s1ap_rrm_pws_response = RRM_PNULL;
	s1ap_rrm_pws_request_t  *p_s1ap_rrm_pws_request = RRM_PNULL;

	p_s1ap_rrm_pws_response = (s1ap_rrm_pws_response_t *)rrm_mem_get(sizeof(s1ap_rrm_pws_response_t));
	if (p_s1ap_rrm_pws_response == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_s1ap_rrm_pws_response failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_MEMSET(p_s1ap_rrm_pws_response, RRM_NULL,sizeof(s1ap_rrm_pws_response_t));
	p_s1ap_rrm_pws_request = (s1ap_rrm_pws_request_t*)rrm_mem_get(sizeof
			(s1ap_rrm_pws_request_t));
    if (p_s1ap_rrm_pws_request == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_s1ap_rrm_pws_request failed" );
        RRM_UT_TRACE_EXIT();
        RRM_MEM_FREE(p_s1ap_rrm_pws_response);
        return RRM_FAILURE;
    }


	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_pws_request(
				p_s1ap_rrm_pws_request,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"RRC->RRM:S1AP_RRM_PWS_REQ failed to parse");
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"RRC->RRM:S1AP_RRM_PWS_REQ successfully parsed");

		if(RRM_SUCCESS == rrm_cellm_check_for_no_broadcast(p_s1ap_rrm_pws_request))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					" No Broadcast is Required for PWS req. [SEND FAILURE to L3]");
		}
		else if(S1AP_RRM_PWS_WARNING_AREA_LIST & p_s1ap_rrm_pws_request->bitmask)
		{
			if (WARNING_AREA_LIST_INFO_CELL_ID_LIST & p_s1ap_rrm_pws_request->warning_area_list.bitmask)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						" CELL ID LIST and PLMN ID is present in the request ");
				/* Process PWS req for Cells on the basis of Cell Ids*/
				rrm_cellm_get_cell_index_for_pws_cell_id(&(p_s1ap_rrm_pws_request->warning_area_list.cell_id_list),
						requested_cell_index_list ,&requested_cell_count);
			}
			else if (WARNING_AREA_LIST_INFO_TRACKING_AREA_ID_LIST & p_s1ap_rrm_pws_request->warning_area_list.bitmask)
			{
				/* Process PWS req for Cells on the basis of TAC Ids*/
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						" TAC ID LIST and PLMN ID is present in the request ");
				rrm_cellm_get_cell_index_for_pws_tac_id(&(p_s1ap_rrm_pws_request->warning_area_list.tracking_area_id_list),
						requested_cell_index_list,&requested_cell_count);

			}
			else if (WARNING_AREA_LIST_INFO_EMERGENCY_AREA_ID_LIST & p_s1ap_rrm_pws_request->warning_area_list.bitmask)
			{   
				/* Process PWS req for cells on the basis of Emergency Ids*/
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						" EMERGENCY ID list is present in the request ");
				rrm_cellm_get_cell_index_for_pws_emrgncy_id(&(p_s1ap_rrm_pws_request->warning_area_list.emergency_area_id_list),
						requested_cell_index_list,&requested_cell_count);
			}            
			else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Wrong Warning Area List Received ");
                ret_val =  RRM_FAILURE;
            }

            /*
             ** Process the PWS request for the requested no. of cells derived above
             */
            if(ret_val)
            {
                /*Klockwork_fix_start*/
                /*SPR FIX 12567 START*/
                ret_val = rrm_rrc_s1ap_pws_req_process_msg_area_list(requested_cell_index_list ,requested_cell_count ,
                        &cell_context_index , success_cell_index_list ,&success_cell_index_count ,
                        &(p_s1ap_rrm_pws_request) ,p_s1ap_rrm_pws_response ,trans_id ,api_id );
                /*Klockwork_fix_end*/
                /*SPR FIX 12567 START*/
                /* Code deleted */
                /*SPR FIX 12567 END*/

			}
		}
		else 
		{
			/* SPR 10812 FIX START */
			/* Process PWS req for all Cells*/
            while(cell_context_index  < RRM_MAX_NUM_CELLS)
			{
				if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index] )
                {
                    SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_REQ: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,cell_context_index);
			/* SPR 10812 FIX END */
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_pws_request;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->api_id = S1AP_RRM_PWS_REQ;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]);
                    if((PWS_W_FOR_KILL_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate )
                            && (PWS_W_FOR_UPDATE_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate )
                            && (PWS_W_FOR_PWS_CNF != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate)) 
                    {
                        if (RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_PWS_REQ_EVENT,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index])))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                    "Failed to process request[%u] received ", api_id);
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = RRM_PNULL;
                        }
                        else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                        {
                            /*SPR FIX 12567 START*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    " Due to invalid state of cell,failure response is sent by rrm for cell index[%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index);
                            p_s1ap_rrm_pws_request = RRM_PNULL;
                            p_s1ap_rrm_pws_response->bitmask = RRM_ZERO;
                            break;
                            /*SPR FIX 12567 END*/

                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "successfully processed api:%d",api_id);
                            success_cell_index_list[success_cell_index_count++] = cell_context_index;
                            rrm_cellm_prepare_pws_response(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index], 
                                    p_s1ap_rrm_pws_response);
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                "Invalid cell substate for PWS req-> cell id [%d] cell_state[%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate);
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = RRM_PNULL;
                        ret_val = RRM_FAILURE;            
                    }
			    /* SPR 10812 FIX START */
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_REQ: Cell Context is Not present at [%d] loc in Global cell Context",cell_context_index);
                }

                cell_context_index++;
            }
            /* SPR 10812 FIX END */
        }
        if(ret_val)
        {
            if(RRM_FAILURE == build_and_send_s1ap_rrm_pws_resp(p_s1ap_rrm_pws_response, trans_id))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Unable to send response of API ID :%d",S1AP_RRM_PWS_REQ);

                ret_val = RRM_FAILURE;
            }
            else
            {

                /*SPR FIX 12567 START*/
                if( RRM_ZERO  != success_cell_index_count)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Some cells are found to schedule PWS message, Change Cell state to [%d]",CELL_STATE_PWS_ONGOING);

                }
                else
                {

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "NO cell is selected to schedule PWS message, Keep cell state as earlier");

                }
                /*SPR FIX 12567 END*/
                for(valid_cell_count = RRM_ZERO ;valid_cell_count < success_cell_index_count; valid_cell_count++)
				{
					CELL_M_FSM_SET_STATE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[success_cell_index_list[valid_cell_count]], CELL_STATE_PWS_ONGOING);
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[success_cell_index_list[valid_cell_count]]->pws_substate = PWS_W_FOR_PWS_CNF;
				}
			}
        }
	/*SPR 18759 Start*/
	else
	{
		if(RRM_FAILURE == build_and_send_s1ap_rrm_pws_resp(p_s1ap_rrm_pws_response, trans_id))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Unable to send response of API ID :%d",S1AP_RRM_PWS_REQ);

			ret_val = RRM_FAILURE;
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Failure Response Successfully sent for S1AP_RRM_PWS_REQ");
		}


	}
	/*SPR 18759 End*/
    }

    /*SPR FIX 12567 START*/
    if (RRM_PNULL != p_s1ap_rrm_pws_request )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Free memory for PWS request");
        RRM_MEM_FREE(p_s1ap_rrm_pws_request);
    }
    if (RRM_PNULL != p_s1ap_rrm_pws_response)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Free memory for PWS response");
        RRM_MEM_FREE(p_s1ap_rrm_pws_response);
    }
    /*SPR FIX 12567 END*/

    
    
    RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_rrc_update_cell_pws_list
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes update pws list request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_prepare_update_pws_list_resp(
		rrc_rrm_updated_pws_si_list_req_t   *p_rrc_rrm_updated_pws_si_list_req,
		rrm_cell_context_t                  *p_cell_context,
		rrc_rrm_updated_pws_si_list_resp_t  *p_rrc_rrm_updated_pws_si_list_resp
		)
{
	RRM_UT_TRACE_ENTER();

	RRM_ASSERT(p_cell_context != RRM_PNULL);
	RRM_ASSERT(p_rrc_rrm_updated_pws_si_list_req != RRM_PNULL);
	RRM_ASSERT(p_rrc_rrm_updated_pws_si_list_resp != RRM_PNULL);
	rrm_return_et  ret_val = RRM_SUCCESS;

	U8 max_warning_count = RRM_ZERO;
	scheduling_data_key_t shed_data_key;
	YLNODE *p_ylnode = RRM_PNULL;
	YLNODE *p_temp = RRM_PNULL;
	U8 left_cmas_warning_count = RRM_ZERO;
	U8 si_index_loop = RRM_ZERO;
	U8 cmas_warn_idx = RRM_ZERO;
	U8 warning_count = RRM_ZERO;
	rrm_bool_et warning_found = RRM_FALSE; 
	rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};
	U8 counter = RRM_ZERO;
	rrm_void_t *p_shed_data_key = RRM_PNULL;
	/*
	 ** Get the copy of the scheduling info present in the cell context.
	 ** Update this list with the new  PWS warnings (ETWS/CMAS) and copy
	 ** this list in the reponse for a particular cell
	 */
	RRM_MEMCPY(&current_sched_info_list, &p_cell_context->operator_info.sib_1_info.scheduling_info_list,
			sizeof(rrm_scheduling_info_list_t));

	max_warning_count = p_rrc_rrm_updated_pws_si_list_req->warning_info_list.count;
	for(warning_count = RRM_ZERO ; warning_count < max_warning_count ; warning_count++)
	{
		RRM_MEMCPY(shed_data_key.msg_id,p_rrc_rrm_updated_pws_si_list_req->warning_info_list.
				warning_info[warning_count].message_identifier , MSG_ID_OCTET_SIZE);

		RRM_MEMCPY(shed_data_key.serial_number,p_rrc_rrm_updated_pws_si_list_req->warning_info_list.
				warning_info[warning_count].serial_number , SERIAL_NUMBER_OCTET_SIZE);

        p_shed_data_key = (rrm_void_t *)(&shed_data_key);
        RRM_ASSERT(RRM_PNULL != p_shed_data_key);
		if (RRM_PNULL != (p_ylnode = ylFind(&p_cell_context->scheduled_cmas_warning_list, 
						p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
						rrm_cellm_shed_data_key_compare)))
		{
			((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status = PWS_BROADCAST_COMPLETE;
			warning_found = RRM_TRUE;

		}
		else if (RRM_PNULL != (p_ylnode = ylFind(&p_cell_context->scheduled_etws_warning_list, 
						p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
						rrm_cellm_shed_data_key_compare)))
		{
			((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status = PWS_BROADCAST_COMPLETE;
			warning_found = RRM_TRUE;
		}
		else
		{   
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"[UPDATED PWS request with unexpexted msg_id and serial num received ] Invalid Cnf for Cell Index : %d",
					p_cell_context->cell_index);    
			break;      
		}
	}  

	if(warning_found)
	{
		/*prepare response */
		p_rrc_rrm_updated_pws_si_list_resp->cell_index = p_cell_context->cell_index;
		p_rrc_rrm_updated_pws_si_list_resp->response = RRM_SUCCESS;

		//	p_rrc_rrm_updated_pws_si_list_resp->bitmask |= UPDATED_PWS_SI_LIST_RESP_CMAS_INFO_PRESENT;
		/*cmas warning data*/
		p_temp = p_cell_context->scheduled_cmas_warning_list.node.next;
		while(p_temp)
		{
			if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.broadcast_status != PWS_BROADCAST_COMPLETE)
				left_cmas_warning_count++;
			p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
		}
		p_temp = p_cell_context->scheduled_cmas_warning_list.node.next;

		while(p_temp)
		{
			if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.broadcast_status == PWS_BROADCAST_COMPLETE)
			{
				if(!left_cmas_warning_count)
				{
					if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] 
							< current_sched_info_list.count)
					{
						for(si_index_loop = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;
								si_index_loop < current_sched_info_list.count; si_index_loop++ )
						{
							RRM_MEMCPY(&current_sched_info_list.scheduling_info[si_index_loop],
									&current_sched_info_list.scheduling_info[si_index_loop+RRM_ONE],
									sizeof(rrm_scheduling_info_t));
                            /* DYNAMIC SIB SCHEDULING START */
                             current_sched_info_list.scheduling_info[si_index_loop].si_periodicity  =
                                      p_cell_context->si_segment_data_sib_scheduling[si_index_loop].si_segment_periodicity;
                           /* DYNAMIC SIB SCHEDULING END */
                              
						}
					}
					current_sched_info_list.count--;
					break;
				}
			}
			else
			{
                /* SPR_20915 Fix - Starts */
				if(MAX_NUM_CMAS_WARNING > p_rrc_rrm_updated_pws_si_list_resp->
				    cmas_scheduling_info_list.cmas_warning_count)
                {
                    /*fill_cmas_ scheduling contents */
                    cmas_warn_idx = p_rrc_rrm_updated_pws_si_list_resp->
                        cmas_scheduling_info_list.cmas_warning_count++;

                    RRM_MEMCPY(p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.
                        cmas_scheduling_info[cmas_warn_idx].message_identifier,
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,
                        MSG_ID_OCTET_SIZE);

                    RRM_MEMCPY(p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.
                        cmas_scheduling_info[cmas_warn_idx].serial_number,
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,
                        SERIAL_NUMBER_OCTET_SIZE);

                    p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.
                        cmas_scheduling_info[cmas_warn_idx].num_of_segments  =
                        ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments;

                    if(left_cmas_warning_count > RRM_ONE)
                    {
                        p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.
                            cmas_scheduling_info[cmas_warn_idx].num_of_repetitions = RRM_FOUR;
                    }
                    else
                    {
                        p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.
                            cmas_scheduling_info[cmas_warn_idx].num_of_repetitions = RRM_ONE;
                    }
                }
                /* SPR_20915 - Fix - Ends */
			}
			p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
		}

		if(left_cmas_warning_count)
		{
			p_rrc_rrm_updated_pws_si_list_resp->bitmask |= UPDATED_PWS_SI_LIST_RESP_CMAS_INFO_PRESENT;
			p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list.cmas_warning_count = left_cmas_warning_count ; 
		}
		/* ETWS warning */
		p_temp = p_cell_context->scheduled_etws_warning_list.node.next;

		while(p_temp)
		{
			if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.broadcast_status == PWS_BROADCAST_COMPLETE)
			{
				counter = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sibs_scheduled;
				while(counter)
				{
					for(si_index_loop = ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
							si_index_loop < current_sched_info_list.count; si_index_loop++ )
					{
						RRM_MEMCPY(&current_sched_info_list.scheduling_info[si_index_loop],
								&current_sched_info_list.scheduling_info[si_index_loop+RRM_ONE],
								sizeof(rrm_scheduling_info_t));
                        /* DYNAMIC SIB SCHEDULING START */
                         current_sched_info_list.scheduling_info[si_index_loop].si_periodicity  =
                                      p_cell_context->si_segment_data_sib_scheduling[si_index_loop].si_segment_periodicity;
                        /* DYNAMIC SIB SCHEDULING END */
					}
					current_sched_info_list.count--;
					counter--;
				}
			}
			else 
			{
				p_rrc_rrm_updated_pws_si_list_resp->bitmask |= UPDATED_PWS_SI_LIST_RESP_ETWS_INFO_PRESENT;

				RRM_MEMCPY( p_rrc_rrm_updated_pws_si_list_resp->etws_scheduling_info.message_identifier,
						((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,MSG_ID_OCTET_SIZE);

				RRM_MEMCPY(p_rrc_rrm_updated_pws_si_list_resp->etws_scheduling_info.serial_number,
						((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,SERIAL_NUMBER_OCTET_SIZE);

				if((((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments) > RRM_ONE)
				{
					p_rrc_rrm_updated_pws_si_list_resp->etws_scheduling_info.num_of_segments  =
						((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments;
					p_rrc_rrm_updated_pws_si_list_resp->etws_scheduling_info.bitmask |= RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT;
				}
			}

			p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
		} 

        /* Klocwork changes start 22 may */
        RRM_MEMCPY(&(p_rrc_rrm_updated_pws_si_list_resp->scheduling_info_list),
                &(current_sched_info_list),sizeof(scheduling_info_list_t));
        /* Klocwork changes end 22 may */
		RRM_MEMCPY(p_cell_context->scheduling_info_list_for_pws,&current_sched_info_list ,sizeof(rrm_scheduling_info_list_t));

	}
	else
	{
		/*prepare response */
		p_rrc_rrm_updated_pws_si_list_resp->cell_index = p_cell_context->cell_index;
		p_rrc_rrm_updated_pws_si_list_resp->response = RRM_FAILURE;
        /* Klocwork changes start 22 may */
        RRM_MEMCPY(&(p_rrc_rrm_updated_pws_si_list_resp->scheduling_info_list),
                &(current_sched_info_list),sizeof(scheduling_info_list_t));
        /* Klocwork changes end 22 may */
	}

	/* PWS_SI_TRANSMISSION_OFFSET_CHANGES_START */
	fill_mac_config_scheduling_info_list(p_cell_context->operator_info.sib_1_info.si_window_length,
			&(p_rrc_rrm_updated_pws_si_list_resp->si_transmission_info),
			(rrm_scheduling_info_list_t *)&(p_rrc_rrm_updated_pws_si_list_resp->scheduling_info_list) );

	p_rrc_rrm_updated_pws_si_list_resp->bitmask |= UPDATED_PWS_SI_LIST_RESP_SI_TRANSMISSION_INFO_PRESENT;

	/* PWS_SI_TRANSMISSION_OFFSET_CHANGES_END*/

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_rrc_updated_pws_list_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes update pws list request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_updated_pws_list_req_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len, /* incoming data length*/
		U16 trans_id /* Incoming transaction Id*/
		)
{
	RRM_UT_TRACE_ENTER();
	S32  length = RRM_ZERO;
    /* Coverity_ID : 16363 */
	rrm_return_et response = RRM_FAILURE;
	rrm_return_et  ret_val = RRM_FAILURE;
	U8 context_index = RRM_ZERO;
	rrc_rrm_updated_pws_si_list_req_t  *p_rrc_rrm_updated_pws_si_list_req = RRM_PNULL;
	rrc_rrm_updated_pws_si_list_resp_t *p_rrc_rrm_updated_pws_si_list_resp = RRM_PNULL;
	p_rrc_rrm_updated_pws_si_list_resp = (rrc_rrm_updated_pws_si_list_resp_t*)rrm_mem_get(sizeof(rrc_rrm_updated_pws_si_list_resp_t));
    if (p_rrc_rrm_updated_pws_si_list_resp == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_rrm_updated_pws_si_list_resp failed" );
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	p_rrc_rrm_updated_pws_si_list_req = (rrc_rrm_updated_pws_si_list_req_t*)rrm_mem_get(sizeof(rrc_rrm_updated_pws_si_list_req_t));
    if (p_rrc_rrm_updated_pws_si_list_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_rrm_updated_pws_si_list_req failed" );
        RRM_UT_TRACE_EXIT();
        RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_resp);
        return RRM_FAILURE;
    }

	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_updated_pws_si_list_req(p_rrc_rrm_updated_pws_si_list_req,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"RRC->RRM:RRC_RRM_UPDATED_PWS_SI_LIST_REQ failed to parse");
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"RRC->RRM:RRC_RRM_UPDATED_PWS_SI_LIST_REQ successfully parsed");

		/* SPR 10812 FIX START */
        while(context_index < RRM_MAX_NUM_CELLS)
        {
            if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
            {
                SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_UPDATE_REQ :Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                if(p_rrc_rrm_updated_pws_si_list_req->cell_index == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index)
                {                                           
                    ret_val = RRM_SUCCESS;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_UPDATE_REQ: cell ID [%d] matches with updated_pws_si_list_req id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    p_rrc_rrm_updated_pws_si_list_req->cell_index);

                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = (rrm_void_t *) p_rrc_rrm_updated_pws_si_list_req;

                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->api_id = RRC_RRM_UPDATED_PWS_SI_LIST_REQ;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                    if((PWS_ONGOING_ACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate)
                            ||(PWS_W_FOR_UPDATE_CNF == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate))
				{
					if (RRM_FAILURE == (response = cellm_fsm_process_event(RRC_RRM_UPDATE_PWS_LIST_REQ_EVENT ,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])))
					{
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "unable to process api:%d",api_id);
						ret_val = RRM_FAILURE;
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
                        }
                        else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                        {

                            /*Cov_fix_54356*/
                            if( RRM_NULL != p_rrc_rrm_updated_pws_si_list_resp)
                                RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_resp);
                            /*Cov_fix_54356*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                "RRM_CELL_INVALID_STATE_FOR_PWS response is received");

                            /* SPR: 15922 Fix Start*/
                            ret_val =  RRM_FAILURE;
                            /* SPR: 15922 Fix End */
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "successfully processed api:%d",api_id);
                            ret_val = RRM_SUCCESS;

                        }
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
							"Invalid cell substate for Updated PWS list req-> cell id [%d] cell_state[%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
					ret_val = RRM_FAILURE;
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
				}   
				break;
			}
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "PWS_UPDATE_REQ: cell ID [%d] Does Not match with PWS update req list id [%d]",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                            p_rrc_rrm_updated_pws_si_list_req->cell_index);
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PWS_UPDATE_REQ: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
            }
            context_index++;
        }
		/* SPR 10812 FIX END */
	}

    RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_resp);        
    RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_req);        
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_rrc_update_cell_pws_list_on_cnf
 * Inputs         : p_rrc_rrm_updated_pws_si_list_cnf
 *                : p_cell_context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes update pws list cnf from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_update_cell_pws_list_on_cnf(
		rrc_rrm_updated_pws_si_list_cnf_t   *p_rrc_rrm_updated_pws_si_list_cnf,
		rrm_cell_context_t                  *p_cell_context
		)
{
	RRM_UT_TRACE_ENTER();
    /* Klocwork changes start 22 may */
    RRM_ASSERT(RRM_PNULL != p_rrc_rrm_updated_pws_si_list_cnf);
    /* Klocwork changes end 22 may */
	U8 max_warning_count = RRM_ZERO;
	max_warning_count = p_rrc_rrm_updated_pws_si_list_cnf->warning_info_list.count;
	scheduling_data_key_t shed_data_key;
	YLNODE *p_ylnode = RRM_PNULL;
	rrm_return_et ret_val = RRM_SUCCESS; 
	U8 warning_count = RRM_ZERO;
	rrm_bool_t  cmas_updated = RRM_FALSE;
	rrm_bool_t  etws_updated = RRM_FALSE;
	U8 cmas_updated_index = RRM_ZERO;
	U8 etws_updated_index = RRM_ZERO;
    rrm_void_t          *p_shed_data_key = RRM_PNULL;

	RRM_ASSERT(p_rrc_rrm_updated_pws_si_list_cnf != RRM_PNULL);

	if( p_rrc_rrm_updated_pws_si_list_cnf->response == RRM_FAILURE)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"UPDATED_PWS_LIST_CNF is Failure for cell index :%d",p_cell_context->cell_index );
	}
	for(warning_count = RRM_ZERO ; warning_count < max_warning_count ; warning_count++)
	{
		RRM_MEMCPY(&shed_data_key.msg_id,p_rrc_rrm_updated_pws_si_list_cnf->warning_info_list.
				warning_info[warning_count].message_identifier , MSG_ID_OCTET_SIZE);

		RRM_MEMCPY(&shed_data_key.serial_number,p_rrc_rrm_updated_pws_si_list_cnf->warning_info_list.
				warning_info[warning_count].serial_number , SERIAL_NUMBER_OCTET_SIZE);
        p_shed_data_key = (rrm_void_t *)(&shed_data_key);
        RRM_ASSERT(RRM_PNULL != p_shed_data_key);

		if (RRM_PNULL != (p_ylnode = ylFind(&p_cell_context->scheduled_etws_warning_list,
						p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
						rrm_cellm_shed_data_key_compare)))
		{
			etws_updated = RRM_TRUE;
			etws_updated_index = ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
			ylDelete(&(p_cell_context->scheduled_etws_warning_list), p_ylnode);
            RRM_MEM_FREE(p_ylnode);

		}
		else if (RRM_PNULL != (p_ylnode = ylFind(&p_cell_context->scheduled_cmas_warning_list,
						p_shed_data_key, rrm_cellm_pws_request_sched_data_key ,
						rrm_cellm_shed_data_key_compare)))
		{
			cmas_updated = RRM_TRUE;
			cmas_updated_index = ((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX];
			ylDelete(&(p_cell_context->scheduled_cmas_warning_list), p_ylnode);
            RRM_MEM_FREE(p_ylnode);
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"UPDATED_PWS_LIST_CNF for invalid Msg Id and Serial Num " );
		}
	}

	RRM_MEMCPY(&p_cell_context->operator_info.sib_1_info.scheduling_info_list
			,p_cell_context->scheduling_info_list_for_pws,sizeof(rrm_scheduling_info_list_t));
	if( etws_updated && (!p_cell_context->scheduled_etws_warning_list.count && 
				p_cell_context->scheduled_cmas_warning_list.count ))
	{
		update_si_index_in_cmas_warning_list(&(p_cell_context->scheduled_cmas_warning_list),etws_updated_index,p_cell_context);
	}
	if( cmas_updated && (p_cell_context->scheduled_etws_warning_list.count &&
				!p_cell_context->scheduled_cmas_warning_list.count))
	{
		update_si_index_in_etws_warning_list(&(p_cell_context->scheduled_etws_warning_list),cmas_updated_index,p_cell_context);
	}
	/*change the ctate of cell to indicate that Updated PWS list procedure is complete*/
	if(PWS_W_FOR_UPDATE_CNF == p_cell_context->pws_substate)
		p_cell_context->pws_substate = PWS_ONGOING_ACTIVE;

	/*check for cell state change */
	if((!(p_cell_context->scheduled_cmas_warning_list.count) && !(p_cell_context->scheduled_etws_warning_list.count)))
	{
		CELL_M_FSM_SET_STATE(p_cell_context,CELL_STATE_ACTIVE);
		p_cell_context->pws_substate = PWS_IDLE;
        RRM_MEM_FREE(p_cell_context->scheduling_info_list_for_pws);  
		p_cell_context->scheduling_info_list_for_pws = RRM_PNULL;
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_rrc_updated_pws_list_cnf_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes update pws list cnf from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_updated_pws_list_cnf_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len, /* incoming data length*/
		U16 trans_id /* Incoming transaction Id*/
		)
{
	RRM_UT_TRACE_ENTER();
	S32  length = RRM_ZERO;
    /* Coverity_ID : 16363 */
	rrm_return_et response = RRM_FAILURE;
	rrm_return_et  ret_val = RRM_SUCCESS;
	U8 context_index = RRM_ZERO;
	rrc_rrm_updated_pws_si_list_cnf_t  *p_rrc_rrm_updated_pws_si_list_cnf = RRM_PNULL;

	p_rrc_rrm_updated_pws_si_list_cnf = (rrc_rrm_updated_pws_si_list_cnf_t*)rrm_mem_get(sizeof(rrc_rrm_updated_pws_si_list_cnf_t));
    if ( p_rrc_rrm_updated_pws_si_list_cnf == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rrc_rrm_updated_pws_si_list_cnf failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_il_parse_rrc_rrm_updated_pws_si_list_cnf(p_rrc_rrm_updated_pws_si_list_cnf,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"RRC->RRM:RRC_RRM_UPDATED_PWS_SI_LIST_CNF unable to parse",
                p_rrc_rrm_updated_pws_si_list_cnf->cell_index, p_rrc_rrm_updated_pws_si_list_cnf->response);
		ret_val = RRM_FAILURE;
        /* Coverity fix 54355 */
        RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_cnf);
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
				"RRC->RRM:RRC_RRM_UPDATED_PWS_SI_LIST_CNF:[CELL:%d] with response: %d",
                p_rrc_rrm_updated_pws_si_list_cnf->cell_index, p_rrc_rrm_updated_pws_si_list_cnf->response);

		/* SPR 10812 FIX START */
        while(context_index < RRM_MAX_NUM_CELLS)
        {
            if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
            {
                SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_UPDATE_CNF :Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                if(p_rrc_rrm_updated_pws_si_list_cnf->cell_index == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_UPDATE_CNF: cell ID [%d] matches with updated_pws_si_list_cnf list id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    p_rrc_rrm_updated_pws_si_list_cnf->cell_index );

                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = (rrm_void_t *)p_rrc_rrm_updated_pws_si_list_cnf;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->api_id = RRC_RRM_UPDATED_PWS_SI_LIST_CNF;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                    if(PWS_W_FOR_UPDATE_CNF == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate)
				{
					if (RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_UPDATE_PWS_LIST_CNF_EVENT,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])))
					{
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "unable to process api:%d",api_id);
						ret_val = RRM_FAILURE;
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
					}
					else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
					{
                        /* SPR 21251 Start */
	                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			                    "RRM_CELL_INVALID_STATE_FOR_PWS");
                        /* SPR 21251 End */
						return RRM_FAILURE; 
					}
					else
					{
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
								"successfully processed api:%d",api_id);
						ret_val = RRM_SUCCESS;
					}
				}
				else
				{
                        /* SPR 21251 Start */
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
							"Invalid cell substate for Updated PWS list CNF-> cell id [%d] cell_state[%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
                        /* SPR 21251 End */
					ret_val = RRM_FAILURE;
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = RRM_PNULL;
                        ret_val =  RRM_FAILURE;
                    }
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                    break;            
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "PWS_UPDATE_CNF: cell ID [%d] Does Not match with PWS update req list id [%d]",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                            p_rrc_rrm_updated_pws_si_list_cnf->cell_index);
                    
                }
            /*Cov_fix_11526*/

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PWS_UPDATE_CNF: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
            }
            context_index++;
        }
        /*Cov_fix_11526*/
        if(RRM_PNULL != p_rrc_rrm_updated_pws_si_list_cnf)
        {
            RRM_MEM_FREE(p_rrc_rrm_updated_pws_si_list_cnf);
        }
         /*Cov_fix_11526*/
        /* SPR 10812 FIX END */
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_prepare_kill_response
 * Inputs         : p_cell_ctx [global context of cell]
 * Outputs        : p_s1ap_rrm_kill_responsee [Response to be filled]
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Updates the scheduling info list as per the killed warning
 ****************************************************************************/
rrm_return_et
rrm_cellm_prepare_kill_response(
		rrm_cell_context_t          *p_cell_ctx,
		s1ap_rrm_kill_response_t    *p_s1ap_rrm_kill_response
		)
{
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(p_s1ap_rrm_kill_response!=RRM_PNULL);
	RRM_ASSERT(p_cell_ctx != RRM_PNULL);
	YLNODE *p_temp = RRM_PNULL; 
	rrm_scheduling_info_list_t current_sched_info_list = {RRM_ZERO};	
	U8 cmas_warn_count = RRM_ZERO;
	U8 cell_count = RRM_ZERO;
	U8 si_index_loop = RRM_ZERO;
	U8 left_cmas_warning_count = RRM_ZERO;
	rrm_return_et  ret_val = RRM_SUCCESS;

	p_s1ap_rrm_kill_response->response = RRM_SUCCESS;

	cell_count = p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.cell_count++;
	p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.
		rrc_rrm_pws_contents[cell_count].cell_index = p_cell_ctx->cell_index;

	p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_PWS_CONTENTS_LIST_PRESENT; 
	RRM_MEMCPY(&current_sched_info_list, &p_cell_ctx->operator_info.sib_1_info.scheduling_info_list,
			sizeof(rrm_scheduling_info_list_t));

	p_temp = p_cell_ctx->scheduled_etws_warning_list.node.next;
	if(p_temp)
	{
		p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].bitmask |=
			RRC_RRM_PWS_CONTENTS_ETWS_SCHEDULING_INFO_PRESENT;
		/*
		 ** Fill the contents of the scheduled ETWS warning for a particular cell
		 ** - Message Id
		 ** - Serial Number
		 ** - Number of sib segnments
		 */
		RRM_MEMCPY(p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
				etws_scheduling_info.message_identifier,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,
				(MSG_ID_OCTET_SIZE));
		RRM_MEMCPY(p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
				etws_scheduling_info.serial_number,((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,
				(SERIAL_NUMBER_OCTET_SIZE));

		if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments > 1)
		{
			p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.bitmask |= 
				RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT;
			p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].etws_scheduling_info.num_of_segments 
				= ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments;
		}
	}

	/* Trversing the CMAS List, prepare the response*/
	p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
	while(p_temp)
	{
		if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.broadcast_status != PWS_BROADCAST_KILLED)
			left_cmas_warning_count++;
		p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
	}
	if(!left_cmas_warning_count)
	{
		if(((scheduled_pws_data_node_t *)p_cell_ctx->scheduled_cmas_warning_list.node.next)->
				scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] < current_sched_info_list.count)	
		{
			for(si_index_loop = ((scheduled_pws_data_node_t *)p_cell_ctx->scheduled_cmas_warning_list.node.next)->
					scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] ;si_index_loop <current_sched_info_list.count; si_index_loop++ )
            {
                RRM_MEMCPY(&current_sched_info_list.scheduling_info[si_index_loop],
                        &current_sched_info_list.scheduling_info[si_index_loop+RRM_ONE],
                        sizeof(rrm_scheduling_info_t));
                /* DYNAMIC SIB SCHEDULING START */
                current_sched_info_list.scheduling_info[si_index_loop].si_periodicity  =
                    p_cell_ctx->si_segment_data_sib_scheduling[si_index_loop].si_segment_periodicity;
                /* DYNAMIC SIB SCHEDULING END */
            }
			current_sched_info_list.count--;
		}
	}
	else
	{
		p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].bitmask |=
			RRC_RRM_PWS_CONTENTS_CMAS_SCHEDULING_INFO_LIST_PRESENT;
		p_temp = p_cell_ctx->scheduled_cmas_warning_list.node.next;
		while(p_temp)
		{
			if(((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.broadcast_status != PWS_BROADCAST_KILLED)	
			{
				/*fill_cmas_ scheduling contents */
				p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.
					rrc_rrm_pws_contents[cell_count].bitmask |= RRC_RRM_PWS_CONTENTS_CMAS_SCHEDULING_INFO_LIST_PRESENT;

				RRM_MEMCPY((p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
							cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].message_identifier),
						((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.msg_id,(MSG_ID_OCTET_SIZE));

				RRM_MEMCPY((p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
							cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].serial_number),
						((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.sched_data_key.serial_number,(SERIAL_NUMBER_OCTET_SIZE));

				p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
					cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_segments = 
					((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.num_of_sib_segments; 
				if(left_cmas_warning_count > RRM_ONE)
				{

					p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
						cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_FOUR; 

				}
				else
				{
					p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
						cmas_scheduling_info_list.cmas_scheduling_info[cmas_warn_count].num_of_repetitions = RRM_ONE; 

				}
				cmas_warn_count++;
			}
			p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
		}	
		p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].
			cmas_scheduling_info_list.cmas_warning_count = cmas_warn_count;
	}
	RRM_MEMCPY(&(p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list),
			&current_sched_info_list,sizeof(rrm_scheduling_info_list_t));

	RRM_MEMCPY(p_cell_ctx->scheduling_info_list_for_pws,&current_sched_info_list ,sizeof(rrm_scheduling_info_list_t));
	/* PWS_SI_TRANSMISSION_OFFSET_CHANGES_START */
	fill_mac_config_scheduling_info_list(p_cell_ctx->operator_info.sib_1_info.si_window_length,
			&(p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].si_transmission_info),
			(rrm_scheduling_info_list_t *)&(p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].scheduling_info_list));

	p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.rrc_rrm_pws_contents[cell_count].bitmask |=
		RRC_RRM_PWS_CONTENTS_SI_TRANSMISSION_INFO_PRESENT;
	/* PWS_SI_TRANSMISSION_OFFSET_CHANGES_END*/
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_s1ap_kill_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *	              : U16 api_id :api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes Kill request from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_kill_req_process_msg(
		U8 *p_api, /* Pointer to incoming Api buffer*/
		U16 api_id, /* incoming api id*/
		U16 data_len, /* incoming data length*/
		U16 trans_id /* Incoming transaction Id*/
		)
{
    RRM_UT_TRACE_ENTER();
    S32  length = RRM_ZERO;
    rrm_return_et response = RRM_FAILURE;
    rrm_return_et  ret_val = RRM_SUCCESS;
    U8 cell_context_index = RRM_ZERO;
    U8 success_cell_index_count = RRM_ZERO;
    /*SPR 22329 Fix Start*/
    /*Code Removed*/
    /*SPR 22329 Fix Stop*/
    U8 success_cell_index_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};
    s1ap_rrm_kill_response_t *p_s1ap_rrm_kill_response = RRM_PNULL;
    U8 requested_cell_index_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};
    U8 requested_cell_count = RRM_ZERO;
    U8 valid_cell_count = RRM_ZERO;

    p_s1ap_rrm_kill_response = (s1ap_rrm_kill_response_t *)rrm_mem_get(sizeof(s1ap_rrm_kill_response_t));
    if ( p_s1ap_rrm_kill_response == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_s1ap_rrm_kill_response failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    p_s1ap_rrm_kill_response->rrc_rrm_pws_contents_list.cell_count = RRM_ZERO;
    RRM_MEMSET(p_s1ap_rrm_kill_response , RRM_ZERO , sizeof(s1ap_rrm_kill_response_t));
    s1ap_rrm_kill_request_t *p_s1ap_rrm_kill_request = RRM_PNULL;

    p_s1ap_rrm_kill_request = (s1ap_rrm_kill_request_t*)rrm_mem_get(sizeof
            (s1ap_rrm_kill_request_t));
    if ( p_s1ap_rrm_kill_request == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_s1ap_rrm_kill_request failed" );
        /* sPR 21251 End */
        RRM_UT_TRACE_EXIT();
        RRM_MEM_FREE(p_s1ap_rrm_kill_response);
        return RRM_FAILURE;
    }


    /* Parse  the incoming message from RRC */
    if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_kill_request(
                p_s1ap_rrm_kill_request,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "RRC->RRM:S1AP_RRM_KILL_REQ failed to parse");
        ret_val = RRM_FAILURE;
    }else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "RRC->RRM:S1AP_RRM_KILL_REQ successfully parsed");

        if(KILL_WARNING_AREA_LIST & p_s1ap_rrm_kill_request->bitmask)
        {
            if (WARNING_AREA_LIST_INFO_CELL_ID_LIST & p_s1ap_rrm_kill_request->warning_area_list.bitmask)
            {
                /* Process KILL req for Cells on the basis of Cell Ids*/
                rrm_cellm_get_cell_index_for_pws_cell_id(&(p_s1ap_rrm_kill_request->warning_area_list.cell_id_list),
                        requested_cell_index_list ,&requested_cell_count);

            }
            else if (WARNING_AREA_LIST_INFO_TRACKING_AREA_ID_LIST & p_s1ap_rrm_kill_request->warning_area_list.bitmask)
            {
                /* Process KILL req for Cells on the basis of TAC Ids*/
                rrm_cellm_get_cell_index_for_pws_tac_id(&(p_s1ap_rrm_kill_request->warning_area_list.tracking_area_id_list),
                        requested_cell_index_list,&requested_cell_count);
            }
            else if (WARNING_AREA_LIST_INFO_EMERGENCY_AREA_ID_LIST & p_s1ap_rrm_kill_request->warning_area_list.bitmask)
            {
                /* Process KILL req for Cells on the basis of Emegency Ids*/
                rrm_cellm_get_cell_index_for_pws_emrgncy_id(&(p_s1ap_rrm_kill_request->warning_area_list.emergency_area_id_list),
                        requested_cell_index_list,&requested_cell_count);

            }
            else
            {
                /* SPR 21251 Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Invalid warning area list as bitmask received: %d", p_s1ap_rrm_kill_request->bitmask);
                /* SPR 21251 End */
                ret_val = RRM_FAILURE;       /* Do nothing */   
            }

            /*
             ** Process the KILL request for the requested no. of cells derived above
             */
            if(ret_val)
            {
                for(valid_cell_count = RRM_ZERO ;
                        (valid_cell_count < requested_cell_count) && (success_cell_index_count < RRM_MAX_NUM_CELLS);
                        valid_cell_count++)
                {
                    cell_context_index = requested_cell_index_list[valid_cell_count];
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_kill_request;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->api_id = S1AP_RRM_KILL_REQ;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]);
                    if(PWS_ONGOING_ACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate)
                    {
                        if (RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_KILL_REQ_EVENT,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index])))
                        {
                            /*SPR 22329 Fix Start*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                                    "No Broadcast ongoing for KILL request in Cell %d",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index);
                            p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                            p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_NO_BROADCAST_ONGOING;
                            ret_val = RRM_FAILURE;
                            /*SPR 22329 Fix Stop*/
                        }
                        else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                        {
                            /* SPR 21251 Start */
                            /*SPR 22329 Fix Start*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                    "Kill request received in Invalid state");
                            /* SPR 21251 End */
                            p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                            p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_UNKNOWN_FAILURE;
                            ret_val = RRM_FAILURE;
                            /*SPR 22329 Fix Stop*/
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                    "successfully processed api:%d",api_id);
                            success_cell_index_list[success_cell_index_count++] = cell_context_index;  	
                            rrm_cellm_prepare_kill_response(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index], 
                                    p_s1ap_rrm_kill_response);
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                    "Cell [%d] is in substate [%d] after successfull KILL REQ !!",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate);
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                "Invalid cell substate for KILL req-> cell id [%d] cell_state[%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate);
                        /*SPR 22329 Fix Start*/
                        p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                        p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_UNKNOWN_FAILURE;
                        /*SPR 22329 Fix Stop*/
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = RRM_PNULL;
                        ret_val = RRM_FAILURE;
                    }
                }
            }
        }	
        else
        {
            /* SPR 10812 FIX START */
            /* Process for all Cells*/
            while(cell_context_index < RRM_MAX_NUM_CELLS)
            {
                if ( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index])
                {
                    SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "PWS_KILL_REQ :Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,cell_context_index);
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_kill_request;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->api_id = S1AP_RRM_KILL_REQ;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]);
                    if(PWS_ONGOING_ACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate)
                    {
                        if (RRM_FAILURE == (response = cellm_fsm_process_event(RRC_RRM_KILL_REQ_EVENT,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index])))
                        {
                            /*SPR 22329 Fix Start*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                                    "No Broadcast ongoing for KILL request in Cell %d",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index);
                            p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                            p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_NO_BROADCAST_ONGOING;
                            ret_val = RRM_FAILURE;
                            /*SPR 22329 Fix Stop*/
                        }
                        else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                        {	
                            /* SPR 21251 Start */
                            /*SPR 22329 Fix Start*/
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                    "Kill request received in invalid state");
                            /* SPR 21251 End */
                            p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                            p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_UNKNOWN_FAILURE;
                            ret_val = RRM_FAILURE;
                            /*SPR 22329 Fix Stop*/
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "successfully processed api:%d",api_id);
                            success_cell_index_list[success_cell_index_count++] = cell_context_index;  	
                            rrm_cellm_prepare_kill_response(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index], 
                                    p_s1ap_rrm_kill_response);
                        }
                    }
                    else
                    {
                        /* SPR 21251 Start */
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                "Invalid cell substate for KILL req-> cell id [%d] cell_state[%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate);
                        /* SPR 21251 End */
                        ret_val = RRM_FAILURE;
                        /*SPR 22329 Fix Start*/
                        p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                        p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_UNKNOWN_FAILURE;
                        /*SPR 22329 Fix Stop*/
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->p_incoming_api_info = RRM_PNULL;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "PWS_KILL_REQ: Cell Context is Not present at [%d] loc in Global cell Context",cell_context_index);
                    /*SPR 22329 Fix Start*/
                    ret_val = RRM_FAILURE;
                    p_s1ap_rrm_kill_response->bitmask |= S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
                    p_s1ap_rrm_kill_response->fail_cause= RRM_RRC_CAUSE_UNKNOWN_FAILURE;
                    /*SPR 22329 Fix Stop*/
                }
                cell_context_index++;
            }
            /* SPR 10812 FIX END */
        }
        /* SPR 22329 Fix Start */
        if(success_cell_index_count)
        {
            p_s1ap_rrm_kill_response->bitmask &= ~S1AP_RRM_KILL_REQ_FAIL_CAUSE_PRESENT;
            p_s1ap_rrm_kill_response->fail_cause= RRM_ZERO;
            ret_val = RRM_SUCCESS;
        }
        /* Code Removed */
        /* SPR 22329 Fix Stop */
        RRM_MEMCPY((p_s1ap_rrm_kill_response->message_identifier),
                p_s1ap_rrm_kill_request->message_identifier,(MSG_ID_OCTET_SIZE));

        RRM_MEMCPY((p_s1ap_rrm_kill_response->serial_number),
                p_s1ap_rrm_kill_request->serial_number,(SERIAL_NUMBER_OCTET_SIZE));

        /* SPR 22329 Fix Start */
        p_s1ap_rrm_kill_response->response = ret_val;
        /* SPR 22329 Fix Stop */
        if(RRM_FAILURE == build_and_send_s1ap_rrm_kill_resp(p_s1ap_rrm_kill_response, trans_id))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Unable to send response of Kill req API ID :%d",S1AP_RRM_PWS_REQ);
            ret_val = RRM_FAILURE;
        }
        else
        {
            /*
             ** Change the state for the cell for which kill request id succesfully handeled 
             */
            for(valid_cell_count = RRM_ZERO ; valid_cell_count < success_cell_index_count ; valid_cell_count++ )
            {
                cell_context_index = success_cell_index_list[valid_cell_count];
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_context_index]->pws_substate = PWS_W_FOR_KILL_CNF; 
            }
        }
    }
    /* SPR 22329 Fix Start */
    if( RRM_NULL != p_s1ap_rrm_kill_response)
        RRM_MEM_FREE(p_s1ap_rrm_kill_response);
    if( RRM_NULL != p_s1ap_rrm_kill_request)
        RRM_MEM_FREE(p_s1ap_rrm_kill_request);
    /* SPR 22329 Fix Stop */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_s1ap_kill_cnf_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes Kill cnf message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_kill_cnf_process_msg(
		U8      *p_api, /* Pointer to incoming Api buffer*/
		U16     api_id, /* incoming api id*/
		U16     data_len, /* incoming data length*/
		U16     trans_id /* Incoming transaction Id*/
		)
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et ret_val = RRM_SUCCESS;
    /* coverity : CID 16363*/
    rrm_return_et response = RRM_FAILURE;
	s1ap_rrm_kill_cnf_t *p_s1ap_rrm_kill_cnf = RRM_PNULL;
	U8 cell_index_loop = RRM_ZERO;
	U8 in_cell_index = RRM_ZERO;
	U8 context_index = RRM_ZERO;
	/* warning removal: variable 'delete_cell_index_count' and 'delete_cell_index_list'
	   are being used in commented code, 10/04/2012 
	   U8 delete_cell_index_count = RRM_ZERO;
	   U8 delete_cell_index_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};*/

	U8 revert_broadcast_status_count = RRM_ZERO;
	U8 revert_broadcast_status_list[RRM_MAX_NUM_CELLS] = {RRM_ZERO};
	U8 loop_index = RRM_ZERO;
	/* warning removal: 10/04/2012 */
	scheduling_data_key_t shed_data_key = { {RRM_ZERO}, {RRM_ZERO}};
	S32 length = RRM_ZERO;
	YLNODE *p_ylnode = RRM_PNULL;
    rrm_void_t       *p_shed_data_key = RRM_PNULL;

    /* BUG_11576_FIX_START */
    p_s1ap_rrm_kill_cnf = (s1ap_rrm_kill_cnf_t *)rrm_mem_get(sizeof(s1ap_rrm_kill_cnf_t));

    if(RRM_PNULL == p_s1ap_rrm_kill_cnf) /* Coverity: CID 16290 */
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Unable to allocate memory to p_s1ap_rrm_kill_cnf");
        return RRM_FAILURE;
    }
    /* BUG_11576_FIX_END */

    /* Parse  the incoming message from RRC */
    /*CID 63861:Coverity_Fix_Start*/
	if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_kill_cnf(
				p_s1ap_rrm_kill_cnf,
				p_api,
				data_len,
				&length))
	{
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
               "RRC->RRM:S1AP_RRM_KILL_CNF failed to parse");
		ret_val = RRM_FAILURE;
        /* Coverity fix 54352 */
        RRM_MEM_FREE(p_s1ap_rrm_kill_cnf);
	}
	else
	{
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO, 
                "RRC->RRM:S1AP_RRM_KILL_CNF with response: %d",p_s1ap_rrm_kill_cnf->kill_resp);
		RRM_MEMCPY(&shed_data_key.msg_id,p_s1ap_rrm_kill_cnf->message_identifier,(MSG_ID_OCTET_SIZE));
		RRM_MEMCPY(&shed_data_key.serial_number,p_s1ap_rrm_kill_cnf->serial_number,(SERIAL_NUMBER_OCTET_SIZE));
        p_shed_data_key = (rrm_void_t *)(&shed_data_key);
        RRM_ASSERT(RRM_PNULL != p_shed_data_key);

		if(S1AP_RRM_KILL_BROADCAST_CANCELLATION_LIST_PRESENT & p_s1ap_rrm_kill_cnf->bitmask)
		{
			for(cell_index_loop = RRM_ZERO ;cell_index_loop < p_s1ap_rrm_kill_cnf->broadcast_cancellation_list.count; cell_index_loop++)
			{
				in_cell_index = p_s1ap_rrm_kill_cnf->broadcast_cancellation_list.broadcast_cancellation[cell_index_loop].cell_index;

				/* Finding the context of the cell in accordence with cell_index */
				context_index = RRM_ZERO;

			    /* SPR 10812 FIX START */
                while(context_index < RRM_MAX_NUM_CELLS )
					{
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
                    {
                        SET_CELL_INDEX(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "PWS_KILL_CNF: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                        if (in_cell_index == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_KILL_CNF: cell ID [%d] matches with broadcast_cancellation_list id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    in_cell_index);

                            print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
						if((p_s1ap_rrm_kill_cnf->broadcast_cancellation_list.broadcast_cancellation[cell_index_loop].
									bitmask & S1AP_RRM_BROADCAST_CANCELLATION_FAIL_CAUSE_PRESENT) &&
								(p_s1ap_rrm_kill_cnf->broadcast_cancellation_list.broadcast_cancellation[cell_index_loop].
								 fail_cause == RRM_RRC_CAUSE_NO_BROADCAST_ONGOING))
						{
							revert_broadcast_status_list[revert_broadcast_status_count++] = context_index;
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
									"KILL_CNF FAILURE <NO BROADCAST_ONGOING> for cell id :%d",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
						}
						else
						{
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_kill_cnf;
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->api_id = S1AP_RRM_KILL_CNF;
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->ongoing_trans_id = trans_id;

                                if(PWS_W_FOR_KILL_CNF == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate)
                                {
                                    if (RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_KILL_CNF_EVENT,
                                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])))
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                                " Invalid KILL CNF received for cell Index :%d",
                                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                                        ret_val = RRM_FAILURE;
                                    }
                                    else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                                    {
                                        /* SPR 21251 Start */
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                                " RRM_CELL_INVALID_STATE_FOR_PWS");
                                        /* SPR 21251 End */
                                        /* coverity : CID 54387*/
                                        RRM_MEM_FREE(p_s1ap_rrm_kill_cnf);
                                        return RRM_FAILURE;
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                                "successfully processed api:%d",api_id);
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                                "Cell [%d] is in substate [%d] after successfull KILL CNF !!",
                                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
                                    }
                                }
                                else
                                {
                                    /* SPR 21251 Start */
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "[KILL CNF ] Un expected event for Cell Index : [%d] in state [%d]",
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate); 
                                    /* SPR 21251 End */
                                    ret_val =RRM_FAILURE;
                                }
                            }
                            print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                            break;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "PWS_KILL_CNF: cell ID [%d] Does Not match with broadcast_cancellation_list id [%d]",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    in_cell_index);
                        }
                    }
                    else
                    {
                      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_KILL_CNF: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
                    }
                    context_index ++;	
                }
			    /* SPR 10812 FIX END */
			}
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Broadcast cancellation list is not present in kill cnf...");

		    /* SPR 10812 FIX START */
			while(context_index  < RRM_MAX_NUM_CELLS)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_KILL_CNF: Cell Context for cell ID [%d] is found at [%d] loc in Global cell Context",
                              p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,context_index);
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->p_incoming_api_info = (rrm_void_t *) p_s1ap_rrm_kill_cnf;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->api_id = S1AP_RRM_KILL_CNF;
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->ongoing_trans_id = trans_id;
                    print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                    if(PWS_W_FOR_KILL_CNF == p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate)
                    {
                        if (RRM_FAILURE == (response = cellm_fsm_process_event( RRC_RRM_KILL_CNF_EVENT,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                    " Invalid KILL CNF received for cell Index :%d",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index);
                            ret_val = RRM_FAILURE;
                        }
                        else if( response == RRM_CELL_INVALID_STATE_FOR_PWS)
                        {
                            /* SPR 21251 Start */
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                                  "RRM_CELL_INVALID_STATE_FOR_PWS");
                            /* SPR 21251 End */
                            /* coverity : CID 54387*/
	                        RRM_MEM_FREE(p_s1ap_rrm_kill_cnf);
                            return RRM_FAILURE;
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "successfully processed api:%d",api_id);
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                    "Cell [%d] is in substate [%d] after successfull KILL CNF !!",
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
                        }
                        print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]);
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "[KILL CNF ] Un expected event for Cell Index : [%d] in state [%d]",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->pws_substate);
                        ret_val =RRM_FAILURE;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              "PWS_KILL_CNF: Cell Context is Not present at [%d] loc in Global cell Context",context_index);
                }
                context_index++;
            }
		    /* SPR 10812 FIX END */
		}

		/* Revert the braodcast status for the cells for which CNF failure is recieved*/
		for(loop_index = RRM_ZERO; loop_index < revert_broadcast_status_count;loop_index++)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"[KILL CNF ] is failure , set the sib on broadcast again");
			if (RRM_PNULL != (p_ylnode = ylFind(&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[revert_broadcast_status_list[loop_index]]->
								scheduled_cmas_warning_list),
							p_shed_data_key,
							rrm_cellm_pws_request_sched_data_key ,
							rrm_cellm_shed_data_key_compare)))
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"change the braodcast status as PWS_BROADCAST_ONGOING");
				((scheduled_pws_data_node_t *)p_ylnode)->scheduled_pws_data.broadcast_status = PWS_BROADCAST_ONGOING;
				print_cell_informaton_for_pws(p_g_rrm_cell_ctx->p_rrm_cell_ctx[revert_broadcast_status_list[loop_index]]);
			}

		}
	}

/* coverity : CID 54387*/
    RRM_MEM_FREE(p_s1ap_rrm_kill_cnf);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************ETWS/CMAS**********************************/


/*  DYNAMIC ICIC CHANGES START  */
/*SPR 17777 +-*/

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_load_information_ind_prcess_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes  message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_load_information_ind_prcess_msg
(
    U8 *p_api, /* Pointer to incoming Api buffer*/
    U16 api_id, /* incoming api id*/
    U16 data_len, /* incoming data length*/
    U16 trans_id /* Incoming transaction Id*/
)
{
    x2ap_rrm_load_information_ind_t        *p_x2ap_rrm_load_ind = RRM_PNULL;  
    rrm_return_et                          ret_val = RRM_SUCCESS;
    U8                                     cell_index = RRM_ZERO;
    S32                                    length = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	p_x2ap_rrm_load_ind = (x2ap_rrm_load_information_ind_t *)rrm_mem_get(sizeof
			(x2ap_rrm_load_information_ind_t));
    if (p_x2ap_rrm_load_ind == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_load_ind failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	/* Parse  the incoming message from RRC */
	if (RRM_FAILURE == rrm_parse_x2ap_rrm_load_information_ind(
				p_x2ap_rrm_load_ind,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				RRM_ERROR,"RRC->RRM:X2AP_RRM_LI_ENB_LOAD_INFORMATION_IND failed to parse");
		ret_val = RRM_FAILURE;
	}
	else
    {
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				RRM_INFO,"RRC->RRM:X2AP_RRM_LI_ENB_LOAD_INFORMATION_IND successfully parsed");
        /* 
           API received on X2 inetrface is targetted to all the cells of the eNodeB
           So, this API is distributed to all the cells in the eNodeB.
           As no cell indx is available to identify the serving cell so
           distributing this message to all the Cell FSMs
         */

        for (cell_index = RRM_ZERO; cell_index < RRM_MAX_NUM_CELLS; cell_index++)
        {
            SET_CELL_INDEX(cell_index);
            if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index] != RRM_PNULL)
            {
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = trans_id;
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = api_id;
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_x2ap_rrm_load_ind; 
                if (RRM_FAILURE == cellm_fsm_process_event (
                            RRM_X2AP_ICIC_LOAD_INFO_IND_EVENT,
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                              "unable to process api:%d",api_id);
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                              "successfully processed api:%d",api_id);
                    ret_val = RRM_SUCCESS;
                }
            }
        }
    }
	RRM_MEM_FREE(p_x2ap_rrm_load_ind);
	RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*  DYNAMIC ICIC CHANGES END    */



/****************************************************************************
 * Function Name  : rrm_rrc_msg_handler
 * Inputs         : p_api_buf: Pointer to input api buffer
 *                : rrm_gb_ctx: Pointer to cell global context
 * Outputs        : Success/Failure 
 * Returns        : Success/Failure
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et
rrm_rrc_msg_handler(rrm_void_t                 *p_api/* Pointer to input api buffer*/ 
        /*SPR 17777 +-*/
		)
{
	U16 api_id                  = RRM_ZERO;  /*To store the API id coming from RRC*/
	U16 msg_size                = RRM_ZERO; /*to store the message size coming from RRC*/	
	rrm_return_et	ret_val = RRM_FAILURE;
	U16 trans_id                = RRM_ZERO;
	U8                      *p_data = RRM_PNULL;
    /* SPR 21251 Start */
    rrm_cell_index_t  cell_index=RRM_ZERO;
    /* SPR 21251 End */
	RRM_UT_TRACE_ENTER();


	/*extracting message size*/
	/* data_length = msg_size  - RRM_API_HEADER_SIZE;*/
	api_id   = rrm_get_word_from_header((U8*)(p_api) + RRM_CSPL_API_ID_INDEX/*5*/);

	/* removing CSPL header for getting transaction id*/
	p_data = (U8 *)p_api + RRM_API_HEADER_SIZE;

	trans_id   = rrm_get_word_from_header(p_data + RRM_INTF_TRANS_ID_INDEX/*0*/);
	msg_size = rrm_get_word_from_header((U8*)(p_data) + RRM_INTF_MSG_ID_INDEX/*8*/);
	/* SPR 21251 Start */
    cell_index = rrm_get_cell_id_from_header((U8*)(p_data));
    SET_CELL_INDEX(cell_index);
    /* SPR 21251 End */
	msg_size = msg_size - RRM_INTERFACE_API_HEADER_SIZE;

	/* removing Interface header for parsing
	 */
	p_data   = p_data + RRM_INTERFACE_API_HEADER_SIZE;

	switch(api_id)
	{
		case RRC_RRM_CELL_SETUP_RESP:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_rrc_cell_setup_resp_process_msg( p_data,
					api_id,
					msg_size,
					trans_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRC_RRM_CELL_START_RESP:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_rrc_cell_start_resp_process_msg( p_data, 
					api_id,
					msg_size, 
					trans_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRC_RRM_CELL_RECONFIG_RESP:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_rrc_cell_reconfig_resp_process_msg(p_data,
					api_id,
					msg_size, 
					trans_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRC_RRM_CELL_DELETE_RESP:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_rrc_cell_delete_resp_process_msg(p_data, 
					api_id,
					msg_size, 
					trans_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRC_RRM_CELL_STOP_RESP:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_rrc_cell_stop_resp_process_msg(p_data, 
					api_id, 
					msg_size, 
					trans_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
			/*   tnl discovery */
            /*RIM start*/
        case S1AP_RRM_RIM_INFO:
            ret_val = rrm_rrc_rim_info_process_msg(p_data,
                    api_id,
                    msg_size);
        /*SPR 17777 +-*/
            break;
            /*RIM end*/
		case S1AP_RRM_MME_CONFIG_TRANSFER:

			ret_val = rrm_rrc_tnl_discovery_resp_process_msg(p_data,
					api_id,
					msg_size,
					trans_id);
			break;

		case X2AP_RRM_LINK_UP_IND:
			if(RRM_FAILURE == rrm_rrc_x2ap_link_up_ind_process_msg(p_data,
						api_id,
						msg_size))
                    /*SPR 17777 +-*/
			{
				ret_val = RRM_FAILURE;
			}
			else
			{
				ret_val = RRM_SUCCESS;
			}
			break;
		case X2AP_RRM_LINK_DOWN_IND:
			if(RRM_SUCCESS == rrm_rrc_x2ap_link_down_ind_process_msg( p_data,
						api_id,
						msg_size))
                        /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		/* mod by yhliu 20191015 for ENDC config update --start */
#ifdef ENDC_ENABLED
		case X2AP_ENDC_CONFIG_UPDATE_IND:
			if(RRM_SUCCESS == rrm_rrc_x2ap_endc_config_update_en_gnb_ind_process_msg( p_data,
						api_id,
						msg_size))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case X2AP_ENDC_CONFIG_UPDATE_RES:
			if(RRM_SUCCESS == rrm_rrc_x2ap_endc_config_update_res_process_msg( p_data,
						api_id,
						msg_size))                   
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;

#endif
		/* mod by yhliu 20191015 for ENDC config update --end */
		case RRC_RRM_UPDATED_PWS_SI_LIST_REQ:
			if(RRM_SUCCESS == rrm_rrc_updated_pws_list_req_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case RRC_RRM_UPDATED_PWS_SI_LIST_CNF:
			if(RRM_SUCCESS == rrm_rrc_updated_pws_list_cnf_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case S1AP_RRM_PWS_REQ:
			if(RRM_SUCCESS == rrm_rrc_s1ap_pws_req_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case S1AP_RRM_PWS_CNF:
			if(RRM_SUCCESS ==  rrm_rrc_s1ap_pws_cnf_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}

			break;
		case S1AP_RRM_KILL_REQ:
			if(RRM_SUCCESS == rrm_rrc_s1ap_kill_req_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}

			break;
		case S1AP_RRM_KILL_CNF:
			if(RRM_SUCCESS == rrm_rrc_s1ap_kill_cnf_process_msg( p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
			/* Code for MLB Start */
		case X2AP_RRM_RSU_ENB_START_RES:
			if (RRM_SUCCESS == rrm_rrc_x2ap_rrm_rsu_enb_start_res_process_msg (p_data,
						api_id,
						msg_size,
						trans_id))
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case X2AP_RRM_RSU_ENB_START_REQ:
			if (RRM_SUCCESS == rrm_rrc_x2ap_rrm_rsu_enb_start_req_process_msg (p_data,
						api_id,
						msg_size))
                        /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case X2AP_RRM_RSU_ENB_STOP_REQ:
			if (RRM_SUCCESS == rrm_rrc_x2ap_rrm_rsu_enb_stop_req_process_msg (p_data,
						api_id,
						msg_size))
                        /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case X2AP_RRM_RSU_ENB_STOP_RES:
			if (RRM_SUCCESS == rrm_rrc_x2ap_rrm_rsu_enb_stop_res_process_msg (p_data,
						api_id,
						msg_size))
                        /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
		case X2AP_RRM_RSU_ENB_UPDATE_IND:
			if (RRM_SUCCESS == rrm_rrc_x2ap_rrm_rsu_enb_update_ind_process_msg (p_data,
						api_id,
						msg_size))
                        /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
			break;
			/* Code for MLB End */

            /* DYNAMIC ICIC CHANGES START */
        case X2AP_RRM_LI_ENB_LOAD_INFORMATION_IND:
            if ( RRM_FAILURE == rrm_rrc_x2ap_load_information_ind_prcess_msg(p_data,
                                                                        api_id,
                                                                        msg_size,
                                                                        trans_id))
            {
                ret_val = RRM_FAILURE;
            }
            else
            {
                ret_val = RRM_SUCCESS;
            }
            break;
        
        case X2AP_RRM_LI_ENB_LOAD_INFORMATION_RES: 
            if(RRM_FAILURE == rrm_rrc_x2ap_rrm_load_info_res_process_msg(p_data,
                                                                        api_id,
                                                                        msg_size,
                                                                        trans_id))
            {
                ret_val = RRM_FAILURE;                            
            }
            else
            {
                ret_val = RRM_SUCCESS;            
            }
            break;
	case S1AP_RRM_LPPA_OTDOA_INFO_REQ:
            /*Coverity_fix_start_54974*/
            if(RRM_FAILURE ==  rrm_rrc_lppa_otdoa_info_req_process_msg(p_data,
                                                           api_id,
                                                           msg_size,
                                                           trans_id))
            {
                ret_val = RRM_FAILURE;
            }
            else
            {
                ret_val = RRM_SUCCESS;
            }
            break;
        /*SPR 16477 Fix Start*/
        /* Received s1ap mme information */
   case S1AP_RRM_MME_INFO:
            if(RRM_FAILURE == rrm_rrc_s1ap_mme_info_process_msg(p_data,
                        msg_size))
            {
                /*SPR 17777 +-*/
                ret_val = RRM_FAILURE;
            }
            break;
        /*SPR 16477 Fix Stop*/

            /* DYNAMIC ICIC CHANGES END */
        #ifdef LTE_EMBMS_SUPPORTED
        case M2AP_RRM_MBMS_SF_INFO_REQ:
            if (RRM_FAILURE == rrm_rrc_m2ap_mbms_sf_info_req(p_data,
                                                    api_id,
                                                    msg_size,
                                                    trans_id))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                             RRM_ERROR,"Failed to process api: %d", api_id);
                ret_val = RRM_FAILURE;

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_BRIEF,"Successfully processed api: %d ",api_id);
                ret_val = RRM_SUCCESS;
            }
            break;
        #endif

		default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
					"rrm_rrc_msg_handler: unexpected api from RRC %d", api_id);
    /*Coverity_fix_end_54974*/
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_ue_del_resp_process_msg
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context 
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the ue delete response from UE to cell
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_ue_del_resp_process_msg(
		rrm_void_t *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
        /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index=RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmuem_cm_delete_all_ue_context_res_t *rrmcm_uem_del_resp = RRM_PNULL;
    /* BUG_11576_FIX_START */
    U8                 index = RRM_ZERO;
    /*Cov_fix_start_64535*/
    /*Cov_fix_end_64535*/
    /* BUG_11576_FIX_END */

	RRM_UT_TRACE_ENTER();
	rrmcm_uem_del_resp =
		(rrmuem_cm_delete_all_ue_context_res_t *)p_api;

	cell_index = rrmcm_uem_del_resp->cell_index;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"UEM->CellM:RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP:[CELL:%d] with response: %d",
			cell_index, rrmcm_uem_del_resp->response);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	if (RRM_TRUE == rrmcm_uem_del_resp->response)/*Kshitij 13571 rel1.3*/
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"UE deleted successfully for cell_index:%d",
				cell_index);
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"UE deleted unsuccefully for cell index:%d",
				cell_index);
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = 
		(void *)p_api; 
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
		RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP;
    /*TRANS ID FIX */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = rrmcm_uem_del_resp->transaction_id; 

	if (RRM_FAILURE == cellm_fsm_process_event (
				RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
				"could not process api id %d in fsm",api_id);
		ret_val = RRM_FAILURE;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
				"Successfully process api id %d in fsm",api_id);
		ret_val = RRM_SUCCESS;
	}
	/*cell deleted free cell index*/
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info 
		= RRM_PNULL; 
	if (CELLM_CELL_DEL_TRIGGERRED_EXTERNALLY == 
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"freeng cell context during cell delete for cell id :%d",cell_index);
		/* UE MEAS CHANGES : STARTS */
		rrmcm_free_meas_config_lists(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
		/* UE MEAS CHANGES : ENDS */
        /* BUG_11576_FIX_START */
        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch)
        {
            for (index = RRM_ZERO; index < 
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.num_of_row; index++)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index])
                {
                    /*SPR 21943 Fix Start*/
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]->p_tpc_id)
                    {
                        RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]->p_tpc_id);
                    }
                    RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]);
                }
            }
            RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch);
            /*SPR 21943 Fix Stop*/
        }

        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch)
        {
            for (index = RRM_ZERO; index < 
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.num_of_row; index++)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index])
                {
                    /*SPR 21943 Fix Start*/
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]->p_tpc_id)
                    {
                        RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]->p_tpc_id);
                    }
                    RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]);
                }
            }
            RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch);
            /*SPR 21943 Fix Stop*/
        }
        /*KPI change stop the timer*/
        if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.kpi_periodic_timer)
        {
            cell_stop_timer(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.kpi_periodic_timer);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->kpi_stat.kpi_periodic_timer = RRM_PNULL;
        }
        /*Cov_fix_start_64535*/
        /*Cov_fix_end_64535*/
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data = RRM_PNULL;
        }
        /* BUG_11576_FIX_END */
        /* SPR 20162 Fix Start */
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st = RRM_PNULL;
        }
        /* SPR 20162 Fix End */
    /*SPR 21223 START*/
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->srs_table.p_wideband_srs_table)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->srs_table.p_wideband_srs_table);
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->srs_table.p_subband_srs_table)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->srs_table.p_subband_srs_table);
        }
    /*SPR 21223 END*/
        /*Bug:9237 start*/
        rrm_clean_cell_queue(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
        /*Bug:9237 end*/

		RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index] = RRM_PNULL;
		/*SPR 17777 +-*/
	}
	else if ((p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_reconfig_deletion_required) ||
			(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered == 
			 CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_ACTIVE_STATE))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"No need to free cell index :%d, ongoing_proc_triggered[%d], cell_reconfig_deletion_required[%d]",
        cell_index, p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered,
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_reconfig_deletion_required);
	}
	else
	{
		/* UE MEAS CHANGES : STARTS */
		rrmcm_free_meas_config_lists(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
		/* UE MEAS CHANGES : ENDS */
        /* BUG_11576_FIX_START */
        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch)
        {
            for (index = RRM_ZERO; index < 
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.num_of_row; index++)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index])
                {
                    /*SPR 21943 Fix Start*/
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]->p_tpc_id)
                    {
                        RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]->p_tpc_id);
                    }
                    RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch[index]);
                }
            }
            RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pusch.p_p_rrm_ue_tpc_rnti_row_pusch);
            /*SPR 21943 Fix Stop*/
        }

        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch)
        {
            for (index = RRM_ZERO; index < 
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.num_of_row; index++)
            {
                if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index])
                {
                    /*SPR 21943 Fix Start*/
                    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]->p_tpc_id)
                    {
                        RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]->p_tpc_id);
                    }
                    RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch[index]);
                }
            }
            RRM_MEM_FREE(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_ue_tpc_rnti_tbl_pucch.p_p_rrm_ue_tpc_rnti_row_pucch);
            /*SPR 21943 Fix Stop*/
        }
        /*Cov_fix_start_64535*/
        /*Cov_fix_end_64535*/
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_reconfig_data = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_ncl_built_from_updated_nrt_info = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_meas_config_sib_info_for_reconfig = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->to_be_scheduled_pws_warning = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->scheduling_info_list_for_pws = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_new_update_data = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config = RRM_PNULL;
        }
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ld_reconfig_data = RRM_PNULL;
        }
        /* SPR 20162 Fix Start */
        if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st)
        {
            RRM_MEM_FREE( p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st);
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->sps_n1_pucch_an_marked_st = RRM_PNULL;
        }
        /* SPR 20162 Fix End */
        rrm_clean_cell_queue(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
        /* BUG_11576_FIX_END */
		/*SPR 17777 +-*/
	}
RRM_UT_TRACE_EXIT();
return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_START */
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_cell_rach_info
 *   DESCRIPTION:
 *        Handles RACH info from MIF
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_return_et                          			    
rrm_cellm_cell_rach_info
(
 U8 *p_api, /*Input Api buffer*/
 U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
 )

{
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrm_cell_index_t                    cell_index = RRM_ZERO;
    rrmcm_rmif_rach_info_ind_t          *p_rach_info_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rach_info_ind = 
        (rrmcm_rmif_rach_info_ind_t *)p_api;	

    cell_index = p_rach_info_ind->cell_index;
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_RACH_INFO_IND->CellM[CELL:%d]",
            cell_index);

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
        return RRM_FAILURE;
    }

    if((p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_rach_info.rach_l2_periodic_timer
                != p_rach_info_ind->l2_reports_periodicity) && 
            (RRM_ZERO != p_rach_info_ind->l2_reports_periodicity) && 
            (RRM_ZERO != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_rach_info.rach_l2_periodic_timer))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Request is for L2 timer reconfiguration");
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_rach_info.rach_l2_periodic_timer =
        p_rach_info_ind->l2_reports_periodicity;

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = 
        (void *)p_api;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = RRMCM_RMIF_RACH_INFO_IND;

    if(RRM_SUCCESS == cellm_fsm_process_event (
                RRMCM_RMIF_RACH_INFO_IND_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    { 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "cellm_fsm_process_event: "
                "Successfully processed api:%d",api_id);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cellm_fsm_process_event: Failed to processed api:%d",api_id);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_cell_rrmim_rac_disable_enable 
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       void
 ******************************************************************************/
rrm_return_et                          			    
rrm_cellm_cell_rrmim_rac_disable_enable
(
 U8 *p_api, /*Input Api buffer*/
 U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
 )

{
	rrm_return_et                           ret_val = RRM_SUCCESS;
	rrm_cell_index_t                        cell_index = RRM_ZERO;
	rrmcm_rmif_rac_enable_disable_req_t	*p_rrmcm_rac_enable_disable_req =
		RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_rrmcm_rac_enable_disable_req = 
		(rrmcm_rmif_rac_enable_disable_req_t *)p_api;	

	cell_index = p_rrmcm_rac_enable_disable_req->cell_index;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->RRMCM_RMIF_RAC_ENABLE_DISABLE_REQ->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = 
		(void *)p_api;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
		RRMCM_RMIF_RAC_ENABLE_DISABLE_REQ;  
	if(RRM_SUCCESS == cellm_fsm_process_event (
				RRMUEM_RMIF_RAC_ENABLE_DISABLE_REQ_EVENT,
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
	{ 
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"cellm_fsm_process_event: "
				"Successfully processed api:%d",api_id);
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"cellm_fsm_process_event: Failed to processed api:%d",api_id);
		ret_val = RRM_FAILURE;
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : map_load_type 
 * Inputs         : load_value: Type of load from Platform 
 * Outputs        : None
 * Returns        : U8
 * Description    : Mapp the load type received from Platform
 ****************************************************************************/
	U8 
map_load_type(load_value type)
{
	rrm_load_type load_type = RRM_LOW;
	switch(type)
	{
		case LOAD_LOW:
			load_type = RRM_LOW;
			break;
		case LOAD_MEDIUM:
			load_type = RRM_MEDIUM;
			break;
		case LOAD_HIGH:
			load_type = RRM_HIGH;
			break;
		case LOAD_OVERLOAD:
			load_type = RRM_OVERLOAD;
			break;
		default:
			load_type =INVALID_LOAD;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Load Type:%d ",load_type);
			break;

	}
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Load Type:%d ",load_type);
	return load_type;
}

/****************************************************************************
 * Function Name  : map_source_type 
 * Inputs         : source_load_type: Type of source from Platform 
 * Outputs        : None
 * Returns        : U8
 * Description    : Mapp the source type received from Platform
 ****************************************************************************/
/* coverity : CID 29633*/
rrm_source_value
map_source_type(rrm_oam_load_src_et source)
{
	rrm_source_value source_value;
	switch(source)
	{
		case SOURCE_TNL:
			source_value = TNL;
			break;
		case SOURCE_MEMORY:
			source_value = MEMORY;
			break;
		case SOURCE_CPU:
			source_value = CPU;
			break;
		default:
			source_value = INVALID_SRC;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Default Source type :%d ",source_value);
			break;

	}
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Source type :%d ",source_value);
	return source_value;
}
/* coverity : CID 29626*/
rrm_x2ap_rsu_load_ind_et
map_x2ap_load_type(rrm_load_type ld_type)
{
	rrm_x2ap_rsu_load_ind_et ld_lvl;
	switch(ld_type)
	{
		case RRM_LOW:
			ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
			break;
		case RRM_MEDIUM:
			ld_lvl = RRM_X2AP_RSU_LOAD_MEDIUM;
			break;
		case RRM_HIGH:
			ld_lvl = RRM_X2AP_RSU_LOAD_HIGH;
			break;
		case RRM_OVERLOAD:
			ld_lvl = RRM_X2AP_RSU_LOAD_OVER;
			break;
		default:
			ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Default Load level :%d ",ld_lvl);
			break;

	}
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Load level :%d ",ld_lvl);
	return ld_lvl;
}

/****************************************************************************
 * Function Name  : chk_global_cell_id 
 * Inputs         : p_rcvd - Its Not NULL pointer
 *                : p_strd - Its Not NULL pointer 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Check stored and recieved global cell Id
 ****************************************************************************/
rrm_return_et chk_global_cell_id(
		rrm_global_cell_id_t     *p_rcvd,
		rrm_global_cell_id_t     *p_strd)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	U8 index = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT(RRM_PNULL != p_rcvd);
	RRM_ASSERT(RRM_PNULL != p_strd);

	/* Comparing MCC Id */
	for (index=RRM_ZERO; index< MAX_MCC_DIGITS; index++)
	{
		if (p_rcvd->primary_plmn_id.mcc[index] != 
				p_strd->primary_plmn_id.mcc[index])
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "stored MCC[%d]  Recvd MCC[%d] "
					"at INDEX[%d]",
					p_strd->primary_plmn_id.mcc[index], 
					p_rcvd->primary_plmn_id.mcc[index], 
					index);
			ret_val = RRM_FAILURE;
			break;
		}
	} 

	if (ret_val != RRM_FAILURE)
	{ 
		/**Comparing MNC Id **/ 
		if (p_rcvd->primary_plmn_id.num_mnc_digit == 
				p_strd->primary_plmn_id.num_mnc_digit)
		{ 
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "No of MNC matches");
			for (index=RRM_ZERO; index< p_rcvd->primary_plmn_id.num_mnc_digit && index < MAX_MNC_DIGITS; index++)
			{
				if (p_rcvd->primary_plmn_id.mnc[index] != 
						p_strd->primary_plmn_id.mnc[index])
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "stored MNC[%d] "
							"Recvd MNC[%d]  at INDEX [%d]", 
							p_strd->primary_plmn_id.mnc[index], 
							p_rcvd->primary_plmn_id.mnc[index], index);
					ret_val = RRM_FAILURE;
					break;
				}
			}/*for loop ends*/
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "stored num_mnc_digit[%d] "
					"Recvd num_mnc_digit[%d]", 
					p_strd->primary_plmn_id.num_mnc_digit, 
					p_rcvd->primary_plmn_id.num_mnc_digit); 
			ret_val = RRM_FAILURE; 
		}
	}


	if (ret_val != RRM_FAILURE)
	{

		/* Comparing Cell Identity */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Comparing Cell Ident");
		for (index=RRM_ZERO; index < MAX_CELL_IDENTITY_OCTETS; index++)
		{
			if (p_strd->cell_identity[index] != p_rcvd->cell_identity[index])
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "stored CELL_ID[%d] "
						"Recvd CELL_ID[%d] at INDEX[%d]", 
						p_strd->cell_identity[index],  
						p_rcvd->cell_identity[index], index);
				ret_val = RRM_FAILURE;
				break;
			}
		}/*for loop ends*/
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name : rrm_updt_num_of_admitted_csg_user
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored num_of_admitted_csg_user param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_admitted_csg_user(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_admitted_csg_user = stored_kpi->num_of_admitted_csg_user;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_admitted_csg_user = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name : rrm_updt_num_of_admitted_non_csg_user
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_admitted_non_csg_user param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_admitted_non_csg_user(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_admitted_non_csg_user= stored_kpi->num_of_admitted_non_csg_user;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_admitted_non_csg_user= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_ue_admission_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_ue_admission_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_ue_admission_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_ue_admission_success= stored_kpi->num_of_ue_admission_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_ue_admission_success = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_ue_admission_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_ue_admission_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_ue_admission_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_ue_admission_fail = stored_kpi->num_of_ue_admission_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_ue_admission_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : 
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_setup_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_setup_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_setup_success = stored_kpi->num_of_erb_setup_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_setup_success = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_erb_setup_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_setup_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_setup_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_setup_fail = stored_kpi->num_of_erb_setup_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_setup_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_erb_modify_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_modify_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_modify_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_modify_success = stored_kpi->num_of_erb_modify_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_modify_success = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_erb_modify_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_modify_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_modify_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_modify_fail = stored_kpi->num_of_erb_modify_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_modify_fail = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_erb_release_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_release_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_release_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_release_success = stored_kpi->num_of_erb_release_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_release_success = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_erb_release_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_erb_release_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_erb_release_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_erb_release_fail = stored_kpi->num_of_erb_release_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_erb_release_fail = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_avg_dl_allocated_gbr_prb
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_avg_dl_allocated_gbr_prb param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_avg_dl_allocated_gbr_prb(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->avg_dl_allocated_gbr_prb = stored_kpi->avg_dl_allocated_gbr_prb;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->avg_dl_allocated_gbr_prb= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_avg_ul_allocated_gbr_prb
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_avg_ul_allocated_gbr_prb param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_avg_ul_allocated_gbr_prb(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->avg_ul_allocated_gbr_prb = stored_kpi->avg_ul_allocated_gbr_prb;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->avg_ul_allocated_gbr_prb = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_avg_dl_allocated_ngbr_prb
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_avg_dl_allocated_ngbr_prb param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_avg_dl_allocated_ngbr_prb(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->avg_dl_allocated_ngbr_prb = stored_kpi->avg_dl_allocated_ngbr_prb;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->avg_dl_allocated_ngbr_prb = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_avg_ul_allocated_ngbr_prb
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_avg_ul_allocated_ngbr_prb param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_avg_ul_allocated_ngbr_prb(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->avg_ul_allocated_ngbr_prb= stored_kpi->avg_ul_allocated_ngbr_prb;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->avg_ul_allocated_ngbr_prb= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_geran_ho_attempt
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_geran_ho_attempt param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_geran_ho_attempt(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_geran_ho_attempt = stored_kpi->num_of_geran_ho_attempt;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_geran_ho_attempt = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_geran_ho_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_geran_ho_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_geran_ho_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_geran_ho_fail = stored_kpi->num_of_geran_ho_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_geran_ho_fail = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_utran_ho_attempt
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_utran_ho_attempt param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_utran_ho_attempt(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_utran_ho_attempt = stored_kpi->num_of_utran_ho_attempt;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_utran_ho_attempt= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_utran_ho_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_utran_ho_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_utran_ho_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_utran_ho_fail = stored_kpi->num_of_utran_ho_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_utran_ho_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_eutran_ho_attempt
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_eutran_ho_attempt param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_eutran_ho_attempt(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_eutran_ho_attempt= stored_kpi->num_of_eutran_ho_attempt;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_eutran_ho_attempt= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_eutran_ho_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_eutran_ho_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_eutran_ho_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_eutran_ho_fail = stored_kpi->num_of_eutran_ho_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_eutran_ho_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_geran_hi_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_geran_hi_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_geran_hi_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_geran_hi_success = stored_kpi->num_of_geran_hi_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_geran_hi_success= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_geran_hi_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_geran_hi_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_geran_hi_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_geran_hi_fail = stored_kpi->num_of_geran_hi_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_geran_hi_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_utran_hi_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_utran_hi_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_utran_hi_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_utran_hi_success = stored_kpi->num_of_utran_hi_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_utran_hi_success= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_utran_hi_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_utran_hi_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_utran_hi_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_utran_hi_fail = stored_kpi->num_of_utran_hi_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_utran_hi_fail = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_eutran_hi_success
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_eutran_hi_success param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_eutran_hi_success(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_eutran_hi_success = stored_kpi->num_of_eutran_hi_success;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_eutran_hi_success= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_eutran_hi_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_eutran_hi_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_eutran_hi_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_eutran_hi_fail = stored_kpi->num_of_eutran_hi_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_eutran_hi_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_enb_init_ho_csg_usr
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_enb_init_ho_csg_usr param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_enb_init_ho_csg_usr(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_enb_init_ho_csg_usr = stored_kpi->num_of_enb_init_ho_csg_usr;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_enb_init_ho_csg_usr= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_enb_init_ho_non_csg_usr
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_enb_init_ho_non_csg_usr param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_enb_init_ho_non_csg_usr(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_enb_init_ho_non_csg_usr = stored_kpi->num_of_enb_init_ho_non_csg_usr;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_enb_init_ho_non_csg_usr= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_enb_init_ue_release
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_enb_init_ue_release param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_enb_init_ue_release(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_enb_init_ue_release = stored_kpi->num_of_enb_init_ue_release;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_enb_init_ue_release= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_pucch_res_alloc_attempts
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_pucch_res_alloc_attempts param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_pucch_res_alloc_attempts(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_pucch_res_alloc_attempts = stored_kpi->num_pucch_res_alloc_attempts;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_pucch_res_alloc_attempts= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}
/*CA STAGE 2*/
/****************************************************************************
 * Function Name : rrm_updt_num_of_ca_ue
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_ca_ue param to
 *                 MIF and reset in cellm
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t 
rrm_updt_num_of_ca_ue(rrmcm_kpi_data_t *stored_kpi,
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *p_reset)

{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_ca_ue = stored_kpi->num_of_ca_ue;
    /* Coverity_ID_Fix_55330 62523 */
    if (RRM_TRUE == *p_reset)
    {
        stored_kpi->num_of_ca_ue = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name : rrm_updt_num_of_sr_res_alloc_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_sr_res_alloc_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_sr_res_alloc_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_sr_res_alloc_fail = stored_kpi->num_of_sr_res_alloc_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_sr_res_alloc_fail= RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_updt_num_of_sr_cqi_alloc_fail
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_num_of_sr_cqi_alloc_fail param to 
 *                 MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_num_of_sr_cqi_alloc_fail(rrmcm_kpi_data_t *stored_kpi, 
                                  rrmcm_kpi_data_t *out_kpi_data,
                                  rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->num_of_sr_cqi_alloc_fail = stored_kpi->num_of_sr_cqi_alloc_fail;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->num_of_sr_cqi_alloc_fail = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}

/* BUG_857 Start*/
/****************************************************************************
 * Function Name : rrm_updt_cell_unavailable_time
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored rrm_updt_cell_unavailable_time
 *                 param to MIF and reset in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_updt_cell_unavailable_time(rrmcm_kpi_data_t *stored_kpi,
                                    rrmcm_kpi_data_t *out_kpi_data,
                                    rrm_bool_et *reset)
{
    RRM_UT_TRACE_ENTER();
    out_kpi_data->cell_unavailable_time = stored_kpi->cell_unavailable_time;
    if (RRM_TRUE == *reset)
    {
        stored_kpi->cell_unavailable_time = RRM_ZERO;
    }
    RRM_UT_TRACE_EXIT();

}  
/* BUG_857 end*/

/*****************************************************************************
 * Array Name     : rrm_cellm_map_bit
 * Inputs         : RRM_MAX_KPI, RRM_EIGHT
 * Outputs        : None
 * Returns        : rrm_cell_bitmap_func_ptr
 * Description    : Definition of two dimensional array of functional pointer
 *          for KPI bit map in cellm.
 ****************************************************************************/
rrm_cell_bitmap_func_ptr rrm_cellm_map_bit[RRM_MAX_KPI][RRM_EIGHT] =
{
    {
        rrm_updt_num_of_admitted_csg_user,
        rrm_updt_num_of_admitted_non_csg_user,
        rrm_updt_num_of_ue_admission_success,
        rrm_updt_num_of_ue_admission_fail,
        rrm_updt_num_of_erb_setup_success,
        rrm_updt_num_of_erb_setup_fail,
        rrm_updt_num_of_erb_modify_success,
        rrm_updt_num_of_erb_modify_fail
    },
    {
        rrm_updt_num_of_erb_release_success,
        rrm_updt_num_of_erb_release_fail,
        rrm_updt_avg_dl_allocated_gbr_prb,
        rrm_updt_avg_ul_allocated_gbr_prb,
        rrm_updt_avg_dl_allocated_ngbr_prb,
        rrm_updt_avg_ul_allocated_ngbr_prb,
        rrm_updt_num_of_geran_ho_attempt,
        rrm_updt_num_of_geran_ho_fail
    },
    {
        rrm_updt_num_of_utran_ho_attempt,
        rrm_updt_num_of_utran_ho_fail,
        rrm_updt_num_of_eutran_ho_attempt,
        rrm_updt_num_of_eutran_ho_fail,
        rrm_updt_num_of_geran_hi_success,
        rrm_updt_num_of_geran_hi_fail,
        rrm_updt_num_of_utran_hi_success,
        rrm_updt_num_of_utran_hi_fail
    },
    {
        rrm_updt_num_of_eutran_hi_success,
        rrm_updt_num_of_eutran_hi_fail,
        rrm_updt_num_of_enb_init_ho_csg_usr,
        rrm_updt_num_of_enb_init_ho_non_csg_usr,
        rrm_updt_num_of_enb_init_ue_release,
        rrm_updt_num_pucch_res_alloc_attempts,
        rrm_updt_num_of_sr_res_alloc_fail,
        rrm_updt_num_of_sr_cqi_alloc_fail
    },
    {
        rrm_updt_cell_unavailable_time,
        rrm_updt_num_of_ca_ue,                     /*CA STAGE 2*/
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL
    }
};

/****************************************************************************
 * Function Name : 
 * Inputs        : stored_kpi -Its Not NULL pointer
 *                 out_kpi_data - Its Null Pointer      
 *                 reset
 * Outputs       : None
 * Return        : Void
 * Description   : This function send stored KPI params to 
 *                 MIF and reset KPI params in cellm 
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_cellm_mapping_kpi_bit(rrmcm_kpi_data_t *stored_kpi, 
        rrmcm_kpi_data_t *out_kpi_data, 
        rrmcm_rmif_kpi_t *kpi_to_report, 
        rrm_bool_et *reset)
{
    U8 index = RRM_ZERO;
    U8 kpi_val = RRM_ZERO;
    U8 kpi_bit = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    
    for (index = RRM_ZERO;index<RRM_MAX_KPI;index++)
    {
        if (RRM_ZERO != kpi_to_report->bitmap[index])
        {
            kpi_val = kpi_to_report->bitmap[index];
            kpi_bit = RRM_ZERO;
            while(RRM_ZERO != kpi_val)
            {
                if(kpi_val & RRM_ONE)
                {
                    rrm_cellm_map_bit[index][kpi_bit](stored_kpi, out_kpi_data, reset); 
                }
                kpi_val = kpi_val>>RRM_ONE;
                ++kpi_bit;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name : rrm_calculate_uplink_downlink_ue_count_for_scheduling 
 * Inputs        : p_cell_context
 * Outputs       : p_dl_ue_schedule , p_ul_ue_schedule 
 * Return        : rrm_return_et
 * Description   : This function calculate ue schedule count in uplink and downlink
 ****************************************************************************/
rrm_void_t 
rrm_calculate_uplink_downlink_ue_count_for_scheduling( rrm_cell_context_t  *p_cell_context,
                                                       U8                  *p_dl_ue_schedule,
                                                       U8                  *p_ul_ue_schedule )
{

    float                           ul_ue_to_be_schedule = RRM_ONE;
    float                           dl_ue_to_be_schedule = RRM_ONE;
    U8                              ul_ue_to_be_schedule_INT = RRM_ONE;
    U8                              dl_ue_to_be_schedule_INT = RRM_ONE;
    U16                             active_dl_ue = 
                                    p_cell_context->ue_scheduling_perfs.active_ue_ul_dl_stats.totalActiveUEsInDl;
    U16                             active_ul_ue = 
                                    p_cell_context->ue_scheduling_perfs.active_ue_ul_dl_stats.totalActiveUEsInUl;
    U16                             total_ue_to_schedule = ( p_cell_context->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_dl
                                                              + p_cell_context->operator_info.rrm_ue_scheduling_info.max_ue_scheduled_ul );


    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
    "Active Ue count [%d] for downlink , Active Ue count [%d] for uplink",
    active_dl_ue, active_ul_ue );

    /* any of active ue in ul and dl are zero then make it non zero */
    if( ( RRM_ZERO == active_dl_ue ) && ( RRM_ZERO == active_ul_ue ))
    {
        active_dl_ue = RRM_ONE;
        active_ul_ue = RRM_ONE;
    }
    else if( active_dl_ue == RRM_ZERO )
    {
        active_dl_ue = RRM_ONE;/* active ue in dl is zero , so considering atleast 1 active ue for dl*/
    }
    else if( active_ul_ue == RRM_ZERO )
    {
        active_ul_ue = RRM_ONE;/* active ue in ul is zero , so considering atleast 1 active ue for ul*/
    }

    /* divide by zero exception will not occur as above part of code are written
       to make sure this */

    dl_ue_to_be_schedule = 
                  (((float)active_dl_ue / ( active_dl_ue + active_ul_ue ))* total_ue_to_schedule );

    ul_ue_to_be_schedule = 
                  (((float)active_ul_ue / ( active_dl_ue + active_ul_ue ))* total_ue_to_schedule );

    /* rounding off to floor limit of float number : absoulte val */
    dl_ue_to_be_schedule_INT = (U8)dl_ue_to_be_schedule;
    ul_ue_to_be_schedule_INT = (U8)ul_ue_to_be_schedule;

    /* considering the decimal factor of ratio 
       if  n , m :( n  > ( n + .5 ) )= n +1,m  */
    if((( ( dl_ue_to_be_schedule + RRM_ROUNDING_FACTOR ) > ((double)( dl_ue_to_be_schedule_INT + RRM_ONE ) ))
          && (ul_ue_to_be_schedule > RRM_ROUNDING_FACTOR ))  || (dl_ue_to_be_schedule <= RRM_ROUNDING_FACTOR))
    {
        dl_ue_to_be_schedule_INT = dl_ue_to_be_schedule_INT + RRM_ONE;
    }
    else if( ( dl_ue_to_be_schedule == (float)dl_ue_to_be_schedule_INT) || ((float)ul_ue_to_be_schedule_INT == ul_ue_to_be_schedule ));
    else 
    {
        ul_ue_to_be_schedule_INT = ul_ue_to_be_schedule_INT + RRM_ONE;
    }

    
    /* setting function out params to be used out side of this function 
        as calculated ue count for uplink and downlink  */
     *p_dl_ue_schedule = dl_ue_to_be_schedule_INT;
     *p_ul_ue_schedule = ul_ue_to_be_schedule_INT;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
    "Calculated Ue count [%d] to be schedule for downlink , ue count [%d] to be"
    "schedule for uplink",*p_dl_ue_schedule,*p_ul_ue_schedule );

    RRM_UT_TRACE_EXIT();

}



/****************************************************************************
 * Function Name : rrm_schedule_downlink_uplink_ue
 * Inputs        : p_cell_context 
 * Outputs       : None
 * Return        : rrm_return_et
 * Description   : This function send ue schedule count in uplink and downlink 
 ****************************************************************************/
rrm_return_et
rrm_schedule_downlink_uplink_ue( rrm_cell_context_t  *p_cell_context )
{

    rrm_return_et                   ret_val = RRM_SUCCESS;
    U8                              ue_ul_to_be_schedule = RRM_ONE;
    U8                              ue_dl_to_be_schedule = RRM_ONE;
    U8                              ul_hysteresis_delta = RRM_ZERO; 
    U8                              dl_hysteresis_delta = RRM_ZERO; 
    RrmMacReconfigSchedulerReq   *p_out_reconf_schedule_msg = RRM_PNULL;


    RRM_UT_TRACE_ENTER();


    rrm_calculate_uplink_downlink_ue_count_for_scheduling( p_cell_context ,
                                                           &ue_dl_to_be_schedule,
                                                           &ue_ul_to_be_schedule );


    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
    "Last configured ue count [%d] for downlink, count [%d] for uplink",
    p_cell_context->ue_schedule_to_dl,
    p_cell_context->ue_schedule_to_ul );

    /* calculating dl hysteresis delta */
    if( p_cell_context->ue_schedule_to_dl > ue_dl_to_be_schedule )
    {
        dl_hysteresis_delta = ( p_cell_context->ue_schedule_to_dl - ue_dl_to_be_schedule );
    }
    else
    {
        dl_hysteresis_delta = ( ue_dl_to_be_schedule - p_cell_context->ue_schedule_to_dl );
    }

    /* calculating ul hysteresis delta */
    if( p_cell_context->ue_schedule_to_ul > ue_ul_to_be_schedule )
    {
        ul_hysteresis_delta = ( p_cell_context->ue_schedule_to_ul - ue_ul_to_be_schedule );
    }
    else
    {
        ul_hysteresis_delta = ( ue_ul_to_be_schedule - p_cell_context->ue_schedule_to_ul );
    }

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
    "Hysteresis delta for dl [%d],Hysteresis delta for ul [%d],Hysteresis delta [%d]"
    "coming from OAM", dl_hysteresis_delta , ul_hysteresis_delta ,
    p_cell_context->operator_info.rrm_ue_scheduling_info.ue_scheduling_hysteresis );


    /* if any of hyeteresis delta is greator than coming hysteresis delta from OAM */ 
    if( ( dl_hysteresis_delta >= p_cell_context->operator_info.rrm_ue_scheduling_info.
                                       ue_scheduling_hysteresis ) || 
        ( ul_hysteresis_delta >= p_cell_context->operator_info.rrm_ue_scheduling_info.
                                       ue_scheduling_hysteresis ) )
    {
       /* allocate the memory */
        p_out_reconf_schedule_msg = (RrmMacReconfigSchedulerReq*)
                                        rrm_mem_get(sizeof(RrmMacReconfigSchedulerReq));
       
        if( RRM_PNULL != p_out_reconf_schedule_msg )
        {
           p_out_reconf_schedule_msg->schedulerParamBitMap = 0x00;

           /* set the bitmask of ue schedule info */
           p_out_reconf_schedule_msg->schedulerParamBitMap |= UES_TO_BE_SCHEDULED_DL_UL_PER_TTI; 
            
           p_out_reconf_schedule_msg->maxUEsToBeScheduledDlUl.maxUEsToBeScheduledDL = ue_dl_to_be_schedule;
           p_out_reconf_schedule_msg->maxUEsToBeScheduledDlUl.maxUEsToBeScheduledUL = ue_ul_to_be_schedule;

           l2_reconfig_scheduler_process_msg( p_out_reconf_schedule_msg,
                                              RRM_MODULE_ID,
                                              RRM_ONE,
                                              p_cell_context->cell_index );
                     
           /* free the allocated memory */ 
           RRM_MEM_FREE(p_out_reconf_schedule_msg);

           /* storing the data in cell context's where we stored the 
              the data from OAM: 
              This is ue count in uplink and downlink, those have to be schedule */
           p_cell_context->ue_schedule_to_dl = ue_dl_to_be_schedule; 
           p_cell_context->ue_schedule_to_ul = ue_ul_to_be_schedule; 

           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
           "RRM successfully sent the reconfig scheduler req to mac");
       }
       else
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
           "Memory allocation failed for rrm_l2_reconf_scheduler_req_t message");
           ret_val = RRM_FAILURE;
       }
    }
    else
    {
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
       "Hysteresis delta for ul or dl is lesss than  coming hysteresis from OAM,"
       "so not sending the ue scheduler reconfig req");
       
    }

    RRM_UT_TRACE_EXIT();

   return ret_val;
}

/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_cell_build_and_send_rach_info_to_mif
 * Inputs         : p_cell_ctx: pointer of cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Build and Send RACH report to MIF
 ****************************************************************************/
rrm_return_et 
rrm_cell_build_and_send_rach_info_to_mif(rrm_cell_context_t *p_cell_ctx)
{
    rrmcm_rmif_rach_l2_report_t    rrm_cell_rach_l2_report = {RRM_ZERO};
    rrm_return_et   ret_val = RRM_SUCCESS;
    U8              index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /*spr_11504_changes_start*/
    rrm_cell_rach_l2_report.cell_index = p_cell_ctx->cell_index;
    /*spr_11504_changes_end*/

    rrm_cell_rach_l2_report.num_of_l2_perf_accumulated_reports = 
        p_cell_ctx->cell_rach_info.cell_rach_data.num_of_l2_perf_accumulated_reports;
    rrm_cell_rach_l2_report.total_rcvd_msg3_random_access_preambles_cbra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cbra;
    rrm_cell_rach_l2_report.total_rcvd_msg3_random_access_preambles_cfra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cfra;
    rrm_cell_rach_l2_report.total_failed_random_access_preambles_msg2_cbra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cbra;
    rrm_cell_rach_l2_report.total_failed_random_access_preambles_msg2_cfra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cfra;
    rrm_cell_rach_l2_report.total_allocated_random_access_preambles = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_allocated_random_access_preambles;
/* SPR-18438 START */
    rrm_cell_rach_l2_report.num_random_access_preambles_group_a =
        p_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_a;
    rrm_cell_rach_l2_report.num_random_access_preambles_group_b = 
        p_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_b;
    /* SPR-18438 END */

    for(index = RRM_ZERO; index < MAX_TA_RANGE; index++)
    {
        rrm_cell_rach_l2_report.total_succ_random_access_ta[index] = 
            p_cell_ctx->cell_rach_info.cell_rach_data.total_succ_random_access_ta[index];
    }

    rrm_cell_rach_l2_report.total_unassigned_false_cfra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_unassigned_false_cfra;
    rrm_cell_rach_l2_report.total_unassigned_sum_cfra = 
        p_cell_ctx->cell_rach_info.cell_rach_data.total_unassigned_sum_cfra;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Resetting RACH data in cell context as ZERO as data has been posted to SON");

    p_cell_ctx->cell_rach_info.cell_rach_data.num_of_l2_perf_accumulated_reports = RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cbra= RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cfra = RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cbra = RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cfra = RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_allocated_random_access_preambles = RRM_ZERO;
 /* SPR-18438 START */
    p_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_a = RRM_ZERO; 
    p_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_b = RRM_ZERO; 
    /* SPR-18438 END */

    for(index = RRM_ZERO; index < MAX_TA_RANGE; index++)
    {
        p_cell_ctx->cell_rach_info.cell_rach_data.total_succ_random_access_ta[index] = RRM_ZERO;
    }
    p_cell_ctx->cell_rach_info.cell_rach_data.total_unassigned_false_cfra = RRM_ZERO;
    p_cell_ctx->cell_rach_info.cell_rach_data.total_unassigned_sum_cfra = RRM_ZERO;

    ret_val =rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
            RRMCM_RMIF_RACH_L2_REPORT,
            sizeof(rrmcm_rmif_rach_l2_report_t),
            (void *)&rrm_cell_rach_l2_report);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "cell index[%u] [%s] in sending RRMCM_RMIF_RACH_L2_REPORT", 
            rrm_cell_rach_l2_report.cell_index,(ret_val == RRM_SUCCESS?"successful":"unsuccessful"));

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */

/****************************************************************************
 * Function Name  : rrm_cell_build_and_send_kpi_to_mif 
 * Inputs         : p_cell_ctx: pointer of cell context 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Build ans Send KPI indication to MIF
 ****************************************************************************/
rrm_return_et 
rrm_cell_build_and_send_kpi_to_mif(rrm_cell_context_t *p_cell_ctx)
{
    rrmcm_kpi_ind_t rrm_cell_kpi={RRM_ZERO};
    rrm_return_et   ret_val = RRM_SUCCESS;
    rrm_bool_et     reset = RRM_FALSE;
    /* BUG_857 Start*/
    struct timeval duration = {RRM_ZERO};
    /* BUG_857 end*/

    RRM_UT_TRACE_ENTER();
    /*Fill admitted csg user and non csg admitted user*/ 
    /*bug_12707_changes_start*/
    /*bug_12707_changes_end*/
    /* BUG_857 Start*/
    if(RRM_ZERO != p_cell_ctx->kpi_stat.cell_stop_time.tv_sec)
    {
        if (CELL_STATE_INACTIVE == p_cell_ctx->cell_state)
        {
            RRM_GETTIMEOFDAY(&duration,RRM_PNULL);
            /* CSR-81563[SPR-11383]-fix start */
            p_cell_ctx->kpi_stat.kpi.cell_unavailable_time =
                ((duration.tv_sec - p_cell_ctx->kpi_stat.cell_stop_time.tv_sec) + p_cell_ctx->kpi_stat.accumulative_duration);
        }
        else
        {
            p_cell_ctx->kpi_stat.kpi.cell_unavailable_time = p_cell_ctx->kpi_stat.accumulative_duration;
        }
    }
    /* BUG_857 end*/
        /* CSR-81563[SPR-11383]-fix end */
    rrm_cellm_mapping_kpi_bit(&(p_cell_ctx->kpi_stat.kpi), 
                              &(rrm_cell_kpi.kpi_data),
                              &(p_cell_ctx->kpi_stat.kpi.kpi_bit), 
                              &reset);
    
    rrm_cell_kpi.cell_index = p_cell_ctx->cell_index;
    rrm_cell_kpi.kpi_data.kpi_bit = p_cell_ctx->kpi_stat.kpi.kpi_bit;
    ret_val =rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				RRMCM_RMIF_KPI_IND,
				sizeof(rrmcm_kpi_ind_t),
				(void *)&rrm_cell_kpi);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	     	"cell index[%u] [%s] in sending RRMCM_RMIF_KPI_IND", 
            rrm_cell_kpi.cell_index,(ret_val == RRM_SUCCESS?"successful":"unsuccessful"));

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_process_get_kpi_req 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the Get Kpi Req from MIF
 ****************************************************************************/
rrm_return_et 
rrm_cellm_process_get_kpi_req(
		void *p_api)
        /*SPR 17777 +-*/
{
    rrm_return_et              ret_val = RRM_SUCCESS;
    rrmcm_rmif_get_kpi_req_t   *p_get_kpi_req = RRM_PNULL;
    rrmcm_rmif_get_kpi_resp_t  cell_get_kpi_resp ={RRM_ZERO}; 
    rrm_cell_context_t         *p_cell_ctx= RRM_PNULL;
    /* BUG_857 Start*/
    struct timeval duration = {RRM_ZERO};
    /* BUG_857 end*/

    RRM_UT_TRACE_ENTER();
   
    p_get_kpi_req = (rrmcm_rmif_get_kpi_req_t *)p_api;
    SET_CELL_INDEX(p_get_kpi_req->cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "MIF->RRMCM_RMIF_GET_KPI_REQ->CellM:[CELL:%d]",p_get_kpi_req->cell_index);
	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_get_kpi_req->cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			"Cell context not found for Cell Index [%d] for which GET KPI REQUEST found",
			p_get_kpi_req->cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
    p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_get_kpi_req->cell_index];
    
    /*KPI: start*/
    /* CSR-81563[SPR-11383]-fix start */
    if (RRM_TRUE == p_get_kpi_req->reset)
    {
        p_cell_ctx->kpi_stat.accumulative_duration = RRM_ZERO;
    }

    /* BUG_857 Start*/
    if(RRM_ZERO != p_cell_ctx->kpi_stat.cell_stop_time.tv_sec)
    {
        if (CELL_STATE_INACTIVE == p_cell_ctx->cell_state)
        {
            RRM_GETTIMEOFDAY(&duration,RRM_PNULL);
            if (RRM_TRUE == p_get_kpi_req->reset)
            {
                p_cell_ctx->kpi_stat.cell_stop_time.tv_sec = duration.tv_sec;
            }
            p_cell_ctx->kpi_stat.kpi.cell_unavailable_time =
                ((duration.tv_sec - p_cell_ctx->kpi_stat.cell_stop_time.tv_sec) + p_cell_ctx->kpi_stat.accumulative_duration);
        }
        else
        {
            p_cell_ctx->kpi_stat.kpi.cell_unavailable_time = p_cell_ctx->kpi_stat.accumulative_duration;
        }
        /* CSR-81563[SPR-11383]-fix end */
    }
    /* BUG_857 end*/
    /*KPI: end*/
    rrm_cellm_mapping_kpi_bit(&(p_cell_ctx->kpi_stat.kpi), 
                              &(cell_get_kpi_resp.kpi),
                              &(p_get_kpi_req->kpi_to_report),
                              &(p_get_kpi_req->reset)
                              );
    
    /* CSR 00070663 FIX START */
    /* SPR-12599-fix start */
    /* Code Deleted*/
    /* SPR-12599-fix end */
    /* CSR 00070663 FIX END */
    
    cell_get_kpi_resp.cell_index = p_get_kpi_req->cell_index;
    cell_get_kpi_resp.trans_id = p_get_kpi_req->trans_id;
    cell_get_kpi_resp.response= RRM_SUCCESS;
    cell_get_kpi_resp.fail_cause= RRM_NO_ERROR;
    cell_get_kpi_resp.kpi.kpi_bit= p_get_kpi_req->kpi_to_report;

	ret_val =rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				RRMCM_RMIF_GET_KPI_RESP,
				sizeof(rrmcm_rmif_get_kpi_resp_t),
				(void *)&cell_get_kpi_resp);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	     	"cell index[%u] [%s] in sending RRMCM_RMIF_GET_KPI_RESP", 
            p_get_kpi_req->cell_index,(ret_val == RRM_SUCCESS? "successful":"unsuccessful"));

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_process_config_kpi_req 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the KPi config req from MIF
 ****************************************************************************/
rrm_return_et 
rrm_cellm_process_config_kpi_req(
		void *p_api)
        /*SPR 17777 +-*/
{
    rrm_return_et                 ret_val = RRM_SUCCESS;
    rrmcm_rmif_kpi_config_req_t   *p_config_kpi_req = RRM_PNULL;
    /* Coverity_ID : 30998 */
    cell_timer_buf_t              timer_buf = {CELL_PERIODIC_TIMER_FOR_ANR,RRM_ZERO,RRM_ZERO,RRM_ZERO };
    rrmcm_rmif_generic_resp_t     generic_resp_to_mif = {RRM_ZERO};
    rrm_cell_context_t            *p_cell_ctx= RRM_PNULL;
    /* SPR 22453 Fix +- */
    U8                            index = RRM_ZERO;
    rrm_bool_et                  bitmap_is_present = RRM_FALSE;
    
    RRM_UT_TRACE_ENTER();

    p_config_kpi_req = (rrmcm_rmif_kpi_config_req_t *)p_api;
    SET_CELL_INDEX(p_config_kpi_req->cell_index);
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "MIF->CellM:RRMCM_RMIF_CONFIG_KPI_REQ:[CELL:%d]",p_config_kpi_req->cell_index);
	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_config_kpi_req->cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			"cell context not found for cell index: %d for which Config KPI Req found ",p_config_kpi_req->cell_index);
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}
    p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_config_kpi_req->cell_index];
    /*Fill response to MIF*/
    generic_resp_to_mif.cellindex= p_config_kpi_req->cell_index;
    generic_resp_to_mif.transaction_id= p_config_kpi_req->trans_id;
    generic_resp_to_mif.response = RRM_SUCCESS;
    generic_resp_to_mif.fail_cause = RRM_NO_ERROR; 
    /* periodic_reporting 0 signify Disabled (0)
     * periodic_reporting 1 signify Enabled (1)
     * Duration must be present incase periodic reporting is set to 
     * Enabled and periodic reporting is not already ongoing.
     */
    if(p_config_kpi_req->periodic_reporting == RRM_TRUE)
    {
        /*If config kpi is received first time.timer value is mandatory*/
        if(!(p_config_kpi_req->bitmask & RRMCM_KPI_CONFIG_DURATION_PRESENT)&& 
            (RRM_PNULL == p_cell_ctx->kpi_stat.kpi_periodic_timer)) 
        {
		    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"timer value is not present for cell index[%u]", p_config_kpi_req->cell_index);
            /*Send failure to Mif. timer is not present */
            generic_resp_to_mif.response = RRM_FAILURE;
            generic_resp_to_mif.fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT; 
        }
        else
        {
            /*Update the bits of kpi*/
            for(index = RRM_ZERO;index<RRM_MAX_KPI;index++)
            {
                p_cell_ctx->kpi_stat.kpi.kpi_bit.bitmap[index] |= p_config_kpi_req->kpi_to_report.bitmap[index];                 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "cell index[%d] set kpi bitmap[0x%x]",p_config_kpi_req->cell_index, 
                        p_cell_ctx->kpi_stat.kpi.kpi_bit.bitmap[index]);
                if (RRM_ZERO != p_cell_ctx->kpi_stat.kpi.kpi_bit.bitmap[index])
                {
                    bitmap_is_present = RRM_TRUE;
                }
            }
            /*start the timer*/
            if ((p_config_kpi_req->bitmask & RRMCM_KPI_CONFIG_DURATION_PRESENT )&& 
                (RRM_TRUE == bitmap_is_present))
            {
                timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_KPI;
                timer_buf.cell_index = p_config_kpi_req->cell_index;
                if(RRM_PNULL != p_cell_ctx->kpi_stat.kpi_periodic_timer)
                {
                    cell_stop_timer(p_cell_ctx->kpi_stat.kpi_periodic_timer);
                    p_cell_ctx->kpi_stat.kpi_periodic_timer = RRM_PNULL;
                }
                p_cell_ctx->kpi_stat.duration = p_config_kpi_req->duration;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "cell index[%u] start timer CELL_PERIODIC_TIMER_FOR_KPI duration[%u]",
                        p_cell_ctx->cell_index, p_cell_ctx->kpi_stat.duration); 
                /* CID : 60715 Fix Start */
                p_cell_ctx->kpi_stat.kpi_periodic_timer = cell_start_timer(CELL_PERIODIC_TIMER_FOR_KPI,(rrm_void_t *)&timer_buf,
                            sizeof(cell_timer_buf_t),p_cell_ctx);
                /* CID : 60715 Fix End */
            }
            else if (RRM_FALSE == bitmap_is_present)
            {
                generic_resp_to_mif.response = RRM_FAILURE;
                generic_resp_to_mif.fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT; 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "cellId[%u] None of the bits are set", p_cell_ctx->cell_index); 
            }

        }
    }
    else
    {
        /*unset the bitmap*/
        for(index = RRM_ZERO;index<RRM_MAX_KPI;index++)
        {
            /* SPR 22543 Fix Start */
            p_cell_ctx->kpi_stat.kpi.kpi_bit.bitmap[index] = RRM_ZERO;
            /* SPR 22543 Fix End */

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "cell index[%d] after unset kpi bitmap[0x%x]",p_config_kpi_req->cell_index, 
                    p_cell_ctx->kpi_stat.kpi.kpi_bit.bitmap[index]);
        }
        /* SPR-17852 START */
        /*timer is running and not null. Stop the timer. all bits of kpi is unset*/
        if ((RRM_TRUE != bitmap_is_present) &&
            (p_cell_ctx->kpi_stat.kpi_periodic_timer)) 
        {
        /* SPR-17852 END */
		    cell_stop_timer(p_cell_ctx->kpi_stat.kpi_periodic_timer);
            p_cell_ctx->kpi_stat.kpi_periodic_timer = RRM_PNULL;
        }
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"cell index[%u] disable config kpi req", p_config_kpi_req->cell_index);
    }
    build_and_send_generic_resp_to_mif(&generic_resp_to_mif,
     RRMCM_RMIF_CONFIG_KPI_RESP);
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_platform_load_ind 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Platform
 ****************************************************************************/
rrm_return_et 
rrm_cellm_platform_load_ind(
		void *p_api)
        /*SPR 17777 +-*/
{
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_cell_platform_t *platform_load_ind = RRM_PNULL;
	U16 cell_index = RRM_ZERO;
	/* MLB Changes Start */
	rrm_source_value  ld_src_type = INVALID_SRC;
	rrm_load_type     ld_type = INVALID_LOAD;
	rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
	U8 load_source_cnt = RRM_ZERO;
	U8 resrc_cnt = RRM_NULL;
	U8 srv_ld_val = RRM_NULL;
	/* MLB Changes End */

	RRM_UT_TRACE_ENTER();

	platform_load_ind = (rrmcm_rmif_cell_platform_t *)p_api;
	cell_index = platform_load_ind->cell_index;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_CELL_PLATFORM_IND->CellM");
	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
               "cell context not found for cell index:%d",
               cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	else
	{
		p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]; 
		switch (platform_load_ind->ind_type)
		{
			case RRM_PERIODIC:
				{
					for( load_source_cnt = RRM_ZERO; ((load_source_cnt < platform_load_ind->count)&& 
								(load_source_cnt < RRM_MAX_SOURCE)); load_source_cnt++)
					{
						ld_src_type = map_source_type(platform_load_ind->cell_load[load_source_cnt].load_src);
						if(RRM_CELL_LOAD_COMPOSITE_PRESENT & p_cell_ctx->cell_load_action.choice)
						{
							ld_type = rrm_get_cur_load_level(&p_cell_ctx->cell_load_action.u.comp_load_info,
									platform_load_ind->cell_load[load_source_cnt].load_level);
							srv_ld_val = platform_load_ind->cell_load[load_source_cnt].load_level;
							if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT) 
							{
								p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
										ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
															      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage : p_cell_ctx->svr_cell_load_info.rr_load.\
															      ul_total_prb_usage;
								if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
								{
									p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
								}
							}
							else
							{
								p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
							}
						}
						else if(RRM_CELL_LOAD_RESRC_SPEC_PRESENT & p_cell_ctx->cell_load_action.choice)
						{
							for (resrc_cnt = RRM_ZERO; resrc_cnt < p_cell_ctx->cell_load_action.u.resrc_spec_info.count; ++resrc_cnt)
							{
								if ((RRM_CELLM_HW_RESRC == p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type) &&
										(( MEMORY == ld_src_type) || (CPU == ld_src_type )))
								{
									ld_type = rrm_get_cur_load_level(&p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn,
											platform_load_ind->cell_load[load_source_cnt].load_level);
									srv_ld_val = platform_load_ind->cell_load[load_source_cnt].load_level;
									if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
												ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
																	      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage :\
																	      p_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage;
										if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
										{
											p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
										}
									}
									else
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
									}
								}
								else if (RRM_CELLM_TNL_RESRC == p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type)
								{
									ld_type = rrm_get_cur_load_level(&p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn,
											platform_load_ind->cell_load[load_source_cnt].load_level);
									srv_ld_val = platform_load_ind->cell_load[load_source_cnt].load_level;
									if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
												ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
																	      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage :\
																	      p_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage;
										if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
										{
											p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
										}
									}
									else
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
									}
								}
							}
						}
						else
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
									"Default load config is not Available or MLB is not enabled");
						}
						if (INVALID_SRC != ld_src_type)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
									"Platform Ind received from Src :%s[%d], Load Type:%s[%d]",
									CELL_LOAD_SRC[ld_src_type],
									ld_src_type,
									CELL_LOAD_TYPE_STATE[ld_type],
									ld_type);

							switch (ld_src_type)
							{
								case MEMORY:
									/* SPR 21020 Fix Start */
									{
										p_cell_ctx->svr_cell_load_info.hw_load = RRM_ZERO;
										p_cell_ctx->svr_cell_load_info.hw_ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
										p_cell_ctx->svr_cell_load_info.mem_load = srv_ld_val;
										p_cell_ctx->svr_cell_load_info.mem_ld_lvl = map_x2ap_load_type(ld_type);
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_MEM_LOAD_PERIODIC_REPORT_PRESENT;

										if ((p_cell_ctx->svr_cell_load_info.bitmask & RRM_CPU_LOAD_PERIODIC_REPORT_PRESENT)
												&& (p_cell_ctx->svr_cell_load_info.cpu_load > srv_ld_val))
										{
											p_cell_ctx->svr_cell_load_info.hw_load = p_cell_ctx->svr_cell_load_info.cpu_load;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = p_cell_ctx->svr_cell_load_info.cpu_ld_lvl;
										}
										else
										{
											p_cell_ctx->svr_cell_load_info.hw_load = srv_ld_val;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = map_x2ap_load_type(ld_type);
										}
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_HW_LOAD_PERIODIC_REPORT_PRESENT;
										p_cell_ctx->cell_load_action.hw_load_support_flag = RRM_TRUE;
										break;
									}
									/* SPR 21020 Fix Stop */
								case CPU:
									{   
										/* SPR 21020 Fix Start */
										p_cell_ctx->svr_cell_load_info.hw_load = RRM_ZERO;
										p_cell_ctx->svr_cell_load_info.hw_ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
										p_cell_ctx->svr_cell_load_info.cpu_load = srv_ld_val;
										p_cell_ctx->svr_cell_load_info.cpu_ld_lvl = map_x2ap_load_type(ld_type);
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_CPU_LOAD_PERIODIC_REPORT_PRESENT;

										if((p_cell_ctx->svr_cell_load_info.bitmask & RRM_MEM_LOAD_PERIODIC_REPORT_PRESENT) && 
												(p_cell_ctx->svr_cell_load_info.mem_load > srv_ld_val))
										{
											p_cell_ctx->svr_cell_load_info.hw_load = p_cell_ctx->svr_cell_load_info.mem_load;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = p_cell_ctx->svr_cell_load_info.mem_ld_lvl;
										}
										else
										{
											p_cell_ctx->svr_cell_load_info.hw_load = srv_ld_val;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = map_x2ap_load_type(ld_type);
										}
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_HW_LOAD_PERIODIC_REPORT_PRESENT;
										/* SPR 20653 Fix Start */
										p_cell_ctx->cell_load_action.hw_load_support_flag = RRM_TRUE;
										/* SPR 20653 Fix End */
										/* SPR 21020 Fix Stop */
										break;
									}
								case TNL:
									{
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT;
										p_cell_ctx->svr_cell_load_info.s1_tnl_load = srv_ld_val;
										/* coverity : CID 29626*/
										p_cell_ctx->svr_cell_load_info.tnl_ld_lvl = map_x2ap_load_type(ld_type);
										/* SPR 20653 Fix Start */
										p_cell_ctx->cell_load_action.tnl_load_support_flag = RRM_TRUE;
										/* SPR 20653 Fix End */
										break;
									}
								default :
									{
										RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
												"Invalid Platform Source Type Received: %d", ld_src_type);
										break;
									}
							}
						}
					}
					break ;
				}
			case RRM_EVENT:
				{
					for( load_source_cnt = RRM_ZERO; ((load_source_cnt < platform_load_ind->count)&&
								(load_source_cnt < RRM_MAX_SOURCE)); load_source_cnt++)
					{
						ld_src_type = map_source_type(platform_load_ind->cell_load[load_source_cnt].load_src);
						if(RRM_CELL_LOAD_COMPOSITE_PRESENT & p_cell_ctx->cell_load_action.choice)
						{
							ld_type = platform_load_ind->cell_load[load_source_cnt].load_level;
							srv_ld_val = rrm_map_ld_lvl_to_ld_prcnt ((rrm_load_type)platform_load_ind->cell_load[load_source_cnt].load_level,\
									&(p_cell_ctx->cell_load_action.u.comp_load_info));
							if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
							{
								p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
										ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
															      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage : p_cell_ctx->svr_cell_load_info.rr_load.\
															      ul_total_prb_usage;
								if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
								{
									p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
								}

							}
							else
							{
								p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
							}
						}
						else if(RRM_CELL_LOAD_RESRC_SPEC_PRESENT & p_cell_ctx->cell_load_action.choice)
						{
							for (resrc_cnt = RRM_ZERO; resrc_cnt < p_cell_ctx->cell_load_action.u.resrc_spec_info.count; ++resrc_cnt)
							{
								if ((RRM_CELLM_HW_RESRC == p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type) &&
										(( MEMORY == ld_src_type) || (CPU == ld_src_type )))
								{
									ld_type = platform_load_ind->cell_load[load_source_cnt].load_level;
									srv_ld_val = rrm_map_ld_lvl_to_ld_prcnt ((rrm_load_type)platform_load_ind->cell_load[load_source_cnt].load_level,\
											&(p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn));
									if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
												ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
																	      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage :\
																	      p_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage;
										if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
										{
											p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
										}
									}
									else
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
									}
								}
								else if (RRM_CELLM_TNL_RESRC == p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type)
								{
									ld_type = platform_load_ind->cell_load[load_source_cnt].load_level;
									srv_ld_val = rrm_map_ld_lvl_to_ld_prcnt ((rrm_load_type)platform_load_ind->cell_load[load_source_cnt].load_level,\
											&(p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn));
									if (p_cell_ctx->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = (p_cell_ctx->svr_cell_load_info.rr_load.\
												ul_total_prb_usage < p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage) ?\
																	      p_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage :\
																	      p_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage;
										if (p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val < srv_ld_val)
										{
											p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
										}
									}
									else
									{
										p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_val = srv_ld_val;
									}
								}
							}
						}
						else
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
									"Default load config is not Available or MLB is not enabled");
						}
                        if (INVALID_SRC != ld_src_type)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
									"Platform Ind received from Src :%s[%d], Load Type:%s[%d]",
									CELL_LOAD_SRC[ld_src_type],
									ld_src_type,
									CELL_LOAD_TYPE_STATE[ld_type],
									ld_type);

							switch (ld_src_type)
							{
								case MEMORY:
									/* SPR 21020 Fix Start */
									{
										p_cell_ctx->svr_cell_load_info.hw_load = RRM_ZERO;
										p_cell_ctx->svr_cell_load_info.hw_ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
										p_cell_ctx->svr_cell_load_info.mem_load = srv_ld_val;
										p_cell_ctx->svr_cell_load_info.mem_ld_lvl = map_x2ap_load_type(ld_type);
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_MEM_LOAD_PERIODIC_REPORT_PRESENT;

										if ((p_cell_ctx->svr_cell_load_info.bitmask & RRM_CPU_LOAD_PERIODIC_REPORT_PRESENT)
												&& (p_cell_ctx->svr_cell_load_info.cpu_load > srv_ld_val))
										{
											p_cell_ctx->svr_cell_load_info.hw_load = p_cell_ctx->svr_cell_load_info.cpu_load;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = p_cell_ctx->svr_cell_load_info.cpu_ld_lvl;
										}
										else
										{
											p_cell_ctx->svr_cell_load_info.hw_load = srv_ld_val;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = map_x2ap_load_type(ld_type);
										}
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_HW_LOAD_PERIODIC_REPORT_PRESENT;
										p_cell_ctx->cell_load_action.hw_load_support_flag = RRM_TRUE;
										break;
									}
									/* SPR 21020 Fix Stop */
								case CPU:
									{   
										/* SPR 21020 Fix Start */
										p_cell_ctx->svr_cell_load_info.hw_load = RRM_ZERO;
										p_cell_ctx->svr_cell_load_info.hw_ld_lvl = RRM_X2AP_RSU_LOAD_LOW;
										p_cell_ctx->svr_cell_load_info.cpu_load = srv_ld_val;
										p_cell_ctx->svr_cell_load_info.cpu_ld_lvl = map_x2ap_load_type(ld_type);
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_CPU_LOAD_PERIODIC_REPORT_PRESENT;

										if((p_cell_ctx->svr_cell_load_info.bitmask & RRM_MEM_LOAD_PERIODIC_REPORT_PRESENT) && 
												(p_cell_ctx->svr_cell_load_info.mem_load > srv_ld_val))
										{
											p_cell_ctx->svr_cell_load_info.hw_load = p_cell_ctx->svr_cell_load_info.mem_load;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = p_cell_ctx->svr_cell_load_info.mem_ld_lvl;
										}
										else
										{
											p_cell_ctx->svr_cell_load_info.hw_load = srv_ld_val;
											p_cell_ctx->svr_cell_load_info.hw_ld_lvl = map_x2ap_load_type(ld_type);
										}
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_HW_LOAD_PERIODIC_REPORT_PRESENT;
										/* SPR 21020 Fix Stop */
										/* SPR 20653 Fix Start */
										p_cell_ctx->cell_load_action.hw_load_support_flag = RRM_TRUE;
										/* SPR 20653 Fix End */
										break;
									}
								case TNL:
									{
										p_cell_ctx->svr_cell_load_info.bitmask |= RRM_HW_LOAD_PERIODIC_REPORT_PRESENT;
										p_cell_ctx->svr_cell_load_info.s1_tnl_load = srv_ld_val;
										/* Coverity: CID 29626,29458,29459 */
										p_cell_ctx->svr_cell_load_info.tnl_ld_lvl = map_x2ap_load_type(ld_type);/* Coverity_ID : 29459 */
										/* SPR 20653 Fix Start */
										p_cell_ctx->cell_load_action.tnl_load_support_flag = RRM_TRUE;
										/* SPR 20653 Fix End */
										break;
									}
								default :
									{
										RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
												"Invalid Platform Source Type Received: %d", ld_src_type);
										break;
									}
							}
						}
					}
					break;
				}
			default :
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
							"Invalid Platform Ind Type Received: %d", platform_load_ind->ind_type);
					break;
				}   
		}
		rrm_fill_dl_comp_avl_cap_val (p_cell_ctx);

		rrm_fill_ul_comp_avl_cap_val (p_cell_ctx);
		/*ret_val = rrm_process_load_action (p_cell_ctx); */
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_l2_kpi_stats_cnf
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et 
rrm_cellm_l2_kpi_stats_cnf(
		void *p_api,
		U16 api_id,
        /*SPR 17777 +-*/
    U8  cell_index)
{
	MacConfigureKpiStatsResp *l2_kpi_cnf = RRM_PNULL;
	rrm_return_et ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	if ( api_id == RRM_MAC_CONFIGURE_KPI_STATS_CNF)
	{
		l2_kpi_cnf = (MacConfigureKpiStatsResp *)p_api;
		if(RRM_PNULL != l2_kpi_cnf)
		{
			if (RRM_SUCCESS == l2_kpi_cnf->responseCode)
			{
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err = RRM_FALSE;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
						"MAC->RRM:RRM_MAC_CONFIGURE_KPI_STATS_CNF:[CELL:%d] with Response :%d Cnf Flag:%d",
                        cell_index,
						l2_kpi_cnf->responseCode,
						p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err);
				ret_val = RRM_SUCCESS;
			}        
			else
			{
				p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err = RRM_TRUE;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						"MAC->RRM:RRM_MAC_CONFIGURE_KPI_STATS_CNF:[CELL:%d] with Response :%d Cnf Flag:%d",
						cell_index,
                        l2_kpi_cnf->responseCode,
						p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err);

				/*Again send the KPI stat request to L2*/ 
                /* SPR 22420 Fix Start */
                ret_val = rrm_request_kpi_from_l2(
                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.radio_cong_threshold.sampling_normal_time,
                        RRM_TRUE,
                        cell_index);
                /* SPR 22420 Fix End */
                /* Coverity Fix 76829 Start */
                /* Code Deleted */
                /* Coverity Fix 76829 End */
			}
		}
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
				"Wrong API id [%d] received from MAC", api_id);

	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* DYNAMIC ICIC CHANGES START   */

/****************************************************************************
 * Function Name  : rrm_cellm_l2_scheduler_reconf_cnf 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et rrm_cellm_l2_scheduler_reconf_cnf
(
    void *p_api
        /*SPR 17777 +-*/
)
{
    rrm_return_et   ret_val = RRM_SUCCESS;
    RrmMacReconfigSchedulerCnf *p_mac_reconfig_cnf = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_mac_reconfig_cnf = (RrmMacReconfigSchedulerCnf *)p_api;
    if(RRM_SUCCESS == p_mac_reconfig_cnf->responseCode)
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_INFO,
            "MAC->RRM:RRM_MAC_SCHEDULER_RECONFIG_CNF with response: %d",
                p_mac_reconfig_cnf->responseCode);
        ret_val = RRM_SUCCESS;
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_ERROR,
            "MAC->RRM:RRM_MAC_SCHEDULER_RECONFIG_CNF with Response: %d",
                p_mac_reconfig_cnf->responseCode);
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }

	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_cellm_l1_meas_report_ind 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et rrm_cellm_l1_meas_report_ind
(
    void *p_api,
        /*SPR 17777 +-*/
    U8  cell_index
)
{
    rrm_return_et             ret_val = RRM_SUCCESS;
    MacRrmLayer1MeasReportInd  *p_l1_meas_report_t = RRM_PNULL;
    rrm_cell_context_t        *p_rrm_cell_ctx = RRM_PNULL;
    U8                        prb_count = RRM_ZERO;
    U8                        prb_counter = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_l1_meas_report_t = (MacRrmLayer1MeasReportInd *) p_api;
    RRM_ASSERT(RRM_PNULL != p_l1_meas_report_t);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MAC->RRM:RRM_MAC_L1_REPORT_IND");
    if(RRM_MAX_NUM_CELLS <= cell_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell index[%d] is invalid", cell_index);
        return RRM_FAILURE;
    }
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if(RRM_PNULL != p_rrm_cell_ctx) /* Coverity: CID 41384 */
    {
    switch(p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
    {
        case RRM_OAM_BW_N_6:
            prb_count = PRB_COUNT_6;
            break;
        case RRM_OAM_BW_N_15:
            prb_count = PRB_COUNT_15;
            break;
        case RRM_OAM_BW_N_25:
            prb_count = PRB_COUNT_25;
            break;
        case RRM_OAM_BW_N_50:
            prb_count = PRB_COUNT_50;
            break;
        case RRM_OAM_BW_N_75:
            prb_count = PRB_COUNT_75;
            break;
        case RRM_OAM_BW_N_100:
            prb_count = PRB_COUNT_100;
            break;
        default :
            prb_count = PRB_COUNT_50;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                    "Incorrect value received for dl_bandwith = %u",
                    p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth);
    }

    /*
       Can't be set to zero.. should be initialise to zero once and that too
       during cell ctxt initialisation and when sending cell_config_req to L2
       p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask = 0x00;
     */

    if(p_l1_meas_report_t->bitmask & INTERFERENCE_PER_PRB_BITMASK)
    {
        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
            RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT;
        p_rrm_cell_ctx->icic_l1_l2_report_info.ul_intf_overload_ind.prb_count = prb_count;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "OI Reports: Interference Per PRB present for PRB[%d]", prb_count);

        for (prb_counter = RRM_ZERO; (prb_counter < prb_count) && (prb_counter < MAX_INTERFERENCE_PER_PRB); prb_counter++)
        {
            if (RRM_ZERO == p_l1_meas_report_t->interferencePerPRB[prb_counter])
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.ul_intf_overload_ind.
                    ul_intf_overload_indication[prb_counter] = RRM_OI_LOW_INTERFERENCE;
            }
            else
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.ul_intf_overload_ind.
                    ul_intf_overload_indication[prb_counter] = RRM_OI_HIGH_INTERFERENCE;
            }
        }
    }
    if(p_l1_meas_report_t->bitmask & THERMAL_NOISE_BITMASK)
    {
        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
            RRM_CTXT_THERMAL_NOISE_PRESENT;
        p_rrm_cell_ctx->icic_l1_l2_report_info.thermal_noise = p_l1_meas_report_t->thermalNoise;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Thermal Noise Received = [%d]", p_l1_meas_report_t->thermalNoise);
    }
    if(p_l1_meas_report_t->bitmask & RS_TX_POWER_BITMASK)
    {
        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
            RRM_CTXT_DL_RS_TX_POWER_PRESENT;
        p_rrm_cell_ctx->icic_l1_l2_report_info.dl_rs_tx_power = p_l1_meas_report_t->dlRsTxPower;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "DL Reference Signal Transmit Power Received = [%d]", 
                p_l1_meas_report_t->dlRsTxPower);
    }
    if(RRM_ZERO == p_l1_meas_report_t->bitmask)
    {
        ret_val = RRM_FAILURE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "No reporting parameter received in API from L2");
    }    
    else
    {
        /* SPR 21843 Fix Start */
        if((p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT) &&
                (p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_HIGH_INTF_IND_PRESENT) &&
                (p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT))
        {
            p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |= RRM_CTXT_LOAD_REPORT_IND_PRESENT;
        }
        /* SPR 21843 Fix End */
        if ((p_rrm_cell_ctx->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) && 
                (p_rrm_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT) &&
                (ICIC_SCHEME_SFR == p_rrm_cell_ctx->operator_info.dynamic_icic_info.icic_scheme_type) &&
                (p_rrm_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT))
        {
            p_rrm_cell_ctx->p_incoming_api_info = (void *)p_l1_meas_report_t;
            if (RRM_FAILURE == cellm_fsm_process_event (
                        RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT,
                        p_rrm_cell_ctx))
            {
                ret_val = RRM_FAILURE;
            }
            else
            {
                ret_val = RRM_SUCCESS;
            }
            /* SPR 21843 Fix Start */
            if(p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_HIGH_INTF_IND_PRESENT)
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_HIGH_INTF_IND_PRESENT;
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT;
            }
            if(p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT)
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT;
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT;
            }
            /* SPR 21843 Fix End */
        }
    }
    }
    else
    {
        RRM_ASSERT(RRM_PNULL != p_rrm_cell_ctx);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_l2_icic_meas_report 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et rrm_cellm_l2_icic_meas_report 
(
    void *p_api,
        /*SPR 17777 +-*/
    U8  cell_index
)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    MacRrmLayer2IcicMeasReportInd    *rrm_mac_l2_icic_meas_report = RRM_PNULL;
    rrm_cell_context_t               *p_rrm_cell_ctx = RRM_PNULL;
    U8                               prb_count = RRM_ZERO;
    U8                               prb_counter = RRM_ZERO;
    U32                              mac_periodic_report_periodicity = RRM_ZERO; 
    RRM_UT_TRACE_ENTER();

    rrm_mac_l2_icic_meas_report = (MacRrmLayer2IcicMeasReportInd *)p_api;
    RRM_ASSERT(RRM_PNULL != rrm_mac_l2_icic_meas_report);

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO, 
			"MAC->RRM:RRM_MAC_ICIC_REPORT_IND:[CELL:%d]",cell_index);
    if(RRM_MAX_NUM_CELLS <= cell_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell index[%d] is invalid", cell_index);
        return RRM_FAILURE;
    }

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    
    if(RRM_PNULL != p_rrm_cell_ctx) /* Coverity: CID 41385 */
    {
        /* SPR_19619 start */
        if (CELL_STATE_ACTIVE == p_rrm_cell_ctx->cell_state)
        {
            /* SPR_19619 stop */
            mac_periodic_report_periodicity = p_rrm_cell_ctx->operator_info.rrm_mac_config.periodic_report_periodicity;
            switch(p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
            {
                case RRM_OAM_BW_N_6:
                prb_count = PRB_COUNT_6;
                break;
                case RRM_OAM_BW_N_15:
                prb_count = PRB_COUNT_15;
                break;
                case RRM_OAM_BW_N_25:
                prb_count = PRB_COUNT_25;
                break;
                case RRM_OAM_BW_N_50:
                prb_count = PRB_COUNT_50;
                break;
                case RRM_OAM_BW_N_75:
                prb_count = PRB_COUNT_75;
                break;
                case RRM_OAM_BW_N_100:
                prb_count = PRB_COUNT_100;
                break;
                default :
                prb_count = PRB_COUNT_50;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
                        "Incorrect value received for dl_bandwith = %u",
                        p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth);
            }

            if(rrm_mac_l2_icic_meas_report->bitmask & RNTP_VAL_BITMASK)
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
                    RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT;
                p_rrm_cell_ctx->icic_l1_l2_report_info.relative_narrowband_tx_power.prb_count = prb_count;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "RNTP Map present for PRB[%d]", prb_count);

                for (prb_counter = RRM_ZERO; (prb_counter < prb_count) && (prb_counter < MAX_INTERFERENCE_PER_PRB) ; prb_counter++)
                {
                    p_rrm_cell_ctx->icic_l1_l2_report_info.relative_narrowband_tx_power.
                        rntp_per_prb[prb_counter] =
                        rrm_mac_l2_icic_meas_report->rntpValuePerPRB[prb_counter];
                }
            }
            if(rrm_mac_l2_icic_meas_report->bitmask & DL_CE_PRB_USAGE_BITMASK)
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
                    RRM_CTXT_DL_CE_PRB_USAGE_PRESENT;
                /* This is the accumulated PRB usage reported from L2 which needs to fetched on the basis of
                   per TTI basis. So, the averaging usage per TTI is done on the basis with the timer
                   value configured during the configuration of MAC layer
                   */
                p_rrm_cell_ctx->icic_l1_l2_report_info.dl_ce_prb_usage = 
                    rrm_mac_l2_icic_meas_report->dlCEPrbUsage / mac_periodic_report_periodicity;
                /* SPR 20867 Fix Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "  DL CE PRB Usage Received = [%d]", p_rrm_cell_ctx->icic_l1_l2_report_info.dl_ce_prb_usage);
                /* SPR 20867 Fix End */
            }
            if(rrm_mac_l2_icic_meas_report->bitmask & UL_CE_PRB_USAGE_BITMASK)
            {
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
                    RRM_CTXT_UL_CE_PRB_USAGE_PRESENT;
                /* This is the accumulated PRB usage reported from L2 which needs to fetched on the basis of
                   per TTI basis. So, the averaging usage per TTI is done on the basis with the timer
                   value configured during the configuration of MAC layer
                   */
                p_rrm_cell_ctx->icic_l1_l2_report_info.ul_ce_prb_usage = 
                    rrm_mac_l2_icic_meas_report->ulCEPrbUsage / mac_periodic_report_periodicity;

                /* SPR 20867 Fix Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "UL CE PRB Usage Received = [%d]", p_rrm_cell_ctx->icic_l1_l2_report_info.ul_ce_prb_usage);
                /* SPR 20867 Fix End */
                /* 
                   To predict the HII based on UL CE PRB Map,
                   HII bitmask is set in Cell Context
                   */
                p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |=
                    RRM_CTXT_HIGH_INTF_IND_PRESENT;
                /* Store the UL CE PRB Usage in array for estimation of HII map in
                 * future
                 */

                p_rrm_cell_ctx->icic_l1_l2_report_info.ul_ce_prb_usage_array[
                    p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples] =
                    /* SPR_19619 start */
                    //rrm_mac_l2_icic_meas_report->ulCEPrbUsage;
                    p_rrm_cell_ctx->icic_l1_l2_report_info.ul_ce_prb_usage;
                /* SPR_19619 stop */
                /* Increase the count for the number of samples stored */
                p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples++;
                /* SPR 20867 Fix Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "Num of samples is :%d", p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples);
                if(RRM_TWO == p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples)
                {
                    p_rrm_cell_ctx->icic_l1_l2_report_info.is_sample_valid_for_partioning = RRM_TRUE; 
                }
                /* SPR 20867 Fix End */
                if (MAX_NUM_OF_CE_PRB_SAMPLES ==
                        p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples)
                {
                    p_rrm_cell_ctx->icic_l1_l2_report_info.num_ce_samples = RRM_ZERO;
                }
            }
            if(RRM_ZERO == rrm_mac_l2_icic_meas_report->bitmask)
            {
                ret_val = RRM_FAILURE;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "No reporting parameter received in API from L2");
            }    
            else
            {
#ifdef UL_MU_MIMO_BUILD_ENABLED
                /* uplink mu mimo chnage start*/
                rrm_prb_usage_reached_threshold_ind(cell_index);
                /* uplink mu mimo chnage end*/
#endif
                /* SPR 21843 Fix Start */
                if((p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT) &&
                        (p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_HIGH_INTF_IND_PRESENT) &&
                        (p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT))
                {
                    p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask |= RRM_CTXT_LOAD_REPORT_IND_PRESENT;
                }
                /* SPR 21843 Fix End */
                if ((p_rrm_cell_ctx->operator_info.bitmask & RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT) && 
                        (p_rrm_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT) &&
                        (ICIC_SCHEME_SFR == p_rrm_cell_ctx->operator_info.dynamic_icic_info.icic_scheme_type) &&
                        (p_rrm_cell_ctx->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT))
                {
                    p_rrm_cell_ctx->p_incoming_api_info = (void *)rrm_mac_l2_icic_meas_report;
                    if (RRM_FAILURE == cellm_fsm_process_event (
                                RRM_PERIODIC_ICIC_L1_L2_REPORT_INFO_EVENT,
                                p_rrm_cell_ctx))
                    {
                        ret_val = RRM_FAILURE;
                    }
                    else
                    {
                        ret_val = RRM_SUCCESS;
                    }
                    /* SPR 21843 Fix Start */
                    if(p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask & RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT)
                    {
                        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_UL_INTF_OVERLOAD_IND_PRESENT;
                        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_HIGH_INTF_IND_PRESENT;
                        p_rrm_cell_ctx->icic_l1_l2_report_info.bitmask ^= RRM_CTXT_RELATIVE_NARROWBAND_TX_POWER_PRESENT;
                    }
                    /* SPR 21843 Fix End */
                }
            }
            /* SPR_19619 start */
        }
        else
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,  RRM_ERROR,
                    "Cell state is not active so dropping the message. Current State is[%d]",
                    p_rrm_cell_ctx->cell_state);
            /* SPR 21251 End */
        }
        /* SPR_19619 stop  */
    }
    else
    {
        RRM_ASSERT(RRM_PNULL != p_rrm_cell_ctx);
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_get_mxn_anetnna_support 
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 ****************************************************************************/
rrm_return_et
rrm_get_mxn_anetnna_support( rrm_cell_index_t      cell_index,
                             rrm_antenna_mxn_et    *p_mxn_support)
{
    rrm_return_et           ret_val = RRM_SUCCESS;
    rrm_cell_context_t      *p_cell_ctxt = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( (RRM_NULL != p_cell_ctxt) && (RRM_NULL != p_mxn_support) )
    {
        *p_mxn_support = p_cell_ctxt->mxn_antenna_support;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "UE Context NULL for cell_index: %d", cell_index);
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/** Dynamic UE Scheduling Start **/
/****************************************************************************
 * Function Name  : rrm_get_l2_ue_prefs_stats_bitmap
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U32 : stats_bitmap
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
U32 rrm_get_l2_cell_prefs_stats_bitmap( U8 cell_index )
{
    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;
    U32                                      l2_cell_perfs_stats_bitmap = 0x00 ;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( RRM_NULL != p_cell_ctxt )
    {
       l2_cell_perfs_stats_bitmap = p_cell_ctxt->mac_perfs_stats_bitmap.cellPerfStatsToReportBitMap; 
    }

    RRM_UT_TRACE_EXIT();

    return l2_cell_perfs_stats_bitmap;
}

/****************************************************************************
 * Function Name  : rrm_get_l2_ue_prefs_stats_bitmap
 * Inputs         : cell_index 
 * Outputs        : None
 * Returns        : U32 : stats_bitmap
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
U32 rrm_get_l2_ue_prefs_stats_bitmap( U8 cell_index )
{

    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;
    U32                                      l2_ue_perfs_stats_bitmap = 0x00 ;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( RRM_NULL != p_cell_ctxt )
    {
       l2_ue_perfs_stats_bitmap = p_cell_ctxt->mac_perfs_stats_bitmap.uePerfStatsToReportBitMap; 
    }

    RRM_UT_TRACE_EXIT();
    return l2_ue_perfs_stats_bitmap;
}

/****************************************************************************
 * Function Name  : rrm_set_cell_prefs_stats_bitmap
 * Inputs         : cell_index
 *                : U32 cell_prefs_stats_bitmap 
 * Outputs        : None
 * Returns        : rrm_void_t
 * Description    : setter methid for bitmap of l2 cell prefs 
 ****************************************************************************/
rrm_void_t rrm_set_cell_prefs_stats_bitmap( U8 cell_index , U32 cell_prefs_stats_bitmap )
{
    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( RRM_NULL != p_cell_ctxt )
    {
       p_cell_ctxt->mac_perfs_stats_bitmap.cellPerfStatsToReportBitMap = cell_prefs_stats_bitmap;
       
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_set_ue_prefs_stats_bitmap
 * Inputs         : cell_index 
 *                : U32 ue_prefs_stats_bitmap 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_void_t rrm_set_ue_prefs_stats_bitmap( U8 cell_index, U32 ue_prefs_stats_bitmap )
{
    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( RRM_NULL != p_cell_ctxt )
    {
       p_cell_ctxt->mac_perfs_stats_bitmap.uePerfStatsToReportBitMap = ue_prefs_stats_bitmap;
       
    }
    
    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : rrm_get_configurable_active_ue_report_timer
 * Inputs         : cell_index 
 * Outputs        : None
 * Returns        : U8 : timer info 
 * Description    : getter function for active ue report timer 
*****************************************************************************/
U8 rrm_get_configurable_active_ue_report_timer( U8 cell_index )
{

    rrm_cell_context_t             *p_cell_ctxt = RRM_PNULL;
    U8                             active_ue_report_timer = RRM_ZERO; 
    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( RRM_NULL != p_cell_ctxt )
    {
        active_ue_report_timer = p_cell_ctxt->active_ue_reports_timer;
       
    }
    
    RRM_UT_TRACE_EXIT();

    return active_ue_report_timer;
}
/****************************************************************************
 * Function Name  : rrm_send_active_ue_report_enable_prefs
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : rrm_void_t 
 * Description    : This function sends mac config prefs stats req
                  : for enabling active ue reporting 
 ****************************************************************************/
rrm_void_t
rrm_send_active_ue_report_enable_prefs( U8  cell_index )
{

    rrm_cell_context_t                      *p_cell_ctxt = RRM_PNULL;
    rrm_mac_config_perf_stats_req_t         l2_prefs_stats_req = { RRM_ZERO };
    U32                                     cell_prefs_bitmap = 0x00;       
  
    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
 
        /* logic for enabling and disabling the bitmask :
           we have getter and setter function for getting and setting the bitmap 
           for cell and ue perfs, which we stoare in cell context for each cell.
           our problem was when sending l2_perfs req then api must take care of
           last bitmap configured at mac in curren request. if it is not taken 
           care then mac understand to disable the report dispachment corresponding
           to that bitmask only. so approach to include the last bitmap also in api
           req.

           Now how to use :
           setter function ask user to provide the resultant bitmap to save in cell
           context after full making correct bitmap.
       
           Bitmap : enable the bit : get the bitmap using getter function.use the byte
           pointer to access the specific byte, as below we have used. perform the OR
           operation of that bit that user want to enable. pass that value back to setter
           function of that bitmap.

           Bitmap :  disable the bit : do same as enable except performing OR operation 
           perform the AND operation.*/  

    if( RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT & 
                          p_cell_ctxt->operator_info.bitmask )
    {
        l2_prefs_stats_req.duration = rrm_get_configurable_active_ue_report_timer(cell_index);
        l2_prefs_stats_req.periodicReporting = RRM_ONE;

        cell_prefs_bitmap = rrm_get_l2_cell_prefs_stats_bitmap( cell_index);

        /* as active ue reports become enable on 6 th least significant bit*/
        cell_prefs_bitmap |= 0x20;

        /* setting the cell prefs bitmap */
        rrm_set_cell_prefs_stats_bitmap( cell_index , cell_prefs_bitmap );

        /*assigning the getter ue and cell prefs bitmap*/ 
        l2_prefs_stats_req.uePerfStatsToReportBitMap = rrm_get_l2_ue_prefs_stats_bitmap( cell_index );
        l2_prefs_stats_req.cellPerfStatsToReportBitMap = rrm_get_l2_cell_prefs_stats_bitmap( cell_index );

        /**       l2 perf stats req       **/
        
        l2_perf_stats_req ( &l2_prefs_stats_req,
                            RRM_MODULE_ID,
                            RRM_ONE,
                            p_cell_ctxt->cell_index );

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
        "Active ue report enabling bitmap is sent to mac");
    }
    /* SPR 21251 +- */

    RRM_UT_TRACE_EXIT();
}
/** Dynamic UE Scheduling End **/

/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_cellm_mac_perf_stats_ind
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from MAC
 ****************************************************************************/
rrm_return_et
rrm_cellm_mac_perf_stats_ind(
        void *p_api,
        /*SPR 17777 +-*/
        U8  cell_index
        )
{
    rrm_return_et                             ret_val = RRM_SUCCESS;
    rrm_mac_cell_perf_stats_ind_params_t      *p_mac_cell_perf_stats_ind = RRM_PNULL;
    rrm_cell_context_t                        *p_cell_ctxt = RRM_PNULL;
    U8                                        index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    p_mac_cell_perf_stats_ind = (rrm_mac_cell_perf_stats_ind_params_t *)p_api;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
	        "MAC->RRM:RRM_MAC_CELL_PERF_STATS_IND:[CELL:%d]", cell_index);
    if(RRM_ZERO != p_cell_ctxt->cell_rach_info.rach_l2_periodic_timer) 
    {
        (p_cell_ctxt->cell_rach_info.cell_rach_data.num_of_l2_perf_accumulated_reports)++;

        p_cell_ctxt->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cbra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalRcvdMsg3RandomAccessPreamblesCBRA;
        p_cell_ctxt->cell_rach_info.cell_rach_data.total_rcvd_msg3_random_access_preambles_cfra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp. 
            rach_succ_fail_perf_stats.totalRcvdMsg3RandomAccessPreamblesCFRA;
        p_cell_ctxt->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cbra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalFailedRandomAccessPreamblesMsg2CBRA;
        p_cell_ctxt->cell_rach_info.cell_rach_data.total_failed_random_access_preambles_msg2_cfra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalFailedRandomAccessPreamblesMsg2CFRA;
        p_cell_ctxt->cell_rach_info.cell_rach_data.total_allocated_random_access_preambles += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalAllocatedRandomAccessPreambles;

        for(index = RRM_ZERO; index < MAX_TA_RANGE; index++)
        {
            p_cell_ctxt->cell_rach_info.cell_rach_data.total_succ_random_access_ta[index] += 
                (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
                rach_succ_fail_perf_stats.totalSuccRandomAccessTA[index];

        }

        p_cell_ctxt->cell_rach_info.cell_rach_data.total_unassigned_false_cfra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalUnassignedFalseCFRA;
        p_cell_ctxt->cell_rach_info.cell_rach_data.total_unassigned_sum_cfra += 
            (U64)p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.
            rach_succ_fail_perf_stats.totalUnassignedSumCFRA;
     
        ret_val = rrm_cell_build_and_send_rach_info_to_mif(p_cell_ctxt);

    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_BRIEF,
                "L2 rach timer value is ZERO, so not sending RACH info to SON");
    }

    /** Dynamic UE Scheduling Start **/ 
    p_cell_ctxt->ue_scheduling_perfs.active_ue_ul_dl_stats =
                p_mac_cell_perf_stats_ind->cell_mac_perf_stats_resp.cell_total_active_ue_dl_ul_stats; 
     /** Dynamic UE Scheduling End **/

     /** Dynamic UE Scheduling Start **/
    if( RRM_TRUE == p_cell_ctxt->ue_scheduling_perfs.ue_scheduling )
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_BRIEF,
        "UE scheduling Feature flag is True");
           
        /* function calculate the ue to be scheduled in uplink and downlink and
          send the scheduler reconfig message */
        rrm_schedule_downlink_uplink_ue( p_cell_ctxt );
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_BRIEF,
       "UE scheduling flag is False");
    }
        /** Dynamic UE Scheduling End **/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_mac_config_perf_stats_cnf
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 *                : cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from MAC
 ****************************************************************************/
rrm_return_et
rrm_cellm_mac_config_perf_stats_cnf(
        void *p_api,
        /*SPR 17777 +-*/
        U8  cell_index
        )
{
    rrm_return_et                        ret_val = RRM_SUCCESS;
    rrm_mac_config_perf_stats_cnf_t      *p_mac_config_perf_cnf = RRM_PNULL;
    rrm_cell_context_t                   *p_cell_ctxt = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);

    p_mac_config_perf_cnf = (rrm_mac_config_perf_stats_cnf_t *)p_api;
    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if(RRM_SUCCESS == p_mac_config_perf_cnf->response_code)
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_INFO,
                "MAC->RRC:MAC_CONFIGURE_PERF_STATS_CNF with response: %d",p_mac_config_perf_cnf->response_code);
        if( RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT &
                                             p_cell_ctxt->operator_info.bitmask )
        {
            p_cell_ctxt->ue_scheduling_perfs.ue_scheduling = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_BRIEF,
                "Successfully setting ON the Dynamic ue scheduling feature");
        }
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_BRIEF,
                "Success Response L2 Mac perf stats cnf %d ",
                p_mac_config_perf_cnf->response_code);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_ERROR,
                "MAC->RRC:MAC_CONFIGURE_PERF_STATS_CNF with response: %d",p_mac_config_perf_cnf->response_code);
        p_cell_ctxt->ue_scheduling_perfs.ue_scheduling = RRM_FALSE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* RACH_OPTIMIZATION_CHANGES_END */

rrm_return_et
rrm_cellm_l2_config_cnf(
void *p_api,
 U16 api_id,
        /*SPR 17777 +-*/
 U8  cell_index
 )
{
    /*  DYNAMIC ICIC CHANGES START  */
    rrm_return_et              ret_val = RRM_SUCCESS;
    RrmMacCellConfigCnf      *p_mac_cnf = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_mac_cnf = (RrmMacCellConfigCnf *)p_api;
    if(RRM_SUCCESS == p_mac_cnf->responseCode)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err = RRM_FALSE;
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_INFO,
                "MAC->RRM:RRM_MAC_CELL_CONFIG_CNF:[CELL:%d] with response %d ",
                cell_index,
                p_mac_cnf->responseCode);
    }
    else
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rcc_param.kpi_cnf_err = RRM_TRUE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "MAC->RRM:RRM_MAC_CELL_CONFIG_CNF:[CELL:%d] with response %d",
                cell_index,
                p_mac_cnf->responseCode);
    }
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =   (void *)p_mac_cnf;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =   RRM_MAC_CELL_CONFIG_CNF;  
    if (RRM_FAILURE == cellm_fsm_process_event (
                RRM_UEM_OR_L2_RESPONSE_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        ret_val = RRM_FAILURE;
    }
    else
    {
        /** Dynamic UE Scheduling Start **/
        rrm_send_active_ue_report_enable_prefs( cell_index );
        /** Dynamic UE Scheduling End **/
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
    /*  DYNAMIC ICIC CHANGES END  */    
}
/*Klockwork_fix_start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_update_prb_process_msg_dl_gbr
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
    rrm_void_t
rrm_cellm_update_prb_process_msg_dl_gbr(rrm_cell_context_t*  p_rrm_cell_ctx)
{

    if (RRM_ZERO !=  p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use)
    {
        if (RRM_ZERO !=  p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_gbr_prb)
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_gbr_prb =
                (p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_gbr_prb +
                 p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use)/RRM_TWO;
        }
        else
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_gbr_prb =
                p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Avg DL GBR:%u",
                p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_gbr_prb);
    }

}
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_update_prb_process_msg_ul_gbr
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
 rrm_void_t
rrm_cellm_update_prb_process_msg_ul_gbr(rrm_cell_context_t* p_rrm_cell_ctx)
{
    /*SPR 21153 Fixed Start */
    /* Code Remove */
    /*SPR 21153 Fixed End */
    
        if (RRM_ZERO != p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_gbr_prb)
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_gbr_prb =
                (p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_gbr_prb +
                 p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use)/RRM_TWO;
        }
        else
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_gbr_prb =
                p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Avg UL GBR:%u",
                 p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_gbr_prb);
        /*SPR 21153 Fixed Start */
        /* Code Remove */
        /*SPR 21153 Fixed end */
    
}
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_update_prb_process_msg_dl_ngbr
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
rrm_void_t
rrm_cellm_update_prb_process_msg_dl_ngbr(rrm_cell_context_t*  p_rrm_cell_ctx)
{
    /*SPR 21153 Fixed Start */
    /* Code Remove */
    /*SPR 21153 Fixed End */
        if (RRM_ZERO != p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_ngbr_prb)
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_ngbr_prb =
                (p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_ngbr_prb +
                 p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use)/RRM_TWO;
        }
        else
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_ngbr_prb =
                p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Avg DL NGBR:%u",
                  p_rrm_cell_ctx->kpi_stat.kpi.avg_dl_allocated_ngbr_prb);
   
   /*SPR 21153 Fixed Start */
   /* Code Remove */
   /*SPR 21153 Fixed end */
}
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_update_prb_process_msg_ul_ngbr
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
rrm_void_t
rrm_cellm_update_prb_process_msg_ul_ngbr(rrm_cell_context_t*  p_rrm_cell_ctx)
{

    if (RRM_ZERO != p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use)
    {
        if (RRM_ZERO != p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_ngbr_prb)
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_ngbr_prb =
                (p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_ngbr_prb + 
                 p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use)/RRM_TWO;
        }
        else
        {
            p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_ngbr_prb =
                p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Avg UL NGBR:%u",
                  p_rrm_cell_ctx->kpi_stat.kpi.avg_ul_allocated_ngbr_prb);
    }
}
/*Klockwork_fix_end*/
        

/* DYNAMIC ICIC CHANGES END     */
/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_update_prb_process_msg 
 *   DESCRIPTION:
 *        send request to rrmim to disable the RAC
 *   RETURNS:
 *       RRM_SUCCESS/RRM_FAILURE
 ******************************************************************************/
rrm_return_et
rrm_cellm_update_prb_process_msg
(
 U8 *p_api, /*pointer to input API buffer*/
        /*SPR 17777 +-*/
   U8  cell_index
 )

{
	U8 index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	U8 prb_per_qci_dl = RRM_ZERO;
	U8 prb_per_qci_ul = RRM_ZERO;
    MacKpiStatsIndParams *l2_mac_param = RRM_PNULL; /*packet delay*/
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;

    /*SPR 19164 Changes start*/
    /*Code Removed*/
    /*SPR 19164 Changes End*/


    RRM_UT_TRACE_ENTER();
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
              "MAC->RRM:RRM_MAC_KPI_STATS_IND:[CELL:%d]", cell_index);
    if(RRM_MAX_NUM_CELLS <= cell_index)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "Cell index[%d] is invalid", cell_index);
	return RRM_FAILURE;
    }
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    /* Coverity 19oct Start : 54987 */
	if((RRM_PNULL == p_rrm_cell_ctx) || 
			(RRM_TRUE == p_rrm_cell_ctx->rcc_param.kpi_cnf_err))
	{
		/*No need to update the store the MAC param if kpi_cnf is TRUE*/
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Eithre cell context is null or kpi_cnf is true");
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
    /* Coverity 19oct End : 54987 */

    /*SPR 21640 Fix Start*/
    /*SPR 21112 Fix Start*/
    /* Code Remove */
    /*SPR 21112 Fix Stop*/
    /*SPR 21640 Fix Stop*/

	/*reset allocated prbs start*/
	rrm_cellm_set_dl_allocated_gbr_prb(cell_index,RRM_ZERO);
	rrm_cellm_set_ul_allocated_gbr_prb(cell_index,RRM_ZERO);
	rrm_cellm_set_dl_allocated_ngbr_prb(cell_index,RRM_ZERO);
	rrm_cellm_set_ul_allocated_ngbr_prb(cell_index,RRM_ZERO);
	p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use = RRM_ZERO;
	p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use = RRM_ZERO;
	p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use = RRM_ZERO;
	p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use = RRM_ZERO;

	/*reset allocated prbs start*/
	l2_mac_param = (MacKpiStatsIndParams *)p_api;
    /* SPR 13492 changes start */
    p_rrm_cell_ctx->rcc_param.totalSessionTimeUE = l2_mac_param->totalSessionTimeUE;
    /* SPR 13492 changes end */

    /* Coverity 19oct Delete : 54987 */
    /* SPR 12036 */
	/*currently MAC is not sending any cell index*/
	for(index = RRM_ZERO;index < RRM_MAX_QCI ;index++)
	{   
		/*Copy the param recevied from MAC in cell context*/
		p_rrm_cell_ctx->rcc_param.total_pkt_delay_per_qci_dl[index] =
			l2_mac_param->totalPktDelayPerQciDL[index];
		p_rrm_cell_ctx->rcc_param.total_pkt_acked_dl_per_qci[index] =
			l2_mac_param->totalPktAckedInDLPerQci[index];
		if(l2_mac_param->DurationTTI != RRM_ZERO)
		{
			p_rrm_cell_ctx->rcc_param.total_prb_usage_ul =
				((l2_mac_param->totalPRBUsageUL * RRM_PERCENTAGE)/
				 (l2_mac_param->DurationTTI * get_ul_res_block_from_ul_bandwidth(p_rrm_cell_ctx)));
			p_rrm_cell_ctx->rcc_param.total_prb_usage_dl =
				((l2_mac_param->totalPRBUsageDL * RRM_PERCENTAGE)/
				 (l2_mac_param->DurationTTI * get_dl_res_block_from_dl_bandwidth(p_rrm_cell_ctx)));

			prb_per_qci_dl =
				((l2_mac_param->totalPRBUsagePerQciDL[index])* RRM_PERCENTAGE )/
                (l2_mac_param->DurationTTI * get_dl_res_block_from_dl_bandwidth(p_rrm_cell_ctx));

			prb_per_qci_ul =
				((l2_mac_param->totalPRBUsagePerQciUL[index])* RRM_PERCENTAGE )/
                (l2_mac_param->DurationTTI * get_ul_res_block_from_ul_bandwidth(p_rrm_cell_ctx));

			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI[%d],PrbUsageDL[%d]",index+RRM_ONE,prb_per_qci_dl);
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI[%d],PrbUsageUL[%d]",index+RRM_ONE,prb_per_qci_ul);


		}
		if(index <  MAX_NUM_GBR/*for gbr*/)
		{
			p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use  
				+= prb_per_qci_dl;

            p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use 
                += prb_per_qci_ul;
        }
        else /*For Non GBR*/
        {
            /* SPR_13986_fix: start */

		/*SPR 19164 Changes start*/
		/*Code Removed*/
		/*SPR 19164 Changes End*/

                p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use 
                    += prb_per_qci_dl;
                p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use
                    += prb_per_qci_ul;
            
            /* SPR_13986_fix: end */

        }	
        /* SPR 13492 changes start */
        p_rrm_cell_ctx->rcc_param.totalSessionTimePerQci[index] = 
            l2_mac_param->totalSessionTimePerQci[index];

        /* SPR 13492 changes end */
	}

	/* MLB Start */
	p_rrm_cell_ctx->svr_cell_load_info.bitmask |= RRM_RR_LOAD_PERIODIC_REPORT_PRESENT;
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_gbr_prb_usage =  p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use; 
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_gbr_prb_usage = p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use;
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage = p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use;
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage = p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use;
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage =
		p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_gbr_prb_usage + p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage;
	p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage =
		p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_gbr_prb_usage +  p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage;

	p_rrm_cell_ctx->svr_cell_load_info.bitmask |= RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT;

	rrm_fill_dl_comp_avl_cap_val (p_rrm_cell_ctx); 

	rrm_fill_ul_comp_avl_cap_val (p_rrm_cell_ctx);

	p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb
		= RRM_ZERO;
	p_rrm_cell_ctx->cell_resource_info.dl_allocated_ngbr_prb 
		=RRM_ZERO ;
	p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb
		= RRM_ZERO; 
	p_rrm_cell_ctx->cell_resource_info.ul_allocated_ngbr_prb
		= RRM_ZERO;
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI DL GBR:%d",
			p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI DL NGBR:%d",
			p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI UL GBR:%d",
			p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"QCI UL NGBR:%d",
			p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use);

    /* Doing averaging of the PRB usage */
    /*Klockwork_fix_start*/
    rrm_cellm_update_prb_process_msg_dl_gbr(p_rrm_cell_ctx);
    rrm_cellm_update_prb_process_msg_ul_gbr(p_rrm_cell_ctx);
    rrm_cellm_update_prb_process_msg_dl_ngbr(p_rrm_cell_ctx);
    rrm_cellm_update_prb_process_msg_ul_ngbr(p_rrm_cell_ctx);
    /*Klockwork_fix_end*/

 /* SPR-18438 START */
    p_rrm_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_a +=
        l2_mac_param->rcvdRandomAccessPreamblesGroupA; 
    p_rrm_cell_ctx->cell_rach_info.cell_rach_data.num_random_access_preambles_group_b +=
        l2_mac_param->rcvdRandomAccessPreamblesGroupB; 
    /* SPR-18438 END */


#ifdef UL_MU_MIMO_BUILD_ENABLED
        /* uplink mu mimo chnage start*/
          rrm_prb_usage_reached_threshold_ind(cell_index);
        /* uplink mu mimo chnage end*/
#endif
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_cell_pdcp_ind_bitrate
 * Inputs         : p_rrm_cell_ctx,rrm_cell_kpi_thp,ue_set_unset_req
 * Outputs        : None
 * Returns        : None 
 * Description    : Handle the message coming from PDCP for bitrate. checlk the throughput
 *                : if throughput is exceeded send ECN_set_req to UE
 ****************************************************************************/
rrm_return_et
/*COV_FIX_START_65036*/
rrm_cell_pdcp_ind_bitrate(rrm_cell_context_t         *p_rrm_cell_ctx,
                          rrm_cell_pdcp_kpi_thp_stat *rrm_cell_kpi_thp,
                          U8                         valid_count)
{
    rrm_return_et                         ret_val = RRM_SUCCESS;
    rrm_cell_qci_bitrate_config_t *p_bitrate_qci    = RRM_PNULL;
    rrmuem_cm_ecn_set_unset_ind_t ue_set_unset_req  = {RRM_ZERO}; 
    U16 count = RRM_ZERO;
    U8 store_ue_info = RRM_ZERO;
    /* Bug_12050_Fix: Start */
    U8 index = RRM_ZERO;
    /* Bug_12050_Fix: End */
    RRM_UT_TRACE_ENTER();
    p_bitrate_qci = &(p_rrm_cell_ctx->p_cell_ecn_config->bitrate_for_cell);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "bitrate count :%d",p_bitrate_qci->count);
    for (count = RRM_ZERO;count < p_bitrate_qci->count; count++)
    {
        for(index = RRM_ZERO; index < valid_count; index++)
        {
            if(rrm_cell_kpi_thp->cell_index[index] == p_rrm_cell_ctx->cell_index)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "count :%d",count);
                if(p_bitrate_qci->bitrate_for_qci[count].qci == rrm_cell_kpi_thp->qci[index])
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "QCI found :%d",p_bitrate_qci->bitrate_for_qci[count].qci);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "From OAM:: UL: max_bitrate[%llu] min bitrate[%llu] DL: max_bitrate[%llu] min_bitarte[%llu]",
                            p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.max_bitrate,
                            p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.min_bitrate,
                            p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.max_bitrate,
                            p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.min_bitrate);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "From PDCP: UL bitrate[%llu] DL bitrate[%llu]",
                            rrm_cell_kpi_thp->PdcpSduBitrateUl[index],
                            rrm_cell_kpi_thp->PdcpSduBitrateDl[index]);

                    /* validate the bitrate is provided for both Uplink and Downlink
                     */
                    if ((p_bitrate_qci->bitrate_for_qci[count].bitmask & RRMCM_RMIF_ECN_UL_BITRATE)&&
                            (p_bitrate_qci->bitrate_for_qci[count].bitmask & RRMCM_RMIF_ECN_DL_BITRATE))
                    {
                        /*Chk UL and DL Thp*/
                        if((p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateUl[index]) &&
                           (p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateDl[index]))
                        {
                            /* Thp exceede then provided from MIF.
                             * Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_BOTH_UL_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE; 
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion true for UL and DL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if((p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateDl[index])&&
                                (p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateUl[index]))
                        {
                            /*Storing Information to send ECN_CE_REQ */
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion true for DL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion false for UL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if ((p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateDl[index]) &&
                                 (p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateUl[index]))
                        {
                            /*Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion false for DL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion true for UL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if((p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateUl[index]) &&
                                (p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateDl[index]))
                        {
                            /* Thp exceede then provided from MIF.
                             * Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_BOTH_UL_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion false for UL and dL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if(p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateUl[index])
                        {
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion true for UL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if(p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateDl[index])
                        {
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion true for DL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if(p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateUl[index])
                        {
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion false for UL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if(p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateDl[index])
                        {
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "both ul dl biset:Congestion false for DL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                    }
                    /*Chk UL Thp*/
                    else if (p_bitrate_qci->bitrate_for_qci[count].bitmask& RRMCM_RMIF_ECN_UL_BITRATE)
                    {

                        if(p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateUl[index]) 
                        {
                            /*Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "ul bitset:Congestion true for UL dir:%d qci:%d congestion:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if(p_bitrate_qci->bitrate_for_qci[count].ul_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateUl[index]) 
                        {
                            /*Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_UL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "ul bitset:Congestion false for UL dir:%d qci:%d status:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }

                    }
                    /*Chk DL Thp*/
                    else if (p_bitrate_qci->bitrate_for_qci[count].bitmask & RRMCM_RMIF_ECN_DL_BITRATE)
                    {

                        if (p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.max_bitrate < rrm_cell_kpi_thp->PdcpSduBitrateDl[index]) 
                        {
                            /*Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status =RRM_TRUE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "dl bitset:Congestion true for DL dir:%d, qci:%d, status:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                        else if (p_bitrate_qci->bitrate_for_qci[count].dl_bitrate.min_bitrate > rrm_cell_kpi_thp->PdcpSduBitrateDl[index]) 
                        {
                            /*Storing Information to send ECN_CE_REQ */ 
                            ue_set_unset_req.ue_qci_list[store_ue_info].direction = ECN_APPLIED_IN_DL;
                            ue_set_unset_req.ue_qci_list[store_ue_info].qci = rrm_cell_kpi_thp->qci[index];
                            ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status = RRM_FALSE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "dl biset:Congestion false for DL dir:%d, qci:%d, status:%d",
                                    ue_set_unset_req.ue_qci_list[store_ue_info].direction,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].qci,
                                    ue_set_unset_req.ue_qci_list[store_ue_info].congestion_status);
                            store_ue_info++;
                        }
                    }
                    /*QCI found in the conigured list of MIF.thp is checked for QCI
                     * Now check for the next entry in list
                     */
                    break;
                }
            }
        }
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "ongoing [UE:%d] next [UE:%d]",
            rrm_cell_kpi_thp->ueIndex[index],
            rrm_cell_kpi_thp->ueIndex[index + RRM_ONE]);
    /*if no further entry for same ue_id. send req to UEM*/
    if (rrm_cell_kpi_thp->ueIndex[index] != rrm_cell_kpi_thp->ueIndex[index + RRM_ONE])
    {
        ue_set_unset_req.trans_id = RRM_ZERO;            
        ue_set_unset_req.cell_index= p_rrm_cell_ctx->cell_index;            
        ue_set_unset_req.ue_index = rrm_cell_kpi_thp->ueIndex[index];
        ue_set_unset_req.count = store_ue_info;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "CELLM send RRMUEM_CM_SET_UNSET_ECN_IND for [UE:%d], count:%d",
                ue_set_unset_req.ue_index,
                ue_set_unset_req.count);
        ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_SET_UNSET_ECN_IND,
                sizeof(rrmuem_cm_ecn_set_unset_ind_t),
                (void *)(&ue_set_unset_req));
    }
    else if (index + RRM_ONE == valid_count)
    {
        ue_set_unset_req.trans_id = RRM_ZERO;            
        ue_set_unset_req.cell_index= p_rrm_cell_ctx->cell_index;            
        ue_set_unset_req.ue_index = rrm_cell_kpi_thp->ueIndex[index];
        ue_set_unset_req.count = store_ue_info;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "CELLM send RRMUEM_CM_SET_UNSET_ECN_IND for [UE:%d], count:%d",
                ue_set_unset_req.ue_index,
                ue_set_unset_req.count);
        ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_SET_UNSET_ECN_IND,
                sizeof(rrmuem_cm_ecn_set_unset_ind_t),
                (void *)(&ue_set_unset_req));

    }
  RRM_UT_TRACE_EXIT();
  return ret_val;
}
/*COV_FIX_END_65036*/
/*Klockwork_fix_end*/
/* Bug_11649_Fix: Start */
/****************************************************************************
 * Function Name  : rrm_find_cell_index_for_ue_index
 * Inputs         : ue_index
 *                : *p_cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : In cell index found corresponding to the ue index provided
 *                : then returns success & copies cell index to *p_cell_index.
 *                : Else returns Failure.
 *****************************************************************************/
rrm_return_et
rrm_find_cell_index_for_ue_index(
 rrm_ue_index_t    ue_index,
 rrm_cell_index_t  *p_cell_index,
 rrm_global_context_t    *p_g_rrm_cell_ctx)
{
    rrm_return_et ret_val = RRM_FAILURE;
    U8            cell_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for(cell_count = RRM_ZERO; cell_count < RRM_MAX_NUM_CELLS; cell_count++)
    {
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count] != RRM_PNULL)
        {
            if(rrm_ue_find_context(ue_index, cell_count) != RRM_PNULL)
            {
                *p_cell_index = cell_count;
                ret_val = RRM_SUCCESS;
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Bug_11649_Fix: End */

/* ECN start*/
/* SPR-10397-fix start */
/****************************************************************************
 * Function Name  : rrm_cell_pdcp_ind 
 * Inputs         : p_api : pointer to data buffer 
 *		          : U16 api_id: api id
 *		          : U16 data_len: data length
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handle the message coming from PDCP. checlk the throughput 
 *                : if throughput is exceeded send ECN_set_req to UE
 ****************************************************************************/
rrm_return_et
rrm_cell_pdcp_ind
(
 void *p_api,
        /*SPR 17777 +-*/
 rrm_global_context_t    *p_rrm_gl_ctx)
{
    rrm_return_et                         ret_val = RRM_SUCCESS;
    PdcpKpiThpStatsIndParams              *p_pdcp_thp_stat = RRM_PNULL;
    rrm_cell_pdcp_kpi_thp_stat rrm_cell_kpi_thp;
    rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;
    U16 entry = RRM_ZERO;
    U16 index= RRM_ZERO;
    U16 count = RRM_ZERO;
    U16 valid_count = RRM_ZERO;
    rrm_bool_et valid = RRM_FALSE;
    rrm_bool_et is_ue_index_found = RRM_FALSE;

    U16 found_ue_index = RRM_ZERO;
    /* Bug_11649_Fix: Start */
    rrm_cell_index_t cell_index = RRM_ZERO;
    /* Bug_11649_Fix: End */
    /* Bug_12050_Fix: Start */
    rrm_temp_max_thp_t  rrm_ue_kpi_thp;
    //rrm_cell_context_t  **p_enb_cell_ctxt = RRM_NULL;
    /* Bug_12050_Fix: End */
#ifdef ENDC_ENABLED    
    rrm_temp_qci_thp_t  rrm_ue_qci_kpi_thp;
    rrm_qci_data_in_stats_t rrm_qci_data_in_stats; 
    U16 stats_index = RRM_ZERO;
    U16 qci_index= RRM_ZERO;
#endif
    RRM_UT_TRACE_ENTER();

    p_pdcp_thp_stat= (PdcpKpiThpStatsIndParams *)p_api;

    RRM_MEMSET(&rrm_cell_kpi_thp, RRM_ZERO, sizeof(rrm_cell_pdcp_kpi_thp_stat));
    /* Bug_12050_Fix: Start */
    RRM_MEMSET(&rrm_ue_kpi_thp, RRM_ZERO, sizeof(rrm_temp_max_thp_t));
#ifdef ENDC_ENABLED    
    RRM_MEMSET(&rrm_ue_qci_kpi_thp, RRM_ZERO, sizeof(rrm_temp_qci_thp_t));
    RRM_MEMSET(&rrm_qci_data_in_stats, RRM_ZERO, sizeof(rrm_qci_data_in_stats_t));
#endif
    rrm_cell_kpi_thp.avgDurationT = (p_pdcp_thp_stat->avgDurationT / RRM_ONE_THOUSAND_MS);
    /* Bug_12050_Fix: End */
    /* Klocwork_fix_27_aug_start */
    /*SPR 22987 Fix Start*/
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Pdcp stats duration[%d]\n", p_pdcp_thp_stat->avgDurationT);

    if(rrm_cell_kpi_thp.avgDurationT > RRM_ZERO)
    {
        /*SPR 22987 Fix Stop*/
        for(entry = RRM_ZERO;entry < MAX_KPI_INDEX && (index < (MAX_KPI_INDEX - RRM_ONE));entry++)
            /* Klocwork_fix_27_aug_end */
        {
            if ((p_pdcp_thp_stat->pdcpSduBitDl[entry] != INVALID_THP_STATS_ENTRY) ||
                    (p_pdcp_thp_stat->pdcpSduBitUl[entry] != INVALID_THP_STATS_ENTRY))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Recieved pdcpSduBitDl[%llu] , pdcpSduBitUl[%llu] \n",
                        p_pdcp_thp_stat->pdcpSduBitDl[entry],
                        p_pdcp_thp_stat->pdcpSduBitUl[entry]);

                rrm_cell_kpi_thp.ueIndex[valid_count] = p_pdcp_thp_stat->ueIndex[entry];
                rrm_cell_kpi_thp.qci[valid_count]     = p_pdcp_thp_stat->qci[entry];

                SET_UE_INDEX(rrm_cell_kpi_thp.ueIndex[valid_count]);

                /*start tgt_cell_ranking*/
                if (p_pdcp_thp_stat->pdcpSduBitDl[entry] != INVALID_THP_STATS_ENTRY)
                {
                    /* BItrate fix done on request of L2 */
                    rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count] = (p_pdcp_thp_stat->pdcpSduBitDl[entry] /
                            rrm_cell_kpi_thp.avgDurationT);
                }
                if (p_pdcp_thp_stat->pdcpSduBitUl[entry] != INVALID_THP_STATS_ENTRY)
                {
                    rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count] = (p_pdcp_thp_stat->pdcpSduBitUl[entry] /
                            rrm_cell_kpi_thp.avgDurationT);

                }
#ifdef ENDC_ENABLED
                rrm_ue_qci_kpi_thp.ue_index[qci_index] = rrm_cell_kpi_thp.ueIndex[valid_count];
                rrm_ue_qci_kpi_thp.qci[qci_index] = rrm_cell_kpi_thp.qci[valid_count];
                if(rrm_find_cell_index_for_ue_index(rrm_ue_qci_kpi_thp.ue_index[qci_index], &cell_index, p_rrm_gl_ctx) == RRM_SUCCESS)
                {
                    SET_CELL_INDEX(cell_index);
                    p_rrm_cell_ctx = p_rrm_gl_ctx->p_rrm_cell_ctx[cell_index];
/* coverity_280107_fix_start */
                    if(RRM_PNULL == p_rrm_cell_ctx)
                    {
                       ret_val = RRM_FAILURE;
                       break;
                    }
/* coverity_280107_fix_end */
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                            "Cell Index not found!!!");
                    continue;
                }
                rrm_ue_qci_kpi_thp.cell_index[qci_index] = p_rrm_cell_ctx->cell_index;
                rrm_ue_qci_kpi_thp.pdcpSduBitDl[qci_index] = rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                rrm_ue_qci_kpi_thp.pdcpSduBitUl[qci_index] = rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                qci_index++;
#endif
                /*end tgt_cell_ranking*/
                /* SPR 21251 +- */
                /* find max thp for a ue in dl and ul*/
                /* coverity_65135_fix: start */
                if (valid_count == RRM_ZERO)
                    /* coverity_65135_fix: end */
                {
                    /* Bug_11649_Fix: Start */
                    if(rrm_find_cell_index_for_ue_index(rrm_cell_kpi_thp.ueIndex[valid_count], &cell_index, p_rrm_gl_ctx) == RRM_SUCCESS)
                    {
                        SET_CELL_INDEX(cell_index);
                        p_rrm_cell_ctx = p_rrm_gl_ctx->p_rrm_cell_ctx[cell_index];
                        /* coverity_280107_fix_start */
                        if(RRM_PNULL == p_rrm_cell_ctx)
                        {
                            ret_val = RRM_FAILURE;
                            break;
                        }
                        /* coverity_280107_fix_end */
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                                "Cell Index not found!!!");
                        continue;
                    }
                    /* Bug_11649_Fix: End */
                    rrm_cell_kpi_thp.cell_index[valid_count] = p_rrm_cell_ctx->cell_index;
                    /*SPR 21670 +-*/
                    /*spr_22323_changes_start*/
                    p_rrm_cell_ctx->max_thp.ue_index[index]  = rrm_cell_kpi_thp.ueIndex[valid_count];
                    /*spr_22323_changes_end*/
                    rrm_ue_kpi_thp.ue_index[index] = rrm_cell_kpi_thp.ueIndex[valid_count];
                    rrm_ue_kpi_thp.cell_index[index] = p_rrm_cell_ctx->cell_index;
                    p_rrm_cell_ctx->max_thp.temp_num_of_active_UE++;

                    valid = RRM_TRUE;
                    /* Bug_11649_Fix: Start */
                    if (p_pdcp_thp_stat->pdcpSduBitUl[entry] != INVALID_THP_STATS_ENTRY)
                    {
                        rrm_ue_kpi_thp.max_ul_thp[index] = rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                        p_rrm_cell_ctx->max_thp.temp_cell_max_ul_thp = rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                    }
                    if (p_pdcp_thp_stat->pdcpSduBitDl[entry] != INVALID_THP_STATS_ENTRY)
                    {
                        rrm_ue_kpi_thp.max_dl_thp[index] = rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                        p_rrm_cell_ctx->max_thp.temp_cell_max_dl_thp = rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                    }
                    /* Bug_11649_Fix: End */
                }
                else
                {
                    is_ue_index_found = RRM_FALSE;
                    {
                        for (found_ue_index = RRM_ZERO;
                                found_ue_index < p_rrm_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell;
                                found_ue_index++)
                        {
                            if (p_rrm_cell_ctx->max_thp.ue_index[found_ue_index] == rrm_cell_kpi_thp.ueIndex[valid_count])
                            {
                                is_ue_index_found = RRM_TRUE;
                                break;
                            }
                        }
                        if (is_ue_index_found == RRM_TRUE)
                        {
                            /* Already updated no need to update again. */
                            /* p_rrm_cell_ctx->max_thp.ue_index[found_ue_index] = rrm_cell_kpi_thp.ueIndex[valid_count]; */
                            rrm_cell_kpi_thp.cell_index[valid_count] = p_rrm_cell_ctx->cell_index;
                            if (p_pdcp_thp_stat->pdcpSduBitUl[entry] != INVALID_THP_STATS_ENTRY)
                            {
                                rrm_ue_kpi_thp.max_ul_thp[index] += rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                                p_rrm_cell_ctx->max_thp.temp_cell_max_ul_thp += rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                            }
                            if (p_pdcp_thp_stat->pdcpSduBitDl[entry] != INVALID_THP_STATS_ENTRY)
                            {
                                rrm_ue_kpi_thp.max_dl_thp[index] += rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                                p_rrm_cell_ctx->max_thp.temp_cell_max_dl_thp += rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                            }
                        }
                        else
                        {
                            index++;
                            /* Bug_11649_Fix: Start */
                            if(rrm_find_cell_index_for_ue_index(rrm_cell_kpi_thp.ueIndex[valid_count], &cell_index, p_rrm_gl_ctx) == RRM_SUCCESS)
                            {
                                p_rrm_cell_ctx = p_rrm_gl_ctx->p_rrm_cell_ctx[cell_index];
                                /* coverity_280107_fix_start */
                                if(RRM_PNULL == p_rrm_cell_ctx)
                                {
                                    ret_val = RRM_FAILURE;
                                    break;
                                }
                                /* coverity_280107_fix_end */
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                                        "Cell Index not found!!!");
                                continue;
                            }
                            /* Bug_11649_Fix: End */
                            p_rrm_cell_ctx->max_thp.temp_num_of_active_UE++;
                            rrm_cell_kpi_thp.cell_index[valid_count] = p_rrm_cell_ctx->cell_index;
                            /* Bug_11649_Fix: End */
                            p_rrm_cell_ctx->max_thp.ue_index[index] = rrm_cell_kpi_thp.ueIndex[valid_count];
                            rrm_ue_kpi_thp.ue_index[index] = rrm_cell_kpi_thp.ueIndex[valid_count];
                            rrm_ue_kpi_thp.cell_index[index] = p_rrm_cell_ctx->cell_index;
                            /* Bug_11649_Fix: Start */
                            if (p_pdcp_thp_stat->pdcpSduBitUl[entry] != INVALID_THP_STATS_ENTRY)
                            {
                                rrm_ue_kpi_thp.max_ul_thp[index] = rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                                p_rrm_cell_ctx->max_thp.temp_cell_max_ul_thp += rrm_cell_kpi_thp.PdcpSduBitrateUl[valid_count];
                            }
                            if (p_pdcp_thp_stat->pdcpSduBitDl[entry] != INVALID_THP_STATS_ENTRY)
                            {
                                rrm_ue_kpi_thp.max_dl_thp[index] = rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                                p_rrm_cell_ctx->max_thp.temp_cell_max_dl_thp += rrm_cell_kpi_thp.PdcpSduBitrateDl[valid_count];
                            }
                            /* Bug_11649_Fix: End */
                        }
                    }
                }
                valid_count++;
            }
        }
        /*SPR 22987 Fix Start*/
    }
    /*SPR 22987 Fix Stop*/

    if (RRM_TRUE == valid)
    {
        /*Updating the throughput in ue_context*/
        for (count = RRM_ZERO; count <= index; count++)
        {
            rrm_cellm_update_thp_of_ue(rrm_ue_kpi_thp.cell_index[count],
                    rrm_ue_kpi_thp.ue_index[count],
                    (rrm_ue_kpi_thp.max_dl_thp[count]),
                    (rrm_ue_kpi_thp.max_ul_thp[count]));
        }
#ifdef ENDC_ENABLED
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "PDCP stats:- qci_index[%d] \n",qci_index);
        for (count = RRM_ZERO; count < qci_index; count++)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "PDCP stats:- For Count[%d] UE_IDX[%d] QCI[%d] ,update qci position\n",
                    count,rrm_ue_qci_kpi_thp.ue_index[count],rrm_ue_qci_kpi_thp.qci[count]);

            rrm_update_qci_pos_in_stats(rrm_ue_qci_kpi_thp.ue_index[count],
                    rrm_ue_qci_kpi_thp.qci[count],
                    &rrm_qci_data_in_stats,&stats_index);
            rrm_cellm_update_qci_thp_of_ue(rrm_ue_qci_kpi_thp.cell_index[count],
                    rrm_ue_qci_kpi_thp.ue_index[count],
                    rrm_ue_qci_kpi_thp.qci[count],
                    stats_index,
                    &rrm_qci_data_in_stats,
                    rrm_ue_qci_kpi_thp.pdcpSduBitUl[count],
                    rrm_ue_qci_kpi_thp.pdcpSduBitDl[count]);
        }
        for( count = RRM_ZERO ;  count < rrm_qci_data_in_stats.ue_count; count++ )
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_WARNING,
                    "ue_index[%d] QCI[%d][%d][%d][%d][%d][%d][%d][%d][%d]\n",
                    rrm_qci_data_in_stats.rrm_qci_pos[count].ue_index,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[0].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[1].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[2].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[3].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[4].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[5].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[6].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[7].pos,
                    rrm_qci_data_in_stats.rrm_qci_pos[count].rrm_qci_pos_in_ue[8].pos
                    );
        }
#endif

    }

    /* ECN bitrate is configured in cell context or not.
     ** and the configration must be for valid number of UE
     */
    /*Cov_fix_start_64992*/
    /*Loop: for checking the bitrate of qci is greater than the max configured bitrate*/
    for(index = RRM_ZERO; index < valid_count; index++)
    {
        /* Bug_11649_Fix: Start */
        if((p_rrm_gl_ctx->p_rrm_cell_ctx[rrm_cell_kpi_thp.cell_index[index]] != RRM_PNULL) &&
                (rrm_cell_kpi_thp.cell_index_traversed[rrm_cell_kpi_thp.cell_index[index]] == RRM_ZERO))
        {
            /* Bug_11649_Fix: End */
            p_rrm_cell_ctx = p_rrm_gl_ctx->p_rrm_cell_ctx[rrm_cell_kpi_thp.cell_index[index]];
            /* coverity_280107_fix_start */
            if(RRM_PNULL == p_rrm_cell_ctx)
            {
                ret_val = RRM_FAILURE;
                break;
            }
            /* coverity_280107_fix_end */

            if (p_pdcp_thp_stat->endIndicator == RRM_ONE)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "End Indicator received in the PDCP_Ind!");

                p_rrm_cell_ctx->cell_resource_info.total_cell_thp_ul = p_rrm_cell_ctx->max_thp.temp_cell_max_ul_thp;
                p_rrm_cell_ctx->cell_resource_info.total_cell_thp_dl = p_rrm_cell_ctx->max_thp.temp_cell_max_dl_thp;
                p_rrm_cell_ctx->max_thp.num_of_active_UE             = p_rrm_cell_ctx->max_thp.temp_num_of_active_UE;

                p_rrm_cell_ctx->max_thp.temp_cell_max_dl_thp  = RRM_ZERO;
                p_rrm_cell_ctx->max_thp.temp_cell_max_ul_thp  = RRM_ZERO;
                p_rrm_cell_ctx->max_thp.temp_num_of_active_UE = RRM_ZERO;
                /*SPR 21670 +-*/
                /*spr_22323_changes_start*/
                for(count = RRM_ZERO; count < MAX_UE_SUPPORTED ; count++)
                    p_rrm_cell_ctx->max_thp.ue_index[count] = RRM_ZERO;
                /*spr_22323_changes_end*/
            }

            if ((p_rrm_cell_ctx->p_cell_ecn_config != RRM_PNULL )&&
                    (p_rrm_cell_ctx->p_cell_ecn_config->num_of_ue != RRM_MINUS_ONE))
            {
                /* Check the bitarte for qci is configured from MIF in 
                 * bitrate_for_cell in cell context for 
                 * which valid throughput is received from PDCP
                 *
                 */

                /*Klockwork_fix_start*/
                ret_val = rrm_cell_pdcp_ind_bitrate(p_rrm_cell_ctx, &rrm_cell_kpi_thp, 
                        valid_count); 
                /*Klockwork_fix_end*/

            }
            rrm_cell_kpi_thp.cell_index_traversed[rrm_cell_kpi_thp.cell_index[index]] = RRM_ONE;
        }
        /* SPR 21251 +- */
    }
    /*Cov_fix_end_64992*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR-10397-fix end */

/****************************************************************************
 * Function Name  :rrm_pdcp_msg_handler
 * Inputs         : p_api_buf : pointer to data buffer 
 *		          : rrm_global_context_t *p_rrm_gb_ctx : pointer to cell global
 *		          : context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et
rrm_pdcp_msg_handler
(
 void  *p_api/*pointer to input API buffer*/,
 rrm_global_context_t    *p_rrm_gb_ctx/*Pointer to global cell context*/)
{
	void *p_data          = RRM_PNULL;
	U16	api_id	          = RRM_ZERO;
	U16	msg_size          = RRM_ZERO;
	rrm_return_et ret_val =	RRM_FAILURE;
	PdcpConfigureKpiStatsResp *p_pdcp_config_kpi_cnf = RRM_PNULL;
	RrmPdcpEcnConfigParamCnf    *pdcp_config_paran_cnf = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	api_id   = rrm_get_word_from_header((U8*)(p_api) + RRM_CSPL_API_ID_INDEX/*5*/);
	p_data = (U8 *)p_api + RRM_API_HEADER_SIZE;
	msg_size = rrm_get_word_from_header((U8*)(p_data) + RRM_INTF_MSG_ID_INDEX/*8*/);
/*BUG 585 FIX START*/
/* Bug_11649_Fix: Start */
/* Logic to extract Cell index from PDCP API Header removed. */
/* Bug_11649_Fix: End */

	msg_size = msg_size - RRM_INTERFACE_API_HEADER_SIZE;/*PDCP header will be of 12 byte*/
	/* removing Interface header
	 */
	p_data   = p_data + RRM_INTERFACE_API_HEADER_SIZE;/*PDCP header will be of 12 byte*/
	switch(api_id)
	{
		case RRM_PDCP_CONFIG_PARAMS_CNF:
			{
				pdcp_config_paran_cnf = (RrmPdcpEcnConfigParamCnf *)p_data;
				if (RRM_SUCCESS == pdcp_config_paran_cnf->respCode)
				{
					ret_val = RRM_SUCCESS;
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
							"PDCP->RRM:RRM_PDCP_CONFIG_PARAMS_CNF with response:%d",
							pdcp_config_paran_cnf->respCode);

				}
				else
				{
					ret_val = RRM_FAILURE;
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"PDCP->RRM:RRM_PDCP_CONFIG_PARAMS_CNF with response:%d",
							pdcp_config_paran_cnf->respCode);
				}
			}
			break;
		case RRM_PDCP_CONFIGURE_KPI_STATS_CNF:
			{
				p_pdcp_config_kpi_cnf = (PdcpConfigureKpiStatsResp *)p_data;
				if (RRM_SUCCESS == p_pdcp_config_kpi_cnf->responseCode)
				{
					ret_val = RRM_SUCCESS;
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
							"PDCP->RRM:RRM_PDCP_CONFIGURE_KPI_STATS_CNF with response:%d",
							p_pdcp_config_kpi_cnf->responseCode);
				}
				else
				{
					ret_val = RRM_FAILURE;
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"PDCP->RRM:RRM_PDCP_CONFIGURE_KPI_STATS_CNF with response:%d",
							p_pdcp_config_kpi_cnf->responseCode);
				}
			}
			break;
        /* Bug_11649_Fix: Start */
		case RRM_PDCP_KPI_THP_STATS_IND: 
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"PDCP->RRM:RRM_PDCP_KPI_THP_STATS_IND")
                /*SPR 17777 +-*/
                ret_val = rrm_cell_pdcp_ind(p_data,p_rrm_gb_ctx);
                /*SPR 17777 +-*/
        /* Bug_11649_Fix: End */
			break;
		default:
			ret_val = RRM_FAILURE;
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Wrong API %d received from PDCP",
					api_id);
            /* SPR 21251 End */

	}
	return ret_val;
}
/* ECN end*/



/****************************************************************************
 * Function Name  :rrm_l2_msg_handler 
 * Inputs         : p_api_buf : pointer to data buffer 
 *		  : rrm_global_context_t *p_rrm_gb_ctx : pointer to cell global
 *		  : context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/

rrm_return_et
rrm_l2_msg_handler(
		void  *p_api/*pointer to input API buffer*/,
		rrm_global_context_t    *p_rrm_gb_ctx/*Pointer to global cell context*/)
{
	void *p_data          = RRM_PNULL;
	U16	api_id	          = RRM_ZERO;
	U16	msg_size          = RRM_ZERO;
	rrm_return_et ret_val =	RRM_FAILURE;
    U8 cell_index         = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	api_id   = rrm_get_word_from_header((U8*)(p_api) + RRM_CSPL_API_ID_INDEX/*5*/);
	p_data = (U8 *)p_api + RRM_API_HEADER_SIZE;
	msg_size = rrm_get_word_from_header((U8*)(p_data) + RRM_INTF_MSG_ID_INDEX/*8*/);
/*BUG 585 FIX START*/
    cell_index = rrm_get_cell_id_from_header((U8*)(p_data));
    SET_CELL_INDEX(cell_index);
    /*++SPR 20009 */
    /*--SPR 20009 */
	msg_size = msg_size - RRM_INTERFACE_API_HEADER_SIZE;
	/* removing Interface header
	 */
	p_data   = p_data + RRM_INTERFACE_API_HEADER_SIZE;
    /*klok_fix_start_7296_7297*/
    /*CID 65851,65850:start*/
    if ((cell_index < RRM_MAX_NUM_CELLS) && (RRM_PNULL != p_rrm_gb_ctx->p_rrm_cell_ctx[cell_index]))
    /*CID 65851,65850:end*/
    {
    /*klok_fix_end_7296_7297*/    
        switch(api_id)
        {

            case RRM_MAC_CONFIGURE_KPI_STATS_CNF:

                /*
                 ** Multiple cell support, Passing a valid cell_index if multiple cell support
                 ** is enabled, otherwise passing 0 in cell_index.
                 */
                /*SPR 17777 +-*/
                ret_val = rrm_cellm_l2_kpi_stats_cnf(p_data,api_id,cell_index);
                break;
            case RRM_MAC_KPI_STATS_IND:
                ret_val = rrm_cellm_update_prb_process_msg( p_data,
                                                    /*SPR 17777 +-*/
                        cell_index);
                /*coverity 24975: break added: aditya , rel 1.3*/
                break;
            case RRM_MAC_CELL_CONFIG_CNF :

                /* 
                 ** Multiple cell support, Passing a valid cell_index if multiple cell support
                 ** is enabled, otherwise passing 0 in cell_index.
                 */
                ret_val = rrm_cellm_l2_config_cnf(p_data,
                        api_id,
                        /*SPR 17777 +-*/
                        cell_index);
                break;
                /* RRM_MAC_RECONF_SCHEDULER_CHANGES_START */
            case RRM_MAC_SCHEDULER_RECONFIG_CNF:
                /*++SPR 20009 */
                /*Code Removed*/
                /*--SPR 20009 */
                /*  DYNAMIC ICIC CHANGES START  */
                ret_val = rrm_cellm_l2_scheduler_reconf_cnf(p_data);
                /*SPR 17777 +-*/

                break;
                /* RRM_MAC_RECONF_SCHEDULER_CHANGES_ENDS */

            case RRM_MAC_L1_REPORT_IND:
                /*++SPR 20009 */
                /*Code Removed*/
                /*--SPR 20009 */
                ret_val = rrm_cellm_l1_meas_report_ind(p_data,
                /*SPR 17777 +-*/
                        cell_index);
                break;

            case RRM_MAC_ICIC_REPORT_IND :

                ret_val = rrm_cellm_l2_icic_meas_report(p_data,
                /*SPR 17777 +-*/
                        cell_index);
                break;
                /*  DYNAMIC ICIC CHANGES END    */
                /* RACH_OPTIMIZATION_CHANGES_START */
            case MAC_CONFIGURE_PERF_STATS_CNF:
                /*++SPR 20009 */
                /*Code Removed*/
                /*--SPR 20009 */
                ret_val = rrm_cellm_mac_config_perf_stats_cnf(p_data,
                        /*SPR 17777 +-*/
                        cell_index);

                break;

            case RRM_MAC_CELL_PERF_STATS_IND:
                /*++SPR 20009 */
                /*Code Removed*/
                /*--SPR 20009 */
                ret_val = rrm_cellm_mac_perf_stats_ind(p_data,
                        /*SPR 17777 +-*/
                        cell_index);

                break;

                /* RACH_OPTIMIZATION_CHANGES_END */
            /* eICIC_PHASE_1_2_CHANGES_START */
            case RRM_MAC_EICIC_REPORT_IND:
                ret_val = rrm_cellm_l2_eicic_meas_report(p_data,
                        /*SPR 17777 +-*/
                        cell_index);
                break;
            /* eICIC_PHASE_1_2_CHANGES_END */
            default:
                /*++SPR 20009 */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, "Unexpected api %d Received from MAC",api_id);
                /*--SPR 20009 */
                ret_val = RRM_FAILURE;
        }
    }
    else
    {
        /*++SPR 20009 */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Cell context not found for CellIdx[%u], Ignoring API [%d] received from MAC",cell_index, api_id);
        /*--SPR 20009 */
        ret_val = RRM_FAILURE;
    }
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_uem_process_msg
 * Inputs         : p_api_buf : pointer to data buffer 
 *		  : rrm_global_context_t *p_rrm_gb_ctx : pointer to cell global
 *		  : context
 * Outputs        : None
 * Returns        : RRM_SUCCESS-> CellM/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/

rrm_return_et
rrm_uem_process_msg(
		void  *p_api/*pointer to input API buffer*/)
        /*SPR 17777 +-*/
{
	void *p_data          = RRM_PNULL;
	U16 data_length       = RRM_ZERO;
	U16	api_id	          = RRM_ZERO;
	U16	msg_size          = RRM_ZERO;
	rrm_return_et ret_val =	RRM_FAILURE;

	RRM_UT_TRACE_ENTER();

	api_id = rrm_get_api_id(p_api);
	msg_size = rrm_get_word_from_header((U8*)(p_api) + RRM_MSG_SIZE_INDEX/*8*/);

	/* removing CSPL header
	 */
	p_data   = p_api + RRM_API_HEADER_SIZE;  
	/*extracting message size
	 */
	data_length = msg_size - RRM_API_HEADER_SIZE;         
	switch(api_id)
	{
		case RRMUEM_CM_DELETE_ALL_UE_CONTEXT_RESP:
			if(RRM_SUCCESS == rrm_cellm_cell_ue_del_resp_process_msg( p_data,
						api_id))
            /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}else
			{
				ret_val = RRM_FAILURE;
			}
			break;
            /*  DYNAMIC ICIC CHANGES START  */
		case RRMUEM_CM_UPDATE_UE_INFO_RESP:
			if(RRM_SUCCESS == rrm_cellm_cell_ue_update_ue_info_process_msg( p_data,
						                                                    api_id))
                                                                    /*SPR 17777 +-*/
			{
				ret_val = RRM_SUCCESS;
			}else
			{
				ret_val = RRM_FAILURE;
			}
			break;
            
            /*  DYNAMIC ICIC CHANGES END  */
            /* CA_Stage3_Change: Start */
        case RRMUEM_CM_CELL_INFO_CHANGE_RESP:
            if(RRM_SUCCESS == rrm_cellm_cell_info_change_ind_resp( p_data,
                        api_id))
                /*SPR 17777 +-*/
            {
                ret_val = RRM_SUCCESS;
            }
            else
            {
                /* SPR 21251 +- */
                ret_val = RRM_FAILURE;
            }

            break;
            /* CA_Stage3_Change: End */
            /* BUG_11648_FIX_START */
        case RRMUEM_CM_CELL_STOP_RESP:
            if(RRM_SUCCESS == rrm_cellm_cell_stop_broadcast_resp( p_data,
                        api_id))
                /*SPR 17777 +-*/
            {
                ret_val = RRM_SUCCESS;
            }
            else
            {
                ret_val = RRM_FAILURE;
            }
            break;
            /* BUG_11648_FIX_END */
            /* eICIC_PHASE_1_2_CHANGES_START */
        case RRMUEM_CM_GET_AGGRESSOR_RESP:
            if(RRM_SUCCESS == rrm_cellm_cell_ue_update_aggressor_info( p_data,
                                   api_id))
                            /*SPR 17777 +-*/
            {
                ret_val = RRM_SUCCESS;
            }else
            {
                ret_val = RRM_FAILURE;
            }
            break;

            /* eICIC_PHASE_1_2_CHANGES_END */
        
        /** eICIC_PHASE_1_2_CHANGES_START */
        case RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP:
            if(RRM_SUCCESS == rrm_cellm_cell_ue_provision_reconfig_resp( p_data,
                        api_id))
                /*SPR 17777 +-*/
            {
                ret_val = RRM_SUCCESS;
            }else
            {
                ret_val = RRM_FAILURE;
            }
            break;
        /** eICIC_PHASE_1_2_CHANGES_END */  
		default:
            /*SPR 17777 +-*/
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "unexpected api %d "
                    "Unused variable data_length=%u",api_id,data_length);
            /*SPR 17777 +-*/
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* Carrier_Aggregation_Start */
/****************************************************************************
 * Function Name  : rrm_load_actn_scell_deact_ind_process_msg
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *      		  : U16 api_id : api id
 *		          : U16 data_len : data length
 *		          : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context 
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles scell deactivation ind process message from 
 *                : peer cell
 ****************************************************************************/
rrm_return_et
rrm_load_actn_scell_deact_ind_process_msg
(
     rrm_void_t *p_api/*pointer to api buffer*/
        /*SPR 17777 +-*/
)
{
    rrm_cell_index_t cell_index                                 = RRM_ZERO;
    rrm_return_et ret_val                                       = RRM_SUCCESS;
    rrm_load_actn_scell_deact_ind_t *rrm_scell_deact_ind        = RRM_PNULL;
    U8 cell_count                                               = RRM_ZERO;
    rrm_scell_deactivation_notification_t scell_deact_notify_ue = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_g_rrm_cell_ctx);

    rrm_scell_deact_ind = (rrm_load_actn_scell_deact_ind_t *)p_api;

    SET_CELL_INDEX(rrm_scell_deact_ind->cell_index_of_deact_scell);


    for (cell_count = RRM_ZERO; cell_count < RRM_MAX_NUM_CELLS; cell_count++)
    {
        /* Coverity_ID_Fix : 61039 */
        if ( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count])
        {
            if (!RRM_MEMCMP(&rrm_scell_deact_ind->global_cell_id, 
                        &p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count]->global_cell_id,
                        sizeof(rrm_global_cell_id_t)))
            {
                cell_index = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count]->cell_index;
                RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
                SET_CELL_INDEX(cell_index);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "scell deactivation ind recieved for Cell Index :%d",
                        cell_index);
                break;
            }
        }
    }
    scell_deact_notify_ue.cell_index = cell_index;
    scell_deact_notify_ue.scell_deact_user.cell_index = rrm_scell_deact_ind->cell_index_of_deact_scell;
    scell_deact_notify_ue.scell_deact_user.num_of_user = rrm_scell_deact_ind->num_of_user;    
    /*SPR 13316:start*/
    /*Hardcoding the value as this deactivation is because of load*/
    scell_deact_notify_ue.trans_id = RRM_ONE;    
    /*SPR 13316:end*/

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Sending notifation to UE Mgr");

    ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
            RRMUEM_CM_SCELL_DEACT_ON_LOAD,
            sizeof( rrm_scell_deactivation_notification_t ),
            (void *)&scell_deact_notify_ue);

    if( RRM_SUCCESS == ret_val )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Successfully send notifation to UE Mgr");
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Failed to send notifation to UE Mgr");
        /* SPR 21251 End */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val; 
}
/* Carrier_Aggregation_End */
/****************************************************************************
 * Function Name  : rrm_rrmim_process_msg
 * Inputs         : p_api_buf : pointer to data buffer 
 *		  : rrm_global_context_t *p_rrm_gb_ctx : pointer to cell global
 *		  : context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles the incoming messages from Interface Handler
 ****************************************************************************/
rrm_return_et
rrm_rrmim_process_msg(
		void  *p_api/*pointer to input API buffer*/)
        /*SPR 17777 +-*/
{
	void *p_data          = RRM_PNULL;
        /*SPR 17777 +-*/
	U32	api_id	          = RRM_ZERO;
	rrm_return_et ret_val =	RRM_FAILURE;
	rrm_cell_index_t  cell_index=RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	api_id = rrm_get_api_id(p_api);
    
    /* SPR 21251 +- */

	/* removing CSPL header*/
	p_data   = p_api + RRM_API_HEADER_SIZE;  

	/*extracting message size*/
        /*SPR 17777 +-*/

    /* SPR 21251 +- */
	switch(api_id)
	{
		/* UE MEAS CHANGES : STARTS */ 
		case RRMCM_RMIF_MEAS_CONFIG_FROM_ANR_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
            /*SPR 17777 +-*/
			ret_val = rrm_cellm_meas_config_req_process_msg(p_data,
					api_id); 
			break;
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
        case RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ:
            ret_val = rrm_cellm_meas_config_obj_remove_req_process_msg(p_data,
                                                            api_id); 
            break;
			/* UE MEAS CHANGES : ENDS */ 
		case RRMCM_RMIF_CELL_CONFIG_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_config_req_process_msg(p_data,
					api_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_RECONFIG_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_reconfig_req_process_msg(p_data, 
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_START_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_start_req_process_msg(p_data,
					api_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_STOP_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_stop_req_process_msg(p_data
                    );
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
			/*Cell update start*/
		case RRMCM_RMIF_CELL_UPDATE_REQ:
			ret_val = rrm_cellm_cell_update_req_process_msg(p_data,
					api_id); 
			break; 
			/*Cell update end*/
		case RRMCM_RMIF_NMM_PREPARE_REQ :
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_nmm_prepare_process_msg(p_data);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_NMM_COMPLETE_REQ :
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_nmm_complete_process_msg(p_data);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_STOP_ADMISSION_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_stop_adm_req_process_msg(p_data,
					api_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;

		case RRMCM_RMIF_CELL_START_ADMISSION_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_start_adm_req_process_msg(p_data,
					api_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_DELETE_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_delete_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_INIT_CONFIG_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_init_config_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_SET_LOG_LEVEL_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_set_log_level_req_process_msg(p_data);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break; 
		case RRMCM_RMIF_LOG_ENABLE_DISABLE_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_log_enb_dis_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_REGISTER_FROM_ANR_REQ:
		case RRMCM_RMIF_CELL_REGISTER_FROM_ES_REQ:
		case RRMCM_RMIF_CELL_REGISTER_FROM_MLB_REQ:
		case RRMCM_RMIF_CELL_REGISTER_FROM_MRO_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_register_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_DEREGISTER_FROM_ANR_REQ:
		case RRMCM_RMIF_CELL_DEREGISTER_FROM_ES_REQ:
		case RRMCM_RMIF_CELL_DEREGISTER_FROM_MLB_REQ:
		case RRMCM_RMIF_CELL_DEREGISTER_FROM_MRO_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_deregister_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ANR_REQ:
		case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ES_REQ:
        case RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MRO_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_set_attr_req_process_msg(p_data,
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRMCM_RMIF_RAC_ENABLE_DISABLE_REQ :
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_cell_rrmim_rac_disable_enable(p_data,
					api_id);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
            /* RACH_OPTIMIZATION_CHANGES_START */
        case RRMCM_RMIF_RACH_INFO_IND :
            ret_val = rrm_cellm_cell_rach_info(p_data,
                    api_id);
            break;
            /* RACH_OPTIMIZATION_CHANGES_END */
		case RRMCM_RMIF_CELL_CONTEXT_PRINT_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			cell_index = ((rrmcm_rmif_cell_context_print_req_t *)p_data)->cell_index;
            SET_CELL_INDEX(cell_index);
			ret_val = rrm_log_cell_info(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
			/* UPDATED NRT INFO CHANGES START */ 
		case RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_cellm_updated_nrt_info_process_msg(p_data, 
					api_id); 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
			/* UPDATED NRT INFO CHANGES END */ 

			/* TNL DISCOVERY */    
		case RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_REQ:
			ret_val = rrm_cellm_tnl_discovery_process_msg(p_data);
			break;
		case RRMCM_RMIF_CELL_ECN_CAPACITY_REQ:
			ret_val = rrm_cellm_ecn_capacity_enhance_req_process_msg(p_data);
			break;
			/* RRM_MAC_RECONF_SCHEDULER_CHANGES_START */
		case RRMCM_RMIF_MAC_RECONF_SCHEDULE_IND:
			ret_val = rrm_cellm_l2_reconfig_scheduler_process_msg(p_data);
			break;
			/* RRM_MAC_RECONF_SCHEDULER_CHANGES_ENDS */
			/* MLB Changes start */
		case RRMCM_RMIF_LOAD_CONFIG_REQ:
			ret_val = rrm_cellm_load_config_req_process_msg(p_data,
					api_id); 
			break;

			/* MLB Changes end */
			/*Platform changes start*/
		case RRMCM_RMIF_CELL_PLATFORM_IND:
			ret_val = rrm_cellm_platform_load_ind(p_data);
			break;
            /* Klocwork changes start 22 may */
            /* Klocwork changes end 22 may */
			/*Platform changes end*/

        case RRMCM_RMIF_TTT_UPDATE_IND_REQ:
            ret_val = rrm_cellm_ttt_update_ind_process_msg(p_data,
                      api_id); 
            break;
        case RRMCM_RMIF_CONFIG_KPI_REQ:
			 ret_val = rrm_cellm_process_config_kpi_req(p_data);
             break;
        case RRMCM_RMIF_GET_KPI_REQ:
			 ret_val = rrm_cellm_process_get_kpi_req(p_data);
             break;

        case RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK:
			 ret_val = rrm_cellm_process_cell_stop_adm_req_for_cell_block(p_data,api_id);
             break;

        case RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK:
			 ret_val = rrm_cellm_process_cell_start_adm_req_for_cell_unblock(p_data,api_id);
             break;
        /* Carrier_Aggregation_Start */
		case RRMCM_RMIF_ENB_CONFIG_REQ:
			ret_val = rrm_cellm_enb_config_req_process_msg(p_data);
			break;
        /* Carrier_Aggregation_End */

        /*SPR 10329:start*/

		case RRMCM_RMIF_ENB_CONFIG_UPDATE_IND:
			ret_val = rrm_cellm_enb_config_update_ind(p_data);
            break;
            /*SPR 17777 +-*/
        /*SPR 10329:end*/

            /* Spr 16142 Fix Start */
        case RRMCM_RMIF_STOP_TNL_DISCOVERY_FROM_ANR_REQ:
            ret_val = rrm_cellm_handle_stop_tnl_discovery_ind(p_data);
            break;
            /* Spr 16142 Fix End */

		default:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
					"unexpected api %d ",api_id);
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_process_msg
 * Inputs         :  void *p_api_buf  : pointer to api buffer
 *		          :  void *p_gl_ctx   : pointer to cell global context
 * Outputs        : None
 * Returns        : void
 * Description    : Handles the incoming messages to cell rrm
 ****************************************************************************/
S32 rrm_process_msg(
		void *p_api_buf/*pointer to api buffer*/,
		void *p_gl_ctx/*pointer to global cell context*/)
{
	U16                    src_id =  RRM_ZERO;
	rrm_return_et          ret_val = RRM_SUCCESS;
	rrm_global_context_t   *p_rrm_gbl_ctx = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

    p_rrm_gbl_ctx = (rrm_global_context_t *)p_gl_ctx;
    /* coverity_94020 start */
    if(PNULL == p_api_buf)
    {
        /*++SPR 20009 */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "p_api_buf received NULL in rrm_process_msg");
        /*--SPR 20009 */
        return(RRM_FAILURE);
    }
    /* coverity_94020 stop */

    /* Check the Source ID of the Message*/
	src_id = rrm_get_src_module_id(p_api_buf);
    /*++SPR 20009 */
    /*Code Removed*/
    /*--SPR 20009 */

	switch (src_id)
	{
		case RRC_MODULE_ID  : 
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
            /*SPR 17777 +-*/
			ret_val = rrm_rrc_msg_handler(p_api_buf);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case MAC_MODULE_ID:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_l2_msg_handler(p_api_buf, p_rrm_gbl_ctx);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case PDCP_MODULE_ID:
			ret_val = rrm_pdcp_msg_handler(p_api_buf, p_rrm_gbl_ctx);
			break;
		case RRM_MIF_MODULE_ID:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/ 
			ret_val = rrm_rrmim_process_msg(p_api_buf);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
		case RRM_UEM_MODULE_ID:
			/*LTE_RRM_KLOCWORK_WARN_10JUL_START*/
			ret_val = rrm_uem_process_msg(p_api_buf);
			/*LTE_RRM_KLOCWORK_WARN_10JUL_END*/
			break;
			/* LTE_RRM_MALL, CID 11118 */
        case RRM_CM_MODULE_ID :
             ret_val = rrm_process_cellm_message(p_api_buf);
            /*SPR 17777 +-*/
             break;
		default:
            /*++SPR 20009 */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
					"Received message from Unknown Module Id (%d)", src_id);
            /*--SPR 20009 */
			break;
	}
        /* SPR 18705:start */
#ifdef LTE_EMBMS_SUPPORTED
        /*
         * check for Node in list in global contest  and .. and both cells are in active state, 
         *then process this req, Otherwise no need to process !!!     
         */
        if (RRM_FAILURE != rrm_find_enqueued_sf_info_req(&p_rrm_gbl_ctx->enque_sf_info_list))
        {

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                    "Total enque_sf_info_list count Nodes: %d",
                    ylCount((&p_rrm_gbl_ctx->enque_sf_info_list)));
            rrm_deque_enqued_sf_info_req_in_glb_cxt(&p_rrm_gbl_ctx->enque_sf_info_list);
        }
#endif
        /* SPR 18705:end */


    SET_CELL_INDEX(0xFF);
	RRM_UT_TRACE_EXIT();
    /* SPR 21251 Start */
	return ret_val;
    /* SPR 21251 End */
}


/****************************************************************************
 * Function Name  : rrm_cellm_cell_reconfig_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context 
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 ****************************************************************************/


rrm_return_et
rrm_cellm_cell_reconfig_req_process_msg(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index=RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_cell_reconfig_req_t *rrmcm_rmif_cell_reconfig_req = RRM_PNULL;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_reconfig_req =
		(rrmcm_rmif_cell_reconfig_req_t *)p_api;
	/*21481:Need to check the cell index for which reconfig has come
	 */ 
	cell_index = rrmcm_rmif_cell_reconfig_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->CellM:RRMCM_RMIF_CELL_RECONFIG_REQ");

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
    	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	    		"Cell context is null For Cell Index :%d",
		    	cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 

/* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
		/* message processing to FSM
		 */

		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
			RRMCM_RMIF_CELL_RECONFIG_REQ;  
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
			((rrmcm_rmif_cell_reconfig_req_t *)p_api)->transaction_id;
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_RECONFIG_REQ_EVENT,
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
		}
		else
		{
			ret_val = RRM_SUCCESS;
		}
/* SPR 11681 Fix Start */
   /* Code deleted */
/* SPR 11681 Fix End */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
 /*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_cellm_cell_start_req_process
 * Inputs         : U8 *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 ****************************************************************************/
/*spr_fix_start_12668*/
rrm_return_et
rrm_cellm_cell_start_req_process(rrm_cell_index_t    cell_index ,
                                 void                *p_api ,
                                 U16                 api_id )
/*spr_fix_end_12668*/
{
    rrm_return_et ret_value = RRM_SUCCESS;   
    RRM_UT_TRACE_ENTER();
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
        RRMCM_RMIF_CELL_START_REQ;  
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
        ((rrmcm_rmif_cell_start_req_t *)p_api)->transaction_id;
    /* message processing to FSM
     */
    if (RRM_FAILURE == cellm_fsm_process_event (
                RRMCM_RMIF_CELL_START_REQ_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
        ret_value = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "successfully process api id %d in fsm",api_id);
        ret_value = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_value;
}

/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : rrm_cellm_cell_start_req_process_msg
 * Inputs         : U8 *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 ****************************************************************************/

rrm_return_et
rrm_cellm_cell_start_req_process_msg(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)

{
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_cell_start_req_t *rrmcm_rmif_cell_start_req = RRM_PNULL;
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_start_req =
		(rrmcm_rmif_cell_start_req_t *)p_api;
	/*21481:Need to check the cell index for which start has come
	 */ 
	cell_index = rrmcm_rmif_cell_start_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->RRMCM_RMIF_CELL_START_REQ->CellM");

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Satrt */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Stop Adm Req For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    /*Get the cell state from cell context*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = 
        CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_OOS_STATE; 
    if (CELL_STATE_ACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = 
            CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_ACTIVE_STATE; 
    }
    else if (CELL_STATE_INACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = 
			CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_INACTIVE_STATE; 
	}
    else if (CELL_STATE_OUT_OF_SERVICE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state)
	{
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = 
			CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_OOS_STATE; 
	}
    /*Klockwork_fix_start*/
    /*spr_fix_start_12668*/ 
     ret_val = rrm_cellm_cell_start_req_process(cell_index ,p_api ,api_id);
     /*spr_fix_end_12668*/
    /*Klockwork_fix_end*/
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
    
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_cell_nmm_complete_process_msg 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell nmm complete req to cell rrm
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_nmm_complete_process_msg(
		void *p_api/*pointer pt api buffer*/
            /*SPR 17777 +-*/
		)
{             
	rrmcm_rmif_nmm_complete_resp_t *p_complete_resp = RRM_PNULL;
	rrmcm_rmif_nmm_complete_req_t *p_complete_req = RRM_PNULL;
	rrm_return_et ret_val = RRM_SUCCESS;
	/*It would be platform specific */

	RRM_UT_TRACE_ENTER();
	p_complete_req = (rrmcm_rmif_nmm_complete_req_t*)p_api;
	p_complete_resp = rrm_mem_get(sizeof(rrmcm_rmif_nmm_complete_resp_t));
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,"MIF->RRMCM_RMIF_NMM_COMPLETE_REQ->CellM");
	if ( p_complete_resp == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_complete_resp failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    p_complete_resp->transaction_id = p_complete_req->transaction_id;
	p_complete_resp->response = RRM_SUCCESS;
	p_complete_resp->fail_cause = RRM_NO_ERROR;
	ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
			RRMCM_RMIF_NMM_COMPLETE_RESP,
			sizeof(rrmcm_rmif_nmm_complete_resp_t),
			(void *)p_complete_resp);
	if(ret_val == RRM_SUCCESS)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Successfully send RRMCM_RMIF_NMM_PREPARE_RESP");
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"Failed to send RRMCM_RMIF_NMM_PREPARE_RESP");
		ret_val = RRM_FAILURE;
	}
	RRM_MEM_FREE(p_complete_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_cell_nmm_prepare_process_msg 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_nmm_prepare_process_msg(
		void *p_api/*pointer pt api buffer*/
            /*SPR 17777 +-*/
		)
{             
	rrmcm_rmif_nmm_prepare_resp_t *p_prepare_resp = RRM_PNULL;
	rrmcm_rmif_nmm_prepare_req_t *p_prepare_req = RRM_PNULL;
	rrm_return_et ret_val = RRM_SUCCESS;
	/*It would be platform specific */

	RRM_UT_TRACE_ENTER();
	p_prepare_req = (rrmcm_rmif_nmm_prepare_req_t *)p_api;
	p_prepare_resp = rrm_mem_get(sizeof(rrmcm_rmif_nmm_prepare_resp_t));
	if (p_prepare_resp  == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_prepare_resp failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_NMM_PREPARE_REQ->CellM");
    p_prepare_resp->transaction_id = p_prepare_req->transaction_id;
	p_prepare_resp->response = RRM_SUCCESS;
	p_prepare_resp->fail_cause = RRM_NO_ERROR;
	ret_val = rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
			RRMCM_RMIF_NMM_PREPARE_RESP,
			sizeof(rrmcm_rmif_nmm_prepare_resp_t),
			(void *)p_prepare_resp);
	if(ret_val == RRM_SUCCESS)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Successfully send RRMCM_RMIF_NMM_PREPARE_RESP");
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"Failed to send RRMCM_RMIF_NMM_PREPARE_RESP");
		ret_val = RRM_FAILURE;
	}
	RRM_MEM_FREE(p_prepare_resp);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_handle_stop_req
 * Inputs         : void *p_api
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : handle cell stop request
 ***********************************************************************/
/*klock_works_changes_start*/

rrm_return_et
rrm_handle_stop_req(void *p_api)
{
    rrm_cell_index_t cell_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    rrmcm_rmif_cell_stop_req_t *rrmcm_rmif_cell_stop_req = RRM_PNULL;
    U32 api_id= RRM_ZERO;
    
    RRM_UT_TRACE_ENTER();
    
    api_id = rrm_get_api_id(p_api);
    rrmcm_rmif_cell_stop_req =
        (rrmcm_rmif_cell_stop_req_t *)p_api;

    cell_index = rrmcm_rmif_cell_stop_req->cellindex;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Stop req for cell index :%d",cell_index);

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;

    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    /*Get the cell state from cell context*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered =
        CELLM_PROC_TRIGGERRED_EXTERNALLY_IN_ACTIVE_STATE;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =
        RRMCM_RMIF_CELL_STOP_REQ;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id =
        ((rrmcm_rmif_cell_stop_req_t *)p_api)->transaction_id;
    /* message processing to FSM
     */
    if (RRM_FAILURE == cellm_fsm_process_event(
                RRMCM_RMIF_CELL_STOP_REQ_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "successfully process api id %d in fsm",api_id);
        ret_val = RRM_SUCCESS;
    }
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/



/****************************************************************************
 * Function Name  : rrm_cellm_cell_stop_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_stop_req_process_msg(
		void *p_api/*pointer pt api buffer*/
            /*SPR 17777 +-*/
		)
{                
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_cell_stop_req_t *rrmcm_rmif_cell_stop_req = RRM_PNULL;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();

	rrmcm_rmif_cell_stop_req =
		(rrmcm_rmif_cell_stop_req_t *)p_api;
	/*cell index for which stop has come
	 */ 
	cell_index = rrmcm_rmif_cell_stop_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->RRMCM_RMIF_CELL_STOP_REQ->CellM");
    {
        /*SPR 21660 changes end */
	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
    /*klock_works_changes_start*/
    if(RRM_FAILURE==rrm_handle_stop_req(p_api))
    {
        ret_val=RRM_FAILURE;
    }
    /*klock_works_changes_end*/
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 
        /*SPR 21660 changes start */
    }
    /*SPR 21660 changes end */
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/*Cell update start*/
/****************************************************************************
 * Function Name  : rrm_cellm_cell_update_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *        : U16 api_id : api id
 *        : U16 data_len : data length
 *        : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_update_req to cell rrm
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_update_req_process_msg(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_cell_update_req_t *rrmcm_rmif_cell_update_req = RRM_PNULL;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_update_req =
		(rrmcm_rmif_cell_update_req_t *)p_api;
	cell_index = rrmcm_rmif_cell_update_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->RRMCM_RMIF_CELL_UPDATE_REQ->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"cell context is null For Cell Index :%d",
			    cell_index);
        /*SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;

/* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
		/* message processing to FSM
		 */

		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =
			RRMCM_RMIF_CELL_UPDATE_REQ;
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id =
			((rrmcm_rmif_cell_update_req_t *)p_api)->transaction_id;
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_UPDATE_REQ_EVENT,
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
					"could not process api id %d in fsm",api_id);
		}
		else
		{
			ret_val = RRM_SUCCESS;
		}
/* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Cell update end*/
/*Klockwork_fix_start*/
/************************************************************************
 * Function Name  : rrm_cellm_ecn_capacity_enhance_req
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Fills radio congestion threshold values to cell rrm
 **************************************************************************/
rrm_void_t
rrm_cellm_ecn_capacity_enhance_req(rrmcm_rmif_cell_ecn_config_req_t        *p_in_cell_ecn_config_req ,
                                   rrmcm_rmif_generic_resp_t               *p_generic_resp ,
                                   rrm_cell_context_t                      *p_cell_ctx ,
                                   RrmPdcpEcnConfigParamReq                *pdcp_ecn_config_param_req)
{
    U8                                      index = RRM_ZERO;
    rrm_bool_et                             ul_bitrate= RRM_FALSE;
    rrm_bool_et                             dl_bitrate = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
        /*Count cannot be zero*/
        if (RRM_ZERO == p_in_cell_ecn_config_req->bitrate.count)
        {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "ECN bitrate count is zero send failure to MIF");
        p_generic_resp->response= RRM_FAILURE;
        p_generic_resp->fail_cause=RRM_ERR_MANDATORY_PARAMS_ABSENT;
        }
        else
        {
            p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.count= p_in_cell_ecn_config_req->bitrate.count; 
            for(index = RRM_ZERO;index<p_in_cell_ecn_config_req->bitrate.count;index++)
            {
                p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].qci=
                    p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].qci;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                        "QCI  :%d",p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].qci);
                if ( p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].bitmask & 
                        RRMCM_RMIF_ECN_UL_BITRATE)
                {
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].bitmask |= RRMCM_RMIF_ECN_UL_BITRATE;
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].ul_bitrate.max_bitrate=
                        p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].ul_bitrate.max_bitrate;
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].ul_bitrate.min_bitrate=
                        p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].ul_bitrate.min_bitrate;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "ul_bitrate  MAX:%llu  MIN:%llu",
                            p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].ul_bitrate.max_bitrate,
                            p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].ul_bitrate.min_bitrate);
                    ul_bitrate= RRM_TRUE;
                }

                if ( p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].bitmask & 
                        RRMCM_RMIF_ECN_DL_BITRATE)
                {
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].bitmask |= RRMCM_RMIF_ECN_DL_BITRATE;
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].dl_bitrate.max_bitrate=
                        p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].dl_bitrate.max_bitrate;
                    p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].dl_bitrate.min_bitrate=
                        p_in_cell_ecn_config_req->bitrate.bitrate_for_qci[index].dl_bitrate.min_bitrate;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "dl_bitrate  MAX:%llu  MIN:%llu",
                            p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].dl_bitrate.max_bitrate,
                            p_cell_ctx->p_cell_ecn_config->bitrate_for_cell.bitrate_for_qci[index].dl_bitrate.min_bitrate);
                    dl_bitrate= RRM_TRUE;
                }
            }
            /*Filling the PDCP_CONFIG_REQ to set ECN bit */
            if (ul_bitrate == RRM_TRUE && dl_bitrate == RRM_TRUE)
            {
            pdcp_ecn_config_param_req->ecnFeatureStatus = ECN_APPLIED_IN_BOTH_UL_DL; 
            }
            else if(ul_bitrate == RRM_TRUE)
            {
            pdcp_ecn_config_param_req->ecnFeatureStatus = ECN_APPLIED_IN_UL;
            }
            else if (dl_bitrate == RRM_TRUE)
            {
            pdcp_ecn_config_param_req->ecnFeatureStatus = ECN_APPLIED_IN_DL;
            }
            else
            {
            pdcp_ecn_config_param_req->ecnFeatureStatus = ECN_NOT_APPLIED;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "ECN applied in dir :%d",pdcp_ecn_config_param_req->ecnFeatureStatus);
            if((!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_UL_DIR))&&
                    (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_AQM)) &&
                    (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_DL_DIR))&&
                    (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_BI_DIR)))
            {
            pdcp_ecn_config_param_req->ecnTrigger=ECN_T2_BASED_ON_RRM_DETECTION; 
            /*SPR:6834 start*/
            pdcp_ecn_config_param_req->lowWaterMark= DEFAULT_LOW_WATER_MARK;
            pdcp_ecn_config_param_req->highWaterMark= DEFAULT_HIGH_WATER_MARK;
                /*SPR:6834 end*/
                /*Sent the PDCP_CONFIG_REQ to PDCP */ 
            rrm_send_pdcp_config_param_req(pdcp_ecn_config_param_req, RRM_MODULE_ID, RRM_ZERO, p_cell_ctx->cell_index); 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "PDCP_CONFIG_REQ:ecnTrigger[%d] ecnFeatureStatus[%d] lowWaterMark[%d] highWaterMark[%d]", 
                    pdcp_ecn_config_param_req->ecnTrigger,
                    pdcp_ecn_config_param_req->ecnFeatureStatus,
                    pdcp_ecn_config_param_req->lowWaterMark,
                    pdcp_ecn_config_param_req->highWaterMark);
        }
        else
        {
            pdcp_ecn_config_param_req->ecnFeatureStatus = ECN_APPLIED_IN_BOTH_UL_DL; 
            pdcp_ecn_config_param_req->ecnTrigger= ECN_BOTH_TRIGGERS_APPLIED; 
            /*SPR:6834 start*/
            pdcp_ecn_config_param_req->lowWaterMark=DEFAULT_LOW_WATER_MARK; 
            pdcp_ecn_config_param_req->highWaterMark= DEFAULT_HIGH_WATER_MARK;
            /*SPR:6834 end*/
            /*Sent the PDCP_CONFIG_REQ to PDCP */ 
            rrm_send_pdcp_config_param_req(pdcp_ecn_config_param_req, RRM_MODULE_ID, RRM_ZERO, p_cell_ctx->cell_index); 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "PDCP_CONFIG_REQ:ecnTrigger[%d] ecnFeatureStatus[%d] lowWaterMark[%d] highWaterMark[%d]", 
                    pdcp_ecn_config_param_req->ecnTrigger,
                    pdcp_ecn_config_param_req->ecnFeatureStatus,
                    pdcp_ecn_config_param_req->lowWaterMark,
                    pdcp_ecn_config_param_req->highWaterMark);
            }
            /*Fill succcess response*/
        p_generic_resp->response= RRM_SUCCESS;
        p_generic_resp->fail_cause=RRM_NO_ERROR;
        }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

/* ECN start*/
/************************************************************************
 * Function Name  : rrm_cellm_ecn_capacity_enhance_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Fills radio congestion threshold values to cell rrm
 **************************************************************************/

rrm_return_et
rrm_cellm_ecn_capacity_enhance_req_process_msg(
		void *p_api/*pointer to api buffer*/
            /*SPR 17777 +-*/
		)
{                
    rrm_return_et                           ret_val = RRM_SUCCESS;
    rrm_cell_context_t                      *p_cell_ctx= RRM_PNULL;
    RrmPdcpEcnConfigParamReq                pdcp_ecn_config_param_req = {RRM_ZERO};
    rrmcm_rmif_generic_resp_t               p_generic_resp={RRM_ZERO};
    rrmuem_cm_unset_for_all_ue_ind_t        ue_unset_ecn_ind = {RRM_ZERO};
    rrmcm_rmif_cell_ecn_config_req_t        *p_in_cell_ecn_config_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_in_cell_ecn_config_req=
        (rrmcm_rmif_cell_ecn_config_req_t *)p_api;
    RRM_ASSERT(p_in_cell_ecn_config_req->cell_index < RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(p_in_cell_ecn_config_req->cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "MIF->RRMCM_RMIF_CELL_ECN_CAPACITY_REQ->CellM:[CELL:%d]",
            /* SPR 10318 fix start*/
            p_in_cell_ecn_config_req->cell_index );
    /* SPR 10318 fix end*/

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_in_cell_ecn_config_req->cell_index])
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell Context Not Created");
        /* SPR 21251 End */
        return RRM_FAILURE;
    }
    p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_in_cell_ecn_config_req->cell_index];

    /* SPR 10318 fix start*/
    p_generic_resp.cellindex = p_in_cell_ecn_config_req->cell_index;
    /* SPR 10318 fix end*/

    if (p_cell_ctx->p_cell_ecn_config == RRM_PNULL)
    {
        p_cell_ctx->p_cell_ecn_config=
            (rrm_cell_ecn_config_t *)rrm_mem_get(sizeof(rrm_cell_ecn_config_t));
        if ( p_cell_ctx->p_cell_ecn_config == RRM_PNULL)
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_ctx->p_cell_ecn_config failed" );
            /* SPR 21251 End */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    /*Storing the configuration cell context*/    
    p_cell_ctx->p_cell_ecn_config->num_of_ue =  p_in_cell_ecn_config_req->num_of_ue;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Num of ue:%d",p_cell_ctx->p_cell_ecn_config->num_of_ue);
    /*-1 as num of ue signifies that. OAM wants to stop ECN capacity enhanance request */
    if(p_cell_ctx->p_cell_ecn_config->num_of_ue == RRM_MINUS_ONE)
    {
        /*check that action ongoing for load config*/
        if((!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_UL_DIR))&&
                (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_AQM)) &&
                (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_DL_DIR))&&
                (!(p_cell_ctx->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_RRM_ECN_BI_DIR)))
        {
            /*Filling param to send PDCP_CONFIG_REQ to stop the setting the ECN bit*/
            pdcp_ecn_config_param_req.ecnFeatureStatus = ECN_NOT_APPLIED;
            pdcp_ecn_config_param_req.ecnTrigger=ECN_T2_BASED_ON_RRM_DETECTION; 
            pdcp_ecn_config_param_req.lowWaterMark=DEFAULT_LOW_WATER_MARK; 
            pdcp_ecn_config_param_req.highWaterMark= DEFAULT_HIGH_WATER_MARK;
            /*Sent the PDCP_CONFIG_REQ to PDCP */ 
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cellm send PDCP_CONFIG_REQ to stop CE detection");
            rrm_send_pdcp_config_param_req(&pdcp_ecn_config_param_req, RRM_MODULE_ID, RRM_ZERO, p_cell_ctx->cell_index); 
        }
        /*Send request to UEM, to unset bit of ECN. If alredy set with Congestion status as true */
        ue_unset_ecn_ind.trans_id = RRM_ZERO;
        ue_unset_ecn_ind.cell_index = p_cell_ctx->cell_index; 
        ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_UNSET_ECN_FOR_ALL_UE_IND,
                sizeof(rrmuem_cm_unset_for_all_ue_ind_t),
                (void *)(&ue_unset_ecn_ind));
        /* Coverity ID 78769 Fix Start*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "cell index[%u] [%s] in sending RRMUEM_CM_UNSET_ECN_FOR_ALL_UE_IND", 
                p_cell_ctx->cell_index,(ret_val == RRM_SUCCESS? "successful":"unsuccessful"));
        /* Coverity ID 78769 Fix End*/
    }
    else
    {
        /*Klockwork_fix_start*/ 
        rrm_cellm_ecn_capacity_enhance_req(p_in_cell_ecn_config_req ,&p_generic_resp ,
                p_cell_ctx ,&pdcp_ecn_config_param_req);
        /*Klockwork_fix__end*/
    }
    /*Fill the response for ECN config resp*/   
    p_generic_resp.transaction_id =p_in_cell_ecn_config_req->transaction_id;
    /*Send the response to MIF*/
    ret_val = build_and_send_generic_resp_to_mif(&p_generic_resp,
            RRMCM_RMIF_CELL_ECN_CAPACITY_RESP);
    /*COV_FIX_START_65028*/
    /*SPR 19013 +-*/
    /*COV_FIX_END_65028*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* ECN end*/
/*SPR 10329:start*/

/************************************************************************
 * Function Name  : rrmcm_gu_group_id_data_key_compare 
 * Inputs         : p_key1,
 *                : p_key2
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : compares mme_group_id 
 **************************************************************************/
int rrmcm_gu_group_id_data_key_compare 
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
    if (!RRM_MEMCMP((rrm_global_mme_group_id_key_t *)p_key1, (rrm_global_mme_group_id_key_t *)p_key2, 
                sizeof(rrm_global_mme_group_id_key_t)))
    {
        return (RRM_FAILURE);
    }
    else
    {
        return (RRM_SUCCESS);
    }
}

/************************************************************************
 * Function Name  : rrmcm_enb_id_data_key_compare 
 * Inputs         : p_key1, 
 *                : p_key2
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : compares eNb Id 
 **************************************************************************/
int rrmcm_enb_id_data_key_compare
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
    if (!RRM_MEMCMP((rrm_global_enb_id_key_t*)p_key1, (rrm_global_enb_id_key_t*)p_key2, sizeof(rrm_global_enb_id_key_t)))
    {
        return (RRM_FAILURE);
    }
    else
    {
        return (RRM_SUCCESS);
    }
}


/************************************************************************
 * Function Name  : rrmcm_gu_group_id_key
 * Inputs         : p_ylnode
 * Outputs        : None
 * Returns        : mme_group_id_key
 * Description    : returns mme_group_id_key  
 **************************************************************************/
const void *
rrmcm_gu_group_id_key
(
 const YLNODE    *p_ylnode
 )
{
    return  &(((rrm_gu_group_id_node_t *)p_ylnode)->mme_group_id_key);
}

/************************************************************************
 * Function Name  : search_gu_group_id_from_list
 * Inputs         : p_add_gu_id,
 *                : p_enb_id_node
 * Outputs        : None
 * Returns        : node of gu_group id
 * Description    : search gu_group_id 
 **************************************************************************/
rrm_gu_group_id_node_t *
search_gu_group_id_from_list
(
 rrm_oam_gu_group_id_t             *p_add_gu_id,
 rrm_enb_gu_group_id_node_t    *p_enb_id_node
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_gu_group_id_list_t    *p_gu_group_id_list       = RRM_PNULL;
    rrm_gu_group_id_node_t    *p_gu_group_id_node       = RRM_PNULL;
    /*SPR 10329:fix start*/
    rrm_global_mme_group_id_key_t  key_mme_group_id;
    RRM_MEMSET(&key_mme_group_id, RRM_ZERO, sizeof(rrm_global_mme_group_id_key_t));
    /*SPR 10329:fix end*/
    U8      count                                       = RRM_ZERO; 
    p_gu_group_id_list  = &(p_enb_id_node->gu_group_id_list);
    RRM_MEMCPY(&key_mme_group_id.plmn_id, &p_add_gu_id->plmn_id,sizeof(rrm_oam_cell_plmn_info_t));
    for(count=RRM_ZERO; count < RRM_MAX_MME_GRP_BYTES; count++)
    {
        key_mme_group_id.mme_group_id[count] =  p_add_gu_id->mme_group_id[count];
    }

    p_gu_group_id_node =  (rrm_gu_group_id_node_t *)
        ylFind(p_gu_group_id_list,
                &key_mme_group_id,
                rrmcm_gu_group_id_key,
                rrmcm_gu_group_id_data_key_compare);

    RRM_UT_TRACE_EXIT();
    return p_gu_group_id_node;
}

/************************************************************************
 * Function Name  : gu_group_id_key_compare_for_ncl
 * Inputs         : p_key1,
 *                : p_key2
 * Outputs        : None
 * Returns        : node of gu_group id
 * Description    : compares gu group Id present in NCL and  UE context
 **************************************************************************/

int gu_group_id_key_compare_for_ncl
(
 const rrm_void_t *p_key1,
 const rrm_void_t *p_key2
 )
{
    if (!RRM_MEMCMP((rrm_gu_group_id_t *)p_key1, (rrm_gu_group_id_t *)p_key2,
                sizeof(rrm_gu_group_id_t)))
    {
        return (RRM_FAILURE);
    }
    else
    {
        return (RRM_SUCCESS);
    }

}

/************************************************************************
 * Function Name  : find_gu_group_id_in_ncl_list
 * Inputs         : p_gu_group_id_list,
 *                : p_gu_group_id
 * Outputs        : None
 * Returns        : node of gu_group id
 * Description    : search gu_group_id 
 **************************************************************************/

rrm_gu_group_id_node_t *
find_gu_group_id_in_ncl_list
(
 rrm_gu_group_id_list_t *p_gu_group_id_list,
 rrm_gu_group_id_t  *p_gu_group_id

 )
{
    RRM_UT_TRACE_ENTER();
    rrm_gu_group_id_node_t    *p_gu_group_id_node       = RRM_PNULL;
    /*CID 65864:delete*/
    p_gu_group_id_node = (rrm_gu_group_id_node_t *)
        ylFind(p_gu_group_id_list,
                p_gu_group_id,
                rrmcm_gu_group_id_key,
                gu_group_id_key_compare_for_ncl); 
    RRM_UT_TRACE_EXIT();
    return p_gu_group_id_node;
}

/************************************************************************
 * Function Name  : rrmcm_enb_group_id_key 
 * Inputs         : p_ylnode
 * Outputs        : None
 * Returns        : enb_key_id
 * Description    : returns enb_key_id  
 **************************************************************************/
const void *
rrmcm_enb_group_id_key
(
 const YLNODE    *p_ylnode
 )
{
    return  &(((rrm_enb_gu_group_id_node_t *)p_ylnode)->enb_key_id);
}

/************************************************************************
 * Function Name  : search_enb_id_in_global_list
 * Inputs         : p_add_gu_id,
 * Outputs        : NONE
 * Returns        : node of gu_group id
 * Description    : returns eNb Id 
 **************************************************************************/
rrm_enb_gu_group_id_node_t *
search_enb_id_in_global_list
(
 rrm_global_enb_id_t  *p_enb_id
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_enb_gu_group_id_list_t       *p_enb_gu_group_id_list = RRM_PNULL;
    rrm_enb_gu_group_id_node_t       *p_enb_gu_group_id_node = RRM_PNULL;
    rrm_global_enb_id_key_t          key_enb_id;
    U8                               count                   = RRM_ZERO;        
    p_enb_gu_group_id_list  = &(p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
    RRM_MEMSET(&key_enb_id, RRM_ZERO, sizeof(rrm_global_enb_id_key_t));
    key_enb_id.enb_type = p_enb_id->enb_type;
    RRM_MEMCPY(&key_enb_id.plmn_id, &p_enb_id->plmn_id,sizeof(rrm_oam_cell_plmn_info_t));
    for(count=RRM_ZERO; count < HOME_ENB_ID_OCTET_SIZE; count++)
    {
        key_enb_id.eNb_id[count] =  p_enb_id->eNb_id[count];
    }
    p_enb_gu_group_id_node =  (rrm_enb_gu_group_id_node_t *)
        ylFind(p_enb_gu_group_id_list,
                &key_enb_id,
                rrmcm_enb_group_id_key,
                rrmcm_enb_id_data_key_compare);

    RRM_UT_TRACE_EXIT();
    return p_enb_gu_group_id_node;
}



/************************************************************************
 * Function Name  : add_gu_group_id_to_global_list 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : add gu_group Id
 **************************************************************************/
rrm_return_et
add_gu_group_id_to_global_list
(
 rrm_gu_group_id_t             *p_add_gu_id,
 rrm_enb_gu_group_id_node_t     *p_enb_gu_group_id_node
 )
{
    rrm_gu_group_id_node_t      *p_rrm_gu_group_id_node     = RRM_PNULL;
    rrm_gu_group_id_list_t      *p_rrm_gu_group_id_list     = RRM_PNULL;
    U8 count                                                = RRM_ZERO;
    rrm_return_et       ret_val                             = RRM_FAILURE;
    RRM_UT_TRACE_ENTER();

    p_rrm_gu_group_id_list = &(p_enb_gu_group_id_node->gu_group_id_list); 
    p_rrm_gu_group_id_node = (rrm_gu_group_id_node_t*)rrm_mem_get( sizeof(rrm_gu_group_id_node_t) );

    if( RRM_NULL != p_rrm_gu_group_id_node )
    {
        RRM_MEMCPY(&(p_rrm_gu_group_id_node->mme_group_id_key.plmn_id), &(p_add_gu_id->plmn_id),sizeof(rrm_oam_cell_plmn_info_t));
        for(count=RRM_ZERO; count < RRM_MAX_MME_GRP_BYTES; count++)
        {
            p_rrm_gu_group_id_node->mme_group_id_key.mme_group_id[count] =  p_add_gu_id->mme_group_id[count];
        }
        ylPushTail( p_rrm_gu_group_id_list ,&( p_rrm_gu_group_id_node->s_node ) );
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation failed for gu_group_id_node_t ");
    } 

    RRM_UT_TRACE_EXIT();
    return ret_val;

}


/************************************************************************
 * Function Name  : add_enb_id_to_global_list 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Add eNb id
 **************************************************************************/
rrm_enb_gu_group_id_node_t *
add_enb_id_to_global_list
(
 rrm_global_enb_id_t *p_enb_gu_group_id
 )
{
    rrm_enb_gu_group_id_node_t      *p_enb_gu_group_id_node = RRM_PNULL;
    rrm_enb_gu_group_id_list_t      *p_enb_gu_group_id_list = RRM_PNULL;
    RRM_UT_TRACE_ENTER();
    
    p_enb_gu_group_id_list =  &(p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
    p_enb_gu_group_id_node  = (rrm_enb_gu_group_id_node_t*)rrm_mem_get( sizeof(rrm_enb_gu_group_id_node_t) );

    if( RRM_NULL != p_enb_gu_group_id_node )
    {
        /*SPR 10329:fix:start*/
        RRM_MEMCPY(&p_enb_gu_group_id_node->enb_key_id, p_enb_gu_group_id,sizeof(rrm_global_enb_id_t));
        /*SPR 10329:fix:end*/
        /* Initialising the rrm_gu_group_id_list_t */
        ylInit(&(p_enb_gu_group_id_node->gu_group_id_list));
        ylPushTail( p_enb_gu_group_id_list ,&( p_enb_gu_group_id_node->s_node ) );
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation failed for rrm_enb_gu_group_id_node_t ");
    }

    RRM_UT_TRACE_EXIT();
    return p_enb_gu_group_id_node;
}

/************************************************************************
 * Function Name  : rrm_fill_gu_group_id_failure_list 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : fills the failure list
 **************************************************************************/
rrm_void_t
rrm_fill_gu_group_id_failure_list
(
 rrm_enb_gu_group_id_success_failure_list_t *p_enb_gu_group_id_success_failure_list, 
 rrm_oam_enb_gu_group_id_t  *p_enb_gu_group_id,
 rrm_oam_gu_group_id_t      *p_gu_group_id,
 U8                         failure_list_count
 )
{
    
    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(&(p_enb_gu_group_id_success_failure_list->enb_id),&(p_enb_gu_group_id->enb_id),sizeof(rrm_global_enb_id_t));
    RRM_MEMCPY(&(p_enb_gu_group_id_success_failure_list->failure_gu_id[failure_list_count]), 
            p_gu_group_id,sizeof(rrm_oam_gu_group_id_t));
    
    p_enb_gu_group_id_success_failure_list->failure_list_count ++;

    RRM_UT_TRACE_EXIT();
}


/************************************************************************
 * Function Name  : rrm_fill_gu_group_id_success_list 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : fills the success list
 **************************************************************************/
rrm_void_t
rrm_fill_gu_group_id_success_list
(
 rrm_enb_gu_group_id_success_failure_list_t *p_enb_gu_group_id_success_failure_list, 
 rrm_oam_enb_gu_group_id_t  *p_enb_gu_group_id,
 rrm_oam_gu_group_id_t      *p_gu_group_id,
 U8                         success_list_count

 )
{
    
    RRM_UT_TRACE_ENTER();


    RRM_MEMCPY(&(p_enb_gu_group_id_success_failure_list->enb_id),&(p_enb_gu_group_id->enb_id),sizeof(rrm_global_enb_id_t));
    /*SPR 10329:fix start*/
    RRM_MEMCPY(&(p_enb_gu_group_id_success_failure_list->success_gu_id[success_list_count]), 
            (p_gu_group_id),sizeof(rrm_oam_gu_group_id_t));
    /*SPR 10329:fix end*/
    
    p_enb_gu_group_id_success_failure_list->success_list_count ++;

    RRM_UT_TRACE_EXIT();
}
/************************************************************************
 * Function Name  : updating_enb_id_node_in_ncl_info 
 * Inputs         : p_enb_id_node
 * Outputs        : None
 * Returns        : NONE
 * Description    : updates enb_id node in ncl_info
 **************************************************************************/

rrm_void_t
updating_enb_id_node_in_ncl_info
(
 rrm_enb_gu_group_id_node_t    *p_enb_id_node,
 rrm_bool_et    node_deleted
 )
{
    U8      index = RRM_ZERO;
    U8      inter_count = RRM_ZERO;
    U8      intra_count = RRM_ZERO;
    U32     cell_id = RRM_ZERO;
    U32     cell_id_in_ncl = RRM_ZERO;
    U32     cell_id_stored_in_enb = RRM_ZERO;
    U32     cell_id_copied_from_enbid = RRM_ZERO;

    RRM_UT_TRACE_ENTER();   

    for (index = RRM_ZERO; index < RRM_MAX_NUM_CELLS; index++)
    {
        /*SPR 10329:fix start*/
        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[index])
        {
            /*SPR 10329:fix end*/
            /* Klocwork_fix_27_aug_start */
            for (intra_count = RRM_ZERO;(intra_count < p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                    ncl_params.lte_ncl.num_valid_intra_freq_cell) && (intra_count < MAX_INTRA_FREQ_CELLS); intra_count++)
            /* Klocwork_fix_27_aug_end */
            {
                if(RRM_ZERO == (RRM_MEMCMP(&p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                intra_freq_cells[intra_count].cell_id.primary_plmn_id, &p_enb_id_node->enb_key_id.plmn_id ,
                                sizeof(rrm_oam_cell_plmn_info_t))))
                {
                    RRM_MEMCPY(&cell_id, p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                            intra_freq_cells[intra_count].cell_id.cell_identity, RRM_FOUR);
                    cell_id_in_ncl = RRM_NTOHL(cell_id);

                    RRM_MEMCPY(&cell_id_copied_from_enbid,p_enb_id_node->enb_key_id.eNb_id, RRM_FOUR);
                    cell_id_stored_in_enb = RRM_NTOHL(cell_id_copied_from_enbid) ;  
                    /*SPR 10329:fix start*/
                    if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.intra_freq_cells[intra_count].\
                            bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT)
                    {
                        if(RRM_OAM_ACCESS_MODE_OPEN == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                intra_freq_cells[intra_count].cell_access_mode)
                        {
                            cell_id_in_ncl =  cell_id_in_ncl >> RRM_TWELVE;
                            cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_TWELVE;
                            if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "cell access mode = [%u], pci = [%u], earfcn = [%u] cell_id matched with enb_id ",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.intra_freq_cells[intra_count].\
                                        cell_access_mode, p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].phy_cell_id,p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                                        rf_params.rf_configurations.dl_earfcn
                                        );

                                if (RRM_FALSE == node_deleted)
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].p_enb_gu_group_id = p_enb_id_node ;
                                }
                                else
                                {

                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].p_enb_gu_group_id = RRM_PNULL ;
                                }
                                /*SPR 21908 Start*/
                                /*CODE DELETED SINCE RRM IN UNABLE TO FILL gu group ID for rest of neighbor's*/
                                /*SPR 21908 End*/
                                /* SPR_22194 Fix - Start */
                                /* Code Deleted */
                                /* SPR_22194 Fix - End */
                            }
                        }
                        else
                        {
                            cell_id_in_ncl =  cell_id_in_ncl >> RRM_FOUR;
                            cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_FOUR;
                            if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "cell access mode = [%u], pci = [%u], earfcn = [%u] cell_id matched with enb_id ",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.intra_freq_cells[intra_count].\
                                        cell_access_mode,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].phy_cell_id,p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                                        rf_params.rf_configurations.dl_earfcn
                                        );
                                if (RRM_FALSE == node_deleted)
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].p_enb_gu_group_id = p_enb_id_node ;
                                }
                                else
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        intra_freq_cells[intra_count].p_enb_gu_group_id = RRM_PNULL ;
                                }
                                /*SPR 21908 Start*/
                                /*CODE DELETED SINCE RRM IN UNABLE TO FILL gu group ID for rest of neighbor's*/
                                /*SPR 21908 End*/
                                /* SPR_22194 Fix - Start */
                                /* Code Deleted */
                                /* SPR_22194 Fix - End */
                            }
                        }
                    }
                    /*SPR 10329:fix end*/
                }
            }
            /*SPR 16494 START*/
            if(intra_count == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell)
            {
                /*SPR 16494 END*/
            /* Klocwork_fix_27_aug_start */
            for(inter_count = RRM_ZERO; (inter_count < p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                    ncl_params.lte_ncl.num_valid_inter_freq_cell) && (inter_count < MAX_INTER_FREQ_CELLS); inter_count++)
            /* Klocwork_fix_27_aug_end */
            {
                if(RRM_ZERO == (RRM_MEMCMP(&p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                inter_freq_cells[inter_count].cell_id.primary_plmn_id, &p_enb_id_node->enb_key_id.plmn_id ,
                                sizeof(rrm_oam_cell_plmn_info_t))))
                {
                    RRM_MEMCPY(&cell_id, p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                            inter_freq_cells[inter_count].cell_id.cell_identity, RRM_FOUR);
                    cell_id_in_ncl = RRM_NTOHL(cell_id);

                    RRM_MEMCPY(&cell_id_copied_from_enbid,p_enb_id_node->enb_key_id.eNb_id, RRM_FOUR);
                    cell_id_stored_in_enb = RRM_NTOHL(cell_id_copied_from_enbid) ;  
                    /*SPR 10329:fix start*/
                    if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                        inter_freq_cells[inter_count].bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT)
                    {
                        /* SPR_15636_Fix: Start */
                        /*SPR 16494 START*/
                        if((RRM_OAM_ACCESS_MODE_OPEN == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                inter_freq_cells[inter_count].cell_access_mode))
                        /*SPR 16494 END*/
                        /* SPR_15636_Fix: End */
                        {
                            cell_id_in_ncl =  cell_id_in_ncl >> RRM_TWELVE;
                            cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_TWELVE;
                            if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))
                            {
                                /* SPR_15636_Fix: Start */
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "cell access mode = [%d], pci = [%d], earfcn = [%d] cell_id matched with enb_id ",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_count].\
                                        cell_access_mode, 
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].phy_cell_id,p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                                        ncl_params.lte_ncl.inter_freq_cells[inter_count].eutra_carrier_arfcn
                                        );
                                /* SPR_15636_Fix: End */

                                if (RRM_FALSE == node_deleted)
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].p_enb_gu_group_id = p_enb_id_node ;
                                }
                                else
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].p_enb_gu_group_id = RRM_PNULL ;
                                }
                                /*SPR 21908 Start*/
                                /*CODE DELETED SINCE RRM IN UNABLE TO FILL gu group ID for rest of neighbor's*/
                                /*SPR 21908 End*/
                                /* SPR_22194 Fix - Start */
                                /* Code Deleted */
                                /* SPR_22194 Fix - End */
                            }
                        }
                        /*SPR 16494 START*/
                        /*code deleted*/
                        else
                        /*SPR 16494 END*/
                        {
                            cell_id_in_ncl =  cell_id_in_ncl >> RRM_FOUR;
                            cell_id_stored_in_enb = cell_id_stored_in_enb >> RRM_FOUR;
                            if (RRM_ZERO == (cell_id_in_ncl ^ cell_id_stored_in_enb))

                            {
                                /* SPR_15636_Fix: Start */
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "cell access mode = [%d], pci = [%d], earfcn = [%d] cell_id matched with enb_id ",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.inter_freq_cells[inter_count].\
                                        cell_access_mode, 
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].phy_cell_id,p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.\
                                        ncl_params.lte_ncl.inter_freq_cells[inter_count].eutra_carrier_arfcn
                                        );
                                /* SPR_15636_Fix: End */

                                if (RRM_FALSE == node_deleted)
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].p_enb_gu_group_id = p_enb_id_node ;
                                }
                                else
                                {
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.ncl_params.lte_ncl.\
                                        inter_freq_cells[inter_count].p_enb_gu_group_id = RRM_PNULL ;
                                }
                                /*SPR 21908 Start*/
                                /*CODE DELETED SINCE RRM IN UNABLE TO FILL gu group ID for rest of neighbor's*/
                                /*SPR 21908 End*/
                                /* SPR_22194 Fix - Start */
                                /* Code Deleted */
                                /* SPR_22194 Fix - End */
                            }
                        }
                    }
                    /*SPR 10329:fix end*/
                }
            }
            /*SPR 16494 START*/
          }
          /*SPR 16494 END*/
        }
    }

    RRM_UT_TRACE_EXIT();
}


/*SPR 10329:end*/

/* Carrier_Aggregation_Start */
/************************************************************************
 * Function Name  : rrm_cellm_enb_config_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the enb config request to rrm
 **************************************************************************/
rrm_return_et
rrm_cellm_enb_config_req_process_msg
(

		void *p_api    /*pointer to api buffer*/
            /*SPR 17777 +-*/
)
{   
    /*SPR 10329:fix start*/
    rrm_return_et ret_val                                      = RRM_FAILURE;
    /*SPR 10329:fix end*/
    rrmcm_rmif_enb_config_req_t *p_rrmcm_rmif_enb_config_req   = RRM_PNULL;
    /*SPR 10329:start*/
    rrmcm_rmif_enb_config_resp_t *p_rrmcm_rmif_enb_config_resp   = RRM_PNULL;
    U8    enb_count                                              = RRM_ZERO;
    U8 resp_count = RRM_ZERO;
    U8 count = RRM_ZERO;
    U8    failure_count                                          = RRM_ZERO;
    U8    success_count                                          = RRM_ZERO;
    U8    mme_id_add_count                                       = RRM_ZERO;
    U8    mme_id_delete_count                                    = RRM_ZERO;
    U8    gu_group_info_count                                    = RRM_ZERO;
    /* Coverity Fix 99677 Start */ 
    U16    fail_cause_type                                        = RRM_ZERO;
    /* Coverity Fix 99677 End */
    rrm_error_et    fail_cause                                   = RRM_NO_ERROR;
    rrm_enb_gu_group_id_node_t    *p_enb_id_node                 = RRM_PNULL; 
    rrm_gu_group_id_node_t    *p_gu_group_id_node                = RRM_PNULL;
    rrm_gu_group_id_list_t    *p_gu_group_id_list                = RRM_PNULL;
    /*Coverity 66673 Fix Start */
    rrm_gu_group_info_success_failure_list_t     *p_gu_group_response_list      = RRM_PNULL;
    p_gu_group_response_list = (rrm_gu_group_info_success_failure_list_t *)rrm_mem_get(
			sizeof(rrm_gu_group_info_success_failure_list_t));
    if (p_gu_group_response_list == RRM_PNULL)
    {
       /* SPR 21251 Start */     
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "Memory allocation to p_gu_group_response_list failed");
        /* SPR 21251 End */
       /* CID 108853 fix Start */
       //rrm_abort();
       RRM_UT_TRACE_EXIT();
       return RRM_FAILURE;
       /* CID 108853 fix Stop */

    }
    RRM_MEMSET(p_gu_group_response_list, RRM_ZERO, sizeof(rrm_global_context_t));
  /*Coverity 66673 Fix End */

    rrm_enb_gu_group_id_list_t    *p_enb_gu_group_id_list                       = RRM_PNULL;
    p_enb_gu_group_id_list = &(p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);

    /*SPR 10329:end*/


    RRM_UT_TRACE_ENTER();
    p_rrmcm_rmif_enb_config_req = (rrmcm_rmif_enb_config_req_t *)p_api;
    /*SPR 10329:fix start*/ 
    p_rrmcm_rmif_enb_config_resp = (rrmcm_rmif_enb_config_resp_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_enb_config_resp_t));
    /*SPR 10329:fix end*/ 

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_ENB_CONFIG_REQ->CellM");
    /*CID 65767:start*/
    if (RRM_PNULL != p_rrmcm_rmif_enb_config_resp)
    {
        /*CID 65897:start*/
        RRM_MEMSET(p_rrmcm_rmif_enb_config_resp, RRM_ZERO, sizeof(rrmcm_rmif_enb_config_resp_t));
        /*CID 65897:end*/
        /* Storing eNodeB id in global context */
        if (RRMCM_RMIF_GLOBAL_ENB_ID_PRESENT & p_rrmcm_rmif_enb_config_req->bitmask)
        {
            p_g_rrm_cell_ctx->enb_context.bitmask |= RRM_GLOBAL_ENB_ID_PRESENT;
            RRM_MEMCPY(&p_g_rrm_cell_ctx->enb_context.enb_id,&p_rrmcm_rmif_enb_config_req->enb_id,
                    sizeof(rrm_global_enb_id_t));
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Recieved enb_id is 0x%x%x%x%x, enb_type is %d",p_g_rrm_cell_ctx->enb_context.enb_id.eNb_id[0],
                    p_g_rrm_cell_ctx->enb_context.enb_id.eNb_id[1],p_g_rrm_cell_ctx->enb_context.enb_id.eNb_id[2],
                    p_g_rrm_cell_ctx->enb_context.enb_id.eNb_id[3],p_g_rrm_cell_ctx->enb_context.enb_id.enb_type);
            /*SPR 10329:fix start*/
            ret_val = RRM_SUCCESS;
            /*SPR 10329:fix end*/
        }
        /*SPR 10329:start*/
#ifdef ENDC_ENABLED
/*NR_DC Code Change Start*/
        if (RRMCM_RMIF_QCI_FOR_SGNB_ADDITION_PRESENT & 
                p_rrmcm_rmif_enb_config_req->bitmask)
        {
            /*set bitmask*/
            p_g_rrm_cell_ctx->enb_context.bitmask |=
                RRM_QCI_FOR_SGNB_ADDITION_PRESENT;

            p_g_rrm_cell_ctx->enb_context.qci_for_sgnb_addition =
                p_rrmcm_rmif_enb_config_req->qci_for_sgnb_addition;

        }
/*NR_DC Code Change Stop*/
#endif
        if(RRMCM_RMIF_GU_GROUP_INFO_PRESENT & p_rrmcm_rmif_enb_config_req->bitmask)
        {
            if((p_rrmcm_rmif_enb_config_req->gu_group_info.bitmask) &&
                    (p_rrmcm_rmif_enb_config_req->gu_group_info.num_of_enb > RRM_ZERO)) 
            {
                for(enb_count = RRM_ZERO; ((enb_count < RRM_MAX_NO_OF_ENB_SUPPORTED) && 
                            (enb_count < p_rrmcm_rmif_enb_config_req->gu_group_info.num_of_enb)); enb_count ++)
                {

                    failure_count = RRM_ZERO;
                    success_count = RRM_ZERO;

                    /*1st node to be inserted in the list when the request is for adding MME GROUP ID*/
                    if((ylCount(p_enb_gu_group_id_list) == RRM_ZERO))  
                    {
                        if((p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count > RRM_ZERO))
                        {
                            p_enb_id_node  = add_enb_id_to_global_list(&(p_rrmcm_rmif_enb_config_req->gu_group_info.\
                                        gu_group_id_list_info[enb_count].enb_id) );
                            if(RRM_NULL != p_enb_id_node)
                            {
                                /*SPR 10329: fix start*/
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        " enb_id is added successfully to the list");
                                /*SPR 10329: fix end*/
                                /*Updating the NCL Enb pointer*/
                                updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);

                                /*adding gu group id to the enb list */
                                for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_rrmcm_rmif_enb_config_req->\
                                            gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count) &&
                                        (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                                {
                                    ret_val =  add_gu_group_id_to_global_list
                                        (
                                         &( p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                             gu_group_id_list_info[enb_count].add_gu_id[mme_id_add_count]),
                                         p_enb_id_node 
                                        );
                                    if(RRM_SUCCESS == ret_val)
                                    {
                                        /*SPR 10329: fix start*/
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                                "successfully added MME group id to the list");
                                        /*SPR 10329: fix end*/
                                        /*Coverity 65860 Fix Start*/
                                        rrm_fill_gu_group_id_success_list(&(p_gu_group_response_list->\
                                        /*Coverity 65860 Fix Start*/
                                                    gu_group_id_list_info[enb_count]),
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count],
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].add_gu_id[mme_id_add_count],
                                                success_count);
                                        success_count++;
                                    }
                                }
                            }

                        }
                        if(p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count > RRM_ZERO)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    " requested to delete gu_group id for an enb that does not exists");

                            fail_cause = RRM_ERR_ENB_NOT_FOUND;

                            for(mme_id_delete_count = RRM_ZERO; (mme_id_delete_count < p_rrmcm_rmif_enb_config_req->\
                                        gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count) &&
                                    (mme_id_delete_count < RRM_MME_MAX_POOLS) ; mme_id_delete_count++)
			    {
				    /*Coverity 65860 Fix Start*/
				    rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
							    /*Coverity 65860 Fix Start*/
							    gu_group_id_list_info[enb_count]),
						    &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
						    &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
						    delete_gu_id[mme_id_delete_count],failure_count); 
				    failure_count++;
			    }

                            if(fail_cause_type == RRM_ZERO)
                            {
                                fail_cause_type= fail_cause;
                            }
                            else
                            {
                                if(fail_cause_type != fail_cause)    
                                {
                                    fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID;
                                }
                            }

                        }
                        /*SPR 10329:fix start*/
                        if((p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count == RRM_ZERO)
                                /*SPR 10329:fix end*/
                                &&
                                (p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count == RRM_ZERO))
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "gu_group_info_list is empty");
                            fail_cause = RRM_ERR_ENB_GU_GROUP_ID_LIST_EMPTY;
                            gu_group_info_count ++;
                            if(fail_cause_type == RRM_ZERO)
                            {
                                fail_cause_type= fail_cause;
                            }
                            else
                            {
                                if(fail_cause_type != fail_cause)    
                                {
                                    fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID ;
                                }
                            }

                        }

                    }

                    else
                    {
                        /*searching enb_id's from the list present in global_context and
                          and returning the node after finding corresponding plmn_id and enb_id */
                        p_enb_id_node = search_enb_id_in_global_list(
                                &( p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].enb_id));
                        /*if requested eNB is not configured at RRM*/
                        if((RRM_PNULL == p_enb_id_node))
                        { 
                            if(p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count]. \
                                    num_gu_group_id_del_count > RRM_ZERO )
                            {

                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        " requested to delete gu_group id for an enb that does not exists");

                                for(mme_id_delete_count = RRM_ZERO; (mme_id_delete_count < p_rrmcm_rmif_enb_config_req->\
                                            gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count) &&
                                        (mme_id_delete_count < RRM_MME_MAX_POOLS) ; mme_id_delete_count++)
				{
					/*Coverity 65860 Fix Start*/
					rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
								/*Coverity 65860 Fix End*/
								gu_group_id_list_info[enb_count]),
							&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
							&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
							delete_gu_id[mme_id_delete_count],failure_count); 

					failure_count++;
				}

                                fail_cause = RRM_ERR_ENB_NOT_FOUND;

                                if(fail_cause_type == RRM_ZERO)
                                {
                                    fail_cause_type= fail_cause;
                                }
                                else
                                {
                                    if(fail_cause_type != fail_cause)    
                                    {
                                        fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID;
                                    }
                                }

                            }
                            if ((p_rrmcm_rmif_enb_config_req->gu_group_info.\
                                        gu_group_id_list_info[enb_count].num_gu_group_id_add_count > RRM_ZERO))
                            {
                                p_enb_id_node = add_enb_id_to_global_list(&(p_rrmcm_rmif_enb_config_req->gu_group_info.\
                                            gu_group_id_list_info[enb_count].enb_id) );
                                if(RRM_NULL != p_enb_id_node)
                                {
                                    /*Updating the NCL Enb pointer*/
                                    updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);

                                    for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_rrmcm_rmif_enb_config_req->\
                                                gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count) &&
                                            (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                                    {
                                        ret_val =  add_gu_group_id_to_global_list
                                            (
                                             &( p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                                 gu_group_id_list_info[enb_count].add_gu_id[mme_id_add_count]),
                                             p_enb_id_node 
                                            );
                                        if(RRM_SUCCESS == ret_val)
					{

						/*Coverity 65860 Fix Start*/
						rrm_fill_gu_group_id_success_list(&(p_gu_group_response_list->\
									/*Coverity 65860 Fix End*/
									gu_group_id_list_info[enb_count]),
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
								add_gu_id[mme_id_add_count],success_count);
						success_count++;
					}
                                    }

                                }


                            }

                            if((p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count == RRM_ZERO)
                                    &&
                                    (p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count == RRM_ZERO))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "gu_group_info_list is empty");
                                fail_cause = RRM_ERR_ENB_GU_GROUP_ID_LIST_EMPTY;
                                gu_group_info_count ++;
                                if(fail_cause_type == RRM_ZERO)
                                {
                                    fail_cause_type= fail_cause;
                                }
                                else
                                {
                                    if(fail_cause_type != fail_cause)    
                                    {
                                        fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID ;
                                    }
                                }

                            }


                        }
                        /*if requested eNb is configured at RRM*/
                        else
                        {
                            if(p_rrmcm_rmif_enb_config_req->gu_group_info.
                                    gu_group_id_list_info[enb_count].num_gu_group_id_del_count > RRM_ZERO)
                            {
                                /* Klocwork_fix_27_aug_start */
                                for(mme_id_delete_count = RRM_ZERO; 
                                        (mme_id_delete_count < p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                        gu_group_id_list_info[enb_count].num_gu_group_id_del_count)
                                        && (mme_id_delete_count < RRM_MME_MAX_POOLS); 
                                        mme_id_delete_count++ )
                                /* Klocwork_fix_27_aug_end */
                                {
                                    if(p_enb_id_node != RRM_NULL)
                                    {
                                        p_gu_group_id_node = search_gu_group_id_from_list(
                                                &( p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                                    gu_group_id_list_info[enb_count].delete_gu_id[mme_id_delete_count]),
                                                p_enb_id_node
                                                );

                                        if(RRM_PNULL != p_gu_group_id_node )
					{
						/*Coverity 65860 Fix Start*/
						rrm_fill_gu_group_id_success_list(&(p_gu_group_response_list->\
									/*Coverity 65860 Fix End*/
									gu_group_id_list_info[enb_count]),
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
								delete_gu_id[mme_id_delete_count],success_count);
						success_count++;
						/*SPR 10329:fix start*/
						p_gu_group_id_list = &(p_enb_id_node->gu_group_id_list);
						/*SPR 10329:fix end*/
						ylDelete(p_gu_group_id_list, &p_gu_group_id_node->s_node);

						RRM_MEM_FREE(p_gu_group_id_node);
						/*Updating the NCL Enb pointer*/
						if(RRM_NULL != p_enb_id_node)
						{
							if(ylCount(p_gu_group_id_list) == RRM_ZERO)
							{
								updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_TRUE);
								ylDelete(p_enb_gu_group_id_list, &p_enb_id_node->s_node);

								RRM_MEM_FREE(p_enb_id_node);

							}


						}

					}
                                        else
					{
						/*SPR 10329:fix start*/
						/*Coverity 65860 Fix Start*/
						rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
									/*Coverity 65860 Fix End*/
									gu_group_id_list_info[enb_count]),
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
								delete_gu_id[mme_id_delete_count],failure_count); 

						failure_count ++;
						fail_cause= RRM_ERR_GU_GROUP_INFO_INVALID;

						if(fail_cause_type == RRM_ZERO)
						{
							fail_cause_type= fail_cause;
						}
						else
						{
							if(fail_cause_type != fail_cause)    
							{
								fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID ;
							}
						}
					}

					/*SPR 10329:fix end*/
				    }
                                    else
                                    {
                                        /*Coverity 65860 Fix Start*/
                                        rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
                                        /*Coverity 65860 Fix End*/
                                                    gu_group_id_list_info[enb_count]),
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
                                                delete_gu_id[mme_id_delete_count],failure_count); 

                                        failure_count ++;
                                    }

                                }
                            }

                            if(p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count]. \
                                    num_gu_group_id_add_count > RRM_ZERO)
                            {
                                for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_rrmcm_rmif_enb_config_req->\
                                            gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count) &&
                                        (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                                {
                                    /*search gu_group_id and if found returns the node */
                                    p_gu_group_id_node = search_gu_group_id_from_list
                                        (
                                         &(p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                             gu_group_id_list_info[enb_count].\
                                             add_gu_id[mme_id_add_count]),
                                         p_enb_id_node  
                                        );
                                    if(RRM_PNULL != p_gu_group_id_node)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                "failure:request to add gu_group_id that has been already present in the list");
                                        /*filling failure list*/
                                        rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
                                                    gu_group_id_list_info[enb_count]),
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count], 
                                                &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
                                                add_gu_id[mme_id_add_count],failure_count); 

                                        failure_count ++;

                                    }
                                    else
                                    {
                                        /*SPR 10329:fix start*/

                                        p_gu_group_id_list = &(p_enb_id_node->gu_group_id_list);
                                        /*SPR 10329:fix end*/
                                        if(ylCount(p_gu_group_id_list) < RRM_MME_MAX_POOLS )
                                        {
                                            ret_val =  add_gu_group_id_to_global_list
                                                (
                                                 &( p_rrmcm_rmif_enb_config_req->gu_group_info. \
                                                     gu_group_id_list_info[enb_count].add_gu_id[mme_id_add_count]),
                                                 p_enb_id_node 
                                                );
                                            if(RRM_SUCCESS == ret_val)
					    {
						    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
								    "successfully added gu group id to the list");

						    /*Coverity 65860 Fix Start*/
						    rrm_fill_gu_group_id_success_list(&(p_gu_group_response_list->\
									    /*Coverity 65860 Fix End*/
									    gu_group_id_list_info[enb_count]),
								    &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count],
								    &p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
								    add_gu_id[mme_id_add_count],success_count);
						    success_count++;
					    }

                                        }
                                        else
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
								" maximum limit to add gu_group_id has been reached to 16 for gu_group_id"); 
						/*Coverity 65860 Fix Start*/
						rrm_fill_gu_group_id_failure_list(&(p_gu_group_response_list->\
									/*Coverity 65860 Fix End*/
									gu_group_id_list_info[enb_count]),
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count],
								&p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].\
								add_gu_id[mme_id_add_count],failure_count);

						failure_count ++;        

						fail_cause = RRM_ERR_GU_GROUP_ID_LIMIT_REACHED;
						if(fail_cause_type == RRM_ZERO)
						{
							fail_cause_type= fail_cause;
						}
						else
						{
							if(fail_cause_type != fail_cause)    
							{
								fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID ;
							}
						}

					}

                                    }
                                }

                            }
                            if((p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_add_count == RRM_ZERO)
                                    &&
                                    (p_rrmcm_rmif_enb_config_req->gu_group_info.gu_group_id_list_info[enb_count].num_gu_group_id_del_count == RRM_ZERO))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "gu_group_info_list is empty");
                                fail_cause = RRM_ERR_ENB_GU_GROUP_ID_LIST_EMPTY;
                                gu_group_info_count ++;
                                if(fail_cause_type == RRM_ZERO)
                                {
                                    fail_cause_type= fail_cause;
                                }
                                else
                                {
                                    if(fail_cause_type != fail_cause)    
                                    {
                                        fail_cause = RRM_ERR_GU_GROUP_INFO_INVALID ;
                                    }
                                }

                            }

                        }
                    }
                }

                if(gu_group_info_count != p_rrmcm_rmif_enb_config_req->gu_group_info.num_of_enb)
                {
                    /*filling failure and success lists*/
                    /* Klocwork_fix_27_aug_start */
                    for(enb_count = RRM_ZERO; ((enb_count < RRM_MAX_NO_OF_ENB_SUPPORTED) && 
                                (enb_count < p_rrmcm_rmif_enb_config_req->gu_group_info.num_of_enb) &&
                                (resp_count < RRM_MAX_NO_OF_ENB_SUPPORTED)); enb_count ++)
                    /* Klocwork_fix_27_aug_end */
                    {
			    /*Coverity 65860 Fix Start*/
			    if((RRM_ZERO != p_gu_group_response_list->gu_group_id_list_info[enb_count].success_list_count)   
					    && (RRM_ZERO != p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count))
			    {
				    /*SPR 10329:fix start*/
				    RRM_MEMCPY(&p_gu_group_response_list->gu_group_id_list_info[resp_count].enb_id,
						    &p_gu_group_response_list->gu_group_id_list_info[enb_count].enb_id,
						    sizeof(rrm_global_enb_id_t));
				    /*SPR 10329:fix end*/
				    for(count = RRM_ZERO; count < RRM_MME_ADD_DELETE_COUNT && 
						    count < p_gu_group_response_list->gu_group_id_list_info[enb_count].success_list_count; count++)
				    {
					    RRM_MEMCPY(&p_gu_group_response_list->gu_group_id_list_info[resp_count].success_gu_id[count], 
							    &p_gu_group_response_list->gu_group_id_list_info[enb_count].success_gu_id[count], sizeof(rrm_oam_gu_group_id_t));
				    }
				    for(count = RRM_ZERO; count < RRM_MME_ADD_DELETE_COUNT && 
						    count < p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count; count++)
				    {

					    RRM_MEMCPY(&p_gu_group_response_list->gu_group_id_list_info[resp_count].failure_gu_id[count],
							    &p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_gu_id[count], sizeof(rrm_oam_gu_group_id_t));
				    } 
				    /*SPR 10329:start*/
				    p_gu_group_response_list->gu_group_id_list_info[resp_count].failure_list_count = 
					    p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count;
				    p_gu_group_response_list->gu_group_id_list_info[resp_count].success_list_count = 
					    p_gu_group_response_list->gu_group_id_list_info[enb_count].success_list_count;
				    /*Coverity 65860 Fix End*/
				    /*SPR 10329:end*/
				    ret_val = RRM_PARTIAL_SUCCESS;
				    /*SPR 10329:start*/
				    resp_count ++;
				    /*SPR 10329:end*/
			    }

			    /*Coverity 65860 Fix Start*/
                        else if((RRM_ZERO != p_gu_group_response_list->gu_group_id_list_info[enb_count].success_list_count)
                                && (RRM_ZERO == p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count))
                        {
                            /*SPR 10329:fix start*/
                            p_gu_group_response_list->gu_group_id_list_info[enb_count].success_list_count = RRM_ZERO;
                            /*SPR 10329:fix end*/
                                        /*Coverity 65860 Fix End*/

                            if(ret_val != RRM_PARTIAL_SUCCESS && ret_val != RRM_FAILURE)
                            {
                                ret_val = RRM_SUCCESS;
                            }
                            else
                            {   
                                ret_val = RRM_PARTIAL_SUCCESS;
                            }
                        }
                        else
                        {
                            /*SPR 10329:start*/
                            /*Coverity 65860 Fix Start*/
                            RRM_MEMCPY(&p_gu_group_response_list->gu_group_id_list_info[resp_count].enb_id,
                                    &p_gu_group_response_list->gu_group_id_list_info[enb_count].enb_id,
                                    sizeof(rrm_global_enb_id_t));
                            p_gu_group_response_list->gu_group_id_list_info[resp_count].success_list_count = RRM_ZERO;

                            for(count = RRM_ZERO; count < RRM_MME_ADD_DELETE_COUNT && 
                                    count < p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count; count++)
                            {
                                RRM_MEMCPY(&p_gu_group_response_list->gu_group_id_list_info[resp_count].failure_gu_id[count],
                                        &p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_gu_id[count],sizeof(rrm_oam_gu_group_id_t));

                            }
                            p_gu_group_response_list->gu_group_id_list_info[resp_count].failure_list_count = 
                                p_gu_group_response_list->gu_group_id_list_info[enb_count].failure_list_count;
                                /*Coverity 65860 Fix End*/
                            ret_val = RRM_FAILURE;
                            resp_count ++;
                            /*SPR 10329:end*/
                        }
                    }
                }
                else
                {
                    ret_val = RRM_FAILURE;
                    /*SPR 10329:fix start*/
                    fail_cause = RRM_ERR_ENB_GU_GROUP_ID_LIST_EMPTY;
                    /*SPR 10329:fix end*/
                }

                if(ret_val == RRM_PARTIAL_SUCCESS || ret_val == RRM_FAILURE)
		{

			/*Coverity 65860 Fix Start*/
			p_gu_group_response_list->num_of_enb = resp_count;
			p_rrmcm_rmif_enb_config_resp->bitmask |= RRM_GU_GROUP_RESPONSE_LIST_PRESENT;
			RRM_MEMCPY(&p_rrmcm_rmif_enb_config_resp->gu_group_response_list,
					p_gu_group_response_list, sizeof(rrm_gu_group_info_success_failure_list_t));
			/*Coverity 65860 Fix End*/
		}

            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " no information for enb is received as enb list count is : [%d]",
                        p_rrmcm_rmif_enb_config_req->gu_group_info.num_of_enb);

                fail_cause = RRM_ERR_GU_GROUP_INFO_EMPTY;
                ret_val = RRM_FAILURE;

            } 

        }
        /*CID 65767:delete*/

        p_rrmcm_rmif_enb_config_resp->response = ret_val;
        p_rrmcm_rmif_enb_config_resp->fail_cause = fail_cause;
        p_rrmcm_rmif_enb_config_resp->transaction_id = p_rrmcm_rmif_enb_config_req->transaction_id;
        /*sending response to MIF*/
        ret_val = rrm_send_internal_msg(
                RRM_MIF_MODULE_ID,
                RRMCM_RMIF_ENB_CONFIG_RESP,
                sizeof(rrmcm_rmif_enb_config_resp_t),
                (void *)p_rrmcm_rmif_enb_config_resp);
        if(ret_val == RRM_SUCCESS)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "successfully send enb config resp to mif");

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failed to send enb config resp to mif");

        }
        RRM_MEM_FREE(p_rrmcm_rmif_enb_config_resp); 

    }
    /*CID 65767:end*/
    /*Coverity 65860 Fix Start*/
    RRM_MEM_FREE(p_gu_group_response_list); 
    /*Coverity 65860 Fix End*/
    /*SPR 10329:end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* Carrier_Aggregation_End */

/************************************************************************
 * Function Name  : rrm_cellm_process_cell_start_adm_req_for_cell_unblock
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_unblock_req to cell rrm
 **************************************************************************/
rrm_return_et
rrm_cellm_process_cell_start_adm_req_for_cell_unblock(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{
    rrm_cell_index_t cell_index = RRM_ZERO;             
	rrm_return_et ret_val = RRM_SUCCESS;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *rrmcm_rmif_cell_start_adm_req_for_cell_unblock = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_start_adm_req_for_cell_unblock =
		(rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *)p_api;
	cell_index = rrmcm_rmif_cell_start_adm_req_for_cell_unblock->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
			RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK; 

		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
			((rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t *)p_api)->transaction_id;
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_START_ADMISSION_REQ_FOR_CELL_UNBLOCK_EVENT, 
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
		}
		else
		{
			ret_val = RRM_SUCCESS;
		}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix__start*/
/************************************************************************
 * Function Name  : rrm_cellm_process_cell_cell_block 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_block_req to cell rrm
 **************************************************************************/
rrm_return_et
rrm_cellm_process_cell_cell_block(rrm_cell_index_t cell_index ,
            /*SPR 17777 +-*/
                                  void             *p_api     ,
                                  U16              api_id)
{
    rrm_return_et ret_value = RRM_SUCCESS;
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
			RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK;  
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
			((rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *)p_api)->transaction_id;
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_STOP_ADMISSION_REQ_FOR_CELL_BLOCK_EVENT,
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
			ret_value = RRM_FAILURE;
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Successfully process api id %d in fsm",api_id);
			ret_value = RRM_SUCCESS;
        }
    
    RRM_UT_TRACE_EXIT();
    return ret_value;
}
/*Klockwork_fix_end*/

/************************************************************************
 * Function Name  : rrm_cellm_process_cell_stop_adm_req_for_cell_block
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_block_req to cell rrm
 **************************************************************************/

rrm_return_et
rrm_cellm_process_cell_stop_adm_req_for_cell_block(

		void *p_api,/*pointer to api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{                
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *rrmcm_rmif_cell_stop_adm_req_for_cell_block = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_stop_adm_req_for_cell_block =
		(rrmcm_rmif_cell_stop_adm_req_for_cell_block_t *)p_api;
	cell_index = rrmcm_rmif_cell_stop_adm_req_for_cell_block->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"cell context is null For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
    /*Klockwork_fix_start*/
            /*SPR 17777 +-*/
    ret_val = rrm_cellm_process_cell_cell_block(cell_index ,p_api ,api_id);
    /*Klockwork_fix_end*/
    /*De allocate trans_id */
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
 /*Klockwork_fix_start*/
/************************************************************************
 * Function Name  : rrm_cellm_cell_stop_process
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 **************************************************************************/
/*spr_fix_start_12668*/
rrm_return_et
rrm_cellm_cell_stop_process(rrm_cell_index_t    cell_index ,
                            void                *p_api ,
                            U16                 api_id )
/*spr_fix_end_12668*/
{
    rrm_return_et ret_value = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
        RRMCM_RMIF_CELL_STOP_ADMISSION_REQ;  
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
        ((rrmcm_rmif_cell_stop_adm_req_t *)p_api)->transaction_id;
    if (RRM_FAILURE == cellm_fsm_process_event (
                RRMCM_RMIF_STOP_ADMISSION_REQ_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
        ret_value = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, "Successfully process api id %d in fsm",api_id);
        ret_value = RRM_SUCCESS;
    }
    /* SPR 11681 Fix Start */
    /* Code deleted */
    /* SPR 11681 Fix End */

    RRM_UT_TRACE_EXIT();
    return ret_value;
}
/*Klockwork_fix_end*/
/************************************************************************
 * Function Name  : rrm_cellm_cell_stop_adm_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 **************************************************************************/

rrm_return_et
rrm_cellm_cell_stop_adm_req_process_msg(

		void *p_api,/*pointer to api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{                
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	rrmcm_rmif_cell_stop_adm_req_t *rrmcm_rmif_cell_stop_adm_req = RRM_PNULL;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->RRMCM_RMIF_CELL_STOP_ADMISSION_REQ->CellM");
	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_stop_adm_req =
		(rrmcm_rmif_cell_stop_adm_req_t *)p_api;
	/*21481:Need to check the cell index for which reconfig has come
	 */ 
	cell_index = rrmcm_rmif_cell_stop_adm_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Stop Adm Req For Cell Index :%d",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
	    /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"cell context is null For Cell Index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
    /*Klockwork_fix_start*/
    /*spr_fix_start_12668*/
    ret_val = rrm_cellm_cell_stop_process(cell_index, p_api, api_id);
    /*spr_fix_end_12668*/
    /*Klockwork_fix__end*/
/* SPR 11681 Fix Start */
   /* Code deleted */
    /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/************************************************************************
 * Function Name  : rrm_cellm_cell_start_adm_req_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_req to cell rrm
 **************************************************************************/
rrm_return_et
rrm_cellm_cell_start_adm_req_process_msg(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		)
{   rrm_cell_index_t cell_index = RRM_ZERO;             
	rrm_return_et ret_val = RRM_SUCCESS;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	rrmcm_rmif_cell_start_adm_req_t *rrmcm_rmif_cell_start_adm_req = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_start_adm_req =
		(rrmcm_rmif_cell_start_adm_req_t *)p_api;
	/*21481:Need to check the cell index for which reconfig has come
	 */ 
	cell_index = rrmcm_rmif_cell_start_adm_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->RRMCM_RMIF_CELL_START_ADMISSION_REQ->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context for found for cell index:%d",
                cell_index);
		return RRM_FAILURE;
	}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
			RRMCM_RMIF_CELL_START_ADMISSION_REQ; 

		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
			((rrmcm_rmif_cell_start_adm_req_t *)p_api)->transaction_id;
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_START_ADMISSION_REQ_EVENT, 
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
#ifdef RRM_UT_FLAG        
			RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.cell_switch_on_resp_F);
#endif        
			ret_val = RRM_FAILURE;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm",api_id);
		}
		else
		{
#ifdef RRM_UT_FLAG        
			RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.cell_switch_on_resp_S);
#endif        
			ret_val = RRM_SUCCESS;
		}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL; 
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_delete_req_process_msg
 * Inputs         : void *p_api : pointer to input API buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_gl_ctx   : pointer to cell global 
 *		  :			context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : handles cell_delete_req message in cell rrm
 ****************************************************************************/


rrm_return_et
rrm_cellm_cell_delete_req_process_msg(
		void *p_api, /*pointer to input API buffer*/
		U16 api_id /*Incoming API id*/
            /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrmcm_rmif_cell_delete_req_t *p_cell_del_req = RRM_PNULL;
	rrm_return_et ret_val = RRM_FAILURE;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_ENTER();

	p_cell_del_req = (rrmcm_rmif_cell_delete_req_t *)p_api;

	cell_index = p_cell_del_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"MIF->CellM:RRMCM_RMIF_CELL_DELETE_REQ:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context not found for cell index:%d",
                cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info  = (void *)p_api;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_proc_triggered = 
		CELLM_CELL_DEL_TRIGGERRED_EXTERNALLY; 
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =RRMCM_RMIF_CELL_DELETE_REQ; 
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
            ((rrmcm_rmif_cell_delete_req_t *)p_api)->transaction_id;
        /*SPR 21683 Start*/
        if(RRMCM_RMIF_INSTANCE_RESET_FLAG_PRESENT & p_cell_del_req->bitmask)
        {
        /*SPR 21683 End*/
	    /* SPR 21632 Start */
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->bitmask |= RRMCM_RMIF_INSTANCE_RESET_FLAG_PRESENT;
	    /* SPR 21632 End */
        }
        else
        {
            p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->bitmask=RRM_ZERO;
        }
        /* message processing to FSM
		 */
		if (RRM_FAILURE == cellm_fsm_process_event( 
					RRMCM_RMIF_CELL_DELETE_REQ_EVENT,
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR," Failed to process api_id:%d",api_id);
			ret_val = RRM_FAILURE;
		}else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED," Successfully processed api_id:%d",api_id);
			ret_val = RRM_SUCCESS;
		}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info  = RRM_PNULL;
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_init_cell_index
 * Inputs         : rrm_global_context_t *p_gl_ctx: 
 *                : pointer to cell global context
 * Outputs        : None
 * Returns        : void
 * Description    : Initializes cell index table
 ****************************************************************************/


rrm_void_t
rrm_init_cell_index(
		rrm_global_context_t *p_g_rrm_cell_ctx /*gloabl cell context*/
		)
{
	U8 max_no_cell=RRM_ZERO;
	U8 max_mcc_digit = RRM_ZERO;
	U8 max_mnc_digit = RRM_ZERO;
	U8 max_cell_id_octect = RRM_ZERO;

	RRM_UT_TRACE_ENTER();
	for(max_no_cell=RRM_ZERO; max_no_cell<RRM_MAX_NUM_CELLS; max_no_cell++)
	{
		for(max_mcc_digit=RRM_ZERO; max_mcc_digit<MAX_MCC_DIGITS; max_mcc_digit++)
		{
			p_g_rrm_cell_ctx->arr_rrm_global_cell_index[max_no_cell].
				global_cell_id.primary_plmn_id.mcc[max_mcc_digit] = RRM_ZERO;
		}
		p_g_rrm_cell_ctx->arr_rrm_global_cell_index[max_no_cell].
			global_cell_id.primary_plmn_id.num_mnc_digit = RRM_ZERO;

		for(max_mnc_digit=RRM_ZERO; max_mnc_digit<MAX_MNC_DIGITS; max_mnc_digit++)
		{
			p_g_rrm_cell_ctx->arr_rrm_global_cell_index[max_no_cell].
				global_cell_id.primary_plmn_id.mnc[max_mnc_digit] = RRM_ZERO;
		}
		for(max_cell_id_octect=RRM_ZERO; max_cell_id_octect<MAX_CELL_IDENTITY_OCTETS;
				max_cell_id_octect++)
		{
			p_g_rrm_cell_ctx->arr_rrm_global_cell_index[max_no_cell].
				global_cell_id.cell_identity[max_cell_id_octect] = RRM_ZERO;
		}
		p_g_rrm_cell_ctx->arr_rrm_global_cell_index[max_no_cell].
			cell_index = RRM_OUT_OF_RANGE;
	}

	RRM_UT_TRACE_EXIT();
}
const rrm_void_t *rrm_rsu_key_off_hash_controlling(const YHNODE *p_hNode)
{
	RRM_ASSERT(RRM_PNULL != p_hNode);
	rrm_rsu_meas_info_node_t *p_ctrl_node = RRM_PNULL;
	p_ctrl_node = (rrm_rsu_meas_info_node_t *)p_hNode;
	return ((const rrm_void_t *)&p_ctrl_node->rsu_id);
}
const rrm_void_t *rrm_rsu_key_off_hash_serving(const YHNODE *p_hNode)
{
	RRM_ASSERT(RRM_PNULL != p_hNode);
	rrm_rsu_meas_srv_cell_info_node_t *p_serv_node = RRM_PNULL;
	p_serv_node = (rrm_rsu_meas_srv_cell_info_node_t *)p_hNode;
	return ((const rrm_void_t *)&p_serv_node->rsu_id);
}

int rrm_rsu_compare_ctrl_hash(
		const rrm_void_t *p_val_1,
		const rrm_void_t *p_val_2)
{
	const rrm_cell_meas_gb_t *p_ser_1 = RRM_PNULL;
	const rrm_cell_meas_gb_t *p_ser_2 = RRM_PNULL;

	p_ser_1 =(rrm_cell_meas_gb_t *)p_val_1;
	p_ser_2 =(rrm_cell_meas_gb_t *)p_val_2;

	/* if ((p_ser_1->meas_serving_id == p_ser_2->meas_serving_id) &&
	   ( RRM_MEMCMP(&p_ser_1->g_enb_id, &p_ser_2->g_enb_id, sizeof(rrm_x2_gb_enb_id_t))))*/
	if (p_ser_1->meas_id == p_ser_2->meas_id)
	{
		return RRM_ZERO;
	}
	else
	{
		return RRM_ONE;
	}
}
int  rrm_rsu_compare_serv_hash(
		const rrm_void_t *p_val_1,
		const rrm_void_t *p_val_2)
{
	const rrm_cell_meas_gb_t *p_ser_1 = RRM_PNULL;
	const rrm_cell_meas_gb_t *p_ser_2 = RRM_PNULL;

	p_ser_1 =( rrm_cell_meas_gb_t *)p_val_1;
	p_ser_2 =( rrm_cell_meas_gb_t *)p_val_2;

	/* if ((p_ser_1->meas_serving_id == p_ser_2->meas_serving_id) &&
	   ( RRM_MEMCMP(&p_ser_1->g_enb_id, &p_ser_2->g_enb_id, sizeof(rrm_x2_gb_enb_id_t))))*/
	if (p_ser_1->meas_id == p_ser_2->meas_id)
	{
		return RRM_ZERO;
	}
	else
	{
		return RRM_ONE;
	}
}

U32 rrm_cellm_hasher_func
(
 const U8 *key,
 const U8 len
 )
{
	U32 hash = RRM_NULL;
	U8 loop = RRM_NULL;
	for(hash = loop = RRM_ZERO; loop < len; ++loop)
	{
		hash += key[loop];
		hash += (hash << RRM_TEN);
		hash ^= (hash >> RRM_SIX);
	}
	hash += (hash << RRM_THREE);
	hash ^= (hash >> RRM_ELEVEN);
	hash += (hash << RRM_FIFTEEN);
	return hash;
}

Ulong32 rrm_cellm_rsu_serving_hash_func( const rrm_void_t *p_enb_id )
{
	U8 *key = RRM_NULL;
	key = (U8 *)(&(((rrm_cell_meas_gb_t *)p_enb_id)->meas_id));
	return rrm_cellm_hasher_func (key, sizeof(U32));
}

Ulong32 rrm_cellm_rsu_controlling_hash_func( const rrm_void_t *p_enb_id )
{
	U8 *key = RRM_NULL;
	key = (U8 *)(&(((rrm_cell_meas_gb_t *)p_enb_id)->meas_id));
	return rrm_cellm_hasher_func (key, sizeof(U32));
}

/****************************************************************************
 * Function Name  : rrm_send_init_to_rrmim
 * Inputs         :  U16 src_module_id : source module id
 *		     rrm_global_context_t *p_gl_ctx   : pointer to cell global 
 *							context
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : sends cell init message to message interface module
 ****************************************************************************/


rrm_return_et rrm_send_init_to_rrmim(
		U16       src_module_id,  /*Source module id*/
		rrm_global_context_t *p_rrm_gb_ctx /*global cell context*/
		)
{
	U16  msg_size  = RRM_ZERO;
	U16  api_id   = RRM_ZERO;
	U8   *p_msg    = RRM_PNULL;
	rrmcm_rmif_init_ind_t *p_rmif_init_ind = RRM_PNULL;
	YHNODE **table_hash_serving;
	YHNODE **table_hash_controlling;

	RRM_UT_TRACE_ENTER();

	msg_size = sizeof(rrmcm_rmif_init_ind_t);
	p_rmif_init_ind = (rrmcm_rmif_init_ind_t *)rrm_mem_get(msg_size);
    if ( p_rmif_init_ind == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rmif_init_ind failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /* coverity : CID 29643*/
    p_rmif_init_ind->module_id = (rrm_internal_module_id_et) src_module_id;
	/* Init cell index for global cell context */
	rrm_init_cell_index(p_rrm_gb_ctx);
	/*Initialize hash table*/
	/*RK:Init the hash table for serving and controlling ENB*/
	/* Serving:: 
rrm_rsu_hash_serving :hash function for generating hash value for serving cell
rrm_rsu_compare_hash_serving: hash function for comparing the key values for hash function
rrm_rsu_key_off_hash_serving: hash function for finding data to the corresponding key
table
	 */
	table_hash_serving = rrm_mem_get(RRM_MAX_BUCKET_SIZE * sizeof(YHNODE *));
    if ( table_hash_serving == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to table_hash_serving failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        RRM_MEM_FREE(p_rmif_init_ind);
        return RRM_FAILURE;
    }
	yhInit(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl), 
			RRM_MAX_BUCKET_SIZE,
			rrm_cellm_rsu_serving_hash_func,
			rrm_rsu_compare_serv_hash,
			rrm_rsu_key_off_hash_serving,
			table_hash_serving
	      );
	/*Controlling:: 
rrm_rsu_hash_controlling :hash function for generating hash value for controlling cell
rrm_rsu_compare_hash_controlling: hash function for comparing the key values for hash function
rrm_rsu_key_off_hash_controlling: hash function for finding data to the corresponding key
table
	 */
	table_hash_controlling = rrm_mem_get(RRM_MAX_BUCKET_SIZE * sizeof(YHNODE *));
    if (table_hash_controlling == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to table_hash_controlling failed" );
        RRM_MEM_FREE(p_rmif_init_ind);
        RRM_MEM_FREE(table_hash_serving);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	yhInit(&(p_g_rrm_cell_ctx->rsu_measid_hash_tbl), 
			RRM_MAX_BUCKET_SIZE,
			rrm_cellm_rsu_controlling_hash_func,
			rrm_rsu_compare_ctrl_hash,
			rrm_rsu_key_off_hash_controlling,
			table_hash_controlling
	      );
	p_msg = (void *)p_rmif_init_ind;
	api_id = RRMCM_RMIF_INIT_IND;

	if( RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_MIF_MODULE_ID,
				api_id, 
				msg_size, 
				p_msg) )
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"failed to send to MIF api_id %d", api_id);
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Sent to MIF api_id : %d, msg_size : %d", api_id, msg_size);
	}
	RRM_MEM_FREE(p_rmif_init_ind);
	RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/****************************************************************************
 * Function Name  : rrm_cellm_init
 * Inputs         : void *p_rrm_cellm_init_data : pointer to cell based init
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Initialises init request send
 ****************************************************************************/

void* rrm_cellm_init(	
		void *p_rrm_cellm_init_data)
{
	U8 index=RRM_ZERO;
	RRM_INIT_LOG(RRM_PNULL);
	RRM_UT_TRACE_ENTER();
	/* Allocate Memory for RRM global context data structure */
	p_g_rrm_cell_ctx = (rrm_global_context_t *)rrm_mem_get(
			sizeof(rrm_global_context_t));
    if ( p_g_rrm_cell_ctx == RRM_PNULL)
    {
            /*SPR 17777 +-*/
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_g_rrm_cell_ctx failed");
        /* SPR 21251 End */
            /*SPR 17777 +-*/
	    /* CID 108854 fix Start */
	    //rrm_abort();
	    RRM_UT_TRACE_EXIT();
	    return p_g_rrm_cell_ctx;
	    /* CID 108854 fix Stop */

    }
    RRM_MEMSET(p_g_rrm_cell_ctx, RRM_ZERO, sizeof(rrm_global_context_t));
	p_g_rrm_cell_ctx->log_level = RRM_OAM_BRIEF;
    /* coverity : CID 29644*/
    p_g_rrm_cell_ctx->log_enabled = RRM_OAM_LOG_ON;
	SET_MODULE_LOG_LEVEL(RRM_OAM_BRIEF);
	for(index= RRM_ZERO;index < RRM_MAX_NUM_CELLS;index++)
	{
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]= RRM_PNULL;
	}
	/* Send rrm INIT to OAM */

    /*spr 10329:start*/
    ylInit(&(p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list));
    /*spr 10329:end*/

    /*SPR 16477 Fix Start*/
    ylInit(&(p_g_rrm_cell_ctx->enb_context.connected_mme_list));
    /*SPR 16477 Fix Stop*/
    /* SPR 13383 changes start */
    rrm_create_ca_inter_band_table_index( p_g_rrm_cell_ctx );
    rrm_create_ca_intra_band_contigious_table_index( p_g_rrm_cell_ctx );
    rrm_function_create_intra_band_non_contigious_index( p_g_rrm_cell_ctx );
    /* SPR 13383 changes end */

	rrm_send_init_to_rrmim(RRM_CM_MODULE_ID, p_g_rrm_cell_ctx);
    /* SPR 18705:start */
#ifdef LTE_EMBMS_SUPPORTED
    ylInit(&(p_g_rrm_cell_ctx->enque_sf_info_list));
#endif
    /* SPR 18705:end */
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_BRIEF,"CELLM Initialized");

	RRM_UT_TRACE_EXIT();
	return p_g_rrm_cell_ctx;
}

/****************************************************************************
 * Function Name  : cell_start_timer
 * Inputs         : 
 *      1.timerType     : Timer Type that to be started.
 *      2.p_data        : Pointer to the data to be saved with timer and
 *                        it's not null pointer.
 *      3.size          : size of data.
 *      4.p_gl_ctxt : Pointer to global context & it's not null pointer.
 * Outputs        : 
 * Returns        : 
 * Variables      : 
 * Description    : This function starts the timer.
 ****************************************************************************/
QTIMER cell_start_timer(cell_timer_et timerType, void *p_data, U16 size,rrm_cell_context_t *p_cell_ctx)
{
    QTIME   time;
    void    *p_timer_buf = RRM_PNULL;
    void    *p_timerId = RRM_PNULL;
    /* DYNAMIC ICIC CHANGES START */
    U32     duration_sec = RRM_ZERO;
    U32     duration_us = RRM_ZERO;
    /* eICIC_PHASE_1_2_CHANGES_START */
    rrm_bool_t repeat_status = RRM_ONE;
    /* eICIC_PHASE_1_2_CHANGES_END */

    /* DYNAMIC ICIC CHANGES END */

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_data);
    RRM_ASSERT (RRM_PNULL != p_cell_ctx);

    p_timer_buf  = rrm_mem_get(size);
    if (RRM_PNULL == p_timer_buf)
    {
        /*raising error event - TIMER_START_FAIL*/
        rrm_raise_error_event_notification(RRM_EE_TIMER_START_FAIL);
    } 
    else
    {
        RRM_MEMCPY(p_timer_buf, p_data, size);
        switch(timerType)
        {
            case CELL_PERIODIC_TIMER_FOR_LD_PROCESS:
                duration_sec = p_cell_ctx->cell_load_action.ld_process_timer;
                duration_us = RRM_ZERO;
                break;
            case CELL_PERIODIC_TIMER_FOR_KPI:
                duration_sec = p_cell_ctx->kpi_stat.duration;
                duration_us = RRM_ZERO;
                break;

                /* eICIC_PHASE_1_2_CHANGES_START */
            case CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL:
                /* bug_13883_start */
                duration_sec = p_cell_ctx->timer_val[timerType];
                duration_us = RRM_ZERO;
                repeat_status = RRM_ZERO;
                break;
            case CELL_GUARD_TIMER_FOR_ABS_PATTERN:
                duration_sec = p_cell_ctx->timer_val[timerType];
                duration_us = RRM_ZERO;
                repeat_status = RRM_ZERO;
                break;
            case CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER:
                duration_sec = p_cell_ctx->timer_val[timerType];
                duration_us = RRM_ZERO;
                repeat_status = RRM_ZERO;
                break;
                /* bug_13883_end */
                /* eICIC_PHASE_1_2_CHANGES_END */
            default:
                duration_sec = p_cell_ctx->timer_val[timerType];
                duration_us = RRM_ZERO;
        }

        time.s  = duration_sec ;
        time.us = duration_us;
        /* eICIC_PHASE_1_2_CHANGES_START */
        p_timerId   = qvTimerStart(&time, p_timer_buf, repeat_status);
        /* eICIC_PHASE_1_2_CHANGES_END */
        if (RRM_PNULL == p_timerId)
        {
            /*raising error event - TIMER_START_FAIL*/
            rrm_raise_error_event_notification(RRM_EE_TIMER_START_FAIL);
            /* SPR 15822 Fix Start */
            RRM_TRACE(RRM_TRUE, p_rrm_cellm_facility_name, RRM_WARNING, 
                    "Timer Started: Timer [%p], TimerType [%u], TimerDuration [%u]sec [%u]msec", 
                    p_timerId, timerType, duration_sec, duration_us/1000);
            /* SPR 15822 Fix End */

            /*Cov_fix_63798*/
            if(PNULL != p_timer_buf)
                RRM_MEM_FREE(p_timer_buf);
            /*Cov_fix_63798*/

        }
        else
        {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                  "Started Timer: Timer Type [%d]: Timer Id [%p]: Duration: [%d]sec [%d]usec",  
                  timerType, p_timerId, duration_sec, duration_us);
    }
    }
    RRM_UT_TRACE_EXIT();
    return(p_timerId);
}
/*SPR 21419 Fix Start*/
/*Code moved*/
/*SPR 21419 Fix Stop*/

/****************************************************************************
 * Function Name  :cell_stop_timer
 * Inputs         : 
 *      1.p_timerId : Pointer to Timer Identifier.
 * Outputs        : 
 * Returns        : 
 * Variables      : 
 * Description    : This function stops the running timer.p_timerId is expected 
 *                  to be NULL as well as NON NULL, so no NULL check is done on it.
 ****************************************************************************/
void cell_stop_timer (QTIMER    p_timerId)
{
	void    *p_timerData = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	if (RRM_PNULL != p_timerId)
	{
    /* SPR-17852 START */
		if(qvTimerRunning(p_timerId))
		{
      p_timerData = cell_get_timer_data(p_timerId);
			if(p_timerData != RRM_PNULL)
			{
				RRM_MEM_FREE(p_timerData);
			}
			qvTimerStop(p_timerId, RRM_PNULL);
		}
        else
        { 
        RRM_TRACE(RRM_TRUE, p_rrm_cellm_facility_name, RRM_ERROR, "timer already expired or not running!");
    }
        }
  else
  { 
        RRM_TRACE(RRM_TRUE, p_rrm_cellm_facility_name, RRM_ERROR, "NULL timer passed!");
  }
  /* SPR-17852 END */

	RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : cell_process_timer_msg
 * Inputs         :
 *      1.  p_timerId : pointer to timer identifier.
 * Outputs        :
 * Returns        :
 * Variables      :
 * Description    : This function is to get the store data associated with
 *                  the timer.
 ****************************************************************************/
void cell_process_timer_msg(QTIMER timer_id, void *p_buf, void *p_context)
{
	cell_timer_buf_t             *p_timer_buf = RRM_PNULL;
	U16                          event_id = RRM_ZERO;
	rrm_return_et                ret_val = RRM_SUCCESS;
	rrm_bool_et                  return_flag = RRM_FALSE;  

	rrm_cell_context_t           *p_cell_ctx;
	cell_son_attr_info_list_t    *p_cell_attribute_info = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT (RRM_PNULL != p_buf);
	RRM_ASSERT (RRM_PNULL != p_context);

	p_g_rrm_cell_ctx   =   (rrm_global_context_t *)p_context;
	p_timer_buf    =   (cell_timer_buf_t *)p_buf;

    /* SPR 15822 Fix Start */
    RRM_TRACE(g_cellm_log_on_off,
            p_rrm_uem_facility_name, 
            RRM_BRIEF,
            "Timer expired: Timer [%p] TimeType [%u]",
            timer_id, p_timer_buf->timer_type);
    /* SPR 15822 Fix End */

    switch (p_timer_buf->timer_type)
    {
        /* Carrier Aggregation start*/
        case CELL_PERIODIC_TIMER_FOR_CELL_LOAD_MULTICASTING_INFO :
        {
            rrm_broadcast_resource_update_info_at_eNB( p_timer_buf );
            break;
        }
        /* Carrier Aggregation end */
        case CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_IND:
            {
                ret_val = rrm_send_rsu_to_neighbour(p_timer_buf->rsu_meas_id);
                /* Coverity 74152 Fix Start */
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Failure in rrm_send_rsu_to_neighbour" );
                }
                /* Coverity 74152 Fix End */
            }
            break;

            default:
            {
                if (p_timer_buf->cell_index < RRM_MAX_NUM_CELLS)
                {
                    p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_timer_buf->cell_index];
                    if (RRM_PNULL != p_cell_ctx)
                    {
                        event_id = CELL_PERIODIC_TIMER_EXPIRY;
                        /* UE MEAS CHANGES : STARTS */
                        switch (p_timer_buf->timer_type)
                        {
                            case CELL_PERIODIC_TIMER_FOR_UE_MEAS:
                                {
                                    p_cell_attribute_info   =  p_cell_ctx->p_son_info->p_anr_info;
                                    p_cell_attribute_info->timer_status
                                        [SON_UE_MEAS_CONFIG_TIMER] = EXPIRED;
                                    break;
                                }
                            case CELL_PERIODIC_TIMER_FOR_ANR:
                                {
                                    p_cell_attribute_info   =  p_cell_ctx->p_son_info->p_anr_info;
                                    p_cell_attribute_info->timer_status
                                        [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = EXPIRED;
                                    break;
                                }
                            case CELL_PERIODIC_TIMER_FOR_ES:
                                {
                                    p_cell_attribute_info   =  p_cell_ctx->p_son_info->p_es_info;
                                    p_cell_attribute_info->timer_status
                                        [SON_ANR_ES_ACTIVE_UE_COUNT_TIMER] = EXPIRED;
                                    break;
                                }

                            case CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO:
                                {
                                    /* Updating the event */
                                    event_id = RRM_PERIODIC_RESRC_UPDATE_EVENT;
                                }
                                break;

                                /* RRM ES Start */
                            case CELL_PERIODIC_TIMER_FOR_ES_SELF_LOAD_INFO:
                                {
                                    /* Updating the event */
                                    event_id = RRM_ES_PERIODIC_RESRC_UPDATE_EVENT;
                                }
                                break;
                                /* RRM ES End */
                            case CELL_PERIODIC_TIMER_FOR_LD_PROCESS:
                                {
                                    /* Process the Load action configured by OAM/SON */
                                    ret_val = rrm_process_load_action (p_cell_ctx);
                                    /* Coverity 74152 Fix Start */
                                    if(RRM_FAILURE == ret_val)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                                "Failure in "
                                                "rrm_process_load_action" );
                                        /* Coverity 74152 Fix End */
                                    }
                                    return_flag = RRM_TRUE;
                                }
                                break;
                                /* DYNAMIC ICIC CHANGES START */
                            case CELL_RECONFIG_TIMER_FOR_ICIC:
                                {
                                    /*
                                     ** Update the event to be raised on the expiry of the 
                                     ** timer that controls the reconfiguration of the cell                 
                                     ** for ICIC purpose. 
                                     */
                                    event_id = RRM_CELL_RECONFIG_FOR_ICIC_EVENT;
                                }
                                break;
                                /* DYNAMIC ICIC CHANGES END */
                            case CELL_PERIODIC_TIMER_FOR_KPI:
                                {
                                    /*send the kpi ind to mif*/
                                    ret_val = rrm_cell_build_and_send_kpi_to_mif(p_cell_ctx);
                                    /* Coverity 74152 Fix Start */
                                    if(RRM_FAILURE == ret_val)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                                "Failure in "
                                                "rrm_cell_build_and_send_kpi_to_mif" );
                                        /* Coverity 74152 Fix End */
                                    }
                                    return_flag = RRM_TRUE;
                                }
                                break;
                                /* eICIC_PHASE_1_2_CHANGES_START */
                            case CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL:
                                {
                                    /*
                                     ** Update the event to be raised on the expiry of the
                                     ** timer that sends the API to UEm to find the aggressor
                                     ** nodes for eICIC purpose.
                                     */
                                    event_id = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL_EVENT;
                                }
                                break;
                            case CELL_GUARD_TIMER_FOR_ABS_PATTERN:
                                {
                                    /*
                                     ** Update the event to be raised on the expiry of the
                                     ** timer that waits for the response from the aggressor
                                     ** after sending them load invoke request.
                                     */
                                    event_id = CELL_GUARD_TIMER_FOR_ABS_PATTERN_EVENT;
                                }
                                break;
                            case CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER:
                                {
                                    /*
                                     ** Update the event to be raised on the expiry of the
                                     ** timer that waits for the response from the aggressor
                                     ** second time after recievng the ABS information.
                                     */
                                    event_id = CELL_ABS_PATTERN_UPDATE_COLLATION_TIMER_EVENT;
                                }
                                break;
                                /* eICIC_PHASE_1_2_CHANGES_END */
                            default:
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                            RRM_DETAILED, "Timer(%d) not matched", 
                                            p_timer_buf->timer_type);

                                    /* Free the timer buffer */
                                    RRM_MEM_FREE(p_timer_buf);
                                    return_flag = RRM_TRUE;
                                    break;
                                }
                        }

                        if(RRM_FALSE == return_flag)
                        {
                            ret_val = cellm_fsm_process_event(
                                    event_id,
                                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_timer_buf->cell_index]);

                            if(RRM_FAILURE == ret_val)
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                        RRM_DETAILED,"failure from FSM");
                            }  
                        }
                        /* UE MEAS CHANGES : ENDS */
                    }
                    else
                    {

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_ERROR,"Cell context not found for timer type [%u], Cell Idx[%u]",
                                p_timer_buf->timer_type, p_timer_buf->cell_index);
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                            RRM_ERROR,"Invalid Cell Idx[%u] for timer type [%d]",
                            p_timer_buf->cell_index, p_timer_buf->timer_type);
                }
            }
            break;
    }

	RRM_UT_TRACE_EXIT();
	return;
}

/****************************************************************************
 * Function Name  : RrmCellMDestinationList/CellRrmEntity
 * Inputs         : None
 * Outputs        : None
 * Returns        : void
 * Description    : defining RrmCellMDestinationList and p_manifest for CSPL
 ****************************************************************************/


static const unsigned long RrmCellMDestinationList[] =
{
	RRM_MIF_MODULE_ID,
	RRC_MODULE_ID,
	MAC_MODULE_ID,
	PDCP_MODULE_ID,
	RRM_UEM_MODULE_ID,
	RRM_ZERO
};

const   QMANIFEST CellRrmEntity =
{
	"RRM_CM_MODULE_ID",
	RRM_CM_MODULE_ID,

	{ RRM_ZERO, rrm_cellm_init },
	{ rrm_process_msg, cell_process_timer_msg  },
	{ RRM_ZERO, RRM_ZERO, RRM_ZERO },
	RrmCellMDestinationList
};



/* __MR__ BEGIN */
#ifdef ENDC_ENABLED
/* NR_REP_CONFIG_FIX_START */
rrm_void_t
rrm_update_cellm_update_peer_gnb_pci_list
(
    U16  pci
)
{
    U8 cell_count  = RRM_ZERO;
    U8 peer_cell_cnt  = RRM_ZERO;
    rrm_cell_context_t *p_cell_context = RRM_PNULL; 
    RRM_UT_TRACE_ENTER();
    for(cell_count = RRM_ZERO; 
            cell_count < p_g_rrm_cell_ctx->enb_cell_count; cell_count++)
    {
        if( RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count] )
        {
            p_cell_context = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count];
            for(peer_cell_cnt = RRM_ZERO; 
                    peer_cell_cnt < p_cell_context->operator_info.endc_info.\
                    peer_gnb_pci_list.count; peer_cell_cnt++)
            {
                if(p_cell_context->operator_info.endc_info.\
                        peer_gnb_pci_list.peer_gnb_pci[peer_cell_cnt].nr_pci == pci)
                {
			       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,
                            RRM_DETAILED,"PCI [%d] is valid for default sgnb\n",pci);
                    p_cell_context->operator_info.endc_info.\
                        peer_gnb_pci_list.peer_gnb_pci[peer_cell_cnt].is_valid = RRM_TRUE;
                    break;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* NR_REP_CONFIG_FIX_END */
/**************************************************************************
 * Function Name  : rrm_cellm_get_sgnb_ambr_share
 * Inputs         : cell_index
 * Outputs        : sgnb_ambr_share
 * Returns        : sgnb_ambr_share
 * Description    : returns the sgnb AMBR share value 
 ****************************************************************************/

U8
rrm_cellm_get_sgnb_ambr_share
(
 rrm_cell_index_t cell_index
 )
{
	return  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.endc_info.sgnb_ambr_share;
}
#endif

/**************************************************************************
 * Function Name  : rrm_cellm_get_erb_service_profile
 * Inputs         : cell_index
 * Outputs        : epc_params
 * Returns        : address of epc_params within epc_info
 * Description    : returns address of epc_params within epc_info
 ****************************************************************************/

epc_params_t*
rrm_cellm_get_erb_service_profile
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->epc_info.epc_params);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_common_eutran_params
 * Inputs         : cell_index
 * Outputs        : common_eutran_params
 * Returns        : address of common_eutran_params within ran_params
 * Description    : returns address of common_eutran_params within ran_params
 ****************************************************************************/

common_eutran_params_t*
rrm_cellm_get_common_eutran_params
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.common_eutran_params);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_admission_control_info
 * Inputs         : cell_index
 * Outputs        : admission_control_info
 * Returns        : address of admission_control_info within operator_info
 * Description    : address of admission_control_info within operator_info
 ****************************************************************************/

admission_control_info_t* 
rrm_cellm_get_admission_control_info
(
 rrm_cell_index_t cell_index
 )
{
	return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.admission_control_info);
}

/*spr 7984 start*/
/**************************************************************************
 * Function Name  : rrm_cellm_get_enable_cqi_mask_r9
 * Inputs         : cell_index
 * Outputs        : enable_cqi_mask_r9
 * Returns        : enable_cqi_mask_r9 within operator_info
 * Description    : enable_cqi_mask_r9 within operator_info
 ****************************************************************************/

rrm_bool_et
rrm_cellm_get_enable_cqi_mask_r9
(
 rrm_cell_index_t cell_index
 )
{
    return (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.rrm_enable_cqi_mask_r9);
}
/*spr 7984 end*/

/*spr 7996 start*/
/*SPR 17777 +-*/
/*spr 7996 end*/

/**CLPC_MR_START*/
/**************************************************************************
 * Function Name  : rrm_cellm_get_rrmc_mac_config
 * Inputs         : cell_index
 * Outputs        : rrmc_mac_config 
 * Returns        : addres of rrmc_mac_config within operator_info
 * Description    : address of rrmc_mac_config within operator_info
 ****************************************************************************/
rrmc_mac_config_t*
rrm_cellm_get_rrmc_mac_config
(
 rrm_cell_index_t cell_index
 )
{
	return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.
			rrm_mac_config);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_tpc_rnti_allocation_table_pucch
 * Inputs         : cell_index
 * Outputs        : rrm_ue_tpc_rnti_tbl_pucch
 * Returns        : addres of rrm_ue_tpc_rnti_tbl_pucch
 * Description    : address of rrm_ue_tpc_rnti_tbl_pucch
 ****************************************************************************/
rrm_ue_tpc_rnti_tbl_pucch_t*
rrm_cellm_get_tpc_rnti_allocation_table_pucch
(
 rrm_cell_index_t cell_index
 )
{
	return (&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
				rrm_ue_tpc_rnti_tbl_pucch));
}
/**CLPC_MR_END*/

/**************************************************************************
 * Function Name  : rrm_cellm_get_tpc_rnti_allocation_table_pusch
 * Inputs         : cell_index
 * Outputs        : rrm_ue_tpc_rnti_tbl_pusch
 * Returns        : addres of rrm_ue_tpc_rnti_tbl_pusch
 * Description    : address of rrm_ue_tpc_rnti_tbl_pusch
 ****************************************************************************/
rrm_ue_tpc_rnti_tbl_pusch_t*
rrm_cellm_get_tpc_rnti_allocation_table_pusch
(
 rrm_cell_index_t cell_index
 )
{
	return (&(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
				rrm_ue_tpc_rnti_tbl_pusch));
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_p_max_sib1
 * Inputs         : cell_index
 * Outputs        : p_max_sib1 
 * Returns        : returns success/failure 
 * Description    : outputs p_max_sib1 and returns success else 
 returns failure
 ****************************************************************************/
rrm_return_et
rrm_cellm_get_p_max_sib1(
		rrm_cell_index_t cell_index,
		S8               *p_p_max_sib1
		)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.
			mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.bitmask & 
			RRMCM_RMIF_P_MAX_SIB1_PRESENT)
	{
		*p_p_max_sib1 = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.
			mobility_params.idle_mode_mobility_params.
			idle_mode_mobility_intra_freq_params.p_max_sib_1;
	}
	else
	{
		ret_val = RRM_FAILURE;
	}
	return ret_val;
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_time_alignment_timer
 * Inputs         : cell_index
 * Outputs        : time alignment timer value
 * Returns        : time alignment timer value within sib_2_info 
 * Description    : time alignment timer value within sib_2_info
 ****************************************************************************/

U8
rrm_cellm_get_time_alignment_timer
(
 rrm_cell_index_t cell_index
 )
{
	return (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.sib_2_info.
			time_alignment_timer);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_antenna_port
 * Inputs         : cell_index
 * Outputs        : antenna_ports_count_number
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : return antenna_ports_count_number from antenna_info
 ****************************************************************************/

rrm_return_et 
rrm_cellm_get_antenna_port
( 
 rrm_cell_index_t cell_index, 
 U8 *antenna_port
 )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	antenna_ports_count_et antenna_enum; 

	antenna_enum = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.antenna_info.antenna_ports_count_number ; 

	switch(antenna_enum)
	{
		case ANTENNA_PORTS_COUNT_AN1:
			*antenna_port = RRM_ONE;
			break;
		case ANTENNA_PORTS_COUNT_AN2:
			*antenna_port = RRM_TWO;
			break;
		case ANTENNA_PORTS_COUNT_AN4:
			*antenna_port = RRM_FOUR;
			break;
		case ANTENNA_PORTS_COUNT_SPARE1:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"antenna port count spare1");
			break;
		default:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"antenna port not avail");
			ret_val = RRM_FAILURE;
	}

	return ret_val;
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_rrmc_band_width
 * Inputs         : cell_index
 * Outputs        : dl_bandwidth from rf_configurations 
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : return dl_bandwidth from rf_configurations
 ****************************************************************************/

rrm_return_et 
rrm_cellm_get_rrmc_band_width
(
 rrm_cell_index_t cell_index, 
 U8 *dl_bandwidth
 )
{
	rrm_return_et       ret_val = RRM_SUCCESS;
	rrm_oam_band_width_et rrmc_bandwidth_enum;

	rrmc_bandwidth_enum = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rf_params.rf_configurations.dl_bandwidth;

	switch(rrmc_bandwidth_enum)
	{
		case RRM_OAM_BW_N_6:
			*dl_bandwidth = RRM_BW_N6;
			break;
		case RRM_OAM_BW_N_15:
			*dl_bandwidth = RRM_BW_N15;
			break;
		case RRM_OAM_BW_N_25:
			*dl_bandwidth = RRM_BW_N25;
			break;
		case RRM_OAM_BW_N_50:
			*dl_bandwidth = RRM_BW_N50;
			break;
		case RRM_OAM_BW_N_75:
			*dl_bandwidth = RRM_BW_N75;
			break;
		case RRM_OAM_BW_N_100:
			*dl_bandwidth = RRM_BW_N100;
			break;
	}
	return ret_val;

}
/* MC,MR & HO start */
/**************************************************************************
 * Function Name  : rrm_cellm_get_report_status
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : value of ho report status
 * Description    : returns the value of ho report status
 *****************************************************************************/
rrm_bool_et
rrm_cellm_get_ho_report_status
(
 rrm_cell_index_t cell_index
 )
{
	/* SPR 10500 FIX START */
    rrm_bool_et        ret_val=RRM_FALSE;
    if((RRM_PNULL != p_g_rrm_cell_ctx) && (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]) &&
      (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info ))
    {
        if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_anr_info)
        {

            return (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->
                    p_anr_info->is_ho_report_active);
        }
    }
    return ret_val;
    /* SPR 10500 FIX END */
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_mlb_report_status
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : value of mlb ho report status
 * Description    : returns the value of mlb ho report status
 *****************************************************************************/
rrm_bool_et
rrm_cellm_get_mlb_ho_report_status
(
 rrm_cell_index_t cell_index
 )
{
    rrm_bool_et        ret_val=RRM_FALSE;

    if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info )
    {
        if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mlb_info )
        {
            ret_val=p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mlb_info->is_ho_report_active;
        }
    }
    return ret_val;
}

/* MRO code changes start */
/**************************************************************************
 * Function Name  : rrm_cellm_get_ho_failure_report_attr_status 
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : value of ho failure report attr status
 * Description    : returns the value of ho failure report attr status
 *****************************************************************************/
rrm_bool_et
rrm_cellm_get_ho_failure_report_attr_status
(
 rrm_cell_index_t cell_index
 )
{
	rrm_bool_et        ret_val=RRM_FALSE;

	if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info )
	{
		if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mro_info )
		{
			ret_val=p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mro_info->is_ho_failure_report_active;
		}
	}
	return ret_val;
}
/**************************************************************************
 * Function Name  : rrm_cellm_get_ho_attemt_ind_attr_status 
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : value of ho attempt indication status
 * Description    : returns the value of ho attempt indication status
 *****************************************************************************/
rrm_bool_et
rrm_cellm_get_ho_attemt_ind_attr_status
(
 rrm_cell_index_t cell_index
 )
{
    rrm_bool_et  ret_val=RRM_FALSE;

   if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info)
   {
       if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mro_info)
       {
           ret_val= p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_son_info->p_mro_info->is_ho_attempt_ind_active;
       }
   }
   return ret_val;

}

/**************************************************************************
 * Function Name  : rrm_cellm_get_ncl_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of ncl_params
 * Description    : returns addess of ncl_params
 ****************************************************************************/

lte_ncl_t* 
rrm_cellm_get_ncl_params
(
 rrm_cell_index_t cell_index
 )
{
	if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.ncl_params.bitmask & 
			RRMCM_RMIF_LTE_NCL_PRESENT)
	{
		return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.ncl_params.lte_ncl);
	}
	else 
	{
		return RRM_PNULL;
	}
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_inter_rat_ncl_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of ncl_params
 * Description    : returns addess of ncl_params
 ****************************************************************************/

inter_rat_ncl_t* 
rrm_cellm_get_inter_rat_ncl_params
(
 rrm_cell_index_t cell_index
 )
{
	if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.ncl_params.bitmask & 
			RRMCM_RMIF_INTER_RAT_NCL_PRESENT)
	{
		return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.ncl_params.inter_rat_ncl);
	}
	else 
	{
		return NULL;
	}
}
/* MC,MR & HO end */
/**************************************************************************
 * Function Name  : rrm_cellm_get_srb_info
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of rlc_layer_params
 * Description    : returns addess of rlc_layer_params
 ****************************************************************************/

rlc_layer_params_t* 
rrm_cellm_get_srb_info
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rlc_layer_params);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_timers_info
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of timer params
 * Description    : returns addess of timer_params
 ****************************************************************************/

rrc_timers_t*
rrm_cellm_get_timer_info
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.rrc_timers_and_constants.rrc_timers);
}
/**************************************************************************
 * Function Name  : rrm_cellm_get_ue_service_profile
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of ue_service_profile
 * Description    : returns addess of ue_service_profile
 ****************************************************************************/

rrc_rrm_ue_service_profile_t* 
rrm_cellm_get_ue_service_profile
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.admission_control_info.ue_service_profile);
}
/**************************************************************************
 * Function Name  : rrm_cellm_mac_layer_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of mac_layer_params
 * Description    : returns addess of mac_layer_params
 ****************************************************************************/

mac_layer_params_t* 
rrm_cellm_mac_layer_params
(
 rrm_cell_index_t cell_index
 )
{
	return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.mac_layer_params);
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_physical_layer_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of physical_layer_params
 * Description    : returns addess of physical_layer_params 
 ****************************************************************************/

rrm_physical_layer_params_t* 
rrm_cellm_get_physical_layer_params
(
 rrm_cell_index_t cell_index
 )
{
	return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.physical_layer_params);
}
/* __MR__ END */

/*BUG_863_CHANGES_START */

/****************************************************************************
 * Function Name  : rrm_cellm_mark_sr_index_free
 * Inputs         : cell_index, frame, slot, sr_res_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Marks a SR resource index as free by inserting the 
 *                  corresponding node in the SR resource list on basis of the 
 *                  frame, slot and res_index
 ****************************************************************************/
/* Coverity 19oct Start : 54929 */
rrm_void_t
rrm_cellm_mark_sr_index_free
(
 rrm_cell_index_t cell_index,
 U8               row_num, 
 U16              col_num
 )
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	rrm_sr_res_list_t *res_node = RRM_PNULL;

	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

   if (RRM_PNULL != p_rrm_cell_ctx)
   {
       if (RRM_PNULL != p_rrm_cell_ctx->sr_res)
       {
          res_node = &(p_rrm_cell_ctx->sr_res[row_num][col_num]);

          if(RRM_PNULL == res_node)
          {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                             "Data for row_num[%d], col_num[%d]",row_num, col_num);
          }
          else
          {
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                             "SR Config Idx[%d], Resource Idx[%d], Row[%d], Col[%d]",
                             res_node->sr_config_index, res_node->sr_pucch_res_index, row_num, col_num);
             res_node->sr_marked_status = RRM_RES_FREE;
          }
       }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                          "This leg will hit when Cell Resources are already deleted and UEs are being deleted");
    }
   }
   else
   {
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                      "This leg will hit when Cell Context is NULL");
   }

	RRM_UT_TRACE_EXIT();
/* Coverity 19oct End : 54929 */
}

/****************************************************************************
 * Function Name  : rrm_cell_get_free_cqi_res_index
 * Inputs         : cell_index, frame, slot
 * Outputs        : cqi_res_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of CQI resource index by frame and
 *                  slot in the CQI resource list; and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et
rrm_cell_get_free_cqi_res_index
(
 rrm_cell_index_t cell_index,
 U8               n2_idx,
 U16              cqi_idx,
 U16              *cqi_config_idx,
 U8               *cqi_pucch_res_idx,
 U16              *ri_res_index
 )
{
	RRM_UT_TRACE_ENTER();

	rrm_return_et retVal = RRM_SUCCESS;
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    rrm_cqi_ri_res_list_t *res_node = RRM_PNULL;

	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    if (RRM_PNULL != p_rrm_cell_ctx)
    {
        res_node = &(p_rrm_cell_ctx->cqi_ri_res[n2_idx][cqi_idx]);

	    if(RRM_RES_BUSY == res_node->cqi_ri_marked_status)
	    {
		   /* Resource is blocked for other UE */
		   retVal = RRM_FAILURE;
        }
        /* SPR 19359 Fix Start */
        /* Check is introduced so that SCell is not allocated CQI Config Index same
         * as allocated to PCell */
        else if ((INVALID_CQI_CFG_INDEX != *cqi_config_idx) &&
                  (res_node->cqi_config_index == *cqi_config_idx))
        {
           retVal = RRM_FAILURE;
        }
       /* SPR 19359 Fix End */
	   else
	   {
		   *cqi_config_idx    = res_node->cqi_config_index;
		   *ri_res_index      = res_node->ri_config_index;
		   *cqi_pucch_res_idx = res_node->cqi_pucch_res_index;
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"cqi_config[%d], cqi_pucch_idx[%d], RI Index[%d]",
				res_node->cqi_config_index, res_node->cqi_pucch_res_index, 
				res_node->ri_config_index);
		   retVal = RRM_SUCCESS;
	    }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell Context is NULL for cell index: %d", cell_index);
        /* SPR 21251 End */
        retVal = RRM_FAILURE;
    }
	RRM_UT_TRACE_EXIT();
	return retVal;
}

/****************************************************************************
 * Function Name  : rrm_cell_mark_cqi_index_busy
 * Inputs         : cell_index, frame, slot, cqi_res_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Marks a SR resource index as free by inserting the 
 *                  corresponding node in the SR resource list on basis of the 
 *                  frame, slot and cqi_res_index
 ****************************************************************************/
void 
rrm_cell_mark_cqi_index_busy
(
 rrm_cell_index_t cell_index,
 U8 row, 
 U16 col
 )
{
	RRM_UT_TRACE_ENTER();
    rrm_cell_context_t    *p_rrm_cell_ctx = RRM_PNULL;
    rrm_cqi_ri_res_list_t *res_node = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    if (RRM_PNULL != p_rrm_cell_ctx)
    {
        res_node = &(p_rrm_cell_ctx->cqi_ri_res[row][col]);

	res_node->cqi_ri_marked_status = RRM_RES_BUSY;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "CQI Config Idx[%d], Resource Idx[%d], RI Index[%d], Row[%d], Col[%d]",
                        res_node->cqi_config_index, res_node->cqi_pucch_res_index, res_node->ri_config_index, row, col);
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell Context is NULL for cell index: %d", cell_index);
        /* SPR 21251 End */
    }

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_available_row_and_column_and_cqi_res_index
 * Inputs         : cell_index
 * Outputs        : frame, slot, cqi_res_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of CQI resource index in any frame 
 *                  and slot; and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_available_row_and_column_and_cqi_res_index
( 
 rrm_cell_index_t cell_index, 
 U8               *row,
 U16              *col, 
 U16              *cqi_config_index,
 U8               *cqi_pucch_res_index,
 U16              *ri_index,
 U8               sr_config_index,
     /* SPR14123start*/
 /* eICIC_PHASE_1_2_CHANGES_START */
 rrm_abs_type_et    abs_type
 /* eICIC_PHASE_1_2_CHANGES_END */
     /* SPR14123end*/

 )
{
    RRM_UT_TRACE_ENTER();

    rrm_return_et ret_val = RRM_SUCCESS;
    rrm_bool_et   free_found        = RRM_FALSE; 
    U8            n2_pucch_res_index_max_value = RRM_ZERO;
    U8            n2_idx  = RRM_ZERO;
    U16           cqi_idx  = RRM_ZERO;
    /* SPR 11003 Fix Start */
    U16           n_one_pucch_an   = RRM_ZERO;
    /* SPR 11003 Fix End */
    U16           sr_periodicity   = RRM_ZERO;
    U16           cqi_periodicity  = RRM_ZERO;
    U8                      n_rb_cqi = RRM_ZERO;
    /* SPR 10749 Fix Start */
    U8            no_of_ue_in_one_n2_rb = RRM_ZERO;
    /* SPR 10749 Fix End */
    /*SPR 15050 start*/
    static U8 first_cqi = RRM_ZERO;
    /*SPR 15050 end*/
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    n_rb_cqi = p_rrm_cell_ctx->ran_info.physical_layer_params.
        physical_layer_param_pucch.n_rb_cqi;
    if(RRM_ZERO == n_rb_cqi)
    {
        n_rb_cqi = RRM_TWO;
    }
    /* SPR 10749 Fix Start */
    no_of_ue_in_one_n2_rb =  RRM_MAX_NUM_OF_UE_IN_SINGLE_RB_FOR_FORMAT2_2A_2B;
    /* Coverity 63918 fix start */
    /* Coverity 63918 fix end */
    n2_pucch_res_index_max_value = (n_rb_cqi * no_of_ue_in_one_n2_rb);
    /* SPR 10749 Fix End */

    find_sr_periodicity_from_cell_context(p_rrm_cell_ctx, &sr_periodicity, &n_one_pucch_an);
    find_cqi_periodicity_from_cell_context(p_rrm_cell_ctx, &cqi_periodicity);

#ifdef PUCCH_RES_GAP
	//allocate pucch resource discontinuously, 0,2,4,...,1,3,5,...
    for(n2_idx = RRM_ZERO; RRM_FALSE == free_found; n2_idx+=2)
#else
    for(n2_idx = RRM_ZERO; (RRM_FALSE == free_found) && (n2_idx < n2_pucch_res_index_max_value); n2_idx++ )
#endif
    {
#ifdef PUCCH_RES_GAP
		if (0 == (n2_idx % 2))
		{
			if (n2_idx >= n2_pucch_res_index_max_value)
			{
				//even value reach max, restart from 1
				n2_idx = 1;
			}
		}
		else
		{
			if (n2_idx >= n2_pucch_res_index_max_value)
			{
				//odd value reach max, terminate
				break;
			}
		}
		//NOTE: n2_pucch_res_index_max_value is number of pucch resource index, not max value
#endif
        for(cqi_idx = RRM_ZERO; 
                (RRM_FALSE == free_found) && (cqi_idx < p_rrm_cell_ctx->allocated_cqi_perodicity_max_val); 
                cqi_idx++)
        {    
            ret_val = rrm_cell_get_free_cqi_res_index(cell_index, n2_idx, cqi_idx,
                    cqi_config_index, cqi_pucch_res_index,
                    ri_index);
            if(ret_val == RRM_SUCCESS)
            {
                /* SPR 16427 fix start */
                if (RRM_SUCCESS == rrm_compare_sub_frame_offset_for_sr_and_cqi(
                            sr_periodicity, cqi_periodicity, 
                            sr_config_index, *cqi_config_index, p_rrm_cell_ctx)
                    /* SPR 16427 fix start */
                   )
                {
#ifdef LTE_EMBMS_SUPPORTED
                    if((RRM_EICIC_ABS_NULL != abs_type) && 
                           (p_rrm_cell_ctx->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_2_ON_BROADCAST ))
                    {
                        if(first_cqi == RRM_ZERO)
                        {
                            *row =  n2_idx;
                            *col = cqi_idx;
                            first_cqi = first_cqi + RRM_ONE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                                    "FINAL Allocation CQI:- CQI-PUCCH-Res=%d, CQI Index=%d, RI Index=%d",
                                    *cqi_pucch_res_index, *cqi_config_index, *ri_index);
                        }    
                        /*SPR 15050 end*/
                        ret_val = rrm_uem_find_free_cqi_index_for_victim(*cqi_config_index,cqi_periodicity, cell_index, abs_type,RRM_ONE);
                        if(RRM_FAILURE == ret_val)
                        {
                            /* check for another available index */
                            continue;
                        }
                    }
                    /* SPR14123start*/
                    /* eICIC_PHASE_1_2_CHANGES_START */
                    else if(RRM_EICIC_ABS_NULL != abs_type)
#else
                    if(RRM_EICIC_ABS_NULL != abs_type)
#endif                    
                    {
                        /*SPR 15050 start*/
                        if(first_cqi == RRM_ZERO)
                        {
                            *row =  n2_idx;
                            *col = cqi_idx;
                            first_cqi = first_cqi + RRM_ONE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                                    "FINAL Allocation CQI:- CQI-PUCCH-Res=%d, CQI Index=%d, RI Index=%d",
                                    *cqi_pucch_res_index, *cqi_config_index, *ri_index);
                        }    
                        /*SPR 15050 end*/
#ifdef LTE_EMBMS_SUPPORTED
                        ret_val = rrm_uem_find_free_cqi_index_for_victim(*cqi_config_index,cqi_periodicity, cell_index, abs_type,RRM_ZERO);
#else
                        ret_val = rrm_uem_find_free_cqi_index_for_victim(*cqi_config_index,cqi_periodicity, cell_index, abs_type);
#endif
                        if(RRM_FAILURE == ret_val)
                        {
                            /* check for another available index */
                            continue;
                        }
                    }
                    /* eICIC_PHASE_1_2_CHANGES_END */
                    /* SPR14123end*/
#ifdef LTE_EMBMS_SUPPORTED
                    else if(p_rrm_cell_ctx->rrm_cell_embms_data.
                                    current_sibs_on_boradcast & MBMS_SIB_2_ON_BROADCAST)
                    {
                        if(first_cqi == RRM_ZERO)
                        {
                            *row =  n2_idx;
                            *col = cqi_idx;
                            first_cqi = first_cqi + RRM_ONE;
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                                    "FINAL Allocation CQI:- CQI-PUCCH-Res=%d, CQI Index=%d, RI Index=%d",
                                    *cqi_pucch_res_index, *cqi_config_index, *ri_index);
                        }    
                        ret_val = rrm_uem_find_free_cqi_index_for_embms(*cqi_config_index,cqi_periodicity, cell_index);
                        if(RRM_FAILURE == ret_val)
                        {
                            /* check for another available index */
                            continue;
                        }
                    }
                    else
                    {


                    }
#endif
                    rrm_cell_mark_cqi_index_busy(cell_index, n2_idx, cqi_idx);
                    *row =  n2_idx;
                    *col = cqi_idx;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                            "FINAL Allocation CQI:- CQI-PUCCH-Res=%d, CQI Index=%d, RI Index=%d",
                            *cqi_pucch_res_index, *cqi_config_index, *ri_index);
                    ret_val = RRM_SUCCESS;
                    free_found = RRM_TRUE;
                }
                else
                {
                    ret_val = RRM_FAILURE;
                }
            }
        }
    }
    /*SPR 15050 start*/
    if((first_cqi != RRM_ZERO)&&(free_found != RRM_TRUE))
    {
        rrm_cell_mark_cqi_index_busy(cell_index, *row, *col);
        ret_val = RRM_SUCCESS; 
    }    
    /*SPR 15050 start*/
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_cqi_resources
 * Inputs         : cell_index, sr_periodicity
 * Outputs        : cqi_res_index, cqi_config_index, frame, slot
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of CQI resource for UE admission. If
 *                  found, then set the CQI resource index and CQI config index
 *                  in the out params and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_cqi_resources
(
 rrm_cell_index_t  cell_index,
 U8                *cqi_pucch_res_index, 
 U16 *cqi_config_index,
 U16               *ri_index,
 U8                sr_config_index,
 U8                *row,
 U16               *col,

     /* SPR14123start*/
        /* eICIC_PHASE_1_2_CHANGES_START */
 rrm_abs_type_et    abs_type
        /* eICIC_PHASE_1_2_CHANGES_END */
     /* SPR14123end*/
 )
{
	RRM_UT_TRACE_ENTER();

    /* coverity : CID 29665*/
    rrm_return_et ret_val = RRM_SUCCESS;

     /* SPR14123start*/
        /* eICIC_PHASE_1_2_CHANGES_START */
	ret_val = rrm_cellm_get_available_row_and_column_and_cqi_res_index(cell_index, row, col, 
			cqi_config_index, cqi_pucch_res_index, 
			ri_index, sr_config_index, abs_type);
        /* eICIC_PHASE_1_2_CHANGES_START */
     /* SPR14123end*/
	RRM_UT_TRACE_EXIT();
	return ret_val;    
}

/****************************************************************************
 * Function Name  : rrm_cellm_mark_cqi_index_free
 * Inputs         : cell_index, frame, slot, sr_res_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Marks a SR resource index as free by inserting the 
 *                  corresponding node in the SR resource list on basis of the 
 *                  frame, slot and cqi_res_index
 ****************************************************************************/
/* Coverity 19oct Start : 54928 */
rrm_void_t 
rrm_cellm_mark_cqi_index_free
(
 rrm_cell_index_t cell_index,
 U8               row_num, 
 U16              col_num
 )
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    /*spr 7754 start*/
    if (RRM_PNULL != p_rrm_cell_ctx->cqi_ri_res)
    {
        rrm_cqi_ri_res_list_t *res_node = &(p_rrm_cell_ctx->cqi_ri_res[row_num][col_num]);

        /* Coverity 19oct Start : 54928 */
        res_node->cqi_ri_marked_status = RRM_RES_FREE;
        /* Coverity 19oct End : 54928 */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CQI/RI Resource Already Released");
    }
    /*spr 7754 end*/
	RRM_UT_TRACE_EXIT();
/* Coverity 19oct End : 54928 */
}



/**************************************************************************
 * Function Name  : rrm_cellm_get_freq_priority_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of frequency priority list
 * Description    : returns addess of freq_priority_params
 ****************************************************************************/

rrm_freq_priority_list_t*
rrm_cellm_get_freq_priority_params
(
 rrm_cell_index_t cell_index
 )
{
        U8                    utran_fdd_count = RRM_ZERO;
        U8                    utran_tdd_count = RRM_ZERO;
	U8                    i =  RRM_ZERO;
	rrm_cell_context_t    *rrm_cell_ctx = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	rrm_cell_ctx =  rrm_cellm_get_cell_context(cell_index);
    /*CID 65804:start*/
    if (RRM_PNULL != rrm_cell_ctx)
    {
        rrm_cell_ctx->operator_info.bitmask |= RRMCM_RMIF_FREQ_PRIORITY_LIST;

        rrm_cell_ctx->operator_info.\
            freq_priority_list.eutran_freq_priority_list_info.count = RRM_ONE; 

        rrm_cell_ctx->operator_info.\
            freq_priority_list.eutran_freq_priority_list_info.eutran_freq_priority_info[RRM_ZERO].carrier_freq =
            rrm_cell_ctx->ran_info.
            rf_params.rf_configurations.dl_earfcn;
        rrm_cell_ctx->operator_info.\
            freq_priority_list.eutran_freq_priority_list_info.eutran_freq_priority_info[RRM_ZERO].cell_reselection_priority = 
            rrm_cell_ctx->ran_info.mobility_params.\
            idle_mode_mobility_params.idle_mode_mobility_intra_freq_params.cell_reselection_priority;


        rrm_cell_ctx->operator_info.\
            freq_priority_list.eutran_freq_priority_list_info.count += 
            rrm_cell_ctx->ran_info.mobility_params.\
            idle_mode_mobility_params.num_valid_inter_freq_list; 


        for(i = RRM_ZERO;i<= rrm_cell_ctx->ran_info.mobility_params.\
                idle_mode_mobility_params.num_valid_inter_freq_list - RRM_ONE; i ++ )
        {
            rrm_cell_ctx->operator_info.\
                freq_priority_list.eutran_freq_priority_list_info.eutran_freq_priority_info[i + RRM_ONE].carrier_freq =
                rrm_cell_ctx->ran_info.mobility_params.\
                idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[i].eutra_carrier_arfcn;

            rrm_cell_ctx->operator_info.\
                freq_priority_list.eutran_freq_priority_list_info.eutran_freq_priority_info[i + RRM_ONE].cell_reselection_priority =
                rrm_cell_ctx->ran_info.mobility_params.\
                idle_mode_mobility_params.idle_mode_mobility_inter_freq_params[i].cell_reselection_priority;

        }


        if (rrm_cell_ctx->ran_info.mobility_params.\
                idle_mode_mobility_params.bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
        {
            if (rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.\
                    idle_mode_mobility_irat_utra_params.bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT)
            {
                rrm_cell_ctx->operator_info.\
                    freq_priority_list.utran_freq_priority_list_info.count = 
                    rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                    irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers; 
                for(utran_fdd_count = RRM_ZERO; utran_fdd_count<= rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_fdd_list.num_irat_eutran_to_utran_fdd_carriers - RRM_ONE; utran_fdd_count ++ )
                {

                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.utran_freq_priority_list_info.utran_freq_priority_info[utran_fdd_count].carrier_freq =
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[utran_fdd_count].utra_carrier_arfcn;

                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.utran_freq_priority_list_info.utran_freq_priority_info[utran_fdd_count].cell_reselection_priority = 
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_fdd_list.irat_eutran_to_utran_fdd_carriers[utran_fdd_count].cell_reselection_priority;

                }
                utran_tdd_count = utran_fdd_count;
            }


            if (rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.\
                    idle_mode_mobility_irat_utra_params.bitmask & RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT)
            {
                rrm_cell_ctx->operator_info.\
                    freq_priority_list.utran_freq_priority_list_info.count += 
                    rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                    irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers; 

                for(i = RRM_ZERO;i<= rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_tdd_list.num_irat_eutran_to_utran_tdd_carriers - RRM_ONE; i ++ )
                {
                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.utran_freq_priority_list_info.utran_freq_priority_info[utran_tdd_count].carrier_freq = 
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[i].utra_carrier_arfcn;

                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.utran_freq_priority_list_info.utran_freq_priority_info[utran_tdd_count].cell_reselection_priority =
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_utra_params.\
                        irat_eutran_to_utran_tdd_list.irat_eutran_to_utran_tdd_carriers[i].cell_reselection_priority;
                    utran_tdd_count++;

                }

            }
        }

        if (rrm_cell_ctx->ran_info.mobility_params.\
                idle_mode_mobility_params.bitmask & RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)
        {
            if (rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.bitmask & 
                    RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT)
            {
                rrm_cell_ctx->operator_info.\
                    freq_priority_list.geran_freq_priority_list_info.count = 
                    rrm_cell_ctx->ran_info.mobility_params.\
                    idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.\
                    irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers; 

                for(i = RRM_ZERO;i<= rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.\
                        irat_eutran_to_geran_list.num_irat_eutran_to_geran_carriers - RRM_ONE; i ++ )
                {
                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.geran_freq_priority_list_info.geran_freq_priority_info[i].carrier_freq =
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.\
                        irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[i].geran_car_freqs;


                    rrm_cell_ctx->operator_info.\
                        freq_priority_list.geran_freq_priority_list_info.geran_freq_priority_info[i].cell_reselection_priority =
                        rrm_cell_ctx->ran_info.mobility_params.\
                        idle_mode_mobility_params.idle_mode_mobility_irat_geran_params.\
                        irat_eutran_to_geran_list.irat_eutran_to_geran_carriers[i].cell_reselection_priority;
                }
            }
        }


        if (rrm_cell_ctx->operator_info.bitmask & RRMCM_RMIF_FREQ_PRIORITY_LIST)
        {
            RRM_UT_TRACE_EXIT();
            return &(rrm_cell_ctx->operator_info.freq_priority_list);
        }
        else
        {
            RRM_UT_TRACE_EXIT();
            return RRM_PNULL;
        }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,"rrm_cell_ctx is null for cell index: %d",cell_index);
        /* SPR 21251 End */
    }
    RRM_UT_TRACE_EXIT();
	return RRM_PNULL;
    /*CID 65804:end*/
}


/****************************************************************************
 * Function Name  : rrm_cellm_get_spid_table_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : address of rrm_oam_spid_table_t 
 * Description    : returns address of the rrm_oam_spid_table_t
 ****************************************************************************/
rrm_oam_spid_table_t*
rrm_cellm_get_spid_table_params
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();

	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask & RRMCM_SPID_TABLE_PRESENT)
	{
		RRM_UT_TRACE_EXIT();
		return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.spid_table);
	}
	else
	{
		RRM_UT_TRACE_EXIT();
		return RRM_PNULL;
	}
}
/**************************************************************************
 * Function Name  : rrm_cellm_get_priority_cfg_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of priority_cfg_params
 * Description    : returns addess of priority_cfg_params
 **************************************************************************/

rrm_priority_cfg_t*
rrm_cellm_get_priority_cfg_params
(
 rrm_cell_index_t cell_index
 )
{
	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask & RRMCM_RMIF_PRIORITY_CFG)
	{
		return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.priority_cfg);
	}
	else
	{
		return RRM_PNULL;
	}
}
/**************************************************************************
 * Function Name  : rrm_cellm_daho_cell_config_info_params
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of daho_cell_config_info
 * Description    : returns addess of daho_cell_config_info_params
 **************************************************************************/

rrm_daho_cell_config_info_t*
rrm_cellm_get_daho_cell_config_info_params
(
 rrm_cell_index_t cell_index
 )
{
	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask & RRMCM_RMIF_DAHO_CELL_LIST)
	{
		return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.daho_cell_config_info);
	}
	else
	{
		return RRM_PNULL;
	}
}
/* BLR Inter RAT changes start */

/****************************************************************************
 * Function Name  : get_b1_trigger_quantity
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et	 get_b1_trigger_quantity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29657*/
	return ((rrm_trigger_quantity_et)p_rrm_cell_ctx->ho_parameters.b1_event_trigger_quantity);
}

/****************************************************************************
 * Function Name  : get_b2_utra_trigger_quantity
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et	 get_b2_utra_trigger_quantity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29659*/
    return ((rrm_trigger_quantity_et)p_rrm_cell_ctx->ho_parameters.b2_event_utran_trigger_quantity);
}
/****************************************************************************
 * Function Name  : get_b2_eutra_trigger_quantity
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et	 get_b2_eutra_trigger_quantity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29658*/
    return ((rrm_trigger_quantity_et)p_rrm_cell_ctx->ho_parameters.b2_event_utran_trigger_quantity);
}
/****************************************************************************
 * Function Name  : get_enable_ue_measurement
 * Inputs         : cell index
 * Outputs        : None
 * Returns        :
 * Description    : get enable_ue_measurement
 *                  that is stored in global context
 ****************************************************************************/
rrm_enable_ue_measurement_et  get_enable_ue_measurement
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return (p_rrm_cell_ctx->ho_parameters.rrm_enable_ue_measurement);
}
/*fix 866 start*/
/****************************************************************************
 * Function Name  : get_s_measure
 * Inputs         : cell index
 * Outputs        : None
 * Returns        :
 * Description    : get s_measure
 *                  that is stored in global context
 ****************************************************************************/
U8  get_s_measure
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return (p_rrm_cell_ctx->ho_parameters.s_measure);
}
/*fix 866 end*/
/****************************************************************************
 * Function Name  : get_b2_event_eutran_thresh_rsrx
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

U8	 get_b2_event_eutran_thresh_rsrx
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return (p_rrm_cell_ctx->ho_parameters.b2_event_eutran_thresh_rsrx);
}
/****************************************************************************
 * Function Name  : get_irat_offset
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

S8	 get_irat_offset
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return (p_rrm_cell_ctx->ho_parameters.irat_offset);
}


/* BLR Inter RAT changes end */
/****************************************************************************
 * Function Name  : get_a5_trigger_quantity
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : 
 * Description    : 
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et	 get_a5_trigger_quantity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29656*/
	return ((rrm_trigger_quantity_et) p_rrm_cell_ctx->ho_parameters.a5_event_trigger_quantity);
}

/****************************************************************************
 * Function Name  : get_delayed_a3_configure
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : rf_params
 * Description    : Returns the radio frequency params
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et  get_delayed_a3_configure
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29660*/
    return ((rrm_trigger_quantity_et)p_rrm_cell_ctx->ho_parameters.delayed_a3_enabled);
}


/****************************************************************************
 * Function Name  : get_a4_meas_cfg_enabled
 * Inputs         : cell index
 * Outputs        : None
 * Returns        :  1 if A4 Meas configurations are enabled otherwise 0
 * Description    : Returns the Measurement configurations  that is stored
 ****************************************************************************/
U8  get_a4_meas_cfg_enabled
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return (p_rrm_cell_ctx->ho_parameters.a4_meas_cfg_enabled);
}


/****************************************************************************
 * Function Name  : get_csfb_blind_timer_duration
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : duration for csfb timer stored otherwise 0
 * Description    : Returns the duration for csfb timer stored
 ****************************************************************************/
U16  get_csfb_blind_timer_duration
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return (p_rrm_cell_ctx->ho_parameters.csfb_blind_timer_duration);
}

/****************************************************************************
 * Function Name  : get_a3_a4_trigger_quantity
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : rf_params
 * Description    : Returns the radio frequency params 
 *                  that is stored in global context
 ****************************************************************************/

rrm_trigger_quantity_et	 get_a3_a4_trigger_quantity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
    /* coverity : CID 29655*/
	return ((rrm_trigger_quantity_et)p_rrm_cell_ctx->ho_parameters.a3_a4_event_trigger_quantity);
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_rf_params
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : rf_params
 * Description    : Returns the radio frequency params 
 *                  that is stored in global context
 ****************************************************************************/
rf_params_t	 *rrm_cellm_get_rf_params
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return &(p_rrm_cell_ctx->ran_info.rf_params);
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_ncl_info
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : ncl_info
 * Description    : Returns the ncl_info params 
 *                  that is stored in global context
 ****************************************************************************/
rrm_cell_context_t	 *rrm_cellm_get_cell_context
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    /*klok_fix_start_8554_8564*/
    /*CID 65848:start*/
    if ( cell_index < RRM_MAX_NUM_CELLS )
    /*CID 65848:end*/
    {
        p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    }
    /*klok_fix_end_8554_8564*/
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ncl_info
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : ncl_info
 * Description    : Returns the ncl_info params 
 *                  that is stored in global context
 ****************************************************************************/
ncl_params_t *rrm_cellm_get_ncl_info
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
#ifndef BLR_DEBUG
	return &(p_rrm_cell_ctx->ran_info.ncl_params);
#else
	if(p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info)
	{
		return p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info;
	}
#endif
}
/* BLR changes start */
/****************************************************************************
 * Function Name  : rrm_cellm_get_lte_ncl_info
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : ncl_info
 * Description    : Returns the lte_ncl_info params 
 *                  that is stored in global context
 ****************************************************************************/
lte_ncl_t *rrm_cellm_get_lte_ncl_info
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
#ifndef BLR_DEBUG
    if((RRMCM_RMIF_NCL_PARAMS_PRESENT & p_rrm_cell_ctx->ran_info.bitmask)&&
        RRMCM_RMIF_LTE_NCL_PRESENT & p_rrm_cell_ctx->ran_info.ncl_params.bitmask)
    {
	    return &(p_rrm_cell_ctx->ran_info.ncl_params.lte_ncl);
    }
    else
    {
        return RRM_PNULL;
    }
#else
	if(p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info)
	{
		return &(p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info->lte_ncl);
	}
#endif
}
/* BLR changes end */
/* SPR_15241_Start */
U32 rrm_cellm_get_dl_earfcn
(
 rrm_cell_index_t cell_index
)
{
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();

    if(RRM_PNULL != p_rrm_cell_ctx)
    {
         return p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn;
    }
    return RRM_ZERO;
}
/* SPR_15241_End */
/* BLR Inter RAT changes start */
/****************************************************************************
 * Function Name  : rrm_cellm_get_inter_rat_ncl_info
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : inter_rat_ncl_info
 * Description    : Returns the inter_rat_ncl_info params 
 *                  that is stored in global context
 ****************************************************************************/
inter_rat_ncl_t	 *rrm_cellm_get_inter_rat_ncl_info
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
#ifndef BLR_DEBUG
	return &(p_rrm_cell_ctx->ran_info.ncl_params.inter_rat_ncl);
#else
	if(p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info)
	{
		return &p_rrm_cell_ctx->p_ncl_built_from_updated_nrt_info->inter_rat_ncl;
	}
#endif
}
/* BLR Inter RAT changes End */
/****************************************************************************
 * Function Name  : rrm_cellm_get_operator_info
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : idle mode intra frequency parameters
 * Description    : Returns the idle mode intra frequency params 
 *                  that is stored in global context
 ****************************************************************************/
rrm_sib_type_3_info_t	 *rrm_cellm_get_sib3_info
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return &(p_rrm_cell_ctx->operator_info.sib_3_info);
}

/*CDMA2000 changes start*/
/****************************************************************************
 * Function Name  : rrm_cellm_get_ps_ho_flag
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : idle mode parameters
 * Description    : Returns the idle mode params
 *                  that is stored in global context
 ****************************************************************************/
U8
rrm_cellm_get_ps_ho_flag
(
    rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    RRM_UT_TRACE_EXIT();
    return (p_rrm_cell_ctx->ran_info.connected_mode_mobility_params.
            common_params_for_eutra.ps_ho_enabled);
}
/*CDMA2000 changes ends*/
/****************************************************************************
 * Function Name  : rrm_cellm_get_idle_mode_params
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : idle mode parameters
 * Description    : Returns the idle mode params 
 *                  that is stored in global context
 ****************************************************************************/
idle_mode_mobility_params_t *rrm_cellm_get_idle_mode_params
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return &(p_rrm_cell_ctx->ran_info.mobility_params.\
			idle_mode_mobility_params);
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_connected_mode_common_params
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : connected mode common mobility parameters 
 * Description    : Returns the connected mode common  mobility params 
 *                  that is stored in global context
 ****************************************************************************/
rrm_common_params_for_eutra_t*  rrm_cellm_get_connected_mode_common_params(
		rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return &(p_rrm_cell_ctx->ran_info.
			connected_mode_mobility_params.common_params_for_eutra);
}
/* BLR Inter RAT changes start */
/****************************************************************************
 * Function Name  : rrm_cellm_get_connected_mode_irat_params
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : connected mode irat parameters 
 * Description    : Returns the connected mode irat params 
 *                  that is stored in global context
 ****************************************************************************/
rrm_irat_params_t* rrm_cellm_get_connected_mode_irat_params(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];


	RRM_UT_TRACE_EXIT();
	return &(p_rrm_cell_ctx->ran_info.connected_mode_mobility_params.irat);
}
/* BLR Inter RAT changes end */

/* SPR 14509 start */
/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_gbr_abs_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently in use by GBR bearers
 * Description    : Returns downlink PRBs currently in use by GBR bearers maintained
 *                  in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_dl_gbr_abs_in_use
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->cell_resource_info.dl_gbr_absprb_in_use;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_ngbr_abs_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently in use by GBR bearers
 * Description    : Returns downlink PRBs currently in use by GBR bearers maintained
 *                  in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_dl_ngbr_abs_in_use
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->cell_resource_info.dl_ngbr_absprb_in_use;
}
/* SPR 14509 end */


/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_gbr_prb_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently in use by GBR bearers
 * Description    : Returns downlink PRBs currently in use by GBR bearers maintained
 *                  in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_dl_gbr_prb_in_use
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_gbr_prb_in_use;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_cell_thp_dl
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : dl cell throughput
 * Description    : dl cell throughput  maintained
 *                  in the cell context
 ****************************************************************************/
U64
rrm_cellm_get_cell_thp_dl
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.total_cell_thp_dl;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_cell_thp_ul
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : ul cell throughput
 * Description    : ul cell throughput  maintained
 *                  in the cell context
 ****************************************************************************/
U64
rrm_cellm_get_cell_thp_ul
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.total_cell_thp_ul;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_gbr_prb_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of uplink PRBs currently in use by GBR bearers
 * Description    : Returns uplink PRBs currently in use by GBR bearers maintained
 *                  in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_ul_gbr_prb_in_use
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_gbr_prb_in_use;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_ngbr_prb_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently in use by non GBR bearers
 * Description    : Returns downlink PRBs currently in use by non GBR bearers
 *                  maintained in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_dl_ngbr_prb_in_use
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_ngbr_prb_in_use;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_ngbr_prb_in_use
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of uplink PRBs currently in use by non GBR bearers
 * Description    : Returns uplink PRBs currently in use by non GBR bearers
 *                  maintained in the cell context
 ****************************************************************************/
U8
rrm_cellm_get_ul_ngbr_prb_in_use
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_ngbr_prb_in_use;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_allocated_gbr_prb
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently allocated to GBR bearers
 * Description    : Returns the no. of downlink PRBs currently allocated to GBR
 *                  bearers. The PRBs are allocated upon ERAB setup and modify
 *                  requests and are not yet reflected on the MAC/UE. When they
 *                  are applied on MAC/UE, the allocated PRBs are set to 0.
 ****************************************************************************/
/*SPR 18654 START*/
U64
/*SPR 18654 END*/
rrm_cellm_get_dl_allocated_gbr_prb
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_allocated_gbr_prb
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of uplink PRBs currently allocated to GBR bearers
 * Description    : Returns the no. of uplink PRBs currently allocated to GBR
 *                  bearers. The PRBs are allocated upon ERAB setup and modify
 *                  requests and are not yet reflected on the MAC/UE. When they
 *                  are applied on MAC/UE, the allocated PRBs are set to 0.
 ****************************************************************************/
/*SPR 18654 START*/
U64
/*SPR 18654 END*/
rrm_cellm_get_ul_allocated_gbr_prb
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_allocated_ngbr_prb
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs currently allocated to non GBR bearers
 * Description    : Returns the no. of downlink PRBs currently allocated to non
 *                  GBR bearers. The PRBs are allocated upon ERAB setup and modify
 *                  requests and are not yet reflected on the MAC/UE. When they
 *                  are applied on MAC/UE, the allocated PRBs are set to 0.
 ****************************************************************************/
/*SPR 18654 START*/
U64
/*SPR 18654 END*/
rrm_cellm_get_dl_allocated_ngbr_prb
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_allocated_ngbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_allocated_ngbr_prb
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of uplink PRBs currently allocated to non GBR bearers
 * Description    : Returns the no. of uplink PRBs currently allocated to non
 *                  GBR bearers. The PRBs are allocated upon ERAB setup and modify
 *                  requests and are not yet reflected on the MAC/UE. When they
 *                  are applied on MAC/UE, the allocated PRBs are set to 0.
 ****************************************************************************/
/*SPR 18654 START*/
U64
/*SPR 18654 END*/
rrm_cellm_get_ul_allocated_ngbr_prb
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_allocated_ngbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_num_prb_based_on_snr
 * Inputs         : cell index
 *                  SNR - for which the value has to be returned
 *                  is_uplink flag - indicates uplink or downlink
 * Outputs        : None
 * Returns        : no. of PRBs required per bits/sec
 * Description    : Returns the value from a mapping table between
 *                  MCS and SINR configured by the operator.
 ****************************************************************************/
U16
rrm_cellm_get_num_prb_based_on_snr
(
 rrm_cell_index_t cell_index,
 rrm_bool_et is_uplink
 )
{
	U16 num_prb_per_bps = RRM_ZERO;
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    if(RRM_TRUE == is_uplink)
    {
        num_prb_per_bps = p_rrm_cell_ctx->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps;
    }
    else
    {
        num_prb_per_bps = p_rrm_cell_ctx->operator_info.admission_control_info.snr_map.snr_dep_params.downlink_snr_dep_params.dl_prb_per_bps;
    }
    return num_prb_per_bps;
}
/*SPR 22151 Fix Start*/
/****************************************************************************
 * Function Name  : rrm_get_rb_factor_for_bitrate
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : RB Factor
 * Description    : Returns the value of rb_factor 
 *                  configured by the operator for a particular bitrate.
 ****************************************************************************/
/*SPR 18654 START*/
rrm_return_et
rrm_get_rb_factor_for_bitrate
(
 rrm_cell_index_t cell_index,
 U16 *p_rb_factor_for_bitrate
)
{
    rrm_cell_context_t *p_cell_context = rrm_cellm_get_cell_context (cell_index);
	/* CID 109684 fix Start */
	if(p_cell_context == RRM_PNULL)
	{
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"Cell Context is NULL ");
		RRM_UT_TRACE_EXIT();
		return RRM_FAILURE;
	}
	/* CID 109684 fix End */
    *p_rb_factor_for_bitrate = p_cell_context->operator_info.admission_control_info.rb_factor_for_bitrate;
    return RRM_SUCCESS;
}
/*SPR 18654 END*/

/****************************************************************************
 * Function Name  : rrm_convert_bitrate_to_prb_dl
 * Inputs         : rrm_ue_context_t *p_ue_context,
 * 		    rrm_prb_t dl_bitrate
 * Outputs        : PRB value
 * Returns        : Void 
 * Description    : Function to convert bitrate(in bps) to prb 
 ****************************************************************************/
rrm_prb_t rrm_convert_bitrate_to_prb_dl
(
   rrm_cell_index_t cell_index,
   rrm_prb_t dl_bitrate   
)
{
	rrm_prb_t dl_prb = RRM_ZERO;
    rrm_return_et ret = RRM_FAILURE;
	U16  rb_factor_for_bitrate = RRM_ZERO;
    ret = rrm_get_rb_factor_for_bitrate(cell_index,&rb_factor_for_bitrate);
    if(ret == RRM_FAILURE)
    {
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"rb_factor_for_bitrate not found ");
	    return dl_prb; 
    }
	rrm_cell_context_t *p_cell_context = PNULL;
	p_cell_context = rrm_cellm_get_cell_context (cell_index);
	dl_prb = (rrm_prb_t)RRM_CEIL((float)((get_dl_res_block_from_dl_bandwidth(p_cell_context)*
	rb_factor_for_bitrate * dl_bitrate ) /
        ((float)(rrm_cellm_get_num_prb_based_on_snr(cell_index, RRM_FALSE)* RRM_MEGA))));
	return dl_prb; 
}

/****************************************************************************
 * Function Name  : rrm_convert_bitrate_to_prb_ul
 * Inputs         : rrm_ue_context_t *p_ue_context,
 * 		    rrm_prb_t ul_bitrate
 * Outputs        : PRB value
 * Returns        : Void 
 * Description    : Function to convert bitrate(in bps) to prb 
 ****************************************************************************/
rrm_prb_t rrm_convert_bitrate_to_prb_ul
(
   rrm_cell_index_t cell_index,
   rrm_prb_t ul_bitrate   
)
{
	rrm_prb_t ul_prb = RRM_ZERO;
    rrm_return_et ret = RRM_FAILURE;
	U16  rb_factor_for_bitrate = RRM_ZERO;
    ret = rrm_get_rb_factor_for_bitrate(cell_index,&rb_factor_for_bitrate);
    if(ret == RRM_FAILURE)
    {
		RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
				"rb_factor_for_bitrate not found ");
	    return ul_prb; 
    }
	rrm_cell_context_t *p_cell_context = PNULL;
	p_cell_context = rrm_cellm_get_cell_context (cell_index);
	ul_prb = (rrm_prb_t)RRM_CEIL((float)((get_ul_res_block_from_ul_bandwidth(p_cell_context)*
		rb_factor_for_bitrate * ul_bitrate) /
		((float)(rrm_cellm_get_num_prb_based_on_snr(cell_index, RRM_TRUE)* RRM_MEGA))));
	return ul_prb; 
}
/*SPR 22151 Fix End*/

/****************************************************************************
 * Function Name  : rrm_cellm_init_rac_rbc_params
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the cell context parameters used by RAC and RBC
 *                  algorithms. Calculates and stores SRB budget PRBs, usable
 *                  PRBs for bearers and budgeted PRBs for GBR and NON GBR bearers
 *                  combined
 ****************************************************************************/
rrm_void_t
rrm_cellm_init_rac_rbc_params
(
 rrm_cell_context_t *p_rrm_cell_ctx
 )
{
	RRM_UT_TRACE_ENTER();
	U8 dl_srb_budget_prbs = RRM_ZERO;
	U8 ul_srb_budget_prbs = RRM_ZERO;


	/** Calculate the SRB prb budget and store in cell context */
	U64 srb_bitrate = p_rrm_cell_ctx->operator_info.admission_control_info.srb_bit_rate;

    /*SPR 22151 Fix Start*/
	dl_srb_budget_prbs = (U8)(p_rrm_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell *
    rrm_convert_bitrate_to_prb_dl(p_rrm_cell_ctx->cell_index,srb_bitrate));
	ul_srb_budget_prbs = (U8)(p_rrm_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell *
	rrm_convert_bitrate_to_prb_ul(p_rrm_cell_ctx->cell_index,srb_bitrate));
    /*SPR 22151 Fix End*/
	p_rrm_cell_ctx->cell_resource_info.dl_srb_budget_prb = dl_srb_budget_prbs;
	p_rrm_cell_ctx->cell_resource_info.ul_srb_budget_prb = ul_srb_budget_prbs;

	/** Calculate the usable prb budget and store in cell context */
	U8 dl_total_bw_prbs = p_rrm_cell_ctx->operator_info.admission_control_info.dl_total_bw_prbs;
	U8 dl_bw_for_control_prbs = p_rrm_cell_ctx->operator_info.admission_control_info.dl_bw_for_control_prbs;
    U8 dl_usable_bw_prb_for_bearers = dl_total_bw_prbs - dl_bw_for_control_prbs - dl_srb_budget_prbs;

	U8 ul_total_bw_prbs = p_rrm_cell_ctx->operator_info.admission_control_info.ul_total_bw_prbs;
    /*SPR 18654 START*/
    /*code deleted*/
    U8 ul_usable_bw_prb_for_bearers = ul_total_bw_prbs - ul_srb_budget_prbs;
    /* SPR_15537_Fix_Start */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "In DL: Usable BW PRBs (%d) , Total BW PRBs (%d) , Control PRBs (%d), SRB PRBs (%d)",
            dl_usable_bw_prb_for_bearers,dl_total_bw_prbs,dl_bw_for_control_prbs,dl_srb_budget_prbs);
    /* SPR_15537_Fix_End */


    /* SPR_15537_Fix_Start */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "In UL: Usable BW PRBs (%d) , Total BW PRBs (%d) , SRB PRBs (%d)",
            ul_usable_bw_prb_for_bearers,ul_total_bw_prbs,ul_srb_budget_prbs);
    /* SPR_15537_Fix_End */
    /*SPR 18654 START*/

	p_rrm_cell_ctx->cell_resource_info.dl_usable_bw_prb_for_bearers = dl_usable_bw_prb_for_bearers;
	p_rrm_cell_ctx->cell_resource_info.ul_usable_bw_prb_for_bearers = ul_usable_bw_prb_for_bearers;

	/** Calculate the budget for the common pool of prbs for allocation for both gbr and ngbr prbs */
	U8 dl_budget_gbr = (U8) (dl_usable_bw_prb_for_bearers *
			(p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_gbr/(float)RRM_PERCENTAGE));
	U8 dl_budget_ngbr = (U8) (dl_usable_bw_prb_for_bearers *
			(p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_ngbr/(float)RRM_PERCENTAGE));
	U8 ul_budget_gbr = (U8) (ul_usable_bw_prb_for_bearers *
			(p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_gbr/(float)RRM_PERCENTAGE));
	U8 ul_budget_ngbr = (U8) (ul_usable_bw_prb_for_bearers *
			(p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_ngbr/(float)RRM_PERCENTAGE));

	/*store dl/ul gbr/ngbr prbs in cell context*/
	p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_gbr = dl_budget_gbr;
	p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_ngbr = dl_budget_ngbr;
	p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_gbr = ul_budget_gbr;
	p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_ngbr = ul_budget_ngbr;

	/*calculate combined dl/ul gbr/ngbr prbs*/
	U8 dl_gbr_ngbr_budget = dl_usable_bw_prb_for_bearers - dl_budget_gbr - dl_budget_ngbr;
	U8 ul_gbr_ngbr_budget = ul_usable_bw_prb_for_bearers - ul_budget_gbr - ul_budget_ngbr;

	/*store combined dl/ul gbr/ngbr prbs in cell context*/
	p_rrm_cell_ctx->cell_resource_info.dl_prb_budget_gbr_ngnr_combined = dl_gbr_ngbr_budget;
	p_rrm_cell_ctx->cell_resource_info.ul_prb_budget_gbr_ngnr_combined = ul_gbr_ngbr_budget;
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_prb_budget_combined
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Downlink PRB allocation budget for GBR and Non GBR bearers
 * Description    : Getter function for Downlink PRB allocation budget for GBR
 *                  and Non GBR bearers.
 ****************************************************************************/
U8
rrm_cellm_get_dl_prb_budget_combined
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_prb_budget_gbr_ngnr_combined;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_prb_budget_combined
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Uplink PRB allocation budget for GBR and Non GBR bearers
 * Description    : Getter function for Uplink PRB allocation budget for GBR
 *                  and Non GBR bearers.
 ****************************************************************************/
U8
rrm_cellm_get_ul_prb_budget_combined
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_prb_budget_gbr_ngnr_combined;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_prb_budget_gbr
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Downlink PRB allocation budget for GBR bearers
 * Description    : Getter function for Downlink PRB allocation budget for GBR
 *                  bearers
 ****************************************************************************/
U8
rrm_cellm_get_dl_prb_budget_gbr
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_gbr;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_prb_budget_gbr
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Uplink PRB allocation budget for GBR bearers
 * Description    : Getter function for Uplink PRB allocation budget for GBR
 *                  bearers
 ****************************************************************************/
U8
rrm_cellm_get_ul_prb_budget_gbr
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_gbr;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_prb_budget_ngbr
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Downlink PRB allocation budget for Non GBR bearers
 * Description    : Getter function for Downlink PRB allocation budget for
 *                  Non GBR bearers
 ****************************************************************************/
U8
rrm_cellm_get_dl_prb_budget_ngbr
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.dl_prb_budget_ngbr;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_prb_budget_ngbr
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Uplink PRB allocation budget for Non GBR bearers
 * Description    : Getter function for Uplink PRB allocation budget for
 *                  Non GBR bearers
 ****************************************************************************/
U8
rrm_cellm_get_ul_prb_budget_ngbr
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.ul_prb_budget_ngbr;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ngbr_threshold
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Threshold in terms of UE-AMBR percentage for non GBR bearers
 * Description    : Getter function for Threshold in terms of UE-AMBR percentage
 *                  for non GBR bearers. The actual value used in algorithm
 *                  will be Threshold/10. Its actual value can range from 0.1
 *                  to 1 in steps of 0.1
 ****************************************************************************/
U8 
rrm_cellm_get_ngbr_threshold
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.ngbr_threshold;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_non_default_bearer_multiplier
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Multiplier to be used for all non-GBR bearers other than
 *                  the default bearer
 * Description    : Getter function for Multiplier to be used for all non-GBR
 *                  bearers other than the default bearer. The actual value
 *                  used in algorithm will be Multiplier/10. The actual value
 *                  may range from 0 to 1 in steps of 0.1
 ****************************************************************************/
U8
rrm_cellm_get_non_default_bearer_multiplier
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.non_default_bearer_multiplier;
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_minimum_bitrate
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Returns minimum UL/DL bitrate for NGBR bearers
 * Description    : Getter function for minimum bitrate that would be
 *                  allocated for all non-GBR bearers.
 ****************************************************************************/
U64
rrm_cellm_get_minimum_bitrate
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.minimum_bitrate;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_reserved_resource_factor
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : Returns percentage which would be used to calculate
 *                  reserved resources for existing users
 * Description    : Getter function for percentage factor
 ****************************************************************************/
U16
rrm_cellm_get_reserved_resource_factor
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.resource_reserved_for_existing_users;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_usable_bw_prb_for_bearers
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of downlink PRBs available for allocation to bearers
 * Description    : Getter function for no. of downlink PRBs available for
 *                  allocation to bearers
 ****************************************************************************/
U8
rrm_cellm_get_dl_usable_bw_prb_for_bearers
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.dl_usable_bw_prb_for_bearers;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_usable_bw_prb_for_bearers
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : no. of uplink PRBs available for allocation to bearers
 * Description    : Getter function for no. of uplink PRBs available for
 *                  allocation to bearers
 ****************************************************************************/
U8
rrm_cellm_get_ul_usable_bw_prb_for_bearers
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.ul_usable_bw_prb_for_bearers;
}

/****************************************************************************
 * Function Name  : rrm_cellm_set_dl_allocated_gbr_prb
 * Inputs         : cell index
 *                  dl_allocated_gbr_prb - allocated downlink PRBs for GBR
 *                                         bearers
 * Outputs        : None
 * Returns        : None
 * Description    : Setter function for storing the allocated downlink PRBs
 *                  for GBR bearers in the cell context
 ****************************************************************************/
rrm_void_t
rrm_cellm_set_dl_allocated_gbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 START*/
 U64 dl_allocated_gbr_prb
 /*SPR 18654 END*/
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	/*SPR 19819 START*/
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Allocating dl_prb = [%u]",dl_allocated_gbr_prb);
	/*SPR 19819 END*/
	RRM_UT_TRACE_EXIT();
	p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb = dl_allocated_gbr_prb;
}

/*spr 7466 start*/
/****************************************************************************
 * Function Name  : rrm_cellm_reset_dl_allocated_gbr_prb
 * Inputs         : cell index
 *                  dl_allocated_gbr_prb - allocated downlink PRBs for GBR
 *                                         bearers
 * Outputs        : None
 * Returns        : None
 * Description    : this function resets amount of dl gbr prbs during erb_release
 ****************************************************************************/
rrm_void_t
rrm_cellm_reset_dl_allocated_gbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 START*/
 U64 dl_allocated_gbr_prb
 /*SPR 18654 END*/
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    /*SPR 19819 START*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Deallocating dl_gbr_prbs(%u) from dl_allocated_gbr_prb [%u]",dl_allocated_gbr_prb,p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb);
    /*SPR 19819 END*/
    /* SPR-15991_3_5NOV Start */
    if((p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb != RRM_ZERO) && (p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb >= dl_allocated_gbr_prb))
    {
        p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb =
            (p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb - dl_allocated_gbr_prb);
    }
    else
    {
        p_rrm_cell_ctx->cell_resource_info.dl_allocated_gbr_prb =
            RRM_ZERO;

    }
    /* SPR-15991_3_5NOV End */

}

/****************************************************************************
 * Function Name  : rrm_cellm_reset_ul_allocated_gbr_prb
 * Inputs         : cell index
 *                  ul_allocated_gbr_prb - allocated uplink PRBs for GBR
 *                                         bearers
 * Outputs        : None
 * Returns        : None
 * Description    : this function resets amount of dl gbr prbs during
 erb_release
 ****************************************************************************/
rrm_void_t
rrm_cellm_reset_ul_allocated_gbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 START*/
 U64 ul_allocated_gbr_prb
 /*SPR 18654 END*/
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    /*SPR 19819 START*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
		    "Deallocating ul_gbr_prbs(%u) from ul_allocated_gbr_prb [%u]",
		    ul_allocated_gbr_prb,p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb);
    /*SPR 19819 END*/
    /* SPR-15991_3_5NOV Start */
    if((p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb!=RRM_ZERO) && (p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb >=   ul_allocated_gbr_prb))
    {
        p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb =
            p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb - ul_allocated_gbr_prb;
    }
    else
    {
        p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb =
            RRM_ZERO;

    }
    /* SPR-15991_3_5NOV End */
}
/*spr 7466 end*/
/****************************************************************************
 * Function Name  : rrm_cellm_set_ul_allocated_gbr_prb
 * Inputs         : cell index
 *                  ul_allocated_gbr_prb - allocated uplink PRBs for GBR
 *                                         bearers
 * Outputs        : None
 * Returns        : None
 * Description    : Setter function for storing the allocated uplink PRBs
 *                  for GBR bearers in the cell context
 ****************************************************************************/
rrm_void_t
rrm_cellm_set_ul_allocated_gbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 END*/
 U64 ul_allocated_gbr_prb
 /*SPR 18654 END*/
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	/*SPR 19819 START*/
	RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
			"Allocating dl_prb = [%u]",ul_allocated_gbr_prb);
	/*SPR 19819 END*/
	RRM_UT_TRACE_EXIT();
	p_rrm_cell_ctx->cell_resource_info.ul_allocated_gbr_prb = ul_allocated_gbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_set_dl_allocated_ngbr_prb
 * Inputs         : cell index
 *                  dl_allocated_ngbr_prb - allocated downlink PRBs for Non
 *                                          GBR bearers
 * Outputs        : None
 * Returns        : None
 * Description    : Setter function for storing the allocated downlink PRBs
 *                  for Non GBR bearers in the cell context
 ****************************************************************************/
rrm_void_t
rrm_cellm_set_dl_allocated_ngbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 START*/
 U64 dl_allocated_ngbr_prb
 /*SPR 18654 END*/
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	p_rrm_cell_ctx->cell_resource_info.dl_allocated_ngbr_prb = dl_allocated_ngbr_prb;
}

/****************************************************************************
 * Function Name  : rrm_cellm_set_ul_allocated_ngbr_prb
 * Inputs         : cell index
 *                  ul_allocated_ngbr_prb - allocated uplink PRBs for Non
 *                                          GBR bearers
 * Outputs        : None
 * Returns        : None
 * Description    : Setter function for storing the allocated uplink PRBs
 *                  for Non GBR bearers in the cell context
 ****************************************************************************/
rrm_void_t
rrm_cellm_set_ul_allocated_ngbr_prb
(
 rrm_cell_index_t cell_index,
 /*SPR 18654 START*/
 U64 ul_allocated_ngbr_prb
 /*SPR 18654 END*/
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	p_rrm_cell_ctx->cell_resource_info.ul_allocated_ngbr_prb = ul_allocated_ngbr_prb;
}
/*Bug_776_changes_start*/
/****************************************************************************
 * Function Name  : rrm_cellm_increment_dl_allocated_ngbr_prb_per_ue
 * Inputs         : cell index
 *                  ue_index
 *                  dl_allocated_ngbr_prb - allocated downlink PRBs for Non
 *                  GBR bearers per UE
 * Outputs        : None
 * Returns        : None
 * Description    : Incrementing function for storing the allocated downlink PRBs
 *                  for Non GBR bearers in the cell context
 *****************************************************************************/
rrm_void_t
rrm_cellm_increment_dl_allocated_ngbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               dl_allocated_ngbr_prb
 )
{
    RRM_UT_TRACE_ENTER();
    p_rrm_ue_context->allocated_info_per_ue.dl_allocated_ngbr_prb += dl_allocated_ngbr_prb;
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_cellm_increment_ul_allocated_ngbr_prb_per_ue
 * Inputs         : cell index
 *                  ue_index
 *                  ul_allocated_ngbr_prb - allocated uplink PRBs for Non
 *                  GBR bearers
 * Outputs        : None
 * Returns        : None
 * Description    : Increment function for storing the allocated uplink PRBs
 *                  for Non GBR bearers in the cell context
 *****************************************************************************/
rrm_void_t
rrm_cellm_increment_ul_allocated_ngbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               ul_allocated_ngbr_prb
 )
{
    RRM_UT_TRACE_ENTER();
    p_rrm_ue_context->allocated_info_per_ue.ul_allocated_ngbr_prb += ul_allocated_ngbr_prb;
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_ul_allocated_gbr_prb_per_ue
 * Inputs         : p_rrm_ue_context 
 *                  erab_id
 * Outputs        : None
 * Returns        : None
 * Description    : Returns the ul allocated gbr per ue  
 *****************************************************************************/
U8
rrm_cellm_get_ul_allocated_gbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               erab_id
 )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return(p_rrm_ue_context->allocated_info_per_ue.allocated_gbr_info_per_drb[erab_id].ul_allocated_gbr_prb);

}
/****************************************************************************
 * Function Name  : rrm_cellm_get_dl_allocated_gbr_prb_per_ue 
 * Inputs         : p_rrm_ue_context
 *                  erab_id
 * Outputs        : None
 * Returns        : None
 * Description    : Returns the dl allocated gbr per ue  
 *****************************************************************************/
U8
rrm_cellm_get_dl_allocated_gbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               erab_id
 )
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    return(p_rrm_ue_context->allocated_info_per_ue.allocated_gbr_info_per_drb[erab_id].dl_allocated_gbr_prb);
}

/****************************************************************************
 * Function Name  : rrm_cellm_decrement_ul_allocated_gbr_prb_per_ue 
 * Inputs         : p_rrm_ue_context
 *                  erab_id
 * Outputs        : None
 * Returns        : None
 * Description    : Decrements the ul allocated gbr per ue  
 *****************************************************************************/
rrm_void_t
rrm_cellm_decrement_ul_allocated_gbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               erab_id
 )
{
    RRM_UT_TRACE_ENTER();
    p_rrm_ue_context->allocated_info_per_ue.allocated_gbr_info_per_drb[erab_id].ul_allocated_gbr_prb = RRM_ZERO;
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_cellm_decrement_dl_allocated_gbr_prb_per_ue 
 * Inputs         : p_rrm_ue_context
 *                  erab_id
 * Outputs        : None
 * Returns        : None
 * Description    : Decrements the dl allocated gbr per ue  
 *****************************************************************************/
rrm_void_t
rrm_cellm_decrement_dl_allocated_gbr_prb_per_ue
(
 rrm_ue_context_t        *p_rrm_ue_context,
 U8               erab_id
 )
{
    RRM_UT_TRACE_ENTER();
    p_rrm_ue_context->allocated_info_per_ue.allocated_gbr_info_per_drb[erab_id].dl_allocated_gbr_prb = RRM_ZERO;
    RRM_UT_TRACE_EXIT();
}
/*Bug_776_changes_end*/

/*********************************************************
 * Function Name  : send_threshold_to_ind 
 * Inputs         : rrm_cell_context_t *p_cell_ctx
 *                : cell_son_attr_info_list_t  *p_attribute_info
 * Outputs        : None
 * Returns        : None
 * Description    : Send threshold Indication to MIF
 **********************************************************/
rrm_return_et
send_threshold_to_ind
(
 rrm_cell_context_t *p_cell_ctx,
 cell_son_attr_info_list_t  *p_attribute_info,  
 rrm_mif_cellm_message_resp_e resp
 )
{

	rrm_ue_count_threshold_reached_ind_t *p_threshold = RRM_PNULL; 
	rrm_return_et ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();     

	p_threshold = (rrm_ue_count_threshold_reached_ind_t *)
		rrm_mem_get(sizeof(rrm_ue_count_threshold_reached_ind_t));
	if (p_threshold == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_threshold failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    if((p_cell_ctx->cell_resource_info.num_active_ue > 
				p_attribute_info->p_ue_threshold->threshold_val )&&
			(p_attribute_info->p_ue_threshold->threshold_flag == RRM_FALSE)) 
	{

		p_threshold->cause = RRM_MIF_CELLM_THRESHOLD_CROSSED;
        p_attribute_info->p_ue_threshold->threshold_value_down_flag = RRM_FALSE;
		p_attribute_info->p_ue_threshold->threshold_flag = RRM_TRUE;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"threshold flag value:%d Num active Ue:%d Threshold Value:%d,Cause:%d",
				p_attribute_info->p_ue_threshold->threshold_flag,
				p_cell_ctx->cell_resource_info.num_active_ue,
				p_attribute_info->p_ue_threshold->threshold_val,
				p_threshold->cause);
		p_threshold->cellindex = p_cell_ctx->cell_index; 

		if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
					resp,
					sizeof(rrm_ue_count_threshold_reached_ind_t),
					(void *)p_threshold)) 
		{  
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"send state change ind for %d",
					p_cell_ctx->cell_index);
			ret_val = RRM_SUCCESS;
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"failure in sending state change ind for cell_index %d",
					p_cell_ctx->cell_index);
			ret_val = RRM_FAILURE;
		}
	}
	/*BUG:104 condition changed for threshold active ue indication 
	 * Indication shall be send: When active UE count becomes equal to 
	 * or less than the threshold value set
	 */
	if((p_cell_ctx->cell_resource_info.num_active_ue <= 
				p_attribute_info->p_ue_threshold->threshold_val)&&
			(p_attribute_info->p_ue_threshold->threshold_value_down_flag == RRM_FALSE))
	{
		p_attribute_info->p_ue_threshold->threshold_flag = RRM_FALSE;
        p_attribute_info->p_ue_threshold->threshold_value_down_flag = RRM_TRUE;
		p_threshold->cause = RRM_MIF_CELLM_BELOW_TH;
		p_threshold->cellindex = p_cell_ctx->cell_index; 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Threshold flag Value:%d Num active Ue:%d Threshold Value:%d,Cause:%d",
				p_attribute_info->p_ue_threshold->threshold_flag,
				p_cell_ctx->cell_resource_info.num_active_ue,
				p_attribute_info->p_ue_threshold->threshold_val,
				p_threshold->cause);

		if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
					resp,
					sizeof(rrm_ue_count_threshold_reached_ind_t),
					(void *)p_threshold)) 
		{  
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"send Threshold Indi for %d",p_cell_ctx->cell_index);
			ret_val = RRM_SUCCESS;
		}
		else
		{
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"failure in sending threshold ind for cell_index %d",
					p_cell_ctx->cell_index);
			ret_val = RRM_FAILURE;
		}
	}
    RRM_MEM_FREE(p_threshold);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_check_p_es_info
 * Inputs         : rrm_cell_context_t *cell_context
 *                : cell_son_attr_info_list_t *p_attribute_info
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    :check and send threshold to ind 
 ****************************************************************************/

/*klock_works_changes_start*/
rrm_return_et
rrm_check_p_es_info
(
 rrm_cell_context_t *p_rrm_cell_ctx,
 cell_son_attr_info_list_t *p_attribute_info
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if (p_rrm_cell_ctx->p_son_info->p_es_info != RRM_PNULL)
    {
        p_attribute_info = p_rrm_cell_ctx->p_son_info->p_es_info;
        if(p_attribute_info->p_ue_threshold != RRM_PNULL)
        {
            if(p_attribute_info->p_ue_threshold->flag_threshold_ue_threshold == RRM_TRUE)
            {
                /* send threshold ind to SON */
                ret_val =send_threshold_to_ind(p_rrm_cell_ctx,p_attribute_info,
                        RRMCM_RMIF_CELL_ACTIVE_THRESHOLD_REACHED_REPORT_FOR_ES_IND);
                if(ret_val == RRM_FAILURE)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"failed to send threshold INDto mif");
                    /* SPR 21251 End */
                }
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Threshold chng IND send for"
                        "cell index:%d",p_rrm_cell_ctx->cell_index);
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}
/*klock_works_changes_end*/
/****************************************************************************
 * Function Name  : rrm_cell_ue_threshold_rchd_ind 
 * Inputs         : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS\RRM_FAILURE
 * Description    : This function will check Son has register for ue_count_threshold
 *                  or not. if yes this function will send threshold ind to MIF
 ****************************************************************************/
rrm_return_et rrm_cell_ue_threshold_rchd_ind(
	rrm_cell_context_t* p_rrm_cell_ctx)
{
	cell_son_attr_info_list_t  *p_attribute_info = RRM_PNULL;
    rrm_return_et              ret_val           = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

	if (p_rrm_cell_ctx->p_son_info != RRM_PNULL)
	{
		if (p_rrm_cell_ctx->p_son_info->p_anr_info != RRM_PNULL)
		{
			p_attribute_info = p_rrm_cell_ctx->p_son_info->p_anr_info;
			if(p_attribute_info->p_ue_threshold != RRM_PNULL)
			{
				if(p_attribute_info->p_ue_threshold->flag_threshold_ue_threshold == RRM_TRUE)
				{
					/* send threshold ind to SON */
					ret_val =send_threshold_to_ind(p_rrm_cell_ctx,p_attribute_info,
							RRMCM_RMIF_CELL_ACTIVE_THRESHOLD_REACHED_REPORT_FOR_ANR_IND);
					if(ret_val == RRM_FAILURE)
					{
						RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"send threshold INDto mif");
					}
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"Threshold chng IND send for" 
							"cell index:%d",p_rrm_cell_ctx->cell_index);
				}
			}
		}

        /*klock_works_changes_start*/
        ret_val = rrm_check_p_es_info(p_rrm_cell_ctx, p_attribute_info);
        /*klock_works_changes_end*/

	}
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_increment_num_active_ue
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : Increments the no. of active UEs in the cell context
 ****************************************************************************/
rrm_return_et
rrm_cellm_increment_num_active_ue
(
 rrm_cell_index_t cell_index
 )
{
    /* SPR 21419 Fix Start */
    cell_timer_buf_t  timer_buf = {RRM_ZERO};
    QTIME   time;
    S32      Err;
    /* SPR 21419 Fix Stop */
	rrm_return_et              ret_val = RRM_SUCCESS;
    /*SPR21886 Start*/
    static rrm_bool_et         l2_kpi_req_sent[RRM_MAX_NUM_L2_INSTANCE] = {RRM_FALSE};
    /*SPR21886 End*/
	PdcpConfigureKpiStatsReqParams           p_pdcp_kpi_config={RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    /* SPR 21419 Fix Start */
    if(p_rrm_cell_ctx!= RRM_PNULL)
    {
        /* SPR 21419 Fix Stop */
        (p_rrm_cell_ctx->cell_resource_info.num_active_ue)++;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                "[CELL:%d] Active UE count incremented to %d",
                cell_index, p_rrm_cell_ctx->cell_resource_info.num_active_ue);
        /*BUG:769 start*/
        ret_val = rrm_cell_ue_threshold_rchd_ind(p_rrm_cell_ctx);
        /*BUG:769 end*/
        /*Radio Congestion Control Feature*/
        /*SPR21886 Start*/
        /* KPI configure request need to be sent per L2 instance basis only, so checking the l2_kpi_req_sent on instance basis */ 
        if((p_rrm_cell_ctx->operator_info.l2_instance < RRM_MAX_NUM_L2_INSTANCE) && (l2_kpi_req_sent[p_rrm_cell_ctx->operator_info.l2_instance] == RRM_FALSE))
        {
            l2_kpi_req_sent[p_rrm_cell_ctx->operator_info.l2_instance] = RRM_TRUE;/*Flag will be true No need to send req again*/
            /*SPR21886 End*/
            /* SPR 22420 Fix Start */
            ret_val = rrm_request_kpi_from_l2(
                    p_rrm_cell_ctx->operator_info.radio_cong_threshold.sampling_normal_time,
                    RRM_TRUE,
                    cell_index);
            /* SPR 22420 Fix End */
            /*Send message to pdcp for KPI throughput*/
            p_pdcp_kpi_config.kpiToReportBitMap = RRM_CELL_PDCP_KPI_THP_BITSET;/*Set the bitmask for THP*/
            p_pdcp_kpi_config.periodicReporting = RRM_TRUE;
            p_pdcp_kpi_config.durationT = RRM_CELL_TIME_DURATION_PDCP_KPI_THP; /*value in in terms of sec*/ 
            ret_val = rrm_send_pdcp_kpi_thp_req(&p_pdcp_kpi_config, 
                    RRM_MODULE_ID,
                    RRM_ZERO,
                    cell_index);
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cellm send PDCP_KPI_CONFIG_REQ to start CE detection");
        }

        /* SPR 21419 Fix Start */

        if((p_rrm_cell_ctx!= RRM_PNULL) &&
                (p_rrm_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM) &&
                (p_rrm_cell_ctx->operator_info.eicic_info.eicic_timer_info.aggressor_sel_timer) &&
                (p_rrm_cell_ctx->cell_resource_info.num_active_ue == RRM_ONE))
        {
            time.s  = p_rrm_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL];
            time.us = RRM_ZERO;
            timer_buf.cell_index = p_rrm_cell_ctx->cell_index;
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;

            p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                rrm_module_timer_start(RRM_CM_MODULE_ID, &time, &timer_buf, sizeof(cell_timer_buf_t), RRM_FALSE, &Err);

            p_rrm_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_rrm_cell_ctx->operator_info.eicic_info.
                eicic_timer_info.aggressor_sel_timer;
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Timer duration is [%d], Timer Type [%d]",
                    p_rrm_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL],CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL);

        }
        else
        {   
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Value of aggressor_sel_timer %d",p_rrm_cell_ctx->operator_info.eicic_info.eicic_timer_info.aggressor_sel_timer);
        }
    }
    /* SPR 21419 Fix Stop */

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_request_kpi_from l2
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : None
 * Description    : RRM shall send KPI stat req to L2
 ****************************************************************************/
rrm_return_et
rrm_request_kpi_from_l2
(
 U16 duration,
    rrm_bool_et periodic_reporting,
    U8  cell_index
 )
{
	rrm_return_et ret_val = RRM_SUCCESS; 
	MacConfigureKpiStatsReqParams l2_kpi_stats_req = {RRM_ZERO}; 

	RRM_UT_TRACE_ENTER();

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Sent KPI req to L2 with duration:[%d] periodic_reporting:[%d]",duration,periodic_reporting);
	/*Send L2 KPI Request*/
	l2_kpi_stats_req.durationT = duration; /*now the value will be in millisec */
	l2_kpi_stats_req.periodicReporting = periodic_reporting;
    /* SPR 13492 Changes start */
	l2_kpi_stats_req.kpiToReportBitMap = RRM_OUT_OF_RANGE_TWO_BYTE; /*Setting 11th bit for IN-SESSION KPI*/
    /* SPR 13492 Changes end */
	/* send message to L2 */

  ret_val = rrm_send_mac_kpi_req(&l2_kpi_stats_req, RRM_MODULE_ID,RRM_ZERO, cell_index); 
	if(ret_val == RRM_FAILURE)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Failed to Send to MAC_CONFIGURE_KPI_STATS_REQ L2");
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/* Spr 19647 Changes Start*/
/****************************************************************************
 * Function Name  : fill_Global_enb_plmn_id_for_eutran_cell
 * Inputs         : rrm_cell_context_t *cell_context
 *                : U8 count
 *                : U8 plmn[3]
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the PLMN ID of EUTRAN cell as per spec 36.413
 ****************************************************************************/
void
fill_Global_enb_plmn_id_for_eutran_cell
(
 rrm_cell_context_t *p_cell_ctx,
            /*SPR 17777 +-*/
 U8 plmn[RRM_THREE]
 )
{
    RRM_UT_TRACE_ENTER();

    plmn[RRM_ZERO]=p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_ONE];
    plmn[RRM_ZERO]=plmn[RRM_ZERO] << RRM_FOUR;
    plmn[RRM_ZERO]=plmn[RRM_ZERO] | (p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_ZERO]);
    
    plmn[RRM_ONE]= p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_TWO];


    if(p_cell_ctx->global_cell_id.primary_plmn_id.num_mnc_digit == RRM_MAX_NUM_MNC_DIGITS)
    {
	    plmn[RRM_TWO]=p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_TWO];
	    plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
	    plmn[RRM_TWO]=plmn[RRM_TWO] | (p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ONE]);
	    plmn[RRM_ONE]= plmn[RRM_ONE] |(p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ZERO]<< RRM_FOUR);

    }
    else if (p_cell_ctx->global_cell_id.primary_plmn_id.num_mnc_digit == (RRM_MAX_NUM_MNC_DIGITS-RRM_ONE))
    {
	    plmn[RRM_TWO]=p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ONE];
	    plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
	    plmn[RRM_TWO]=plmn[RRM_TWO] | (p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ZERO]);
	    plmn[RRM_ONE]= plmn[RRM_ONE] | RRM_HIGH_NIBBLE;
    }

    RRM_UT_TRACE_EXIT();
}
/* Spr 19647 Changes End*/


/*RIM changes start*/
/****************************************************************************
 * Function Name  : fill_plmn_id_for_eutran_cell
 * Inputs         : rrm_cell_context_t *cell_context
 *                : U8 count
 *                : U8 plmn[3]
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the PLMN ID of EUTRAN cell
 ****************************************************************************/
void
fill_plmn_id_for_eutran_cell
(
 rrm_cell_context_t *p_cell_ctx,
            /*SPR 17777 +-*/
 U8 plmn[RRM_THREE]
 )
{
    RRM_UT_TRACE_ENTER();

    /* SPR 18010 Fix Start */
    plmn[RRM_ZERO]=RRM_EVENT_U16_INVALID_VALUE;
    plmn[RRM_ZERO]=p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_ONE];
    plmn[RRM_ZERO]=plmn[RRM_ZERO] << RRM_FOUR;
    plmn[RRM_ZERO]=plmn[RRM_ZERO] | (p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_ZERO]);
    
    plmn[RRM_ONE]=RRM_EVENT_U16_INVALID_VALUE;
    plmn[RRM_ONE]= p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_TWO];

    plmn[RRM_TWO]=p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ONE];
    plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
    plmn[RRM_TWO]=plmn[RRM_TWO] | (p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_ZERO]);

    if(p_cell_ctx->global_cell_id.primary_plmn_id.num_mnc_digit == RRM_MAX_NUM_MNC_DIGITS)
    {
        plmn[RRM_ONE]= plmn[RRM_ONE] & p_cell_ctx->global_cell_id.primary_plmn_id.mnc[RRM_TWO];
        plmn[RRM_ONE]= plmn[RRM_ONE] << RRM_FOUR;
        plmn[RRM_ONE]= plmn[RRM_ONE] | (p_cell_ctx->global_cell_id.primary_plmn_id.mcc[RRM_TWO]);

    }
/* Spr 19647 Changes Start*/
    else
/* Spr 19647 Changes End*/
    {
        plmn[RRM_ONE]= plmn[RRM_ONE] | RRM_HIGH_NIBBLE;
    }
    /* SPR 18010 Fix Stop */

    RRM_UT_TRACE_EXIT();
}

/* Spr 19647 Changes Start*/
/* Code Deleted */ 
/* Spr 19647 Changes End*/

 /* Spr 19647 Changes Start*/
/****************************************************************************
 * Function Name  : fill_plmn_id_for_utran_geran_cell
 * Inputs         : plmn_identity_t *plmn_identity
 *                : U8 count
 *                : U8 plmn[3]
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the PLMN ID of UTRAN  and GERAN cell as TS 3GPP TS 24.008 -10.5.5.15
 *                : Routing area identification  
 ****************************************************************************/
void
fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE
(
 /* Spr 16211 Changes Start*/
plmn_identity_t *p_plmn_identity, 

/* Spr 16211 Changes End*/
 U8 plmn[RRM_THREE]
 )
{
    RRM_UT_TRACE_ENTER();

    /* SPR_11740_FIX_START */
    plmn[RRM_ZERO]=RRM_EVENT_U16_INVALID_VALUE;
 /* Spr 16211 Changes Start*/
    if(p_plmn_identity->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
    {
        plmn[RRM_ZERO]=p_plmn_identity->mcc[RRM_ONE];
        plmn[RRM_ZERO]=plmn[RRM_ZERO] << RRM_FOUR;
        plmn[RRM_ZERO]=plmn[RRM_ZERO] | (p_plmn_identity->mcc[RRM_ZERO]);
        plmn[RRM_ONE]= p_plmn_identity->mcc[RRM_TWO];
    }

    plmn[RRM_TWO]=p_plmn_identity->mnc.mnc[RRM_ONE];
    plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
    plmn[RRM_TWO]=plmn[RRM_TWO] | (p_plmn_identity->mnc.mnc[RRM_ZERO]);

    if(p_plmn_identity->mnc.count == RRM_MAX_NUM_MNC_DIGITS)
    {
        plmn[RRM_ONE]= plmn[RRM_ONE] | (p_plmn_identity->mnc.mnc[RRM_TWO] << RRM_FOUR);

    }
    else if ((p_plmn_identity->mnc.count) == (RRM_MAX_NUM_MNC_DIGITS-RRM_ONE))
    {
        plmn[RRM_ONE]= plmn[RRM_ONE] | RRM_HIGH_NIBBLE;
    }
 /* Spr 19647 Changes End*/
/* Spr 16211 Changes End*/


    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name  : fill_plmn_id_for_utran_cell
 * Inputs         : rrm_cell_context_t *cell_context
 *                : U8 count
 *                : U8 plmn[3]
 * Outputs        : None
 * Returns        : None
 * Description    : Fills the PLMN ID of UTRAN cell
 ****************************************************************************/
void
fill_plmn_id_for_utran_cell
(
 /* Spr 16211 Changes Start*/
/* Spr 19647 Changes Start*/
plmn_identity_t *plmn_identity, 
/* Spr 19647 Changes End*/
 
/* Spr 16211 Changes End*/
 U8 plmn[RRM_THREE]
 )
{
    RRM_UT_TRACE_ENTER();
    /* SPR_11740_FIX_START */
/* Spr 19647 Changes Start*/
 /* Spr 16211 Changes Start*/
    if(plmn_identity->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
    {
        plmn[RRM_ZERO]=plmn_identity->mcc[RRM_ONE];
        plmn[RRM_ZERO]=plmn[RRM_ZERO] << RRM_FOUR;
        plmn[RRM_ZERO]=plmn[RRM_ZERO] | (plmn_identity->mcc[RRM_ZERO]);
        plmn[RRM_ONE]= plmn_identity->mcc[RRM_TWO];
    }

    if(plmn_identity->mnc.count == RRM_MAX_NUM_MNC_DIGITS)
    {
        plmn[RRM_TWO]=plmn_identity->mnc.mnc[RRM_TWO];
        plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
        plmn[RRM_TWO]=plmn[RRM_TWO]|(plmn_identity->mnc.mnc[RRM_ONE]);
        plmn[RRM_ONE]= plmn[RRM_ONE] | (plmn_identity->mnc.mnc[RRM_ZERO] << RRM_FOUR);

    }
    else if ((plmn_identity->mnc.count) == (RRM_MAX_NUM_MNC_DIGITS-RRM_ONE))
    {
        plmn[RRM_TWO]=plmn_identity->mnc.mnc[RRM_ONE];
        plmn[RRM_TWO]=plmn[RRM_TWO] << RRM_FOUR;
        plmn[RRM_TWO]=plmn[RRM_TWO]|(plmn_identity->mnc.mnc[RRM_ZERO]);
        plmn[RRM_ONE]= plmn[RRM_ONE] | RRM_HIGH_NIBBLE;
    }
 /* Spr 19647 Changes End*/
/* Spr 16211 Changes End*/
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name  : rrm_check_cell_context_and_fsm_event
 * Inputs         : rrm_cell_index_t  cell_index
 *                : rim_information_t *p_rim_info
 *                : U16               api_id
 *                : rrm_return_et     *ret_val
 * Outputs        : None
 * Returns        : SUCCESS/FAILURE
 * Description    : check and find the fsm event
 ****************************************************************************/

/*klock_works_changes_start*/
rrm_return_et
rrm_check_cell_context_and_fsm_event
(
 rrm_cell_index_t  cell_index,
 rim_information_t *p_rim_info,
 U16               api_id,
 rrm_return_et     *ret_val
 )

{
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RIM info resp For Cell Index :%d",
            cell_index);

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "cell context in null for cell index: %d", cell_index);
        /* SPR 21251 End */
        /* SPR: 15922 Fix start */
        *ret_val =  RRM_FAILURE;
    }
    else
    {
        /* SPR: 15922 Fix End */
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info =
            (void *)p_rim_info;

        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =
            S1AP_RRM_RIM_INFO;
        if (RRM_FAILURE == cellm_fsm_process_event(
                    RRC_RRM_RIM_INFO_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "unable to process api:%d ",api_id);
            *ret_val = RRM_FAILURE;
        }
        else

        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "successfully processed api:%d ",api_id);
            *ret_val = RRM_SUCCESS;
        }
        /* SPR: 15922 Fix Start */
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
    }
    /* SPR: 15922 Fix End */
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*klock_works_changes_end*/

/****************************************************************************
 * Function Name  : rrm_rrc_rim_info_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *            : U16 api_id :api id
 *        : U16 data_len : data length
 *        : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rim_info_resp from RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_rim_info_process_msg(
        U8 *p_api, /* Pointer to incoming Api buffer*/
        U16 api_id, /* incoming api id*/
        U16 data_len /* incoming data length*/
            /*SPR 17777 +-*/
        )
{
    rrm_cell_index_t  cell_index=RRM_ZERO;
    S32  length = RRM_ZERO;
    rrm_return_et   ret_val = RRM_FAILURE;
    rim_information_t *p_rim_info = RRM_PNULL;

    SET_CELL_INDEX(cell_index);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"RRC->S1AP_RRM_RIM_INFO->CellM");
    RRM_UT_TRACE_ENTER();
    /*SPR 20553 FIX START */     
    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "CELL context is NULL for cell index [%d] hence returning RRM_FAILURE ", cell_index);
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*SPR 20553 FIX END */

    p_rim_info = (rim_information_t *)rrm_mem_get(sizeof
            (rim_information_t));
    if (p_rim_info == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_rim_info failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    /*klock_works_changes_start*/
      /* Parse  the incoming message from RRC */
    if (RRM_SUCCESS == rrm_il_parse_rim_information(
                p_rim_info,
                p_api,
                data_len,
                &length))
    {
        if(RRM_FAILURE==rrm_check_cell_context_and_fsm_event(cell_index, p_rim_info,api_id,&ret_val))
        { 
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "failure reurned from rrm_check_cell_context_and_fsm_event for cell index: %d",
                    cell_index);
            /* SPR 21251 End */
            return RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "unable to parse api:%d ",api_id);
        ret_val = RRM_FAILURE;
    }
    
    /*klock_works_changes_end*/
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = RRM_PNULL;
    RRM_MEM_FREE(p_rim_info);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_check_for_stale_rsn
 * Inputs         : U32 rsn_recd 
 *                : U32 rsn_prev
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : Checks if sequence number is not used
 ****************************************************************************/
rrm_bool_t
rrm_check_for_stale_rsn
(
 U32 rsn_recd,
 U32 rsn_prev
 )
{
    rrm_bool_t status = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    if(((rsn_recd - rsn_prev) % RRM_MAX_RSN) < RRM_MAX_RSN_BY_2)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "seq no. received is valid");
        status = RRM_FALSE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "same seq no. received as previous one or invalid seq no. received");
        status = RRM_TRUE;

    }

    RRM_UT_TRACE_EXIT();
    return status;
}

/****************************************************************************
 * Function Name  : rrm_send_rim_ack
 * Inputs         : U8 count
 *                : rim_app_identity_t app_id
 *                : rrm_cell_context_t *p_cell_ctx
 * Outputs        : None
 * Returns        : None
 * Description    : Build and sends rim ack message
 ****************************************************************************/
void
rrm_send_rim_ack
(
 U8 count,
 rim_app_identity_t app_id,
 rrm_cell_context_t *p_cell_ctx
 )
{
    rrm_return_et       ret_val = RRM_SUCCESS;
    rim_information_ack_t rim_info_ack;
    U32 *p_temp_cell_identity = RRM_PNULL; 
    RRM_UT_TRACE_ENTER();

    RRM_MEMSET(&rim_info_ack, RRM_ZERO, sizeof(rim_information_ack_t));

    rim_info_ack.app_idty = app_id;
    rim_info_ack.ver = RRM_ONE;
    rim_info_ack.bitmask |= RIM_INFO_ACK_PROTOCOL_VER_PRESENT;

    p_temp_cell_identity = (U32 *)p_cell_ctx->global_cell_id.cell_identity;
    if(app_id == RIM_UTRA_SI_APP)
    {
        U8 plmn[RRM_THREE];
        rim_info_ack.ver = RRM_ONE;
        rim_info_ack.bitmask |= RIM_INFO_ACK_PROTOCOL_VER_PRESENT;
        rim_info_ack.bitmask |= RIM_INFO_ACK_MME_ID_PRESENT;
        rim_info_ack.mme_id = RRM_ZERO;
        rim_info_ack.seq_num = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
            utran_freq_cells[count].last_recd_rsn;
        rim_info_ack.dst_cell.bitmask |= RIM_UTRAN_ROUTING_ADDR_PRESENT;
        rim_info_ack.dst_cell.utran_rtng_addr.rnc_id[RRM_ZERO] =
            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
            uc_id.rnc_id >> RRM_EIGHT;
        rim_info_ack.dst_cell.utran_rtng_addr.rnc_id[RRM_ONE] =
            ((p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
              uc_id.rnc_id << RRM_EIGHT)>> RRM_EIGHT);
        RRM_MEMCPY(rim_info_ack.dst_cell.utran_rtng_addr.routing_idty.lac,
                p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rai.
                lai.lac, (MAX_LAC_SIZE*sizeof(U8)));
        rim_info_ack.dst_cell.utran_rtng_addr.routing_idty.rac =
            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rai.rac;
        /*filling plmn_id of dst_cell*/
        /* Spr 16211 Changes Start*/
        /* Spr 19647 Changes Start*/
        fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].rai.lai.plmn_identity,plmn);
        /* Spr 19647 Changes End*/
        /* Spr 16211 Changes End*/
        RRM_MEMCPY(rim_info_ack.dst_cell.utran_rtng_addr.routing_idty.plmn.plmn, plmn, (RRM_THREE*sizeof(U8)));
        rim_info_ack.src_cell.bitmask |= RIM_EUTRAN_ROUTING_ADDR_PRESENT;
        /* SPR 18353 Fix Start */
        if(p_cell_ctx->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
        {
            if (p_cell_ctx->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN)
            {
                rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
            }
            else
            {
                rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_HOME_ENB;
            }
        }
        else
        {
            rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
        }
        /* SPR 18353 Fix Stop */

        rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_id =
            RRM_NTOHL(*(p_temp_cell_identity));
        /*filling PLMN id of dest cell under enb*/
	/* Spr 19647 Changes Start*/
	fill_Global_enb_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 */
	/* Spr 19647 Changes End*/
        RRM_MEMCPY(rim_info_ack.src_cell.eutran_rtng_addr.enb.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
        RRM_MEMCPY(&rim_info_ack.src_cell.eutran_rtng_addr.ta_idty.tac,
                p_cell_ctx->epc_info.epc_params.general_epc_params.tac, sizeof(U16));
        fill_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 +-*/
	/* Spr 19647 Changes End*/
        /*filling PLMN id of dest cell under ta_idty*/
        RRM_MEMCPY(rim_info_ack.src_cell.eutran_rtng_addr.ta_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

    }
    else if (app_id == RIM_NACC_APP)
    {
        U8 plmn[RRM_THREE];
        rim_info_ack.ver = RRM_ONE;
        rim_info_ack.bitmask |= RIM_INFO_ACK_PROTOCOL_VER_PRESENT;
        rim_info_ack.bitmask |= RIM_INFO_ACK_MME_ID_PRESENT;
        rim_info_ack.mme_id = RRM_ZERO;
        rim_info_ack.seq_num = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
            geran_freq_cells[count].last_recd_rsn;
        rim_info_ack.dst_cell.bitmask |= RIM_GERAN_ROUTING_ADDR_PRESENT;
        rim_info_ack.dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ZERO] =
            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
            geran_freq_cells[count].cell_id >> RRM_EIGHT;
        rim_info_ack.dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ONE] =
            ((p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
              cell_id << RRM_EIGHT) >> RRM_EIGHT);

        RRM_MEMCPY(rim_info_ack.dst_cell.geran_rtng_addr.routing_idty.lac,
                p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                lai.lac, (MAX_LAC_SIZE*sizeof(U8)));
        /*filling plmn_id of dst_cell*/
        /* Spr 16211 Changes Start*/
        /* Spr 19647 Changes Start*/
        fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].lai.plmn_identity, plmn);
        /* Spr 19647 Changes End*/
        /* Spr 16211 Changes End*/
	/* SPR 19327 Fix Start*/
	if (RRM_GERAN_FREQ_CELL_RAC_PRESENT & p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].bitmask)
	{
		rim_info_ack.dst_cell.geran_rtng_addr.routing_idty.rac = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].rac;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
				"RAC is not present");
	}
	/* SPR 19327 Fix Stop*/
        RRM_MEMCPY(rim_info_ack.dst_cell.geran_rtng_addr.routing_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
        rim_info_ack.src_cell.bitmask |= RIM_EUTRAN_ROUTING_ADDR_PRESENT;
        /* SPR 18353 Fix Start */
        if(p_cell_ctx->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
        {
            if (p_cell_ctx->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN)
            {
                rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
            }
            else
            {
                rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_HOME_ENB;
            }
        }
        else
        {
            rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
        }
        /* SPR 18353 Fix Stop */

        rim_info_ack.src_cell.eutran_rtng_addr.enb.enb_id =
            RRM_NTOHL(*(p_temp_cell_identity));
        /*filling PLMN id of dest cell under enb*/
	/* Spr 19647 Changes Start*/
	fill_Global_enb_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 */
        RRM_MEMCPY(rim_info_ack.src_cell.eutran_rtng_addr.enb.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
	/*coverity 25200,25208: range of data to copy changed to 2 bytes, aditya, rel1.3.1*/
        RRM_MEMCPY(&rim_info_ack.src_cell.eutran_rtng_addr.ta_idty.tac,
                p_cell_ctx->epc_info.epc_params.general_epc_params.tac, MAX_TAC_SIZE*sizeof(U8));
        fill_plmn_id_for_eutran_cell(p_cell_ctx,plmn);/*SPR 17777 +-*/
	/* Spr 19647 Changes End*/
        //gur30784 Need to fill PLMN id of dest cell under ta_idty
        RRM_MEMCPY(rim_info_ack.src_cell.eutran_rtng_addr.ta_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
    }
    ret_val = rrm_send_rim_ack_to_l3(p_cell_ctx, &rim_info_ack);
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_ERROR,
                "Failed to Send RIM_INFO_ACK to RRC");
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_request_rim_info_req_inter_rat_ncl
 * Inputs         : rrm_cell_context_t *p_cell_ctx
 *                : U8 pdu_ext_type
 * Outputs        : None
 * Returns        : rrm_return_et
 * Description    : Build and sends rim info req message
 ****************************************************************************/
rrm_return_et
rrm_request_rim_info_req_inter_rat_ncl(rrm_cell_context_t     *p_cell_ctx ,
                                       rim_information_req_t  *rim_info_req ,
                                       U32                    *p_temp_cell_identity ,
                                       U8                     pdu_ext_type)
{
    U8 count = RRM_ZERO;
    U8 num_cells = RRM_ZERO;
    rrm_return_et       ret_val = RRM_FAILURE;
    
    RRM_UT_TRACE_ENTER();

        num_cells = p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.num_valid_geran_cell;
        for(count = RRM_ZERO; count < num_cells; count++)
        {
            if(RRM_PNULL == p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
                geran_freq_cells[count].rim_geran_info)
            {
                p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                  rim_geran_info = (rrm_rim_geran_info_t*)rrm_mem_get(sizeof(rrm_rim_geran_info_t));
                if (  p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                  rim_geran_info == RRM_PNULL)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to  p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].\
                            rim_geran_info failed" );
                    /* SPR 21251 End */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                } 
            }

        RRM_MEMSET(rim_info_req, RRM_ZERO, sizeof(rim_information_req_t));
        U8 plmn[RRM_THREE];
        rim_info_req->mme_id = RRM_ZERO;
        rim_info_req->dst_cell.bitmask |= RIM_GERAN_ROUTING_ADDR_PRESENT;
        rim_info_req->dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ZERO] =
            p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.
            geran_freq_cells[count].cell_id >> RRM_EIGHT;
        rim_info_req->dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ONE] =
            ((p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
              cell_id << RRM_EIGHT) >> RRM_EIGHT);

        RRM_MEMCPY(rim_info_req->dst_cell.geran_rtng_addr.routing_idty.lac,
                    p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                    lai.lac, (MAX_LAC_SIZE*sizeof(U8)));
            /* plmn_id of dst_cell*/
        /* Spr 16211 Changes Start*/
        /* Spr 19647 Changes Start*/
        fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].lai.plmn_identity, plmn);
        /* Spr 19647 Changes End*/
        /* Spr 16211 Changes End*/
        RRM_MEMCPY(rim_info_req->dst_cell.geran_rtng_addr.routing_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
        rim_info_req->src_cell.bitmask |= RIM_EUTRAN_ROUTING_ADDR_PRESENT;
        /* SPR_11740_FIX_START */
        rim_info_req->src_cell.eutran_rtng_addr.enb.enb_type = (U8)p_g_rrm_cell_ctx->enb_context.enb_id.enb_type;
        rim_info_req->src_cell.eutran_rtng_addr.enb.enb_id = RRM_NTOHL(*(p_temp_cell_identity));

        RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_DETAILED, "Cell Id[0x%x], [0x%x]. eNbId[0x%x]",
                *p_temp_cell_identity, RRM_NTOHL(*(p_temp_cell_identity)), rim_info_req->src_cell.eutran_rtng_addr.enb.enb_id);
            /* SPR_11740_FIX_END */

            /*PLMN id of src cell under enb*/
            fill_plmn_id_for_eutran_cell(p_cell_ctx,plmn);/*SPR 17777 +-*/
        RRM_MEMCPY(rim_info_req->src_cell.eutran_rtng_addr.enb.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
        RRM_MEMCPY(&rim_info_req->src_cell.eutran_rtng_addr.ta_idty.tac,
                    p_cell_ctx->epc_info.epc_params.general_epc_params.tac, sizeof(U16));
            /* PLMN id of src cell under ta_idty*/
        RRM_MEMCPY(rim_info_req->src_cell.eutran_rtng_addr.ta_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

        rim_info_req->app_idty = RIM_NACC_APP;
        rim_info_req->seq_num = RRM_INCREMENT_RSN(p_cell_ctx->cur_rsn);
        p_cell_ctx->cur_rsn++;

        rim_info_req->pdu_ind.pdu_ext = pdu_ext_type;
        rim_info_req->pdu_ind.ack = RIM_NO_ACK_REQUESTED;
        rim_info_req->ver = RRM_ONE;
        rim_info_req->bitmask |= RIM_INFO_REQ_PROTOCOL_VER_PRESENT;
        rim_info_req->bitmask |= RIM_INFO_REQ_APP_CONTAINER_PRESENT;
        rim_info_req->bitmask |= RIM_INFO_REQ_MME_ID_PRESENT;

        ret_val = rrm_send_rim_req (p_cell_ctx, rim_info_req);
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_ERROR,
                        "Failed to Send RIM_INFO_REQ to RRC");
                RRM_MEM_FREE(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].
                    rim_geran_info);
            }

        }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrm_request_rim_info_req
 * Inputs         : rrm_cell_context_t *p_cell_ctx
 *                : U8 pdu_ext_type
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Build and sends rim info req message
 ****************************************************************************/
rrm_return_et
rrm_request_rim_info_req
(
 rrm_cell_context_t *p_cell_ctx,
 /* Spr 16211 Changes Start*/
 inter_rat_ncl_t *p_inter_rat_ncl, 
 /* Spr 16211 Changes End*/
 U8 pdu_ext_type
 )
{
    rrm_return_et       ret_val = RRM_FAILURE;
    rim_information_req_t  rim_info_req = {RRM_ZERO};
    /* Spr 16211 Changes Start*/
    /* Variable removed */
    /* Spr 16211 Changes End*/
    U8 count = RRM_ZERO;
    U32 *p_temp_cell_identity = RRM_PNULL; 
    /* Spr 16211 Changes Start*/
    /* SPR-19167 START */
    U8 plmn[MAX_PLMN_ID_BYTES] = {0};
    /* SPR-19167 END */
    /* Spr 16211 Changes End*/

    RRM_UT_TRACE_ENTER();
    p_temp_cell_identity = (U32 *)p_cell_ctx->global_cell_id.cell_identity;

    /* SPR-19167 START */
    rrm_bool_et mme_found = RRM_FALSE;
    U8 loop = RRM_ZERO;
    rrm_connected_mme_node_t *p_rrm_connected_mme_node = RRM_NULL;

    rrm_oam_cell_plmn_info_t plmn_id;
    U8 plmn_id_out[MAX_PLMN_ID_BYTES] = {RRM_ZERO};
    /* SPR-19167 END */

    /* Spr 16211 Changes Start*/
    /* SPR-19167 START */
    for(count = RRM_ZERO; count < p_inter_rat_ncl->num_valid_geran_cell; count++)
    {
        p_rrm_connected_mme_node = (rrm_connected_mme_node_t*)ylFirst(&p_g_rrm_cell_ctx->enb_context.connected_mme_list);
        RRM_MEMSET(&plmn_id, RRM_ZERO, sizeof(rrm_oam_cell_plmn_info_t));
        RRM_MEMCPY(&plmn_id.mcc, &p_inter_rat_ncl->geran_freq_cells[count].lai.plmn_identity.mcc, MAX_MCC_DIGITS);
        RRM_MEMCPY(&plmn_id.mnc, &p_inter_rat_ncl->geran_freq_cells[count].lai.plmn_identity.mnc.mnc, MAX_MNC_DIGITS);
        plmn_id.num_mnc_digit = p_inter_rat_ncl->geran_freq_cells[count].lai.plmn_identity.mnc.count;
        rrm_plmnid_from_mcc_mnc(plmn_id_out, &plmn_id);
        while (RRM_PNULL != p_rrm_connected_mme_node)
        {
                /* SPR-19167 START */
                mme_found = RRM_FALSE;
		/* SPR-19167 END */
            for (loop = RRM_ZERO; loop < p_rrm_connected_mme_node->connected_gummei_info.num_served_plmns; loop++)
            {
                if (!RRM_MEMCMP(plmn_id_out, p_rrm_connected_mme_node->connected_gummei_info.plmn_identity[loop].plmn_id,                   MAX_PLMN_ID_BYTES))
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name, RRM_BRIEF,
                            "PLMN ID [0x%x%x%x] at Idx[%d] match with MME Id[%d]", plmn_id_out[RRM_ZERO],
                            plmn_id_out[RRM_ONE], plmn_id_out[RRM_TWO], loop, p_rrm_connected_mme_node->mme_key_id);
                    mme_found = RRM_TRUE;
                    RRM_MEMSET(&plmn_id_out, RRM_ZERO, sizeof(U8)*MAX_PLMN_ID_BYTES);
                    break;
                }
            }
            if(RRM_TRUE == mme_found)
            {

                RRM_MEMSET(&rim_info_req, RRM_ZERO, sizeof(rim_information_req_t));
                rim_info_req.mme_id = p_rrm_connected_mme_node->mme_key_id;
                /* SPR-19167 END */
                rim_info_req.dst_cell.bitmask |= RIM_GERAN_ROUTING_ADDR_PRESENT;
                rim_info_req.dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ZERO] =
                    p_inter_rat_ncl->geran_freq_cells[count].cell_id >> RRM_EIGHT;
                rim_info_req.dst_cell.geran_rtng_addr.geran_cell_idty[RRM_ONE] =
                    ((p_inter_rat_ncl->geran_freq_cells[count].
                      cell_id << RRM_EIGHT) >> RRM_EIGHT);

                RRM_MEMCPY(rim_info_req.dst_cell.geran_rtng_addr.routing_idty.lac,
                        p_inter_rat_ncl->geran_freq_cells[count].lai.lac, (MAX_LAC_SIZE*sizeof(U8)));
                /* plmn_id of dst_cell*/
                /* Spr 16211 Changes Start*/
		/* Spr 19647 Changes Start*/
		fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE(&p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.geran_freq_cells[count].lai.plmn_identity, plmn);
		/* Spr 19647 Changes End*/
                /* Spr 16211 Changes End*/
                RRM_MEMCPY(rim_info_req.dst_cell.geran_rtng_addr.routing_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
                /* Spr 16211 Changes Start */
                rim_info_req.dst_cell.geran_rtng_addr.routing_idty.rac = 
                    p_inter_rat_ncl->geran_freq_cells[count].rac;
                /* Spr 16211 Changes End */
                /* SPR 18266 Fix Start */
                rim_info_req.app_cont.bitmask |= RIM_REQ_APP_CONTAINER_NACC_PRESENT;

                RRM_MEMCPY(rim_info_req.app_cont.nacc.cell_idty.routing_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

                RRM_MEMCPY(rim_info_req.app_cont.nacc.cell_idty.routing_idty.lac,
                        p_inter_rat_ncl->geran_freq_cells[count].lai.lac, (MAX_LAC_SIZE*sizeof(U8)));

                rim_info_req.app_cont.nacc.cell_idty.routing_idty.rac = 
                    p_inter_rat_ncl->geran_freq_cells[count].rac;

                rim_info_req.app_cont.nacc.cell_idty.geran_cell_idty[RRM_ZERO] =
                    p_inter_rat_ncl->geran_freq_cells[count].cell_id >> RRM_EIGHT;

                rim_info_req.app_cont.nacc.cell_idty.geran_cell_idty[RRM_ONE] =
                    ((p_inter_rat_ncl->geran_freq_cells[count].cell_id << RRM_EIGHT) >> RRM_EIGHT);
                /* SPR 18266 Fix Stop */

                rim_info_req.src_cell.bitmask |= RIM_EUTRAN_ROUTING_ADDR_PRESENT;
                /* Calculate enb_tyep from access mode */
                if(p_cell_ctx->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
                {
                    if(p_cell_ctx->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN)
                    {     
                        rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
                    }     
                    else  
                    {     
                        rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_HOME_ENB;
                    }     
                }
                else
                {    
                    rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
                }
                rim_info_req.src_cell.eutran_rtng_addr.enb.enb_id =
                    RRM_NTOHL(*(p_temp_cell_identity));
                /*PLMN id of src cell under enb*/
		/* Spr 19647 Changes Start*/
		fill_Global_enb_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 */
		/* Spr 19647 Changes End*/
                RRM_MEMCPY(rim_info_req.src_cell.eutran_rtng_addr.enb.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
		    fill_plmn_id_for_eutran_cell(p_cell_ctx,rim_info_req.src_cell.eutran_rtng_addr.ta_idty.plmn.plmn);/*SPR 17777 */
                RRM_MEMCPY(&rim_info_req.src_cell.eutran_rtng_addr.ta_idty.tac,
                        p_cell_ctx->epc_info.epc_params.general_epc_params.tac, sizeof(U16));
                /* PLMN id of src cell under ta_idty*/
		/*SPR 20324 Fix Start*/
		/*Code Deleted*/
		/*SPR 20324 Fix End*/
                rim_info_req.app_idty = RIM_NACC_APP;
                rim_info_req.seq_num = RRM_INCREMENT_RSN(p_cell_ctx->cur_rsn);
                p_cell_ctx->cur_rsn++;

                rim_info_req.pdu_ind.pdu_ext = pdu_ext_type;
                rim_info_req.pdu_ind.ack = RIM_NO_ACK_REQUESTED;
                rim_info_req.ver = RRM_ONE;
                rim_info_req.bitmask |= RIM_INFO_REQ_PROTOCOL_VER_PRESENT;
                rim_info_req.bitmask |= RIM_INFO_REQ_APP_CONTAINER_PRESENT;
                rim_info_req.bitmask |= RIM_INFO_REQ_MME_ID_PRESENT;

                ret_val = rrm_send_rim_req (p_cell_ctx, &rim_info_req);
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
                            "Failed to Send RIM_INFO_REQ to RRC");
                }
                else
                {
                    /* SPR-19167 START */
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                            "Successfully Send RIM_INFO_REQ to RRC for GERAN CellId %d pci =%d",
                            p_inter_rat_ncl->geran_freq_cells[count].cell_id,
                            p_inter_rat_ncl->geran_freq_cells[count].pci);
                }

            }
            p_rrm_connected_mme_node = (rrm_connected_mme_node_t *)ylNext(&p_rrm_connected_mme_node->s_node);

        }
        mme_found = RRM_FALSE;
    }
    mme_found = RRM_FALSE;
    for(count = RRM_ZERO; count < p_inter_rat_ncl->num_valid_utran_freq_cell; count++)
    {
        p_rrm_connected_mme_node = (rrm_connected_mme_node_t*)ylFirst(&p_g_rrm_cell_ctx->enb_context.connected_mme_list);
        RRM_MEMSET(&plmn_id, RRM_ZERO, sizeof(rrm_oam_cell_plmn_info_t));
        RRM_MEMCPY(&plmn_id.mcc, &p_inter_rat_ncl->utran_freq_cells[count].rai.lai.plmn_identity.mcc, MAX_MCC_DIGITS);
        RRM_MEMCPY(&plmn_id.mnc, &p_inter_rat_ncl->utran_freq_cells[count].rai.lai.plmn_identity.mnc.mnc, MAX_MNC_DIGITS);
        plmn_id.num_mnc_digit = p_inter_rat_ncl->utran_freq_cells[count].rai.lai.plmn_identity.mnc.count;
        rrm_plmnid_from_mcc_mnc(plmn_id_out, &plmn_id);
        while (RRM_PNULL != p_rrm_connected_mme_node)
        {
                /* SPR-19167 START */
                mme_found = RRM_FALSE;
		/* SPR-19167 END */
            for (loop = RRM_ZERO; loop < p_rrm_connected_mme_node->connected_gummei_info.num_served_plmns; loop++)
            {
                if (!RRM_MEMCMP(plmn_id_out, p_rrm_connected_mme_node->connected_gummei_info.plmn_identity[loop].plmn_id,                   MAX_PLMN_ID_BYTES))
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name, RRM_BRIEF,
                            "PLMN ID [0x%x%x%x] at Idx[%d] match with MME Id[%d]", plmn_id_out[RRM_ZERO],
                            plmn_id_out[RRM_ONE], plmn_id_out[RRM_TWO], loop, p_rrm_connected_mme_node->mme_key_id);
                    mme_found = RRM_TRUE;
                    RRM_MEMSET(&plmn_id_out, RRM_ZERO, sizeof(U8)*MAX_PLMN_ID_BYTES);
                    break;
                }
            }
            if(RRM_TRUE == mme_found)
            {
                RRM_MEMSET(&rim_info_req, RRM_ZERO, sizeof(rim_information_req_t));
                rim_info_req.mme_id = p_rrm_connected_mme_node->mme_key_id;
                /* SPR-19167 END */

                rim_info_req.dst_cell.bitmask |= RIM_UTRAN_ROUTING_ADDR_PRESENT;
		/*SPR 19709 FIX START*/
		if(p_inter_rat_ncl->utran_freq_cells[count].uc_id.bitmask && RRM_UTRAN_EXTN_RNC_ID_PRESENT)
		{
			rim_info_req.dst_cell.utran_rtng_addr.rnc_id[RRM_ZERO] =
				p_inter_rat_ncl->utran_freq_cells[count].uc_id.extended_rnc_id >> RRM_EIGHT;
			rim_info_req.dst_cell.utran_rtng_addr.rnc_id[RRM_ONE] =
				p_inter_rat_ncl->utran_freq_cells[count].uc_id.extended_rnc_id & RRM_U16_LOW_BYTE_MASK;
		}
		else
		{
                rim_info_req.dst_cell.utran_rtng_addr.rnc_id[RRM_ZERO] =
                    p_inter_rat_ncl->utran_freq_cells[count].uc_id.rnc_id >> RRM_EIGHT;
                rim_info_req.dst_cell.utran_rtng_addr.rnc_id[RRM_ONE] =
				(p_inter_rat_ncl->utran_freq_cells[count].uc_id.rnc_id & RRM_U16_LOW_BYTE_MASK);
		} 
		/*SPR 19709 FIX END*/
                RRM_MEMCPY(rim_info_req.dst_cell.utran_rtng_addr.routing_idty.lac,
                        p_inter_rat_ncl->utran_freq_cells[count].rai.lai.lac, (MAX_LAC_SIZE*sizeof(U8)));
                rim_info_req.dst_cell.utran_rtng_addr.routing_idty.rac =
                    p_inter_rat_ncl->utran_freq_cells[count].rai.rac;
                /*filling plmn_id of dst_cell*/
		/* Spr 19647 Changes Start*/
		fill_plmn_id_for_utran_geran_cell_for_dst_rtng_addr_IE(&p_inter_rat_ncl->utran_freq_cells[count].rai.lai.plmn_identity, plmn);
		/* Spr 19647 Changes End*/
                RRM_MEMCPY(rim_info_req.dst_cell.utran_rtng_addr.routing_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

                /* SPR 17078 Fix Start */
                rim_info_req.app_cont.bitmask |= RIM_REQ_APP_CONTAINER_UTRA_SI_PRESENT;
		/* Spr 19647 Changes Start*/
		fill_plmn_id_for_utran_cell(&p_inter_rat_ncl->utran_freq_cells[count].rai.lai.plmn_identity, plmn);
		/* Spr 19647 Changes End*/

                RRM_MEMCPY(rim_info_req.app_cont.utra_si.rpt_cell_id.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

		/* Spr 19709 Changes Start*/
                rim_info_req.app_cont.utra_si.rpt_cell_id.cell_id =
			(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].
			 uc_id.cell_id[RRM_ONE]); 
		rim_info_req.app_cont.utra_si.rpt_cell_id.cell_id = rim_info_req.app_cont.utra_si.rpt_cell_id.cell_id<<RRM_EIGHT; 
		rim_info_req.app_cont.utra_si.rpt_cell_id.cell_id|=
			(p_cell_ctx->ran_info.ncl_params.inter_rat_ncl.utran_freq_cells[count].uc_id.cell_id[RRM_ZERO]);
		/* Spr 19709 Changes Start*/

                /* SPR 17078 Fix Stop */

                rim_info_req.src_cell.bitmask |= RIM_EUTRAN_ROUTING_ADDR_PRESENT;
                /* Calculate enb_tyep from access mode */
                if(p_cell_ctx->bitmask & RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT)
                {
                    if(p_cell_ctx->access_mgmt_params.access_mode == RRM_OAM_ACCESS_MODE_OPEN)
                    {     
                        rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
                    }     
                    else  
                    {     
                        rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_HOME_ENB;
                    }     
                }
                else
                {    
                    rim_info_req.src_cell.eutran_rtng_addr.enb.enb_type = RIM_ENB_TYPE_MACRO_ENB;
                }
                rim_info_req.src_cell.eutran_rtng_addr.enb.enb_id =
                    RRM_NTOHL(*(p_temp_cell_identity));
                /*filling PLMN id of src cell under enb*/
		/* Spr 19647 Changes Start*/
		fill_Global_enb_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 */
		/* Spr 19647 Changes End*/
                RRM_MEMCPY(rim_info_req.src_cell.eutran_rtng_addr.enb.plmn.plmn, plmn, RRM_THREE*sizeof(U8));
		/*SPR 20191 FIX START*/
                fill_plmn_id_for_eutran_cell(p_cell_ctx, plmn);/*SPR 17777 */
                /*SPR 20191 FIX END*/
                /*coverity 25199, 25206, range of data to be copied changed, aditya, rel 1.3.1*/
                RRM_MEMCPY(&rim_info_req.src_cell.eutran_rtng_addr.ta_idty.tac,
                        p_cell_ctx->epc_info.epc_params.general_epc_params.tac, MAX_TAC_SIZE*sizeof(U8));
                /*filling PLMN id of src cell under ta_idty*/
                RRM_MEMCPY(rim_info_req.src_cell.eutran_rtng_addr.ta_idty.plmn.plmn, plmn, RRM_THREE*sizeof(U8));

                rim_info_req.app_idty = RIM_UTRA_SI_APP;
                rim_info_req.seq_num = RRM_INCREMENT_RSN(p_cell_ctx->cur_rsn);
                p_cell_ctx->cur_rsn++;

                rim_info_req.pdu_ind.pdu_ext = pdu_ext_type;
                rim_info_req.pdu_ind.ack = RIM_NO_ACK_REQUESTED;
                rim_info_req.ver = RRM_ONE;
                rim_info_req.bitmask |= RIM_INFO_REQ_PROTOCOL_VER_PRESENT;
                rim_info_req.bitmask |= RIM_INFO_REQ_APP_CONTAINER_PRESENT;
                rim_info_req.bitmask |= RIM_INFO_REQ_MME_ID_PRESENT;

                ret_val = rrm_send_rim_req (p_cell_ctx, &rim_info_req);
                if(RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
                            "Failed to Send RIM_INFO_REQ to RRC");
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                            "Successfully Send RIM_INFO_REQ to RRC" 
                            " for UTRAN Cell ID = %d %d, RNC ID = %d PCI = %d",
                            p_inter_rat_ncl->utran_freq_cells[count].uc_id.cell_id[RRM_ONE],
                            p_inter_rat_ncl->utran_freq_cells[count].uc_id.cell_id[RRM_ZERO],
                            p_inter_rat_ncl->utran_freq_cells[count].uc_id.rnc_id,
                            p_inter_rat_ncl->utran_freq_cells[count].pcpich_scrambling_code);
                }
            }
            p_rrm_connected_mme_node = (rrm_connected_mme_node_t *)ylNext(&p_rrm_connected_mme_node->s_node);
        }
        mme_found = RRM_FALSE;
    }
    /* SPR-19167 END */
    /* Spr 16211 Changes End*/

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*RIM changes end*/



/****************************************************************************
 * Function Name  : rrm_cellm_decrement_num_active_ue
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : Decrement the no. of active UEs in the cell context
 ****************************************************************************/
rrm_return_et
rrm_cellm_decrement_num_active_ue
(
 rrm_cell_index_t cell_index
 )
{

    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    /*SPR 21419 Fix Start*/
    QTIME   time= {RRM_ZERO};
    /* Coverity 114620 Fix Start */
    S32     Err = RRM_ZERO;
    /* Coverity 114620 Fix End */
    /*SPR 21419 Fix Stop */

    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    if(p_rrm_cell_ctx->cell_resource_info.num_active_ue > RRM_ZERO)
    {
        (p_rrm_cell_ctx->cell_resource_info.num_active_ue)--;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                "[CELL:%d] Active UE count decremented to %d", 
                cell_index, p_rrm_cell_ctx->cell_resource_info.num_active_ue);
        if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config != RRM_PNULL)
        {
            if (p_rrm_cell_ctx->p_cell_ecn_config->num_active_ecn_ue > RRM_ZERO)
            {
                (p_rrm_cell_ctx->p_cell_ecn_config->num_active_ecn_ue)--;
            }
        }

        /*BUG:769 start*/
        ret_val = rrm_cell_ue_threshold_rchd_ind(p_rrm_cell_ctx);
        /*BUG:769 end*/
    }
    /*BUG:823 start*/
    if (RRM_ZERO == p_rrm_cell_ctx->cell_resource_info.num_active_ue)
    {
        p_rrm_cell_ctx->svr_cell_load_info.bitmask |= RRM_RR_LOAD_PERIODIC_REPORT_PRESENT;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_gbr_prb_usage = RRM_ZERO;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_gbr_prb_usage =  RRM_ZERO;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage =  RRM_ZERO;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage =  RRM_ZERO;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.dl_total_prb_usage =  RRM_ZERO;
        p_rrm_cell_ctx->svr_cell_load_info.rr_load.ul_total_prb_usage =  RRM_ZERO;

        /* SPR 21419 Fix Start */
        if((p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer))
        {
            time.s  = p_rrm_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL];
            time.us = RRM_ZERO;

            /*Stopping CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL timer, because no UE is left on the cell */
            if(RRM_SUCCESS == rrm_module_timer_stop(p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer,&time,&Err))
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                        "Timer stopped  %p: timertype [%d]",
                        p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer,CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL);

                p_rrm_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = RRM_ZERO; 
                p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =  RRM_PNULL;
            }
            else
            {
                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                        "Stopping timer is failed %p, received error is %d",
                        p_rrm_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer,Err);
            }
        }
        /* SPR 21419 Fix Stop */
    }
    /*BUG:823 end*/
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/* SPS related changes start */
/****************************************************************************
 * Function Name  : rrm_cellm_decrement_num_sps_active_ue
 * Inputs         : cell index
 * Outputs        : None
 * Returns        : None
 * Description    : Decrement the no. of SPS active UEs in the cell context
 ****************************************************************************/
void
rrm_cellm_decrement_num_sps_active_ue
(
 rrm_cell_index_t cell_index,
 U16              ue_sps_n1_pucch_indx
 )
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t   *p_cell_context = RRM_PNULL;

	p_cell_context = rrm_cellm_get_cell_context(cell_index);
	if(p_cell_context != RRM_PNULL)
	{
		p_cell_context->sps_ues_count--;
        /* SPR 11003 Fix Start */
        /* N1_idx 26, Total 27(Including n_cs_an).
         * One is decremented from the count coz the out put is being checked for index array
         */
		if((RRM_PNULL != p_cell_context->sps_n1_pucch_an_marked_st) &&
                (ue_sps_n1_pucch_indx <= (((p_cell_context->ran_info.physical_layer_params.
                                            physical_layer_param_pucch.n1_pucch_an + RRM_ONE) +
                                           (p_cell_context->ran_info.physical_layer_params.
                                            physical_layer_param_pucch.n_cs_an * 
                                            p_cell_context->ran_info.physical_layer_params.
                                            physical_layer_param_pucch.delta_pucch_shift) 
                                           - 
                                           p_cell_context->sps_n1_pucch_an_start_indx) - RRM_ONE)))

		{
            /*CA stage2:start*/
            if(p_cell_context->operator_info.ca_config.is_ca_eligible)
            {
                p_cell_context->sps_n1_pucch_an_marked_st[ue_sps_n1_pucch_indx]=RRM_ZERO;
                p_cell_context->sps_n1_pucch_an_marked_st[ue_sps_n1_pucch_indx+ RRM_ONE]=RRM_ZERO;
            }
            else
            {
            /*CA stage2:end*/
                p_cell_context->sps_n1_pucch_an_marked_st[ue_sps_n1_pucch_indx]=RRM_ZERO;
            }
		}
		else
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
					"sps_n1_pucch_an_marked_st is NULL or wrong index[%d] for CELL_INDEX[%d]", 
					ue_sps_n1_pucch_indx,cell_index);
		}
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
				"CELL_INDEX[%d] is NULL", cell_index);
	}
	RRM_UT_TRACE_EXIT();
}
/* SPS related changes end */

/****************************************************************************
 * Function Name  : rrm_cellm_get_cpu_utilization_limit
 * Inputs         : cell_index 
 * Outputs        : None
 * Returns        : CPU utilization limit
 * Description    : Returns the upper limit of maximum CPU utilization allowed
 ****************************************************************************/
	U8 
rrm_cellm_get_cpu_utilization_limit(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.cpu_utilization_limit;
}


/****************************************************************************
 * Function Name  : rrm_cellm_get_max_num_ue_per_cell
 * Inputs         : cell_index 
 * Outputs        : None
 * Returns        : Maximum number of UEs per cell
 * Description    : Returns the maximum number of UEs allowed per cell
 ****************************************************************************/
/* +- SPR 18268 */
	U16 
    /* +- SPR 18268 */
rrm_cellm_get_max_num_ue_per_cell(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.max_num_ue_per_cell;
}


/****************************************************************************
 * Function Name  : rrm_cellm_get_num_active_ue
 * Inputs         : cell_index 
 * Outputs        : None
 * Returns        : Number of active UEs in the cell
 * Description    : Returns the number of active UEs in the cell
 ****************************************************************************/
/* SPR 21527 Start */
	U16 
/* SPR 21527 End */
rrm_cellm_get_num_active_ue(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	/* SPR-20656 START */
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "[CELL:%d] Number of Active UE count is %d",
                                cell_index, p_rrm_cell_ctx->cell_resource_info.num_active_ue);
	/* SPR-20656 END */

	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.num_active_ue;
}
/** TNL feature */
/****************************************************************************
 * Function Name  : rrm_cellm_get_total_backhaul_capacity
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : Get the total backhaul capacity
 * Description    : Returns the total backhaul capacity of the cell
 ****************************************************************************/
U64 
rrm_cellm_get_total_backhaul_capacity
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.tnl_capacity.total_backhaul_capacity;
}
/****************************************************************************
 * Function Name  : rrm_cellm_get_capacity_threshold
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : Retuns the capacity threshold
 * Description    : Returns the capacity thershold
 ****************************************************************************/
U8 
rrm_cellm_get_capacity_threshold
(
 rrm_cell_index_t cell_index
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->operator_info.admission_control_info.tnl_capacity.capacity_threshold;
}
/** TNL feature */
/****************************************************************************
 * Function Name  : rrm_cell_get_free_sr_res_index
 * Inputs         : cell_index, frame, slot, *sr_res_index
 * Outputs        : sr_res_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of SR resource index by frame and
 *                  slot in the SR resource list; and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et
rrm_cell_get_free_sr_res_index
(
 rrm_cell_index_t cell_index,
 U8  n1_idx, 
 U16 sr_idx, 
 U8 *sr_config_idx,
 U8 *sr_pucch_res_idx
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_return_et retVal = RRM_SUCCESS;
   rrm_cell_context_t  *p_rrm_cell_ctx = RRM_PNULL;
   rrm_sr_res_list_t   *res_node = RRM_PNULL;

   p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
   if (RRM_PNULL != p_rrm_cell_ctx)
   {
      if (RRM_PNULL != p_rrm_cell_ctx->sr_res)
      {
         res_node = &(p_rrm_cell_ctx->sr_res[n1_idx][sr_idx]);
         if(RRM_PNULL == res_node)
         {
             /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Data for row_num[%d], col_num[%d]",n1_idx, sr_idx);
            /* SPR 21251 End */
            retVal = RRM_FAILURE;
         }
         else
         {
	if(RRM_RES_BUSY == res_node->sr_marked_status)
	{
		/* Resource is blocked for other UE */
		retVal = RRM_FAILURE;
	}
	else
	{
		*sr_config_idx = res_node->sr_config_index;
		*sr_pucch_res_idx = res_node->sr_pucch_res_index;
		retVal = RRM_SUCCESS;
	}
         }
      }
      else
      {
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                         "Should not have come here");
         retVal = RRM_FAILURE;
      }
   }
   else
   {
       /* SPR 21251 Start */
      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "Cell Context is NULL for cell_index: %d", cell_index);
      retVal = RRM_FAILURE;
   }
	RRM_UT_TRACE_EXIT();
	return retVal;
}

/****************************************************************************
 * Function Name  : rrm_cell_mark_sr_index_busy
 * Inputs         : cell_index, frame, slot, sr_res_index
 * Outputs        : None
 * Returns        : None
 * Description    : Marks a SR resource index as busy by popping the corresponding 
 *                  node out of the SR resource list on basis of the frame, 
 *                  slot and res_index
 ****************************************************************************/
void 
rrm_cell_mark_sr_index_busy
(
 rrm_cell_index_t cell_index,
 U8    n1_idx, 
 /*SPR 15713 Fix Start*/
 U16   sr_idx,
 rrm_bool_et mark_sr_as_free
 /*SPR 15713 Fix End*/

 )
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;

   p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	rrm_sr_res_list_t *res_node = &(p_rrm_cell_ctx->sr_res[n1_idx][sr_idx]);

	res_node->sr_marked_status = RRM_RES_BUSY;
              /*SPR 15713 Fix Start*/
              res_node->sr_conflict_resolve = mark_sr_as_free;
              /*SPR 15713 Fix End*/

   RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cell_mark_sr_index_free
 * Inputs         : cell_index, frame, slot, sr_res_index
 * Outputs        : None
 * Returns        : None
 * Description    : Marks a SR resource index as busy by popping the corresponding 
 *                  node out of the SR resource list on basis of the frame, 
 *                  slot and res_index
 ****************************************************************************/
void 
rrm_cell_mark_sr_index_free
(
 rrm_cell_index_t cell_index,
 U8    n1_idx, 
 U16   sr_idx
 )
{
   RRM_UT_TRACE_ENTER();

   rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;
   rrm_sr_res_list_t *res_node = RRM_PNULL;

   p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
   if (RRM_PNULL != p_rrm_cell_ctx)
   {
       if (RRM_PNULL != p_rrm_cell_ctx->sr_res)
       {
           res_node = &(p_rrm_cell_ctx->sr_res[n1_idx][sr_idx]);
           if(RRM_PNULL == res_node)
           {
               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                               "Data for row_num[%d], col_num[%d]",n1_idx, sr_idx);
           }
           else
           {
               res_node->sr_marked_status = RRM_RES_FREE;

               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                               "SR-MarkedStatus[%d]", res_node->sr_marked_status);
           }
       }
       else
       {
           RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                           "This leg will hit when Cell Resources are already deleted and UEs are being deleted");
       }
   }
   else
   {
       /* SPR 21251 Start */
       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                       "Cell Context is NULL");
       /* SPR 21251 End */
   }

   RRM_UT_TRACE_EXIT();
}
/*BUG_863_CHANGES_END */



/****************************************************************************
 * Function Name  : rrm_cellm_get_available_frame_and_slot_and_sr_res_index
 * Inputs         : cell_index, *row_num, *slot, *sr_res_index
 * Outputs        : frame, slot, sr_res_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of SR resource index in any frame 
 *                  and slot; and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_available_row_and_colum_and_sr_res_index
( 
 rrm_cell_index_t  cell_index,
 U8  *row,
 U16 *colum,
 U8  *sr_config,
 /*SPR 15713 Fix Start*/
 U8  *sr_pucch_res,
 rrm_bool_et mark_sr_as_free
 /*SPR 15713 Fix End*/

 )
{
    RRM_UT_TRACE_ENTER();

    rrm_return_et ret_val           = RRM_FAILURE;
    /*SPR 20786 Fix Start*/
    /*Code Removed*/
    /*SPR 20786 Fix Stop*/
    /* COMP_WARN_1_FEB:compilation warning removal */ 
    /* SPR 11003 Fix Start */
    U16           n_one_pucch_an    = RRM_ZERO;
    U16           n1_idx            = RRM_ZERO;
    /* SPR 11003 Fix End */
	U16           sr_idx            = RRM_ZERO;
	U16                     sr_periodicity = RRM_ZERO;


	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;

	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	find_sr_periodicity_from_cell_context(p_rrm_cell_ctx, &sr_periodicity, &n_one_pucch_an);    

    /*SPR 20786 Fix Start*/
    for(n1_idx = RRM_ZERO; (n1_idx < n_one_pucch_an); n1_idx++ )
    {
        /* SPR 12387 Fix Start */
        for(sr_idx = RRM_ZERO; 
                (sr_idx < p_rrm_cell_ctx->sr_data.allocated_sr_perodicity_max_val); sr_idx++)
            /*SPR 20786 Fix Stop*/
            /* SPR 12387 Fix End */
        {
            ret_val = rrm_cell_get_free_sr_res_index(cell_index, n1_idx, sr_idx, 
                    sr_config, sr_pucch_res);
            if(ret_val == RRM_SUCCESS)
            {
                /*SPR 15713 Fix Start*/
                rrm_cell_mark_sr_index_busy(cell_index, n1_idx, sr_idx, mark_sr_as_free);
                /*SPR 15713 Fix End*/
                *row =  n1_idx;
                *colum = sr_idx;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
                        "FINAL Allocation SR:- sr_puccch_res_idx%d, sr_config_idx=%d, n_one_pucch_an=%d",
                        *sr_pucch_res, *sr_config, n_one_pucch_an);
                ret_val = RRM_SUCCESS;
                /*SPR 20786 Fix Start*/
                n1_idx = n_one_pucch_an;
                sr_idx = p_rrm_cell_ctx->sr_data.allocated_sr_perodicity_max_val;
                /*Code Removed*/
                /*SPR 20786 Fix Stop*/
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_cellm_get_sr_resources
 * Inputs         : cell_index, sr_periodicity, *frame, *slot
 * Outputs        : sr_res_index, sr_config_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of SR resource for UE admission. If
 *                  found, then set the SR resource index and SR config index
 *                  in the out params and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_sr_resources
(
 rrm_cell_index_t  cell_index,
 U8  *sr_res_index, 
 U8  *sr_config_index,
 U8  *row,
 /*SPR 15713 Fix Start*/
 U16 *colum,
 rrm_bool_et mark_sr_as_free
 /*SPR 15713 Fix End*/

 )
{
	RRM_UT_TRACE_ENTER();

	rrm_return_et ret_val = RRM_SUCCESS;
	ret_val = rrm_cellm_get_available_row_and_colum_and_sr_res_index(cell_index, row, colum, 
    /*SPR 15713 Fix Start*/
            sr_config_index, sr_res_index, mark_sr_as_free);
    /*SPR 15713 Fix End*/

	RRM_UT_TRACE_EXIT();
	return ret_val;    
}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_initialize_sr_res_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Initializes the SR resource list
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_initialize_sr_res_list
(
 rrm_cell_context_t       *p_cell_context
 )
{
	U16                     sr_index_count = RRM_ZERO;
	U16                     sr_periodicity = RRM_ZERO;
    /* SPR 11003 Fix Start */
    U16                     n_one_pucch_an = RRM_ZERO;
	U16                     sr_table_map[MAX_PERIODIC_REPTITION_SR] = {RRM_ZERO};
    U16                     n1_pucch_res_index_count = RRM_ZERO;
    /* SPR 11003 Fix End */
	U8                      alloc_sr_from_algo_val = RRM_ZERO;
	rrm_sr_res_list_t       *sr_node = RRM_PNULL;
	rrm_return_et           ret_val = RRM_FAILURE;
#ifdef TDD_MODE_FLAG
    U32 loop_count = RRM_ZERO;
    U32 first_index = RRM_ZERO;
    U32 last_index = RRM_ZERO;
    U32 temp_sr_index = RRM_ZERO;
#endif

	RRM_UT_TRACE_ENTER();

	find_sr_periodicity_from_cell_context(p_cell_context, &sr_periodicity, &n_one_pucch_an);    
#ifndef TDD_MODE_FLAG
	ret_val = prepare_sr_resource_list(sr_table_map,/*SPR 17777 +-*/ 
			sr_periodicity, &alloc_sr_from_algo_val);
#else
	ret_val = prepare_sr_resource_list(p_cell_context,sr_table_map,
			sr_periodicity, &alloc_sr_from_algo_val);
#endif
	if (ret_val == RRM_FAILURE)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Alarming Situation if this block hits....");
		return RRM_FAILURE;
	}
#ifdef TDD_MODE_FLAG
	/* 
	   This function shall be used in case of TDD Mode only. The reason for shuffling
	   of SR indexes is done here in order to place those SR indexes at the end of the list
	   which can have collision with CQI Indexes at initial level. In case of TDD we have limited 
	   number of UL subframe so chances of collision increases.
	 */
	loop_count = alloc_sr_from_algo_val / RRM_TWO;
	last_index = alloc_sr_from_algo_val - RRM_ONE;
	first_index = RRM_ZERO;
	while(loop_count != RRM_ZERO)
	{
		temp_sr_index = sr_table_map[last_index];
		sr_table_map[last_index] = sr_table_map[first_index];
		sr_table_map[first_index] = temp_sr_index;
		last_index--;
		first_index++;
		loop_count--;
	}
#endif    
    /*MEMORY_PROFILING*/
    /* Allocate memory for CQI_RI_RES allocation */
    p_cell_context->sr_res = RRM_PNULL;
    p_cell_context->sr_res = rrm_mem_get(n_one_pucch_an * sizeof(rrm_sr_res_list_t*));
    if ( p_cell_context->sr_res == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"Memory allocation to p_cell_context->sr_res failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    } 
    for( n1_pucch_res_index_count = RRM_ZERO; 
              n1_pucch_res_index_count < n_one_pucch_an ; n1_pucch_res_index_count++)
    {
        p_cell_context->sr_res[n1_pucch_res_index_count] = rrm_mem_get(alloc_sr_from_algo_val * sizeof(rrm_sr_res_list_t));
        if ( p_cell_context->sr_res[n1_pucch_res_index_count] == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"Memory allocation to p_cell_context->sr_res[n1_pucch_res_index_count] failed" );
            RRM_UT_TRACE_EXIT();
            RRM_MEM_FREE(p_cell_context->sr_res);
            return RRM_FAILURE;
        }
    }
    /*MEMORY_PROFILING*/

	for(n1_pucch_res_index_count = RRM_ZERO; n1_pucch_res_index_count < n_one_pucch_an; 
			n1_pucch_res_index_count++)
	{
		for(sr_index_count = RRM_ZERO; sr_index_count < alloc_sr_from_algo_val; sr_index_count++)
		{
			sr_node = &(p_cell_context->sr_res[n1_pucch_res_index_count][sr_index_count]);
			sr_node->sr_config_index = sr_table_map[sr_index_count];
			sr_node->sr_pucch_res_index = n1_pucch_res_index_count;
			sr_node->row_num = n1_pucch_res_index_count;
			sr_node->col_num = sr_index_count;
			sr_node->sr_marked_status = RRM_RES_FREE;
            /*SPR 15713 Fix Start*/
            sr_node->sr_conflict_resolve = RRM_FALSE;
            /*SPR 15713 Fix End*/
			            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				      "Array[%d][%d]-->SR-PUCCH-Res-Idx[%d], SR[%d] Status[%d]", 
				      n1_pucch_res_index_count, sr_index_count, sr_node->sr_pucch_res_index, 
				      sr_node->sr_config_index, sr_node->sr_marked_status);
		}
	}
/* SPR 12387 Fix Start */
	p_cell_context->sr_data.allocated_sr_perodicity_max_val = alloc_sr_from_algo_val;
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	          "Toatl SR Res Allocated [%d]", (alloc_sr_from_algo_val * n_one_pucch_an ));
/* SPR 12387 Fix End */
	RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* ETWS_CMAS inititializations */
rrm_void_t
rrm_cellm_cell_init_etws_cmas_list
(
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();

	/* Initialize the meas context lists */
	ylInit(&(p_cell_context->scheduled_etws_warning_list));
	ylInit(&(p_cell_context->scheduled_cmas_warning_list));

	RRM_UT_TRACE_EXIT();
}
/* UE MEAS CHANGES : STARTS */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_init_meas_context_list 
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the Meas Context(EUTRAN and UTRA) List
 ****************************************************************************/
rrm_void_t
rrm_cellm_cell_init_meas_context_list
(
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();

	/* Initialize the meas context lists */
	ylInit(&(p_cell_context->meas_eutran_list));
	ylInit(&(p_cell_context->meas_utran_list));
	ylInit(&(p_cell_context->meas_geran_list));

	RRM_UT_TRACE_EXIT();
}
/*X2AP START */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_init_x2_enb_list 
 * Inputs         : rrm_global_context_t *p_g_rrm_cell_ctx
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the X2 Enb List
 ****************************************************************************/
rrm_void_t
rrm_cellm_cell_init_x2_enb_list
(
 rrm_global_context_t *p_g_rrm_cell_ctx
 )
{
	RRM_UT_TRACE_ENTER();

	ylInit(&(p_g_rrm_cell_ctx->rrm_x2_enb_list));
	RRM_UT_TRACE_EXIT();
}
/*X2AP END */
/* UE MEAS CHANGES : ENDS */

/* Fix 960 Start */
/****************************************************************************
 * Function Name  : rrm_init_tnl_discovery_trans_id_list 
 * Inputs         : rrm_global_context_t *p_g_rrm_cell_ctx
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the Transaction ID list for TNL discovery Req
 ****************************************************************************/
rrm_void_t
rrm_init_tnl_discovery_trans_id_list
(
 rrm_global_context_t *p_g_rrm_cell_ctx
 )
{
	RRM_UT_TRACE_ENTER();

	ylInit(&(p_g_rrm_cell_ctx->rrm_tnl_discovery_trans_id_list));
	RRM_UT_TRACE_EXIT();
}
/* Fix 960 End */

rrm_bool_et
rrm_cellm_is_rac_enabled(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();

	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	RRM_UT_TRACE_EXIT();
	return (rrm_bool_et)p_rrm_cell_ctx->enable_rac_flag;
}
/****************************************************************************
 * Function Name  : build_and_send_tnl_discovery_resp_to_mif
 * Inputs         : rrmcm_rmif_son_tnl_discovery_resp_t *p_tnl_discovery_resp
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the CQI resource list
 ****************************************************************************/
rrm_return_et build_and_send_tnl_discovery_resp_to_mif(
		rrmcm_rmif_son_tnl_discovery_resp_t  *p_tnl_discovery_resp,
		U16                         api_id)
{
	rrm_return_et        ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();

	/*
	 * sending failure response to MIF
	 */
	if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				api_id,
				sizeof(rrmcm_rmif_son_tnl_discovery_resp_t),
				(void *)p_tnl_discovery_resp))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,"build_and_send_tnl_discovery_resp_to_mif: Tnl discovery response send successfully"); 

		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,"build_and_send_tnl_discovery_resp_to_mif: Tnl discovery response sending failed");
		ret_val = RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();

	return ret_val;
}


/****************************************************************************
 * Function Name  : build_and_send_generic_resp_to_mif
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the CQI resource list
 ****************************************************************************/
rrm_return_et build_and_send_generic_resp_to_mif(
		rrmcm_rmif_generic_resp_t  *p_generic_resp_to_mif,
		U16                         api_id)
{
	rrm_return_et        ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();

	/*
	 * sending failure response to MIF
	 */
	if (RRM_SUCCESS == rrm_send_internal_msg((U16)RRM_MIF_MODULE_ID,
				api_id,
				sizeof(rrmcm_rmif_generic_resp_t),
				(void *)p_generic_resp_to_mif))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"build_and_send_generic_resp_to_mif: Generic response send successfully for cell index:%d",
				p_generic_resp_to_mif->cellindex);
		ret_val = RRM_SUCCESS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"build_and_send_generic_resp_to_mif: failure in send config response  for cell index:%d",
				p_generic_resp_to_mif->cellindex);
		ret_val = RRM_FAILURE;
	}

	RRM_UT_TRACE_EXIT();

	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_admission_control
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : Which type of call should be allowed
 * Description    : This function check if operation is allowed for a UE or not
 ****************************************************************************/
rrm_calls_allowed_et
rrm_cellm_admission_control(
		rrm_cell_index_t cell_index,
		rrm_bool_et chk_for_rab)

{
	U8                    ld_percnt       = RRM_ZERO;
	U8                    cal_lmt         = RRM_ZERO;
	rrm_cell_context_t    *p_cell_ctxt    = RRM_ZERO;
	rrm_calls_allowed_et  ret_val         = RRM_NO_CALLS;
	U16                   i               = RRM_ZERO;
    /* Bug_8718_start */
    U8                    soft_lmt        = RRM_ZERO;
    /* Bug_8718_end */


	RRM_UT_TRACE_ENTER();

	p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	if (RRM_PNULL == p_cell_ctxt)
	{
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Cell Context not found for cell index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_NO_CALLS;
	}
    /*SPR_9051_CHANGES_START*/
	if((p_cell_ctxt->cell_state == CELL_STATE_ACTIVE) ||
        (p_cell_ctxt->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP) ||
        (p_cell_ctxt->cell_state == CELL_STATE_W_FOR_CELL_RECONFIG_RESP_FOR_NRT) ||
        (p_cell_ctxt->cell_state == CELL_STATE_PWS_ONGOING) ||
        (p_cell_ctxt->cell_state == CELL_STATE_MLB_W_FOR_CELL_RECONFIG_RESP) ||
        (p_cell_ctxt->cell_state ==
         CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2) ||
              
        /* SPR 18181 Fix Start */
          (p_cell_ctxt->cell_state == CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP))
        /* SPR 18181 Fix Stop */

        /* SPR 14228 Fix : Removed states
         * CELL_STATE_BLOCK_W_FOR_CELL_RECONFIG_RESP &
         * CELL_STATE_ALREADY_BLOCKED
         */

    /*SPR_9051_CHANGES_END*/
	{
        ret_val = RRM_ALL_CALLS;
		switch(p_cell_ctxt->cell_load_action.choice)
		{
			case RRM_CELL_LOAD_COMPOSITE_PRESENT:
				{
					if (p_cell_ctxt->cell_load_action.u.comp_load_info.actn_status & RRMCM_ACTN_STOP_ADM)
					{
						rrm_get_load_percent(&p_cell_ctxt->cell_load_action.u.comp_load_info,
								p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl, 
                            /*SPR 17777 +-*/
								&ld_percnt);
                        /* Bug_8718_start */
                        /* SPR 17844 fix start */
                        switch(p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl)
                        {
                            /* SPR 17844 fix end */
                            case RRM_MEDIUM:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.comp_load_info.mid_load.soft_lmt;
                                break;

                            case RRM_HIGH:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.comp_load_info.high_load.soft_lmt;
                                break;

                            case RRM_OVERLOAD:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.comp_load_info.over_load.soft_lmt;
                                break;

                            default:

                                soft_lmt = RRM_DEFINED_DEFAULT_VALUE_FOR_SOFT_LMT;
                                break;
                        }
                        /* Bug_8718_end */
						cal_lmt = soft_lmt + ld_percnt;
						if (p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_val > cal_lmt)
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
									"Only Emergency and high priority calls will be entertained !!! \
                                    Current load [%u], Thrshlmt[%u], Load lvl[%u]",
									p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_val, cal_lmt,
									p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl);
							ret_val = RRM_EMRGCY_CALLS;
						}
						else
						{
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
									"Allow only privilege calls [Hand-in, CSG, Emergency & High Priority] !!!\
                                    Current load [%u], Thrshlmt[%u], Load lvl[%u]",
									p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_val, cal_lmt,
									p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl);
							ret_val = RRM_PRIVILEGE_CALLS;
						}
					}
					else
					{
						if ((RRM_FALSE == chk_for_rab) && (RRM_TRUE == p_cell_ctxt->stop_adm_flag))
						{
							ret_val = RRM_PRIVILEGE_CALLS;
							RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
									"Stop admission without load !!!");
						}
					}
				}
				break;

			case RRM_CELL_LOAD_RESRC_SPEC_PRESENT:
				{
					for (i = RRM_ZERO; i < p_cell_ctxt->cell_load_action.u.resrc_spec_info.count; i++)
					{
						if (p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.actn_status & RRMCM_ACTN_STOP_ADM)
						{
							rrm_get_load_percent(&p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn,
									p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.curr_load_lvl, 
                                /*SPR 17777 +-*/
									&ld_percnt);
                            /* SPR 17844 fix start */
                        switch(p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.curr_load_lvl)
                        {
                            /* SPR 17844 fix end */         
                            case RRM_MEDIUM:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.mid_load.soft_lmt;
                                break;

                            case RRM_HIGH:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.high_load.soft_lmt;
                                break;

                            case RRM_OVERLOAD:
                                
                                soft_lmt = p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.over_load.soft_lmt;
                                break;

                            default:
                                soft_lmt = RRM_DEFINED_DEFAULT_VALUE_FOR_SOFT_LMT;
                                break;
                        }
                        /* Bug_8718_end */
						cal_lmt = soft_lmt + ld_percnt;
							if (p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[i].ld_actn.curr_load_val > cal_lmt)
							{
								RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                        "Only Emergency and high priority calls will be entertained !!!" 
                                        "Current load [%u], Thrshlmt[%u], Load lvl[%u]",
                                        p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_val,
										cal_lmt,
                                        p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl);
								ret_val = RRM_EMRGCY_CALLS;
								break;
							}
							else
							{
								RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                        "Allow only privilege calls [Hand-in, CSG, Emergency & High Priority] !!!"
                                        "Current load [%u], Thrshlmt[%u], Load lvl[%u]",
										p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_val, cal_lmt,
										p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl);
								ret_val = RRM_PRIVILEGE_CALLS;
							}
						}
						else
						{
							if ((RRM_FALSE == chk_for_rab) && (RRM_TRUE == p_cell_ctxt->stop_adm_flag))
							{
								RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
										"Stop admission without load !!!");
                                /*SPR_9051_CHANGES_START*/
								ret_val = RRM_EMRGCY_CALLS;
                                /*SPR_9051_CHANGES_END*/
								break;
							}
						}
					}
				}
				break;

			default:
				break;
		}
	}
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Not allowing calls as cell[%u] is not active. Cell state is"
                " [%u]", p_cell_ctxt->cell_index, p_cell_ctxt->cell_state);
    }

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_ue_admission_allowed 
 * Inputs         : rrm_cell_index_t cell_index
 * Outputs        : None
 * Returns        : None
 * Description    : Checks whether UE admission is allowed or not
 ****************************************************************************/
	rrm_calls_allowed_et 
rrm_cellm_ue_admission_allowed(rrm_cell_index_t cell_index)
{
	return rrm_cellm_admission_control(cell_index, RRM_FALSE);
}
/****************************************************************************
 * Function Name  : rrm_cellm_erb_setup_and_modification_allowed 
 * Inputs         : rrm_cell_index_t cell_index
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : erb modification is allowed or not
 ****************************************************************************/
	rrm_calls_allowed_et 
rrm_cellm_erb_setup_and_modification_allowed(rrm_cell_index_t cell_index)
{
	return rrm_cellm_admission_control(cell_index, RRM_TRUE);
}
/******************************************************************
  Function Name	:	rrm_log_cell_info
Inputs		:	rrm_cell_context_t's pointer
Outputs		:	none
Return		:	
Description	:	This function write the cell info in file
 *******************************************************************/
	rrm_return_et
rrm_log_cell_info(const rrm_cell_context_t *ptr_rrm_cell_context)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    FILE *fptr_cell_log= NULL;
    char* arrow="--->";
    U8 mcc_count =RRM_ZERO;	
    U8 mnc_count =RRM_ZERO;
    U8 drx_count =RRM_ZERO;
    U8 qci_count =RRM_ZERO;
    U8 srb_count =RRM_ZERO;
    U8 scgd_info_count = RRM_ZERO;	
    U8 csg_count =RRM_ZERO;
    U8 hnb_count =RRM_ZERO;

    /* FIx for Coverity, LTE_RRM_MALL, CID:11193 [Prasant] */
    RRM_ASSERT(RRM_PNULL != ptr_rrm_cell_context);
    /* SPR 19337 : CID 11193 fix start */
    /* open the file */
    fptr_cell_log = rrm_fopen((const char*)LTE_RRM_CELL_INFO_LOG,"w+");
    /* SPR 19337 : CID 11193 fix stop */
    /*check for null file  pointer*/
    if(RRM_PNULL == fptr_cell_log)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_ERROR,
                "null file pointer"
                "fptr_cell_log");
        /* SPR 21251 End */

        /*LTE_RRM_KLOCWORK_WARN_JULY_START*/
        return RRM_FAILURE;
        /*LTE_RRM_KLOCWORK_WARN_JULY_END*/
    }

    /*here we start to log the cell_context's selected memebers*/
    RRM_FPRINTF(fptr_cell_log,"\ncell_context_t : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\nbitmask_t : %u",(U32)ptr_rrm_cell_context->bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\ncell_states_et : %d",ptr_rrm_cell_context->cell_state);

    /*-----------rrm_global_cell_id_t :------------------*/
    RRM_FPRINTF(fptr_cell_log,"\nglobal_cell_id_t : %s",arrow);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask : %d",ptr_rrm_cell_context->global_cell_id.primary_plmn_id.bitmask);*/

    for(mcc_count =RRM_ZERO ; mcc_count <MAX_MCC_DIGITS;mcc_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\t\tmcc[%d] : %d",mcc_count,ptr_rrm_cell_context->global_cell_id.primary_plmn_id.mcc[mcc_count]);
    }
    RRM_FPRINTF(fptr_cell_log,"\n\t\tnum_mnc_digit : %d",ptr_rrm_cell_context->global_cell_id.primary_plmn_id.num_mnc_digit);

    for(mnc_count = RRM_ZERO; mnc_count<MAX_MNC_DIGITS;mnc_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\t\tmnc[%d] : %d",mnc_count,ptr_rrm_cell_context->global_cell_id.primary_plmn_id.mnc[mnc_count]);
    }
    /*---------------------------------------------------*/

    /*----------------------ran_t------------------------*/
    RRM_FPRINTF(fptr_cell_log,"\nran_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\tbitmask : %u",(U32)ptr_rrm_cell_context->ran_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\tantenna_info : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tantenna_ports_count_number : %d",ptr_rrm_cell_context->ran_info.antenna_info.antenna_ports_count_number);
    RRM_FPRINTF(fptr_cell_log,"\n\tphysical_layer_params : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask : %u",(U32)ptr_rrm_cell_context->ran_info.physical_layer_params.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_pdsch : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tp_b : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tp_a : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a);

    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_prach : %s",arrow);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.bitmask);*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\troot_sequence_index : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.root_sequence_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tconfiguration_index : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.configuration_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\thigh_speed_flag : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.high_speed_flag);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tzero_correlation_zone_config : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.zero_correlation_zone_config);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tfrequency_offset : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_prach.frequency_offset);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_pucch : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_pucch_shift : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tn_rb_cqi : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tn_cs_an : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n_cs_an);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tn1_pucch_an : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n1_pucch_an);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tcqi_pucch_resource_index : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.cqi_pucch_resource_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_pusch : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tn_sb : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pusch.n_sb);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpusch_hopping_mode : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pusch.pusch_hopping_mode);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\thopping_offset : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pusch.hopping_offset);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tenable_64_qam : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_pusch.enable_64_qam);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_ul_reference_signal : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tgroup_hopping_enabled : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_hopping_enabled);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tgroup_assignment_pusch : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.group_assignment_pusch);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tsequence_hopping_enabled : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.sequence_hopping_enabled);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tcyclic_shift : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_reference_signal.cyclic_shift);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphysical_layer_param_ul_power_control : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tp_0_nominal_pusch : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch);	
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\talpha : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_power_control.alpha);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tp_0_nominal_pucch : %d",ptr_rrm_cell_context->ran_info.physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pucch);
    /* BUG_371 FIX START */
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_f_pucch_format_1 : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_f_pucch_format_1b : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_f_pucch_format_2 : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_f_pucch_format_2a : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_f_pucch_format_2b : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdelta_preamble_msg_3 : %d",ptr_rrm_cell_context->operator_info.rrm_operator_ul_pwr_ctrl.delta_preamble_msg_3);
    /* BUG_371 FIX END */
    RRM_FPRINTF(fptr_cell_log,"\n\tmac_layer_params : %s",arrow);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.bitmask);*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tmac_layer_param_rach : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpreamble_info : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tnumber_of_ra_preambles : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.number_of_ra_preambles);	
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tsize_of_ra_group_a : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.size_of_ra_group_a);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tmessage_size_group_a : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.message_size_group_a);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tmessage_power_offset_group_b : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.message_power_offset_group_b);*/
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpower_ramping_step : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_info.power_ramping_step);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpreamble_initial_received_target_power : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_initial_received_target_power);	
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpreamble_trans_max : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.preamble_trans_max);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tresponse_window_size : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.response_window_size);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tcontention_resolution_timer : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.contention_resolution_timer);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tmax_harq_msg_3tx : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_rach.max_harq_msg_3tx);
        RRM_FPRINTF(fptr_cell_log,"\n\t\tmac_layer_param_drx : %s",arrow);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tnum_valid_drx_profiles : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.num_valid_drx_profiles);
     */
    for(drx_count = RRM_ZERO; drx_count<MAX_NO_DRX_PROFILE;drx_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdrx_config[%d] : %s",drx_count,arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tbitmask : %u",(U32)ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tnum_qci : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].num_qci);

        for( qci_count=RRM_ZERO;qci_count<RRM_MAX_QCI;qci_count++)
        {
            RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tqci[%d] : %d",qci_count,ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].qci[qci_count]);
        }
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\ton_duration_timer : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].on_duration_timer);

        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tdrx_inactivity_timer : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].drx_inactivity_timer);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tdrx_retransmission_timer : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].drx_retransmission_timer);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tlong_drx_cycle : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].long_drx_cycle);
#ifdef ENDC_ENABLED
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tlong_drx_cycle_r15 : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].long_drx_cycle_r15);
#endif
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tdrx_start_offset : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].drx_start_offset);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tshort_drx_cycle : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].short_drx_cycle);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tdrx_short_cycle_timer : %d",ptr_rrm_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_config[drx_count].drx_short_cycle_timer);

    }
    RRM_FPRINTF(fptr_cell_log,"\n\trlc_layer_params : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tnum_valid_srb_info : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.num_valid_srb_info);

    for( srb_count = RRM_ZERO ;srb_count < MAX_NO_SRB;srb_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\t\trlc_layer_param_srb[%d] : %s",srb_count,arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %u",(U32)ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdefault_configuration : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].default_configuration);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tsrb_params : %s",arrow);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tt_poll_retransmit : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.t_poll_retransmit);	
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tpoll_pdu : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.poll_pdu);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tpoll_byte : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.poll_byte);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tmax_retx_threshold : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.max_retx_threshold);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tt_reordering : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.t_reordering);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tt_status_prohibit : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.t_status_prohibit);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tpriority : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.priority);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tpiroritized_bit_rate : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.piroritized_bit_rate);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tbucket_size_duration : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.bucket_size_duration);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tlogical_channel_group : %d",ptr_rrm_cell_context->ran_info.rlc_layer_params.rlc_layer_param_srb[srb_count].srb_params.logical_channel_group);

    }

    RRM_FPRINTF(fptr_cell_log,"\n\tcell_restriction_params : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tcell_and_access_barring : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tcell_barred : %d",ptr_rrm_cell_context->ran_info.cell_restriction_params.cell_and_access_barring.cell_barred);
    /* SPR 10730 Fix Start */
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbarring_for_emergency : %d",ptr_rrm_cell_context->ran_info.cell_restriction_params.cell_and_access_barring.barring_for_emergency);	
    /* SPR 10730 Fix End */
    /*-----------------------------------------------------*/	




    /*----------------------------operator_info------------------------------*/
    RRM_FPRINTF(fptr_cell_log,"\noperator_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\tbitmask : %u",(U32)ptr_rrm_cell_context->operator_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\tcell_params : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tsub_carrier_spacing : %d",ptr_rrm_cell_context->operator_info.cell_params.sub_carrier_spacing);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_cyclic_prefix : %d",ptr_rrm_cell_context->operator_info.cell_params.dl_cyclic_prefix);
    RRM_FPRINTF(fptr_cell_log,"\n\t\trb_size : %d",ptr_rrm_cell_context->operator_info.cell_params.rb_size);
    RRM_FPRINTF(fptr_cell_log,"\n\trrm_mac_config : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tmax_harq_retrans : %d",ptr_rrm_cell_context->operator_info.rrm_mac_config.max_harq_retrans);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tstart_rarnti_range : %d",ptr_rrm_cell_context->operator_info.rrm_mac_config.start_rarnti_range);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tend_rarnti_range : %d",ptr_rrm_cell_context->operator_info.rrm_mac_config.end_rarnti_range);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tenable_frequency_selective_scheduling : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tul_freq_selective_enable : %d",ptr_rrm_cell_context->operator_info.rrm_mac_config.enable_frequency_selective_scheduling.ul_freq_selective_enable);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tdl_freq_selective_enable : %d",ptr_rrm_cell_context->operator_info.rrm_mac_config.enable_frequency_selective_scheduling.dl_freq_selective_enable);
    RRM_FPRINTF(fptr_cell_log,"\n\tphich_config : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphich_resource : %d",ptr_rrm_cell_context->operator_info.phich_config.phich_resource);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tphich_duration : %d",ptr_rrm_cell_context->operator_info.phich_config.phich_duration);
    RRM_FPRINTF(fptr_cell_log,"\n\tfrequency_selective_scheduling : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tul_freq_selective_enable : %d",ptr_rrm_cell_context->operator_info.frequency_selective_scheduling.ul_freq_selective_enable);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_freq_selective_enable : %d",ptr_rrm_cell_context->operator_info.frequency_selective_scheduling.dRRM_FPRINTFl_freq_selective_enable);	
     */	RRM_FPRINTF(fptr_cell_log,"\n\tcontention_free_rach_timer : %d",ptr_rrm_cell_context->operator_info.contention_free_rach_timer);
    RRM_FPRINTF(fptr_cell_log,"\n\tsib_1_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask : %u",(U32)ptr_rrm_cell_context->operator_info.sib_1_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\tfrequency_band_indicator : %d",ptr_rrm_cell_context->operator_info.sib_1_info.frequency_band_indicator);*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tcell_access_info : %s",arrow);
    /* BUG_371 FIX START */
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tintra_frequency_reselection : %d",ptr_rrm_cell_context->ran_info.cell_restriction_params.
            cell_and_access_barring.cell_access_info.intra_frequency_reselection);
    /* BUG_371 FIX END */
    RRM_FPRINTF(fptr_cell_log,"\n\t\tsi_window_length : %d",ptr_rrm_cell_context->operator_info.sib_1_info.si_window_length);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tscheduling_info_list : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tcount : %d",ptr_rrm_cell_context->operator_info.sib_1_info.scheduling_info_list.count);

    for( scgd_info_count = RRM_ZERO; scgd_info_count<MAX_SCHEDULING_INFO_LIST ;scgd_info_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tscheduling_info : %s",arrow);
        /*	RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tsib_mapping_info : %s",arrow);
            RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tcount : %d",ptr_rrm_cell_context->operator_info.sib_1_info.scheduling_info_list.scheduling_info.sib_mapping_info.count);*/
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tsib_type : %s",arrow);
        /*	for(short int j = RRM_ZERO;j<32 ;j++)
            {
            RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tsib_type : %d",sib_type[j]);	
            }*/
        /*		RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tsi_periodicity : %d",ptr_rrm_cell_context->operator_info.sib_1_info.scheduling_info_list.scheduling_info.si_periodicity);
         */	
       /*Coverity_fix_start_54946*/
    }
    RRM_FPRINTF(fptr_cell_log,"\n\t\tims_emergency_support_r9 : %d",ptr_rrm_cell_context->operator_info.sib_1_info.ims_emergency_support_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tcell_selection_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %u",(U32)ptr_rrm_cell_context->operator_info.sib_1_info.cell_selection_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tq_qual_min_r9 : %d",ptr_rrm_cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tq_qual_min_offset_r9_present : %d",ptr_rrm_cell_context->operator_info.sib_1_info.cell_selection_info.q_qual_min_offset_r9_present);
    RRM_FPRINTF(fptr_cell_log,"\n\tsib_2_info : %s",arrow);
    /*
       RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask : %d",ptr_rrm_cell_context->operator_info.sib_2_info.bitmask);
       RRM_FPRINTF(fptr_cell_log,"\n\t\taccess_barring_info : %s",arrow);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.bitmask);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\tac_barring_for_mo_signalling : %s",arrow);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_factor : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_signalling.ac_barring_factor);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_time : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_signalling.ac_barring_time);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_for_special_ac : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_signalling.ac_barring_for_special_ac);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\tac_barring_for_mo_data : %s",arrow);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_factor : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_data.ac_barring_factor);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_time : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_data.ac_barring_time);
       RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_for_special_ac : %d",ptr_rrm_cell_context->operator_info.sib_2_info.access_barring_info.ac_barring_for_mo_data.ac_barring_for_special_ac);
     */
    RRM_FPRINTF(fptr_cell_log,"\n\t\tradio_res_config_common_sib : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\trrm_bcch_config : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tmodification_period_coeff : %d",ptr_rrm_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.rrm_bcch_config.modification_period_coeff);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\trrm_pcch_config : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tdefault_paging_cycle : %d",ptr_rrm_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.default_paging_cycle);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tnB : %d",ptr_rrm_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.rrm_pcch_config.nB);	
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tul_cyclic_prefix_length : %d",ptr_rrm_cell_context->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length);
    RRM_FPRINTF(fptr_cell_log,"\n\t\trrm_freq_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %u",(U32)ptr_rrm_cell_context->operator_info.sib_2_info.rrm_freq_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tul_carrier_freq : %d",ptr_rrm_cell_context->operator_info.sib_2_info.rrm_freq_info.ul_carrier_freq);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tadditional_spectrum_emission : %d",ptr_rrm_cell_context->operator_info.sib_2_info.rrm_freq_info.additional_spectrum_emission);
    RRM_FPRINTF(fptr_cell_log,"\n\t\ttime_alignment_timer : %d",ptr_rrm_cell_context->operator_info.sib_2_info.time_alignment_timer);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\tssac_barring_r9 : %s",arrow);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tssac_barring_for_mmtel_voice_r9 : %s",arrow);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_factor : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_factor);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_time : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_time);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_for_special_ac : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\tssac_barring_for_mmtel_video_r9 : %s",arrow);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_factor : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_factor);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_time : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_time);
        RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tac_barring_for_special_ac : %d",ptr_rrm_cell_context->operator_info.sib_2_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac);
     */
    RRM_FPRINTF(fptr_cell_log,"\n\tsib_3_info : %s",arrow);

/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tbitmask:%u",(U32)ptr_rrm_cell_context->operator_info.sib_3_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tintra_freq_reselection_info : %s",arrow);
/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %u",(U32)ptr_rrm_cell_context->operator_info.sib_3_info.intra_freq_reselection_info.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tmeasurement_bandwidth : %d",ptr_rrm_cell_context->operator_info.sib_3_info.intra_freq_reselection_info.measurement_bandwidth);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tpresence_antenna_port1 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.intra_freq_reselection_info.presence_antenna_port1);
    RRM_FPRINTF(fptr_cell_log,"\n\t\ts_intra_search : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\ts_intra_search_p_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_p_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\ts_intra_search_q_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.s_intra_search.s_intra_search_q_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\ts_non_intra_search : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\ts_non_intra_search_p_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_p_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\ts_non_intra_search_q_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.s_non_intra_search.s_non_intra_search_q_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tq_qual_min_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.q_qual_min_r9);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tthresh_serving_lowq_r9 : %d",ptr_rrm_cell_context->operator_info.sib_3_info.thresh_serving_lowq_r9);

    RRM_FPRINTF(fptr_cell_log,"\n\tsib_4_info : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tcsg_id_range : %s",arrow);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\t\t\tbitmask : %d",ptr_rrm_cell_context->operator_info.sib_4_info.csg_id_range.bitmask);
     */	RRM_FPRINTF(fptr_cell_log,"\n\t\t\tstart : %d",ptr_rrm_cell_context->operator_info.sib_4_info.csg_id_range.start);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\trange : %d",ptr_rrm_cell_context->operator_info.sib_4_info.csg_id_range.range);


    RRM_FPRINTF(fptr_cell_log,"\n\tadmission_control_info : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tsrb_bit_rate : %llu",ptr_rrm_cell_context->operator_info.admission_control_info.srb_bit_rate);
    /* SPR 20653 Fix Start */
    RRM_FPRINTF(fptr_cell_log,"\n\t\tmin_sr_periodicity : %d",ptr_rrm_cell_context->operator_info.admission_control_info.min_sr_periodicity);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tmin_cqi_periodicity : %d",ptr_rrm_cell_context->operator_info.admission_control_info.min_cqi_periodicity);
    /* SPR 20653 Fix End */
    RRM_FPRINTF(fptr_cell_log,"\n\t\tcpu_utilization_limit : %d",ptr_rrm_cell_context->operator_info.admission_control_info.cpu_utilization_limit);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tmax_num_ue_per_cell : %d",ptr_rrm_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_prb_budget_gbr : %d",ptr_rrm_cell_context->operator_info.admission_control_info.dl_prb_budget_gbr);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tul_prb_budget_gbr : %d",ptr_rrm_cell_context->operator_info.admission_control_info.ul_prb_budget_gbr);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_prb_budget_ngbr : %d",ptr_rrm_cell_context->operator_info.admission_control_info.dl_prb_budget_ngbr);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tul_prb_budget_ngbr : %d",ptr_rrm_cell_context->operator_info.admission_control_info.ul_prb_budget_ngbr);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tngbr_threshold : %d",ptr_rrm_cell_context->operator_info.admission_control_info.ngbr_threshold);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tnon_default_bearer_multiplier : %d",ptr_rrm_cell_context->operator_info.admission_control_info.non_default_bearer_multiplier);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_total_bw_prbs : %d",ptr_rrm_cell_context->operator_info.admission_control_info.dl_total_bw_prbs);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tul_total_bw_prbs : %d",ptr_rrm_cell_context->operator_info.admission_control_info.ul_total_bw_prbs);
    RRM_FPRINTF(fptr_cell_log,"\n\t\tdl_bw_for_control_prbs : %d",ptr_rrm_cell_context->operator_info.admission_control_info.dl_bw_for_control_prbs);
        /*SPR 18654 START*/
        /*code deleted*/
        /*SPR 18654 END*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\tsnr_map : %s",arrow);

    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tsnr_dep_params:uplink_snr_dep_params : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.ul_mcs);

/* SPR 20636 Changes Start*/
                /* SPR 20430 Changes Start*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tsnr_dep_params:uplink_snr_dep_params : %u",(U32)ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.bitmask);
                /* SPR 20430 Changes End*/
/* SPR 20636 Changes End*/
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tul_prb_per_bps : %f",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\tpusch_config_dedicated : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tbeta_offset_ack_index : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.beta_offset_ack_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tbeta_offset_ri_index : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.beta_offset_ri_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tbeta_offset_cqi_index : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.beta_offset_cqi_index);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\tuplink_pow_control : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pusch);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tdelta_mcs_enabled : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.delta_mcs_enabled);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\taccumulation_enabled : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.accumulation_enabled);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tp0_ue_pucch : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pucch);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tp_srs_offset : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p_srs_offset);
    RRM_FPRINTF(fptr_cell_log,"\n\t\t\t\t\tfilter_coefficient : %d",ptr_rrm_cell_context->operator_info.admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.filter_coefficient);


    /*-----------------------------------------------------------------------*/

    /*-----------------------------------ccess_mgmt_params------------------------------------*/
    RRM_FPRINTF(fptr_cell_log,"\naccess_mgmt_params : %s",arrow);
    RRM_FPRINTF(fptr_cell_log,"\n\taccess_mode : %d",ptr_rrm_cell_context->access_mgmt_params.access_mode);
    /*	RRM_FPRINTF(fptr_cell_log,"\n\tmax_ues_served : %d",ptr_rrm_cell_context->access_mgmt_params.max_ues_served);*/
    RRM_FPRINTF(fptr_cell_log,"\n\tmax_csg_members : %d",ptr_rrm_cell_context->access_mgmt_params.max_csg_members);
    RRM_FPRINTF(fptr_cell_log,"\n\tmax_non_csg_members : %d",ptr_rrm_cell_context->access_mgmt_params.max_non_csg_members);
    RRM_FPRINTF(fptr_cell_log,"\n\tmax_resource_non_csg_members : %d",ptr_rrm_cell_context->access_mgmt_params.max_resource_non_csg_members);
    RRM_FPRINTF(fptr_cell_log,"\n\thnb_name_size : %d",ptr_rrm_cell_context->access_mgmt_params.hnb_name_size);

    for( csg_count = RRM_ZERO;csg_count<NUM_CSG_OCTETS;csg_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\tcsg_id : %d",ptr_rrm_cell_context->access_mgmt_params.csg_id[csg_count]);	
    }

    for(hnb_count = RRM_ZERO ;hnb_count<RRMCM_MAX_HNB_ID;hnb_count++)
    {
        RRM_FPRINTF(fptr_cell_log,"\n\thbname : %d",ptr_rrm_cell_context->access_mgmt_params.hnb_name[hnb_count]);
    }
    /*-----------------------------------------------------------------------*/	

    RRM_FPRINTF(fptr_cell_log,"\nongoing_trans_id : %d",ptr_rrm_cell_context->ongoing_trans_id);

    if(fptr_cell_log)
    {
        RRM_FFLUSH(fptr_cell_log);
        rrm_fclose(fptr_cell_log);
    }
    /*Coverity_fix_end_54946*/
    return ret_val;
}


/* UPDATED NRT INFO CHANGES START */ 
/****************************************************************************
 * Function Name  : rrm_cellm_updated_nrt_info_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *		          : U16 api_id : api id
 *		          : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the updated_nrt_info message to cell rrm
 ****************************************************************************/

rrm_return_et
rrm_cellm_updated_nrt_info_process_msg(
		void *p_api,/*pointer pt api buffer*/
		U16 api_id /*API id of incoming message*/
            /*SPR 17777 +-*/
		)
{
	rrm_cell_index_t  cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	cell_index = ((rrmcm_rmif_updated_nrt_info_t *)p_api)->cellindex;
	RRM_ASSERT(cell_index < RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
			"MIF->RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ->CellM:[CELL:%d]", cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"cell context is null for cell index: %d", cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 

	/* message processing to FSM
	 */
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = 
		RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ;  
	p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
		((rrmcm_rmif_updated_nrt_info_t *)p_api)->transaction_id;
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */
		if (RRM_FAILURE == cellm_fsm_process_event (
					RRMCM_RMIF_UPDATED_NRT_INFO_EVENT,
					p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
		{
			ret_val = RRM_FAILURE;
		}
		else
		{
			ret_val = RRM_SUCCESS;
		}
   /* SPR 11681 Fix Start */
   /* Code deleted */
   /* SPR 11681 Fix End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* UPDATED NRT INFO CHANGES END */ 

/* TNL DISCOVERY */
/* Fix 960 Start */
rrm_return_et
rrm_store_tnl_discovery_trans_id(
    rrmcm_rmif_cell_son_tnl_discovery_req_t *p_tnl_discovery_req
)
{
    rrm_return_et                              ret_val                       = RRM_SUCCESS;
    rrm_tnl_discovery_trans_id_node_t         *p_tnl_discovery_trans_id_node = RRM_PNULL;
    rrm_tnl_discovery_trans_id_list_t         *p_tnl_discovery_trans_id_list = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_tnl_discovery_trans_id_list = &(p_g_rrm_cell_ctx->rrm_tnl_discovery_trans_id_list);

    p_tnl_discovery_trans_id_node = (rrm_tnl_discovery_trans_id_node_t *)
                                        rrm_mem_get(sizeof(rrm_tnl_discovery_trans_id_node_t));
    if (RRM_PNULL == p_tnl_discovery_trans_id_node)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation failure for p_tnl_discovery_trans_id_node");
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }
    else
    {
        /* Spr 16142 Fix Start */
        RRM_MEMSET((void *)p_tnl_discovery_trans_id_node,0,
                sizeof(rrm_tnl_discovery_trans_id_node_t));
        /* Spr 16142 Fix End */

        p_tnl_discovery_trans_id_node->trans_id = p_tnl_discovery_req->transaction_id;
        /* SPR 9463 Fix-2 Start */
        rrm_memcpy_gl_enb_id(&p_tnl_discovery_trans_id_node->enb_id,
            &p_tnl_discovery_req->tnl_discovery_req.target_enb_id);

        ylPushTail(p_tnl_discovery_trans_id_list, &(p_tnl_discovery_trans_id_node->sNode));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Node created string enb id with trans id = %d Enb-Trans list size = %d", 
            p_tnl_discovery_trans_id_node->trans_id, ylCount(p_tnl_discovery_trans_id_list));

        /* SPR 9463 Fix-2 End */
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;    
}
/* Fix 960 End */

/****************************************************************************
 * Function Name  : rrm_cellm_tnl_discovery_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the tnl discovery message and sends to RRC
 ****************************************************************************/

rrm_return_et
rrm_cellm_tnl_discovery_process_msg(
		void *p_api/*pointer pt api buffer*/
            /*SPR 17777 +-*/
		)
{
	rrm_return_et ret_val = RRM_SUCCESS;
        /* SPR_17367_Start */
	rrmcm_rmif_son_tnl_discovery_resp_t tnl_res = {RRM_NULL};
        /* SPR_17367_End */

	RRM_UT_TRACE_ENTER();
	rrmcm_rmif_cell_son_tnl_discovery_req_t *p_tnl_dis_req = RRM_PNULL;

	p_tnl_dis_req = (rrmcm_rmif_cell_son_tnl_discovery_req_t *)p_api;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_REQ->CellM");
    /* Fix 960 Start */
	if(RRM_SUCCESS == rrm_store_tnl_discovery_trans_id(p_tnl_dis_req))
	{
		/* SPR_17367_Start */
		if(RRM_FAILURE == rrm_build_and_send_enb_config_tranfer_req(p_tnl_dis_req, &p_g_rrm_cell_ctx->enb_context))
		{
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,"failed to build enb_config_tranfer_req ");
			ret_val = RRM_FAILURE;                                 
			tnl_res.transaction_id = p_tnl_dis_req->transaction_id;
			tnl_res.tnl_discovery_resp.result = RRM_FAILURE;
			tnl_res.tnl_discovery_resp.error_code = RRM_ERR_NO_MME_CONNECTED_TO_TARGET;
			tnl_res.tnl_discovery_resp.target_enb_id = p_tnl_dis_req->tnl_discovery_req.target_enb_id;
			tnl_res.tnl_discovery_resp.enb_tnl_address_list_size = RRM_ZERO;

			if(RRM_FAILURE ==  build_and_send_tnl_discovery_resp_to_mif(&tnl_res,RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_RES))
			{
				RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,"unable to send tnl discovery response to mif ");
				ret_val = RRM_FAILURE;
			}   
		}   
		/* SPR_17367_End */
		else
		{
			/*Raising event LOCAL_ENB_CONFIGURATION_TRANSFER
			  RRM shall send this event when the S1 message
			  "eNB CONFIGURATION TRANSFER" is sent by RRM towards MME
			  */
			rrm_raise_event_enb_config_transfer();
		}
    }
    else
    {
        ret_val = RRM_FAILURE;
	    /* SPR_17367_Start */
        tnl_res.transaction_id = p_tnl_dis_req->transaction_id;
        tnl_res.tnl_discovery_resp.result = RRM_FAILURE;
        tnl_res.tnl_discovery_resp.error_code = RRM_ERR_INTERNAL_FAILURE;
        tnl_res.tnl_discovery_resp.target_enb_id = p_tnl_dis_req->tnl_discovery_req.target_enb_id;
        tnl_res.tnl_discovery_resp.enb_tnl_address_list_size = RRM_ZERO;

        if(RRM_FAILURE ==  build_and_send_tnl_discovery_resp_to_mif(&tnl_res,RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_RES))
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,"unable to send tnl discovery response to mif ");
            ret_val = RRM_FAILURE;
        }
        /* SPR_17367_End */
    }
    /* Fix 960 End */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}    




U16 max_num_of_resources_for_assigned_periodicity_cqi(U16    cqi_periodicity)
{
	U16     max_num_of_cqi_resources = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	switch(cqi_periodicity)
	{
		case CQI_PERIODICITY_0:
			max_num_of_cqi_resources = CQI_PERIODICITY_2MS;
			break;

		case CQI_PERIODICITY_1:
			max_num_of_cqi_resources = CQI_PERIODICITY_5MS;
			break;

		case CQI_PERIODICITY_2:
			max_num_of_cqi_resources = CQI_PERIODICITY_10MS;
			break;

		case CQI_PERIODICITY_3:
			max_num_of_cqi_resources = CQI_PERIODICITY_20MS;
			break;

		case CQI_PERIODICITY_4:
			max_num_of_cqi_resources = CQI_PERIODICITY_40MS;
			break;

		case CQI_PERIODICITY_5:
			max_num_of_cqi_resources = CQI_PERIODICITY_80MS;
			break;

		case CQI_PERIODICITY_6:
			max_num_of_cqi_resources = CQI_PERIODICITY_160MS;
			break;

	}
	RRM_UT_TRACE_EXIT();
	return max_num_of_cqi_resources;
}


U16 max_num_of_resources_for_assigned_periodicity(U16    sr_periodicity)
{
	U16     max_num_of_sr_resources = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	switch(sr_periodicity)
	{
		case SR_PERIODICITY_0:
			max_num_of_sr_resources = SR_PERIODICITY_5MS;
			break;

		case SR_PERIODICITY_1:
			max_num_of_sr_resources = SR_PERIODICITY_10MS;
			break;

		case SR_PERIODICITY_2:
			max_num_of_sr_resources = SR_PERIODICITY_20MS;
			break;

		case SR_PERIODICITY_3:
			max_num_of_sr_resources = SR_PERIODICITY_40MS;
			break;

		case SR_PERIODICITY_4:
			max_num_of_sr_resources = SR_PERIODICITY_80MS;
			break;
            /* SPR 18871 Fix Start */
		case SR_PERIODICITY_5:
			max_num_of_sr_resources = SR_PERIODICITY_2MS;
			break;
		case SR_PERIODICITY_6:
			max_num_of_sr_resources = SR_PERIODICITY_1MS;
			break;
            /* SPR 18871 Fix End */

	}
	RRM_UT_TRACE_EXIT();

	return max_num_of_sr_resources;
}







rrm_void_t  shuffle_ri_indexes(U16      *ri_index, U16      size)
{

	/*    RRM_UT_TRACE_ENTER();*/

	U16      i = RRM_ZERO;
	U16      temp = RRM_ZERO;
	for (i = RRM_ZERO; i < size; i++)
	{
		temp = ri_index[i];
		if (size <= (i + RRM_ONE))
		{
			break;
		}
		else
		{
			ri_index[i] = ri_index[i+RRM_ONE];
			ri_index[i+RRM_ONE] = temp;
		}
	}
	/*   RRM_UT_TRACE_EXIT();*/

}

/*klock_works_changes_start*/
void rrm_find_cfg_configured_duration 
(
 rrm_cell_context_t *p_cell_context,
 U16                *cfg_configured, 
 U16                *cfg_configured_upper_bound
)
{
    RRM_UT_TRACE_ENTER();

    /* SPR 20653 Fix Start */
    switch(p_cell_context->operator_info.admission_control_info.min_sr_periodicity)
        /* SPR 20653 Fix End */
    {
        case SR_PERIODICITY_0:
             *cfg_configured = SR_PERIODICITY_5MS;
             break;

        case SR_PERIODICITY_1:
             *cfg_configured = SR_PERIODICITY_10MS;
             break;

        case SR_PERIODICITY_2:
             *cfg_configured = SR_PERIODICITY_20MS;
             break;

        case SR_PERIODICITY_3:
             *cfg_configured = SR_PERIODICITY_40MS;
             break;

        case SR_PERIODICITY_4:
             *cfg_configured = SR_PERIODICITY_80MS;
             break;

       /* SPR 18871 Fix Start */
        case SR_PERIODICITY_5:
             *cfg_configured = SR_PERIODICITY_2MS;
             break;

        case SR_PERIODICITY_6:
             *cfg_configured = SR_PERIODICITY_1MS;
             break;
       /* SPR 18871 Fix End */
        default :
             /* SPR 20653 Fix Start */
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                     "Incorrect Value(%d) configured from CFG, so picking up 10ms Periodicity",
                     p_cell_context->operator_info.admission_control_info.min_sr_periodicity);
             /* SPR 20653 Fix End */
             *cfg_configured = SR_PERIODICITY_10MS;
    }
    
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    RRM_UT_TRACE_EXIT();
}

void chek_and_fill_sr_periodicity_from_cell_context
(
 U16                *sr_periodicity,
 rrm_cell_context_t *p_cell_context,
 U16                *cfg_configured,
 U16                *cfg_configured_upper_bound,
 U16                *runtime_calculated 
 )
{

#ifdef TDD_MODE_FLAG
	U8                      tdd_subfrm_config = RRM_ZERO;
    U16                     transient_data_for_sr = RRM_ZERO;
#endif    

    RRM_UT_TRACE_ENTER();

    /* SPR 7952_FIX_START */
#ifndef TDD_MODE_FLAG
    /* SPR 20653 Fix Start */
    if( *sr_periodicity < p_cell_context->operator_info.admission_control_info.min_sr_periodicity )
    {
        *sr_periodicity = p_cell_context->operator_info.admission_control_info.min_sr_periodicity;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Value chosen for SR Periodicity is(%d)ms",
                *cfg_configured);
    }
    /* Code Removed */
    /* SPR 20653 Fix End */
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Value chosen for SR Periodicity is(%d)ms",
                *runtime_calculated);
    }
    /* SPR 7957_FIX_END */
#else
    /* SPR 20653 Fix Start */
    if( *sr_periodicity < p_cell_context->operator_info.admission_control_info.min_sr_periodicity )
    {
        *sr_periodicity = p_cell_context->operator_info.admission_control_info.min_sr_periodicity;
        transient_data_for_sr = *cfg_configured;
    }
    /* Code removed */
    /* SPR 20653 Fix End */
    else
    {
        transient_data_for_sr = *runtime_calculated;
    }
    if(p_cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
    {
        tdd_subfrm_config = p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.sub_frame_assignment;
        if ((RRM_OAM_SA0 == tdd_subfrm_config) ||
                (RRM_OAM_SA1 == tdd_subfrm_config) ||
                (RRM_OAM_SA2 == tdd_subfrm_config) ||
                (RRM_OAM_SA6 == tdd_subfrm_config)
           )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Value chosen for SR Periodicity is(%d)ms in TDD UL/DL Config 0, 1, 2, 6",
                    transient_data_for_sr);
        }
        else if ((RRM_OAM_SA3 == tdd_subfrm_config) ||
                (RRM_OAM_SA4 == tdd_subfrm_config) ||
                (RRM_OAM_SA5 == tdd_subfrm_config)
                )
        {
            if (*sr_periodicity < SR_PERIODICITY_1)
            {
                *sr_periodicity = SR_PERIODICITY_1;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Value of SR in %dms can't be supported in TDD UL/DL Config 3,4,5 so taking minimum of 10ms",
                        transient_data_for_sr);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Value chosen for SR Periodicity is(%d)ms",
                        transient_data_for_sr);
            } 
        }
    }

#endif    
    /* SPR 7952_FIX_END */
    RRM_UT_TRACE_EXIT();
}
/*klock_works_changes_end*/



rrm_void_t find_sr_periodicity_from_cell_context
(
 rrm_cell_context_t *p_cell_context,
 U16                *p_sr_periodicity,
 /* SPR 11003 Fix Start */
 U16                *p_n_one_pucch_an
 /* SPR 11003 Fix End */
 )
{

/* SPR 12387 Fix Start */
    *p_n_one_pucch_an = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.sr_n1_pucch_an_last_indx + RRM_ONE;
	*p_sr_periodicity = p_cell_context->sr_data.sr_periodicity;

/* SPR 12387 Fix End */
	RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name  : rrm_return_k_basd_on_dl_bw 
 * Inputs         : cell_index
 * Outputs        : value of k
 * Returns        : value of k
 * Description    : returns value of k based on dl bandwidth
 ****************************************************************************/
	U8
rrm_return_k_basd_on_dl_bw(rrm_cell_index_t  cell_index)
{
	U8 k = RRM_ZERO;

	rrm_oam_band_width_et dl_bandwidth  =  
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->
		ran_info.rf_params.rf_configurations.dl_bandwidth;

	switch(dl_bandwidth)
	{
		case RRM_OAM_BW_N_6:
			k = RRM_ONE; 
			break;
		case RRM_OAM_BW_N_15:
		case RRM_OAM_BW_N_25:
			k = RRM_FOUR;
			break;
		case RRM_OAM_BW_N_50:
			k = RRM_SIX;
			break;
		case RRM_OAM_BW_N_75:
		case RRM_OAM_BW_N_100:
			k = RRM_EIGHT;
			break;
		default:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
					"Incorrect value received for dl_bandwidth = %u i" 
					"returned value of k zero",  dl_bandwidth);
			break;
	}/** switch case ends here*/

	return k;
}
U8 rrm_cellm_subband_cqi_param (rrm_cell_index_t cell_index)
{
    U8 k = RRM_ZERO;
    if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask & RRMCM_RMIF_SUBBAND_CQI_PRESENT)
    {
        k = (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.k);
    }
    else
    {
        k = RRM_ONE;
    }
    return k;
}

U8 rrm_cellm_subband_periodic_reporting(rrm_cell_index_t cell_index)
{
    U8 periodcity_factor = RRM_ZERO;
    if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.bitmask & RRMCM_RMIF_SUBBAND_CQI_PERIODCITY_FACTOR_PRESENT)
    {
        periodcity_factor =(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.periodicity_factor);
    }
    else
    {
        periodcity_factor = RRM_ONE; 
    }
    return periodcity_factor;
}

/* Sub Band CQI start */
	U8 
rrm_cellm_get_subband_size(void)/*SPR 17777 +-*/
{
	U8 k = RRM_ZERO;   
	RRM_UT_TRACE_ENTER();
	/* K is removed from RRM-OAM intreface so calculating value for k */ 
	/* K value currently kept 1 later relase made the decision making */
	k = RRM_ONE; /**rrm_return_k_basd_on_dl_bw(cell_index);*/
	RRM_UT_TRACE_EXIT();
	/* return the value for K*/
	return k;  

}
/* Sub Band CQI end */
U16 rrm_get_non_emergengy_active_call (rrm_cell_index_t cell_index)
{
	return (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_resource_info.num_active_ue);
}
/*GBR LIMIT START */
U64 rrm_cellm_get_used_dl_bitrate(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit;
}

U64 rrm_cellm_get_used_ul_bitrate(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();
	return p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit;
}

void rrm_cellm_set_used_dl_bitrate_during_erb_release(rrm_cell_index_t cell_index, U64 dl_bitrate)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /*SPR 19819 30JUN START*/
    if(p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit >= dl_bitrate)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Deallocating dl_bitrate(%llu) from used gbr limit [%llu]",
                dl_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit);
	p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit = p_rrm_cell_ctx->
		cell_resource_info.used_gbr_limit.used_dl_gbr_limit - dl_bitrate;
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
            "Resetting used_dl_bitrate to ZERO as dl_bitrate(%llu) > used gbr bitrate [%llu]",
            dl_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit);
        p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit = RRM_ZERO;
    }    
    /*SPR 19819 30JUN END*/
	RRM_UT_TRACE_EXIT();
}

void rrm_cellm_set_used_ul_bitrate_during_erb_release(rrm_cell_index_t cell_index, U64 ul_bitrate)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /*SPR 19819 30JUN START*/
    if(p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit >= ul_bitrate)
    {    
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
                "Deallocating ul_bitrate(%llu) from used gbr limit [%llu]",
                ul_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit);
	p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit = p_rrm_cell_ctx->
		cell_resource_info.used_gbr_limit.used_ul_gbr_limit - ul_bitrate;
    }   
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_WARNING,
            "Resetting used_ul_bitrate to ZERO as ul_bitrate(%llu) > used gbr ul bitrate [%llu]",
            ul_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit);
        p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit = RRM_ZERO;
    }    
    /*SPR 19819 30JUN END*/
	RRM_UT_TRACE_EXIT();
}

U16 rrm_cellm_get_dl_gbr_limit(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	U16 dl_gbr_bitrate;
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	if(p_rrm_cell_ctx->operator_info.admission_control_info.bitmask & RRMCM_RMIF_RESOURCE_RESERVED_PRESENT)
	{
		/*GBR limit for new users calculated after considering reserved resources for existing users*/
		dl_gbr_bitrate = (RRM_FLOOR)((float)(p_rrm_cell_ctx->operator_info.admission_control_info.
					avail_gbr_limit.dl_gbr_limit) * ((float)(RRM_PERCENTAGE -
							rrm_cellm_get_reserved_resource_factor(cell_index))/(float)RRM_PERCENTAGE));
	}
	else
	{
		dl_gbr_bitrate = p_rrm_cell_ctx->operator_info.admission_control_info.
			avail_gbr_limit.dl_gbr_limit;
	}
	RRM_UT_TRACE_EXIT();
	return dl_gbr_bitrate;
}

U16 rrm_cellm_get_ul_gbr_limit(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	U16 ul_gbr_bitrate;
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	if(p_rrm_cell_ctx->operator_info.admission_control_info.bitmask & RRMCM_RMIF_RESOURCE_RESERVED_PRESENT)
	{
		/*GBR limit for new users calculated after considering reserved resources for existing users*/
		ul_gbr_bitrate = (RRM_FLOOR)((float)(p_rrm_cell_ctx->operator_info.admission_control_info.
					avail_gbr_limit.ul_gbr_limit) * ((float)(RRM_PERCENTAGE -
							rrm_cellm_get_reserved_resource_factor(cell_index))/(float)RRM_PERCENTAGE));
	}
	else
	{
		ul_gbr_bitrate = p_rrm_cell_ctx->operator_info.admission_control_info.
			avail_gbr_limit.ul_gbr_limit;
	}

	RRM_UT_TRACE_EXIT();
	return ul_gbr_bitrate;

}

void rrm_cellm_set_used_dl_bitrate_during_erb_setup_modify(rrm_cell_index_t cell_index, U64 dl_bitrate)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /*SPR 19819 START*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
            "Allocating, dl_bitrate(%llu) + Already allocated [%llu]",
            dl_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit);
    /*SPR 19819 END*/
	p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_dl_gbr_limit = p_rrm_cell_ctx->
		cell_resource_info.used_gbr_limit.used_dl_gbr_limit + dl_bitrate;
	RRM_UT_TRACE_EXIT();
}

void rrm_cellm_set_used_ul_bitrate_during_erb_setup_modify(rrm_cell_index_t cell_index, U64 ul_bitrate)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /*SPR 19819 START*/
    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_INFO,
            "Allocating, ul_bitrate(%llu) + Already allocated [%llu]",
            ul_bitrate,p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit);
    /*SPR 19819 END*/
	p_rrm_cell_ctx->cell_resource_info.used_gbr_limit.used_ul_gbr_limit = p_rrm_cell_ctx->
		cell_resource_info.used_gbr_limit.used_ul_gbr_limit + ul_bitrate;
	RRM_UT_TRACE_EXIT();
}
/*LTE_RRM_TM_SWITCH_START*/


/****************************************************************************
 * Function Name  : rrm_get_dl_sinr_quality_threshold
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U8
 * Description    : Returns the sinr quality threshold
 ****************************************************************************/
U8 rrm_get_dl_sinr_quality_threshold(rrm_cell_index_t cell_index)
{

    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U8                        sinr_quality_threshold = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    sinr_quality_threshold = p_rrm_cell_ctx->dl_sinr_quality_threshold;

    RRM_UT_TRACE_EXIT();

    return sinr_quality_threshold;
}


/* uplink mu mimo change start*/


/****************************************************************************
 * Function Name  : rrm_prb_usage_reached_at_threshold_ind
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : rrm_void_t
 * Description    : Returns the sinr quality threshold
 ****************************************************************************/
rrm_void_t
rrm_prb_usage_reached_threshold_ind( rrm_cell_index_t cell_index)
{

    rrm_return_et               ret_val = RRM_SUCCESS;
    U64                         total_uplink_prb_usage = RRM_ZERO;
    U32                         cell_center_prb_usage = RRM_ZERO;
    U32                         cell_edge_prb_usage = RRM_ZERO;
    U32                         CELL_CENTER_PRB_USAGE_THRESHOLD = RRM_ZERO;
    U32                         CELL_EDGE_PRB_USAGE_THRESHOLD = RRM_ZERO;
    U32                         CELL_CENTER_PRB_USAGE_LOW_THRESHOLD = RRM_ZERO;
    U32                         CELL_EDGE_PRB_USAGE_LOW_THRESHOLD = RRM_ZERO;
    U32                         uplink_prb_usage_threshold_percentage = RRM_ZERO;
    U32                         uplink_prb_usage_down_percentage = RRM_ZERO;
    U32                         uplink_cell_center_prb_budget = RRM_ZERO;
    U32                         uplink_cell_edge_prb_budget = RRM_ZERO;
    rrmuem_cm_prb_threshold_reached_ind_t
                                prb_threshold_ind = { RRM_ZERO };

    RRM_UT_TRACE_ENTER();

    
    total_uplink_prb_usage = rrm_get_total_uplink_prb_usage(cell_index);

    RRM_TRACE( g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
            "Total Uplink prb usage [%llu] ",total_uplink_prb_usage);

    cell_edge_prb_usage = rrm_get_uplink_cell_edge_prb_usage(cell_index);

    cell_center_prb_usage = (((U32)total_uplink_prb_usage) - (cell_edge_prb_usage));

    RRM_TRACE( g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
    "Cell Edge prb usage [%d], Cell Center prb usage [%d]",
    cell_edge_prb_usage,cell_center_prb_usage);

    uplink_prb_usage_threshold_percentage = 
                                  rrm_get_cell_uplink_prb_usage_threshold_percentage(cell_index);
    uplink_prb_usage_down_percentage = rrm_get_cell_prb_usage_down_threshold_percentage(cell_index);

    uplink_cell_center_prb_budget = rrm_get_uplink_cell_center_prb_budget(cell_index);
    uplink_cell_edge_prb_budget = rrm_get_uplink_cell_edge_prb_budget(cell_index);
 
    RRM_TRACE( g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
    "Cell Edge Prb Budget [%d], Cell Center prb budget [%d]",
    uplink_cell_edge_prb_budget,uplink_cell_center_prb_budget );

    CELL_CENTER_PRB_USAGE_THRESHOLD = (U32)(RRM_CEILF(((float)uplink_cell_center_prb_budget * 
                                        uplink_prb_usage_threshold_percentage ) / RRM_PERCENTAGE));
 
    CELL_EDGE_PRB_USAGE_THRESHOLD = (U32)(RRM_CEILF(((float)uplink_prb_usage_threshold_percentage *
                                                      uplink_cell_edge_prb_budget )/RRM_PERCENTAGE));

    CELL_CENTER_PRB_USAGE_LOW_THRESHOLD = (U32)(RRM_FLOORF(((float)uplink_prb_usage_down_percentage *
                                           uplink_cell_center_prb_budget )/RRM_PERCENTAGE));

    CELL_EDGE_PRB_USAGE_LOW_THRESHOLD = (U32)(RRM_FLOORF(((float)uplink_prb_usage_down_percentage *
                                                 uplink_cell_edge_prb_budget )/RRM_PERCENTAGE));

    RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
    "Cell Center prb usage upper threshold [%d], Cell Center prb usage down threshold[%d]",
    CELL_CENTER_PRB_USAGE_THRESHOLD,CELL_CENTER_PRB_USAGE_LOW_THRESHOLD);
   
    RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
    "Cell Edge prb usage upper threshold [%d], Cell Edge prb usage down threshold [%d]",
    CELL_EDGE_PRB_USAGE_THRESHOLD,CELL_EDGE_PRB_USAGE_LOW_THRESHOLD);

    /* SPR 11093 Fix Start */
     prb_threshold_ind.cell_index = cell_index;
    /* SPR 11093 Fix End */

    if( cell_center_prb_usage >= CELL_CENTER_PRB_USAGE_THRESHOLD
         && cell_edge_prb_usage >= CELL_EDGE_PRB_USAGE_THRESHOLD )
    {
        prb_threshold_ind.enable = RRM_TRUE;
        prb_threshold_ind.both_cell = RRM_TRUE;
    }
    else if( cell_center_prb_usage <= CELL_CENTER_PRB_USAGE_LOW_THRESHOLD &&
             cell_edge_prb_usage <= CELL_EDGE_PRB_USAGE_LOW_THRESHOLD )
    {
        prb_threshold_ind.disable = RRM_TRUE;
        prb_threshold_ind.both_cell = RRM_TRUE;
    }
    else if( cell_center_prb_usage >= CELL_CENTER_PRB_USAGE_THRESHOLD && 
             cell_edge_prb_usage <= CELL_EDGE_PRB_USAGE_LOW_THRESHOLD )
    {
        prb_threshold_ind.enable = RRM_TRUE;
        prb_threshold_ind.cell_region_enable = RRM_CELL_CENTER_UE;
        prb_threshold_ind.disable = RRM_TRUE;
        prb_threshold_ind.cell_region_disable = RRM_CELL_EDGE_UE;
    }
    else if( cell_center_prb_usage <= CELL_CENTER_PRB_USAGE_LOW_THRESHOLD &&
             cell_edge_prb_usage >= CELL_EDGE_PRB_USAGE_THRESHOLD )
    {
        prb_threshold_ind.enable = RRM_TRUE;
        prb_threshold_ind.cell_region_enable = RRM_CELL_EDGE_UE;
        prb_threshold_ind.disable = RRM_TRUE;
        prb_threshold_ind.cell_region_disable = RRM_CELL_CENTER_UE;
    }
    else
    {
        if( cell_center_prb_usage >= CELL_CENTER_PRB_USAGE_THRESHOLD )
        {
            prb_threshold_ind.enable = RRM_TRUE;
            prb_threshold_ind.cell_region_enable = RRM_CELL_CENTER_UE;
            prb_threshold_ind.only_single_region = RRM_TRUE;
        }
        else if( cell_center_prb_usage <= CELL_CENTER_PRB_USAGE_LOW_THRESHOLD )
        {
            prb_threshold_ind.disable = RRM_TRUE;
            prb_threshold_ind.cell_region_disable = RRM_CELL_CENTER_UE;
            prb_threshold_ind.only_single_region = RRM_TRUE;
        }
        
        if( cell_edge_prb_usage >= CELL_EDGE_PRB_USAGE_THRESHOLD )
        {
            prb_threshold_ind.enable = RRM_TRUE;
            prb_threshold_ind.cell_region_enable = RRM_CELL_EDGE_UE;
            prb_threshold_ind.only_single_region = RRM_TRUE;
        }
        else if( cell_edge_prb_usage <= CELL_EDGE_PRB_USAGE_LOW_THRESHOLD )
        {
            prb_threshold_ind.disable = RRM_TRUE;
            prb_threshold_ind.cell_region_disable = RRM_CELL_EDGE_UE;
            prb_threshold_ind.only_single_region = RRM_TRUE;
        }
    }

    /* SPR 11093 Fix Start */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_BRIEF,
    "ENABLE [%d] , DISABLE [%d] CELL IDX [%d] ",prb_threshold_ind.enable,prb_threshold_ind.disable,prb_threshold_ind.cell_index);
    /* SPR 11093 Fix End */


    if( prb_threshold_ind.enable || prb_threshold_ind.disable )
    {
        ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
                                        RRMUEM_CM_PRB_THRESHOLD_REACHED_IND,
                                        sizeof(rrmuem_cm_prb_threshold_reached_ind_t),
                                        (void *)(&prb_threshold_ind));
        if( RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
            "Failed to send the prb threshold indication to UE Mgr");
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
        "Prb threshold condition does not meet for uplink mu miumo ");
    }

    RRM_UT_TRACE_EXIT();

}


/****************************************************************************
 * Function Name  : rrm_get_uplink_cell_center_prb_budget
 * Inputs         : cell_index,
 * Outputs        : None
 * Returns        : U32
 * Description    : get the cell edge prb usage value
 ****************************************************************************/
U32
rrm_get_uplink_cell_center_prb_budget( rrm_cell_index_t     cell_index)
{

    const rrm_cell_context_t*  p_rrm_cell_ctx = RRM_PNULL;
    U32                        uplink_cell_center_prb_budget = RRM_ZERO;
    U8                         index = RRM_ZERO;
    U8                         count = RRM_ZERO;
   
    RRM_UT_TRACE_ENTER();
   
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    count = p_rrm_cell_ctx->operator_info.dynamic_icic_info.
            ul_resource_partition_info.num_of_cell_center_region;

    for( index = RRM_ZERO; index < count ; index++ )
    {
        uplink_cell_center_prb_budget += p_rrm_cell_ctx->operator_info.dynamic_icic_info.
                                         ul_resource_partition_info.cell_center_region[index].num_of_rb;
    }
    
    RRM_UT_TRACE_EXIT();

    return uplink_cell_center_prb_budget;
}


/****************************************************************************
 * Function Name  : rrm_get_uplink_cell_edge_prb_budget
 * Inputs         : cell_index,
 * Outputs        : None
 * Returns        : U32
 * Description    : get the cell edge prb usage value
 ****************************************************************************/
U32
rrm_get_uplink_cell_edge_prb_budget( rrm_cell_index_t    cell_index)
{

    const rrm_cell_context_t*  p_rrm_cell_ctx = RRM_PNULL;
    U32                        uplink_cell_edge_prb_budget = RRM_ZERO;
   
    RRM_UT_TRACE_ENTER();
   
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if( p_rrm_cell_ctx->operator_info.dynamic_icic_info.
        ul_resource_partition_info.bitmask & RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT )
    {
    
        uplink_cell_edge_prb_budget = p_rrm_cell_ctx->operator_info.dynamic_icic_info.
                                         ul_resource_partition_info.cell_edge_region.num_of_rb;
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "Cell Edge Resource Partition is not present");
        /* SPR 21251 End */
    }
    
    RRM_UT_TRACE_EXIT();

    return uplink_cell_edge_prb_budget;

}



/****************************************************************************
 * Function Name  : rrm_get_cell_edge_prb_usage
 * Inputs         : cell_index,
 * Outputs        : None
 * Returns        : U32
 * Description    : get the cell edge prb usage value
 ****************************************************************************/
U32 rrm_get_uplink_cell_edge_prb_usage( rrm_cell_index_t    cell_index )
{


    const rrm_cell_context_t   *p_rrm_cell_ctx = RRM_PNULL;
    U32                        cell_edge_prb_usage = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    cell_edge_prb_usage = p_rrm_cell_ctx->icic_l1_l2_report_info.ul_ce_prb_usage;

    RRM_UT_TRACE_EXIT();

    return cell_edge_prb_usage;
}


/****************************************************************************
 * Function Name  : rrm_set_mac_ue_reconfig_mutex
 * Inputs         : cell_index,ue_mac_reconfig_mutex
 * Outputs        : None
 * Returns        : rrm_void_t
 * Description    : Set the mac ue reconfig request mutex
 ****************************************************************************/
rrm_void_t rrm_set_mac_ue_reconfig_mutex( rrm_cell_index_t cell_index,
                                          /*SPR 7892 FIX START*/
                                          rrm_mac_ue_reconfig_mutex_val_et 
                                              ue_mac_reconfig_mutex 
                                          /*SPR 7892 FIX END*/
                                          )
{
    rrm_cell_context_t   *p_cell_ctx = RRM_PNULL;
    
    RRM_UT_TRACE_ENTER();
                        
    p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
 
    if( RRM_NULL != p_cell_ctx )
    { 
    p_cell_ctx->ue_mac_reconfig_mutex = ue_mac_reconfig_mutex;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
        "Cell context is null for cell index [%d] ", cell_index );
    }
        

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : rrm_get_mac_ue_reconfig_mutex
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U8
 * Description    : Returns the ue mac reconfig mutex
 ****************************************************************************/
/*SPR 7892 FIX START*/
rrm_mac_ue_reconfig_mutex_val_et  
rrm_get_mac_ue_reconfig_mutex
(
    rrm_cell_index_t  cell_index
)
/*SPR 7892 FIX END*/
{
    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    /*SPR 7892 FIX START*/
    rrm_mac_ue_reconfig_mutex_val_et  ue_mac_reconfig_mutex = MAC_UE_RECONF_NOT_ONGOING;
    /*SPR 7892 FIX END*/
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    if (RRM_PNULL != p_rrm_cell_ctx)
    {
    ue_mac_reconfig_mutex = p_rrm_cell_ctx->ue_mac_reconfig_mutex;
    }

    RRM_UT_TRACE_EXIT();

    return ue_mac_reconfig_mutex;
}

/****************************************************************************
 * Function Name  : rrm_get_uplink_pathloss_threshold_for_ue
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U32
 * Description    : Returns the uplink pathloss threshold
 ****************************************************************************/
U32 rrm_get_uplink_pathloss_threshold_for_ue( rrm_cell_index_t cell_index )
{

    const rrm_cell_context_t* p_cell_ctxt = RRM_PNULL;
    U32                       uplink_pathloss_threshold = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    uplink_pathloss_threshold = p_cell_ctxt->rrm_olpc_config_params.ul_pathloss_threshold;
 
    RRM_UT_TRACE_EXIT();
   
    return uplink_pathloss_threshold;
}


/****************************************************************************
 * Function Name  : rrm_get_uplink_sinr_threshold
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U8
 * Description    : Returns the uplink sinr threshold
 ****************************************************************************/
U8 rrm_get_uplink_sinr_threshold( rrm_cell_index_t cell_index )
{

    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U8                        uplink_sinr_threshold = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    uplink_sinr_threshold = p_rrm_cell_ctx->uplink_sinr_threshold;

    RRM_UT_TRACE_EXIT();
 
    return uplink_sinr_threshold;

}


/****************************************************************************
 * Function Name  : rrm_get_total_uplink_prb_usage
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U64
 * Description    : Returns the uplink prb usage
 ****************************************************************************/
U64 rrm_get_total_uplink_prb_usage( rrm_cell_index_t    cell_index)
{
    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U64                       total_uplink_prb_usage = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    total_uplink_prb_usage = p_rrm_cell_ctx->rcc_param.total_prb_usage_ul;

    RRM_UT_TRACE_EXIT();
 
    return total_uplink_prb_usage;
}



/****************************************************************************
 * Function Name  : rrm_get_cell_uplink_prb_usage_threshold
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U8
 * Description    : Returns the cell prb usage threshold
 ****************************************************************************/
U8 rrm_get_cell_uplink_prb_usage_threshold_percentage( rrm_cell_index_t cell_index )
{

    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U8                        cell_ul_prb_usage_threshold = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    cell_ul_prb_usage_threshold = p_rrm_cell_ctx->uplink_prb_budget_threshold;

    RRM_UT_TRACE_EXIT();

    return cell_ul_prb_usage_threshold;
}


/****************************************************************************
 * Function Name  : rrm_get_cell_prb_usage_down_threshold
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U8
 * Description    : Returns the cell prb usage down threshold
 ****************************************************************************/
U8 rrm_get_cell_prb_usage_down_threshold_percentage( rrm_cell_index_t cell_index )
{
    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U8                        cell_ul_prb_usage_down_threshold = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

    cell_ul_prb_usage_down_threshold = p_rrm_cell_ctx->uplink_prb_budget_down_threshold;

    RRM_UT_TRACE_EXIT();

    return cell_ul_prb_usage_down_threshold;

}


/* uplink mu mimo change end*/
/*klock_works_changes_start*/
/****************************************************************************
 * Function Name  : packet_delay_budget_higher_range 
 *                : U8 pkt_delay_value
 * Outputs        : None
 * Returns        : packet_delay_budget
 * Description    : Convert corresponding enum value
 ****************************************************************************/
U16 packet_delay_budget_higher_range(U8 pkt_delay_value)
{

    U16 packet_delay_budget = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch(pkt_delay_value)

    {
		case RRM_OAM_PACKET_DELAY_BUDGET_MS600:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS600;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS700:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS700;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS800:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS800;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS900:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS900;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS1000:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS1000;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS1500:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS1500;
			break;
		case RRM_OAM_PACKET_DELAY_BUDGET_MS2000:
			packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS2000;
			break;
		default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Not of any valid packet delay budget");

    }

    RRM_UT_TRACE_EXIT();
    return packet_delay_budget;
}

/****************************************************************************
 * Function Name  : packet_delay_budget_lower_range
 *                : U8 pkt_delay_value
 * Outputs        : None
 * Returns        : packet_delay_budget
 * Description    : Convert corresponding enum value
 ****************************************************************************/

U16 packet_delay_budget_lower_range(U8 pkt_delay_value)
{

    U16 packet_delay_budget = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch(pkt_delay_value)

    {

        case RRM_OAM_PACKET_DELAY_BUDGET_MS50:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS50;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS100:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS100;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS150:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS150;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS200:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS200;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS300:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS300;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS400:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS400;
            break;
        case RRM_OAM_PACKET_DELAY_BUDGET_MS500:
            packet_delay_budget = RRM_PACKET_DELAY_BUDGET_MS500;
            break;

        default:
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Not of any valid packet delay budget");
            /* SPR 21251 End */

    }

    RRM_UT_TRACE_EXIT();
    return packet_delay_budget;
}
/*klock_works_changes_end*/


/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_pkt_delay_bdgt_value
 *   DESCRIPTION:
 *        Convert corresponding enum value
 *   RETURNS:
 *       U16
 ******************************************************************************/
U16 rrm_cellm_pkt_delay_bdgt_value(U8 pkt_delay_value)
{
	U16 packet_delay_budget = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /*klock_works_changes_start*/

    if (pkt_delay_value <= RRM_OAM_PACKET_DELAY_BUDGET_MS500)
    {
        packet_delay_budget=packet_delay_budget_lower_range(pkt_delay_value);
    }
    else
    {
        packet_delay_budget=packet_delay_budget_higher_range(pkt_delay_value);
    }

    /*klock_works_changes_end*/

    RRM_UT_TRACE_EXIT();
    return packet_delay_budget;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_pkt_err_loss_rate_value
 *   DESCRIPTION:
 *        Convert corresponding enum value
 *   RETURNS:
 *       U32
 ******************************************************************************/
	U32
rrm_cellm_pkt_err_loss_rate_value(U8 pkt_err_loss_rate)
{
	U32 packet_error_loss_rate = RRM_ZERO;

	RRM_UT_TRACE_EXIT();
	switch(pkt_err_loss_rate)
	{
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_0:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_0;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_1:
			packet_error_loss_rate = RRM_PACKET_ERR_LOSS_RATE_10_POWER_1;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_2:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_2;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_3:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_3;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_4:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_4;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_5:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_5;
			break;
		case RRM_OAM_PACKET_ERR_LOSS_RATE_10_POWER_6:
			packet_error_loss_rate= RRM_PACKET_ERR_LOSS_RATE_10_POWER_6;
			break;
		default:
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Not of any valid packet error loss rate");
            /* SPR 21251 End */
	}
	RRM_UT_TRACE_EXIT();
	return packet_error_loss_rate;
}


/****************************************************************************
 * Function Name  : rrm_get_packet_delay_budget
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : rrm_oam_packet_delay_budget_et
 * Description    : Returns the packet delay budget
 ****************************************************************************/
	U16
rrm_get_packet_delay_budget(rrm_cell_index_t    cell_index,
		U8			qci_index)
{

    const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    U16			      packet_delay = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /* Coverity_fix_start_55014 */
    /*klok_fix_start_7279*/
    if ((RRM_ZERO >= qci_index) && (qci_index < RRM_MAX_QCI))
    {
    /*klok_fix_end_7279*/     
        packet_delay = p_rrm_cell_ctx->epc_info.epc_params. \
                       qos_config_params[qci_index].packet_delay_budget;
    }
    /* Coverity_fix_end_55014 */
    packet_delay = rrm_cellm_pkt_delay_bdgt_value( packet_delay );

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Packet Delay [%d] for QCI [%d]",packet_delay,qci_index);

    RRM_UT_TRACE_EXIT();

    return packet_delay;

}



/****************************************************************************
 * Function Name  : rrm_get_packet_error_loss_rate
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : U32
 * Description    : Returns the packet error loss rate
 ****************************************************************************/
	U32
rrm_get_packet_error_loss_rate(rrm_cell_index_t    cell_index,
		U8		   qci_index)
{
	const rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	U32                       packet_error_loss_rate = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	packet_error_loss_rate = p_rrm_cell_ctx->epc_info.epc_params. \
				 qos_config_params[qci_index-1].packet_error_loss_rate;

	packet_error_loss_rate = rrm_cellm_pkt_err_loss_rate_value(packet_error_loss_rate);   

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"Packet error loss [%d] for QCI [%d]",packet_error_loss_rate,qci_index); 

	RRM_UT_TRACE_EXIT();

	return packet_error_loss_rate;

}

/*LTE_RRM_TM_SWITCH_END*/
/*GBR LIMIT END */

rrm_bool_et rrm_cellm_get_srs_status(rrm_cell_index_t cell_index)
{
	rrm_bool_et status = RRM_FALSE;
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;

	RRM_UT_TRACE_ENTER();
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	status = p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_srs.srsEnabled;

	RRM_UT_TRACE_EXIT();
	return status;
}


/* Soft Lock changes start */
rrm_block_cell_params_ho_t * rrm_cellm_get_block_cell_ho_params(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
	RRM_UT_TRACE_EXIT();

	return (&(p_rrm_cell_ctx->block_cell_params_ho));
}
/* Soft Lock changes end */

/****************************************************************************
 * Function Name  : rrm_populate_enb_context  
 * Inputs         : rrm_enb_context_t  *p_enb_context : pointer to enodeb 
 global context
 *                : void *p_api  : pointer to api buffer
 * Outputs        : None
 * Returns        : None
 * Description    : populate the enodeb context
 ****************************************************************************/

void rrm_populate_enb_context
(
 rrm_enb_context_t  *p_enb_context,
 void               *p_api
 ) 
{
	RRM_UT_TRACE_ENTER();

	rrmcm_rmif_cell_config_req_t *p_cell_config_req = RRM_PNULL;
	p_cell_config_req = (rrmcm_rmif_cell_config_req_t *)p_api;
    /* Carrier_Aggregation_Start */
    /* If enb id is present in global context then no need to update enb id recieved
        in cell config request */
    if (!(RRM_GLOBAL_ENB_ID_PRESENT & p_enb_context->bitmask))
    {
    /* Carrier_Aggregation_End */
	// Populating eNB ID
	p_enb_context->enb_id.eNb_id[RRM_ZERO] = p_cell_config_req->global_cell_id.cell_identity[RRM_ZERO];
	p_enb_context->enb_id.eNb_id[RRM_ONE] = p_cell_config_req->global_cell_id.cell_identity[RRM_ONE];

	if(p_cell_config_req->access_mgmt_params.csg_id[RRM_ZERO] != RRM_ZERO ||
			p_cell_config_req->access_mgmt_params.csg_id[RRM_ONE] != RRM_ZERO ||
			p_cell_config_req->access_mgmt_params.csg_id[RRM_TWO] != RRM_ZERO ||
			p_cell_config_req->access_mgmt_params.csg_id[RRM_THREE] != RRM_ZERO)
	{
		p_enb_context->enb_id.enb_type = RRM_ENB_TYPE_HOME;
		p_enb_context->enb_id.eNb_id[RRM_TWO] = p_cell_config_req->global_cell_id.cell_identity[RRM_TWO];
		p_enb_context->enb_id.eNb_id[RRM_THREE] = p_cell_config_req->global_cell_id.cell_identity[RRM_THREE];
		p_enb_context->enb_id.eNb_id[RRM_THREE] &= RRM_HIGH_NIBBLE;
	}
	else
	{
		p_enb_context->enb_id.enb_type = RRM_ENB_TYPE_MACRO;
		p_enb_context->enb_id.eNb_id[RRM_TWO] = p_cell_config_req->global_cell_id.cell_identity[RRM_TWO];
		p_enb_context->enb_id.eNb_id[RRM_TWO] &= RRM_HIGH_NIBBLE;
	}

	RRM_MEMCPY(&p_enb_context->enb_id.plmn_id,
			&p_cell_config_req->global_cell_id.primary_plmn_id,
			sizeof(p_enb_context->enb_id.plmn_id));
    /* Carrier_Aggregation_Start */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "enb is already present so enb id recieved in cell config req is not updating in global context"
                "Stored enb_id is 0x%x%x%x%x, enb_type is %d",p_enb_context->enb_id.eNb_id[0],
                p_enb_context->enb_id.eNb_id[1],p_enb_context->enb_id.eNb_id[2],
                p_enb_context->enb_id.eNb_id[3],p_enb_context->enb_id.enb_type);
    }
    /* Carrier_Aggregation_End */

    /* SPR_17367_Start */
    /* Code deleted */
    /* SPR_17367_End */

	RRM_MEMCPY(p_enb_context->enb_tai.tac,
			p_cell_config_req->epc_info.epc_params.general_epc_params.tac,
			sizeof(p_enb_context->enb_tai.tac));

	RRM_MEMCPY(&p_enb_context->enb_tai.plmn_id,
			&p_cell_config_req->global_cell_id.primary_plmn_id,
			sizeof(p_enb_context->enb_id.plmn_id));

	/* IP Address is not populated yet as it is currently not provisioned in any of RRM APIs */

	RRM_UT_TRACE_EXIT();
}    

/****************************************************************************
 * Function Name  : rrm_fill_plmn_identity_from_config_transfer
 * Inputs         : rrm_oam_cell_plmn_info_t *p_rrm_plmn_id
 *                : plmn_identity_t *p_mme_plmn_id
 * Outputs        : None
 * Returns        : None
 * Description    : This function convert the mme_plmn_id_t to rrm_plmn_id_t
 ****************************************************************************/

void rrm_fill_plmn_identity_from_config_transfer
(
 rrm_oam_cell_plmn_info_t *p_rrm_plmn_id,
 plmn_identity_t *p_mme_plmn_id
 ) 
{
	RRM_UT_TRACE_ENTER();

	if (p_mme_plmn_id->presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
	{
		RRM_MEMCPY(p_rrm_plmn_id->mcc, p_mme_plmn_id->mcc, sizeof(p_rrm_plmn_id->mcc));
	}
	p_rrm_plmn_id->num_mnc_digit = p_mme_plmn_id->mnc.count;
	RRM_MEMCPY(p_rrm_plmn_id->mnc, (p_mme_plmn_id->mnc).mnc, sizeof(p_rrm_plmn_id->mnc));    

	RRM_UT_TRACE_EXIT();
}  
/* RRM_MAC_RECONF_SCHEDULER_CHANGES_START */

/************************************************************************
 * Function Name  : rrm_cellm_l2_reconfig_scheduler_process_msg 
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell_reconfig_scheduler_req to cell rrm
 **************************************************************************/

rrm_return_et
rrm_cellm_l2_reconfig_scheduler_process_msg(

		void *p_api/*pointer to api buffer*/
            /*SPR 17777 +-*/
		)
{                
	rrm_cell_index_t cell_index = RRM_ZERO;
	rrm_return_et ret_val = RRM_SUCCESS;
	rrmcm_rmif_reconf_scheduler_parameters_t *p_rrmcm_rmif_cell_reconf_schedule_req = RRM_PNULL;
	RrmMacReconfigSchedulerReq            *p_rrm_l2_reconf_scheduler_req = RRM_PNULL;

	RRM_UT_TRACE_ENTER();

	p_rrmcm_rmif_cell_reconf_schedule_req =
		(rrmcm_rmif_reconf_scheduler_parameters_t *)p_api;

	cell_index = p_rrmcm_rmif_cell_reconf_schedule_req->cellindex;
	RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"RRM->RRMCM_RMIF_MAC_RECONF_SCHEDULE_IND->CellM:[CELL:%d]",
			cell_index);

	if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
	{ 
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"Cell context is not found For Cell Index :%d",
			    cell_index);
        /* SPR 21251 End */
		return RRM_FAILURE;
	}

	p_rrm_l2_reconf_scheduler_req = rrm_mem_get(sizeof(RrmMacReconfigSchedulerReq));
	if(p_rrm_l2_reconf_scheduler_req == RRM_PNULL)
	{
		RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name,RRM_ERROR,
				"Failed to Alloc memory for p_rrm_l2_reconf_scheduler_req");
    /*+ Coverity CID : 21184 +*/
    return RRM_FAILURE;
    /*- Coverity CID : 21184 -*/
    }

	RRM_MEMCPY(p_rrm_l2_reconf_scheduler_req,
			((U8 *)p_rrmcm_rmif_cell_reconf_schedule_req + 
			 sizeof(U32)),
			sizeof(RrmMacReconfigSchedulerReq));
	l2_reconfig_scheduler_process_msg(p_rrm_l2_reconf_scheduler_req,
	                            		RRM_MODULE_ID, 
                                        p_rrmcm_rmif_cell_reconf_schedule_req->transaction_id,
                                        cell_index);
	RRM_MEM_FREE(p_rrm_l2_reconf_scheduler_req);
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/* RRM_MAC_RECONF_SCHEDULER_CHANGES_ENDS */

/* SPR 10749 Fix Start */
/**************************************************************************
 * Function Name  : rrm_cellm_get_valid_n2_pucch_index 
 * Inputs         : cell_index 
 * Outputs        : n2_pucch_res_index_tbl, valid_n2_pucch_index
 * Returns        : 
 * Description    : This functions determines the n2_pucch_res_inexes from the n_rb_cqi
 ****************************************************************************/
rrm_void_t
rrm_cellm_get_valid_n2_pucch_index
(
 rrm_cell_context_t           *p_cell_context,
 U16                          *p_n2_pucch_res_ind_tbl,
 U16                          *p_no_of_valid_n2_pucch_ind
 )
{
    U16              n_rb_cqi                             = RRM_ZERO;
    U16              total_n2_pucch_index                 = RRM_ZERO;
    U16              valid_n2_pucch_ind                   = RRM_ZERO;   
    U16              rb_index                             = RRM_ZERO;
    U16              index                                = RRM_ZERO;
    U16              start_n2_pucch_index_curr_rb         = RRM_ZERO;
    U16              n2_pucch_used_in_one_rb              = RRM_FOUR;
    U16              multiplier                           = RRM_ZERO;
    U16              calculated_n2_pucch_res_index        = RRM_ZERO;


    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_cell_context  &&
            RRM_PNULL != p_n2_pucch_res_ind_tbl &&
            RRM_PNULL != p_no_of_valid_n2_pucch_ind)
    {
        n_rb_cqi = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi;
        if(RRM_ZERO == n_rb_cqi)
        {
            n_rb_cqi = RRM_TWO;
        }
        n2_pucch_used_in_one_rb = RRM_MAX_NUM_OF_UE_IN_SINGLE_RB_FOR_FORMAT2_2A_2B;
        /* Coverity 63919 fix start */
        /* Coverity 63919 fix end */
        total_n2_pucch_index =  (n2_pucch_used_in_one_rb * n_rb_cqi);

        for(index=RRM_ZERO;(index < n2_pucch_used_in_one_rb) && (valid_n2_pucch_ind <=total_n2_pucch_index);index++)
        {
            for (rb_index=RRM_ONE;(rb_index <= n_rb_cqi)&& (valid_n2_pucch_ind <=total_n2_pucch_index) ;rb_index++)
            {
                start_n2_pucch_index_curr_rb = (rb_index-RRM_ONE) * N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB;

                if(n2_pucch_used_in_one_rb == N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB)
                {
                    multiplier = RRM_CEIL((float) (N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB/(float)(n2_pucch_used_in_one_rb-1)));
                }
                /*CID 63919:delete*/
                /* n2_pucch_indexes in one rb (0,1..11) */
                calculated_n2_pucch_res_index = start_n2_pucch_index_curr_rb + (multiplier * index);
                if(calculated_n2_pucch_res_index >= (N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB*rb_index))
                {
                    calculated_n2_pucch_res_index = calculated_n2_pucch_res_index - (N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB-RRM_ONE);
                    /* if pucch_index crossed maximum pucch_index in one RB then set calculated_n2_pucch_res_index
                       to next available pucch_index ex. if calculated_n2_pucch_res_index=12 then 
                       make the calculated_n2_pucch_res_index =1.
                     */
                }
                p_n2_pucch_res_ind_tbl[valid_n2_pucch_ind++] = calculated_n2_pucch_res_index;
            }
        }
        *p_no_of_valid_n2_pucch_ind = valid_n2_pucch_ind;
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "p_cell_context, p_n2_pucch_res_ind_tbl or p_no_of_valid_n2_pucch_ind is NULL ");
        /* SPR 21251 End */
    }

    RRM_UT_TRACE_EXIT();
}
/* SPR 10749 Fix End */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_initialize_cqi_res_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Initializes the CQI-RI resource list
 ****************************************************************************/
/* Bug 10856 Fix Start */
rrm_return_et
rrm_cellm_cell_initialize_cqi_res_list
(
 rrm_cell_context_t       *p_cell_context,
 cqi_ri_map_info_per_ue   *p_cqi_ri_table_map,
 U16                      *p_alloc_cqi_ri_from_algo_val
                            /*SPR 17777 +-*/
 )
{

    U16                     cqi_ri_index_count = RRM_ZERO;
    U16                     cqi_periodicity = RRM_ZERO;
    /* SPR 10749 Fix Start */
    U16                     n2_pucch_res_index_count = RRM_ZERO;
    U16                     n2_pucch_res_index_max_value = RRM_ZERO;
    /* SPR 10749 Fix End */
    rrm_return_et           ret_val = RRM_FAILURE;
    rrm_cqi_ri_res_list_t   *cqi_node = RRM_PNULL;
    /* SPR 10749 Fix Start */
    /* Code deleted */
    /* SPR 10749 Fix Start */


    /* SPR 15454 Fix Start */
    /* Code deleted */
    /* SPR 15454 Fix End */
 
    
    U16                     n2_pucch_res_index_tbl[MAX_N2_PUCCH_AN]     = {RRM_ZERO};
    /* SPR 10749 Fix End */
    /* CID:63249 Fix Start */
    U16                     index = RRM_ZERO;
    /* CID:63249 Fix End */
    find_cqi_periodicity_from_cell_context(p_cell_context, &cqi_periodicity);

	  ret_val = prepare_cqi_ri_resource_list(p_cell_context, p_cqi_ri_table_map, 
			cqi_periodicity, p_alloc_cqi_ri_from_algo_val);
    if (ret_val == RRM_FAILURE)
        {
       RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
               "Alarming Situation if this block hits....");
       return RRM_FAILURE;
    }
   
    /* SPR 10749 Fix Start */
    rrm_cellm_get_valid_n2_pucch_index(p_cell_context,
            &n2_pucch_res_index_tbl[RRM_ZERO],
            &n2_pucch_res_index_max_value);
    /* SPR 10749 Fix End */
/* SPR 22248 MBMS Changes Start */
#ifdef LTE_EMBMS_SUPPORTED
      p_cell_context->allocated_n2_pucch_res_idx_val = 
                    n2_pucch_res_index_max_value;
#endif
/* SPR 22248 MBMS Changes Stop */
/*SPR 15454 +-*/ 

    /*MEMORY_PROFILING*/
    /* Allocate memory for CQI_RI_RES allocation */
    p_cell_context->cqi_ri_res = RRM_PNULL;
    p_cell_context->cqi_ri_res = rrm_mem_get(n2_pucch_res_index_max_value * sizeof(rrm_cqi_ri_res_list_t*));
    if ( p_cell_context->cqi_ri_res == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_context->cqi_ri_res failed" );
        /* SPR 21251 End */
/*SPR 15454 +-*/ 
        RRM_UT_TRACE_EXIT();
        /* CID 63249 Fix End */
        /*Cov_fix_57920*/
        return RRM_FAILURE;
    } 
    for( n2_pucch_res_index_count = RRM_ZERO; 
              n2_pucch_res_index_count < n2_pucch_res_index_max_value ; n2_pucch_res_index_count++)
    {
        p_cell_context->cqi_ri_res[n2_pucch_res_index_count] = rrm_mem_get((*p_alloc_cqi_ri_from_algo_val)* sizeof(rrm_cqi_ri_res_list_t));
        if ( p_cell_context->cqi_ri_res[n2_pucch_res_index_count] == RRM_PNULL)
        {
                /* SPR 21251 Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_cell_context->cqi_ri_res[n2_pucch_res_index_count] failed" );
                /* SPR 21251 End */
                /* COVERITY : RESOURCE LEAK : CID : 63249 fix start */
                for( index = RRM_ZERO ; index < n2_pucch_res_index_count ; index++)
                {
                    if( RRM_NULL != p_cell_context->cqi_ri_res[index])
                        RRM_MEM_FREE( p_cell_context->cqi_ri_res[index]);
                }
                /* COVERITY : RESOURCE LEAK : CID : 63249 fix end */
            RRM_MEM_FREE(p_cell_context->cqi_ri_res);
            /* CID 63249 Fix Start */
            /* CID 63249 Fix End */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
    }
    /*MEMORY_PROFILING*/
/*SPR 15454 +-*/ 
    for(n2_pucch_res_index_count = RRM_ZERO; n2_pucch_res_index_count < n2_pucch_res_index_max_value; 
                 n2_pucch_res_index_count++)
    {
       for(cqi_ri_index_count = RRM_ZERO; cqi_ri_index_count < *p_alloc_cqi_ri_from_algo_val; 
                       cqi_ri_index_count++)
       {
/*SPR 15454 Start*/
          cqi_node = &(p_cell_context->cqi_ri_res[n2_pucch_res_index_count][cqi_ri_index_count]);
            cqi_node->cqi_config_index = p_cqi_ri_table_map[cqi_ri_index_count].cqi_index;
            cqi_node->ri_config_index = p_cqi_ri_table_map[cqi_ri_index_count].ri_index;
            cqi_node->cqi_pucch_res_index = n2_pucch_res_index_count;
            cqi_node->row_num = n2_pucch_res_index_count;
            cqi_node->col_num = cqi_ri_index_count;
            cqi_node->cqi_ri_marked_status = RRM_RES_FREE;
          RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                   "Final Array[%d][%d]-->CQI-PUCCH-Res-Idx[%d], CQI[%d] RI[%d], Status[%d]", n2_pucch_res_index_count,
                          cqi_ri_index_count, cqi_node->cqi_pucch_res_index,
                          cqi_node->cqi_config_index, cqi_node->ri_config_index,
                          cqi_node->cqi_ri_marked_status);
/*SPR 15454 END */
       }
    }


    p_cell_context->allocated_cqi_perodicity_max_val = *p_alloc_cqi_ri_from_algo_val;
   
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/* Bug 10856 Fix End */

/* TDD_SRS_FREQ_HOPPING_START */
/****************************************************************************
 * Function Name  : rrm_cellm_get_subband_srs_resources
 * Inputs         : cell_index, srs_periodicity 
 * Outputs        : sr_res_index, sr_config_index
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the availability of SRS resource for UE admission. If
 *                  found, then set the SRS resource index and SRS config index
 *                  in the out params and return RRM_SUCCESS.
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_subband_srs_resources
(
 rrm_cell_index_t     cell_index,
 rrm_ue_srs_params_t  *p_rrm_ue_srs_params

 )
{
	rrm_cell_context_t* p_cell_context = RRM_PNULL;
	rrm_return_et ret_val = RRM_FAILURE;
	U16            res_anchor_index = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	p_cell_context = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	//    print_srs_resource_info(p_cell_context);

	for(res_anchor_index = RRM_ZERO; 
			res_anchor_index <= 
			(p_cell_context->allocated_srs_max_anchor_val - p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
			res_anchor_index++)
	{
    /*SPR 21223 START*/
		if (p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_marked_status == RRM_RES_FREE)
		{
			p_rrm_ue_srs_params->srs_anchor = p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].anchor;
            /* SPR_8391_CHANGES_START*/
			p_rrm_ue_srs_params->srs_bandwidth =  p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_bw;
			p_rrm_ue_srs_params->srs_hopping_bandwidth = p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_hopping_bw;
            /* SPR_8391_CHANGES_END*/
			p_rrm_ue_srs_params->frequency_domain_position =  p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].n_rrc;
			/* SPR 8189 FIX START */
            p_rrm_ue_srs_params->duration =  p_cell_context->ran_info.physical_layer_params.physical_layer_param_srs.srs_duration;
			/* SPR 8189 FIX END */
			p_rrm_ue_srs_params->srs_configuration_index =  p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_index;
			p_rrm_ue_srs_params->transmission_comb =  p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].comb;
			p_rrm_ue_srs_params->cyclic_shift = p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].c_shift;
            /* SPR_8315_PART2_FIX_START */
			p_rrm_ue_srs_params->srs_res_type = RRM_UE_SRS_TYPE_SUBBAND; 
            /* SPR_8315_PART2_FIX_END */
			p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_marked_status = RRM_RES_BUSY;
			ret_val = RRM_SUCCESS;
            /* SPR_8315_PART2_FIX_START */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
					"SUBBAND SRS_CONFIG assigned:- SRS_ANCHOR[%d],SRS_BW[%d], SRS_HBW[%d], FREQ_DOM_POS[%d],"
					"DURATION[%d], SRS_CONFIG_INDX[%d] , COMB [%d] , CyClic Shift[%d], SRS_Res_Type[%d]",
					p_rrm_ue_srs_params->srs_anchor,p_rrm_ue_srs_params->srs_bandwidth,p_rrm_ue_srs_params->srs_hopping_bandwidth,
					p_rrm_ue_srs_params->frequency_domain_position,p_rrm_ue_srs_params->duration,p_rrm_ue_srs_params->srs_configuration_index,
					p_rrm_ue_srs_params->transmission_comb,p_rrm_ue_srs_params->cyclic_shift,
                                        p_rrm_ue_srs_params->srs_res_type);
            /* SPR_8315_PART2_FIX_END */
			break;
		}
		else if (p_cell_context->srs_table.p_subband_srs_table[res_anchor_index].srs_marked_status == RRM_RES_BUSY)
		{
    /*SPR 21223 END*/
			ret_val = RRM_FAILURE;
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;    
}

rrm_return_et 
rrm_cellm_get_wideband_srs_resources
(
 rrm_cell_index_t     cell_index,
 rrm_ue_srs_params_t  *p_rrm_ue_srs_params
 )
{
	rrm_cell_context_t* p_cell_context = RRM_PNULL;
	rrm_return_et ret_val = RRM_FAILURE;
	U16            res_anchor_index = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	p_cell_context = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	//	print_srs_resource_info(p_cell_context);
		/* SPR 8019 FIX START */
	for(res_anchor_index = RRM_ZERO;
			res_anchor_index < (p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs -RRM_ONE ); 
			res_anchor_index++)
		/* SPR 8019 FIX END */
	{
/*SPR 21223 START*/ 	
		if (p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_marked_status == RRM_RES_FREE)
		{
			p_rrm_ue_srs_params->srs_anchor = p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].anchor;
            /* SPR_8391_CHANGES_START*/
			p_rrm_ue_srs_params->srs_bandwidth =  p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_bw;
			p_rrm_ue_srs_params->srs_hopping_bandwidth =
            p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_hopping_bw;
            /* SPR_8391_CHANGES_END*/
			p_rrm_ue_srs_params->frequency_domain_position =  RRM_ZERO;
			/* SPR 8189 FIX START */
            p_rrm_ue_srs_params->duration =  p_cell_context->ran_info.physical_layer_params.physical_layer_param_srs.srs_duration;
			/* SPR 8189 FIX END*/
			p_rrm_ue_srs_params->srs_configuration_index =  p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_index;
			p_rrm_ue_srs_params->transmission_comb =  p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].comb;
			p_rrm_ue_srs_params->cyclic_shift = p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].c_shift;
            /* SPR_8315_PART2_FIX_START */
			p_rrm_ue_srs_params->srs_res_type = RRM_UE_SRS_TYPE_WIDEBAND; 
            /* SPR_8315_PART2_FIX_END */
			p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_marked_status = RRM_RES_BUSY;
			ret_val = RRM_SUCCESS;
            /* SPR_8315_PART2_FIX_START */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_INFO,
			   "WIDEBAND SRS_CONFIG assigned:- SRS_ANCHOR[%d],SRS_BW[%d], SRS_HBW[%d], FREQ_DOM_POS[%d],"
			   "DURATION[%d], SRS_CONFIG_INDX[%d] , COMB [%d] , CyClic Shift[%d], SRS_Res_Type[%d]",
			   p_rrm_ue_srs_params->srs_anchor,p_rrm_ue_srs_params->srs_bandwidth,p_rrm_ue_srs_params->srs_hopping_bandwidth,
			   p_rrm_ue_srs_params->frequency_domain_position,p_rrm_ue_srs_params->duration,p_rrm_ue_srs_params->srs_configuration_index,
			   p_rrm_ue_srs_params->transmission_comb,p_rrm_ue_srs_params->cyclic_shift,
                           p_rrm_ue_srs_params->srs_res_type);
            /* SPR_8315_PART2_FIX_END */
			break;
		}
		else if (p_cell_context->srs_table.p_wideband_srs_table[res_anchor_index].srs_marked_status == RRM_RES_BUSY)
		{
/*SPR 21223 END*/ 
            /* SPR 21251 Start */
	        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			        "Resources are busy");
            /* SPR 21251 End */
			ret_val = RRM_FAILURE;
			continue;
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;    
}
/****************************************************************************
 * Function Name  : rrm_cellm_mark_srs_index_free
 * Inputs         : cell_index, srs_anchor
 * Outputs        : none
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the BUSY index and marked the the index for
 *                  released UE.
 ****************************************************************************/
rrm_return_et
rrm_cellm_mark_srs_index_free
(
 rrm_cell_index_t cell_index,
 U16   srs_anchor
 )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;
	U16                 srs_search_index = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	if(srs_anchor < p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs )
	{
		/* SPR 8019 FIX START */
        for (srs_search_index = RRM_ZERO; 
				srs_search_index < (p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs -RRM_ONE );
				srs_search_index++)
		/* SPR 8019 FIX END */
		{
    /*SPR 21223 START*/
			if ((p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].anchor == srs_anchor)) 
			{
				p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].srs_marked_status = RRM_RES_FREE;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_INFO,
						"WIDEBAND SRS_CONFIG FREED:- SRS_ANCHOR[%d],SRS_CONFIG_INDX[%d] , COMB [%d] , CyClic Shift[%d]",
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].anchor,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].srs_index,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].comb,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].c_shift);
    /*SPR 21223 END*/
				ret_val = RRM_SUCCESS;
				break;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
		}
	}

	else
	{
		for (srs_search_index = RRM_ZERO;
				srs_search_index <= (p_rrm_cell_ctx->allocated_srs_max_anchor_val -  p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
				srs_search_index++)
		{
    /*SPR 21223 START*/
			if ((p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].anchor == srs_anchor)) 
			{
				p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].srs_marked_status = RRM_RES_FREE;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_INFO,
						"SUBBAND SRS_CONFIG FREED:- SRS_ANCHOR[%d],SRS_CONFIG_INDX[%d] ,N_RRC [%d], COMB [%d] , CyClic Shift[%d]",
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].anchor,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].srs_index,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].n_rrc,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].comb,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].c_shift);
    /*SPR 21223 END*/
				ret_val = RRM_SUCCESS;
				break;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
		}
	}
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_mark_srs_index_busy
 * Inputs         : cell_index, srs_anchor
 * Outputs        : none
 * Returns        : RRM_SUCCESS or RRM_FAILURE
 * Description    : Checks the BUSY index and marked the the index for
 *                  released UE.
 ****************************************************************************/
rrm_return_et
rrm_cellm_mark_srs_index_busy
(
 rrm_cell_index_t cell_index,
 U16   srs_anchor
 )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	rrm_cell_context_t *p_rrm_cell_ctx = RRM_PNULL;
	U16                 srs_search_index = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
	p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];

	if(srs_anchor < p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs )
	{
		/* SPR 8019 FIX START */
		for (srs_search_index = RRM_ZERO; 
				srs_search_index < (p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs - RRM_ONE);
				srs_search_index++)
		/* SPR 8019 FIX END */
		{
    /*SPR 21223 START*/
			if ((p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].anchor == srs_anchor)) 
			{
				p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].srs_marked_status = RRM_RES_BUSY;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_INFO,
						"WIDEBAND SRS_CONFIG marked BUSY:- SRS_ANCHOR[%d],SRS_CONFIG_INDX[%d] , COMB [%d] , CyClic Shift[%d]",
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].anchor,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].srs_index,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].comb,
						p_rrm_cell_ctx->srs_table.p_wideband_srs_table[srs_search_index].c_shift);
    /*SPR 21223 END*/
				ret_val = RRM_SUCCESS;
				break;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
		}
	}

	else
	{
		for (srs_search_index = RRM_ZERO;
				srs_search_index <= (p_rrm_cell_ctx->allocated_srs_max_anchor_val-p_rrm_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
				srs_search_index++)
		{
    /*SPR 21223 START*/
			if ((p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].anchor == srs_anchor)) 
			{
				p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].srs_marked_status = RRM_RES_BUSY;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_INFO,
						"SUBBAND SRS_CONFIG marked BUSY:- SRS_ANCHOR[%d],SRS_CONFIG_INDX[%d] ,N_RRC [%d], COMB [%d] , CyClic Shift[%d]",
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].anchor,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].srs_index,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].n_rrc,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].comb,
						p_rrm_cell_ctx->srs_table.p_subband_srs_table[srs_search_index].c_shift);
    /*SPR 21223 END*/
				ret_val = RRM_SUCCESS;
				break;
			}
			else
			{
				ret_val = RRM_FAILURE;
			}
		}
	}
	return ret_val;
}

rrm_void_t
get_the_n_rrc_index_max_limit
(
 rrm_oam_band_width_et channel_bandwidth,
 U8 subframe_bw_config,
 U8 srs_bandwidth,
 U8 srs_hopping_bw,
/* SPR_8391_CHANGES_START*/
 U8 *p_n_rrc_max_count,
 U8 *p_rb_count_hopping_bw
/* SPR_8391_CHANGES_END*/
 )
{
	RRM_UT_TRACE_ENTER();
	U8 rb_in_srs_bw = RRM_ZERO;
	U8 rb_in_srs_hopping_bw = RRM_ZERO;

	switch(channel_bandwidth)
	{
		case RRM_OAM_BW_N_6:
		case RRM_OAM_BW_N_15:
		case RRM_OAM_BW_N_25:
			{
				rb_in_srs_bw = srs_rb_allocation_tbl_bw_upto_5[subframe_bw_config][srs_bandwidth][RRM_ZERO]; 
				rb_in_srs_hopping_bw = srs_rb_allocation_tbl_bw_upto_5[subframe_bw_config][srs_hopping_bw][RRM_ZERO];

				*p_n_rrc_max_count = rb_in_srs_hopping_bw/rb_in_srs_bw ;

			}
			break; 
		case RRM_OAM_BW_N_50:
			{
				rb_in_srs_bw = srs_rb_allocation_tbl_bw_10[subframe_bw_config][srs_bandwidth][RRM_ZERO]; 
				rb_in_srs_hopping_bw = srs_rb_allocation_tbl_bw_10[subframe_bw_config][srs_hopping_bw][RRM_ZERO];

				*p_n_rrc_max_count = rb_in_srs_hopping_bw/rb_in_srs_bw ;

			}
			break; 

		case RRM_OAM_BW_N_75:
			{
				rb_in_srs_bw = srs_rb_allocation_tbl_bw_15[subframe_bw_config][srs_bandwidth][RRM_ZERO]; 
				rb_in_srs_hopping_bw = srs_rb_allocation_tbl_bw_15[subframe_bw_config][srs_hopping_bw][RRM_ZERO];

				*p_n_rrc_max_count = rb_in_srs_hopping_bw/rb_in_srs_bw ;

			}
			break; 

		case RRM_OAM_BW_N_100:
			{
				rb_in_srs_bw = srs_rb_allocation_tbl_bw_20[subframe_bw_config][srs_bandwidth][RRM_ZERO]; 
				rb_in_srs_hopping_bw = srs_rb_allocation_tbl_bw_20[subframe_bw_config][srs_hopping_bw][RRM_ZERO];

				*p_n_rrc_max_count = rb_in_srs_hopping_bw/rb_in_srs_bw ;

			}
			break;

		default:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"INVALID CHANNEL BW recieved!!!");

	}

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			" Channel BW [%d] , RB_IN_SRS_BW[%d] , RB_IN_SRS_HOPPING_BW[%d] , MAX_N_RRC_IDX[%d]",
			channel_bandwidth,rb_in_srs_bw,rb_in_srs_hopping_bw,*p_n_rrc_max_count);
/* SPR_8391_CHANGES_START*/
        *p_rb_count_hopping_bw = rb_in_srs_hopping_bw;
/* SPR_8391_CHANGES_END*/
	RRM_UT_TRACE_EXIT();
}
/* SPR_8391_CHANGES_START*/
rrm_void_t
get_sub_band_data_sets_for_icic
(
 rrm_oam_band_width_et      channel_bandwidth,
 rrm_bool_et                hopping_enable,
 U8                         subframe_bw_config,
 rrm_dynamic_icic_info_t    *p_dynamic_icic_info,
 U8                         *p_wb_srs_bw_for_ce,
 U8                         *p_wb_hopping_bw_for_ce,
 U8                         *p_n_rrc_min_index
 )
{
    U8                 srs_bw_array_for_c_srs[SRS_BW3 + RRM_ONE] = {RRM_ZERO};
    U8                 srs_bw_count = RRM_ZERO;
    U32                ce_start_rb = RRM_ZERO;  
    U32                ce_num_of_rb = RRM_ZERO;  

	RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_dynamic_icic_info);
    RRM_ASSERT(RRM_PNULL != p_wb_srs_bw_for_ce);
    RRM_ASSERT(RRM_PNULL != p_wb_hopping_bw_for_ce);
    RRM_ASSERT(RRM_PNULL != p_n_rrc_min_index);

    /*SPR 21223 START*/
     /* SPR_8315_PART2_FIX_START */
    *p_wb_hopping_bw_for_ce = SRS_BW0;
    *p_n_rrc_min_index      = RRM_ZERO;
    if (RRM_TRUE == hopping_enable)
    {
	    *p_wb_srs_bw_for_ce     = SRS_BW1;
    }
    else
    {
	    *p_wb_srs_bw_for_ce     = SRS_BW0;
    }
    /* SPR_8315_PART2_FIX_END */
    /*SPR 21223 END*/

    if ((p_dynamic_icic_info->bitmask & RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT) &&
        (p_dynamic_icic_info->ul_resource_partition_info.num_of_cell_edge_region != RRM_ZERO))
    {
        ce_start_rb = p_dynamic_icic_info->ul_resource_partition_info.cell_edge_region.start_rb;
        ce_num_of_rb = p_dynamic_icic_info->ul_resource_partition_info.cell_edge_region.num_of_rb;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "CE Partition Present; Start RB [%d], Num of RBs [%d]",
                ce_start_rb, ce_num_of_rb);

        switch(channel_bandwidth)
        {
            case RRM_OAM_BW_N_6:
            case RRM_OAM_BW_N_15:
            case RRM_OAM_BW_N_25:
                {
                    for(srs_bw_count = RRM_ZERO; srs_bw_count <= SRS_BW3; srs_bw_count++)
                    {
                        srs_bw_array_for_c_srs[srs_bw_count] =
                            srs_rb_allocation_tbl_bw_upto_5[subframe_bw_config][srs_bw_count][RRM_ZERO];
                    }
                }
                break; 
            case RRM_OAM_BW_N_50:
                {
                    for(srs_bw_count = RRM_ZERO; srs_bw_count <= SRS_BW3; srs_bw_count++)
                    {
                        srs_bw_array_for_c_srs[srs_bw_count] =
                            srs_rb_allocation_tbl_bw_10[subframe_bw_config][srs_bw_count][RRM_ZERO];
                    }
                }
                break; 

            case RRM_OAM_BW_N_75:
                {
                    for(srs_bw_count = RRM_ZERO; srs_bw_count <= SRS_BW3; srs_bw_count++)
                    {
                        srs_bw_array_for_c_srs[srs_bw_count] =
                            srs_rb_allocation_tbl_bw_15[subframe_bw_config][srs_bw_count][RRM_ZERO];
                    }
                }
                break; 

            case RRM_OAM_BW_N_100:
                {
                    for(srs_bw_count = RRM_ZERO; srs_bw_count <= SRS_BW3; srs_bw_count++)
                    {
                        srs_bw_array_for_c_srs[srs_bw_count] =
                            srs_rb_allocation_tbl_bw_20[subframe_bw_config][srs_bw_count][RRM_ZERO];
                    }
                }
                break;

            default:
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "INVALID CHANNEL BW recieved!!!");
        }
        if (ce_num_of_rb >= srs_bw_array_for_c_srs[SRS_BW0] )
        {
            *p_wb_hopping_bw_for_ce =  SRS_BW0;
            *p_n_rrc_min_index = ((ce_start_rb / RRM_FOUR) == RRM_ZERO) ? (ce_start_rb / RRM_FOUR) : 
                ((ce_start_rb / RRM_FOUR) - RRM_ONE);
                if (RRM_TRUE == hopping_enable)
                {
                    *p_wb_srs_bw_for_ce =  SRS_BW1;
                }
                else
                {
                    *p_wb_srs_bw_for_ce =  SRS_BW0;
                }
        }
        else if (ce_num_of_rb >= srs_bw_array_for_c_srs[SRS_BW1] )
        {
            *p_wb_hopping_bw_for_ce = SRS_BW1;
            *p_n_rrc_min_index = ((ce_start_rb / RRM_FOUR) == RRM_ZERO) ? (ce_start_rb / RRM_FOUR) : 
                ((ce_start_rb / RRM_FOUR) - RRM_ONE);
                if (RRM_TRUE == hopping_enable)
                {
                    *p_wb_srs_bw_for_ce =  SRS_BW2;
                }
                else
                {
                    *p_wb_srs_bw_for_ce =  SRS_BW1;
                }

        }
        else if (ce_num_of_rb >= srs_bw_array_for_c_srs[SRS_BW2] )
        {
            *p_wb_hopping_bw_for_ce = SRS_BW2;
            *p_n_rrc_min_index = ((ce_start_rb / RRM_FOUR) == RRM_ZERO) ? (ce_start_rb / RRM_FOUR) : 
                ((ce_start_rb / RRM_FOUR) - RRM_ONE);
                if (RRM_TRUE == hopping_enable)
                {
                    *p_wb_srs_bw_for_ce =  SRS_BW3;
                }
                else
                {
                    *p_wb_srs_bw_for_ce=  SRS_BW2;
                }

        }
        else if (ce_num_of_rb >= srs_bw_array_for_c_srs[SRS_BW3] )
        {
            *p_wb_srs_bw_for_ce = SRS_BW3;
            *p_n_rrc_min_index = ((ce_start_rb / RRM_FOUR) == RRM_ZERO) ? (ce_start_rb / RRM_FOUR) : 
                ((ce_start_rb / RRM_FOUR) - RRM_ONE);
            *p_wb_hopping_bw_for_ce =  SRS_BW3;
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "SRS BW[%d], Hopping BW[%d], n_rrc_Min_Index[%d] ",
                *p_wb_srs_bw_for_ce, *p_wb_hopping_bw_for_ce, *p_n_rrc_min_index);
    }

    /*SPR 21223 START*/
    /* Code Moved */ 
    /*SPR 21223 END*/

	RRM_UT_TRACE_EXIT();
}

/* SPR_8391_CHANGES_END*/
/*Klockwork_fix_start*/
rrm_void_t
print_srs_resource_info_sb(rrm_cell_context_t   *p_cell_context ,
                           U16                  last_indx_for_sb)
{
    U16 count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    for(count = RRM_ZERO; count < last_indx_for_sb;
            count++)
    { 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "SB SRS CONFIG at index [%d]",count);

    /*SPR 21223 START*/
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "SRS INDEX -[%d]",p_cell_context->srs_table.p_subband_srs_table[count].srs_index);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "N_RRC - [%d]",p_cell_context->srs_table.p_subband_srs_table[count].n_rrc);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "COMB - [%d]",p_cell_context->srs_table.p_subband_srs_table[count].comb);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "CYCLIC_SHIFT -[%d]" ,p_cell_context->srs_table.p_subband_srs_table[count].c_shift);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "STATUS - [%d]",p_cell_context->srs_table.p_subband_srs_table[count].srs_marked_status);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
                "SRS ANCHOR - [%d]",p_cell_context->srs_table.p_subband_srs_table[count].anchor);
    /*SPR 21223 END*/
    }
    RRM_UT_TRACE_EXIT();
}
/*Klockwork_fix_end*/

rrm_void_t
print_srs_resource_info
(
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();

	U16 count = RRM_ZERO;
	U16 last_indx_for_sb = RRM_ZERO;

	last_indx_for_sb = p_cell_context->allocated_srs_max_anchor_val - p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs;
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"MAX SRS CONFIGURATIONS are [%d]",p_cell_context->allocated_srs_max_anchor_val);

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"SWITCH POINT FROM WB TO SB SRS CONFIGURATIONS is  [%d]",p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"RES ANCHOR FOR WB SRS CONFIGURATIONS are from 1 - [%d]",
			(p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs -RRM_ONE ));
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"RES ANCHOR FOR SB SRS CONFIGURATIONS are from [%d] - [%d]",
			p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs,
			p_cell_context->allocated_srs_max_anchor_val);
	last_indx_for_sb = p_cell_context->allocated_srs_max_anchor_val - p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"LAST INDEX for SB CONFIGURATIONS is [%d]",
			last_indx_for_sb);

	for(count = RRM_ZERO; count < (p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs - RRM_ONE );
			count++)
	{ 
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"WB SRS CONFIG at index [%d]",count);

    /*SPR 21223 START*/
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"SRS INDEX -[%d]",p_cell_context->srs_table.p_wideband_srs_table[count].srs_index);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"COMB - [%d]",p_cell_context->srs_table.p_wideband_srs_table[count].comb);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"CYCLIC_SHIFT -[%d]" ,p_cell_context->srs_table.p_wideband_srs_table[count].c_shift);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"STATUS - [%d]",p_cell_context->srs_table.p_wideband_srs_table[count].srs_marked_status);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"SRS ANCHOR - [%d]",p_cell_context->srs_table.p_wideband_srs_table[count].anchor);
    /*SPR 21223 END*/
	}

    /*Klockwork_fix_start*/
    print_srs_resource_info_sb(p_cell_context ,last_indx_for_sb);
    /*Klockwork_fix_end*/
	RRM_UT_TRACE_EXIT();

}
rrm_void_t
rrm_set_srs_resources_free
(
 rrm_cell_context_t *p_cell_ctx
 )
{
	rrm_wb_srs_table_t            *p_wb_srs_table = RRM_PNULL;
	rrm_sb_srs_table_t            *p_sb_srs_table = RRM_PNULL;
	U16                           srs_index = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

    /* SPR 22835 Fix Start */
    if(PNULL != p_cell_ctx->srs_table.p_wideband_srs_table)
    {
        /*SPR 21223 START*/
        for(srs_index = RRM_ZERO; srs_index < p_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs;
                srs_index++)
        {
            p_wb_srs_table = &(p_cell_ctx->srs_table.p_wideband_srs_table[srs_index]);
            p_wb_srs_table->srs_marked_status = RRM_RES_FREE;
        }
    }
    if(PNULL != p_cell_ctx->srs_table.p_subband_srs_table)
    {
	    for(srs_index = RRM_ZERO ; 
			srs_index <= (p_cell_ctx->allocated_srs_max_anchor_val -  p_cell_ctx->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
			srs_index++)
    	{ 
	    	p_sb_srs_table = &(p_cell_ctx->srs_table.p_subband_srs_table[srs_index]);
    	    p_sb_srs_table->srs_marked_status = RRM_RES_FREE;
	    }
    /*SPR 21223 END*/
   }
   /* SPR 22835 Fix End */
	RRM_UT_TRACE_EXIT();
}


/*SPR 21223 START*/
rrm_return_et
rrm_initialize_srs_parameters_for_ue
/*SPR 21223 END*/
(
 rrm_cell_context_t *p_cell_context
 )
{
    /*SPR 21223 START*/
    rrm_return_et   ret_val = RRM_SUCCESS;
    U16 max_num_ue_per_cell     = RRM_ZERO;
    max_num_ue_per_cell = p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell;
    if(p_cell_context->srs_table.p_wideband_srs_table)
    {
            RRM_MEM_FREE( p_cell_context->srs_table.p_wideband_srs_table);
    }
    p_cell_context->srs_table.p_wideband_srs_table = rrm_mem_get(sizeof(rrm_wb_srs_table_t) * max_num_ue_per_cell);
    if (p_cell_context->srs_table.p_wideband_srs_table == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_context->srs_table.p_wideband_srs_table failed" );
        ret_val = RRM_FAILURE ;
        RRM_UT_TRACE_EXIT();
        return ret_val;
    }
    RRM_MEMSET(p_cell_context->srs_table.p_wideband_srs_table, RRM_ZERO, (sizeof(rrm_wb_srs_table_t) * max_num_ue_per_cell));
    if(p_cell_context->srs_table.p_subband_srs_table)
    {
        /* SPR 22835 Fix Start */
            RRM_MEM_FREE( p_cell_context->srs_table.p_subband_srs_table);
        /* SPR 22835 Fix End */
    }
    p_cell_context->srs_table.p_subband_srs_table = rrm_mem_get(sizeof(rrm_sb_srs_table_t) * max_num_ue_per_cell);
    if (p_cell_context->srs_table.p_subband_srs_table == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cell_context->srs_table.p_subband_srs_table failed" );
        ret_val = RRM_FAILURE ;
        RRM_UT_TRACE_EXIT();
        return ret_val;
    }
    RRM_MEMSET(p_cell_context->srs_table.p_subband_srs_table, RRM_ZERO, (sizeof(rrm_sb_srs_table_t) * max_num_ue_per_cell));
    return ret_val;
    /*SPR 21223 END*/

}

rrm_void_t
populate_wideband_srs_res_list
(
 rrm_wb_srs_table_t *rrm_wb_srs_table,
 U16 *p_srs_subframes_list,
 U16 wb_srs_max_index,
/* SPR_8391_CHANGES_START*/
 U16 *p_res_anchor,
 U8 srs_bw,
 /*SPR 21223 START*/
 U8 srs_hopping_bw,
 rrm_bool_et completely_wideband,
 U16 max_ue_supported_per_cell
 /*SPR 21223 END*/
/* SPR_8391_CHANGES_END*/
 )
{
	U8  cyclic_shift_index = RRM_ZERO;
	U8  comb_index = RRM_ZERO;
	U16 count_for_resource = RRM_ZERO;
	U16 srs_subframes_list_index = RRM_ZERO;
	U16 srs_index = RRM_ZERO;
    /*SPR 21223 START*/
    U16 srs_higher_bound = RRM_ZERO;
    U16 srs_resources_value = RRM_ZERO;
    U16 srs_indexes_for_wideband = RRM_ZERO;
    /*SPR 21223 END*/
	RRM_UT_TRACE_ENTER();

    /*SPR 21223 START*/
    if(RRM_TRUE == completely_wideband)
    {
       srs_indexes_for_wideband = wb_srs_max_index;
       srs_resources_value = (wb_srs_max_index * RRM_SIXTEEN);    
    }
    else
    {
       srs_indexes_for_wideband = (U16)RRM_FLOOR( (float)(((WB_SRS_CONFIG_PERCENT)* (float)(wb_srs_max_index))));
       srs_resources_value = (U16)RRM_FLOOR( (float)(((WB_SRS_CONFIG_PERCENT)* 
                (float)(wb_srs_max_index*RRM_SIXTEEN))));
    }   

    if(max_ue_supported_per_cell  < srs_resources_value)
	{
        srs_higher_bound = max_ue_supported_per_cell ;
    }
    else
    {
        srs_higher_bound = srs_resources_value;
    }

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_INFO,
            "wb_srs_max_index =[%d], MAX_UE_SUPPORTED_PER_CELL  =[%d],"
            " srs_higher_bound =[%d],srs_resources_value =[%u],srs_indexes_for_wideband = [%u]",
            wb_srs_max_index, max_ue_supported_per_cell
            ,srs_higher_bound,srs_resources_value,srs_indexes_for_wideband);

    for(cyclic_shift_index = RRM_ZERO;(cyclic_shift_index < RRM_EIGHT)&&(count_for_resource < srs_higher_bound);cyclic_shift_index++)
		{
        for (comb_index = RRM_ZERO;
                (comb_index<MAX_TRANS_COMB)&&(count_for_resource < srs_higher_bound) ; comb_index++)
			{
            for(srs_subframes_list_index = RRM_ZERO ; 
                 (srs_subframes_list_index < srs_indexes_for_wideband) && 
                 (count_for_resource < srs_higher_bound);
                srs_subframes_list_index++)
			{
                /*SPR 21223 END*/
				srs_index = p_srs_subframes_list[srs_subframes_list_index]; 

				rrm_wb_srs_table[count_for_resource].srs_index = srs_index;
				rrm_wb_srs_table[count_for_resource].comb = comb_index;
				rrm_wb_srs_table[count_for_resource].c_shift =  cyclic_shift_index;
				rrm_wb_srs_table[count_for_resource].srs_marked_status = RRM_RES_FREE;
				*p_res_anchor = (*p_res_anchor) + RRM_ONE;
				rrm_wb_srs_table[count_for_resource].anchor = *p_res_anchor;
                /* SPR_8391_CHANGES_START*/
				rrm_wb_srs_table[count_for_resource].srs_bw = srs_bw;
				rrm_wb_srs_table[count_for_resource].srs_hopping_bw = srs_hopping_bw;
				/*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				  "srs_table:- Res Index[%d],Comb[%d], CyclicShift[%d], AllocStatus[%d], SRS Anchor[%d]",
				  rrm_wb_srs_table[count_for_resource].srs_index,
				  rrm_wb_srs_table[count_for_resource].comb,
				  rrm_wb_srs_table[count_for_resource].c_shift,
				  rrm_wb_srs_table[count_for_resource].srs_marked_status,
				  rrm_wb_srs_table[count_for_resource].anchor,
                                  rrm_wb_srs_table[count_for_resource].srs_bw,
                                  rrm_wb_srs_table[count_for_resource].srs_hopping_bw);*/
                /* SPR_8391_CHANGES_END*/
				count_for_resource ++;  
			}
		}
	}
    /*SPR 21223 START*/
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_BRIEF,
					  "count_for_resource for wideband = %d",count_for_resource);
    /*SPR 21223 END*/
	RRM_UT_TRACE_EXIT();
}


rrm_void_t
populate_subband_srs_res_list
(
 rrm_sb_srs_table_t *rrm_sb_srs_table,
 U16 *p_srs_subframes_list,
 U16 wb_srs_max_index,
 U16 srs_subframes_max_count,
/* SPR_8391_CHANGES_START*/
 U8 n_rrc_min_index,
 U8 n_rrc_max_count,
 U8 n_rb_hopping_bw,
 U16 *p_res_anchor,
 U8 wb_hopping_bw_for_ce,
 U8 srs_bw,
 U16 max_ue_supported_per_cell 
/* SPR_8391_CHANGES_END*/
 )
{
	U8  cyclic_shift_index = RRM_ZERO;
	U8  comb_index = RRM_ZERO;
	U16 count_for_resource = RRM_ZERO;
	U16 srs_subframes_list_index = RRM_ZERO;
    /*SPR 21223 START*/
	U16  n_rrc_index = RRM_ZERO;
    /*SPR 21223 END*/
	U16 srs_index = RRM_ZERO;
/* SPR_8391_CHANGES_START*/
	U8 n_rrc_counter = RRM_ZERO;
    /* SPR_8391_CHANGES_END*/
    /*SPR 21223 START*/
    U16 srs_higher_bound = RRM_ZERO;
    U16 srs_lower_bound = RRM_ZERO;
    U16 subband_resource_value = RRM_ZERO;
    U16 wideband_resource_value = RRM_ZERO;
    /*SPR 21223 END*/

	RRM_UT_TRACE_ENTER();

    /*SPR 21223 START*/
    srs_lower_bound =
        (U16)RRM_FLOOR((float)(((WB_SRS_CONFIG_PERCENT)*(float)(srs_subframes_max_count))));

    subband_resource_value = (U16)RRM_FLOOR( (float)(((SB_SRS_CONFIG_PERCENT)* 
                (float)(srs_subframes_max_count*RRM_SIXTEEN*n_rrc_max_count))));

    wideband_resource_value = (U16)RRM_FLOOR( (float)(((WB_SRS_CONFIG_PERCENT)* 
                (float)(srs_subframes_max_count*RRM_SIXTEEN))));

    if(max_ue_supported_per_cell < subband_resource_value)
	{
        srs_higher_bound =  max_ue_supported_per_cell;
    }
    else
	{
        srs_higher_bound = subband_resource_value;
    }

	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_INFO,
            "wb_srs_max_index =[%d], MAX_UE_SUPPORTED_PER_CELL =[%d],srs_lower_bound"
            "=[%d],n_rrc_max_count =[%d], srs_higher_bound =[%u],"
            "n_rrc_max_count=[%d],srs_subframes_max_count[%d],subband_resource_value=[%u],wideband_resource_value = [%u]",
            wb_srs_max_index, max_ue_supported_per_cell ,srs_lower_bound
            ,n_rrc_max_count , srs_higher_bound ,
            n_rrc_max_count,srs_subframes_max_count,subband_resource_value,wideband_resource_value);

    for(cyclic_shift_index = RRM_ZERO;(cyclic_shift_index< RRM_EIGHT)&&(count_for_resource < srs_higher_bound);cyclic_shift_index++)
	{
        for (comb_index = RRM_ZERO;
                ((comb_index<MAX_TRANS_COMB)&&(count_for_resource < srs_higher_bound)); comb_index++)
		{
/* SPR_8391_CHANGES_START*/
            n_rrc_counter = RRM_ZERO;
            for(n_rrc_index = n_rrc_min_index; ((n_rrc_index < n_rrc_min_index +
                            n_rrc_max_count)&&(count_for_resource < srs_higher_bound)) ;n_rrc_index++)
                /* SPR_8391_CHANGES_END*/
			{
                for(srs_subframes_list_index = srs_lower_bound; 
                        ((srs_subframes_list_index <
                          srs_subframes_max_count)&&(count_for_resource < srs_higher_bound)); srs_subframes_list_index++)
				{
                    /*SPR 21223 END*/
					srs_index = p_srs_subframes_list[srs_subframes_list_index]; 

					rrm_sb_srs_table[count_for_resource].srs_index = srs_index;
/* SPR_8391_CHANGES_START*/
					rrm_sb_srs_table[count_for_resource].n_rrc = n_rrc_min_index + ((n_rrc_counter * n_rb_hopping_bw) / RRM_FOUR);
/* SPR_8391_CHANGES_END*/
					rrm_sb_srs_table[count_for_resource].comb = comb_index;
					rrm_sb_srs_table[count_for_resource].c_shift =  cyclic_shift_index;
					rrm_sb_srs_table[count_for_resource].srs_marked_status = RRM_RES_FREE;
					*p_res_anchor = (*p_res_anchor) + RRM_ONE;
					rrm_sb_srs_table[count_for_resource].anchor = *p_res_anchor;
/* SPR_8391_CHANGES_START*/
					rrm_sb_srs_table[count_for_resource].srs_bw = srs_bw;
					rrm_sb_srs_table[count_for_resource].srs_hopping_bw = wb_hopping_bw_for_ce;
/* SPR_8391_CHANGES_END*/
					/*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
							"srs_table:- Res Index[%d], N_RRC [%d], Comb[%d], CyclicShift[%d], AllocStatus[%d], SRS Anchor[%d], SRS BW[%d], SRS HOPP BW[%d]",
							rrm_sb_srs_table[count_for_resource].srs_index,
							rrm_sb_srs_table[count_for_resource].n_rrc,
							rrm_sb_srs_table[count_for_resource].comb,
							rrm_sb_srs_table[count_for_resource].c_shift,
							rrm_sb_srs_table[count_for_resource].srs_marked_status,
							rrm_sb_srs_table[count_for_resource].anchor,
							rrm_sb_srs_table[count_for_resource].srs_bw,
							rrm_sb_srs_table[count_for_resource].srs_hopping_bw);*/
					count_for_resource ++;   
				}
/* SPR_8391_CHANGES_START*/
                n_rrc_counter++;
/* SPR_8391_CHANGES_END*/
			}
		}
	}
    /*SPR 21223 START*/
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,RRM_INFO,
					  "count_for_resource for Sub-band = %d",count_for_resource);
    /*SPR 21223 END*/

	RRM_UT_TRACE_EXIT();
}


rrm_void_t
find_srs_index_limit_for_wb_and_sb
(
 U16 srs_subframes_max_count, 
 U16 *p_wb_srs_max_index  
 )
{
	RRM_UT_TRACE_ENTER();
	U8 num_of_indexes_for_wb_srs = RRM_ZERO;

	num_of_indexes_for_wb_srs = RRM_FLOOR( (float)(((WB_SRS_CONFIG_PERCENT)* (float )(srs_subframes_max_count))));
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_BRIEF,
					  "num_of_indexes_for_wb_srs = %d",num_of_indexes_for_wb_srs);

	*p_wb_srs_max_index =  num_of_indexes_for_wb_srs;

	RRM_UT_TRACE_EXIT();
}
/*TDD_SRS_FREQ_HOPPING_END */

/* SPR 8422 FIX START */
rrm_void_t
get_bw_parts_frm_system_bw
(
   rrm_oam_band_width_et system_bw,
   U8 *p_j_bw_parts
)
{
    RRM_UT_TRACE_ENTER();
    
    switch(system_bw)
    {
        case RRM_OAM_BW_N_6:
            *p_j_bw_parts = RRM_ZERO;
            break;

        case RRM_OAM_BW_N_15:
        case RRM_OAM_BW_N_25:
            *p_j_bw_parts = RRM_TWO;
            break;

        case RRM_OAM_BW_N_50:
            *p_j_bw_parts = RRM_THREE;
            break;

        case RRM_OAM_BW_N_75:
        case RRM_OAM_BW_N_100:
            *p_j_bw_parts = RRM_FOUR;
            break;
    } 
    
     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	           "System BW [%d]and J_BW_PARTS [%d]",system_bw,*p_j_bw_parts);
    RRM_UT_TRACE_EXIT();
}
/* SPR 8422 FIX END */

 /*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_compare_sub_frame_offset_for_cqi
 * Inputs         : sr_periodicity,cqi_periodicity,sr_config_index,cqi_config_index
 * Outputs        : None
 * Returns        : RRM_TRUE : Subframe offset for CQI and SR is same
 *                  RRM_FALSE: Subframe offset for CQI and SR is not same 
 * Description    : This function checks whether the subfram offsets allocated
 *                  for CQI and SR are same or not.
 ****************************************************************************/
rrm_void_t
rrm_compare_sub_frame_offset_for_cqi(U8  cqi_periodicity ,
                                     U16 *p_cqi_start_index)
{
    RRM_UT_TRACE_ENTER();
#ifndef TDD_MODE_FLAG 
    switch(cqi_periodicity)
    {
        case CQI_PERIODICITY_0:
            *p_cqi_start_index = CQI_PERIODICITY_2MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_1:
            *p_cqi_start_index = CQI_PERIODICITY_5MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_2:
            *p_cqi_start_index = CQI_PERIODICITY_10MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_3:
            *p_cqi_start_index = CQI_PERIODICITY_20MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_4:
            *p_cqi_start_index = CQI_PERIODICITY_40MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_5:
            *p_cqi_start_index = CQI_PERIODICITY_80MS_FDD_START_INDEX;
            break;

        case CQI_PERIODICITY_6:
            *p_cqi_start_index = CQI_PERIODICITY_160MS_FDD_START_INDEX;
            break;

        default :
            *p_cqi_start_index = CQI_PERIODICITY_10MS_FDD_START_INDEX;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Default value chosen");
    }
#else
    switch(cqi_periodicity)
    {
	    /* Coverity 40958 fix start */
	    /* Coverity 40958 fix end */
	    case CQI_PERIODICITY_1:
		    *p_cqi_start_index = CQI_PERIODICITY_5MS_TDD_START_INDEX;
		    break;

	    case CQI_PERIODICITY_2:
		    *p_cqi_start_index = CQI_PERIODICITY_10MS_TDD_START_INDEX;
		    break;

	    case CQI_PERIODICITY_3:
		    *p_cqi_start_index = CQI_PERIODICITY_20MS_TDD_START_INDEX;
		    break;

	    case CQI_PERIODICITY_4:
		    *p_cqi_start_index = CQI_PERIODICITY_40MS_TDD_START_INDEX;
		    break;

	    case CQI_PERIODICITY_5:
		    *p_cqi_start_index = CQI_PERIODICITY_80MS_TDD_START_INDEX;
		    break;

	    case CQI_PERIODICITY_6:
		    *p_cqi_start_index = CQI_PERIODICITY_160MS_TDD_START_INDEX;
		    break;

	    default :
		    *p_cqi_start_index = CQI_PERIODICITY_10MS_TDD_START_INDEX;
		    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
				    "Default value chosen");
    }
#endif
    RRM_UT_TRACE_EXIT();
}
#ifndef TDD_MODE_FLAG

/*Klockwork_fix_start*/
rrm_void_t
assign_cqi_periodicity_from_cell_context(U16   cqi_periodicity_in_ms ,
                                         U16   *cqi_periodicity ,
                                         U16   *runtime_calculated)
{
    RRM_UT_TRACE_ENTER();
	if (cqi_periodicity_in_ms <= CQI_PERIODICITY_2MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_0;
        *runtime_calculated = CQI_PERIODICITY_2MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_5MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_1;
        *runtime_calculated = CQI_PERIODICITY_5MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_10MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_2;
        *runtime_calculated = CQI_PERIODICITY_10MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_20MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_3;
        *runtime_calculated = CQI_PERIODICITY_20MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_40MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_4;
        *runtime_calculated = CQI_PERIODICITY_40MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_80MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_5;
        *runtime_calculated = CQI_PERIODICITY_80MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_160MS)
	{
        *cqi_periodicity = CQI_PERIODICITY_6;
        *runtime_calculated = CQI_PERIODICITY_160MS;
	}
	else
	{
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "CQI periodicity in ms is greater than 160. So, value chosen for CQI Periodicity is(%u)",
                *cqi_periodicity);
        *cqi_periodicity = CQI_PERIODICITY_6;
        *runtime_calculated = CQI_PERIODICITY_160MS;
    }
    RRM_UT_TRACE_EXIT();
}
rrm_void_t
assign_initial_cqi_periodicity(rrm_cell_context_t  *p_cell_context ,
                               U16                 *cfg_configured)
{
    RRM_UT_TRACE_ENTER();
    /* SPR 20653 Fix Start */
    switch(p_cell_context->operator_info.admission_control_info.min_cqi_periodicity)
    /* SPR 20653 Fix End */
    {
        case CQI_PERIODICITY_0 :
            *cfg_configured = CQI_PERIODICITY_2MS;
            break;
        case CQI_PERIODICITY_1 :
            *cfg_configured = CQI_PERIODICITY_5MS;
            break;
        case CQI_PERIODICITY_2 :
            *cfg_configured = CQI_PERIODICITY_10MS;
            break;
        case CQI_PERIODICITY_3 :
            *cfg_configured = CQI_PERIODICITY_20MS;
            break;
        case CQI_PERIODICITY_4 :
            *cfg_configured = CQI_PERIODICITY_40MS;
            break;
        case CQI_PERIODICITY_5 :
            *cfg_configured = CQI_PERIODICITY_80MS;
            break;
        case CQI_PERIODICITY_6 :
            *cfg_configured = CQI_PERIODICITY_160MS;
            break;
        default :
    /* SPR 20653 Fix Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Incorrect Value(%d) configured from CFG, so picking up 10ms Periodicity",
                    p_cell_context->operator_info.admission_control_info.min_cqi_periodicity);
            *cfg_configured = CQI_PERIODICITY_10MS;
             /* Start :SPR 8687 */
             p_cell_context->operator_info.admission_control_info.min_cqi_periodicity = CQI_PERIODICITY_2;
    /* SPR 20653 Fix End */
             /* End :SPR 8687 */
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix Start */
/* Code removed */
/* SPR 20653 Fix End */
/*Klockwork_fix_end*/

rrm_void_t find_cqi_periodicity_from_cell_context
(
 rrm_cell_context_t *p_cell_context,
 U16                *p_cqi_periodicity
 )

{
    /* +- SPR 18268 */
	U16                      max_num_ue = RRM_ZERO;
    /* +- SPR 18268 */
	U8                      n_rb_cqi = RRM_ZERO;
	U8                      delta_pucch_shift = RRM_ZERO;
	U16                     cqi_periodicity = RRM_ZERO;
	U16                     cqi_periodicity_in_ms = RRM_ZERO;
    /* SPR 7957_FIX_START */
	U16                     runtime_calculated = RRM_ZERO;
	U16                     cfg_configured = RRM_ZERO;
    /* SPR 21251 +- */
    /* SPR 7957_FIX_END */
#ifdef LTE_EMBMS_SUPPORTED
    U8                     factor = RRM_ZERO;
    U8                     new_rf_count = RRM_ZERO;
    U8                     non_mbms_sf  = RRM_ZERO;
#endif
	RRM_UT_TRACE_ENTER();

	max_num_ue = p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell;
	n_rb_cqi = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi;
	/* OAM has configured the delta pucch values 0,1,2
	   RRM needs to map the values to 1,2,3 delta_pucch_shift + 1 is required */
	delta_pucch_shift = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift + RRM_ONE;


	if (RRM_ZERO == max_num_ue)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
				"UE Configured Incorrect. No resource Allocation:%d",
				max_num_ue);
		return;
	}

	if (RRM_ZERO == n_rb_cqi)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
				"UE Configured Incorrect. N_RB_CQI default value used:%d",
				n_rb_cqi);
		n_rb_cqi = RRM_TWO;
	}

    /* Bug:4253 Fix Start */
    if (RRM_TRUE == rrm_cellm_is_victim_node(p_cell_context))
    {
        cqi_periodicity_in_ms = ((max_num_ue + RRM_MAX_ELIGIBLE_ACTIVE_VICTIM_UE) / ((N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB / delta_pucch_shift)* n_rb_cqi)) + RRM_ONE;
    }
    else
    {
	cqi_periodicity_in_ms = ((max_num_ue) / ((N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB / delta_pucch_shift)* n_rb_cqi)) + RRM_ONE;
    }
    /* Bug:4253 Fix End */
#ifdef LTE_EMBMS_SUPPORTED
    if((p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_2_ON_BROADCAST ) ||
      (p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_13_ON_BROADCAST ))
    { 
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "MBMS is enabled in System ,Re-Calculate Cqi_Periodicity in ms including MBMS SFs");
        non_mbms_sf = get_num_of_non_mbms_sf_count(p_cell_context->rrm_cell_embms_data.embms_sf_reserved_list);
        if ( RRM_TEN != non_mbms_sf)
        {
            if( RRM_ZERO != ( cqi_periodicity_in_ms % non_mbms_sf) )
            {
                factor = RRM_ONE;
            }
            new_rf_count = ((cqi_periodicity_in_ms / non_mbms_sf) + factor );
            cqi_periodicity_in_ms = new_rf_count * RRM_TEN;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    " New cqi_periodicity_in_ms = %d",cqi_periodicity_in_ms);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "No MBSFN's SF present. No need to Re-Calculate "
                    "Cqi_Periodicity in ms including MBMS SFs");
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                  "MBMS is yet not enabled in System ,No need to Re-Calculate "
                  "Cqi_Periodicity in ms including MBMS SFs");
    }
#endif


    /* SPR 7957_FIX_START */
    /*Klockwork_fix_start*/
    assign_cqi_periodicity_from_cell_context(cqi_periodicity_in_ms ,&cqi_periodicity ,&runtime_calculated);
    assign_initial_cqi_periodicity(p_cell_context ,&cfg_configured);
    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */
    /*Klockwork_fix_end*/
    


	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"RRM Run time Logic Calculations:- max_num_ue(%d), Value calculated for CQI Periodicity is(%d)ms ,"
            "Lower bound configured for CQI Periodicity is (%d)ms ",
			max_num_ue, runtime_calculated, cfg_configured);

    /* SPR 20653 Fix Start */
	if( cqi_periodicity < p_cell_context->operator_info.admission_control_info.min_cqi_periodicity)
	{
		cqi_periodicity = p_cell_context->operator_info.admission_control_info.min_cqi_periodicity;
	}
    /* Code removed */
    /* SPR 20653 Fix End */
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Value chosen for CQI Periodicity is(%d)ms",
                runtime_calculated);
    }
    /* SPR 7957_FIX_END */

	*p_cqi_periodicity = cqi_periodicity;
	RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name  : find_srs_time_and_delta_sfc_from_cell_context
 * Inputs         : subframe_config
 * Outputs        : p_subframe_config, p_time, p_delta, p_count
 * Returns        : void
 * Description    : Find the time and delta sfc from cell context.
 ****************************************************************************/
rrm_void_t
find_srs_time_and_delta_sfc_from_cell_context
(
 U8                 subframe_config,
 U8                 *p_time,
 U8                 *p_delta,
 U8                 *p_count
 )
{
	U8  delta[RRM_EIGHT] = {RRM_ZERO};
	U8  time = RRM_ZERO;
	U8  count_for_delta_sfc = RRM_ZERO;
	/** This fuction allows to get the set of value for SRS ON for OFF in which 
	  subframe number which is as per 3GPP spec 36.211 section 5.3.2 */
	/*    RRM_UT_TRACE_ENTER();*/

	switch(subframe_config)
	{
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC0 :
			time = RRM_ONE;
			delta[RRM_ZERO]=RRM_ZERO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC1 :
			time = RRM_TWO;
			delta[RRM_ZERO]=RRM_ZERO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC2 :
			time = RRM_TWO;
			delta[RRM_ZERO]=RRM_ONE;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC3 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_ZERO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC4 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_ONE;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC5 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_TWO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC6 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_THREE;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC7 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_ZERO;
			delta[RRM_ONE]=RRM_ONE;
			*p_count =RRM_TWO;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC8 :
			time = RRM_FIVE;
			delta[RRM_ZERO]=RRM_TWO;
			delta[RRM_ONE]=RRM_THREE;
			*p_count =RRM_TWO;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC9 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_ZERO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC10 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_ONE;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC11 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_TWO;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC12 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_THREE;
			*p_count =RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC13 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_ZERO;
			delta[RRM_ONE]=RRM_ONE;
			delta[RRM_TWO]=RRM_TWO;
			delta[RRM_THREE]=RRM_THREE;
			delta[RRM_FOUR]=RRM_FOUR;
			delta[RRM_FIVE]=RRM_SIX;
			delta[RRM_SIX]=RRM_EIGHT;
			*p_count =RRM_SEVEN;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC14 :
			time = RRM_TEN;
			delta[RRM_ZERO]=RRM_ZERO;
			delta[RRM_ONE]=RRM_ONE;
			delta[RRM_TWO]=RRM_TWO;
			delta[RRM_THREE]=RRM_THREE;
			delta[RRM_FOUR]=RRM_FOUR;
			delta[RRM_FIVE]=RRM_FIVE;
			delta[RRM_SIX]=RRM_SIX;
			delta[RRM_SEVEN]=RRM_EIGHT;
			*p_count =RRM_EIGHT;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC15 :
			break;
		default :
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Value chosen for SRS configuration is wrong (%d)",
					subframe_config);
	}
	*p_time = time;
	for ( count_for_delta_sfc = RRM_ZERO; count_for_delta_sfc < *p_count; count_for_delta_sfc++ )
	{
		p_delta[count_for_delta_sfc] = delta[count_for_delta_sfc];
	}
	/*    RRM_UT_TRACE_EXIT();*/
}
/****************************************************************************
 * Function Name  : find_srs_periodicity_from_cell_context
 * Inputs         : max_num_ue, p_srs_periodicity, p_srs_start_index
 * Outputs        : p_srs_periodicity, p_srs_start_index
 * Returns        : void
 * Description    : checks the maximum number of UE and and finds out the 
 *                  srs periodicity and srs start index.
 ****************************************************************************/
rrm_void_t
find_srs_periodicity_from_cell_context
(
 rrm_cell_context_t  *p_cell_context,
 U16                 *p_srs_start_index,
 U16                 *p_srs_offset,
 U16                 *p_srs_periodicity_in_ms
 )
{
	RRM_UT_TRACE_ENTER();

	switch(p_cell_context->operator_info.admission_control_info.srs_periodicity)
    {
            case SRS_PERIODICITY_0:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_2_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_2_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_2MS;
                    break;
                }

            case SRS_PERIODICITY_1:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_5_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_5_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_5MS;
                    break;
                }

            case SRS_PERIODICITY_2:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_10_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_10_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_10MS;
                    break;
                }

            case SRS_PERIODICITY_3:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_20_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_20_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_20MS;
                    break;
                }
            
            case SRS_PERIODICITY_4:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_40_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_40_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_40MS;
                    break;
                }
            
            case SRS_PERIODICITY_5:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_80_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_80_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_80MS;
                    break;
                }
            
            case SRS_PERIODICITY_6:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_160_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_160_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_160MS;
                    break;
                }
            
            case SRS_PERIODICITY_7:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_320_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_320_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_320MS;
                    break;
                }
            default:
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Invalid Value (%d) is configured from CFG for SRS Periodicity"
                            "So chosing SRS periodicity as 5",
                            p_cell_context->operator_info.admission_control_info.srs_periodicity);
                    *p_srs_start_index = SRS_START_INDEX_FOR_80_MS;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_80_MS;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_80MS;
                    p_cell_context->operator_info.admission_control_info.srs_periodicity = SRS_PERIODICITY_5;
                }
    }

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
			"Value chosen for SRS Periodicity is %d", *p_srs_periodicity_in_ms);

	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_cellm_cell_initialize_srs_res_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the SRS resource list
 ****************************************************************************/
rrm_void_t
rrm_cellm_cell_initialize_srs_res_list
(
 rrm_cell_context_t *p_cell_context
 )
{
	U16  srs_index = RRM_ZERO;
	U16  srs_config_index = RRM_ZERO;
	U16 srs_start_index = RRM_ZERO;
	U16 srs_offset = RRM_ZERO;
	U8  srs_subframe_offset_ns = RRM_ZERO;
	U16 srs_periodicity_in_ms = RRM_ZERO;
	U8  delta_sfc = RRM_ZERO;
	U8  config_period_t_sfc = RRM_ZERO;
	U8  num_of_delta_sfc_derived_frm_subFrame_config = RRM_ZERO;
	U8  delta[RRM_EIGHT] = {RRM_ZERO};
	U16 res_anchor = RRM_ZERO;
	U8  subframe_config = RRM_ZERO;

	/* SRS_FREQ_HOPPING_START */
	U16 wb_srs_max_index   = RRM_ZERO;
	U16 srs_subframes_list[SRS_PERIODICITY_320MS] = {RRM_ZERO};
	U16 srs_subframes_list_index = RRM_ZERO; 
	U16 srs_subframes_max_count = RRM_ZERO;
	rrm_oam_band_width_et  channel_bandwidth = RRM_OAM_BW_N_6;
	U8 n_rrc_max_count = RRM_ZERO;
	U8  subframe_bw_config = RRM_ZERO;
    /* SPR_8391_CHANGES_START*/
    U16   count = RRM_ZERO;
    /* SPR_8391_CHANGES_END*/
	/* SRS_FREQ_HOPPING_END */
	
    /* SPR 8019 FIX START */
    rrm_frequency_selective_sched_et freq_selective_sched = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE; 
    /* SPR 8019 FIX END */

    /* SPR_8391_CHANGES_START*/
    rrm_icic_scheme_type_et         icic_scheme = ICIC_SCHEME_NONE; 
    operator_info_t            *p_operator_info = RRM_PNULL;

    U8  wb_srs_bw_for_ce = RRM_ZERO;
    U8  wb_hopping_bw_for_ce = RRM_ZERO;
    U8  n_rrc_min_index = RRM_ZERO;
    U8  n_rb_hopping_bw = RRM_ZERO;
    rrm_bool_et hopping_enable = RRM_FALSE;

	RRM_UT_TRACE_ENTER();

    p_operator_info = &(p_cell_context->operator_info);
    RRM_ASSERT(RRM_PNULL != p_operator_info);
    
    freq_selective_sched = p_operator_info->rrm_mac_config.
                                  enable_frequency_selective_scheduling.ul_freq_selective_enable;
    
    if((RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & p_operator_info->bitmask) && 
       (RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT & p_operator_info->dynamic_icic_info.bitmask))
    {
        icic_scheme = p_operator_info->dynamic_icic_info.icic_scheme_type;
    }
    
    if(RRM_ONE == p_cell_context->ran_info.physical_layer_params.physical_layer_param_srs.srs_hopping_enable)
    {
        hopping_enable = RRM_TRUE;
    }
    /* SPR_8391_CHANGES_END*/

    subframe_config = p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_srs.srs_subframe_config;

    subframe_bw_config = p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_srs.srs_bandwidth_config;
    channel_bandwidth = p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth;
    /*Initializing the values for UE specific SRS parmaters */
    /*SPR 21223 START*/ 
    if(RRM_SUCCESS == rrm_initialize_srs_parameters_for_ue(p_cell_context))
    {	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Values for UE specific SRS parmaters Intialized Successfully");
    }
    /*SPR 21223 END*/ 

	/** Find SRS periodicity and from cell context */
	find_srs_periodicity_from_cell_context(p_cell_context,
			&srs_start_index,
			&srs_offset,
			&srs_periodicity_in_ms);


	/* SRS_FREQ_HOPPING_START */
	/** WIDEBAND : Loop for SRS config index selection */
	for (srs_index = srs_start_index ; srs_index< (srs_start_index + srs_periodicity_in_ms) ; srs_index++)
	{
		/*Determining which subframe should transmit SRS based on values already configured
		  and the one calculated from below mentioned rule as defined in Spec 36.211
		  [ns/2]mod T(sfc)   */
		srs_subframe_offset_ns = (srs_index - srs_offset)% RRM_TEN;
		delta_sfc = srs_subframe_offset_ns;
		find_srs_time_and_delta_sfc_from_cell_context(subframe_config, &config_period_t_sfc, delta,
				&num_of_delta_sfc_derived_frm_subFrame_config);
		delta_sfc = delta_sfc % config_period_t_sfc;

		for ( srs_config_index=RRM_ZERO;
                (srs_config_index< num_of_delta_sfc_derived_frm_subFrame_config) && (srs_subframes_list_index < SRS_PERIODICITY_320MS);
                srs_config_index++ )
		{
			if(delta_sfc == delta[srs_config_index])
			{
				srs_subframes_list[srs_subframes_list_index] = srs_index;
				srs_subframes_list_index++; 
				break;
			}
		}
	}

	srs_subframes_max_count =  srs_subframes_list_index;

/* SPR_8391_CHANGES_START*/
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	  "There are [%d] valid SRS subframes :", srs_subframes_max_count);
	  for(count = 0 ; count < srs_subframes_max_count ; count++)
	  {
	  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	  "SRS subframe[%d]",srs_subframes_list[count]);
	  }
/* SPR_8391_CHANGES_END*/

    /* SPR 8019 FIX START */
      /*SPR 21090 START*/
    if(( RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE ==
                freq_selective_sched)||((RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE ==
                    freq_selective_sched)&& ((ICIC_SCHEME_HFR == icic_scheme)||(
                            ICIC_SCHEME_NONE == icic_scheme))))
      /*SPR 21090 END*/
    {

        /* SPR_8391_CHANGES_START*/
        /*SPR 21223 START*/
        populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_subframes_list,srs_subframes_max_count,
                &res_anchor,SRS_BW0,SRS_BW0,RRM_TRUE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
        /*SPR 21223 END*/
        /* SPR_8391_CHANGES_END*/

        p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
        p_cell_context->allocated_srs_max_anchor_val = res_anchor;
        
/* Start fix for Coverity_ID : 83297 */       
        if(RRM_ZERO != srs_subframes_max_count)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Wideband SRS resourcs- [%d] ,wideband srs indexes: [%d] - [%d], Switch_point: [%d]",
                    p_cell_context->allocated_srs_max_anchor_val,
                    srs_subframes_list[0],srs_subframes_list[srs_subframes_max_count -1],
                    p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
        }
        /* Coverity 83297 Fix End*/
    }
    else
    {
        /* SPR_8391_CHANGES_START*/
        if (ICIC_SCHEME_NONE != icic_scheme)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "ICIC Scheme[%d] is configured from OAM. Allocating Sub band as per CE/CC Partition",icic_scheme);


            if((p_cell_context->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT) &&
                    (p_cell_context->operator_info.dynamic_icic_info.ul_resource_partition_info.num_of_cell_edge_region != RRM_ZERO))
            {
        /*SPR 21223 START*/
                /*code deleted*/
                populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_subframes_list,srs_subframes_max_count,
                        &res_anchor,SRS_BW0,SRS_BW0,RRM_FALSE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
        /*SPR 21223 END*/

                p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
                get_sub_band_data_sets_for_icic(channel_bandwidth,
                        hopping_enable,
                        subframe_bw_config,
                        &(p_cell_context->operator_info.dynamic_icic_info),
                        &wb_srs_bw_for_ce,
                        &wb_hopping_bw_for_ce,
                        &n_rrc_min_index);

                get_the_n_rrc_index_max_limit(channel_bandwidth, subframe_bw_config, 
                        wb_srs_bw_for_ce, wb_hopping_bw_for_ce, &n_rrc_max_count, &n_rb_hopping_bw);

        /*SPR 21223 START*/
                populate_subband_srs_res_list(p_cell_context->srs_table.p_subband_srs_table, srs_subframes_list,
                        wb_srs_max_index, srs_subframes_max_count,
                        n_rrc_min_index, n_rrc_max_count, 
                        n_rb_hopping_bw, &res_anchor,
                        wb_hopping_bw_for_ce, wb_srs_bw_for_ce,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
        /*SPR 21223 END*/
                /* SPR_8391_CHANGES_END*/

                p_cell_context->allocated_srs_max_anchor_val = res_anchor;

                /* SPR 8019 FIX START */
                /* Coverity 83297 Fix Start*/
                if(RRM_ZERO != srs_subframes_max_count)
                {
             /*SPR 21223 START*/
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Wideband SRS resourcs- [%d] ,"
                            "Subband SRS resources- [%d] " , 
                            (p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs-1),
                            (p_cell_context->allocated_srs_max_anchor_val -
                             p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs + 1));
             /*SPR 21223 END*/
                }
                /* Coverity 83297 Fix End*/
                /* SPR 8019 FIX END */
                /* SPR_8391_CHANGES_START*/
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "CE Partition is absent")
             /*SPR 21223 START*/
                    populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_subframes_list,srs_subframes_max_count,
                            &res_anchor,SRS_BW0,SRS_BW0,RRM_TRUE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
             /*SPR 21223 END*/

                p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
                p_cell_context->allocated_srs_max_anchor_val = res_anchor;
		/* SPR 19838: CID 10422 Fix Start */
		if(RRM_ZERO != srs_subframes_max_count)
		{
                	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        	"Wideband SRS resourcs- [%d] ,wideband srs indexes: [%d] - [%d], Switch_point: [%d]",
                        	p_cell_context->allocated_srs_max_anchor_val,
                        	srs_subframes_list[0],srs_subframes_list[srs_subframes_max_count -1],
                        	p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
		}
		/* SPR 19838: CID 10422 Fix End */
            }
        }
      /*SPR 21090 START*/
      /*code deleted*/
      /*SPR 21090 END*/
    }
    /* SPR 8019 FIX END */

	/*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	  "MAX Value of Res Anchor=[%d] , START_ANCHOR_FOR_SUBBAND = [%d]",
	  p_cell_context->allocated_srs_max_anchor_val,p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);*/

	//print_srs_resource_info(p_cell_context);
	/* SRS_FREQ_HOPPING_END */
	RRM_UT_TRACE_EXIT();
}

     /* SPR14123end */
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrm_compare_sub_frame_offset_for_sr_and_cqi 
 * Inputs         : sr_periodicity,cqi_periodicity,sr_config_index,cqi_config_index
 * Outputs        : None
 * Returns        : RRM_TRUE : Subframe offset for CQI and SR is same
 *                  RRM_FALSE: Subframe offset for CQI and SR is not same 
 * Description    : This function checks whether the subfram offsets allocated
 *                  for CQI and SR are same or not.
 ****************************************************************************/
rrm_return_et
rrm_compare_sub_frame_offset_for_sr_and_cqi(
		U8  sr_periodicity,
		U8  cqi_periodicity,
		U8   sr_config_index,
		U16 cqi_config_index,
        /* SPR 16427 fix start */
        rrm_cell_context_t* p_rrm_cell_ctx
        /* SPR 16427 fix end */
		)
{

	U16             sr_start_index = RRM_ZERO;
	U16             cqi_start_index = RRM_ZERO;
	U16             sr_sub_frame_offset = RRM_ZERO;
	U16             cqi_sub_frame_offset = RRM_ZERO;
	rrm_return_et   ret_val = RRM_SUCCESS;
    /* SPR 16427 fix start */
    U8              sr_periodicity_ms = RRM_ZERO;
    U8              cqi_periodicity_ms = RRM_ZERO;
    /* SPR 16427 fix end */

	RRM_UT_TRACE_ENTER();

	switch(sr_periodicity)
	{
		case SR_PERIODICITY_0:
			sr_start_index = SR_PERIODICITY_5MS_START_INDEX;
			break;

		case SR_PERIODICITY_1:
			sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
			break;

		case SR_PERIODICITY_2:
			sr_start_index = SR_PERIODICITY_20MS_START_INDEX;
			break;

		case SR_PERIODICITY_3:
			sr_start_index = SR_PERIODICITY_40MS_START_INDEX;
			break;

		case SR_PERIODICITY_4:
			sr_start_index = SR_PERIODICITY_80MS_START_INDEX;
			break;
            /*spr_22345_changes_start*/
		case SR_PERIODICITY_5:
			sr_start_index = SR_PERIODICITY_2MS_START_INDEX;
			break;

		case SR_PERIODICITY_6:
			sr_start_index = SR_PERIODICITY_1MS_START_INDEX;
			break;
            /*spr_22345_changes_end*/

		default :
			sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
					"Default value chosen");
	}
    /* SPR 16427 fix start */
    rrm_get_sr_periodicity_in_ms(p_rrm_cell_ctx, &sr_periodicity_ms);
    /* SPR 16427 fix end */
	sr_sub_frame_offset = sr_config_index - sr_start_index;
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"sr_sub_frame_offset(%d), sr_config_index(%d), sr_start_index(%d)", 
			sr_sub_frame_offset, sr_config_index, sr_start_index);

    /*Klockwork_fix_start*/
    rrm_compare_sub_frame_offset_for_cqi(cqi_periodicity ,&cqi_start_index);
    /*Klockwork_fix_end*/

    /* SPR 16427 fix start */
    rrm_get_cqi_periodicity_in_ms(p_rrm_cell_ctx, &cqi_periodicity_ms);
    /* SPR 16427 fix end */
	cqi_sub_frame_offset = cqi_config_index - cqi_start_index;
    /* SPR 16427 fix start */
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
            "sr_config_index(%d), sr_sub_frame_offset(%d), sr_periodicity_ms(%d)ms, cqi_config_index(%d), cqi_sub_frame_offset(%d), cqi_periodicity_ms(%d)ms",
            sr_config_index, sr_sub_frame_offset, sr_periodicity_ms, cqi_config_index, cqi_sub_frame_offset, cqi_periodicity_ms);

    if ( RRM_TRUE == rrm_is_sr_cqi_collide( sr_sub_frame_offset,
                sr_periodicity_ms, cqi_sub_frame_offset, cqi_periodicity_ms ) )
    {
        ret_val = RRM_FAILURE;
    }
    /* SPR 16427 fix end */

	RRM_UT_TRACE_EXIT();
	return ret_val;
}


rrm_return_et prepare_cqi_ri_resource_list
(
 rrm_cell_context_t      *p_cell_context,
 cqi_ri_map_info_per_ue  *p_outgoing_map,
 U16                     cqi_periodicity_val,
 U16                      *p_alloc_cqi_ri_from_algo_val
 )
{
	rrm_bool_et          table_formed = RRM_FALSE;
	U16                  cqi_periodicity = RRM_ZERO;
	U16                  num_correct_mapping_recvd = RRM_ZERO;
	U16                  shuffle = RRM_ZERO;
	U16                        ri_start_index = RRM_ZERO;
	U16                        cqi_start_index = RRM_ZERO;
	U16                        last_calc_max_unique_val_count = RRM_ZERO;
	/* warning removal: structure intiatialization 10/04/2012 */
	cqi_ri_map_info_per_ue     cqi_ri_table_map[MAX_PERIODICTY_CQI_N_P] = {{RRM_ZERO}};
	cqi_ri_map_info_per_ue     cqi_ri_table_map_temp[MAX_PERIODICTY_CQI_N_P] = {{RRM_ZERO}};

	U16      map_count = RRM_ZERO;
	U16      map_idx = RRM_ZERO;
	static U16      ri_index[MAX_RI_INDEX_ARRAY_SIZE] = {RRM_ZERO};
	U16      ri_index_max_count = RRM_ZERO;
	U16      ri_index_count = RRM_ZERO;
	U16      cqi_index_count = RRM_ZERO;
	U16      ri_periodicity_val = RRM_ZERO;
	U16      ri_periodicity = RRM_ZERO;
    /* Coverity_fix_start_30706 */
	U16      *p_cqi_indexval_for_configured_periodicity = RRM_PNULL;
    /* Coverity_fix_end_30706 */
	/* SPR 8422 FIX START */
    rrm_frequency_selective_sched_et freq_selective_sched = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE ;
	U8       H_Val = RRM_ZERO;
    U8       J_bw_parts = RRM_ZERO;
    U8       K_subband_size = RRM_ZERO;
    /* SPR 8422 FIX END */
#ifdef LTE_EMBMS_SUPPORTED
    U8        index = RRM_ZERO;
#endif
	RRM_UT_TRACE_ENTER();
    /* SPR 11029 Fix Start */
    p_cqi_indexval_for_configured_periodicity = (U16 *) rrm_mem_get ( sizeof(U16) * CQI_INDEX_ARRAY_SIZE);
    /* SPR 11029 Fix End */
    /* Coverity_fix_start_62557 */
    if (p_cqi_indexval_for_configured_periodicity != RRM_PNULL)
    {
        /* SPR 11029 Fix Start */
        RRM_MEMSET(p_cqi_indexval_for_configured_periodicity, RRM_ZERO, ( sizeof(U16) * CQI_INDEX_ARRAY_SIZE));
        /* SPR 11029 Fix End */

	switch(cqi_periodicity_val)
	{
		case CQI_PERIODICITY_0:
			cqi_periodicity = CQI_PERIODICITY_2MS;
			cqi_start_index = CQI_PERIODICITY_2MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_1:
			cqi_periodicity = CQI_PERIODICITY_5MS;
			cqi_start_index = CQI_PERIODICITY_5MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_2:
			cqi_periodicity = CQI_PERIODICITY_10MS;
			cqi_start_index = CQI_PERIODICITY_10MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_3:
			cqi_periodicity = CQI_PERIODICITY_20MS;
			cqi_start_index = CQI_PERIODICITY_20MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_4:
			cqi_periodicity = CQI_PERIODICITY_40MS;
			cqi_start_index = CQI_PERIODICITY_40MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_5:
			cqi_periodicity = CQI_PERIODICITY_80MS;
			cqi_start_index = CQI_PERIODICITY_80MS_FDD_START_INDEX;
			break;

		case CQI_PERIODICITY_6:
			cqi_periodicity = CQI_PERIODICITY_160MS;
			cqi_start_index = CQI_PERIODICITY_160MS_FDD_START_INDEX;
			break;
	}
	//ri_reporting_period = RI_REPORTING_PERIOD_IN_MULTIPLES_CQI_PMI;
	/* SPR 8422 FIX START */
    freq_selective_sched = p_cell_context->operator_info.rrm_mac_config.
                                  enable_frequency_selective_scheduling.dl_freq_selective_enable;

    if(RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE == freq_selective_sched)
    {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	           "Both wideband and subband CQI reporting is configured");
    /* SPR 20653 Fix Start */
	    ri_periodicity_val = p_cell_context->operator_info.admission_control_info.min_ri_periodicity;  
    /* SPR 20653 Fix End */

        get_bw_parts_frm_system_bw( p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                    &J_bw_parts);
        K_subband_size = rrm_cellm_get_subband_size();/*SPR 17777 +-*/

        H_Val = (J_bw_parts * K_subband_size) + RRM_ONE;
        
        ri_periodicity = H_Val * cqi_periodicity * ri_periodicity_val;

        while (ri_periodicity > 10240)
        {
          ri_periodicity_val = ri_periodicity_val / 2;
          ri_periodicity = H_Val * cqi_periodicity * ri_periodicity_val;
        }

    /* SPR 20653 Fix Start */
        if(ri_periodicity_val != p_cell_context->operator_info.admission_control_info.min_ri_periodicity)
        { 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "MRI value configured from cfg is (%d).But RI offsets are coming > 1024 SFNs, So recalculating MRI as (%d)",
                    p_cell_context->operator_info.admission_control_info.min_ri_periodicity,
                    ri_periodicity_val);
        }
    /* SPR 20653 Fix End */


        switch(ri_periodicity_val)
        {
            case RI_PERIODICITY_1:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_1_START_INDEX;
                break;

            case RI_PERIODICITY_2:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_2_START_INDEX;
                break;

            case RI_PERIODICITY_4:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_4_START_INDEX;
                break;

            case RI_PERIODICITY_8:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_8_START_INDEX;
                break;

            case RI_PERIODICITY_16:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_16_START_INDEX;
                break;

            case RI_PERIODICITY_32:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_32_START_INDEX;
                break;
        }
    }
    else
    {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Only wideband CQI reporting is configured");
    /* SPR 20653 Fix Start */
        ri_periodicity_val = p_cell_context->operator_info.admission_control_info.min_ri_periodicity;  
    /* SPR 20653 Fix End */

        switch(ri_periodicity_val)
        {
            case RI_PERIODICITY_1:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_1;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_1_START_INDEX;
                break;

            case RI_PERIODICITY_2:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_2;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_2_START_INDEX;
                break;

            case RI_PERIODICITY_4:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_4;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_4_START_INDEX;
                break;

            case RI_PERIODICITY_8:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_8;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_8_START_INDEX;
                break;

            case RI_PERIODICITY_16:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_16;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_16_START_INDEX;
                break;

            case RI_PERIODICITY_32:
                ri_periodicity = cqi_periodicity * RI_PERIODICITY_32;
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_32_START_INDEX;
                break;
        }


    }
	/* SPR 8422 FIX END */

	ri_index_max_count = cqi_periodicity;
        /*    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	      "cqi_periodicity[%d], ri_periodicity[%d]", cqi_periodicity, ri_periodicity);*/
    /* Klocwork changes start 27 may */
    for (map_idx = RRM_ZERO; (map_idx < MAX_PERIODICTY_CQI_N_P) && (map_idx < cqi_periodicity); map_idx++)
    /* Klocwork changes end 27 may */
	{
		/* Main Memory Map */
		cqi_ri_table_map[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].allocated = RRM_FALSE;

		/* Transient values Memory Map */
		cqi_ri_table_map_temp[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].allocated = RRM_FALSE;
	}

	for (ri_index_count = RRM_ZERO; ri_index_count < ri_index_max_count; ri_index_count++)
	{
		ri_index[ri_index_count] = ri_start_index + ri_index_count;
	}

	for (cqi_index_count = RRM_ZERO; cqi_index_count < cqi_periodicity; cqi_index_count++)
	{
#ifdef LTE_EMBMS_SUPPORTED
       if((p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_2_ON_BROADCAST ) ||
       (p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_13_ON_BROADCAST ))
        {
            /*
             ** Check whether the calculated subframe offset for CQI reporting
             ** is a MBMS SF or not.
             */
            if ( RRM_FALSE == 
                  rrm_check_configured_mtch_sf( p_cell_context->rrm_cell_embms_data.embms_sf_reserved_list,
                                                cqi_index_count))
            {
                *(p_cqi_indexval_for_configured_periodicity + index) = cqi_index_count + cqi_start_index ; 
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "index[%d], cqi_index_count %d",
                        *(p_cqi_indexval_for_configured_periodicity + cqi_index_count),
                        cqi_index_count );
                index++;

            }
        }
        else
        {
#endif
            *(p_cqi_indexval_for_configured_periodicity + cqi_index_count) = cqi_index_count + cqi_start_index; 

#ifdef LTE_EMBMS_SUPPORTED
        }
#endif
            /* SPR 11029 Fix Start */
            /*       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                     "Populating CQI-Index[%d] = %d", cqi_index_count, p_cqi_indexval_for_configured_periodicity[cqi_index_count]);*/
            /* SPR 11029 Fix End */
	}

	while((table_formed == RRM_FALSE) && (shuffle < cqi_periodicity))
	{

#ifndef LTE_EMBMS_SUPPORTED
            call_function_to_map_indexes(p_cqi_indexval_for_configured_periodicity, ri_index, cqi_ri_table_map,
                /*SPR 17777 +-*/
				cqi_periodicity, ri_periodicity, cqi_start_index, ri_start_index);
#else
        if((p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_2_ON_BROADCAST ) ||
            (p_cell_context->rrm_cell_embms_data.current_sibs_on_boradcast & MBMS_SIB_13_ON_BROADCAST))
        {
            call_function_to_map_indexes(p_cqi_indexval_for_configured_periodicity, ri_index, cqi_ri_table_map,
                    cqi_periodicity, ri_periodicity, cqi_start_index, ri_start_index, index);
        }
        else
        {
            call_function_to_map_indexes(p_cqi_indexval_for_configured_periodicity, ri_index, cqi_ri_table_map,
                    cqi_periodicity, ri_periodicity, cqi_start_index, ri_start_index, cqi_periodicity);
        }

#endif

		num_correct_mapping_recvd = RRM_ZERO;
        /* Klocwork changes start 27 may */
        for (map_count = RRM_ZERO; (map_count < MAX_PERIODICTY_CQI_N_P) && (map_count < cqi_periodicity); map_count++)
        /* Klocwork changes end 27 may */
		{
			if (RRM_TRUE == cqi_ri_table_map[map_count].allocated)
			{
				num_correct_mapping_recvd++;
			}
		}
            /*       RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			 "Total number of correct enteries in count(%d) is %d/%d", 
			 (shuffle +1), num_correct_mapping_recvd, cqi_periodicity);*/
		if (num_correct_mapping_recvd == cqi_periodicity)
		{
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
					" ************* Mapping Table Formed with Correct Values **************");
			table_formed = RRM_TRUE;
            /* Klocwork changes start 27 may */
            for (map_count = RRM_ZERO; (map_count <MAX_PERIODICTY_CQI_N_P) &&(map_count < cqi_periodicity); map_count++)
            /* Klocwork changes end 27 may */
			{
                    /*              RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						"RI[%d], CQI[%d], SF_RI[%d], SF_CQI[%d], Alloc[%d]",
						cqi_ri_table_map[map_count].ri_index,
						cqi_ri_table_map[map_count].cqi_index,
						cqi_ri_table_map[map_count].sf_ri_scheduling,
						map_count,
						cqi_ri_table_map[map_count].allocated);*/
				RRM_MEMCPY(p_outgoing_map, &cqi_ri_table_map, sizeof(cqi_ri_map_info_per_ue) * cqi_periodicity);
				*p_alloc_cqi_ri_from_algo_val = cqi_periodicity;
			}
		}
		else
		{
			if (last_calc_max_unique_val_count < num_correct_mapping_recvd)
			{
				last_calc_max_unique_val_count = num_correct_mapping_recvd;
				RRM_MEMCPY(&cqi_ri_table_map_temp, &cqi_ri_table_map, sizeof(cqi_ri_map_info_per_ue) * last_calc_max_unique_val_count);
			}
			/* Initialise MAP again and shuffle the indexes*/
            /* Klocwork changes start 27 may */
            for (map_idx = RRM_ZERO; (map_idx < MAX_PERIODICTY_CQI_N_P) && (map_idx < cqi_periodicity); map_idx++)
            /* Klocwork changes end 27 may */
			{
				cqi_ri_table_map[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
				cqi_ri_table_map[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
				cqi_ri_table_map[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
				cqi_ri_table_map[map_idx].allocated = RRM_FALSE;
			}
            /* SPR 19359 Fix Start */
            if (cqi_periodicity == ri_periodicity)
            {
            shuffle_ri_indexes(ri_index, cqi_periodicity);
            shuffle++;
        }
            else
            {
                shuffle = cqi_periodicity;
            }
        }
            /* SPR 19359 Fix End */
	}
	if (table_formed == RRM_FALSE )
	{
        /* Klocwork 29 may changes start*/
        if(last_calc_max_unique_val_count < MAX_PERIODICTY_CQI_N_P)
        {
            RRM_MEMCPY(p_outgoing_map, 
                    &cqi_ri_table_map_temp, 
                    sizeof(cqi_ri_map_info_per_ue) * last_calc_max_unique_val_count);
        }
        else
        {
            RRM_MEMCPY(p_outgoing_map, 
                    &cqi_ri_table_map_temp, 
                    sizeof(cqi_ri_map_info_per_ue) * MAX_PERIODICTY_CQI_N_P);
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "last_calc_max_unique_val_count exceeded 160 size so we are using the macro MAX_PERIODICTY_CQI_N_P in MEMCPY");
        }
        /* Klocwork 29 may changes end*/

		*p_alloc_cqi_ri_from_algo_val = last_calc_max_unique_val_count;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"************* Out of Total [%d] resources [%d] are Collison Free **************",
				cqi_periodicity, last_calc_max_unique_val_count);
		for (map_count = RRM_ZERO; map_count < last_calc_max_unique_val_count; map_count++)
		{
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"RI[%d], CQI[%d], SF_RI[%d], SF_CQI[%d], Alloc[%d]",
					p_outgoing_map[map_count].ri_index,
					p_outgoing_map[map_count].cqi_index,
					p_outgoing_map[map_count].sf_ri_scheduling,
					map_count,
					p_outgoing_map[map_count].allocated);
		}
	}
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
               "Dynamic memory allocation is failed for p_cqi_indexval_for_configured_periodicity");
        /* SPR 21251 End */
        return RRM_FAILURE;
    }
    /* Coverity_fix_end_62557 */
    RRM_MEM_FREE(p_cqi_indexval_for_configured_periodicity);
	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;

}

rrm_return_et 
prepare_sr_resource_list
(
            /*SPR 17777 +-*/
 U16                     *p_outgoing_map,
 U16                     sr_periodicity_val,
 U8                      *alloc_sr_from_algo_val 
 )
{
	U16      i = RRM_ZERO;
	U16      sr_start_index = RRM_ZERO;
	U16      sr_periodicity = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	switch(sr_periodicity_val)
	{
		case SR_PERIODICITY_0:
			sr_periodicity = SR_PERIODICITY_5MS;
			sr_start_index = SR_PERIODICITY_5MS_START_INDEX;
			break;

		case SR_PERIODICITY_1:
			sr_periodicity = SR_PERIODICITY_10MS;
			sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
			break;

		case SR_PERIODICITY_2:
			sr_periodicity = SR_PERIODICITY_20MS;
			sr_start_index = SR_PERIODICITY_20MS_START_INDEX;
			break;

		case SR_PERIODICITY_3:
			sr_periodicity = SR_PERIODICITY_40MS;
			sr_start_index = SR_PERIODICITY_40MS_START_INDEX;
			break;

		case SR_PERIODICITY_4:
			sr_periodicity = SR_PERIODICITY_80MS;
			sr_start_index = SR_PERIODICITY_80MS_START_INDEX;
			break;
            /* SPR 18871 Fix Start */
		case SR_PERIODICITY_5:
			sr_periodicity = SR_PERIODICITY_2MS;
			sr_start_index = SR_PERIODICITY_2MS_START_INDEX;
			break;
		case SR_PERIODICITY_6:
			sr_periodicity = SR_PERIODICITY_1MS;
			sr_start_index = SR_PERIODICITY_1MS_START_INDEX;
			break;
            /* SPR 18871 Fix End */
	}

	for (i = RRM_ZERO; i < sr_periodicity; i++)
	{
		p_outgoing_map[i] = i + sr_start_index;
	}
	*alloc_sr_from_algo_val = sr_periodicity;

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}


rrm_void_t call_function_to_map_indexes(U16                  *cqi_indexval_for_configured_periodicity, 
		U16                        *ri_index,
		cqi_ri_map_info_per_ue     *cqi_ri_table_map,
		U16                        cqi_periodicity,
		U16                        ri_periodicity,
		U16                        cqi_start_index,
		U16                        ri_start_index
            /*SPR 17777 +-*/
#ifdef LTE_EMBMS_SUPPORTED
       , U16                       num_of_cqi_indexes 
#endif
		)
{
	S8       entry_done_map = RRM_FALSE;
	S8       collision_found = RRM_FALSE;

	U16      cqi_index_count = RRM_ZERO;
	U16      ri_index_count = RRM_ZERO;
	U16      map_count = RRM_ZERO;
	U16      ri_index_fetched_temp = RRM_ZERO;

	U16      cqi_index = RRM_ZERO;

	S16      n_offset_ri = RRM_ZERO;
	U16      n_offset_cqi = RRM_ZERO;
	U16      sf_for_cqi_sceduling = RRM_ZERO;
	S16      sf_for_ri_sceduling = RRM_ZERO;

	/*    RRM_UT_TRACE_ENTER();*/
#ifndef LTE_EMBMS_SUPPORTED
	for (cqi_index_count = RRM_ZERO; cqi_index_count < cqi_periodicity; cqi_index_count++)
#else
	for (cqi_index_count = RRM_ZERO; cqi_index_count < num_of_cqi_indexes; cqi_index_count++)
#endif
	{
		cqi_index = cqi_indexval_for_configured_periodicity[cqi_index_count];
		/*      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"************* Processing CQI-Index [%d] **************", cqi_index);*/

		n_offset_cqi = cqi_index - cqi_start_index;

		sf_for_cqi_sceduling = n_offset_cqi;

		/*      RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			" N_Offset_CQI [%d], SF_FOR_CQI[%d]", n_offset_cqi, sf_for_cqi_sceduling);*/
		for (ri_index_count = RRM_ZERO; ri_index_count < cqi_periodicity; ri_index_count++)
		{
            /* SPR 19359 Fix Start */
            if(ri_periodicity == cqi_periodicity)
            {
            ri_index_fetched_temp = ri_index[ri_index_count];
            }
            else
            {
                ri_index_fetched_temp = ri_index[RRM_ZERO];
            }
            /* SPR 19359 Fix End */
			n_offset_ri = ri_start_index - ri_index_fetched_temp;
			sf_for_ri_sceduling = n_offset_ri + sf_for_cqi_sceduling;
			if (sf_for_ri_sceduling < RRM_ZERO)
			{
				sf_for_ri_sceduling = ri_periodicity + sf_for_ri_sceduling;
			}
			/*         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				   "N_Offset_RI [%d], SF_FOR_RI[%d], RI Index[%d]", 
				   n_offset_ri, sf_for_ri_sceduling, ri_index_fetched_temp);*/

			collision_found = RRM_FALSE;
#ifndef LTE_EMBMS_SUPPORTED
			for (map_count = RRM_ZERO; map_count < cqi_periodicity; map_count++)
#else
			for (map_count = RRM_ZERO; map_count < num_of_cqi_indexes; map_count++)
#endif
			{
                /* SPR 19359 Fix Start */
                /* check if RI Index is already allocated in stored array */
                if ((sf_for_ri_sceduling == cqi_ri_table_map[map_count].sf_ri_scheduling) &&
                        ((RRM_TRUE == cqi_ri_table_map[map_count].allocated)))
                /* SPR 19359 Fix End */
				{
					/*                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							   "MAP Table Data Collided with RI_Index [%d], SF_FOR_RI[%d], AllocatioStatus[%d]", 
							   ri_index_fetched_temp, sf_for_ri_sceduling, cqi_ri_table_map[map_count].allocated);*/
					collision_found = RRM_TRUE;
					break;
				}
			}
			/* No Probs and we can add data in map table */
			if(RRM_FALSE == collision_found)
			{
				/*            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					      "No collision found for RI Index[%d], so storing it in MAP......", ri_index_fetched_temp);*/
				entry_done_map = RRM_FALSE;
#ifndef LTE_EMBMS_SUPPORTED
				for (map_count = RRM_ZERO; map_count < cqi_periodicity; map_count++)
#else
			for (map_count = RRM_ZERO; map_count < num_of_cqi_indexes; map_count++)
#endif
				{
					/*               RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							 "Entries stored in Map alread RI(%d),CQI(%d),Allocated(%d)",
							 cqi_ri_table_map[map_count].ri_index,
							 cqi_ri_table_map[map_count].cqi_index,
							 cqi_ri_table_map[map_count].allocated);*/
					if (RRM_FALSE == cqi_ri_table_map[map_count].allocated)
					{
						cqi_ri_table_map[map_count].allocated = RRM_TRUE;
						cqi_ri_table_map[map_count].ri_index = ri_index_fetched_temp;
						cqi_ri_table_map[map_count].sf_ri_scheduling = sf_for_ri_sceduling;
						cqi_ri_table_map[map_count].cqi_index = cqi_index;
						entry_done_map = RRM_TRUE;
						break;
					}
				}
				if (RRM_FALSE == entry_done_map) 
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Critical Error has occured in Resource Allocation");
				}
				else
				{
					break;
				}
			}
			else
			{
				entry_done_map = RRM_FALSE;
				continue;
			}

		}
        if(RRM_FALSE == entry_done_map)
        {
            RRM_UT_TRACE_EXIT();
            return;
        }
	}
}

#else
/*
 ** Function definitions to be used when TDD mode is configured 
 */

//TDD
/* SPR 12387 Fix Start */
/****************************************************************************
 * Function Name  : find_ul_opportunity_for_sr_periodicity_calc 
 * Inputs         : sf_assignment
 * Outputs        : ul_opportunity_count 
 * Returns        : value of ul_opportunity_count
 * Description    : returns value of ul_opportunity_count
 ****************************************************************************/
U16 
find_ul_opportunity_for_sr_periodicity_calc(rrm_oam_sub_frame_asgmnt_et sf_assignment)
{
    U16 ul_opportunity_count = RRM_ZERO;
    U16 sf_count = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

    for(sf_count = RRM_ZERO; sf_count < SUBFRAMES_IN_ONE_FRAME; sf_count++)
    {
        if(tdd_config_subfrm_pattern[sf_assignment][sf_count] == UL_SF)
        {
            ++ul_opportunity_count;
        }
    }
	RRM_UT_TRACE_EXIT();
    
    return ul_opportunity_count;
}
/* SPR 12387 Fix End */
/* SPR 12102 Fix Start */
rrm_bool_et
check_if_spcl_sf_reserved_for_rach
(
  U8    prach_config_idx
)
{
   rrm_bool_et ret_val = RRM_FALSE;
   
   RRM_UT_TRACE_ENTER();

   if( ( prach_config_idx >= PRACH_PREAMBLE_FMT_4_CONFIG_IDX_START ) &&
       ( prach_config_idx <= PRACH_PREAMBLE_FMT_4_CONFIG_IDX_END )
     )
   {
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF, 
			      "There can be random access resources in UpPts as PRACH Config IDx is [%d] "
                  "which lies in the prach config idx range i.e.[48-57] for preamble format 4. "
                  "So reserve special SF's UpPts for PRACH and ignore them for SRS", 
                  prach_config_idx);
       ret_val = RRM_TRUE;
   }
   else
   {
       /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, 
			      "There cannot be any random access resources in UpPts as PRACH Config IDx is [%d]. "
                  "So special SF's are not reserved for PRACH and can be utilized for SRS", 
                  prach_config_idx);
        /* SPR 21251 End */
   }

   RRM_UT_TRACE_EXIT();
   return ret_val;
}
/* SPR 12102 Fix End */

rrm_void_t find_cqi_periodicity_from_cell_context
(
 rrm_cell_context_t *p_cell_context,
 U16                *p_cqi_periodicity
 )

{
    /* +- SPR 18268 */
	U16                      max_num_ue = RRM_ZERO;
    /* +- SPR 18268 */
	U8                      n_rb_cqi = RRM_ZERO;
	U8                      delta_pucch_shift = RRM_ZERO;
	U16                     cqi_periodicity = RRM_ZERO;
	U16                     cqi_periodicity_in_ms = RRM_ZERO;
	U8                      tdd_subfrm_config = RRM_NULL;
    U16                      new_cqi_periodicity_tdd = RRM_ZERO;
    /* SPR 7957_FIX_START */
	U16                     runtime_calculated = RRM_ZERO;
	U16                     cfg_configured = RRM_ZERO;
	U16                     cfg_configured_upper_bound = RRM_ZERO;
    /* SPR 7957_FIX_END */

	RRM_UT_TRACE_ENTER();

	max_num_ue = p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell;
	n_rb_cqi = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.n_rb_cqi;
	/* OAM has configured the delta pucch values 0,1,2
	   RRM needs to map the values to 1,2,3 delta_pucch_shift + 1 is required */
	delta_pucch_shift = p_cell_context->ran_info.physical_layer_params.physical_layer_param_pucch.delta_pucch_shift + RRM_ONE;


	if (RRM_ZERO == max_num_ue)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
				"UE Configured Incorrect. No resource Allocation:%d",
				max_num_ue);
		return;
	}

	if (RRM_ZERO == n_rb_cqi)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING, 
				"UE Configured Incorrect. N_RB_CQI default value used:%d",
				n_rb_cqi);
		n_rb_cqi = RRM_TWO;
	}
	cqi_periodicity_in_ms = ((max_num_ue) / ((N2_PUCCH_CYCLIC_SHIFT_IN_ONE_RB / delta_pucch_shift)* n_rb_cqi)) + RRM_ONE;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"max_num_ue(%d), cqi_periodicity_in_ms(%d)",
			max_num_ue, cqi_periodicity_in_ms);

    /* SPR 7957_FIX_START */
	if (cqi_periodicity_in_ms <= CQI_PERIODICITY_1MS)
	{
		cqi_periodicity = CQI_PERIODICITY_0;
        runtime_calculated = CQI_PERIODICITY_1MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_5MS)
	{
		cqi_periodicity = CQI_PERIODICITY_1;
        runtime_calculated = CQI_PERIODICITY_5MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_10MS)
	{
		cqi_periodicity = CQI_PERIODICITY_2;
        runtime_calculated = CQI_PERIODICITY_10MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_20MS)
	{
		cqi_periodicity = CQI_PERIODICITY_3;
        runtime_calculated = CQI_PERIODICITY_20MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_40MS)
	{
		cqi_periodicity = CQI_PERIODICITY_4;
        runtime_calculated = CQI_PERIODICITY_40MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_80MS)
	{
		cqi_periodicity = CQI_PERIODICITY_5;
        runtime_calculated = CQI_PERIODICITY_80MS;
	}
	else if (cqi_periodicity_in_ms <= CQI_PERIODICITY_160MS)
	{
		cqi_periodicity = CQI_PERIODICITY_6;
        runtime_calculated = CQI_PERIODICITY_160MS;
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
				"CQI periodicity in ms is greater than 160.So, value chosen for CQI Periodicity is(%d)",
				cqi_periodicity);
		cqi_periodicity = CQI_PERIODICITY_6;
        runtime_calculated = CQI_PERIODICITY_160MS;
	}
    /* SPR 20653 Fix Start */
    switch(p_cell_context->operator_info.admission_control_info.min_cqi_periodicity)
    /* SPR 20653 Fix End */
    {
        case CQI_PERIODICITY_0 :
             cfg_configured = CQI_PERIODICITY_1MS;
             break;
        case CQI_PERIODICITY_1 :
             cfg_configured = CQI_PERIODICITY_5MS;
             break;
        case CQI_PERIODICITY_2 :
             cfg_configured = CQI_PERIODICITY_10MS;
             break;
        case CQI_PERIODICITY_3 :
             cfg_configured = CQI_PERIODICITY_20MS;
             break;
        case CQI_PERIODICITY_4 :
             cfg_configured = CQI_PERIODICITY_40MS;
             break;
        case CQI_PERIODICITY_5 :
             cfg_configured = CQI_PERIODICITY_80MS;
             break;
        case CQI_PERIODICITY_6 :
             cfg_configured = CQI_PERIODICITY_160MS;
             break;
        default :
             /* SPR 20653 Fix Start */
	         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                       "Incorrect Value(%d) configured from CFG, so picking up 10ms Periodicity",
                       p_cell_context->operator_info.admission_control_info.min_cqi_periodicity);
             /* SPR 20653 Fix End */
             cfg_configured = CQI_PERIODICITY_10MS;
    }
    
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
	
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"RRM Run time Logic Calculations:- Value calculated for CQI Periodicity is(%d)ms ,"
            "Lower bound configured for CQI Periodicity is (%d)ms and Upper bound configured for CQI Periodicity is (%d)ms",
			runtime_calculated, cfg_configured, cfg_configured_upper_bound);

    /* SPR 20653 Fix Start */
	if( cqi_periodicity < p_cell_context->operator_info.admission_control_info.min_cqi_periodicity)
	{
		cqi_periodicity = p_cell_context->operator_info.admission_control_info.min_cqi_periodicity;
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
		 	"Value chosen for CQI Periodicity is(%d)ms",
		 	cfg_configured);
	}
    /* Code removed */
    /* SPR 20653 Fix End */
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Value chosen for CQI Periodicity is(%d)ms",
                runtime_calculated);
    }
    /* SPR 7957_FIX_END */

	/*
	 ** Validate that the periodicity calculated above is a valid for the TDD configuration
	 ** configured for the cell.
	 ** As per specs 36.213 , 
	 ** -- Periodicity of 1 is aplicable for TDD UL/DL configuration of 0, 1, 3, 4, and 6 .
	 ** -- Periodicity of 5 is aplicable for TDD UL/DL configuration of 0, 1, 2, and 6.
	 ** -- Rest all periodicities are valid for all the 6 TDD UL/DL configurations.
	 */
	if(p_cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
	{
        /* Bug 603 Fix Start */
		if((cqi_periodicity == CQI_PERIODICITY_0) ||(cqi_periodicity == CQI_PERIODICITY_1))
        /* Bug 603 Fix End */
		{
			tdd_subfrm_config = p_cell_context->ran_info.physical_layer_params.
				physical_layer_param_tdd_frame_structure.sub_frame_assignment;
			get_valid_cqi_periodicity_for_tdd(cqi_periodicity,tdd_subfrm_config,&new_cqi_periodicity_tdd);
			cqi_periodicity = new_cqi_periodicity_tdd;
		}
	}

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
			"Value chosen for CQI Periodicity after validating for TDD UL/DL config is(%d)",
			cqi_periodicity);


	*p_cqi_periodicity = cqi_periodicity;
	RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name  : check_for_valid_cqi_periodicity_for_tdd
 * Inputs         : tdd_subfrm_config
 *                  cqi_periodicity_in_ms
 * Outputs        : None
 * Returns        : RRM_TRUE : cqi reporting period is applicable for
 *                             TDD configuration.
 *                  RRM_FALSE: cqi reporting period is not applicable for
 *                             TDD configuration.
 * Description    : This funcion checks whether the cqi reporting period is
 *                  applicable for the configured TDD subframe assignment i.e.
 *                  TDD UL/DL configuration or not.
 ****************************************************************************/
rrm_bool_et
check_for_valid_cqi_periodicity_for_tdd
(
 U16 cqi_periodicity ,
 U8 tdd_subfrm_config
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_bool_et ret_val = RRM_TRUE;

	if((cqi_periodicity == CQI_PERIODICITY_0) &&
			((tdd_subfrm_config == RRM_OAM_SA2) || (tdd_subfrm_config == RRM_OAM_SA5)))
	{
		ret_val = RRM_FALSE;
	}
	else if((cqi_periodicity == CQI_PERIODICITY_1) &&
			((tdd_subfrm_config == RRM_OAM_SA3) ||(tdd_subfrm_config == RRM_OAM_SA4)
			 || (tdd_subfrm_config == RRM_OAM_SA5)))
	{
		ret_val = RRM_FALSE;
	}
	else
	{
		/* DO Nothing as cqi_peridicity_in_ms is valed for the tdd_subfrm_config */
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : find_new_cqi_periodicity 
 * Inputs         : cqi_periodicity_in_ms
 *                  tdd_subfrm_config
 * Outputs        : p_cqi_periodicity_tdd
 * Returns        : None
 * Description    : This function calculates the new CQI periodicity (nearest 
 *                  to the already calculated periodicity) which is applicable
 *                  for the configured TDD subframe assignment i.e. TDD UL/DL
 *                  configuration.
 ****************************************************************************/
rrm_void_t find_new_cqi_periodicity
(
 U16 cqi_periodicity,
 U8 tdd_subfrm_config, 
 U16 *p_cqi_periodicity_tdd
 )
{
	RRM_UT_TRACE_ENTER();

	if(( CQI_PERIODICITY_0 == cqi_periodicity) && ( RRM_OAM_SA2 == tdd_subfrm_config))
	{
		*p_cqi_periodicity_tdd = CQI_PERIODICITY_1;
	}   
	else
	{
		*p_cqi_periodicity_tdd = CQI_PERIODICITY_2;
	}

	RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : prepare_cqi_ri_resource_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context,
 *                  cqi_periodicity_val
 * Outputs        : p_outgoing_map , p_alloc_cqi_ri_from_algo_val
 * Returns        : None
 * Description    : This function populates the p_outgoing_map with the CQI
 *                  and RI config indexes and updates 
 *                  p_alloc_cqi_ri_from_algo_val with the count of
 *                  cqi_ri indexes populated.
 ****************************************************************************/
rrm_return_et prepare_cqi_ri_resource_list
(
 rrm_cell_context_t      *p_cell_context,
 cqi_ri_map_info_per_ue  *p_outgoing_map,
 U16                     cqi_periodicity_val,
 U16                      *p_alloc_cqi_ri_from_algo_val
 )
{
	rrm_bool_et                table_formed = RRM_FALSE;
	U16                        cqi_periodicity = RRM_ZERO;
	U16                        num_correct_mapping_recvd = RRM_ZERO;
	U16                        shuffle = RRM_ZERO;
	U16                        ri_start_index = RRM_ZERO;
	U16                        cqi_start_index = RRM_ZERO;
	U16                        last_calc_max_unique_val_count = RRM_ZERO;
	/* warning removal: structure intiatialization 10/04/2012 */
	cqi_ri_map_info_per_ue     cqi_ri_table_map[MAX_PERIODICTY_CQI_N_P] = {{RRM_ZERO}};
	cqi_ri_map_info_per_ue     cqi_ri_table_map_temp[MAX_PERIODICTY_CQI_N_P] = {{RRM_ZERO}};
	U16                        map_count = RRM_ZERO;
	U16                        map_idx = RRM_ZERO;
	U16                        ri_index[MAX_RI_INDEX_ARRAY_SIZE] = {RRM_ZERO};
	U16                        ri_index_max_count = RRM_ZERO;
	U16                        ri_index_count = RRM_ZERO;
	U16                        mri_val = RRM_ZERO;
	U16                        ri_periodicity = RRM_ZERO;
	U16                        cqi_indexval_for_configured_periodicity[CQI_INDEX_ARRAY_SIZE] = {RRM_ZERO};
	U8                         tdd_subfrm_config = RRM_NULL;
	U16                        num_cqi_indexes = RRM_ZERO;
	/* SPR 8422 FIX START */
    rrm_frequency_selective_sched_et freq_selective_sched = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE ;
	U8       H_Val = RRM_ZERO;
    U8       J_bw_parts = RRM_ZERO;
    U8       K_subband_size = RRM_ZERO;
    /* SPR 8422 FIX END */
	RRM_UT_TRACE_ENTER();

	tdd_subfrm_config = p_cell_context->ran_info.physical_layer_params.
		physical_layer_param_tdd_frame_structure.sub_frame_assignment;

	switch(cqi_periodicity_val)
	{
		case CQI_PERIODICITY_0:
			cqi_periodicity = CQI_PERIODICITY_1MS;
			cqi_start_index = CQI_PERIODICITY_1MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_1:
			cqi_periodicity = CQI_PERIODICITY_5MS;
			cqi_start_index = CQI_PERIODICITY_5MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_2:
			cqi_periodicity = CQI_PERIODICITY_10MS;
			cqi_start_index = CQI_PERIODICITY_10MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_3:
			cqi_periodicity = CQI_PERIODICITY_20MS;
			cqi_start_index = CQI_PERIODICITY_20MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_4:
			cqi_periodicity = CQI_PERIODICITY_40MS;
			cqi_start_index = CQI_PERIODICITY_40MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_5:
			cqi_periodicity = CQI_PERIODICITY_80MS;
			cqi_start_index = CQI_PERIODICITY_80MS_TDD_START_INDEX;
			break;

		case CQI_PERIODICITY_6:
			cqi_periodicity = CQI_PERIODICITY_160MS;
			cqi_start_index = CQI_PERIODICITY_160MS_TDD_START_INDEX;
			break;
	}

	/* SPR 8422 FIX START */
    freq_selective_sched = p_cell_context->operator_info.rrm_mac_config.
                                  enable_frequency_selective_scheduling.dl_freq_selective_enable;

    if(RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE == freq_selective_sched)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Both wideband and subband CQI reporting is configured");
        get_bw_parts_frm_system_bw( p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth,
                &J_bw_parts);
        K_subband_size = rrm_cellm_get_subband_size();/*SPR 17777 +-*/

        H_Val = (J_bw_parts * K_subband_size) + RRM_ONE;
        
    /* SPR 20653 Fix Start */
        mri_val = p_cell_context->operator_info.admission_control_info.min_ri_periodicity;  
    /* SPR 20653 Fix End */
        ri_periodicity = H_Val * mri_val * cqi_periodicity;

        while (ri_periodicity > 10240)
        {
          mri_val = mri_val / 2;
          ri_periodicity = H_Val * mri_val * cqi_periodicity;
        }

    /* SPR 20653 Fix Start */
        if(mri_val != p_cell_context->operator_info.admission_control_info.min_ri_periodicity)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "MRI value configured from cfg is (%d).But RI offsets are coming > 1024 SFNs, So recalculating MRI as (%d)",
                    p_cell_context->operator_info.admission_control_info.min_ri_periodicity,
                    mri_val);
        }
    /* SPR 20653 Fix End */


        switch(mri_val)
        {
            case MRI_VAL_1:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_1_START_INDEX;
                break;

            case MRI_VAL_2:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_2_START_INDEX;
                break;

            case MRI_VAL_4:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_4_START_INDEX;
                break;

            case MRI_VAL_8:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_8_START_INDEX;
                break;

            case MRI_VAL_16:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_16_START_INDEX;
                break;

            case MRI_VAL_32:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_32_START_INDEX;
                break;
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	           "Only wideband CQI reporting is configured");
    /* SPR 20653 Fix Start */
        mri_val = p_cell_context->operator_info.admission_control_info.min_ri_periodicity;  
    /* SPR 20653 Fix End */
        ri_periodicity = mri_val * cqi_periodicity;
        switch(mri_val)
        {
            case MRI_VAL_1:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_1_START_INDEX;
                break;

            case MRI_VAL_2:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_2_START_INDEX;
                break;

            case MRI_VAL_4:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_4_START_INDEX;
                break;

            case MRI_VAL_8:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_8_START_INDEX;
                break;

            case MRI_VAL_16:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_16_START_INDEX;
                break;

            case MRI_VAL_32:
                ri_start_index = RI_PERIODICITY_FOR_CQI_MULTIPLE_VAL_32_START_INDEX;
                break;
        }
    }
    /* SPR 8422 FIX END */

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"cqi_periodicity[%d], ri_periodicity[%d]", cqi_periodicity, ri_periodicity);

	prepare_cqi_index_list(cqi_indexval_for_configured_periodicity , 
			tdd_subfrm_config ,cqi_periodicity,cqi_start_index,&num_cqi_indexes);
	
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
			"TDD_DEBUG:VALID CQI INDEXS ARE:");
	for (ri_index_count = 0; ri_index_count < num_cqi_indexes ; ri_index_count++)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name,RRM_DETAILED,
				"CQI INDEX [%d] " , cqi_indexval_for_configured_periodicity[ri_index_count]);

	}

    ri_index_max_count = cqi_periodicity;

	for (ri_index_count = RRM_ZERO; ri_index_count < ri_index_max_count; ri_index_count++)
	{
		ri_index[ri_index_count] = ri_start_index + ri_index_count;

	}

    /* Klocwork changes start 22 may */
    for (map_idx = RRM_ZERO; (map_idx < MAX_PERIODICTY_CQI_N_P) && (map_idx < num_cqi_indexes ); map_idx++)
    /* Klocwork changes end 22 may */
	{
		/* Main Memory Map */
		cqi_ri_table_map[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map[map_idx].allocated = RRM_FALSE;

		/* Transient values Memory Map */
		cqi_ri_table_map_temp[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
		cqi_ri_table_map_temp[map_idx].allocated = RRM_FALSE;
	}

	if( CQI_PERIODICITY_1MS != cqi_periodicity )
	{
		while((table_formed == RRM_FALSE) && (shuffle < ri_index_max_count))
		{
			call_function_to_map_indexes(cqi_indexval_for_configured_periodicity, ri_index, cqi_ri_table_map,
					num_cqi_indexes, cqi_periodicity, ri_periodicity, cqi_start_index, ri_start_index,tdd_subfrm_config);

			num_correct_mapping_recvd = RRM_ZERO;
			for (map_count = RRM_ZERO; map_count < num_cqi_indexes; map_count++)
			{
				if (RRM_TRUE == cqi_ri_table_map[map_count].allocated)
				{
					num_correct_mapping_recvd++;
				}
			}
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Total number of correct enteries in count(%d) is %d/%d", 
					(shuffle +1), num_correct_mapping_recvd, cqi_periodicity);
			if (num_correct_mapping_recvd == num_cqi_indexes)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
						" ************* Mapping Table Formed with Correct Values **************");
				table_formed = RRM_TRUE;
				for (map_count = RRM_ZERO; map_count < cqi_periodicity; map_count++)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"RI[%d], CQI[%d], SF_RI[%d], SF_CQI[%d], Alloc[%d]",
							cqi_ri_table_map[map_count].ri_index,
							cqi_ri_table_map[map_count].cqi_index,
							cqi_ri_table_map[map_count].sf_ri_scheduling,
							map_count,
							cqi_ri_table_map[map_count].allocated);
					RRM_MEMCPY(p_outgoing_map, &cqi_ri_table_map, sizeof(cqi_ri_map_info_per_ue) * cqi_periodicity);
					*p_alloc_cqi_ri_from_algo_val = num_cqi_indexes;
				}
			}
			else
			{
		    /*SPR 19819 30JUN START*/
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"********* Storing the MAP Index temporarily ******");
            /*SPR 19819 30JUN END*/
				if (last_calc_max_unique_val_count < num_correct_mapping_recvd)
				{
					last_calc_max_unique_val_count = num_correct_mapping_recvd;
					RRM_MEMCPY(&cqi_ri_table_map_temp, &cqi_ri_table_map, sizeof(cqi_ri_map_info_per_ue) * last_calc_max_unique_val_count);
				}
				/* Initialise MAP again and shuffle the indexes*/
				for (map_idx = RRM_ZERO; map_idx < num_cqi_indexes; map_idx++)
				{
					cqi_ri_table_map[map_idx].cqi_index = RRM_EVENT_U32_INVALID_VALUE;
					cqi_ri_table_map[map_idx].ri_index = RRM_EVENT_U32_INVALID_VALUE;
					cqi_ri_table_map[map_idx].sf_ri_scheduling = RRM_EVENT_U32_INVALID_VALUE;
					cqi_ri_table_map[map_idx].allocated = RRM_FALSE;
				}
				shuffle_ri_indexes(ri_index, ri_index_max_count);
				shuffle++;
			}   
		}
	}
	else
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"************* Mapping table formed for 1 ms CQI peiodicity************");
		map_cqi_ri_indexes_for_one_cqi_period(cqi_indexval_for_configured_periodicity, 
				ri_index, cqi_ri_table_map,num_cqi_indexes,
				 /*SPR 17777 +-*/ri_start_index);
		table_formed = RRM_TRUE;
	}

	if (table_formed == RRM_FALSE )
	{
		RRM_MEMCPY(p_outgoing_map, 
				&cqi_ri_table_map_temp, 
				sizeof(cqi_ri_map_info_per_ue) * last_calc_max_unique_val_count);
		*p_alloc_cqi_ri_from_algo_val = last_calc_max_unique_val_count;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"************* Mapping Table Formed with Lowest Collision Values  **************");
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"************* Out of Total [%d] resources [%d] are Collison Free **************",
				num_cqi_indexes, last_calc_max_unique_val_count);
		for (map_count = RRM_ZERO; map_count < last_calc_max_unique_val_count; map_count++)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"RI[%d], CQI[%d], SF_RI[%d], SF_CQI[%d], Alloc[%d]",
					p_outgoing_map[map_count].ri_index,
					p_outgoing_map[map_count].cqi_index,
					p_outgoing_map[map_count].sf_ri_scheduling,
					map_count,
					p_outgoing_map[map_count].allocated);
		}
	}

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : map_cqi_ri_indexes_for_one_cqi_period
 * Inputs         : p_cqi_indexval_for_configured_periodicity,p_ri_index
 *                  num_cqi_indexes,cqi_start_index,ri_start_index
 * Outputs        : cqi_ri_table_map 
 * Returns        : None
 * Description    : This function maps the cqi indexes and ri indexes uniquely 
 and populates the cqi_ri_table_map.
 ****************************************************************************/
rrm_void_t
map_cqi_ri_indexes_for_one_cqi_period
(
 U16 *p_cqi_indexval_for_configured_periodicity,
 U16 *p_ri_index,
 cqi_ri_map_info_per_ue *cqi_ri_table_map,
 U16 num_cqi_indexes,
 /*SPR 17777 +-*/
 U16 ri_start_index
 )
{
	U16      map_count = RRM_ZERO;
	U16      sf_for_cqi_sceduling = RRM_ZERO;
	S16      sf_for_ri_sceduling = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	for(map_count = RRM_ZERO ; map_count < num_cqi_indexes ; map_count++)
	{
		sf_for_cqi_sceduling = 
			p_cqi_indexval_for_configured_periodicity[map_count] - ri_start_index; 
		sf_for_ri_sceduling = (ri_start_index - p_ri_index[map_count]) + sf_for_cqi_sceduling;

		cqi_ri_table_map[map_count].allocated = RRM_TRUE;
		cqi_ri_table_map[map_count].ri_index = p_ri_index[map_count] ;
		cqi_ri_table_map[map_count].sf_ri_scheduling = sf_for_ri_sceduling;
		cqi_ri_table_map[map_count].cqi_index = p_cqi_indexval_for_configured_periodicity[map_count];

		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"RI[%d], CQI[%d], SF_RI[%d], SF_CQI[%d], Alloc[%d]",
				cqi_ri_table_map[map_count].ri_index,
				cqi_ri_table_map[map_count].cqi_index,
				cqi_ri_table_map[map_count].sf_ri_scheduling,
				map_count,
				cqi_ri_table_map[map_count].allocated);
	}

	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : prepare_sr_resource_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context,
 *                  sr_periodicity_val
 * Outputs        : p_outgoing_map , alloc_sr_from_algo_val
 * Returns        : None
 * Description    : This function populates the p_outgoing_map with the SR 
 *                  config indexes and updates alloc_sr_from_algo_val
 *                  with the count of SR indexes populated.
 ****************************************************************************/
rrm_return_et 
prepare_sr_resource_list
(
 rrm_cell_context_t      *p_cell_context,
 U16                     *p_outgoing_map,
 U16                     sr_periodicity_val,
 U8                      *alloc_sr_from_algo_val 
 )
{
	U16      sr_start_index = RRM_ZERO;
	U16      sr_periodicity = RRM_ZERO;
	U8      tdd_subfrm_config = RRM_NULL;
	U8       p_num_sr_indexes = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	tdd_subfrm_config = p_cell_context->ran_info.physical_layer_params.
		physical_layer_param_tdd_frame_structure.sub_frame_assignment;
	switch(sr_periodicity_val)
	{
		case SR_PERIODICITY_0:
			sr_periodicity = SR_PERIODICITY_5MS;
			sr_start_index = SR_PERIODICITY_5MS_START_INDEX;
			break;

		case SR_PERIODICITY_1:
			sr_periodicity = SR_PERIODICITY_10MS;
			sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
			break;

		case SR_PERIODICITY_2:
			sr_periodicity = SR_PERIODICITY_20MS;
			sr_start_index = SR_PERIODICITY_20MS_START_INDEX;
			break;

		case SR_PERIODICITY_3:
			sr_periodicity = SR_PERIODICITY_40MS;
			sr_start_index = SR_PERIODICITY_40MS_START_INDEX;
			break;

		case SR_PERIODICITY_4:
			sr_periodicity = SR_PERIODICITY_80MS;
			sr_start_index = SR_PERIODICITY_80MS_START_INDEX;
			break;
            /* SPR 18871 Fix Start */
		case SR_PERIODICITY_5:
			sr_periodicity = SR_PERIODICITY_2MS;
			sr_start_index = SR_PERIODICITY_2MS_START_INDEX;
			break;
		case SR_PERIODICITY_6:
			sr_periodicity = SR_PERIODICITY_1MS;
			sr_start_index = SR_PERIODICITY_1MS_START_INDEX;
			break;
            /* SPR 18871 Fix End */
	}


	prepare_sr_index_list( p_outgoing_map ,tdd_subfrm_config,sr_periodicity,sr_start_index ,&p_num_sr_indexes);

	*alloc_sr_from_algo_val = p_num_sr_indexes;

	RRM_UT_TRACE_EXIT();
	return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : prepare_sr_index_list 
 * Inputs         : tdd_subfrm_config,sr_periodicity,sr_start_index
 * Outputs        : p_outgoing_map,p_num_sr_indexes
 * Returns        : None
 * Description    : This function populates the p_sr_index_list with 
 *                  valid sr indexes as per the TDD UL/DL configuration and 
 *                  updates p_num_sr_indexes with the number of valid sr 
 *                  indexes.
 ****************************************************************************/
rrm_void_t 
prepare_sr_index_list
(
 U16 *p_sr_index_list,
 U8 tdd_subfrm_config ,
 U8  sr_periodicity ,
 U16 sr_start_index,
 U8 *p_num_sr_indexes
 )
{
	U16             sr_index_count = RRM_ZERO;
	U16             sr_offset = RRM_ZERO;
	U16             sr_index_list_count = RRM_ZERO;
	rrm_bool_et     ret_val = RRM_TRUE;

	RRM_UT_TRACE_ENTER();

	for(sr_index_count = sr_start_index ; 
			sr_index_count < (sr_start_index + sr_periodicity); sr_index_count++)
	{
		sr_offset = sr_index_count - sr_start_index;
		/*
		 ** Check whether the calculated subframe offset for SR reporting
		 ** is valid for the given TDD UL/DL config.
		 */
		ret_val = rrm_check_subfrm_offset_is_valid(sr_offset,tdd_subfrm_config,sr_periodicity);

		if(ret_val)
		{
			p_sr_index_list[sr_index_list_count++] = sr_index_count;
		}
	}

	*p_num_sr_indexes = sr_index_list_count;
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : prepare_cqi_index_list 
 * Inputs         : tdd_subfrm_config,cqi_periodicity,cqi_start_index
 * Outputs        : p_cqi_index_list,p_num_cqi_indexes
 * Returns        : None
 * Description    : This function populates the p_cqi_index_list with 
 *                  valid cqi indexes as per the TDD UL/DL configuration and 
 *                  updates p_num_cqi_indexes with the number of valid cqi 
 *                  indexes.
 ****************************************************************************/
rrm_void_t 
prepare_cqi_index_list
(
 U16 *p_cqi_index_list,
 U8 tdd_subfrm_config ,
 U8  cqi_periodicity ,
 U16 cqi_start_index,
 U16 *p_num_cqi_indexes
 )
{
	U16             cqi_index_count = RRM_ZERO;
	U16             cqi_offset = RRM_ZERO;
	U16             cqi_index_list_count = RRM_ZERO;
	rrm_bool_et     ret_val = RRM_TRUE;
	U8              count = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	if( CQI_PERIODICITY_1MS != cqi_periodicity)
	{
		for(cqi_index_count = cqi_start_index ; 
				cqi_index_count < (cqi_start_index + cqi_periodicity); cqi_index_count++)
		{
			cqi_offset = cqi_index_count - cqi_start_index;

			/*
			 ** Check whether the calculated subframe offset for CQI reporting
			 ** is valid for the given TDD UL/DL config.
			 */
			ret_val = rrm_check_subfrm_offset_is_valid(cqi_offset,tdd_subfrm_config,cqi_periodicity);

			if(ret_val)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						" CQI index[%d] is Valid for CQI reporting",cqi_index_count);
				p_cqi_index_list[cqi_index_list_count++] = cqi_index_count;
			}
		}
	}
	else
	{
		for(count = RRM_ZERO ; count < SUBFRAMES_IN_ONE_FRAME ; count ++)
		{
			if(RRM_TRUE == rrm_check_subfrm_offset_is_for_ul(count ,tdd_subfrm_config))
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						" CQI index[%d] is Valid for CQI reporting",count);
				p_cqi_index_list[cqi_index_list_count++] = count;
			}
		}
	}

	*p_num_cqi_indexes = cqi_index_list_count;
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : prepare_ri_index_list 
 * Inputs         : ri_index_max_count,
 *                  tdd_subfrm_config,ri_periodicity,ri_start_index
 * Outputs        : p_ri_index 
 * Returns        : None
 * Description    : This function populates the p_ri_index_list with 
 *                  valid ri indexes as per the TDD UL/DL configuration and 
 *                  updates p_num_ri_indexes with the number of valid ri 
 *                  indexes.
 ****************************************************************************/
rrm_void_t 
prepare_ri_index_list
(
 U16 *p_ri_index_list,
 U8 tdd_subfrm_config ,
 U16 ri_index_max_count,
 U16 ri_start_index,
 U16 ri_periodicity
 )
{
	U16             ri_index_count = RRM_ZERO;
	S16             ri_offset = RRM_ZERO;
	U16             ri_index_list_count = RRM_ZERO;
	rrm_bool_et     ret_val = RRM_TRUE;
	U8              count = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	if( RI_PERIODICITY_1 != ri_periodicity)
	{
		for(ri_index_count = ri_start_index ; 
				ri_index_count < ri_index_max_count  ; ri_index_count++)
		{
			ri_offset = ri_start_index - ri_index_count;

			/*
			 ** Check whether the calculated subframe offset for RI reporting
			 ** is valid for the given TDD UL/DL config.
			 */
			ret_val = rrm_check_subfrm_offset_is_valid(ri_offset,tdd_subfrm_config,ri_periodicity);

			if(ret_val)
			{
				p_ri_index_list[ri_index_list_count++] = ri_index_count;
			}
		}
	}
	else
	{
		/*
		 **  As per specs 36.213 , for periodicity = 1 ms , all the UL subframes
		 **  are utilized for the RI reporting. 
		 */
		for(count = RRM_ZERO ; count < SUBFRAMES_IN_ONE_FRAME ; count ++)
		{
			if(RRM_TRUE == rrm_check_subfrm_offset_is_for_ul(count ,tdd_subfrm_config))
			{
				p_ri_index_list[ri_index_list_count++] = count;
			}
		}
	}

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : get_valid_cqi_periodicity_for_tdd 
 * Inputs         : cqi_periodicity,tdd_subfrm_config
 * Outputs        : p_new_cqi_periodicity_tdd
 * Returns        : None
 * Description    : This function checks the validity of the input periodicty
 *                  and if it is not vlaid , assigns the new periodicity in
 *                  in p_new_cqi_periodicity_tdd
 ****************************************************************************/
rrm_void_t
get_valid_cqi_periodicity_for_tdd
(
 U16 cqi_periodicity,
 U8 tdd_subfrm_config,
 U16 *p_new_cqi_periodicity_tdd
 )
{
	rrm_bool_et             valid_cqi_periodicity = RRM_FALSE;

	valid_cqi_periodicity = check_for_valid_cqi_periodicity_for_tdd(cqi_periodicity ,tdd_subfrm_config);
	if(RRM_FALSE == valid_cqi_periodicity)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"CQI Periodicity[%d], is not valid for the configured TDD UL/DL"
				"subrame configuration [%d]",cqi_periodicity,tdd_subfrm_config);
		find_new_cqi_periodicity(cqi_periodicity ,tdd_subfrm_config,p_new_cqi_periodicity_tdd);
	}
	else
	{
		/*
		 * Given periodicity is valid , so no need to calculate new one
		 */
		*p_new_cqi_periodicity_tdd = cqi_periodicity;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"CQI Periodicity (%d) is valid for the configured TDD UL/DL"
				"subrame configuration(%d)", cqi_periodicity , tdd_subfrm_config);
	}
}
/****************************************************************************
 * Function Name  : rrm_check_subfrm_offset_is_valid 
 * Inputs         : cqi_offset
 *                  tdd_subfrm_config,cqi_periodicity
 * Outputs        : None
 * Returns        : RRM_TRUE  : Subframe offset is valid .
 *                  RRM_FALSE : Subframe offset is not valid.
 * Description    : This function chechs whether the calculated CQI/RI 
 *                  subframe is a valid subframe or not as per the TDD
 *                  UL/DL configuration and periodicity.
 ****************************************************************************/
rrm_bool_et 
rrm_check_subfrm_offset_is_valid
(
 U16 subfrm_offset, 
 U8 tdd_subfrm_config ,
 U8  periodicity
 )
{
	rrm_bool_et ret_val = RRM_FALSE; 
	U16 sbfrm = RRM_NULL;

	//RRM_UT_TRACE_ENTER();

	//sbfrm = subfrm_offset % 10 ;

	/*
	 ** Check whether the dervied subframe is an UL subframe,
	 ** as only UL subframes can be used for CQI/RI/SR reporting in TDD
	 */
	ret_val = rrm_check_subfrm_offset_is_for_ul(subfrm_offset ,tdd_subfrm_config);

	if((periodicity < CQI_PERIODICITY_10MS) && ret_val)
	{
		/*
		 ** Check whether the next subframe derived using the peridicity
		 ** is also an UL subframe
		 ** as only UL subframes can be used for CQI/RI/SR reporting in TDD
		 */
		sbfrm = subfrm_offset + periodicity;
		ret_val = rrm_check_subfrm_offset_is_for_ul(sbfrm , tdd_subfrm_config);
	}

	return ret_val;
	//RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : call_function_to_map_indexes 
 * Inputs         : cqi_indexval_for_configured_periodicity ,ri_index,num_cqi_indexes
 *                  ri_periodicity,cqi_start_index,ri_start_index
 * Outputs        : cqi_ri_table_map 
 * Returns        : None 
 * Description    : This function maps the cqi indexes and ri indexes uniquly
 *                  and populates the cqi_ri_table_map.
 ****************************************************************************/
rrm_void_t call_function_to_map_indexes(U16                  *cqi_indexval_for_configured_periodicity, 
		U16                        *ri_index,
		cqi_ri_map_info_per_ue     *cqi_ri_table_map,
		U16                        num_cqi_indexes,
		U16                        cqi_periodicity,
		U16                        ri_periodicity,
		U16                        cqi_start_index,
		U16                        ri_start_index,
		U8                        tdd_subfrm_config
		)
{
	S8       entry_done_map = RRM_FALSE;
	S8       collision_found = RRM_FALSE;

	U16      cqi_index_count = RRM_ZERO;
	U16      ri_index_count = RRM_ZERO;
	U16      map_count = RRM_ZERO;
	U16      ri_index_fetched_temp = RRM_ZERO;

	U16      cqi_index = RRM_ZERO;

	S16      n_offset_ri = RRM_ZERO;
	U16      n_offset_cqi = RRM_ZERO;
	U16      sf_for_cqi_sceduling = RRM_ZERO;
	S16      sf_for_ri_sceduling = RRM_ZERO;

	/*    RRM_UT_TRACE_ENTER();*/

	for (cqi_index_count = RRM_ZERO; cqi_index_count < num_cqi_indexes; cqi_index_count++)
	{
		cqi_index = cqi_indexval_for_configured_periodicity[cqi_index_count];
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"************* Processing CQI-Index [%d] **************", cqi_index);

		n_offset_cqi = cqi_index - cqi_start_index;

		sf_for_cqi_sceduling = n_offset_cqi;

		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				" N_Offset_CQI [%d], SF_FOR_CQI[%d]", n_offset_cqi, sf_for_cqi_sceduling);
		for (ri_index_count = 0; ri_index_count < cqi_periodicity; ri_index_count++)
		{
			ri_index_fetched_temp = ri_index[ri_index_count];
			n_offset_ri = ri_start_index - ri_index_fetched_temp;
			sf_for_ri_sceduling = n_offset_ri + sf_for_cqi_sceduling;
			if (sf_for_ri_sceduling < RRM_ZERO)
			{
				sf_for_ri_sceduling = ri_periodicity + sf_for_ri_sceduling;
			}
			/*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"N_Offset_RI [%d], SF_FOR_RI[%d], RI Index[%d]", 
					n_offset_ri, sf_for_ri_sceduling, ri_index_fetched_temp);*/

			if(RRM_FALSE == rrm_check_subfrm_offset_is_for_ul(sf_for_ri_sceduling ,tdd_subfrm_config))
			{
				/*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"RI_SF [%d] for RI index [%d] is NOT an UPLINK SF ",sf_for_ri_sceduling,
						ri_index_count); */
				continue;
			}
			else
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"RI index [%d] is valid for RI reporting ",ri_index_count); 
			}

			collision_found = RRM_FALSE;

#ifdef RI_COINCIDE_WITH_CQI
			//RI coincide with CQI, N_OFFSET_RI=0, always use ri_start_index as ri_index
			ri_index_fetched_temp = ri_start_index;
#else
			for (map_count = RRM_ZERO; map_count < num_cqi_indexes; map_count++)
			{
				/* check if RI Index is already allocated in stored array */
				if ( ((ri_index_fetched_temp == cqi_ri_table_map[map_count].ri_index) &&
							(RRM_TRUE == cqi_ri_table_map[map_count].allocated))
						||
						(sf_for_ri_sceduling == cqi_ri_table_map[map_count].sf_ri_scheduling)                    
				   )
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							"MAP Table Data Collided with RI_Index [%d], SF_FOR_RI[%d], AllocatioStatus[%d]", 
							ri_index_fetched_temp, sf_for_ri_sceduling, cqi_ri_table_map[map_count].allocated);
					collision_found = RRM_TRUE;
					break;
				}
			}
#endif

			/* No Probs and we can add data in map table */
			if(RRM_FALSE == collision_found)
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"No collision found for RI Index[%d], so storing it in MAP......", ri_index_fetched_temp);
				entry_done_map = RRM_FALSE;
				for (map_count = RRM_ZERO; map_count < num_cqi_indexes; map_count++)
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							"Entries stored in Map alread RI(%d),CQI(%d),Allocated(%d)",
							cqi_ri_table_map[map_count].ri_index,
							cqi_ri_table_map[map_count].cqi_index,
							cqi_ri_table_map[map_count].allocated);
					if (RRM_FALSE == cqi_ri_table_map[map_count].allocated)
					{
						cqi_ri_table_map[map_count].allocated = RRM_TRUE;
						cqi_ri_table_map[map_count].ri_index = ri_index_fetched_temp;
						cqi_ri_table_map[map_count].sf_ri_scheduling = sf_for_ri_sceduling;
						cqi_ri_table_map[map_count].cqi_index = cqi_index;
						entry_done_map = RRM_TRUE;
						break;
					}
				}
				if (RRM_FALSE == entry_done_map) 
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
							"Critical Error has occured in Resource Allocation");
				}
				else
				{
					break;
				}
			}
			else
			{
				entry_done_map = RRM_FALSE;
				continue;
			}

		}
		if (RRM_FALSE == entry_done_map)
		{
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Critical Error has occured in Resource Allocation");
            /* SPR 21251 End */
			RRM_UT_TRACE_EXIT();
			return;
		}
	}
	/*   RRM_UT_TRACE_EXIT();*/
}

/****************************************************************************
 * Function Name  : rrm_compare_sub_frame_offset_for_sr_and_cqi 
 * Inputs         : sr_periodicity,cqi_periodicity,sr_config_index,cqi_config_index
 * Outputs        : None
 * Returns        : RRM_TRUE : Subframe offset for CQI and SR is same
 *                  RRM_FALSE: Subframe offset for CQI and SR is not same 
 * Description    : This function checks whether the subfram offsets allocated
 *                  for CQI and SR are same or not.
 ****************************************************************************/
rrm_return_et
rrm_compare_sub_frame_offset_for_sr_and_cqi(
		U8  sr_periodicity,
		U8  cqi_periodicity,
		U8   sr_config_index,
		U16 cqi_config_index,
        /* SPR 16427 fix start */
        rrm_cell_context_t* p_rrm_cell_ctx
        /* SPR 16427 fix end */
		)
{

	U16             sr_start_index = RRM_ZERO;
	U16             cqi_start_index = RRM_ZERO;
	U16             sr_sub_frame_offset = RRM_ZERO;
	U16             cqi_sub_frame_offset = RRM_ZERO;
	rrm_return_et   ret_val = RRM_SUCCESS;
    /* SPR 16427 fix start */
    U8              sr_periodicity_ms = RRM_ZERO;
    U8              cqi_periodicity_ms = RRM_ZERO;
    /* SPR 16427 fix end */

	RRM_UT_TRACE_ENTER();

	if( CQI_PERIODICITY_0 != cqi_periodicity )
	{
		switch(sr_periodicity)
		{
			case SR_PERIODICITY_0:
				sr_start_index = SR_PERIODICITY_5MS_START_INDEX;
				break;

			case SR_PERIODICITY_1:
				sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
				break;

			case SR_PERIODICITY_2:
				sr_start_index = SR_PERIODICITY_20MS_START_INDEX;
				break;

			case SR_PERIODICITY_3:
				sr_start_index = SR_PERIODICITY_40MS_START_INDEX;
				break;

			case SR_PERIODICITY_4:
				sr_start_index = SR_PERIODICITY_80MS_START_INDEX;
				break;
                /*spr_22345_changes_start*/
			case SR_PERIODICITY_5:
				sr_start_index = SR_PERIODICITY_2MS_START_INDEX;
				break;

			case SR_PERIODICITY_6:
				sr_start_index = SR_PERIODICITY_1MS_START_INDEX;
				break;
                /*spr_22345_changes_end*/

			default :
				sr_start_index = SR_PERIODICITY_10MS_START_INDEX;
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
						"Default value chosen");
		}
        /* SPR 16427 fix start */
        rrm_get_sr_periodicity_in_ms(p_rrm_cell_ctx, &sr_periodicity_ms);
        /* SPR 16427 fix end */
		sr_sub_frame_offset = sr_config_index - sr_start_index;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"sr_sub_frame_offset(%d), sr_config_index(%d), sr_start_index(%d)", 
				sr_sub_frame_offset, sr_config_index, sr_start_index);

		rrm_compare_sub_frame_offset_for_cqi(cqi_periodicity ,&cqi_start_index);

        /* SPR 16427 fix start */
        rrm_get_cqi_periodicity_in_ms(p_rrm_cell_ctx, &cqi_periodicity_ms);
        /* SPR 16427 fix end */

		cqi_sub_frame_offset = cqi_config_index - cqi_start_index;

        /* SPR 16427 fix start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "sr_config_index(%d), sr_sub_frame_offset(%d), sr_periodicity_ms(%d)ms, cqi_config_index(%d), cqi_sub_frame_offset(%d), cqi_periodicity_ms(%d)ms",
                sr_config_index, sr_sub_frame_offset, sr_periodicity_ms, cqi_config_index, cqi_sub_frame_offset, cqi_periodicity_ms);

        if ( RRM_TRUE == rrm_is_sr_cqi_collide( sr_sub_frame_offset,
                    sr_periodicity_ms, cqi_sub_frame_offset, cqi_periodicity_ms ) )
        {
            /* SPR 21251 Start */
	        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			    "sr cqi collide.");
            /* SPR 21251 End */
            ret_val = RRM_FAILURE;
        }
        /* SPR 16427 fix end */

	}  
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_check_subfrm_offset_is_for_ul
 * Inputs         : cqi_sbfrm
 *                  tdd_subfrm_config
 * Outputs        : None
 * Returns        : RRM_TRUE  : CQI subframe is a UL subframe.
 *                  RRM_FALSE : CQI subframe is not a UL subframe.
 * Description    : This function chechs whether the calculated CQI subframe
 *                  number is a a UL subframe or an DL subframe as per the  
 *                  configured TDD subframe assignment i.e. TDD UL/DL
 *                  configuration.
 ****************************************************************************/
rrm_bool_et
rrm_check_subfrm_offset_is_for_ul
(
 U16 cqi_sbfrm,
 U8 tdd_subfrm_config 
 )
{
	rrm_bool_et ret_val = RRM_FALSE;
	U16 sbfrm = RRM_NULL;

	sbfrm = cqi_sbfrm % SUBFRAMES_IN_ONE_FRAME;
	if(tdd_config_subfrm_pattern[tdd_subfrm_config][sbfrm] == UL_SF)
	{
		ret_val = RRM_TRUE;
	}
	return ret_val;
}

/****************************************************************************
 * Function Name  : find_srs_time_and_delta_sfc_from_cell_context
 * Inputs         : subframe_config
 * Outputs        : p_subframe_config, p_time, p_delta, p_count
 * Returns        : void
 * Description    : Find the time and delta sfc from cell context.
 ****************************************************************************/
rrm_void_t
find_srs_time_and_delta_sfc_from_cell_context
(
 U8                 subframe_config,
 U8                 *p_time,
 U8                 *p_delta,
 U8                 *p_count
 )
{
	U8  delta[RRM_EIGHT] = {RRM_ZERO};
	U8  time = RRM_ZERO;
	U8  count_for_delta_sfc = RRM_ZERO;
	/** This fuction allows to get the set of value for SRS ON for OFF in which 
	  subframe number which is as per 3GPP spec 36.211 section 5.3.2 */
	RRM_UT_TRACE_ENTER();

	switch(subframe_config)
	{
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC0 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			*p_count = RRM_ONE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC1 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			*p_count = RRM_TWO;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC2 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_THREE;
			*p_count = RRM_TWO;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC3 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_FOUR;
			*p_count = RRM_TWO;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC4 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			delta[RRM_TWO] = RRM_THREE;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC5 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			delta[RRM_TWO] = RRM_FOUR;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC6 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_THREE;
			delta[RRM_TWO] = RRM_FOUR;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC7 :
			time = RRM_FIVE;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			delta[RRM_TWO] = RRM_THREE;
			delta[RRM_THREE] = RRM_FOUR;
			*p_count = RRM_FOUR;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC8 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			delta[RRM_TWO] = RRM_SIX;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC9 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_THREE;
			delta[RRM_TWO] = RRM_SIX;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC10 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_SIX;
			delta[RRM_TWO] = RRM_SEVEN;
			*p_count = RRM_THREE;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC11 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_TWO;
			delta[RRM_TWO] = RRM_SIX;
			delta[RRM_THREE] = RRM_EIGHT;
			*p_count = RRM_FOUR;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC12 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_THREE;
			delta[RRM_TWO] = RRM_SIX;
			delta[RRM_THREE] = RRM_NINE;
			*p_count = RRM_FOUR;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC13 :
			time = RRM_TEN;
			delta[RRM_ZERO] = RRM_ONE;
			delta[RRM_ONE] = RRM_FOUR;
			delta[RRM_TWO] = RRM_SIX;
			delta[RRM_THREE] = RRM_SEVEN;
			*p_count = RRM_FOUR;
			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC14 :
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC15 :
			break;
		default :
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Value chosen for SRS configuration is wrong (%d)",subframe_config);
	}
	*p_time = time;
	for ( count_for_delta_sfc = RRM_ZERO; count_for_delta_sfc < *p_count; count_for_delta_sfc++ )
	{
		p_delta[count_for_delta_sfc] = delta[count_for_delta_sfc];
	}
	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : get_valid_srs_periodicity_for_tdd 
 * Inputs         : srs_periodicity,tdd_subfrm_config,srs_subframe_config
 * Outputs        : p_new_srs_periodicity_tdd
 * Returns        : None
 * Description    : This function checks the validity of the input periodicty
 *                  and if it is not vlaid , assigns the new periodicity in
 *                  in p_new_srs_periodicity_tdd
 ****************************************************************************/
rrm_void_t
get_valid_srs_periodicity_for_tdd
(
 U16 srs_periodicity,
 U8 tdd_subfrm_config,
 U8 srs_subframe_config,
 U16 *p_new_srs_periodicity_tdd,
 U16 *p_srs_start_index,
 U16 *p_srs_offset

 )
{
	RRM_UT_TRACE_ENTER();

	if((srs_subframe_config <= RRM_OAM_SRS_SUBFRAME_CONFIG_SC7)  &&
			(srs_periodicity < SRS_PERIODICITY_5MS))

	{
		*p_new_srs_periodicity_tdd =  SRS_PERIODICITY_5MS;
		*p_srs_start_index = SRS_START_INDEX_FOR_5_MS_TDD;
		*p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_5_MS_TDD;
	}

	else if(((srs_subframe_config >= RRM_OAM_SRS_SUBFRAME_CONFIG_SC8) && 
				(srs_subframe_config <= RRM_OAM_SRS_SUBFRAME_CONFIG_SC13)) &&
			(srs_periodicity < SRS_PERIODICITY_10MS)  
	       )
	{
		*p_new_srs_periodicity_tdd =  SRS_PERIODICITY_10MS;
		*p_srs_start_index = SRS_START_INDEX_FOR_10_MS_TDD;
		*p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_10_MS_TDD;
	}
	else
	{
		*p_new_srs_periodicity_tdd =  srs_periodicity;

	}

	if(((RRM_OAM_SA3 == tdd_subfrm_config) ||
				(RRM_OAM_SA4 == tdd_subfrm_config) || 
				(RRM_OAM_SA5 == tdd_subfrm_config )) &&
			((*p_new_srs_periodicity_tdd) < SRS_PERIODICITY_10MS)
	  )
	{
		*p_new_srs_periodicity_tdd = SRS_PERIODICITY_10MS;
		*p_srs_start_index = SRS_START_INDEX_FOR_10_MS_TDD;
		*p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_10_MS_TDD;
	}
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : find_srs_periodicity_from_cell_context
 * Inputs         : max_num_ue, p_srs_periodicity, p_srs_start_index
 * Outputs        : p_srs_periodicity, p_srs_start_index
 * Returns        : void
 * Description    : checks the maximum number of UE and and finds out the 
 *                  srs periodicity and srs start index.
 ****************************************************************************/
rrm_void_t
find_srs_periodicity_from_cell_context
(
 rrm_cell_context_t  *p_cell_context,
 U16                 *p_srs_start_index,
 U16                 *p_srs_offset,
 U16                 *p_srs_periodicity_in_ms
 )
{
	RRM_UT_TRACE_ENTER();

	switch(p_cell_context->operator_info.admission_control_info.srs_periodicity)
    {
            case SRS_PERIODICITY_0:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_2_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_2_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_2MS;
                    break;
                }

            case SRS_PERIODICITY_1:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_5_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_5_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_5MS;
                    break;
                }

            case SRS_PERIODICITY_2:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_10_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_10_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_10MS;
                    break;
                }

            case SRS_PERIODICITY_3:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_20_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_20_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_20MS;
                    break;
                }
            
            case SRS_PERIODICITY_4:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_40_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_40_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_40MS;
                    break;
                }
            
            case SRS_PERIODICITY_5:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_80_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_80_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_80MS;
                    break;
                }
            
            case SRS_PERIODICITY_6:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_160_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_160_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_160MS;
                    break;
                }
            
            case SRS_PERIODICITY_7:
                {
                    *p_srs_start_index = SRS_START_INDEX_FOR_320_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_320_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_320MS;
                    break;
                }
            default:
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Invalid Value (%d) is configured from CFG for SRS Periodicity"
                            "So chosing SRS periodicity as 5",
                            p_cell_context->operator_info.admission_control_info.srs_periodicity);
                    *p_srs_start_index = SRS_START_INDEX_FOR_80_MS_TDD;
                    *p_srs_offset = SRS_OFFSET_CALCULATION_VAL_FOR_80_MS_TDD;
                    *p_srs_periodicity_in_ms = SRS_PERIODICITY_80MS;
                    p_cell_context->operator_info.admission_control_info.srs_periodicity = SRS_PERIODICITY_5;
                }
    }

    /* SPR Fix 12193 start */
	RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
			"Value chosen for SRS Periodicity is %d", *p_srs_periodicity_in_ms);
    /* SPR Fix 12193 end */

	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : check_sf_is_valid_for_srs_subframe_config 
 * Inputs         : srs_sf_offset , srs_subframe_config
 * Outputs        : None 
 * Returns        : RRM_TRUE : If the SRS offset is valid for SRS SF config. 
 *                  RRM_FALSE : If the SRS offset is not valid for SRS SF config.
 * Description    : This function checks that whether the given srs offset is a
 *                  subset of the srs offsets valid for the SRS configuration.
 *                  If it is a subset , it is valid else it is not.
 ****************************************************************************/
rrm_bool_t
check_sf_is_valid_for_srs_subframe_config 
(
 S8 srs_sf_offset, 
 U8 srs_subframe_config
 )
{
//	RRM_UT_TRACE_ENTER();
	U8 num_of_sf_offsets = RRM_ZERO;
	rrm_bool_t ret_val = RRM_FALSE; 
	U8 count = RRM_ZERO;
	U8 t_sfc = RRM_ZERO;


	if (srs_subframe_config < RRM_EIGHT)
	{
		t_sfc = RRM_FIVE;
	}
	else
	{
		t_sfc = RRM_TEN;
	}

	srs_sf_offset = srs_sf_offset % t_sfc;
	switch(srs_subframe_config)
	{

		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC0: 
			num_of_sf_offsets = RRM_ONE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC1: 
			num_of_sf_offsets = RRM_TWO;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC2: 
			num_of_sf_offsets = RRM_TWO;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC3: 
			num_of_sf_offsets = RRM_TWO;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC4: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC5: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC6: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC7: 
			num_of_sf_offsets = RRM_FOUR;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC8: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC9: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC10: 
			num_of_sf_offsets = RRM_THREE;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC11: 
			num_of_sf_offsets = RRM_FOUR;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC12: 
			num_of_sf_offsets = RRM_FOUR;

			break;
		case RRM_OAM_SRS_SUBFRAME_CONFIG_SC13: 
			num_of_sf_offsets = RRM_FOUR;

			break;
		default:
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
					"Invalid[%d] SRS SF configuration", srs_subframe_config); 

	}

	for(count = RRM_ZERO ; count < num_of_sf_offsets ; count ++)
	{
		if(valid_sf_offset_for_srs_config[srs_subframe_config][count] == srs_sf_offset)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"SRS SF offset[%d] is valid for SRS SF configuration [%d]",srs_sf_offset,srs_subframe_config); 
			ret_val = RRM_TRUE;      
			break; 
		}
	}

//	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : get_sf_frm_k_srs_for_uppts_symbol_length_one 
 * Inputs         : k_srs
 * Outputs        : srs_offset
 * Returns        : None
 * Description    : This function finds the subframe number corresponding
 *                  to given k_srs if the SRS symbol length is 1.
 ****************************************************************************/
rrm_void_t
get_sf_frm_k_srs_for_uppts_symbol_length_one
(
 U8 k_srs,
 S8 *srs_offset
 )
{
//	RRM_UT_TRACE_ENTER();
	if((k_srs == RRM_ZERO) ||(k_srs == RRM_FIVE))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"SRS SF offset 0 and 5 are not valid for SRS with ONE symbol length"); 
		*srs_offset = RRM_INDEX_ERR;

	}
	else
	{
		*srs_offset = k_srs;
	}

//	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : get_sf_frm_k_srs_for_uppts_symbol_length_two 
 * Inputs         : k_srs
 * Outputs        : srs_offset
 * Returns        : None
 * Description    : This function finds the subframe number corresponding
 *                  to given k_srs if the SRS symbol length is 2.
 ****************************************************************************/
rrm_void_t
get_sf_frm_k_srs_for_uppts_symbol_length_two
(
 U8 k_srs,
 S8 *srs_offset
 )
{
//	RRM_UT_TRACE_ENTER();
	//    U8 k_val_srs = k_val_for_srs % 10;
	if((k_srs == RRM_ZERO) ||(k_srs == RRM_ONE))
	{
		*srs_offset = RRM_ONE;

	}
	else if ((k_srs == RRM_FIVE) ||(k_srs == RRM_SIX))
	{
		*srs_offset = RRM_SIX;
	}
	else
	{
		*srs_offset = k_srs;
	}

	//RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : sf_is_spcl_for_tdd_config 
 * Inputs         : tdd_sbfrm_config , srs_sf_offset
 * Outputs        : None 
 * Returns        : RRM_TRUE : If the SRS offset is Special SF . 
 *                  RRM_FALSE : If the SRS offset is not special SF
 * Description    : This function checks whether the SRS offsets is SPCL
 *                  or not as per the provided TDD configurations 
 ****************************************************************************/
rrm_bool_t
sf_is_spcl_for_tdd_config
(
 U8 tdd_sbfrm_config,
 S8 srs_sf_offset
 ) 
{
	rrm_bool_t ret_val = RRM_FALSE;
	if(srs_sf_offset == RRM_ONE)
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"TDD_DEBUG :srs_sf [%d] is special for all TDD configurations ",
				srs_sf_offset);
		ret_val = RRM_TRUE;
	}
	else if( (srs_sf_offset == RRM_SIX) &&
			((tdd_sbfrm_config == RRM_OAM_SA0) || (tdd_sbfrm_config == RRM_OAM_SA1) ||
			 (tdd_sbfrm_config == RRM_OAM_SA2) ||(tdd_sbfrm_config == RRM_OAM_SA6)))

	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"TDD_DEBUG :srs_sf [%d] is special for TDD config[%d]  ",srs_sf_offset,tdd_sbfrm_config );
		ret_val = RRM_TRUE;
	}
	else
	{
		ret_val = RRM_FALSE;
	}

	return ret_val;

}  
/****************************************************************************
 * Function Name  : rrm_check_subfrm_offset_is_valid_for_srs_tx 
 * Inputs         : spcl_sf_valid_for_srs , k_srs ,srs_periodicity_in_ms
 *                  tdd_spcl_sf_pattern, tdd_sbfrm_config, srs_subframe_config 
 * Outputs        : None 
 * Returns        : RRM_TRUE : If the SRS offset is valid . 
 *                  RRM_FALSE : If the SRS offset  is valid.
 * Description    : This function checks the validity of the SRS offsets as per the
 *                  provided TDD and SRS configurations for the SRS periodicity 
 *                  greater than 2ms.
 ****************************************************************************/
rrm_bool_t
rrm_check_subfrm_offset_is_valid_for_srs_tx
(
 U8 tdd_sbfrm_config ,
 U8 tdd_spcl_sf_pattern,
 U8 k_srs,
 U8 srs_subframe_config ,
 rrm_bool_t spcl_sf_valid_for_srs,
 U16 srs_periodicity_in_ms
 )
{
//	RRM_UT_TRACE_ENTER();
	S8 srs_sf_offset = RRM_NULL; 
	rrm_bool_t ret_val = RRM_TRUE;

	k_srs = k_srs % RRM_TEN;
	/*
	 ** Get the subframe number from the k_srs value as per the
	 ** spec 36.213 , table 8.2-3
	 */
	if(tdd_spcl_sf_pattern <= RRM_OAM_SSP4)
	{
		get_sf_frm_k_srs_for_uppts_symbol_length_one(k_srs ,&srs_sf_offset);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"For 1 symbol :SRS SF offset [%d] for  k_srs [%d] ",srs_sf_offset,k_srs); 
	}
	else
	{
		get_sf_frm_k_srs_for_uppts_symbol_length_two( k_srs ,&srs_sf_offset);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"For 2 symbol :SRS SF offset [%d] for  k_srs [%d] ",srs_sf_offset,k_srs); 
	} 

	/*
	 ** k_srs has no mapping with the Suframe.  
	 */
	if(srs_sf_offset == RRM_INDEX_ERR )
	{
		ret_val = RRM_FALSE;
	}   

	if(!spcl_sf_valid_for_srs && (sf_is_spcl_for_tdd_config(tdd_sbfrm_config,srs_sf_offset))) 
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
				"SPECIAL SF 1 and 5 are not valid for SRS as srs_max_uppts is FALSE"); 
		ret_val = RRM_FALSE;
	}


	if(ret_val)
	{
		if(tdd_config_subfrm_pattern[tdd_sbfrm_config][srs_sf_offset] !=  DL_SF )
		{
			if(srs_periodicity_in_ms < SRS_PERIODICITY_10MS )
			{
				if(tdd_config_subfrm_pattern[tdd_sbfrm_config][srs_sf_offset+srs_periodicity_in_ms] != DL_SF )
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
							"SRS SF offset[%d] is valid for TDD UL/DL configuration [%d]",srs_sf_offset,tdd_sbfrm_config); 
					ret_val = check_sf_is_valid_for_srs_subframe_config (srs_sf_offset, srs_subframe_config);
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"SRS SF offset[%d] is not valid for TDD UL/DL configuration [%d]",srs_sf_offset,tdd_sbfrm_config); 
					ret_val = RRM_FALSE;
				}
			}
			else
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"SRS SF offset[%d] is valid for TDD UL/DL configuration [%d]",srs_sf_offset,tdd_sbfrm_config); 
				ret_val = check_sf_is_valid_for_srs_subframe_config (srs_sf_offset, srs_subframe_config);
			}
		}
		else
		{
			ret_val = RRM_FALSE;
		}
	}

	//RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : check_sf_is_valid_for_2ms 
 * Inputs         : sf_num, spcl_sf_valid_for_srs
 *                  tdd_spcl_sf_pattern, tdd_sbfrm_config, srs_subframe_config 
 * Outputs        : None 
 * Returns        : RRM_TRUE : If the SRS offset is valid. 
 *                  RRM_FALSE : If the SRS offset  is valid.
 * Description    : This function checks the validity of the SRS offsets as per the
 *                  provided TDD and SRS configurations 
 ****************************************************************************/
rrm_bool_t
check_sf_is_valid_for_2ms
(
 U8 k_srs,
 rrm_bool_t spcl_sf_valid_for_srs,
 U8 tdd_sbfrm_config,
 U8 tdd_spcl_sf_pattern,
 U8 srs_subframe_config
 )
{
	RRM_UT_TRACE_ENTER();
	rrm_bool_t ret_val = RRM_TRUE;
	S8 srs_sf_offset = RRM_NULL;  

	/*
	 ** Get the subframe number from the k_srs value as per the
	 ** spec 36.213 , table 8.2-3
	 */
	if(tdd_spcl_sf_pattern <= RRM_OAM_SSP4)
	{
		get_sf_frm_k_srs_for_uppts_symbol_length_one(k_srs ,&srs_sf_offset);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"For 1 symbol :SRS SF offset [%d] for  k_srs [%d] ",srs_sf_offset,k_srs); 
	}
	else
	{
		get_sf_frm_k_srs_for_uppts_symbol_length_two( k_srs ,&srs_sf_offset);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"For 2 symbol :SRS SF offset [%d] for  k_srs [%d] ",srs_sf_offset,k_srs); 
	} 

	/*
	 ** k_srs has no mapping with the Suframe.  
	 */
	if(srs_sf_offset == RRM_INDEX_ERR )
	{
		ret_val = RRM_FALSE;
	}   

	/*
	 ** Special SF(1) is not valid if the usage of Special SF's 
	 ** is not allowed.
	 */
	if(!spcl_sf_valid_for_srs &&(srs_sf_offset == RRM_SUCCESS))
	{
		ret_val = RRM_FALSE ;
	}
	if(ret_val)
	{
		/*
		 ** SF is not an Uplink/SPCL subframe , or it is uplink/SPCL but next SF
		 ** allocated for SRS as per the periodicity is not an uplink/spcl SF.
		 */
		if(((tdd_config_subfrm_pattern[tdd_sbfrm_config][srs_sf_offset]) == DL_SF ) ||
				((tdd_config_subfrm_pattern[tdd_sbfrm_config][srs_sf_offset + RRM_FIVE]) == DL_SF)) 
		{
			ret_val = RRM_FALSE ;
		}
		if( ret_val)
		{
			/*
			 ** Check that the srs_offset is a subset of the offsets valid for the 
			 ** SRS SF configuration.
			 */
			ret_val =  check_sf_is_valid_for_srs_subframe_config (srs_sf_offset, srs_subframe_config);
		}
	}

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_check_valid_srs_index_for_2ms 
 * Inputs         : srs_index, spcl_sf_valid_for_srs
 *                  tdd_spcl_sf_pattern, tdd_sbfrm_config, srs_subframe_config 
 * Outputs        : None 
 * Returns        : RRM_TRUE : If the SRS config index is valid for 2ms periodicty
 *                  RRM_FALSE : If the SRS config index is valid for 2ms periodicty
 * Description    : This function checks the validity of the SRS offsets as per the
 *                  provided TDD and SRS configurations and marks that SRS config 
 *                  index as valid , for which SRS offsets are valid.
 ****************************************************************************/
rrm_bool_t
rrm_check_valid_srs_index_for_2ms
(
 rrm_bool_t spcl_sf_valid_for_srs,
 U8 tdd_spcl_sf_pattern,
 U8 srs_subframe_config,
 U8 tdd_sbfrm_config,
 U16  srs_index
 )
{
	RRM_UT_TRACE_ENTER();
	U8 srs_offset = RRM_ZERO;
	U8 k_srs = RRM_NULL;
	rrm_bool_t ret_val = RRM_TRUE;
	for (srs_offset = RRM_ZERO; srs_offset < MAX_SRS_OFFSETS_FOR_2MS ; srs_offset++ )
	{
		/* get the srs offset for the given srs config index */
		k_srs = valid_offsets_for_2ms_srs_periodicity[srs_index][srs_offset];
		if(RRM_FALSE == 
				check_sf_is_valid_for_2ms(k_srs, spcl_sf_valid_for_srs, tdd_sbfrm_config,
					tdd_spcl_sf_pattern , srs_subframe_config ))
		{
			ret_val = RRM_FALSE;
			break;
		}   
	}
    /* Coverity 48351 fix start */
    RRM_UT_TRACE_EXIT();
    /* Coverity 48351 fix end */
    return ret_val;
}

/****************************************************************************
 * Function Name  : prepare_srs_index_list
 * Inputs         : srs_start_index, srs_periodicity_in_ms , spcl_sf_valid_for_srs
 *                  tdd_spcl_sf_pattern, tdd_sbfrm_config, srs_subframe_config 
 * Outputs        : p_srs_index_list_as_per_periodicity , p_srs_index_count 
 * Returns        : None
 * Description    : Populates the p_srs_index_list_as_per_periodicity list with
 *                  valid SRS indexes.
 ****************************************************************************/
rrm_void_t
prepare_srs_index_list
(
 U16 srs_start_index,
 U16 srs_periodicity_in_ms,
 rrm_bool_t spcl_sf_valid_for_srs,
 U8 tdd_spcl_sf_pattern,
 U8 tdd_sbfrm_config,
 U8 srs_subframe_config,
 U16 *p_srs_index_list_as_per_periodicity,
 U16 *p_srs_index_count
 )
{
	RRM_UT_TRACE_ENTER();
	U16 srs_index_val = RRM_ZERO;
	U8 k_srs = RRM_ZERO;
	U16 srs_idx_count = RRM_ZERO;

	//DEBUG
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
			"TDD_DEBUG SRS_START_ID [%d] , SRS_PERIODICITY[%d] , SRS_UPPTS [%d]"
			"TDD_SPCL_PATTERN [%d] , TDD_SF_CONFIG[%d] , SRS_SF_CONFIG[%d]" ,
			srs_start_index, srs_periodicity_in_ms, spcl_sf_valid_for_srs , tdd_spcl_sf_pattern,
			tdd_sbfrm_config, srs_subframe_config);
	//DEBUG

	/*
	 ** Validation for the SRS configuration indexes is done
	 ** as per the specs 36.211 and 36.213.
	 ** For 2ms periodicty , there are 10 srs config indexes avalable.
	 ** For all other periodicities , a range of srs config indexes is
	 ** avaialble and range is same as the periodicity.
	 */
	if(srs_periodicity_in_ms == SRS_PERIODICITY_2MS)
	{
		for(srs_index_val = RRM_ZERO ; srs_index_val < RRM_TEN ; srs_index_val++)
		{
			if(RRM_TRUE == rrm_check_valid_srs_index_for_2ms(spcl_sf_valid_for_srs,tdd_spcl_sf_pattern,
						srs_subframe_config , tdd_sbfrm_config ,
						srs_index_val))
			{                                     
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"SRS index[%d] is Valid for SRS tx",srs_index_val);
				p_srs_index_list_as_per_periodicity[srs_idx_count++] = srs_index_val;
			}
		}
	}
	else /*for all other periodicities validation is different from the 2ms periodicity*/
	{
		for(srs_index_val = srs_start_index ; srs_index_val < (srs_start_index + srs_periodicity_in_ms) ;srs_index_val++)
		{
			k_srs = srs_index_val - srs_start_index;

			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"TDD_DEBUG :k_srs is [%d] ",k_srs);

			if( RRM_TRUE == rrm_check_subfrm_offset_is_valid_for_srs_tx(tdd_sbfrm_config ,tdd_spcl_sf_pattern,
						k_srs,
						srs_subframe_config ,spcl_sf_valid_for_srs,
						srs_periodicity_in_ms) )
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"SRS index[%d] is Valid for SRS tx",srs_index_val);

				p_srs_index_list_as_per_periodicity[srs_idx_count++] = srs_index_val;    
			}
			else
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"SRS index[%d] is NOT  Valid for SRS tx",srs_index_val);

			}

		}
	}

	*p_srs_index_count = srs_idx_count;
  /*gur26516fix*/
  RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
						"Total SRS indexes are :[%d]",*p_srs_index_count);
  int temp_count;
  for(temp_count = RRM_ZERO ; temp_count < srs_idx_count ; temp_count++)
  {
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"SRS index[%d] is [%d]",
          temp_count ,p_srs_index_list_as_per_periodicity[temp_count]);
  }

	RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_cellm_cell_initialize_srs_res_list
 * Inputs         : rrm_cell_context_t *p_cell_context Cell Context
 * Outputs        : None
 * Returns        : None
 * Description    : Initializes the SRS resource list
 ****************************************************************************/
rrm_void_t
rrm_cellm_cell_initialize_srs_res_list
(
 rrm_cell_context_t *p_cell_context
 )
{
    U16 srs_start_index = RRM_ZERO;
    U16 srs_offset = RRM_ZERO;
    U16 srs_periodicity_in_ms = RRM_ZERO;
    U16 res_anchor = RRM_ZERO;
    U8  srs_subframe_config = RRM_ZERO;
    U8  tdd_sbfrm_config = RRM_ZERO;
    U16 new_srs_periodicity_in_ms = RRM_ZERO;
    rrm_bool_t spcl_sf_valid_for_srs = RRM_FALSE;
    U8 tdd_spcl_sf_pattern = RRM_NULL;
    U16 srs_index_list_as_per_periodicity[SRS_INDEX_ARRAY_SIZE] = {RRM_ZERO};
    U16 max_srs_index_count = RRM_ZERO;
    /* TDD_SRS_FREQ_HOPPING_START */
    U16 wb_srs_max_index   = RRM_ZERO;
    U16 srs_subframes_max_count = RRM_ZERO;
    /*cov fix start 29663 */
    rrm_oam_band_width_et  channel_bandwidth = RRM_OAM_BW_N_6;
    /*cov fix end 29663 */
    U8 n_rrc_max_count = RRM_ZERO;
    U8  subframe_bw_config = RRM_ZERO;
    /* TDD_SRS_FREQ_HOPPING_END */
    /* SPR_8391_CHANGES_START*/
    U8  wb_srs_bw_for_ce = RRM_ZERO;
    U8  wb_hopping_bw_for_ce = RRM_ZERO;
    U8  n_rrc_min_index = RRM_ZERO;
    rrm_frequency_selective_sched_et ul_freq_selective_sched = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE; 
    rrm_icic_scheme_type_et         icic_scheme = ICIC_SCHEME_NONE; 
    operator_info_t            *p_operator_info = RRM_PNULL;
    /*SPR 8019 FIX START2*/
    U8  n_rb_hopping_bw = RRM_ZERO;
    /*SPR 8019 FIX END2*/

    rrm_bool_et hopping_enable = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    p_operator_info = &(p_cell_context->operator_info);
    RRM_ASSERT(RRM_PNULL != p_operator_info);

    /* SPR 8019 FIX START */
    ul_freq_selective_sched = p_operator_info->rrm_mac_config.
        enable_frequency_selective_scheduling.ul_freq_selective_enable;
    /* SPR 8019 FIX END */
    if((RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & p_operator_info->bitmask) && 
            (RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT & p_operator_info->dynamic_icic_info.bitmask))
    {
        icic_scheme = p_operator_info->dynamic_icic_info.icic_scheme_type;
    }

    if(RRM_ONE == p_cell_context->ran_info.physical_layer_params.physical_layer_param_srs.srs_hopping_enable)
    {
        hopping_enable = RRM_TRUE;
    }

    /* SPR_8391_CHANGES_END*/

    srs_subframe_config = p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_srs.srs_subframe_config;

    /* TDD_SRS_FREQ_HOPPING_START */
    subframe_bw_config = p_cell_context->ran_info.physical_layer_params.
        physical_layer_param_srs.srs_bandwidth_config;
    channel_bandwidth = p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth;
    /*Initializing the values for UE specific SRS parmaters */
    /*SPR 21223 START*/
    if(RRM_SUCCESS == rrm_initialize_srs_parameters_for_ue(p_cell_context))
    {	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Values for UE specific SRS parmaters Intialized Successfully");
    }
    /*SPR 21223 END*/ 
    /* TDD_SRS_FREQ_HOPPING_END */

    /*
     ** This parameter decides whether we can use Special SF for SRS or not
     */

    /* SPR 12102 Fix Start */
    if(( RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT & 
                p_cell_context->ran_info.physical_layer_params.physical_layer_param_srs.bitmask)
            &&
            (RRM_FALSE ==  check_if_spcl_sf_reserved_for_rach(p_cell_context->ran_info.
                                                              physical_layer_params.
                                                              physical_layer_param_prach.configuration_index)))
    {
        spcl_sf_valid_for_srs = RRM_TRUE;
    }
    else
    { 
        spcl_sf_valid_for_srs = RRM_FALSE;
    }
    /* SPR 12102 Fix End */

    if(p_cell_context->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT)
    {
        tdd_sbfrm_config = p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.sub_frame_assignment;
        tdd_spcl_sf_pattern = p_cell_context->ran_info.physical_layer_params.
            physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;
    }

    /** Find SRS periodicity and from cell context */
    find_srs_periodicity_from_cell_context(p_cell_context,
            &srs_start_index,
            &srs_offset,
            &srs_periodicity_in_ms);

    /*
     ** Check for the validity of the periodicity calculated above.
     ** It the periodicty is valid , this function keeps new_srs_periodicity_in_ms
     ** same as srs_periodicity_in_ms
     */
    get_valid_srs_periodicity_for_tdd(srs_periodicity_in_ms,tdd_sbfrm_config,
            srs_subframe_config,&new_srs_periodicity_in_ms,
            &srs_start_index,&srs_offset);

    /* 
     ** Assisgn the new valid periodicty to the srs_periodicity_in_ms 
     ** for further use.
     */
    srs_periodicity_in_ms = new_srs_periodicity_in_ms;                                            
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Valid SRS Periodicity is %d", srs_periodicity_in_ms);
    /*
     ** Populate the srs_index_list_as_per_periodicity list with the valid 
     ** SRS indexes . Validation is done on the basis of the following
     ** parameters:
     ** - srs_maxuppts
     ** - tdd_subframe_assignmnt
     ** - tdd_special_sub_frame_patterns
     ** - srs_subframe_pattern
     ** - srs_periodicity
     */
        prepare_srs_index_list(srs_start_index,srs_periodicity_in_ms,spcl_sf_valid_for_srs,
                tdd_spcl_sf_pattern,tdd_sbfrm_config,srs_subframe_config,
                srs_index_list_as_per_periodicity,&max_srs_index_count);

    /* TDD_SRS_FREQ_HOPPING_START */
    srs_subframes_max_count =  max_srs_index_count;
    /* SPR 8019 FIX START */
    /* SPR_8391_CHANGES_START */
    /*SPR 21090 START*/
    if(( RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE == ul_freq_selective_sched)||((
                    RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE==ul_freq_selective_sched)&&
                ((ICIC_SCHEME_HFR == icic_scheme)||(ICIC_SCHEME_NONE == icic_scheme)))) 
        /*SPR 21090 END*/
    {
        /*SPR 21223 START*/
        populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_index_list_as_per_periodicity,srs_subframes_max_count,
                &res_anchor,SRS_BW0,SRS_BW0,RRM_TRUE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
        /*SPR 21223 END*/

        p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
        p_cell_context->allocated_srs_max_anchor_val = res_anchor;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Wideband SRS resourcs- [%d] ,wideband srs indexes: [%d] - [%d], Switch_point: [%d]",
                p_cell_context->allocated_srs_max_anchor_val,
                srs_index_list_as_per_periodicity[0],srs_index_list_as_per_periodicity[srs_subframes_max_count -1],
                p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
    }
    else
    {
        if (ICIC_SCHEME_NONE != icic_scheme)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "ICIC Scheme[%d] is configured from OAM. Allocating Sub band as per CE/CC Partition",icic_scheme);
            if((p_cell_context->operator_info.dynamic_icic_info.bitmask & RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT) &&
                    (p_cell_context->operator_info.dynamic_icic_info.ul_resource_partition_info.num_of_cell_edge_region != RRM_ZERO))
            {
                /*SPR 21223 START*/
                /*code deleted*/
                populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_index_list_as_per_periodicity,srs_subframes_max_count,
                        &res_anchor,SRS_BW0,SRS_BW0,RRM_FALSE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
                /*SPR 21223 END*/

                p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
                get_sub_band_data_sets_for_icic(channel_bandwidth,
                        hopping_enable,
                        subframe_bw_config,
                        &(p_cell_context->operator_info.dynamic_icic_info),
                        &wb_srs_bw_for_ce,
                        &wb_hopping_bw_for_ce,
                        &n_rrc_min_index);

                get_the_n_rrc_index_max_limit(channel_bandwidth, subframe_bw_config, 
                        wb_srs_bw_for_ce, wb_hopping_bw_for_ce, &n_rrc_max_count, &n_rb_hopping_bw);

                /*SPR 21223 START*/
                populate_subband_srs_res_list(p_cell_context->srs_table.p_subband_srs_table, srs_index_list_as_per_periodicity,
                        wb_srs_max_index, srs_subframes_max_count,
                        n_rrc_min_index, n_rrc_max_count, 
                        n_rb_hopping_bw, &res_anchor,
                        wb_hopping_bw_for_ce, wb_srs_bw_for_ce,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
                /*SPR 21223 END*/

                p_cell_context->allocated_srs_max_anchor_val = res_anchor;

                /* SPR 8019 FIX START */
                /* CID 120612 Fix Start */
                if(RRM_ZERO != wb_srs_max_index)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Wideband SRS resourcs- [%d] ,wideband srs indexes: [%d] - [%d],"
                            "Subband SRS resources- [%d] ,subband srs indexes: [%d] - [%d]." , 
                            (p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs-1),
                            srs_index_list_as_per_periodicity[0],srs_index_list_as_per_periodicity[wb_srs_max_index-1],
                            (p_cell_context->allocated_srs_max_anchor_val -
                             p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs + 1),
                            srs_index_list_as_per_periodicity[wb_srs_max_index],srs_index_list_as_per_periodicity[srs_subframes_max_count-1]);
                }
                /* CID 120612 Fix End */
                /* SPR 8019 FIX END */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "CE Partition is absent")
                    /*SPR 8019 FIX START2*/
                    /*SPR 21223 START*/
                    populate_wideband_srs_res_list(p_cell_context->srs_table.p_wideband_srs_table,srs_index_list_as_per_periodicity,srs_subframes_max_count,
                            &res_anchor,SRS_BW0,SRS_BW0,RRM_TRUE,p_cell_context->operator_info.admission_control_info.max_num_ue_per_cell);
                /*SPR 21223 END*/
                /*SPR 8019 FIX END2*/

                p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs = res_anchor + 1;
                p_cell_context->allocated_srs_max_anchor_val = res_anchor;

                /*SPR 8019 FIX START2*/
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Wideband SRS resourcs- [%d] ,wideband srs indexes: [%d] - [%d], Switch_point: [%d]",
                        p_cell_context->allocated_srs_max_anchor_val,
                        srs_index_list_as_per_periodicity[0],srs_index_list_as_per_periodicity[srs_subframes_max_count -1],
                        p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);
                /*SPR 8019 FIX END2*/
            }
        }

        /*SPR 21090 START*/
        /*code deleted*/
        /*SPR 21090 END*/

        /* SPR_8315_PART2_FIX_START */
        /* SPR_8315_PART2_FIX_END */
    }
    /* SPR_8391_CHANGES_END*/
    /* SPR 8019 FIX END */

    /*RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
      "MAX Value of Res Anchor=[%d] , START_ANCHOR_FOR_SUBBAND = [%d]",
      p_cell_context->allocated_srs_max_anchor_val,p_cell_context->srs_table.res_anchor_for_switch_wideband_to_subband_srs);*/

                    //print_srs_resource_info(p_cell_context);

                    /* TDD_SRS_FREQ_HOPPING_END */

                    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Array Name     : tdd_config_dl_subframes
 * Inputs         : MAX_TDD_UL_DL_CONFIG ,SUBFRAMES_IN_ONE_FRAME
 * Outputs        : None
 * Returns        : None
 * Description    : UL/DL subframes pattern available in each TDD UL/DL 
 *                  configuration.
 ****************************************************************************/
U8 tdd_config_subfrm_pattern[MAX_TDD_UL_DL_CONFIG][SUBFRAMES_IN_ONE_FRAME] =
{
	{
		DL_SF, SPCL_SF, UL_SF, UL_SF, UL_SF,
		DL_SF, SPCL_SF, UL_SF, UL_SF, UL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, UL_SF, DL_SF,
		DL_SF, SPCL_SF, UL_SF, UL_SF, DL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, DL_SF, DL_SF,
		DL_SF, SPCL_SF, UL_SF, DL_SF, DL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, UL_SF, UL_SF,
		DL_SF, DL_SF, DL_SF, DL_SF, DL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, UL_SF, DL_SF,
		DL_SF, DL_SF, DL_SF, DL_SF, DL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, DL_SF, DL_SF,
		DL_SF, DL_SF, DL_SF, DL_SF, DL_SF
	},
	{
		DL_SF, SPCL_SF, UL_SF, UL_SF, UL_SF,
		DL_SF, SPCL_SF, UL_SF, UL_SF, DL_SF
	}
};


/****************************************************************************
 * Array Name     : valid_sf_offset_for_srs_config
 * Inputs         : MAX_SRS_SF_CONFIG , MAX_OFFSETS_IN_SRS_SF_CONFIG
 * Outputs        : None
 * Returns        : None
 * Description    : This array provides mapping between the srs offsets and 
 *                  SRS subframe configurations for TDD.
 ****************************************************************************/
U8 valid_sf_offset_for_srs_config [MAX_SRS_SF_CONFIG][MAX_OFFSETS_IN_SRS_SF_CONFIG]=
{
	DELTA_SFC_SF_0,
	DELTA_SFC_SF_1,
	DELTA_SFC_SF_2,
	DELTA_SFC_SF_3,
	DELTA_SFC_SF_4,
	DELTA_SFC_SF_5,
	DELTA_SFC_SF_6,
	DELTA_SFC_SF_7,
	DELTA_SFC_SF_8,
	DELTA_SFC_SF_9
	/*{1, 6, 7},
	{1, 2, 6, 8},
	{1, 3, 6, 9},
	{1, 4, 6, 7}*/
};

/****************************************************************************
 * Array Name     : valid_offsets_for_2ms_srs_periodicity
 * Inputs         : SUBFRAMES_IN_ONE_FRAME , MAX_SRS_OFFSETS_FOR_2MS
 * Outputs        : None
 * Returns        : None
 * Description    : This array provides mapping between the srs offsets and 
 *                  SRS configuration index (10 atmost) for SRS periodicity of 2 ms.
 ****************************************************************************/
U8 valid_offsets_for_2ms_srs_periodicity[SUBFRAMES_IN_ONE_FRAME][MAX_SRS_OFFSETS_FOR_2MS]=
{
	T_OFFSET_SF_0,
	T_OFFSET_SF_1,
	T_OFFSET_SF_2,
	T_OFFSET_SF_3,
	T_OFFSET_SF_4,
	T_OFFSET_SF_5,
	T_OFFSET_SF_6,
	T_OFFSET_SF_7,
	T_OFFSET_SF_8,
	T_OFFSET_SF_9
};
#endif

/* SPR14123start */
/****************************************************************************
 * Function Name  : rrm_uem_find_free_cqi_index_for_victim 
 * Inputs         : cqi_periodicity,cqi_config_index, abs_type, cell_index
 * Outputs        : None
 * Returns        : RRM_TRUE : Subframe offset for CQI and ABS frame is same 
 *                  RRM_FALSE: Subframe offset for CQI and ABS frmae is not same 
 * Description    : This function checks whether the subfram offsets allocated
 *                  for CQI is valid for ABS or Non-ABS or not.
 ****************************************************************************/
rrm_return_et
rrm_uem_find_free_cqi_index_for_victim(
		U16 cqi_config_index,
		U8  cqi_periodicity,
        rrm_cell_index_t cell_index,
#ifndef LTE_EMBMS_SUPPORTED
        rrm_abs_type_et    abs_type
#else
        rrm_abs_type_et    abs_type,
        U8                 check_for_embms 
#endif
		)
{

    U8              pattern_index = RRM_ZERO;
    U16             cqi_start_index = RRM_ZERO;
    U16             cqi_sub_frame_offset = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctxt = RRM_PNULL;
    U8              index_mask = 0x80;
    rrm_return_et   ret_val = RRM_SUCCESS;
    /*SPR 15663 start*/
    U8             new_meas_abs_pattern[RRM_MAX_PATTERN_BYTE];
    /*SPR 15663 end*/
    /*SPR 15050 fix start*/ 
    U8 offset_bit = RRM_ZERO;
#ifdef TDD_MODE_FLAG 
    U8 abs_size = RRM_ZERO;
#endif    
    RRM_UT_TRACE_ENTER();
    /*SPR 15663 start*/
    RRM_MEMSET(new_meas_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    /*SPR 15663 end*/ 
    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
    if( p_cell_ctxt == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "p_cell_ctxt is NULL for cell index: %d", cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
#ifndef TDD_MODE_FLAG 
     offset_bit = MAX_SUBFRAME_PATTERN_FDD * RRM_EIGHT;
#else
     abs_size = rrm_find_abs_frame_size(& p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
     switch(abs_size)
     {
        case RRM_MAX_ABS_PATTERN_BYTE_TDD_0 :
             offset_bit = RRM_SEVENTY;
             break;
        case RRM_MAX_ABS_PATTERN_BYTE_TDD_1_5 :
             offset_bit = RRM_TWENTY;
             break;
        case RRM_MAX_ABS_PATTERN_BYTE_TDD_6 :
             offset_bit = RRM_SIXTY;
             break;
        default :
             offset_bit = MAX_SUBFRAME_PATTERN_FDD * RRM_EIGHT;
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "TDD configuration has not been given by the operator");
     }    
#endif
     /*SPR 15050 fix end*/
    /*Klockwork_fix_start*/
    rrm_compare_sub_frame_offset_for_cqi(cqi_periodicity ,&cqi_start_index);
    /*Klockwork_fix_end*/
     /*SPR 15050 fix start*/
     /*code deleted*/
     /*SPR 15050 fix end*/

#ifndef TDD_MODE_FLAG 
    /*SPR 15663 start*/
    cqi_sub_frame_offset = cqi_config_index - cqi_start_index;
    /* SPR 21251 +- */
    cqi_sub_frame_offset = cqi_sub_frame_offset % offset_bit;
    pattern_index = cqi_sub_frame_offset / RRM_EIGHT;
    if((cqi_sub_frame_offset % RRM_EIGHT) < RRM_FOUR)
    {
        if(pattern_index >= RRM_ONE)
        {
            pattern_index = pattern_index - RRM_ONE;
            index_mask >>= (RRM_FOUR + (cqi_sub_frame_offset % RRM_EIGHT));
        }   
        else
        {
            pattern_index = RRM_FOUR - pattern_index;; 
            index_mask >>= (RRM_FOUR + (cqi_sub_frame_offset % RRM_EIGHT));
        }    
    }
    else
    {
        index_mask >>= ((cqi_sub_frame_offset % RRM_EIGHT)- RRM_FOUR);
    }    
    if(RRM_EICIC_ABS_PRESENT == abs_type)
    {
        if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied))
        {    
            if(RRM_ZERO == (index_mask & p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied[pattern_index]))
            {
                ret_val = RRM_FAILURE;
                /* SPR 21251 Start */
	            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			            "index_mask is not set");
                /* SPR 21251 End */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "RRM_EICIC_ABS_PRESENT, pattern_index(%d), index_mask(%d)", 
                        index_mask, pattern_index);

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "abs pattern in RRM_EICIC_ABS_PRESENT is :"); 
                rrm_print_abs_pattern(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied);
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    " usable_abs_pattern_applied is null"); 
        }    
    }
    else if (RRM_EICIC_ABS_NOT_PRESENT == abs_type)
    {
        /*SPR 15663 start*/
        if(p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR )
        {   
            if(RRM_SUCCESS == rrm_cellm_get_highest_load_abs(p_cell_ctxt,new_meas_abs_pattern))
            {    
                if(RRM_ONE == (index_mask & new_meas_abs_pattern[pattern_index]))
                {
                    ret_val = RRM_FAILURE;
                    /* SPR 21251 Start */
	                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			                "index_mask is set");
                    /* SPR 21251 End */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "RRM_EICIC_ABS_NOT_PRESENT for aggressor, pattern_index(%d), index_mask(%d)", 
                            index_mask, pattern_index);

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "abs_pattern at aggressor side not aligned with cqi_offset "); 
                    rrm_print_abs_pattern(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied);
                    RRM_UT_TRACE_EXIT();
                    return ret_val;
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "abs_pattern of highest load not present"); 
            }    

        }
        else if( p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
        {
            if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied))
            {    
                if(RRM_ONE == (index_mask & p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied[pattern_index]))   
                {
                    ret_val = RRM_FAILURE;
                    /* SPR 21251 Start */
	                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
			                "index_mask is set");
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "RRM_EICIC_ABS_NOT_PRESENT for victim, pattern_index(%d), index_mask(%d)", 
                            index_mask, pattern_index);
                    /* SPR 21251 End */
                    RRM_UT_TRACE_EXIT();
                    return ret_val;

                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        " usable_abs_pattern_applied is null"); 
            }    
        }
    }  
    /*SPR 15663 end*/
#endif
    cqi_sub_frame_offset = cqi_config_index - cqi_start_index;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "cqi_sub_frame_offset(%d), cqi_config_index(%d), cqi_start_index(%d)", 
            cqi_sub_frame_offset, cqi_config_index, cqi_start_index);

    cqi_sub_frame_offset = cqi_sub_frame_offset % offset_bit;
    /*SPR 15050 fix start*/
    pattern_index = cqi_sub_frame_offset / RRM_EIGHT;
    index_mask >>= (cqi_sub_frame_offset % RRM_EIGHT);
    /*SPR 15050 fix end*/
    if(RRM_EICIC_ABS_PRESENT == abs_type)
    {
        if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied))
        {    
        if(RRM_ZERO == (index_mask & p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied[pattern_index]))
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "RRM_EICIC_ABS_PRESENT, pattern_index(%d), index_mask(%d)", 
            index_mask, pattern_index);
            
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "abs pattern in RRM_EICIC_ABS_PRESENT is :"); 
            rrm_print_abs_pattern(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied);
        }
    }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    " usable_abs_pattern_applied is null"); 
        }    
    }
    else if (RRM_EICIC_ABS_NOT_PRESENT == abs_type)
    {
        /*SPR 15663 start*/
        if(p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR )
        {   
            if(RRM_SUCCESS == rrm_cellm_get_highest_load_abs(p_cell_ctxt,new_meas_abs_pattern))
            {    
                if(RRM_ONE == (index_mask & new_meas_abs_pattern[pattern_index]))
                {
                    ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "RRM_EICIC_ABS_NOT_PRESENT for aggressor, pattern_index(%d), index_mask(%d)", 
                            index_mask, pattern_index);

                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "abs_pattern at aggressor side not aligned with cqi_offset "); 
                    rrm_print_abs_pattern(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied);
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "abs_pattern of highest load not present"); 
            }   
        }
        else if( p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
        {
            if( RRM_FALSE == rrm_check_abs_pattern_is_null(p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied))
            {    
                if(RRM_ONE == (index_mask & p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied[pattern_index]))   
                {
                    ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "RRM_EICIC_ABS_NOT_PRESENT for victim, pattern_index(%d), index_mask(%d)", 
                            index_mask, pattern_index);
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "abs_pattern of highest load not present"); 
            }    
        }
        /*SPR 15663 end*/
    }

#ifdef LTE_EMBMS_SUPPORTED
    if( ( RRM_ONE == check_for_embms) && (RRM_SUCCESS == ret_val))
    {
        ret_val = rrm_uem_find_free_cqi_index_for_embms(cqi_config_index,cqi_periodicity, cell_index);
    }
#endif
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR14123end */
/* Code for MLB Start */
/****************************************************************************
 * Function Name  : rrm_cellm_start_ld_process_timer 
 * Inputs         : *p_cell_ctx
 * Outputs        : None
 * Returns        : Void
 * Description    : Start a periodic timer to process Cell load on expiry of
 *                  Timer.
 ****************************************************************************/
rrm_void_t
rrm_cellm_start_ld_process_timer 
(
    rrm_cell_context_t *p_cell_ctx
)
{
    /* coverity : CID 30998 */
    cell_timer_buf_t              timer_buf = {CELL_PERIODIC_TIMER_FOR_ANR,RRM_ZERO,RRM_ZERO,RRM_ZERO };

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    if (RRM_NULL != p_cell_ctx->cell_load_action.ld_process_timer)
    {
        /* Starting Cell Load processing timer */
        timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_LD_PROCESS;
        timer_buf.cell_index = p_cell_ctx->cell_index;
        /* BUG_11848_CHANGES_START */
        if (RRM_TRUE == p_cell_ctx->immediate_cell_start)
        {
        /* CID : 60716 fix start */
        p_cell_ctx->cell_load_action.ld_process_timer_id =
            cell_start_timer ( CELL_PERIODIC_TIMER_FOR_LD_PROCESS , (rrm_void_t *)&timer_buf,
                    sizeof (cell_timer_buf_t), p_cell_ctx);
        /* CID : 60716 fix end */
        if (RRM_PNULL == p_cell_ctx->cell_load_action.ld_process_timer_id)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Cell Load Process Timer failed to Start for Cell Index:%d", p_cell_ctx->cell_index);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Cell Load Process Timer Started for Cell Index:%d", p_cell_ctx->cell_index);
        }
    }
    else
    {
           p_cell_ctx->cell_load_action.ld_process_timer_id = RRM_PNULL;
        }
        /* BUG_11848_CHANGES_END */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Cell Load process timer val is ZERO Cell index:%d" ,p_cell_ctx->cell_index);
    }
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : rrm_get_rsu_srv_cell_trans_node
 * Inputs         : U16 transaction ID
 * Outputs        : None
 * Returns        : Pointer  to rrm_rsu_trans_info_node_t
 * Description    : Return the RSU Info Node corresponding to trans_id.
 ****************************************************************************/
rrm_rsu_trans_info_node_t *rrm_get_rsu_srv_cell_trans_node
(
 U16 trans_id
 )
{
	RRM_UT_TRACE_ENTER();
	YLNODE *p_node = RRM_PNULL;
	rrm_rsu_trans_info_node_t *p_rrm_rsu_trans_info = RRM_PNULL;
	p_node = ylFirst (&p_g_rrm_cell_ctx->rsu_trans_info_list);
	while (p_node)
	{ 
		p_rrm_rsu_trans_info = (rrm_rsu_trans_info_node_t *)p_node;
		if (trans_id == p_rrm_rsu_trans_info->trans_id)
		{
			return p_rrm_rsu_trans_info;
		}
		p_node = ylNext(p_node);
	}
	RRM_UT_TRACE_EXIT();
	return RRM_PNULL;
}


/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_rsu_enb_start_res_process_msg 
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rsu_enb_start_res message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_rsu_enb_start_res_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len, /* incoming data length*/
 U16     trans_id /* Incoming transaction Id*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_enb_start_res_t *p_x2ap_rrm_rsu_enb_start_res = RRM_PNULL;
    rrm_rsu_trans_info_node_t *p_rrm_rsu_trans_info = RRM_PNULL;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_rsu_meas_id_node_t  *p_meas_id_node = RRM_NULL;
    S32 length = RRM_NULL;
    rrm_rsu_meas_info_node_t *p_rsu_controlling_node = RRM_PNULL;
    /*Rel10 CR 393 changes start*/
    U16 cell_cnt = RRM_ZERO;
    U8 num_admitted_measurment_present = RRM_TRUE;
    /*Rel10 CR 393 changes end*/

    RRM_UT_TRACE_ENTER();
    p_x2ap_rrm_rsu_enb_start_res = (x2ap_rrm_rsu_enb_start_res_t *) \
                                   rrm_mem_get (sizeof (x2ap_rrm_rsu_enb_start_res_t));
    if ( p_x2ap_rrm_rsu_enb_start_res == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_rsu_enb_start_res failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    if (RRM_FAILURE == rrm_parse_x2ap_rrm_rsu_enb_start_res(
                p_x2ap_rrm_rsu_enb_start_res,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_START_RES unable to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_START_RES with response: %d", p_x2ap_rrm_rsu_enb_start_res->response);
        if (RRM_SUCCESS != p_x2ap_rrm_rsu_enb_start_res->response)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,\
                    "RSU enb response is failure with cause: (type:%d and value:%d)",\
                    p_x2ap_rrm_rsu_enb_start_res->rrm_cause.type,\
                    p_x2ap_rrm_rsu_enb_start_res->rrm_cause.value);
        }
        else /* Response == RRM_SUCCESS */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Recvd RSU enb start Resp");
            /*Rel10 CR 393 changes start*/
            if (ENB_START_PARTIAL_SUCCESS & p_x2ap_rrm_rsu_enb_start_res->bitmask)
            {
                for (cell_cnt = RRM_ZERO; cell_cnt < p_x2ap_rrm_rsu_enb_start_res->rrm_rsu_measurement_res_list.num_cell
                        ; cell_cnt++)
                {
                    if ((X2AP_RRM_FAILED_CAUSE_NUM_ITEM_PRESENT & p_x2ap_rrm_rsu_enb_start_res->
                                rrm_rsu_measurement_res_list.rsu_measurement_res_item[cell_cnt].bitmask) &&
                            (RRM_ZERO == p_x2ap_rrm_rsu_enb_start_res->rrm_rsu_measurement_res_list.
                             rsu_measurement_res_item[cell_cnt].num_measurement))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,\
                                "RSU enb response is partial success with cause: (type:%d and value:%d)\
                                and procedure is consider failed because no admitted measurement\
                                [num_measurment = %d]",p_x2ap_rrm_rsu_enb_start_res->rrm_cause.type,\
                                p_x2ap_rrm_rsu_enb_start_res->rrm_cause.value,\
                                p_x2ap_rrm_rsu_enb_start_res->rrm_rsu_measurement_res_list.\
                                rsu_measurement_res_item[cell_cnt].num_measurement);
                        num_admitted_measurment_present = RRM_FALSE;
                    }
                }
            }
            if (num_admitted_measurment_present)
            {
                /*Rel10 CR 393 changes end*/

                p_rrm_rsu_trans_info = rrm_get_rsu_srv_cell_trans_node (trans_id);
                RRM_ASSERT(RRM_PNULL != p_rrm_rsu_trans_info);

		/* Coverity 88369 Fix Start */
		if (RRM_PNULL == p_rrm_rsu_trans_info)
		{
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"p_rrm_rsu_trans_info is null");
            /* SPR 21251 End */
                    /* Coverity 77487 Fix Start */
                    RRM_MEM_FREE(p_x2ap_rrm_rsu_enb_start_res);
                    /* Coverity 77487 Fix End */
			RRM_UT_TRACE_EXIT();
			return RRM_FAILURE;
		}
		/* Coverity 88369 Fix End */
                SET_CELL_INDEX(p_rrm_rsu_trans_info->cell_index);
                if ((RRM_NULL != (p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rrm_rsu_trans_info->cell_index])) &&
                        (p_x2ap_rrm_rsu_enb_start_res->bitmask & ENB_MEAS_ID_IS_PRESENT))
                {
                    p_rsu_controlling_node = (rrm_rsu_meas_info_node_t *)rrm_mem_get(sizeof(rrm_rsu_meas_info_node_t));
                     if ( p_rsu_controlling_node == RRM_PNULL)
                     {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_rsu_controlling_node failed" );
                        RRM_UT_TRACE_EXIT();
                        RRM_MEM_FREE(p_x2ap_rrm_rsu_enb_start_res);
                         return RRM_FAILURE;
                     }
                    RRM_MEMSET(p_rsu_controlling_node, RRM_ZERO, sizeof(rrm_rsu_meas_info_node_t));
                    p_rsu_controlling_node->rsu_id.meas_id =  p_x2ap_rrm_rsu_enb_start_res->enb_meas_id;
                    p_rsu_controlling_node->cell_index =  p_rrm_rsu_trans_info->cell_index;
                    /*In future RRC shall send rrm_x2_gb_enb_id_t*/
                    rrm_fill_rrm_x2_gb_enb_id(&(p_x2ap_rrm_rsu_enb_start_res->global_enb_id), 
                            &(p_rsu_controlling_node->rsu_id.g_enb_id));

                    /*Insert the node in hash table*/
                    yhInsert(&(p_g_rrm_cell_ctx->rsu_measid_hash_tbl), &(p_rsu_controlling_node->rsu_controlling_node));

                    p_meas_id_node = (rrm_rsu_meas_id_node_t*)rrm_mem_get(sizeof(rrm_rsu_meas_id_node_t));
                    if(RRM_PNULL != p_meas_id_node) /* Coverity: CID 29549 */
                    {
                    p_meas_id_node->rsu_meas_id = p_x2ap_rrm_rsu_enb_start_res->enb_meas_id;
                    /*For future need to fill the enb_id as well*/
                    rrm_fill_rrm_x2_gb_enb_id(&(p_x2ap_rrm_rsu_enb_start_res->global_enb_id), &(p_meas_id_node->g_enb_id));
                    ylPushTail(&p_cell_ctx->rsu_meas_id_list, &p_meas_id_node->node);
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Unable to allocate memory to p_meas_id_node");
                         RRM_MEM_FREE(p_x2ap_rrm_rsu_enb_start_res);
                         RRM_MEM_FREE(p_rsu_controlling_node);                         
                        return RRM_FAILURE;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Cell context with index [0x%x] does not exist", p_rrm_rsu_trans_info->cell_index);
                }
                /* Removing rsu info node from list */
                ylDelete (&p_g_rrm_cell_ctx->rsu_trans_info_list, &p_rrm_rsu_trans_info->sNode);
                RRM_MEM_FREE(p_rrm_rsu_trans_info);
                if(RRM_PNULL != p_cell_ctx)
                {
                    /*spr 8151 start*/
                    if (RRM_ZERO == p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                    {
                    /*spr 8151 end*/
        /* eICIC_PHASE_1_2_CHANGES_START */
                        rrm_hndl_rsu_stop_req_for_ncl (p_cell_ctx, RRM_PNULL);
        /* eICIC_PHASE_1_2_CHANGES_END */
                    }
                }
            }
        }
    }
    RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_start_res);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*Rel10 CR 393 changes start*/
/* SPR 14465 start */
/****************************************************************************
 * Function Name  : rrm_fill_x2ap_rrm_rsu_measurement_res
 * Inputs         : x2ap_rrm_rsu_enb_start_req_t x2ap_rrm_rsu_enb_start_req
 *                : rrm_cell_context_t  *p_cell_ctxt:pointer to cell_context
 * Outputs        : x2ap_rrm_rsu_measurement_res_t *p_rrm_rsu_measurement_res_list
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Fill function for x2ap_rrm_rsu_measurement_res
 ****************************************************************************/
rrm_void_t
rrm_fill_x2ap_rrm_rsu_measurement_res
(
    x2ap_rrm_rsu_enb_start_req_t *p_x2ap_rrm_rsu_enb_start_req,
    rrm_cell_context_t  *p_cell_ctxt,
    x2ap_rrm_rsu_measurement_res_t *p_rrm_rsu_measurement_res_list,
    U16 cell_cnt
)
{
    /* code deleted */
    /* SPR 14465 end */
    U16 num_cell_not_supported = RRM_ZERO;
    U16 num_measurement_cnt = RRM_ZERO; /* PRB and Composite capacity is supported by default */
    U16 num_meas_cnt = RRM_ZERO;
    /*SPR 18994 START*/
    U32 report_char = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    /* Here counting number of failed measurement item */

    if ((RRM_FALSE != rrm_check_set_report_charaterstics
                (&p_x2ap_rrm_rsu_enb_start_req->report_characteristics,
                 RRM_TNL_LOAD_REPORT_CHAR_SET)) &&
            /* SPR 20653 Fix Start */
            !(p_cell_ctxt->cell_load_action.tnl_load_support_flag))
        /* SPR 20653 Fix End */
    {
        num_measurement_cnt++;
        rrm_set_report_charaterstics(&report_char,RRM_TNL_LOAD_REPORT_CHAR_SET);
    }
    if ((RRM_FALSE != rrm_check_set_report_charaterstics(&p_x2ap_rrm_rsu_enb_start_req->report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET)) &&
            /* SPR 20653 Fix Start */
            !(p_cell_ctxt->cell_load_action.hw_load_support_flag))
        /* SPR 20653 Fix End */
    {
        num_measurement_cnt++;
        rrm_set_report_charaterstics(&report_char,RRM_HW_LOAD_REPORT_CHAR_SET);
    }

    /* eICIC_PHASE_1_2_CHANGES_START */
    /* SPR 14464 start */
    if((RRM_FALSE != rrm_check_set_report_charaterstics(&p_x2ap_rrm_rsu_enb_start_req->report_characteristics,RRM_ABS_STATUS_REPORT_CHAR_SET)) &&
            (RRM_TRUE != rrm_cellm_is_victim_node(p_cell_ctxt)))
    {
        /* SPR 14464 end */
        num_measurement_cnt++;
        rrm_set_report_charaterstics(&report_char,RRM_ABS_STATUS_REPORT_CHAR_SET);
    }
    /*SPR 18994 END*/
    /* eICIC_PHASE_1_2_CHANGES_END */

    /* SPR 14465 start */
    if (RRM_ZERO != num_measurement_cnt)
    {
        /* SPR 19448 Fix Start */
        num_cell_not_supported = p_rrm_rsu_measurement_res_list->num_cell + RRM_ONE;
        /* SPR 19448 Fix End */

        p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE].bitmask |=
            X2AP_RRM_FAILED_CAUSE_NUM_ITEM_PRESENT;
        p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE]
            .num_measurement = num_measurement_cnt;
        RRM_MEMCPY(&(p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE]
                    .cell_info),&(p_x2ap_rrm_rsu_enb_start_req->cell_info[cell_cnt]), sizeof(rrm_cell_global_id_eutra_t));

        p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE].bitmask |=
            X2AP_RRM_FAILED_CAUSE_ITEM_PRESENT;
        /* Klocwork changes start 27 may */
        if((num_cell_not_supported > RRM_ZERO) && (num_cell_not_supported <= MAX_SERVED_CELLS))
        {
            /* Klocwork changes start 22 may */
            for (num_meas_cnt = RRM_ZERO; ( num_meas_cnt < MAX_ENB_MEASUREMENTS ) && (num_meas_cnt < num_measurement_cnt); num_meas_cnt++)
                /* Klocwork changes end 22 may */
            {
                /* Fill failed report characterictics */
                p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE].
                    measurement_failure_cause_item[num_meas_cnt].report_characteristics =
                    report_char;
                p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE].
                    measurement_failure_cause_item[num_meas_cnt].rrm_cause.type =
                    RADIO_NETWORK_LAYER_TYPE;
                p_rrm_rsu_measurement_res_list->rsu_measurement_res_item[num_cell_not_supported - RRM_ONE].
                    measurement_failure_cause_item[num_meas_cnt].rrm_cause.value =
                    RRM_X2AP_MEASUREMENT_NOT_SUPPORTED_FOR_THE_OBJECT;
            }
        }
        p_rrm_rsu_measurement_res_list->num_cell++;
    }
    /* SPR 14465 end */
    /* Klocwork changes end 27 may */
    RRM_UT_TRACE_EXIT();
}
/*Rel10 CR 393 changes end*/



/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_rsu_enb_start_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rsu_enb_start_req message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_rsu_enb_start_req_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len /* incoming data length*/
            /*SPR 17777 +-*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_enb_start_req_t x2ap_rrm_rsu_enb_start_req;
    rrm_oam_eutran_global_cell_id_t gb_cell_id;
    U16 num_cell = RRM_NULL;
    U16 cell_cnt = RRM_NULL;
    U16 cell_idx = RRM_NULL;
    cell_timer_buf_t timer_buf;
    x2ap_rrm_cause_t x2ap_cause;
    S32 length = RRM_NULL;
    rrm_cell_context_t  *p_cell_ctxt = RRM_PNULL;
    rrm_rsu_meas_srv_cell_info_node_t *p_rsu_serv_info = RRM_PNULL;
    x2ap_rrm_rsu_measurement_res_t rrm_rsu_measurement_res_list = {RRM_ZERO};
    U32  timer_duration = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if (RRM_FAILURE == rrm_parse_x2ap_rrm_rsu_enb_start_req(
                &x2ap_rrm_rsu_enb_start_req,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_START_REQ failed to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "RRC->RRM:X2AP_RRM_RSU_ENB_START_REQ successfully parsed");

        /*Allocating memory for the YHNODE*/
        p_rsu_serv_info = (rrm_rsu_meas_srv_cell_info_node_t *)rrm_mem_get(sizeof(rrm_rsu_meas_srv_cell_info_node_t));
        if ( p_rsu_serv_info == RRM_PNULL)
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_rsu_serv_info failed" );
            /* SPR 21251 End */
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        RRM_MEMSET(p_rsu_serv_info, RRM_ZERO, sizeof(rrm_rsu_meas_srv_cell_info_node_t));
        p_rsu_serv_info->rsu_id.meas_id = x2ap_rrm_rsu_enb_start_req.enb_meas_id;
        rrm_fill_rrm_x2_gb_enb_id(&(x2ap_rrm_rsu_enb_start_req.peer_gb_enb_id),&(p_rsu_serv_info->rsu_id.g_enb_id)); 

        p_rsu_serv_info->report_characteristics = x2ap_rrm_rsu_enb_start_req.report_characteristics;

        num_cell = x2ap_rrm_rsu_enb_start_req.num_cell;
        switch (x2ap_rrm_rsu_enb_start_req.report_periodicity)
        {
            /* BUG_825_Fix Start */
            case X2AP_RRM_RSU_REPORTING_PERIODICITY_1000MS:
            timer_duration  = RRM_RSU_REPORTING_PERIODICITY_1000MS;
            break;

            case X2AP_RRM_RSU_REPORTING_PERIODICITY_2000MS:
            timer_duration = RRM_RSU_REPORTING_PERIODICITY_2000MS;
            break;

            case X2AP_RRM_RSU_REPORTING_PERIODICITY_5000MS:
            timer_duration= RRM_RSU_REPORTING_PERIODICITY_5000MS;
            break;

            case X2AP_RRM_RSU_REPORTING_PERIODICITY_10000MS:
            timer_duration = RRM_RSU_REPORTING_PERIODICITY_10000MS;
            break;
            /* BUG_825_Fix End */
            default:
            ret_val = RRM_FAILURE;
            x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
            x2ap_cause.value = RRM_X2AP_UNSPECIFIED;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Invalid periodicity [0x%x] received",
                    x2ap_rrm_rsu_enb_start_req.report_periodicity);
        }

        if (RRM_FAILURE != ret_val)
        {
            if (x2ap_rrm_rsu_enb_start_req.report_characteristics)
            {
                /* SPR 19337: CID 19341 fix start */
                /*CID 30635 Fix Start*/
                for (cell_cnt = RRM_NULL; (cell_cnt < (U8)num_cell) && (cell_cnt < MAX_SERVED_CELLS); ++cell_cnt)
                    /*CID 30635 Fix Stop*/
                    /* SPR 19337: CID 19341 fix stop */
                {
                    ret_val = rrm_map_rrm_x2ap_glb_cell_id (&x2ap_rrm_rsu_enb_start_req.cell_info[cell_cnt],\
                            &gb_cell_id);
                    /* Setting serving cell bit corresponding to cell index */
                    if ((RRM_SUCCESS == ret_val) && (RRM_PNULL != (p_cell_ctxt = 
                                    get_cell_cntxt_n_cell_idx_from_gb_cell_id (&gb_cell_id, &cell_idx))))
                    {
                        SET_CELL_INDEX(cell_idx);

                        /*SPR 18994 START*/
                        if ((RRM_FALSE != 
                                    rrm_check_set_report_charaterstics(&x2ap_rrm_rsu_enb_start_req.report_characteristics,
                                        RRM_TNL_LOAD_REPORT_CHAR_SET)) 
                                /* SPR 20653 Fix Start */
                                &&(RRM_FALSE == p_cell_ctxt->cell_load_action.tnl_load_support_flag))
                            /* SPR 20653 Fix End */
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "LTE RRM not support TNL load report");
                            rrm_reset_report_charaterstics(&p_rsu_serv_info->report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET);
                            ret_val = RRM_FAILURE;
                        }
                        if ((RRM_FALSE != 
                                    rrm_check_set_report_charaterstics(&x2ap_rrm_rsu_enb_start_req.report_characteristics,
                                        RRM_HW_LOAD_REPORT_CHAR_SET))                                                           
                                /* SPR 20653 Fix Start */
                                && (RRM_FALSE == p_cell_ctxt->cell_load_action.hw_load_support_flag))
                            /* SPR 20653 Fix End */
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "LTE RRM not support HW load report");
                            rrm_reset_report_charaterstics(&p_rsu_serv_info->report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET);
                            ret_val = RRM_FAILURE;
                        }
                        /* SPR 14465 start */

                        /* SPR 20622 Fix Start */
                        if ((RRM_FALSE != 
                                    rrm_check_set_report_charaterstics(&x2ap_rrm_rsu_enb_start_req.report_characteristics,
                                        RRM_ABS_STATUS_REPORT_CHAR_SET)) && 
                                (RRM_TRUE == rrm_cellm_is_victim_node(p_cell_ctxt)) && 
                                (!(RRM_CELLM_USABLE_ABS_PATTERN_PRESENT & p_cell_ctxt->rrm_eicic_cell_info.bitmask)))
                            /* SPR 20622 Fix Stop */
                        {

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "p_cell_ctxt->rrm_eicic_cell_info.bitmask = [%x]",p_cell_ctxt->rrm_eicic_cell_info.bitmask);

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    "LTE RRM not support ABS report");
                            rrm_reset_report_charaterstics(&p_rsu_serv_info->report_characteristics,RRM_ABS_STATUS_REPORT_CHAR_SET);
                            ret_val = RRM_FAILURE;
                        }
                        /*SPR 18994 END*/
                        if (ENB_START_PARTIAL_SUCCESS & x2ap_rrm_rsu_enb_start_req.bitmask)
                        {
                            if (RRM_ZERO == x2ap_rrm_rsu_enb_start_req.partial_success_indicator_present)
                            {
                                rrm_fill_x2ap_rrm_rsu_measurement_res (&x2ap_rrm_rsu_enb_start_req, p_cell_ctxt,
                                        &rrm_rsu_measurement_res_list, cell_cnt);
                                /* SPR 20622 Fix Start */
                                if(RRM_ZERO == rrm_rsu_measurement_res_list.num_cell)
                                {
                                    ret_val = RRM_SUCCESS;
                                }
                                else 
                                {
                                    ret_val = RRM_PARTIAL_SUCCESS;
                                }
                                /* SPR 20622 Fix Stop */
                            }
                            else
                            {
                                /*CID 30635 Fix Start*/
                                x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
                                x2ap_cause.value = RRM_X2AP_UNSPECIFIED;
                                /*CID 30635 Fix Stop*/
                                ret_val = RRM_FAILURE;
                            }
                        }
                        /*CID 30635 Fix Start*/
                        else
                        {
                            if (RRM_FAILURE == ret_val)
                            {
                                /* SPR 21251 Start */
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "Request measurement not supported !!");
                                /* SPR 21251 End */
                                x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
                                x2ap_cause.value = RRM_X2AP_MEASUREMENT_NOT_SUPPORTED_FOR_THE_OBJECT;
                                break;
                            }
                        }

                        rrm_setbit(p_rsu_serv_info->serving_cell, cell_idx);
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "Request for Invalid cell !!");
                        x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
                        x2ap_cause.value = RRM_X2AP_CELL_NOT_AVAILABLE;
                        ret_val = RRM_FAILURE;
                        break;
                    }
                }
                /* SPR 14465 end */
            }
            else
            {
                ret_val = RRM_FAILURE;
                x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
                x2ap_cause.value = RRM_X2AP_REPORT_CHARACTERISTICS_EMPTY;
            }
        }

        if ((RRM_SUCCESS == ret_val) || (RRM_PARTIAL_SUCCESS == ret_val))
        {
            /*Insert the node in hash table for serving cell*/
            yhInsert(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl), &(p_rsu_serv_info->rsu_serving_node));

            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_IND;
            timer_buf.rsu_meas_id = p_rsu_serv_info->rsu_id.meas_id;
            /* BUG_825_Fix Start */
            p_rsu_serv_info->timer_id = rrm_ue_start_timer (
                    timer_duration * RRM_SEC_TO_MILLI_SEC_CONV /*1000*/,
                    (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), RRM_ONE);
            /* BUG_825_Fix End */
        }

        if (RRM_SUCCESS != (ret_val = build_and_send_rrm_x2ap_rrm_rsu_rrm_start_res (p_rsu_serv_info->rsu_id.meas_id,\
                        &(x2ap_rrm_rsu_enb_start_req.peer_gb_enb_id),\
                        ret_val, &x2ap_cause, &rrm_rsu_measurement_res_list)))
        {
            /* SPR-17852 START */
            if (p_rsu_serv_info->timer_id) 
            {
                /* SPR-17852 END */
                cell_stop_timer(p_rsu_serv_info->timer_id);
                /* SPR-17852 START */
                p_rsu_serv_info->timer_id = RRM_PNULL;
                /* SPR-17852 END */
            }
            /* End fix for Coverity_ID : 893290 */
            /*SPR 20007 : Coverity_fix 86772 */
            yhDelete(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl), &(p_rsu_serv_info->rsu_serving_node));
            rrm_mem_free(p_rsu_serv_info);
            /* SPR 20007 : Coverity_fix 86772 */

        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_rsu_enb_stop_req_process_msg 
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rsu_enb_stop_req message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_rsu_enb_stop_req_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len /* incoming data length*/
 /*SPR 17777 +-*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_enb_stop_req_t *p_x2ap_rrm_rsu_enb_stop_req = RRM_PNULL;
    x2ap_rrm_cause_t x2ap_cause;
    S32 length = RRM_NULL;
    rrm_rsu_meas_srv_cell_info_node_t *p_rsu_serv= RRM_PNULL;
    rrm_cell_meas_gb_t        p_key = {RRM_ZERO};
    rrm_global_context_t *p_rrm_glb_ctx = RRM_PNULL;
    YHNODE *p_hnode = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_x2ap_rrm_rsu_enb_stop_req = (x2ap_rrm_rsu_enb_stop_req_t *) \
                                  rrm_mem_get (sizeof (x2ap_rrm_rsu_enb_stop_req_t));
    if ( p_x2ap_rrm_rsu_enb_stop_req == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_rsu_enb_stop_req failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    if (RRM_FAILURE == rrm_parse_x2ap_rrm_rsu_enb_stop_req(
                p_x2ap_rrm_rsu_enb_stop_req,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_STOP_REQ failed to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        p_rrm_glb_ctx = (rrm_global_context_t *)qvThisContext ();
        /* CID 110676 Fix Start */
        if(RRM_PNULL == p_rrm_glb_ctx)
        {
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"p_rrm_glb_ctx is null");
            /* SPR 21251 End */
            RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_stop_req);
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;
        }
        /* CID 110676 Fix End */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "RRC->RRM:X2AP_RRM_RSU_ENB_STOP_REQ successfully parsed");
        p_key.meas_id = p_x2ap_rrm_rsu_enb_stop_req->enb_meas_id;
        RRM_MEMCPY(&(p_key.g_enb_id),&p_x2ap_rrm_rsu_enb_stop_req->peer_gb_enb_id,sizeof(x2_gb_enb_id_t));
        /*Find the node in hash table stop the timer and delete the node from table*/
        p_hnode = yhFind(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl),
                (rrm_void_t *)&(p_key));
        if (RRM_PNULL != p_hnode)
        {
            p_rsu_serv = (rrm_rsu_meas_srv_cell_info_node_t *)p_hnode;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Stop Sending RSU to requesting peer eNB MID:%d", p_rsu_serv->rsu_id.meas_id);
            /* BUG_825_Fix Start */
            /* SPR-17852 START */
            if(p_rsu_serv->timer_id)
            {
                cell_stop_timer (p_rsu_serv->timer_id);
                p_rsu_serv->timer_id = RRM_PNULL;
            }
            /* SPR-17852 END */
            /* BUG_825_Fix End */
            RRM_MEMSET(&p_rsu_serv->serving_cell,
                    RRM_ZERO, sizeof(p_rsu_serv->serving_cell));

            /*Delete the Hash node and free the memory*/
            yhDelete (&(p_rrm_glb_ctx->rsu_measid_serving_hash_tbl), (YHNODE *)p_rsu_serv);
            RRM_MEM_FREE(p_rsu_serv);
        }
        else
        {
            /* Failure needs to be sent */
            ret_val = RRM_FAILURE;
            x2ap_cause.type = RADIO_NETWORK_LAYER_TYPE;
            x2ap_cause.value = RRM_X2AP_UNKNOWN_ENB_MEASUREMENT_ID;

        }

        ret_val = build_and_send_rrm_x2ap_rrm_rsu_rrm_stop_res (p_x2ap_rrm_rsu_enb_stop_req->enb_meas_id,\
                &(p_x2ap_rrm_rsu_enb_stop_req->peer_gb_enb_id), 
                ret_val, &x2ap_cause);
    }
    RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_stop_req);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_rsu_enb_stop_res_process_msg 
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rsu_enb_stop_res message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_rsu_enb_stop_res_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len /* incoming data length*/
 /*SPR 17777 +-*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_enb_stop_res_t *p_x2ap_rrm_rsu_enb_stop_res = RRM_PNULL;
    rrm_global_context_t *p_rrm_glb_ctx = RRM_PNULL;
    S32 length = RRM_NULL;
    rrm_cell_meas_gb_t        p_key = {RRM_ZERO};
    YHNODE *p_hnode = RRM_PNULL;
    rrm_rsu_meas_info_node_t *p_rsu_ctrl = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_x2ap_rrm_rsu_enb_stop_res = (x2ap_rrm_rsu_enb_stop_res_t *) \
                                  rrm_mem_get (sizeof (x2ap_rrm_rsu_enb_stop_res_t));
    if ( p_x2ap_rrm_rsu_enb_stop_res == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_rsu_enb_stop_res failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    if (RRM_FAILURE == rrm_parse_x2ap_rrm_rsu_enb_stop_res(
                p_x2ap_rrm_rsu_enb_stop_res,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_STOP_RES unable to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        p_rrm_glb_ctx = (rrm_global_context_t *)qvThisContext ();
        RRM_ASSERT (RRM_PNULL != p_rrm_glb_ctx);
        /* SPR 19838 : CID 10221 Fix Start */
        if(RRM_PNULL == p_rrm_glb_ctx)
        {
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"p_rrm_glb_ctx is null");
            /* SPR 21251 End */
            RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_stop_res);
            RRM_UT_TRACE_EXIT();
            return RRM_FAILURE;		
        }
        /* SPR 19838 : CID 10221 Fix End */
        p_key.meas_id = p_x2ap_rrm_rsu_enb_stop_res->enb_meas_id;
        RRM_MEMCPY(&(p_key.g_enb_id),&(p_x2ap_rrm_rsu_enb_stop_res->peer_gb_enb_id), sizeof(x2_gb_enb_id_t));
        p_hnode = yhFind(&(p_rrm_glb_ctx->rsu_measid_hash_tbl),
                (rrm_void_t *)&(p_key));
        if (RRM_PNULL != p_hnode)
        {
            if (RRM_SUCCESS == p_x2ap_rrm_rsu_enb_stop_res->response )
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                        "RRC->RRM:X2AP_RRM_RSU_ENB_STOP_RES with response:%d for MeasId:%d", 
                        p_x2ap_rrm_rsu_enb_stop_res->response, p_x2ap_rrm_rsu_enb_stop_res->enb_meas_id);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "RRC->RRM:X2AP_RRM_RSU_ENB_STOP_RES with response failure:%d for MeasId:%d Cause (Type: %d and Value :%d)",
                        p_x2ap_rrm_rsu_enb_stop_res->response, p_x2ap_rrm_rsu_enb_stop_res->enb_meas_id, 
                        p_x2ap_rrm_rsu_enb_stop_res->rrm_cause.type, 
                        p_x2ap_rrm_rsu_enb_stop_res->rrm_cause.value);
            }
            /*Find the node and delete the node from hash table*/
            p_rsu_ctrl = (rrm_rsu_meas_info_node_t *)p_hnode;

            yhDelete (&(p_rrm_glb_ctx->rsu_measid_hash_tbl), (YHNODE *)p_rsu_ctrl);
            RRM_MEM_FREE(p_rsu_ctrl);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Invalid MeasId [%u] received in X2AP_RRM_RSU_ENB_STOP_RES", p_x2ap_rrm_rsu_enb_stop_res->enb_meas_id);
        }
    }
    RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_stop_res);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : get_cell_cntxt_n_cell_idx_from_gb_cell_id 
 * Inputs         :
 *                : rrm_oam_eutran_global_cell_id_t *p_gb_cell_id 
 * Outputs        : U16 *p_cell_index 
 * Returns        : pointer to Cell context 
 * Description    : Find cell context and cell index from gloabal cell Id
 ****************************************************************************/
    rrm_cell_context_t *get_cell_cntxt_n_cell_idx_from_gb_cell_id 
(
 rrm_oam_eutran_global_cell_id_t *p_gb_cell_id,
 U16 *p_cell_index
 )
{
    U16 cell_cnt = RRM_NULL;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    for (cell_cnt = RRM_ZERO; cell_cnt < RRM_MAX_NUM_CELLS; ++cell_cnt)
    {
        if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_cnt])
        {
            if (RRM_SUCCESS == compare_global_cell_id (p_gb_cell_id, 
                        &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_cnt]->global_cell_id)))
            {
                p_cell_context = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_cnt];
                *p_cell_index = p_cell_context->cell_index;
                break;
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return p_cell_context;
}

/****************************************************************************
 * Function Name  : rrm_map_rrm_x2ap_glb_cell_id 
 * Inputs         : rrm_cell_global_id_eutra_t *p_gb_x2ap_cell_id
 *                : rrm_oam_eutran_global_cell_id_t *p_gb_cell_id
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Map X2AP global cell id into rrm global cell id
 ****************************************************************************/
    rrm_return_et rrm_map_rrm_x2ap_glb_cell_id 
(
 rrm_cell_global_id_eutra_t *p_gb_x2ap_cell_id,
 rrm_oam_eutran_global_cell_id_t *p_gb_rrm_cell_id
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_gb_x2ap_cell_id);
    RRM_ASSERT(RRM_PNULL != p_gb_rrm_cell_id);

    if (p_gb_x2ap_cell_id->plmn_identity.presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
    {
        RRM_MEMCPY((p_gb_rrm_cell_id->primary_plmn_id.mcc),\
                (p_gb_x2ap_cell_id->plmn_identity.mcc),\
                sizeof(p_gb_rrm_cell_id->primary_plmn_id.mcc));
    }
    else
    {
        RRM_MEMSET (p_gb_rrm_cell_id->primary_plmn_id.mcc, RRM_NULL,\
                sizeof (p_gb_rrm_cell_id->primary_plmn_id.mcc));
    }
    p_gb_rrm_cell_id->primary_plmn_id.num_mnc_digit = \
                                                      p_gb_x2ap_cell_id->plmn_identity.mnc.count;
    RRM_MEMCPY((p_gb_rrm_cell_id->primary_plmn_id.mnc),
            (p_gb_x2ap_cell_id->plmn_identity.mnc.mnc),
            sizeof(p_gb_rrm_cell_id->primary_plmn_id.mnc));
    RRM_MEMCPY(p_gb_rrm_cell_id->cell_identity, p_gb_x2ap_cell_id->cell_identity,\
            sizeof (p_gb_rrm_cell_id->cell_identity));

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_get_eutran_cell_type_for_global_cell_id 
 * Inputs         :
 *                : rrm_oam_eutran_global_cell_id_t *p_gb_cell_id
 *                : rrm_cell_context_t *p_cell_cxt
 * Outputs        : rrm_eutran_cell_types_et *cell_type;
 *                : U16 *nbr_cell_idx
 * Returns        : None
 * Description    : find global cell Id is belongs to inter cell or intra cell
 *                : in ncl list.
 ****************************************************************************/
    rrm_void_t rrm_get_eutran_cell_type_for_global_cell_id 
(
 rrm_oam_eutran_global_cell_id_t *p_glb_cell_id,
 rrm_cell_context_t *p_cell_ctx,
 rrm_eutran_cell_types_et *p_cell_type,
 U16 *nbr_cell_idx
 )
{
    U8 num_valid_ran_list = RRM_ZERO;
    U8 cell_list = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();    
    RRM_ASSERT(RRM_PNULL != p_glb_cell_id);
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    num_valid_ran_list = p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;
    for (cell_list = RRM_ZERO; cell_list < num_valid_ran_list; ++cell_list)
    {
        ret_val = compare_global_cell_id (p_glb_cell_id,
                &(p_cell_ctx->ran_info.\
                    ncl_params.lte_ncl.\
                    intra_freq_cells[cell_list].\
                    cell_id));
        if (RRM_SUCCESS == ret_val)
        {
            *p_cell_type = RRM_EUTRAN_INTRA_FREQ_CELL;
            *nbr_cell_idx = cell_list;
            break;
        }
    }
    /* Check global cell Id belongs to inter freq cell */
    num_valid_ran_list = p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell;
    for (cell_list = RRM_ZERO; cell_list < num_valid_ran_list; ++cell_list)
    {
        ret_val = compare_global_cell_id ((rrm_oam_eutran_global_cell_id_t *)p_glb_cell_id,
                &(p_cell_ctx->ran_info.\
                    ncl_params.lte_ncl.\
                    inter_freq_cells[cell_list].\
                    cell_id));
        if (RRM_SUCCESS == ret_val)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Inter freq[%d]",
                    p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[cell_list].eutra_carrier_arfcn);
            *p_cell_type = RRM_EUTRAN_INTER_FREQ_CELL;
            *nbr_cell_idx = cell_list;
            break;
        }
    }
    RRM_UT_TRACE_EXIT();
    return;
}

/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_rsu_enb_update_ind_process_msg 
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rsu_enb_update_ind message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_rsu_enb_update_ind_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len /* incoming data length*/
 /*SPR 17777 +-*/
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    x2ap_rrm_rsu_enb_update_ind_t *p_x2ap_rrm_rsu_enb_update_ind = RRM_PNULL;
    U16 cell_idx = RRM_ZERO;
    U16 report_cnt = RRM_NULL;
    U16 num_reports = RRM_NULL;
    S32 length = RRM_ZERO;
    rrm_oam_eutran_global_cell_id_t gb_cell_id;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_eutran_cell_types_et cell_type = RRM_EUTRAN_INVALID_FREQ_CELL;
    rrm_cell_meas_gb_t   p_key = {RRM_ZERO};
    YHNODE *p_hnode = RRM_PNULL;
    rrm_rsu_meas_info_node_t *p_rsu_ctrl = RRM_PNULL;
    U16 nbr_cell_idx = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    p_x2ap_rrm_rsu_enb_update_ind = (x2ap_rrm_rsu_enb_update_ind_t *) \
                                    rrm_mem_get (sizeof (x2ap_rrm_rsu_enb_update_ind_t));
    if ( p_x2ap_rrm_rsu_enb_update_ind == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_rsu_enb_update_ind failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }

    RRM_MEMSET(p_x2ap_rrm_rsu_enb_update_ind, RRM_ZERO, sizeof(x2ap_rrm_rsu_enb_update_ind_t));

    /* Parse  the incoming message from RRC */
    if (RRM_FAILURE == rrm_parse_x2ap_rrm_rsu_enb_update_ind (
                p_x2ap_rrm_rsu_enb_update_ind,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
                "RRC->RRM:X2AP_RRM_RSU_ENB_UPDATE_IND failed to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "RRC->RRM:X2AP_RRM_RSU_ENB_UPDATE_IND successfully parsed");
        p_key.meas_id = p_x2ap_rrm_rsu_enb_update_ind->enb_meas_id;
        RRM_MEMCPY(&(p_key.g_enb_id),&(p_x2ap_rrm_rsu_enb_update_ind->peer_gb_enb_id),sizeof(x2_gb_enb_id_t));

        /*Find the meas_id in controlling hash table*/
        p_hnode = yhFind(&(p_g_rrm_cell_ctx->rsu_measid_hash_tbl),
                (rrm_void_t *)&(p_key));
        if(RRM_PNULL != p_hnode)
        {
            /*Delete the node in hash table*/
            p_rsu_ctrl = (rrm_rsu_meas_info_node_t *)p_hnode;
            /* Getting Serving cell's cell Index */
            p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[p_rsu_ctrl->cell_index];
            num_reports = p_x2ap_rrm_rsu_enb_update_ind->num_reports;

            SET_CELL_INDEX(p_rsu_ctrl->cell_index);

            rrm_fill_rrm_x2_gb_enb_id (&p_x2ap_rrm_rsu_enb_update_ind->peer_gb_enb_id,
                    &p_rsu_ctrl->rsu_id.g_enb_id);
            for (report_cnt = RRM_ZERO; report_cnt < num_reports; ++report_cnt)
            {
                /* Converting global cell id recved on x2 link into rrm specific glb cell id */
                ret_val = rrm_map_rrm_x2ap_glb_cell_id (&(p_x2ap_rrm_rsu_enb_update_ind-> \
                            rsu_report[report_cnt] \
                            .cell_info), &gb_cell_id);
                /* Coverity Fix 77132 Start */
                if (RRM_FAILURE == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Failure returned by function rrm_map_rrm_x2ap_glb_cell_id");
                }
                /* Coverity Fix 77132 End */
                /* Getting cell context from global cell id */
                if (RRM_PNULL != p_cell_ctx)
                {
                    /* Getting eutran cell type (inter/intra) for a gbl cell id */
                    rrm_get_eutran_cell_type_for_global_cell_id ( \
                            &gb_cell_id, \
                            p_cell_ctx,
                            &cell_type, \
                            &nbr_cell_idx);
                    if (RRM_EUTRAN_INVALID_FREQ_CELL != cell_type)
                    {
                        /* Updating neighbor cell load info in cell context */
                        /* eICIC_PHASE_1_2_CHANGES_START */
                        ret_val = rrm_cellm_populate_nbr_rsu_in_cell_context ( \
                                p_x2ap_rrm_rsu_enb_update_ind, \
                                p_cell_ctx, report_cnt, cell_type,\
                                nbr_cell_idx);
                        /* eICIC_PHASE_1_2_CHANGES_END */
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "RSU received for Uknown neighbor cell (NOT IN NCL)");
                        ret_val = RRM_FAILURE;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "cell_context not found for cell index: %d", cell_idx);
                    /* SPR 19838 : CID 10354 Fix Start */
                    RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_update_ind);
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                    /* SPR 19838 : CID 10354 Fix End */
                }
                /* eICIC_PHASE_1_2_CHANGES_START */

                rrm_cellm_tune_abs_pattern(p_cell_ctx);
                /* eICIC_PHASE_1_2_CHANGES_END */
            }
        }
    }
    RRM_MEM_FREE (p_x2ap_rrm_rsu_enb_update_ind);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_fill_ld_ac_barring
 * Inputs         : rrm_access_class_barring_info_t *p_mif_acb
 * Outputs        : rrm_cellm_ac_barring_ld_info_t *p_cell_acb
 * Returns        : Void
 * Description    : Fill load ac barring info in cell context received from MIF.
 ****************************************************************************/
rrm_void_t
    rrm_cellm_fill_ld_ac_barring
(
 rrm_cellm_ac_barring_ld_info_t *p_cell_acb,
 rrm_access_class_barring_info_t *p_mif_acb
 )
{
    RRM_ASSERT(RRM_PNULL != p_cell_acb);
    RRM_ASSERT(RRM_PNULL != p_mif_acb);
    RRM_UT_TRACE_ENTER();
    p_cell_acb->ac_barring_factor = p_mif_acb->ac_barring_factor;
    p_cell_acb->ac_barring_time = p_mif_acb->ac_barring_time;
    p_cell_acb->ac_barring_spec_ac = p_mif_acb->ac_barring_for_special_ac;
    RRM_UT_TRACE_EXIT();    
    return;
}

/****************************************************************************
 * Function Name  : rrm_cellm_fill_load_actn
 * Inputs         : rrm_cell_load_def_t *p_cell_load,
 *                : rrmcm_rmif_action_t *p_cell_mif_load
 * Outputs        : NONE
 * Returns        : Void
 * Description    : Populate cell load action.
 ****************************************************************************/
rrm_void_t
rrm_cellm_fill_load_actn
(
 rrm_cell_load_def_t *p_cell_load,
 rrmcm_rmif_action_t *p_cell_mif_load,
 /*EICIC_TDD_CHANGES_START*/
 rrm_cell_context_t *p_cell_ctx
 /*EICIC_TDD_CHANGES_END*/
 )
{
    U8                  abs_pattern_index = RRM_ZERO;
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_ASSERT (RRM_PNULL != p_cell_load);
    RRM_ASSERT (RRM_PNULL != p_cell_mif_load);
    RRM_UT_TRACE_ENTER();
    p_cell_load->bitmask = p_cell_mif_load->bitmask;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "Action def Bitmask[0x%x]", p_cell_load->bitmask);

    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_PATTERN_BYTE;
    /*SPR 17777 +-*/
    RRM_TRACE(g_cellm_log_on_off,p_g_rrm_cellm_facility_name, RRM_DETAILEDALL,
            "Unused variable p_cell_ctx=%p",p_cell_ctx);/*SPR 17777 +-*/
    /*SPR 17777 +-*/
#endif
    /*EICIC_TDD_CHANGES_END*/

    if (RRMCM_RMIF_PERCNTG_PRESENT & p_cell_load->bitmask)
    {
        p_cell_load->percent = p_cell_mif_load->load_perctg;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updating load %% to [%u]%%", p_cell_load->percent);
    }
    if (RRMCM_RMIF_ACTION_PRESENT & p_cell_load->bitmask)
    {
        p_cell_load->action = p_cell_mif_load->action;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updating action[0x%x]", p_cell_load->action);

        /* Bug_8718_start */
        /*If stop admission action is present and already no soft limit value is set, 
          then assigning with default value (else original value retains). 
          Can be updated if stop admission info is present*/    /* SPR 17844 fix start */
        if(p_cell_mif_load->action & RRMCM_ACTN_STOP_ADM)
        {
            /* SPR 17844 fix end */
            p_cell_load->soft_lmt = RRM_DEFINED_DEFAULT_VALUE_FOR_SOFT_LMT;
        }
        /* Bug_8718_end */
    }
    if (RRMCM_RMIF_NUM_USR_PRESENT & p_cell_load->bitmask)
    {
        p_cell_load->num_of_usr = p_cell_mif_load->num_usr;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updating num usr[%u]",  p_cell_load->num_of_usr);
    }
    /* Bug_8718_start */
    if((RRMCM_RMIF_STOP_ADM_INFO_PRESENT & p_cell_mif_load->bitmask) && 
            (p_cell_mif_load->stop_adm_info.bitmask & RRMCM_RMIF_SOFT_LIMIT_PRESENT))
    {
        p_cell_load->soft_lmt = p_cell_mif_load->stop_adm_info.soft_limit;
    }
    /* Bug_8718_end */
    if (RRMCM_RMIF_Q_WATERMARK_PRESENT & p_cell_load->bitmask)
    {
        RRM_MEMCPY(&p_cell_load->q_watermark, &p_cell_mif_load->q_watermark, sizeof(rrm_oam_watermark_t));
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updating High watermark[%u], Low watermark[%u]",
                p_cell_load->q_watermark.high_watermark,
                p_cell_load->q_watermark.low_watermark);
    }
    if (RRMCM_RMIF_LD_AC_BARRING_PRESENT & p_cell_load->bitmask)
    {
        if (p_cell_mif_load->ld_ac_bar.bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
        {
            p_cell_load->ld_ac_bar.bitmask |= RRM_CELLM_LDACB_MMTEL_MOSIGL_PRESENT; 
            rrm_cellm_fill_ld_ac_barring (&p_cell_load->ld_ac_bar.mo_sigl, &p_cell_mif_load->ld_ac_bar.ac_barring_for_mo_signalling);
        }
        if (p_cell_mif_load->ld_ac_bar.bitmask & RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
        {
            p_cell_load->ld_ac_bar.bitmask |= RRM_CELLM_LDACB_MMTEL_MODATA_PRESENT;
            rrm_cellm_fill_ld_ac_barring (&p_cell_load->ld_ac_bar.mo_data, &p_cell_mif_load->ld_ac_bar.ac_barring_for_mo_data);
        }
        if (p_cell_mif_load->ld_ac_bar.bitmask & RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
        {
            if (p_cell_mif_load->ld_ac_bar.ssac_barring_r9.bitmask & RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
            {
                p_cell_load->ld_ac_bar.bitmask |= RRM_CELLM_LDACB_MMTEL_VOICE_PRESENT;
                rrm_cellm_fill_ld_ac_barring (&p_cell_load->ld_ac_bar.mmtel_voice, &p_cell_mif_load->ld_ac_bar.ssac_barring_r9.\
                        ssac_barring_for_mmtel_voice_r9);
            }
            if (p_cell_mif_load->ld_ac_bar.ssac_barring_r9.bitmask & RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT)
            {
                p_cell_load->ld_ac_bar.bitmask |= RRM_CELLM_LDACB_MMTEL_VIDEO_PRESENT;
                rrm_cellm_fill_ld_ac_barring (&p_cell_load->ld_ac_bar.mmtel_video, &p_cell_mif_load->ld_ac_bar.ssac_barring_r9.\
                        ssac_barring_for_mmtel_video_r9);
            }
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Updating AC Barring Configuration");
    }
    /* Bug_944_start */
    if (RRMCM_RMIF_REDIRECT_INFO_PRESENT & p_cell_mif_load->bitmask)
    {
        p_cell_load->bitmask |= RRM_CELLM_MARD_INFO_PRESENT;
        if (RRMCM_RMIF_MARD_PRESENT & p_cell_mif_load->mard_info.bitmask)
        {
            p_cell_load->mard_info.bitmask |= RRM_CELLM_MARD_PRESENT;
            p_cell_load->mard_info.mard_present = p_cell_mif_load->mard_info.mard_present;
        }
        if (RRMCM_RMIF_MEAS_BASED_RWR_TIMER_PRESENT & p_cell_mif_load->mard_info.bitmask)
        {
            p_cell_load->mard_info.bitmask |= RRM_CELLM_MEAS_BASED_RWR_TIMER_PRESENT;
            p_cell_load->mard_info.rwr_timer = p_cell_mif_load->mard_info.rwr_timer;
        }
    }
    /* Bug_944_end */
    /** eICIC_PHASE_1_2_CHANGES_START */
    if(RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT & p_cell_mif_load->bitmask)
    {
        /*SPR 14412 start*/ 
        p_cell_load->bitmask |= RRM_CELLM_EICIC_LOAD_CONFIG_PRESENT;
        /*SPR 14412 end*/
        if (RRMCM_RMIF_ELIGIBLE_UE_PRESENT & p_cell_mif_load->eicic_load_config.bitmask)
        {
            p_cell_load->eicic_load_config.bitmask |= RRM_CELLM_ELIGIBLE_UE_PRESENT;
            p_cell_load->eicic_load_config.eligible_ue = 
                p_cell_mif_load->eicic_load_config.eligible_ue;
        }
        if (RRMCM_RMIF_ABS_PATTERN_PRESENT & p_cell_mif_load->eicic_load_config.bitmask)
        {
            p_cell_load->eicic_load_config.bitmask |= RRM_CELLM_ABS_PATTERN_PRESENT;
            /*EICIC_TDD_CHANGES_START*/
            for (abs_pattern_index = RRM_ZERO;
                    abs_pattern_index < abs_size;
                    abs_pattern_index++)
                /*EICIC_TDD_CHANGES_END*/    
            {
                p_cell_load->eicic_load_config.abs_pattern[abs_pattern_index] =
                    p_cell_mif_load->eicic_load_config.abs_pattern[abs_pattern_index];
            }
            rrm_copy_tdd_bits(abs_size, p_cell_load->eicic_load_config.abs_pattern);

        }
    }
    /** eICIC_PHASE_1_2_CHANGES_END */
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_populate_load_actn_in_cell_context
 * Inputs         : rrmcm_rmif_srv_cell_info_t,
 * Outputs        : NONE
 * Returns        : Void
 * Description    : Populate cell load action.
 ****************************************************************************/
rrm_void_t
    rrm_populate_load_actn_in_cell_context
(
 rrmcm_rmif_srv_cell_info_t *p_srv_info
 )

{
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_global_context_t *p_rrm_gbl_ctx = RRM_PNULL;
    U8  resrc_cnt = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    p_rrm_gbl_ctx = (rrm_global_context_t *)qvThisContext();
    RRM_ASSERT (RRM_PNULL != p_rrm_gbl_ctx);
    /* Coverity 88345 Fix Start */
    if (RRM_PNULL == p_rrm_gbl_ctx)
    {
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"p_rrm_gbl_ctx is null");
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return;	
    }
    /* Coverity 88345 Fix End */
    p_cell_ctx = p_rrm_gbl_ctx->p_rrm_cell_ctx[p_srv_info->cellindex];
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);
    if (p_srv_info->bitmask & RRMCM_RMIF_RESRC_SPEC_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Resource specific selection made");
        /* Resetting information as composite load info is void after this */
        /* Bug_8718_start */
        /*If cell load type has changed from composite to resrc specific, 
          then only clear the previous buffer, else update the existing one*/
        if(p_cell_ctx->cell_load_action.choice == RRM_CELL_LOAD_COMPOSITE_PRESENT)
        {
            RRM_MEMSET(&(p_cell_ctx->cell_load_action.u), RRM_ZERO, sizeof(p_cell_ctx->cell_load_action.u));
        }
        /* Bug_8718_end */
        p_cell_ctx->cell_load_action.choice = RRM_CELL_LOAD_RESRC_SPEC_PRESENT;
        p_cell_ctx->cell_load_action.u.resrc_spec_info.count = p_srv_info->resrc_spec.count;
        for (resrc_cnt = RRM_ZERO; resrc_cnt < p_srv_info->resrc_spec.count; ++resrc_cnt)
        {
            p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type =
                p_srv_info->resrc_spec.resrc_info[resrc_cnt].resrc_type;
            if (p_srv_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_ACTION_OVERLD_PRESENT)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Overload Configuration...");
                p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask |= RRM_CELLM_OVERLOAD_PRESENT;
                /*EICIC_TDD_CHANGES_START*/
                rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.over_load,
                        &p_srv_info->resrc_spec.resrc_info[resrc_cnt].overload, p_cell_ctx);
                /*EICIC_TDD_CHANGES_END*/
            }
            if (p_srv_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_ACTION_HIGHLD_PRESENT)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Highload Configuration...");
                p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask |= RRM_CELLM_HIGHLOAD_PRESENT;
                /*EICIC_TDD_CHANGES_START*/
                rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.high_load,
                        &p_srv_info->resrc_spec.resrc_info[resrc_cnt].highload, p_cell_ctx);
                /*EICIC_TDD_CHANGES_END*/
            }
            if (p_srv_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_ACTION_MIDLD_PRESENT)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Midload Configuration...");
                p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask |= RRM_CELLM_MIDLOAD_PRESENT;
                /*EICIC_TDD_CHANGES_START*/
                rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.mid_load,
                        &p_srv_info->resrc_spec.resrc_info[resrc_cnt].midload,p_cell_ctx);
                /*EICIC_TDD_CHANGES_END*/
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                "Composite load selection made");
        /* Resetting information as resource specific load info is void after this */
        /* Bug_8718_start */
        /*If cell load type has changed from resrc to composite specific, 
          then only clear the previous buffer, else update the existing one*/
        if(p_cell_ctx->cell_load_action.choice == RRM_CELL_LOAD_RESRC_SPEC_PRESENT)
        {
            RRM_MEMSET(&(p_cell_ctx->cell_load_action.u), RRM_ZERO, sizeof(p_cell_ctx->cell_load_action.u));
        }
        /* Bug_8718_end */
        p_cell_ctx->cell_load_action.choice = RRM_CELL_LOAD_COMPOSITE_PRESENT;
        if (p_srv_info->bitmask & RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Overload Configuration...");
            p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |= RRM_CELLM_OVERLOAD_PRESENT;
            /*EICIC_TDD_CHANGES_START*/
            rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.comp_load_info.over_load,
                    &p_srv_info->over_load_lvl_act, p_cell_ctx);
            /*SPR 14811 start*/
            if ((RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT & p_srv_info->over_load_lvl_act.bitmask) &&
                    (RRMCM_RMIF_ABS_PATTERN_PRESENT & p_srv_info->over_load_lvl_act.eicic_load_config.bitmask))
            {
                rrm_raise_error_event_notification(RRM_EE_ABS_FOUND_OVER_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Overload ABS Pattern Found...");
            }
            else
            {
                rrm_raise_error_event_notification(RRM_EE_ABS_NOT_FOUND_OVER_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Overload ABS Pattern Not Found...");
            }
            /*SPR 14811 end*/
            /*EICIC_TDD_CHANGES_END*/
        }
        if (p_srv_info->bitmask & RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Highload Configuration...");
            p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |= RRM_CELLM_HIGHLOAD_PRESENT;
            /*EICIC_TDD_CHANGES_START*/
            rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.comp_load_info.high_load,
                    &p_srv_info->high_load_lvl_act,p_cell_ctx);
            /*EICIC_TDD_CHANGES_END*/
            /*SPR 14811 start*/
            if ((RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT & p_srv_info->high_load_lvl_act.bitmask) &&
                    (RRMCM_RMIF_ABS_PATTERN_PRESENT & p_srv_info->high_load_lvl_act.eicic_load_config.bitmask))
            {
                rrm_raise_error_event_notification(RRM_EE_ABS_FOUND_HIGH_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Highload ABS Pattern Found...");
            }
            else
            {

                rrm_raise_error_event_notification(RRM_EE_ABS_NOT_FOUND_HIGH_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Highload ABS Pattern Not Found...");
            }    
            /*SPR 14811 end*/
        }
        if (p_srv_info->bitmask & RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Midload Configuration...");
            p_cell_ctx->cell_load_action.u.comp_load_info.bitmask |= RRM_CELLM_MIDLOAD_PRESENT;
            /*EICIC_TDD_CHANGES_START*/
            rrm_cellm_fill_load_actn (&p_cell_ctx->cell_load_action.u.comp_load_info.mid_load,
                    &p_srv_info->mid_load_lvl_act, p_cell_ctx);
            /*SPR 14811 start*/
            if ((RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT & p_srv_info->mid_load_lvl_act.bitmask) &&
                    (RRMCM_RMIF_ABS_PATTERN_PRESENT & p_srv_info->mid_load_lvl_act.eicic_load_config.bitmask))
            {
                rrm_raise_error_event_notification(RRM_EE_ABS_FOUND_MID_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Midload ABS Pattern Found...");
            }
            else
            {
                rrm_raise_error_event_notification(RRM_EE_ABS_NOT_FOUND_MID_LOAD);
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Midload ABS Pattern Not Found...");
            }

            /*SPR 14811 end*/
        }
        /*EICIC_TDD_CHANGES_END*/  
    }
    RRM_UT_TRACE_EXIT();
}
    rrm_bool_et rrm_check_load_perctg
(
 U8 load_percntg_over,
 U8 load_percntg_high,
 U8 load_percntg_mid
 ) 
{
    rrm_bool_et ret_val = RRM_TRUE;
    RRM_UT_TRACE_ENTER();

    if( RRM_ZERO != load_percntg_high )
    { 
        if( load_percntg_high <= load_percntg_mid )
        {
            ret_val = RRM_FALSE;
        } 
    } 
    if( RRM_ZERO != load_percntg_over )
    {
        if(load_percntg_over <= load_percntg_high )
        {
            ret_val = RRM_FALSE;
        }
        else if (load_percntg_over <= load_percntg_mid)
        {
            ret_val = RRM_FALSE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val; 
}
/*klock_works_changes_start*/
rrm_bool_et
    check_resrc_specific_info
(
 rrmcm_rmif_srv_cell_info_t *p_srv_cell_info,
 rrm_cell_context_t *p_cell_ctx
 )
{
    U8  over_load = RRM_NULL;
    U8  high_load = RRM_NULL;
    U8  mid_load = RRM_NULL;

    U8 resrc_cnt = RRM_NULL;
    rrm_bool_et ret_val = RRM_TRUE;
    RRM_UT_TRACE_ENTER();


    for (resrc_cnt = RRM_NULL; resrc_cnt < p_srv_cell_info->resrc_spec.count; ++resrc_cnt)
    {
        over_load = RRM_ZERO;
        high_load = RRM_ZERO;
        mid_load = RRM_ZERO;
        if (p_srv_cell_info->bitmask & RRMCM_RMIF_RESRC_SPEC_PRESENT )
        {
            if ((p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT) ||
                    (p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT) ||
                    (p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask & RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT))
            {
                /* Fixed by Manoj*/
                if( RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask )
                {
                    over_load = p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].overload.load_perctg;
                }
                else if( RRM_CELLM_OVERLOAD_PRESENT & p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask )
                {
                    over_load = p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.over_load.percent;
                }
                if( RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask )
                {
                    high_load = p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].highload.load_perctg;
                }
                else if( RRM_CELLM_HIGHLOAD_PRESENT & p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask )
                {
                    high_load = p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.high_load.percent;
                }
                if( RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].bitmask )
                {
                    mid_load = p_srv_cell_info->resrc_spec.resrc_info[resrc_cnt].midload.load_perctg;
                }
                else if( RRM_CELLM_MIDLOAD_PRESENT & p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.bitmask )
                {
                    mid_load = p_cell_ctx->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.mid_load.percent;
                }
                ret_val = rrm_check_load_perctg( over_load, high_load, mid_load );
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/
/*SPR 14248 start*/
/*spr_20555_changes_start*/
/*code deleted*/
/*spr_20555_changes_end*/
/*SPR 14248 end*/
    rrm_bool_et rrm_verify_load_cfg_req_from_mif
(
 rrmcm_rmif_srv_cell_info_t *p_srv_cell_info
 )
{

    rrm_bool_et ret_val = RRM_TRUE;
    rrm_cell_context_t *p_cell_ctx = RRM_PNULL;
    rrm_global_context_t *p_rrm_gbl_ctx = RRM_PNULL;
    U8           over_load = RRM_NULL;
    U8           high_load = RRM_NULL;
    U8           mid_load = RRM_NULL;

    RRM_ASSERT(RRM_PNULL != p_srv_cell_info);
    RRM_UT_TRACE_ENTER();
    p_rrm_gbl_ctx = (rrm_global_context_t *)qvThisContext();
    RRM_ASSERT (RRM_PNULL != p_rrm_gbl_ctx);
    /* Coverity 88360 Fix Start */
    if (RRM_PNULL == p_rrm_gbl_ctx)
    {
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"p_rrm_gbl_ctx is null");
        /* SPR 21251 End */
        return RRM_FALSE;
    }
    /* Coverity 88360 Fix End */
    p_cell_ctx = p_rrm_gbl_ctx->p_rrm_cell_ctx[p_srv_cell_info->cellindex];
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    if( (p_srv_cell_info->bitmask & RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT) ||
            (p_srv_cell_info->bitmask & RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT) ||
            (p_srv_cell_info->bitmask & RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT) )
    {
        if( RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            over_load = p_srv_cell_info->over_load_lvl_act.load_perctg;
        }
        else if( RRM_CELLM_OVERLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask )
        {
            over_load = p_cell_ctx->cell_load_action.u.comp_load_info.over_load.percent;
        }
        if( RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            high_load = p_srv_cell_info->high_load_lvl_act.load_perctg;
        }
        else if( RRM_CELLM_HIGHLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask )
        {
            high_load = p_cell_ctx->cell_load_action.u.comp_load_info.high_load.percent;
        }
        if( RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT & p_srv_cell_info->bitmask )
        {
            mid_load = p_srv_cell_info->mid_load_lvl_act.load_perctg;
        }
        else if( RRM_CELLM_MIDLOAD_PRESENT & p_cell_ctx->cell_load_action.u.comp_load_info.bitmask )
        {
            mid_load = p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.percent;
        }  
        ret_val = rrm_check_load_perctg( over_load, high_load, mid_load );
    }
    else
    {
        /*klock_works_changes_start*/
        ret_val = check_resrc_specific_info(p_srv_cell_info, p_cell_ctx);
        /*klock_works_changes_end*/
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*klock_works_changes_start*/
rrm_return_et
    rrm_cellm_update_load_config_params_process_msg
(
 rrmcm_rmif_load_config_req_t                    *p_rrmcm_rmif_load_config_req, 
 rrm_cell_context_t                              *p_cell_ctx, 
 rrm_bool_et                                     *self_ld_rpt_tmr_chng, 
 rrm_bool_et                                     *nbr_ld_rpt_tmr_chng, 
 rrmcm_rmif_generic_non_cell_specific_api_resp_t *resp,
 U16                                             api_id
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

    if (RRMCM_RMIF_LOAD_RPT_INTRVL & p_rrmcm_rmif_load_config_req->bitmask)
    {
        if (p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO] !=
                p_rrmcm_rmif_load_config_req->load_rpt_intrvl)
        {
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO] =
                p_rrmcm_rmif_load_config_req->load_rpt_intrvl;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Updated CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO [%u]",
                    p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO]);
            *self_ld_rpt_tmr_chng = RRM_TRUE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                    "Ignoring Timer value CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO"
                    " [%u] as value provided equal to stored value",
                    p_rrmcm_rmif_load_config_req->load_rpt_intrvl);
        }
    }

    if (RRMCM_RMIF_NCL_LOAD_IND_INTRVL & p_rrmcm_rmif_load_config_req->bitmask)
    {
        if (p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO] != 
                p_rrmcm_rmif_load_config_req->ncl_load_ind_intrvl)
        {
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO] =
                p_rrmcm_rmif_load_config_req->ncl_load_ind_intrvl;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Updated CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO [%u]",
                    p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
            *nbr_ld_rpt_tmr_chng = RRM_TRUE;

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Ignoring Timer value"
                    " CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO [%u] as value"
                    " provided equal to stored value",
                    p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
        }
    }

    if (*self_ld_rpt_tmr_chng && !*nbr_ld_rpt_tmr_chng)
    {
        /* Only self reporting timer is updated */
        if (RRM_FAILURE == cellm_fsm_process_event(RRMCM_RMIF_CHNG_SELF_RPT_TMR_EVENT, p_cell_ctx))
        {
            ret_val = RRM_FAILURE;
            resp->fail_cause = RRM_ERR_INTERNAL_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm", api_id);
        }
    }
    else if (!*self_ld_rpt_tmr_chng && *nbr_ld_rpt_tmr_chng)
    {
        /* Only neighbour load reporting timer is updated */
        if (RRM_FAILURE == cellm_fsm_process_event(RRMCM_RMIF_CHNG_NBR_RPT_TMR_EVENT, p_cell_ctx))
        {
            ret_val = RRM_FAILURE;
            resp->fail_cause = RRM_ERR_INTERNAL_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm", api_id);
        }
    }
    else if (*self_ld_rpt_tmr_chng && *nbr_ld_rpt_tmr_chng)
    {
        /* Both neighbour load reporting and self timer is updated */
        if (RRM_FAILURE == cellm_fsm_process_event(RRMCM_RMIF_CHNG_BOTH_RPT_TMR_EVENT, p_cell_ctx))
        {
            ret_val = RRM_FAILURE;
            resp->fail_cause = RRM_ERR_INTERNAL_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm", api_id);
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*klock_works_changes_end*/
/****************************************************************************
 * Function Name  : rrm_cellm_load_config_req_req_process_msg
 * Inputs         : void *p_api :pointer to input API buffer
 *                : U16 api_id : api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : global context
 * Outputs        : FAILURE/SUCCESS
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes load config request
 ****************************************************************************/

rrm_return_et
rrm_cellm_load_config_req_process_msg(
        void *p_api, /*Input Api buffer*/
        U16 api_id /*Incoming Api id*/
        /*SPR 17777 +-*/
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;
#ifdef TDD_MODE_FLAG
    /*EICIC_TDD_CHANGES_START*/
    U8               abs_size = RRM_ZERO;
    U8               eicic_ret_val = RRM_SUCCESS;
    /*EICIC_TDD_CHANGES_END*/
#endif 
    rrmcm_rmif_load_config_req_t *p_rrmcm_rmif_load_config_req = RRM_PNULL;
    rrmcm_rmif_generic_non_cell_specific_api_resp_t resp;
    rrm_global_context_t    *p_rrm_gbl_ctx          = RRM_PNULL;
    rrm_cell_context_t      *p_cell_ctx             = RRM_PNULL;
    rrm_bool_et               ld_cfg_req_check      = RRM_FALSE;
    /*SPR 14248 start*/
/*spr_20555_changes_start*/
/*spr_20555_changes_end*/
    /*SPR 14248 end*/
    rrm_cell_index_t                      i         = RRM_ZERO;
    rrm_bool_et             self_ld_rpt_tmr_chng    = RRM_FALSE;
    rrm_bool_et             nbr_ld_rpt_tmr_chng     = RRM_FALSE;
    rrm_bool_et             trigger_fsm_event       = RRM_FALSE;
    /* new_api_element_start */
    U8                    new_meas_abs_pattern[RRM_MAX_PATTERN_BYTE];
    U8                    ncl_count = RRM_ZERO;
    /* new_api_element_start */

    RRM_UT_TRACE_ENTER();

    p_rrmcm_rmif_load_config_req =(rrmcm_rmif_load_config_req_t *)p_api;


    p_rrm_gbl_ctx = (rrm_global_context_t *)qvThisContext();
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_LOAD_CONFIG_REQ->CellM");

    if(RRM_PNULL != p_rrm_gbl_ctx) /* Coverity: CID 23031 */
    {
        if ((RRMCM_RMIF_LOAD_RPT_INTRVL & p_rrmcm_rmif_load_config_req->bitmask) ||
                (RRMCM_RMIF_NCL_LOAD_IND_INTRVL & p_rrmcm_rmif_load_config_req->bitmask) || 
                (RRMCM_RMIF_LOAD_CHK_PRDCTY_PRESENT & p_rrmcm_rmif_load_config_req->bitmask) ||
                (RRMCM_RMIF_HIGH_ACT_RPT_LMT_PRESENT & p_rrmcm_rmif_load_config_req->bitmask))
        {
            for (i = RRM_ZERO; i < RRM_MAX_NUM_CELLS ; i++)
            {
                if (RRM_PNULL != p_rrm_gbl_ctx->p_rrm_cell_ctx[i])
                {
                    p_cell_ctx = p_rrm_gbl_ctx->p_rrm_cell_ctx[i];
                    SET_CELL_INDEX(p_cell_ctx->cell_index);
                    /*Coverity: CID 57592*/
                    /* Bug_8718_start */
                    /*New timer value will only be reconfigured if value is different from the previous value*/
                    if((p_rrmcm_rmif_load_config_req->bitmask & RRMCM_RMIF_LOAD_CHK_PRDCTY_PRESENT) &&
                            (p_cell_ctx->cell_load_action.ld_process_timer != p_rrmcm_rmif_load_config_req->load_chk_periodicity))
                    {
                        p_cell_ctx->cell_load_action.ld_process_timer = p_rrmcm_rmif_load_config_req->load_chk_periodicity;

                        /*As new load_config_req has been received, so reconfiguring the timer value, 
                          old one was either configured during cell setup or previous load config req*/
                        if(p_cell_ctx->cell_load_action.ld_process_timer_id)
                        {
                            cell_stop_timer (p_cell_ctx->cell_load_action.ld_process_timer_id);
                            /* SPR-17852 START */
                            p_cell_ctx->cell_load_action.ld_process_timer_id = RRM_PNULL;
                            /* SPR-17852 END */
                            rrm_cellm_start_ld_process_timer (p_cell_ctx);
                        }
                    }
                    if(p_rrmcm_rmif_load_config_req->bitmask & RRMCM_RMIF_HIGH_ACT_RPT_LMT_PRESENT)
                    {
                        p_cell_ctx->cell_load_action.high_actn_applied_lmt = p_rrmcm_rmif_load_config_req->high_actn_repeat_lmt;
                    }
                    /* SPR 20653 Fix Start */
                    if(p_rrmcm_rmif_load_config_req->bitmask & RRMCM_RMIF_TNL_LOAD_SUPPORT_FLAG_PRESENT)
                    {
                        p_cell_ctx->cell_load_action.tnl_load_support_flag = p_rrmcm_rmif_load_config_req->tnl_load_support_flag;
                    }
                    if(p_rrmcm_rmif_load_config_req->bitmask & RRMCM_RMIF_HW_LOAD_SUPPORT_FLAG_PRESENT)
                    {
                        p_cell_ctx->cell_load_action.hw_load_support_flag = p_rrmcm_rmif_load_config_req->hw_load_support_flag;
                    }
                    /* SPR 20653 Fix End */
                    /* Bug_8718_end */

                    if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
                    {
                        if (RRMCM_RMIF_LOAD_RPT_INTRVL & p_rrmcm_rmif_load_config_req->bitmask)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                    "Ignoring Timer value CELL_PERIODIC_TIMER_FOR_SELF_LOAD_INFO"
                                    " [%u] as MLB has registered for this cell idx[%u]",
                                    p_rrmcm_rmif_load_config_req->load_rpt_intrvl, p_cell_ctx->cell_index);
                        }
                        if (RRMCM_RMIF_NCL_LOAD_IND_INTRVL & p_rrmcm_rmif_load_config_req->bitmask)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                                    "Ignoring Timer value CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO"
                                    " [%u] as MLB has registered for this cell idx[%u]",
                                    p_rrmcm_rmif_load_config_req->load_rpt_intrvl, p_cell_ctx->cell_index);
                        }
                        continue;
                    }

                    /*klock_works_changes_start*/             
                    ret_val=rrm_cellm_update_load_config_params_process_msg(p_rrmcm_rmif_load_config_req, p_cell_ctx, &self_ld_rpt_tmr_chng,
                            &nbr_ld_rpt_tmr_chng,&resp,api_id);                 
                    /*klock_works_changes_end*/
                }

            }
        }


        for (i = RRM_ZERO; i < p_rrmcm_rmif_load_config_req->num_of_cell; i++)
        {
            /** eICIC_PHASE_1_2_CHANGES_START */
            p_cell_ctx = p_rrm_gbl_ctx->p_rrm_cell_ctx[p_rrmcm_rmif_load_config_req->srv_cell_info[i].cellindex];

#ifdef TDD_MODE_FLAG
            /*EICIC_TDD_CHANGES_START*/
            if((p_cell_ctx->ran_info.bitmask & RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT)&& 
                    (p_cell_ctx->ran_info.physical_layer_params.bitmask  & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT))
            {    
                abs_size = rrm_find_abs_frame_size(& p_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                        " return failure as physical_layer_param_tdd_frame_structur is not present for TDD")
                    eicic_ret_val = RRM_FAILURE;
            }    
            if((p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask & RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT)&& 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].over_load_lvl_act.bitmask & RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT) && 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].over_load_lvl_act.eicic_load_config.bitmask & RRMCM_RMIF_ABS_PATTERN_PRESENT)) 
            {
                if( RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_rrmcm_rmif_load_config_req->srv_cell_info[i].over_load_lvl_act.eicic_load_config.
                            abs_pattern,abs_size))
                {
                    eicic_ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.")
                }    
            }    
            if((p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask & RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT)&& 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].high_load_lvl_act.bitmask & RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT) && 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].high_load_lvl_act.eicic_load_config.bitmask & RRMCM_RMIF_ABS_PATTERN_PRESENT)) 
            {
                if( RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_rrmcm_rmif_load_config_req->srv_cell_info[i].high_load_lvl_act.eicic_load_config.
                            abs_pattern,abs_size))
                {
                    eicic_ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.");
                }    
            }    
            if((p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask & RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT)&& 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].mid_load_lvl_act.bitmask & RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT) && 
                    (p_rrmcm_rmif_load_config_req->srv_cell_info[i].mid_load_lvl_act.eicic_load_config.bitmask & RRMCM_RMIF_ABS_PATTERN_PRESENT)) 
            {
                if( RRM_FAILURE == rrm_validate_abs_pattern_for_tdd( p_rrmcm_rmif_load_config_req->srv_cell_info[i].mid_load_lvl_act.eicic_load_config.
                            abs_pattern,abs_size))
                {
                    eicic_ret_val = RRM_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            " returning failure as the no. of bits for abs_pattern exceeds for the present tdd configuration.");
                }    
            }    
            if(eicic_ret_val == RRM_FAILURE)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "CELLM: Returning FAILURE as abs PATTERN is not as per the TDD config");
                ret_val = RRM_FAILURE;
                resp.fail_cause = RRM_ERR_INVALID_PARAMS;
                break;
            }
            /*EICIC_TDD_CHANGES_END*/ 
#endif           
            /*13961_fix_start*/ 
            if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR )
            /*13961_fix_end*/
            {
                if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_OVERLOAD && (p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask &
                            RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT))
                {
                    if(RRM_ZERO != RRM_MEMCMP(p_rrmcm_rmif_load_config_req->srv_cell_info[i].over_load_lvl_act.eicic_load_config.abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE))
                    {
                        trigger_fsm_event = RRM_TRUE;
                        p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CTXT_COMP_OVERLOAD_ABS_RECONFIG_PRESENT;
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.over_load.eicic_load_config.abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                    }    
                }        

                if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_HIGH && (p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask &
                            RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT))
                {   /*13961_fix_start*/
                    if(RRM_ZERO != RRM_MEMCMP(p_rrmcm_rmif_load_config_req->srv_cell_info[i].high_load_lvl_act.eicic_load_config.abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE))
                        /*13961_fix_end*/ 
                    {
                        trigger_fsm_event = RRM_TRUE;
                        p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CTXT_COMP_HIGHLOAD_ABS_RECONFIG_PRESENT;
                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.high_load.eicic_load_config.abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                    }    
                }        

                if(p_cell_ctx->cell_load_action.u.comp_load_info.curr_load_lvl == RRM_MEDIUM && (p_rrmcm_rmif_load_config_req->srv_cell_info[i].bitmask &
                            RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT))
                {
                    /*13961_fix_start*/ 
                    if(RRM_ZERO != RRM_MEMCMP(p_rrmcm_rmif_load_config_req->srv_cell_info[i].mid_load_lvl_act.eicic_load_config.abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,RRM_MAX_PATTERN_BYTE))
                        /*13961_fix_end*/
                    {
                        trigger_fsm_event = RRM_TRUE;
                        p_cell_ctx->rrm_eicic_cell_info.bitmask |= RRM_CTXT_COMP_MIDLOAD_ABS_RECONFIG_PRESENT;
                        RRM_MEMCPY(p_cell_ctx->rrm_eicic_cell_info.temp_load_config_abs_pattern,
                                p_cell_ctx->cell_load_action.u.comp_load_info.mid_load.eicic_load_config.abs_pattern,
                                RRM_MAX_PATTERN_BYTE);
                    }    
                }        


            }
            /* SPR 20653 Fix Start */
            /* Code removed */
            /* SPR 20653 Fix End */
            /** eICIC_PHASE_1_2_CHANGES_END */

            ld_cfg_req_check = rrm_verify_load_cfg_req_from_mif (&p_rrmcm_rmif_load_config_req->srv_cell_info[i]);

            /*SPR 14248 start*/
/*spr_20555_changes_start*/
/*code deleted*/
/*spr_20555_changes_end*/
            /*SPR 14248 end*/
/*spr_20555_changes_start*/
            if (RRM_TRUE == ld_cfg_req_check)
/*spr_20555_changes_end*/
            {
                rrm_populate_load_actn_in_cell_context (&p_rrmcm_rmif_load_config_req->srv_cell_info[i]);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "CELLM: Overload/Highload/Midload Should be in decending order or abs pattern should be subset of its subsequent higher load");
                ret_val = RRM_FAILURE;
                resp.fail_cause = RRM_ERR_INVALID_PARAMS;
                break;
            }
            /** eICIC_PHASE_1_2_CHANGES_START */
            if(trigger_fsm_event == RRM_TRUE)
            {    
                if (RRM_FAILURE == cellm_fsm_process_event(RRM_MAC_EICIC_ABS_RECONFIG_REQ_EVENT, p_cell_ctx))
                {
                    ret_val = RRM_FAILURE;
                    resp.fail_cause = RRM_ERR_INTERNAL_FAILURE;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, "could not process api id %d in fsm", api_id);
                }
            }
            /* new_api_element_start */
            else
            {
                if ( (RRM_TRUE == rrm_cellm_is_aggressor_node(p_cell_ctx)) &&
                        (RRM_SUCCESS == rrm_cellm_get_highest_load_abs(p_cell_ctx,new_meas_abs_pattern)))
                { 
                    if(RRM_ZERO != RRM_MEMCMP(p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                                new_meas_abs_pattern, RRM_MAX_ABS_PATTERN_BYTE_FDD))
                    {
                        RRM_MEMSET( p_cell_ctx->rrm_eicic_cell_info.temp_meas_abs_pattern, RRM_ZERO,
                                RRM_MAX_PATTERN_BYTE );                                         
                        RRM_MEMCPY( p_cell_ctx->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                                new_meas_abs_pattern,RRM_MAX_ABS_PATTERN_BYTE_FDD );
                        // inform victims  
                        for(ncl_count = RRM_ZERO; 
                                ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell ; 
                                ncl_count++)
                        {
                            if( (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent == RRM_SEND_ABS_PATTERN ) ||
                                    ( p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                      abs_info_sent == RRM_EICIC_ABS_PATTERN ))
                            {
                                /* bug_13898_start */
                                if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                            p_cell_ctx,LOAD_INFO_EICIC_ABS_PATTERN,ncl_count))
                                    /* bug_13898_end */
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Successfully shared ABS pattern with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                                        abs_info_sent = RRM_EICIC_ABS_PATTERN ;
                                    /* bug_14010_start */  
                                    if( ABS_USAGE_NONE == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.                   abs_usage_rep_status)

                                    {
                                        rrm_hndl_rsu_stop_req_for_ncl( p_cell_ctx,
                                                &(p_cell_ctx->ran_info.ncl_params.lte_ncl.
                                                    intra_freq_cells[ncl_count]));

                                        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                                        {
                                            if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctx,ncl_count,
                                                        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO],
                                                        /*Bug 586 Changes Start*/

                                                        RRM_TRUE))
                                                /*Bug 586 Changes End*/
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                        "Successfuly sent ABS reporting in RSR start req to Target Cell[%d]",
                                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_START;
                                            }
                                            else
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                                        "Unable to send ABS reporting in RSR start req to Target Cell[%d]",
                                                        p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                                            }
                                        }
                                    }
                                    else
                                    {

                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                                "RSU is already started for NCL_COUNT[%d] and PCI [%d]",
                                                ncl_count,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    }
                                    /* bug_14010_end */  
                                }
                                else
                                {
                                    /* SPR 21251 Start */
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Unable to share ABS pattern with Neighbour[%d]",
                                            p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                    /* SPR 21251 End */
                                }
                            }
                        }
                    }
                }

            }
            /* new_api_element_end */
            /** eICIC_PHASE_1_2_CHANGES_END */
        }

        resp.transaction_id = p_rrmcm_rmif_load_config_req->transaction_id;
        if (RRM_SUCCESS == ret_val)
        {
            resp.response = RRM_SUCCESS;
            resp.fail_cause = RRM_NO_ERROR;
        }
        else
        {
            resp.response = RRM_FAILURE;
        }

        ret_val = rrm_send_internal_msg(
                RRM_MIF_MODULE_ID,
                RRMCM_RMIF_LOAD_CONFIG_RESP,
                sizeof(rrmcm_rmif_generic_non_cell_specific_api_resp_t),
                (void *)&resp);
        if(ret_val == RRM_SUCCESS)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Successfully send load config resp to MIF");

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Failed to send load config resp to MIF");
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "p_rrm_gbl_ctx is NULL");
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


x2ap_rrm_rsu_load_indicator_et
    rrm_map_x2_load_lvl
(
 rrm_x2ap_rsu_load_ind_et load_lvl
 )
{
    x2ap_rrm_rsu_load_indicator_et x2_load_lvl;
    switch(load_lvl)
    {
        case RRM_X2AP_RSU_LOAD_LOW:
            x2_load_lvl = X2AP_RRM_RSU_LOAD_LOW;
            break;

        case RRM_X2AP_RSU_LOAD_MEDIUM:
            x2_load_lvl = X2AP_RRM_RSU_LOAD_MEDIUM;
            break;

        case RRM_X2AP_RSU_LOAD_HIGH:
            x2_load_lvl = X2AP_RRM_RSU_LOAD_HIGH;
            break;

        case RRM_X2AP_RSU_LOAD_OVER:
            x2_load_lvl = X2AP_RRM_RSU_LOAD_OVER;
            break;

        default:
            /* Should never reach here */
            x2_load_lvl = X2AP_RRM_RSU_LOAD_OVER;
            break;
    }

    return x2_load_lvl;
}



rrm_return_et
    rrm_send_rsu_to_neighbour
(
 U32 meas_id
 )
{
    rrm_global_context_t                *p_rrm_glb_ctx;
    rrm_rsu_meas_srv_cell_info_node_t   *p_srv_cell_info;
    rrm_cell_context_t                  *p_cell_ctxt=RRM_NULL;
    /*Initialized, rel 2.0.1, aditya, 29756*/
    x2ap_rrm_rsu_rrm_update_t           rsu = {RRM_ZERO};
    x2ap_rrm_rsu_info_t                 *p_rsu_info=RRM_NULL;
    U32                                 i = RRM_NULL;
    U32                                 j = RRM_NULL;
    rrm_cell_index_t                    cell_idx;
    rrm_return_et                       ret_val = RRM_SUCCESS;
    rrm_cell_meas_gb_t                  p_key   = {RRM_ZERO};
    RRM_UT_TRACE_ENTER();
    YHNODE *p_hnode = RRM_PNULL;
    /*MY_FIX*/
#ifdef TDD_MODE_FLAG     
    U8 abs_size = RRM_ZERO; 
#endif
    p_rrm_glb_ctx = p_g_rrm_cell_ctx;

    p_key.meas_id = meas_id;
    /*Need to fill the g_enb_id*/
    /* p_key.g_enb_id; */
    /* Coverity CID 100113 Fix Start */	
    p_hnode = yhFind((const YHASH *)&(p_rrm_glb_ctx->rsu_measid_serving_hash_tbl),
            (rrm_void_t *)&(p_key));
    /* Coverity CID 100113 Fix Start */	

    if(RRM_PNULL != p_hnode)
    {
        p_srv_cell_info =(rrm_rsu_meas_srv_cell_info_node_t *)p_hnode;
        if(RRM_PNULL == p_srv_cell_info->timer_id)
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "RRM Serving cell Timer Id is Invalid" );
            /* SPR 21251 End */
            return RRM_FAILURE;
        }
        rsu.enb_meas_id = meas_id;
        rrm_fill_x2_gb_enb_id(&rsu.peer_gb_enb_id, &(p_srv_cell_info->rsu_id.g_enb_id));
        rsu.num_reports = RRM_ZERO;

        for (i = RRM_ZERO; i < sizeof(p_srv_cell_info->serving_cell)/sizeof(p_srv_cell_info->serving_cell[RRM_ZERO]); i++)
        {
            if (RRM_ZERO != p_srv_cell_info->serving_cell[i])
            {
                /*+Coverity :CID 25354 +*/
                /* This byte contain information */
                /*klok_fix_start_7286*/
                for (j = RRM_ZERO; j <  RRM_MAX_NUM_CELLS ; j++)
                {
                    cell_idx = (i * RRM_MAX_NUM_CELLS) + j;
                    /*klok_fix_end_7286*/
                    /*-Coverity :CID 25354 -*/
                    if (RRM_TRUE == rrm_is_bitset(p_srv_cell_info->serving_cell, cell_idx))
                    {
                        /*coverity 25209 : check for range added, aditya rel 2.0*/
                        /*klok_fix_start_7286*/
                        if ((cell_idx < RRM_MAX_NUM_CELLS) && (RRM_NULL != p_rrm_glb_ctx->p_rrm_cell_ctx[cell_idx]) && 
                                (rsu.num_reports < RRM_MAX_NUM_CELLS))
                        {
                            /*klok_fix_end_7286*/
                            p_cell_ctxt = p_rrm_glb_ctx->p_rrm_cell_ctx[cell_idx];
                            p_rsu_info = & rsu.rsu_report[rsu.num_reports].rsu_info;
                            rrm_fill_x2_gb_cid(&rsu.rsu_report[rsu.num_reports].cell_info, &p_cell_ctxt->global_cell_id);
                            p_rsu_info->bitmask = RRM_ZERO;
                            /* SPR 14465 start */
                            /*SPR 18994 START*/
                            if ((RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask) && 
                                    (RRM_FALSE != rrm_check_set_report_charaterstics
                                     (&p_srv_cell_info->report_characteristics,
                                      RRM_PRB_REPORT_CHAR_SET)))
                            {
                                /* SPR 14465 end */
                                p_rsu_info->bitmask |= PRB_PERIODIC_REPORT_PRESENT;
                                p_rsu_info->radio_resource_status.dl_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.dl_gbr_prb_usage;
                                p_rsu_info->radio_resource_status.ul_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.ul_gbr_prb_usage;
                                p_rsu_info->radio_resource_status.dl_non_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage;
                                p_rsu_info->radio_resource_status.ul_non_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage;
                                p_rsu_info->radio_resource_status.dl_total_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.dl_total_prb_usage;
                                p_rsu_info->radio_resource_status.ul_total_gbr_prb_usage = p_cell_ctxt->svr_cell_load_info.rr_load.ul_total_prb_usage;
                            }

                            /* SPR 14465 start */
                            if ((RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT &  p_cell_ctxt->svr_cell_load_info.bitmask) && 
                                    (RRM_FALSE != rrm_check_set_report_charaterstics
                                     (&p_srv_cell_info->report_characteristics,
                                      RRM_TNL_LOAD_REPORT_CHAR_SET)))
                            {
                                /* SPR 14465 end */
									p_rsu_info->bitmask |= TNL_LOAD_IND_PERIODIC_REPORT_PRESENT;
									p_rsu_info->s1_tnl_load_indicator.dl_s1_tnl_load_indicator =
										rrm_map_x2_load_lvl(p_cell_ctxt->svr_cell_load_info.tnl_ld_lvl);
									p_rsu_info->s1_tnl_load_indicator.ul_s1_tnl_load_indicator = 
										rrm_map_x2_load_lvl(p_cell_ctxt->svr_cell_load_info.tnl_ld_lvl);
								}
                            /*SPR 20622 Fix Start*/
                            else if ((RRM_FALSE != rrm_check_set_report_charaterstics
                                        (&p_srv_cell_info->report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET))&&
                                    /* SPR 20653 Fix Start */
                                    (RRM_TRUE == p_cell_ctxt->cell_load_action.tnl_load_support_flag))
                                /* SPR 20653 Fix End */
                            {
                                p_rsu_info->bitmask |= TNL_LOAD_IND_PERIODIC_REPORT_PRESENT;
                                p_rsu_info->s1_tnl_load_indicator.dl_s1_tnl_load_indicator = X2AP_RRM_RSU_LOAD_LOW;
                                p_rsu_info->s1_tnl_load_indicator.ul_s1_tnl_load_indicator = X2AP_RRM_RSU_LOAD_LOW;
                            }
                            else
                            {
                                /* SPR 21251 Start */
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "LTE RRM not support TNL load report");
                                /* SPR 21251 End */

                            }
                            /*SPR 20622 Fix Stop*/

							/* SPR 14465 start */
                            if ((RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask) &&
                                    (RRM_FALSE != rrm_check_set_report_charaterstics
                                     (&p_srv_cell_info->report_characteristics,
                                      RRM_HW_LOAD_REPORT_CHAR_SET)) ) 
								{
									/* SPR 14465 end */
									p_rsu_info->bitmask |= LOAD_IND_PERIODIC_REPORT_PRESENT;
									p_rsu_info->hardware_load_indicator.dl_hardware_load_indicator =
										rrm_map_x2_load_lvl(p_cell_ctxt->svr_cell_load_info.hw_ld_lvl);
									p_rsu_info->hardware_load_indicator.ul_hardware_load_indicator =
										rrm_map_x2_load_lvl(p_cell_ctxt->svr_cell_load_info.hw_ld_lvl);
								}
                            /*SPR 20622 Fix Start*/
                            else if((RRM_FALSE != rrm_check_set_report_charaterstics
                                        (&p_srv_cell_info->report_characteristics,
                                         RRM_HW_LOAD_REPORT_CHAR_SET))&&
                                    /* SPR 20653 Fix Start */
                                    (RRM_TRUE == p_cell_ctxt->cell_load_action.hw_load_support_flag))
                                /* SPR 20653 Fix End */
                            {
                                p_rsu_info->bitmask |= LOAD_IND_PERIODIC_REPORT_PRESENT;
                                p_rsu_info->hardware_load_indicator.dl_hardware_load_indicator = X2AP_RRM_RSU_LOAD_LOW;
                                p_rsu_info->hardware_load_indicator.ul_hardware_load_indicator = X2AP_RRM_RSU_LOAD_LOW;
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "LTE RRM not support HW load report");
                            }
                            /*SPR 20622 Fix Stop*/

							/* SPR 14465 start */
							if ((RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT &  p_cell_ctxt->svr_cell_load_info.bitmask) && 
                                    (RRM_FALSE != rrm_check_set_report_charaterstics
                                     (&p_srv_cell_info->report_characteristics,
                                      RRM_COMPOSITE_CAPACITY_REPORT_CHAR_SET)))
							{
								/* SPR 14465 end */
								p_rsu_info->bitmask |= COMPOSITE_AVAILABLE_CAPACITY_PERIODIC_REPORT_PRESENT;
								p_rsu_info->composite_available_capacity_group.dl_composite_available_capacity.bitmask = RRM_ZERO;
								if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT &  p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.bitmask)
								{
									p_rsu_info->composite_available_capacity_group.dl_composite_available_capacity.bitmask =
										CELL_CAPACITY_CLASS_VALUE_PRESENT;
									p_rsu_info->composite_available_capacity_group.dl_composite_available_capacity.cell_capacity_class_value =
										p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_class_val;
								}
								p_rsu_info->composite_available_capacity_group.dl_composite_available_capacity.cell_capacity_value =
									p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val;

								if(RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.bitmask)
								{
									p_rsu_info->composite_available_capacity_group.ul_composite_available_capacity.bitmask =
										CELL_CAPACITY_CLASS_VALUE_PRESENT;
									p_rsu_info->composite_available_capacity_group.ul_composite_available_capacity.cell_capacity_class_value =
										p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_class_val;
								}

								p_rsu_info->composite_available_capacity_group.ul_composite_available_capacity.cell_capacity_value =
									p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val;
							}
							/* eICIC_PHASE_1_2_CHANGES_START */
							/* SPR 14465 start */
                            /*SPR 20622 Fix Start*/
                            /*SPR 21234 Fix Start*/
                            if ((RRM_FALSE != rrm_check_set_report_charaterstics
                                     (&p_srv_cell_info->report_characteristics,
                                         RRM_ABS_STATUS_REPORT_CHAR_SET)) && 
                                    (RRM_ABS_STATUS_INFO_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask))
								{
									p_rsu_info->bitmask |= ABS_STATUS_PERIODIC_REPORT_PRESENT;
									p_rsu_info->abs_status.dl_abs_status = p_cell_ctxt->svr_cell_load_info.abs_status.dl_abs_status;
									p_rsu_info->abs_status.x2ap_usable_abs_information.bitmask = RRM_ZERO;
									/* SPR 14465 end */
#ifndef TDD_MODE_FLAG
									p_rsu_info->abs_status.x2ap_usable_abs_information.bitmask |= X2AP_USABLE_ABS_INFORMATION_FDD_PRESENT;
									RRM_MEMCPY( p_rsu_info->abs_status.x2ap_usable_abs_information.
											usable_abs_info_fdd.usable_abs_pattern_fdd_info , 
											p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied , RRM_MAX_ABS_PATTERN_BYTE_FDD);
#else
									abs_size = rrm_find_abs_frame_size(& p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);		

									p_rsu_info->abs_status.x2ap_usable_abs_information.bitmask |= X2AP_USABLE_ABS_INFORMATION_TDD_PRESENT;
									RRM_MEMCPY( p_rsu_info->abs_status.x2ap_usable_abs_information.
											usable_abs_info_tdd.usable_abs_pattern_tdd_info , 
											p_cell_ctxt->rrm_eicic_cell_info.usable_abs_pattern_applied ,abs_size);
									rrm_copy_tdd_bits(abs_size,p_rsu_info->abs_status.x2ap_usable_abs_information.
											usable_abs_info_tdd.usable_abs_pattern_tdd_info);
#endif
								}
                            /*SPR 21234 Fix Stop*/
							}
							/* SPR 19614 Fix End */
              /* eICIC_PHASE_1_2_CHANGES_END */
							rsu.num_reports++;
						}
					}
				}
			}
		}
    if(RRM_NULL != p_cell_ctxt)
    {
        if (RRM_SUCCESS != rrm_il_send_x2ap_rrm_rsu_rrm_update (&rsu, RRM_MODULE_ID, RRC_MODULE_ID, RRM_ZERO,p_cell_ctxt->cell_index))
        {
            ret_val = RRM_FAILURE;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Cannot send update for measId [%u]", meas_id);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "RRM Successfully Sent rrm_x2apRrm_il_send_x2ap_rrm_rsu_rrm_update to peer");
        }
    }
    else
    {
        /* SPR 21251 Start*/
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                         "p_cell_context is Null");
         /* SPR 21251 End */
    }

	RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_get_max_val 
 * Inputs         : x
 *                  y
 * Outputs        : None
 * Returns        : U8 
 * Description    : Returns Max of x and y.
 ****************************************************************************/
 U8 rrm_get_max_val (U8 x, U8 y)
{
	return ((x > y)? (x):(y));
}

/****************************************************************************
 * Function Name  : rrm_get_total_ul_resrc_spec_cell_load 
 * Inputs         : rrm_rs_srv_cell_ld_info_t *p_srv_load
 * Outputs        : None
 * Returns        : U8 (1-100)
 * Description    : Returns the ul total Resource Specific load.
 ****************************************************************************/
U8 rrm_get_total_ul_resrc_spec_cell_load (rrm_rs_srv_cell_ld_info_t *p_srv_load)
{
	U8 total_ul_ld = RRM_NULL;
	U8 prb_ul_ld = RRM_NULL;
	U8 tnl_ul_ld = RRM_NULL;
	U8 hw_ul_ld = RRM_NULL;

	RRM_ASSERT(RRM_PNULL != p_srv_load);
	RRM_UT_TRACE_ENTER();
	if (p_srv_load->bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
	{
		prb_ul_ld = p_srv_load->rr_load.ul_total_prb_usage;
	}
	if (p_srv_load->bitmask & RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT)
	{
		tnl_ul_ld = p_srv_load->s1_tnl_load;
	}
	if (p_srv_load->bitmask & RRM_HW_LOAD_PERIODIC_REPORT_PRESENT)
	{
		hw_ul_ld = p_srv_load->hw_load;
	}
	total_ul_ld = rrm_get_max_val (prb_ul_ld, tnl_ul_ld);
	total_ul_ld = rrm_get_max_val (total_ul_ld, hw_ul_ld);
	return total_ul_ld;
}

/****************************************************************************
 * Function Name  : rrm_get_total_dl_resrc_spec_cell_load 
 * Inputs         : rrm_rs_srv_cell_ld_info_t *p_srv_load
 * Outputs        : None
 * Returns        : U8 (1-100)
 * Description    : Returns the dl total Resource Specific load.
 ****************************************************************************/
U8 rrm_get_total_dl_resrc_spec_cell_load (rrm_rs_srv_cell_ld_info_t *p_srv_load)
{
	U8 total_dl_ld = RRM_NULL;
	U8 prb_dl_ld = RRM_NULL;
	U8 tnl_dl_ld = RRM_NULL;
	U8 hw_dl_ld = RRM_NULL;

	RRM_ASSERT(RRM_PNULL != p_srv_load);
	RRM_UT_TRACE_ENTER();
	if (p_srv_load->bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
	{
		prb_dl_ld = p_srv_load->rr_load.dl_total_prb_usage;
	}
	if (p_srv_load->bitmask & RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT)
	{
		tnl_dl_ld = p_srv_load->s1_tnl_load;
	}
	if (p_srv_load->bitmask & RRM_HW_LOAD_PERIODIC_REPORT_PRESENT)
	{
		hw_dl_ld = p_srv_load->hw_load;
	}
	total_dl_ld = rrm_get_max_val (prb_dl_ld, tnl_dl_ld);
	total_dl_ld = rrm_get_max_val (total_dl_ld, hw_dl_ld);
	return total_dl_ld;
}

/****************************************************************************
 * Function Name  : rrm_get_total_resrc_spec_cell_load 
 * Inputs         : rrm_rs_srv_cell_ld_info_t *p_srv_load
 * Outputs        : None
 * Returns        : U8 (1-100)
 * Description    : Returns the total Resource Specific load.
 ****************************************************************************/
U8 rrm_get_total_resrc_spec_cell_load (rrm_rs_srv_cell_ld_info_t *p_srv_load)
{
	U8 cell_ld_ul = RRM_NULL;
	U8 cell_ld_dl = RRM_NULL;

	RRM_ASSERT(RRM_PNULL != p_srv_load);
	RRM_UT_TRACE_ENTER();
	cell_ld_ul = rrm_get_total_ul_resrc_spec_cell_load (p_srv_load);
	cell_ld_dl = rrm_get_total_dl_resrc_spec_cell_load (p_srv_load);    
	RRM_UT_TRACE_EXIT();
	return (rrm_get_max_val (cell_ld_ul, cell_ld_dl));
}

/****************************************************************************
 * Function Name  : rrm_fill_dl_comp_avl_cap_val
 * Inputs         : rrm_cell_context_t *p_cell_ctx 
 * Outputs        : None
 * Returns        : Void
 * Description    : Fill dl composite available capacity value in cell context.
 ****************************************************************************/
void rrm_fill_dl_comp_avl_cap_val (rrm_cell_context_t *p_cell_ctx)
{
	U8 total_dl_ld = RRM_NULL;
	rrm_rs_srv_cell_ld_info_t *p_srv_load = RRM_PNULL;
	RRM_ASSERT(RRM_PNULL != p_cell_ctx);
	RRM_UT_TRACE_ENTER();
	p_srv_load = &(p_cell_ctx->svr_cell_load_info);
	total_dl_ld = rrm_get_total_dl_resrc_spec_cell_load (p_srv_load);
	p_srv_load->comp_avl_cap_grp.dl.cell_cap_val = (RRM_MAX_AVLB_CAPCTY - total_dl_ld);
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_fill_ul_comp_avl_cap_val 
 * Inputs         : rrm_cell_context_t *p_cell_ctx 
 * Outputs        : None
 * Returns        : Void
 * Description    : Fill ul composite available capacity value in cell context.
 ****************************************************************************/
void rrm_fill_ul_comp_avl_cap_val (rrm_cell_context_t *p_cell_ctx)
{
	U8 total_ul_ld = RRM_NULL;
	rrm_rs_srv_cell_ld_info_t *p_srv_load = RRM_PNULL;
	RRM_ASSERT(RRM_PNULL != p_cell_ctx);
	RRM_UT_TRACE_ENTER();
	p_srv_load = &(p_cell_ctx->svr_cell_load_info);
	total_ul_ld = rrm_get_total_ul_resrc_spec_cell_load (p_srv_load);
	p_srv_load->comp_avl_cap_grp.ul.cell_cap_val = (RRM_MAX_AVLB_CAPCTY - total_ul_ld);
	RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_get_total_comp_cell_load
 * Inputs         : rrm_rs_srv_cell_ld_info_t *p_srv_load
 * Outputs        : None
 * Returns        : U8 (1 to 100)
 * Description    : Returns total Composite load of  the cell.
 ****************************************************************************/
U8 rrm_get_total_comp_cell_load (rrm_rs_srv_cell_ld_info_t *p_srv_load)
{
    U8 cell_total_ld = RRM_NULL;
    U8 total_dl_ld = RRM_NULL;
    U8 total_ul_ld = RRM_NULL;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT (RRM_PNULL != p_srv_load);
    total_ul_ld = rrm_get_total_ul_resrc_spec_cell_load (p_srv_load);
    total_dl_ld = rrm_get_total_dl_resrc_spec_cell_load (p_srv_load);
    cell_total_ld = rrm_get_max_val (total_ul_ld, total_dl_ld);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Cell load value [%d]", cell_total_ld);

    RRM_UT_TRACE_EXIT();
    return cell_total_ld;
}

void
check_bitmask_and_calc_load_value
(
 rrm_cell_load_action_t *p_load_lvl, 
 U8                     *count, 
 rrm_load_type          *load_lvl, 
 U8                     *load_val
)
{
    RRM_UT_TRACE_ENTER();

	if(p_load_lvl->bitmask & RRM_CELLM_MIDLOAD_PRESENT)
	{
		if (*count < INVALID_LOAD)
		{
			load_val[*count] = p_load_lvl->mid_load.percent;
			load_lvl[*count] = RRM_MEDIUM;
			(*count)++;
		}
	}

	if(p_load_lvl->bitmask & RRM_CELLM_HIGHLOAD_PRESENT)
	{
		if (*count < INVALID_LOAD)
		{
			load_val[*count] =  p_load_lvl->high_load.percent;
			load_lvl[*count] = RRM_HIGH;
			(*count)++;
		}
	}

	if(p_load_lvl->bitmask & RRM_CELLM_OVERLOAD_PRESENT)
	{
		if (*count < INVALID_LOAD)
		{
			load_val[*count] = p_load_lvl->over_load.percent;
			load_lvl[*count] = RRM_OVERLOAD;
			(*count)++;
		}
	}
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_get_cur_load_level 
 * Inputs         : rrm_cell_load_action_t *p_ld_actn
 *                : cur_ld: Cell current load
 * Outputs        : None
 * Returns        : cell load type (cell load level)
 * Description    : Get current cell load level
 ****************************************************************************/
rrm_load_type 
rrm_get_cur_load_level (rrm_cell_load_action_t *p_load_lvl, U8 cur_ld)
{
	rrm_load_type load_lvl[INVALID_LOAD];
	U8 load_val[INVALID_LOAD];
	U8            count                 = RRM_ZERO;
	U8            i                     = RRM_ZERO;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT(RRM_PNULL != p_load_lvl);
    /*Coverity 61364 Fix Start*/
    /* Initializing with the lowest load level */
    load_val[count] = RRM_ZERO;
    load_lvl[count] = RRM_LOW;
    count++;
    /*Coverity 61364 Fix End*/
    
    /*klock_works_changes_start*/
    check_bitmask_and_calc_load_value(p_load_lvl, &count, load_lvl, load_val);
    /*klock_works_changes_end*/

	if (RRM_ONE == count)
	{
		/* None of the loads above Low is defined */
		RRM_UT_TRACE_EXIT();
        return load_lvl[RRM_ZERO];
	}

	for (i = RRM_ONE; i < count; i++)
	{
		if (cur_ld < load_val[i])
		{
			RRM_UT_TRACE_EXIT();
			return load_lvl[i - RRM_ONE];
		}
	}

    /*+Covertiy :CID 25680 +*/
	if ((cur_ld > load_val[i - RRM_ONE]))
    /*-Covertiy :CID 25680 -*/
	{
		/* Current load level is above the load levels defined hence considering
		 * it to be an overload case 
		 */
		RRM_UT_TRACE_EXIT();
		return RRM_OVERLOAD;
	}

	/* Current load level is equal to the load defined */
	RRM_UT_TRACE_EXIT();
	return load_lvl[i - RRM_ONE];
}

/****************************************************************************
 * Function Name  : rrm_handle_load_action
 * Inputs         : rrm_cell_load_action_t *p_ld_actn
 *                : ld_lvl: load label
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handle load action for the cell
 ****************************************************************************/
rrm_return_et rrm_handle_load_action 
(   rrm_cell_load_action_t *p_ld_actn,
    rrm_load_type ld_lvl,
    rrm_cell_context_t *p_cell_ctxt,
    U8 ld_choice,
    U8 resrc_cnt
    )
{
    U8 actn_cnt = RRM_NULL;
    U16 actn = RRM_NULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT (RRM_PNULL != p_ld_actn);
    RRM_ASSERT (RRM_PNULL != p_cell_ctxt);
    if (p_ld_actn->curr_load_lvl != ld_lvl)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "Load level changed from [%u]->[%u] for cell [%u]",
                p_ld_actn->curr_load_lvl, ld_lvl, p_cell_ctxt->cell_index);
        rrm_reset_load_actn (p_cell_ctxt, p_ld_actn, ld_lvl);
    }
    switch (ld_lvl)
    {
        case RRM_OVERLOAD:
            {
                if (p_ld_actn->bitmask & RRM_CELLM_OVERLOAD_PRESENT)
                {
                    actn = p_ld_actn->over_load.action;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                            "Identified actions [0x%x] for OVERLOAD level", actn);
                    while (RRM_ZERO != actn)
                    {

                        if(actn_cnt < RRM_ACTN_MAX)
                        {
                            if (actn & RRM_ONE )
                            {
                                ret_val = rrm_cell_load_actn[actn_cnt] (p_cell_ctxt, &p_ld_actn->over_load, ld_choice, resrc_cnt);
                            }
                        }
                        else 
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                 "Action count[%d] exceeded the action range", actn_cnt);
                        }
                        actn = actn >> RRM_ONE;
                        ++actn_cnt;
                    }
                  
                  }
                  /*SPR 14182 start*/ 
                  if((p_ld_actn->curr_load_lvl != ld_lvl) && (p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR))
                  {
                     ret_val = rrm_cell_load_abs_pattern_send_to_l2( p_cell_ctxt, &p_ld_actn->over_load);
                  }
                  /*SPR 14182 end*/
                break;
            }
        case RRM_HIGH:
            {
                if (p_ld_actn->bitmask & RRM_CELLM_HIGHLOAD_PRESENT)
                {
                    if ((p_ld_actn->curr_load_lvl != ld_lvl) ||
                            (p_ld_actn->curr_load_val > (p_ld_actn->over_load.percent - p_cell_ctxt->cell_load_action.high_actn_applied_lmt)))
                    {
                        actn = p_ld_actn->high_load.action;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                                "Identified actions [0x%x] for HIGHLOAD level", actn);
                        while (RRM_ZERO != actn)
                        {
                            if(actn_cnt < RRM_ACTN_MAX)
                            {
                                if (actn & RRM_ONE )
                                {
                                    ret_val = rrm_cell_load_actn[actn_cnt] (p_cell_ctxt, &p_ld_actn->high_load, ld_choice, resrc_cnt);
                                }
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "Action count[%d] exceeded the action range", actn_cnt);
                            }
                            actn = actn >> RRM_ONE;
                            ++actn_cnt;
                        }
                                        
                    
                    }
                }
                 /*SPR 14182 start*/
                 if((p_ld_actn->curr_load_lvl != ld_lvl) && (p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR))
                 {    
                 ret_val = rrm_cell_load_abs_pattern_send_to_l2( p_cell_ctxt, &p_ld_actn->high_load);
                 }
                 /*SPR 14182 end*/
                break;
            }
        case RRM_MEDIUM:
            {
                if (p_ld_actn->bitmask & RRM_CELLM_MIDLOAD_PRESENT)
                {
                    if (p_ld_actn->curr_load_lvl != ld_lvl)
                    {
                        actn = p_ld_actn->mid_load.action;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                                "Identified actions [0x%x] for MEDIUM LOAD level", actn);
                        while (RRM_ZERO != actn)
                        {
                            if(actn_cnt < RRM_ACTN_MAX)
                            {
                                if (actn & RRM_ONE )
                                {
                                    ret_val = rrm_cell_load_actn[actn_cnt] (p_cell_ctxt, &p_ld_actn->mid_load, ld_choice, resrc_cnt);
                                }
                            }
                            else 
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "Action count[%d] exceeded the action range", actn_cnt);
                            }
                            actn = actn >> RRM_ONE;
                            ++actn_cnt;
                        }
                   }
                }
                
                 /*SPR 14182 start*/
                 if((p_ld_actn->curr_load_lvl != ld_lvl) && (p_cell_ctxt->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_AGGRESSOR))
                 {    
                 ret_val = rrm_cell_load_abs_pattern_send_to_l2( p_cell_ctxt, &p_ld_actn->mid_load);
                 }
                 /*SPR 14182 end*/
                break;
            }
        case RRM_LOW:
            /* Nothing needs to be done everything is under control */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell Load level is LOW");
            break;

        default :
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Cell Load level is [0x%x]", ld_lvl);
                ret_val = RRM_FAILURE;
                break;
            }
    }
   RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_get_load_percent
 * Inputs         : rrm_cell_load_action_t *p_ld_actn
 *                : ld_lvl, p_cell_ctxt
 * Outputs        : p_ld_percnt
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Returns the percentage value configured depending upon the
 * load level provided
 ****************************************************************************/
rrm_return_et rrm_get_load_percent 
(   rrm_cell_load_action_t  *p_ld_actn,
    rrm_load_type           ld_lvl,
            /*SPR 17777 +-*/
    U8                      *p_ld_percnt
    )
{
	rrm_return_et ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();

	RRM_ASSERT (RRM_PNULL != p_ld_actn);
            /*SPR 17777 +-*/

	switch (ld_lvl)
	{
		case RRM_OVERLOAD:
			{
				if (RRM_CELLM_OVERLOAD_PRESENT & p_ld_actn->bitmask)
				{
					*p_ld_percnt = p_ld_actn->over_load.percent;
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"Overload info not present");
					ret_val = RRM_FAILURE;
				}
			}
			break;

		case RRM_HIGH:
			{
				if (RRM_CELLM_HIGHLOAD_PRESENT & p_ld_actn->bitmask)
				{
					*p_ld_percnt = p_ld_actn->high_load.percent;
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"High load info not present");
					ret_val = RRM_FAILURE;
				}
			}
			break;

		case RRM_MEDIUM:
			{
				if (RRM_CELLM_MIDLOAD_PRESENT & p_ld_actn->bitmask)
				{
					*p_ld_percnt = p_ld_actn->mid_load.percent;
				}
				else
				{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
							"Medium load info not present");
					ret_val = RRM_FAILURE;
				}
			}
			break;

		default :
			{
                /* SPR 21251 Start */
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Invalid Cell Load level[%d] received or LOAD Balancing is Not Enable", ld_lvl);
                /* SPR 21251 End */
				ret_val = RRM_FAILURE;
				break;
			}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_process_load_action_Specific
 * Inputs         : rrm_cell_context_t *p_cell_ctxt :pointer to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes load action for the cell
 ****************************************************************************/
rrm_return_et
rrm_process_load_action_Specific(rrm_cell_context_t               *p_cell_ctxt ,
                                 rrm_cell_load_action_info_t      *p_srv_ld_actn ,
                                 U8                                resrc_cnt)
{
    rrm_load_type ld_lvl = INVALID_LOAD;
    U8 cell_load = RRM_NULL;
    rrm_return_et ret_val = RRM_SUCCESS;
    switch (p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type)
    {
        case RRM_CELLM_HW_RESRC:
            {
                if (p_cell_ctxt->svr_cell_load_info.bitmask & RRM_HW_LOAD_PERIODIC_REPORT_PRESENT)
                {
                    ld_lvl = rrm_get_cur_load_level(&p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn,
                            p_cell_ctxt->svr_cell_load_info.hw_load);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "HW resource load level[%u] for cell_index[%d]", ld_lvl, p_cell_ctxt->cell_index);
                    rrm_handle_load_action (&(p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn),
                            ld_lvl,p_cell_ctxt, RRM_CELL_LOAD_RESRC_SPEC_PRESENT, resrc_cnt);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl = ld_lvl;

                    if (RRM_OVERLOAD == p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell Resource load level [%d] is Overload, Setting cell cap availability to 0", 
                                p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type);
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_ZERO;
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_ZERO;
                    }
                    
                }
                break;
            }
        case RRM_CELLM_TNL_RESRC:
            {
                if (p_cell_ctxt->svr_cell_load_info.bitmask & RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT)
                {
                    ld_lvl = rrm_get_cur_load_level(&p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn,
                            p_cell_ctxt->svr_cell_load_info.s1_tnl_load);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "TNL resource load level[%u]", ld_lvl);
                    rrm_handle_load_action (&(p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn),
                            ld_lvl,p_cell_ctxt, RRM_CELL_LOAD_RESRC_SPEC_PRESENT, resrc_cnt);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl = ld_lvl;
                    if (RRM_OVERLOAD == p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell Resource load level [%d] is Overload, Setting cell cap availability to 0", 
                                p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type);
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_ZERO;
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_ZERO;
                    }
                }
                break;
            }
        case RRM_CELLM_NONGRB_RESRC:
            {
                if (p_cell_ctxt->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
                {
                    cell_load = rrm_get_max_val (p_cell_ctxt->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage,
                            p_cell_ctxt->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage);
                    ld_lvl = rrm_get_cur_load_level (&(p_srv_ld_actn->u.resrc_spec_info.
                                resrc_spec_info[resrc_cnt].ld_actn), cell_load);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "NON-GBR resource current usage[%u], load level[%u]", cell_load, ld_lvl);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_val = cell_load;
                    rrm_handle_load_action (&(p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn),
                            ld_lvl,p_cell_ctxt, RRM_CELL_LOAD_RESRC_SPEC_PRESENT, resrc_cnt);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl = ld_lvl;
                    if (RRM_OVERLOAD == p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell Resource load level [%d] is Overload, Setting cell cap availability to 0", 
                                p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type);
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_ZERO;
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_ZERO;
                    }
                }
                break;
            }
        case RRM_CELLM_GBR_RESRC:
            {
                if (p_cell_ctxt->svr_cell_load_info.bitmask & RRM_RR_LOAD_PERIODIC_REPORT_PRESENT)
                {
                    cell_load = rrm_get_max_val (p_cell_ctxt->svr_cell_load_info.rr_load.dl_gbr_prb_usage,
                            p_cell_ctxt->svr_cell_load_info.rr_load.ul_gbr_prb_usage);
                    ld_lvl = rrm_get_cur_load_level (&(p_srv_ld_actn->u.resrc_spec_info.
                                resrc_spec_info[resrc_cnt].ld_actn), cell_load);
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "GBR resource current usage[%u], load level[%u]", cell_load, ld_lvl);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_val = cell_load;
                    rrm_handle_load_action (&(p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn),
                            ld_lvl,p_cell_ctxt, RRM_CELL_LOAD_RESRC_SPEC_PRESENT, resrc_cnt);
                    p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl = ld_lvl;
                    if (RRM_OVERLOAD == p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].ld_actn.curr_load_lvl)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell Resource load level [%d] is Overload, Setting cell cap availability to 0", 
                                p_cell_ctxt->cell_load_action.u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type);
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_ZERO;
                        p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_ZERO;
                    }
                }
                break;
            }
        default:
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Invalid Load Resource [%u] recvd",
                        p_srv_ld_actn->u.resrc_spec_info.resrc_spec_info[resrc_cnt].resrc_type);
                ret_val = RRM_FAILURE;
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrm_process_load_action
 * Inputs         : rrm_cell_context_t *p_cell_ctxt :pointer to cell context
 * Outputs        : None 
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes load action for the cell
 ****************************************************************************/
rrm_return_et rrm_process_load_action (rrm_cell_context_t *p_cell_ctxt)
{
	rrm_return_et ret_val = RRM_SUCCESS;
	U8 cell_load = RRM_NULL;
	rrm_cell_load_action_info_t *p_srv_ld_actn = RRM_PNULL;
	p_srv_ld_actn = &p_cell_ctxt->cell_load_action;
	rrm_load_type ld_lvl = INVALID_LOAD;
	U8 resrc_cnt = RRM_NULL;
	RRM_UT_TRACE_ENTER();
	RRM_ASSERT (RRM_PNULL != p_cell_ctxt);
	if (p_srv_ld_actn->choice == RRM_CELL_LOAD_COMPOSITE_PRESENT) /* Composite Load Present */
	{
		cell_load = rrm_get_total_comp_cell_load (&p_cell_ctxt->svr_cell_load_info);
		ld_lvl = rrm_get_cur_load_level (&(p_srv_ld_actn->u.comp_load_info), cell_load);
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
				"Cell resources current usage[%u], load level[%u] for cell_index[%d]", 
                 cell_load, ld_lvl, p_cell_ctxt->cell_index);
		p_srv_ld_actn->u.comp_load_info.curr_load_val = cell_load;
        ret_val = rrm_handle_load_action (&(p_srv_ld_actn->u.comp_load_info), ld_lvl, p_cell_ctxt, RRM_CELL_LOAD_COMPOSITE_PRESENT, RRM_NULL);
		p_srv_ld_actn->u.comp_load_info.curr_load_lvl = ld_lvl;

		if (RRM_OVERLOAD == p_cell_ctxt->cell_load_action.u.comp_load_info.curr_load_lvl)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
					"Cell Composite load level is Overload, Setting cell cap availability to 0");
			p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val = RRM_ZERO;
			p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val = RRM_ZERO;
		}
	}
	else /* ReSRC Specific Load Present */
	{
		for (resrc_cnt = RRM_ZERO; resrc_cnt < p_srv_ld_actn->u.resrc_spec_info.count; ++resrc_cnt)
		{
            /*Klockwork_fix_start*/
            rrm_process_load_action_Specific(p_cell_ctxt ,p_srv_ld_actn ,resrc_cnt);
            /*Klockwork_fix_end*/
		}
	}
	RRM_UT_TRACE_EXIT();
	return ret_val;
}

U8 rrm_map_ld_lvl_to_ld_prcnt 
(
 rrm_load_type ld_lvl,
 rrm_cell_load_action_t *p_ld_actn
 )
{
	U8 ld_prcnt = RRM_NULL;
	RRM_ASSERT(RRM_PNULL != p_ld_actn);
	RRM_UT_TRACE_ENTER();
	switch (ld_lvl)
	{
		case RRM_MEDIUM:
			{
				if (RRM_CELLM_MIDLOAD_PRESENT & p_ld_actn->bitmask)
				{
					ld_prcnt = p_ld_actn->mid_load.percent;
				}
				break;
			}
		case RRM_HIGH:
			{
				if (RRM_CELLM_HIGHLOAD_PRESENT & p_ld_actn->bitmask)
				{
					ld_prcnt = p_ld_actn->high_load.percent;
				}
				break;
			}
		case RRM_OVERLOAD:
			{
				if (RRM_CELLM_OVERLOAD_PRESENT & p_ld_actn->bitmask)
				{
					ld_prcnt = p_ld_actn->over_load.percent;
				}
				break;
			}
		default:
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,        
						"No Load Percentage is Configured, Considering Low (0) ld percentage");
				ld_prcnt = RRM_NULL;
				break;
			}
	}
	RRM_UT_TRACE_EXIT();
	return ld_prcnt;
}

rrm_rs_load_lvl_et
rrm_map_rrm_oam_ld_lvl
(
 rrm_load_type rrm_ld_lvl
 )
{
	rrm_rs_load_lvl_et oam_ld_lvl = RRM_LOW_LOAD_LVL;
	switch (rrm_ld_lvl)
	{
		case RRM_LOW:
			{
				oam_ld_lvl = RRM_LOW_LOAD_LVL;
				break;
			}
		case RRM_MEDIUM:
			{
				oam_ld_lvl = RRM_MID_LOAD_LVL;
				break; 
			}
		case RRM_HIGH:
			{
				oam_ld_lvl = RRM_HIGH_LOAD_LVL;
				break;
			}
		case RRM_OVERLOAD:
			{
				oam_ld_lvl = RRM_OVERLOAD_LVL;
				break;
			}
		default:
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
						"RRM Invalid load lvl[%d] received", rrm_ld_lvl);
				break;
			}
	}
	return oam_ld_lvl;
}

/* Code for MLB End */

/****************************************************************************
 * Function Name  : rrm_send_pdcp_config_param_req
 * Inputs         : RrmPdcpEcnConfigParamReq *rrm_pdcp_config_param_req
 *                : U16 src_module_id
 *                : U16 transaction_id
 *                : U8  cell_index 
 * Outputs        : None
 * Returns        : None
 * Description    : send KPI stat req to L2
 ****************************************************************************/
rrm_return_et
rrm_send_pdcp_config_param_req
(
 RrmPdcpEcnConfigParamReq *rrm_pdcp_config_param_req,/* Pointer to API specific information. */
 U16 src_module_id,  /* Source module identifier */
 U16 transaction_id, /* Interface transaction identifier */ 
 U8  cell_index      /* cell index */
 )
{
	U16 msg_length     = RRM_ZERO;
	U16 msg_api_length = RRM_ZERO;
	U8 *p_mac_msg = RRM_PNULL;
	U8 *p_msg = RRM_PNULL;

	msg_length = sizeof(RrmPdcpEcnConfigParamReq);
	msg_api_length = msg_length + RRM_API_HEADER_SIZE + RRM_INTERFACE_API_HEADER_SIZE;

	/* Allocate buffer */
	p_msg = rrm_msg_mem_get(msg_api_length);

	if (p_msg == RRM_PNULL)
	{
		/* Not enough memory */
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Memory allocation failure for p_msg");
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_mac_msg = p_msg;
	RRM_MEMSET(p_mac_msg, RRM_ZERO, msg_api_length);

	/* Fill CSPL header */
	rrm_construct_api_header(p_mac_msg, RRM_VERSION_ID, src_module_id,
			PDCP_MODULE_ID,RRM_PDCP_CONFIG_PARAMS_REQ, msg_api_length);

	p_mac_msg= p_mac_msg + RRM_API_HEADER_SIZE;
    /*
    ** Fill interface header.
    ** Multiple cell support, Passing a valid cell_index if multiple cell support
    ** is enabled, otherwise passing 0 in cell_index.
    */
    /*SPR 20856 Start*/
    rrm_construct_interface_api_header(p_mac_msg, transaction_id, src_module_id,
            PDCP_MODULE_ID, RRM_PDCP_CONFIG_PARAMS_REQ, msg_length, cell_index);
    /*SPR 20856 End*/

    /* Fill MAC_INIT_LAYER_REQ message */
    p_mac_msg = p_mac_msg + RRM_INTERFACE_API_HEADER_SIZE;

	RRM_MEMCPY(p_mac_msg,rrm_pdcp_config_param_req,sizeof(RrmPdcpEcnConfigParamReq));

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
            "Src(%u)->Dst(%u):RRM_PDCP_CONFIG_PARAMS_REQ", src_module_id, PDCP_MODULE_ID);
	/* Send message to */
	rrm_send_message(p_msg, PDCP_MODULE_ID);
	return RRM_SUCCESS;
}
/****************************************************************************
 * Function Name  : rrm_send_pdcp_kpi_thp_req 
 * Inputs         : PdcpConfigureKpiStatsReqParams *p_pdcp_kpi_config
 *                : U16 src_module_id
 *                : U16 transaction_id
 *                : U8  cell_index
 * Outputs        : None
 * Returns        : None
 * Description    : send KPI stat req to L2
 ****************************************************************************/
rrm_return_et
rrm_send_pdcp_kpi_thp_req
(
 PdcpConfigureKpiStatsReqParams *p_pdcp_kpi_config,
 U16 src_module_id ,
    U16 transaction_id,
    U8  cell_index 
 )
{
	U16 msg_length     = RRM_ZERO;
	U16 msg_api_length = RRM_ZERO;
	U8 *p_mac_msg = RRM_PNULL;
	U8 *p_msg = RRM_PNULL;

	msg_length = sizeof(PdcpConfigureKpiStatsReqParams);

	msg_api_length = msg_length + RRM_API_HEADER_SIZE + RRM_INTERFACE_API_HEADER_SIZE;
	/* Allocate buffer */
	p_msg = rrm_msg_mem_get(msg_api_length);

	if (p_msg == RRM_PNULL)
	{
		/* Not enough memory */
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Memory allocation failure for p_msg");
        /* SPR 21251 End */
		return RRM_FAILURE;
	}
	p_mac_msg = p_msg;
	RRM_MEMSET(p_mac_msg, RRM_ZERO, msg_api_length);

	/* Fill CSPL header */
	rrm_construct_api_header(p_mac_msg, RRM_VERSION_ID, src_module_id,
			PDCP_MODULE_ID,RRM_PDCP_CONFIGURE_KPI_STATS_REQ, msg_api_length);

	p_mac_msg= p_mac_msg + RRM_API_HEADER_SIZE;
    /*
    ** Fill interface header.
    ** Multiple cell support, Passing a valid cell_index if multiple cell support
    ** is enabled, otherwise passing 0 in cell_index.
    */
    /*SPR 20856 Start*/
    rrm_construct_interface_api_header(p_mac_msg, transaction_id, src_module_id,
            PDCP_MODULE_ID, RRM_PDCP_CONFIGURE_KPI_STATS_REQ, msg_length, cell_index);
    /*SPR 20856 End*/

    /* Fill MAC_INIT_LAYER_REQ message */
    p_mac_msg = p_mac_msg + RRM_INTERFACE_API_HEADER_SIZE;

	RRM_MEMCPY(p_mac_msg,p_pdcp_kpi_config,sizeof(PdcpConfigureKpiStatsReqParams));

    RRM_TRACE(g_uem_log_on_off, p_g_rrm_uem_facility_name, RRM_INFO,
            "Src(%u)->Dst(%u):RRM_PDCP_CONFIGURE_KPI_STATS_REQ", src_module_id, PDCP_MODULE_ID);
	/* Send message to */
	rrm_send_message(p_msg, PDCP_MODULE_ID);
	return RRM_SUCCESS;
}

/****************************************************************************
 * Function Name  : rrm_cellm_num_ue_to_apply_ecn 
 * Inputs         : rrm_cell_index_t cell_index
 * Outputs        : number of Ue on which ECN need to be apply
 * Returns        : U8
 * Description    : Provide number of UE on which ECN need to be apply 
 ****************************************************************************/
	S8
rrm_cellm_num_ue_to_apply_ecn(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config != RRM_PNULL)
	{
		RRM_UT_TRACE_EXIT();
		return (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config->num_of_ue);
	}
	else 
	{
		return RRM_INDEX_ERR;
	}
}
/*LOAD start*/
	rrm_return_et
rrm_send_unset_aqm_ecn_bit(rrm_cell_context_t *p_cell_ctx)/*SPR 17777 +-*/
{

	RrmPdcpEcnConfigParamReq          pdcp_ecn_config_param_req = {RRM_ZERO};
	rrm_return_et                     ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	if (p_cell_ctx->p_cell_ecn_config == RRM_PNULL)
	{
		pdcp_ecn_config_param_req.ecnFeatureStatus = ECN_NOT_APPLIED; 
		pdcp_ecn_config_param_req.ecnTrigger=ECN_T1_BASED_ON_WATERMARKS; 
	}
	else
	{
		pdcp_ecn_config_param_req.ecnFeatureStatus = ECN_APPLIED_IN_BOTH_UL_DL; 
		pdcp_ecn_config_param_req.ecnTrigger = ECN_T2_BASED_ON_RRM_DETECTION; 
	}
	pdcp_ecn_config_param_req.lowWaterMark=DEFAULT_LOW_WATER_MARK; 
	pdcp_ecn_config_param_req.highWaterMark= DEFAULT_HIGH_WATER_MARK;
    ret_val = rrm_send_pdcp_config_param_req(&pdcp_ecn_config_param_req,
                                              RRM_MODULE_ID,
                                              RRM_ZERO, 
                                              p_cell_ctx->cell_index);

	RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_reset_load_actn
 * Inputs         : rrm_cell_context_t *p_cell_ctxt
 *                : rrm_cell_load_action_t *p_ld_actn
 * Outputs        : None
 * Returns        : rrm_return_et 
 * Description    : Reset actions flags when load level changed.
 ****************************************************************************/
rrm_return_et rrm_reset_load_actn
(   rrm_cell_context_t *p_cell_ctxt,
    rrm_cell_load_action_t *p_ld_actn,
    rrm_load_type ld_lvl
    )
{
	rrm_return_et ret_val = RRM_SUCCESS;

	RRM_UT_TRACE_ENTER();
	RRM_ASSERT(RRM_PNULL != p_cell_ctxt);
	RRM_ASSERT(RRM_PNULL != p_ld_actn);

	if (p_ld_actn->actn_status & RRMCM_ACTN_STOP_ADM)
	{
		p_ld_actn->actn_status ^= RRMCM_ACTN_STOP_ADM; /* Bit 3 is set for Stop Adm action clear here on load level changed */
		p_cell_ctxt->stop_adm_flag = RRM_FALSE;
	}
	if (p_ld_actn->actn_status & RRMCM_ACTN_AQM)
	{
		/*unset the Aqm action*/
		ret_val = rrm_send_unset_aqm_ecn_bit(p_cell_ctxt);/*SPR 17777 +-*/
        if(RRM_FAILURE == ret_val)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				   "unable to set Aqm action");

		}         
		p_ld_actn->actn_status ^= RRMCM_ACTN_AQM; 
	}
	if(p_ld_actn->actn_status & RRMCM_ACTN_RRM_ECN_UL_DIR)
	{
		/*clear action ongoing ACTN_RRM_ECN_UL_DIR*/
		ret_val = rrm_ue_unset_ecn_bit(p_cell_ctxt->cell_index);/* SPR 20652 Fix +- */
		p_ld_actn->actn_status ^= RRMCM_ACTN_RRM_ECN_UL_DIR;
	}
	if(p_ld_actn->actn_status & RRMCM_ACTN_RRM_ECN_DL_DIR)
	{
		/*clear action ongoing ACTN_RRM_ECN_DL_DIR*/
		ret_val = rrm_ue_unset_ecn_bit(p_cell_ctxt->cell_index);/*SPR 17777 +-*/
		p_ld_actn->actn_status ^= RRMCM_ACTN_RRM_ECN_DL_DIR;
	}
    /*+ Coverity CID : 28805 +*/
	if( p_ld_actn->actn_status & RRMCM_ACTN_RRM_ECN_BI_DIR)
	{
		/*clear action ongoing ACTN_RRM_ECN_BI_DIR*/
		ret_val = rrm_ue_unset_ecn_bit(p_cell_ctxt->cell_index);/*SPR 17777 +-*/
		p_ld_actn->actn_status ^= RRMCM_ACTN_RRM_ECN_BI_DIR;
	}
    /* Carrier_Aggregation_Start */
    /* Scell deact action clear here on load level changed */
    if (p_ld_actn->actn_status & RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
    {
        p_ld_actn->actn_status ^= RRMCM_ACTN_RRM_SCELL_DEACTIVATE;
    }
    /* Carrier_Aggregation_End */
    if ((p_ld_actn->actn_status & RRMCM_ACTN_AC_BARRING))
    {
        if ((RRM_LOW == ld_lvl) && 
            (RRM_PNULL == p_cell_ctxt->p_cell_ld_reconfig_data))
        {
            /*+ Coverity CID : 28826 start+*/
            p_cell_ctxt->p_cell_ld_reconfig_data = rrm_mem_get(sizeof(rrm_cellm_load_ac_barring_t));
            /*+ Coverity CID : 28826 end+*/
            if ( p_cell_ctxt->p_cell_ld_reconfig_data == RRM_PNULL)
            {
                /* SPR 21251 Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                     "Memory allocation to p_cell_ctxt->p_cell_ld_reconfig_data failed" );
                /* SPR 21251 End */
                RRM_UT_TRACE_EXIT();
                return RRM_FAILURE;
            }
            /*+ Coverity CID : 28825 start+*/
            RRM_MEMSET(p_cell_ctxt->p_cell_ld_reconfig_data, RRM_NULL, sizeof(rrm_cellm_load_ac_barring_t));
            /*+ Coverity CID : 28825 end+*/
            if(p_cell_ctxt->operator_info.bitmask & RRMCM_RMIF_SIB_2_INFO_PRESENT)
            {
                if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.bitmask &
                        RRMCM_RMIF_BARRING_INFO_PRESENT)
                {
                    if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                            bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT)
                    {
                        p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_MOSIGL_PRESENT;
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_factor = 
                            rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                        access_barring_info.ac_barring_for_mo_signalling));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_time = 
                            rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                        access_barring_info.ac_barring_for_mo_signalling));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_sigl.ac_barring_spec_ac = 
                            rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                        access_barring_info.ac_barring_for_mo_signalling));
                    }
                    if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.
                            bitmask & RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT)
                    {
                        p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_MODATA_PRESENT;
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_factor =
                                        rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                        access_barring_info.ac_barring_for_mo_data));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_time =
                                        rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                        access_barring_info.ac_barring_for_mo_data));
                        p_cell_ctxt->p_cell_ld_reconfig_data->mo_data.ac_barring_spec_ac =
                            rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.
                                        access_barring_info.ac_barring_for_mo_data));
                    }
                    if(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT)
                    {
                        if (p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT)
                        {
                            p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_VOICE_PRESENT;
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_factor = 
                                rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_time =
                                rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_voice.ac_barring_spec_ac = 
                                rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9));
                        }
                        if (p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.access_barring_info.bitmask &
                            RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT) 
                        {
                            p_cell_ctxt->p_cell_ld_reconfig_data->bitmask |= RRM_CELLM_LDACB_MMTEL_VIDEO_PRESENT;
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_factor =
                                rrm_get_ac_barring_factor(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_time =
                                rrm_get_ac_barring_time(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                            p_cell_ctxt->p_cell_ld_reconfig_data->mmtel_video.ac_barring_spec_ac =
                                rrm_get_ac_barring_for_special_ac(&(p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.\
                                            access_barring_info.ssac_barring_r9.ssac_barring_for_mmtel_video_r9));
                        }
                    }
                }
            }
            (void)cellm_fsm_process_event(RRC_RRM_MLB_CELL_RECONFIG_REQ_EVENT, p_cell_ctxt);

        }
        RRM_MEM_FREE(p_cell_ctxt->p_cell_ld_reconfig_data);
        p_cell_ctxt->p_cell_ld_reconfig_data = RRM_PNULL;
        p_ld_actn->actn_status ^= RRMCM_ACTN_AC_BARRING;  
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

void rrm_cellm_increment_ecn_ue(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config != RRM_PNULL)
	{
		p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config->num_active_ecn_ue++;
	}
	RRM_UT_TRACE_EXIT();
}
U8 rrm_cellm_get_num_ue_on_ecn(rrm_cell_index_t cell_index)
{
	RRM_UT_TRACE_ENTER();
	if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config != RRM_PNULL)
	{
		RRM_UT_TRACE_EXIT();
		return  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_cell_ecn_config->num_active_ecn_ue;
	}
	else
	{
		return RRM_ZERO;
	}
}

rrm_void_t
rrm_hndl_rsu_stop_req_for_ncl(
		rrm_cell_context_t *p_cell_ctx,
        /* eICIC_PHASE_1_2_CHANGES_START */
        intra_freq_cells_t *p_target_freq_cell 
        /* eICIC_PHASE_1_2_CHANGES_END */
		)
{
	rrm_rsu_meas_id_node_t  *p_meas_node        = RRM_PNULL;
	rrm_cell_meas_gb_t        p_key             ={RRM_ZERO};
	YHNODE *p_hnode = RRM_PNULL;
    /* eICIC_PHASE_1_2_CHANGES_START */
    U8             target_enb_id[HOME_ENB_ID_OCTET_SIZE] ;
    rrm_bool_et    stop_target  = RRM_FALSE;
    /* eICIC_PHASE_1_2_CHANGES_END */
	RRM_UT_TRACE_ENTER ();

	/*coverity 23067: typecast to rrm_rsu_meas_id_node_t:simerjit, rel 1.3*/
	while (RRM_PNULL != (p_meas_node = (rrm_rsu_meas_id_node_t *)ylPopHead(&p_cell_ctx->rsu_meas_id_list)))
	{
        /* eICIC_PHASE_1_2_CHANGES_START */
        if(RRM_PNULL != p_target_freq_cell)
        {
            RRM_MEMSET(target_enb_id,RRM_ZERO,HOME_ENB_ID_OCTET_SIZE);
            RRM_MEMCPY(target_enb_id,p_target_freq_cell->cell_id.cell_identity,HOME_ENB_ID_OCTET_SIZE);

            if ((p_target_freq_cell->bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                    (p_target_freq_cell->cell_access_mode != RRM_OAM_ACCESS_MODE_OPEN)) /* Its HeNodeB */
            {
                target_enb_id[RRM_THREE]  &= RRM_HIGH_NIBBLE;
                if(  S1AP_OAM_HOME_ENB_ID_PRESENT & p_meas_node->g_enb_id.enb_id.presence_bitmask)
                {
                    if( RRM_ZERO == RRM_MEMCMP( p_meas_node->g_enb_id.enb_id.home_enb_id.eNB_id,
                                target_enb_id,HOME_ENB_ID_OCTET_SIZE)) 
                    {
                        stop_target = RRM_TRUE;
                    }
                }
            }
            else /* MACRO NODE */
            {
                target_enb_id[RRM_THREE] = RRM_ZERO;
                target_enb_id[RRM_TWO]  &= RRM_HIGH_NIBBLE;
                if (S1AP_OAM_MACRO_ENB_ID_PRESENT  & p_meas_node->g_enb_id.enb_id.presence_bitmask)
                {
                    /*SPR 14523 start*/ 
                    if( RRM_ZERO == RRM_MEMCMP( p_meas_node->g_enb_id.enb_id.macro_enb_id.eNB_id,
                                target_enb_id,MACRO_ENB_ID_OCTET_SIZE)) 
                    /*SPR 14523 end*/    
                    {
                        stop_target = RRM_TRUE;
                    }
                }
            }
            
            if( RRM_TRUE == stop_target)
            {
                p_key.meas_id = p_meas_node->rsu_meas_id;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Searching RSU Meas context [%u] !!!", p_meas_node->rsu_meas_id);
                RRM_MEMCPY(&(p_key.g_enb_id),&(p_meas_node->g_enb_id), sizeof(rrm_x2_gb_enb_id_t)); 
                /* Coverity CID 100114 Fix Start */	
                p_hnode = yhFind((const YHASH *) &(p_g_rrm_cell_ctx->rsu_measid_hash_tbl), (rrm_void_t *) &p_key);
                /* Coverity CID 100114 Fix End */	

                if (RRM_PNULL != p_hnode)
                {
                    build_and_send_rrm_x2ap_rrm_rsu_stop_req(p_meas_node->rsu_meas_id,&(p_meas_node->g_enb_id));
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "RSU Meas context [%u] not valid !!!", p_meas_node->rsu_meas_id);
                }
                RRM_MEM_FREE(p_meas_node);
                break;
            }
        }
        /* eICIC_PHASE_1_2_CHANGES_END */
        else
        {
            p_key.meas_id = p_meas_node->rsu_meas_id;
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    "Searching RSU Meas context [%u] !!!", p_meas_node->rsu_meas_id);
            RRM_MEMCPY(&(p_key.g_enb_id),&(p_meas_node->g_enb_id), sizeof(rrm_x2_gb_enb_id_t)); 
            p_hnode = yhFind(&(p_g_rrm_cell_ctx->rsu_measid_hash_tbl), (rrm_void_t *) &p_key);
            if (RRM_PNULL != p_hnode)
            {
                build_and_send_rrm_x2ap_rrm_rsu_stop_req(p_meas_node->rsu_meas_id,&(p_meas_node->g_enb_id));
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "RSU Meas context [%u] not valid !!!", p_meas_node->rsu_meas_id);
            }
            RRM_MEM_FREE(p_meas_node);
        }
	}

	RRM_UT_TRACE_EXIT ();
	return;
}

/* CSPL Hash Comparison Function */
int rrm_cmp_enb_id
(
 const rrm_void_t *p_val_1,
 const rrm_void_t *p_val_2
 )
{
	U32 key1 = *((U32 *)p_val_1);
	U32 key2 = *((U32 *)p_val_2);
	key1 = key1 << RRM_TWELVE;
	key2 = key2 << RRM_TWELVE;
	return (key1 - key2);
}
/* CSPL Hash Hashing Function*/
Ulong32 rrm_cellm_hashing_func
(
 const rrm_void_t *p_enb_id
 )
{
	U8 *key = RRM_NULL;
	U32 key1 = *((U32 *)p_enb_id);
    /* SPR 12910 start */
	key1 = key1 << RRM_TWELVE;
    /* SPR 12910 end */
	key = (U8 *)&key1;
	return rrm_cellm_hasher_func (key, sizeof(U32));
}

/* CSPL Hash keyof function */
const rrm_void_t *rrm_keyof_func (const YHNODE *p_hNode)
{
	RRM_ASSERT(RRM_PNULL != p_hNode);
	rrm_cellm_enb_id_hnode_t *p_enb_hnode = RRM_PNULL;
	p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)p_hNode;
	return ((const rrm_void_t *)&p_enb_hnode->enb_id);
}

rrm_return_et
rrm_build_and_send_rsu_req_to_macro_enb
(
 rrm_cellm_enb_id_hnode_t *p_enb_hnode,
 U32 periodic,
 rrm_cell_index_t cell_index
 )
{
	rrm_cellm_enb_id_lnode_t    *p_enb_lnode = RRM_PNULL;
	rrm_meas_rpt_config_info_t  rrm_meas_rpt_config_info;
	rrm_return_et               ret_val = RRM_SUCCESS;
    U32                         i       = RRM_ZERO;
    /*SPR 18994 START*/
    U32 report_characteristics = RRM_ZERO;
    /*SPR 18994 END*/
	RRM_ASSERT (RRM_PNULL != p_enb_hnode);
    RRM_UT_TRACE_ENTER ();
	rrm_meas_rpt_config_info.num_cell = RRM_ZERO;
	rrm_meas_rpt_config_info.cell_index = cell_index;
	while (RRM_PNULL != (p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)ylPopHead(&p_enb_hnode->list)))
	{
		if ((HO_ALLOWED == p_enb_lnode->enb_info.ho_status) && /* Check HO status is enable */
                (RRM_FALSE == p_enb_lnode->enb_info.blacklisted))
		{
			if ((RRM_TRUE == p_enb_lnode->enb_info.x2_link_up_status) ||
					(X2_ALLOWED_CONNECTED == p_enb_lnode->enb_info.x2_status))
			{
				RRM_MEMCPY(&rrm_meas_rpt_config_info.cell_info[rrm_meas_rpt_config_info.num_cell].global_cell_id,
						&p_enb_lnode->enb_info.cell_id, sizeof (rrm_oam_eutran_global_cell_id_t));
				rrm_meas_rpt_config_info.num_cell++;
			}
			else
			{
                /* SPR 21251 Start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Link is not UP for neighbor :");
                /* SPR 21251 End */
                for (i = RRM_ZERO; i < MAX_CELL_IDENTITY_OCTETS; i++)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "cell_identity[%u] = %u",
                            i, p_enb_lnode->enb_info.cell_id.cell_identity[i]);
                }
				ret_val = RRM_FAILURE;
			}
		}
		else /* HO is not enable so no Resource Status Update request will be sent */
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Load Report not allowed as HOO status %s allowed, cell %s blacklisted for Neighbour cell",
                    (HO_ALLOWED == p_enb_lnode->enb_info.ho_status)? "is": "not",
                    (RRM_FALSE == p_enb_lnode->enb_info.blacklisted) ? "is": "not");
            /* SPR 21251 End */
            for (i = RRM_ZERO; i < MAX_CELL_IDENTITY_OCTETS; i++)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                        "cell_identity[%u] = %u",
                        i, p_enb_lnode->enb_info.cell_id.cell_identity[i]);
            }
            ret_val = RRM_FAILURE;
        }
        RRM_MEM_FREE (p_enb_lnode);
	}
    /* SPR 12910 start */
    if (RRM_ZERO != rrm_meas_rpt_config_info.num_cell)
    {
        /*SPR 18994 START*/
        rrm_set_report_charaterstics(&report_characteristics,RRM_PRB_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_COMPOSITE_CAPACITY_REPORT_CHAR_SET);
        /* SPR 12910 end */
        ret_val = build_and_send_rrm_x2ap_rrm_rsu_start_req (&rrm_meas_rpt_config_info, report_characteristics, /* report_characteristics */
			    periodic);
        /*SPR 18994 END*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "rrm_x2ap_rrm_rsu_start_req should not be sent to Macro Cell");
    }
    RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_free_load_info_resource_on_error 
 * Inputs         : YHASH *p_rrm_enbid_hash : pointer
 *                :  to hash 
 * Outputs        : None
 * Returns        : void  
 * Description    : free the memory resources 
 ****************************************************************************/
/*Cov_fix_63722_63720_54337_63724*/
rrm_void_t rrm_free_load_info_resource_on_error( YHASH  *p_rrm_enbid_hash )
{

    rrm_cellm_enb_id_hnode_t          *p_enb_hnode = RRM_PNULL;
    /*SPR 16829 Fix Start*/
    rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    /*SPR 16829 Fix End*/

    RRM_UT_TRACE_ENTER ();

    /*SPR 16829 Fix Start*/
    if( RRM_PNULL != p_rrm_enbid_hash )
    {
    /*SPR 16829 Fix End*/    
        while (RRM_PNULL != ( p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)yhFirst((const YHASH *)p_rrm_enbid_hash )) )
        {
            while (RRM_PNULL != (p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)ylPopHead(&p_enb_hnode->list)))
            {
                RRM_MEM_FREE (p_enb_lnode);
            }

            yhDelete ( p_rrm_enbid_hash , (YHNODE *)p_enb_hnode);

            RRM_MEM_FREE (p_enb_hnode);
        }

         /*SPR 16829 Fix Start*/
        if( RRM_PNULL != p_rrm_enbid_hash->table )
        {
        /*SPR 16829 Fix End*/    
            RRM_MEM_FREE(p_rrm_enbid_hash->table);
            /*SPR 16829 Fix Start*/
            p_rrm_enbid_hash->table = RRM_PNULL;
            /*SPR 16829 Fix End*/
        }
    }

    RRM_UT_TRACE_EXIT();
}
/*Cov_fix_63722_63720*/
/****************************************************************************
 * Function Name  : rrm_cellm_find_and_send_rsu_req_to_cells_on_same_enb 
 * Inputs         : lte_ncl_t, rrm_cell_index_t, periodic
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE  
 * Description    : This function selects the cell for which Resource status
 * request needs to be sent. It groups cells on same eNodeB in a single request
 * and send request to each eNodeB
 ****************************************************************************/
rrm_return_et rrm_cellm_find_and_send_rsu_req_to_cells_on_same_enb
(
 lte_ncl_t *lte_ncl,
 rrm_cell_index_t cell_index,
 U32              periodic
 )
{
    U8                          ncl_cnt = RRM_NULL;
    YHASH                       rrm_enbid_hash;
    rrm_meas_rpt_config_info_t  rrm_meas_rpt_config_info;
    rrm_cellm_enb_id_hnode_t    *p_enb_hnode = RRM_PNULL;
    rrm_cellm_enb_id_lnode_t    *p_enb_lnode = RRM_PNULL;
    /*SPR 18994 START*/
    U32 report_characteristics = RRM_ZERO;
    /*SPR 18994 END*/
    rrm_return_et               ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER ();
    RRM_ASSERT(RRM_PNULL != lte_ncl);
    /* Getting Memory For Hash Table */
    YHNODE **table = (YHNODE **)rrm_mem_get(((RRM_CELLM_MAX_HASH_BUCKECT) * sizeof (YHNODE *)));

    if(RRM_PNULL == table) /* Coverity: CID 30217 */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to table failed");
        return RRM_FAILURE;
    }
    /* Init Hash Table rrm_enbid_hash */
    yhInit (&rrm_enbid_hash, RRM_CELLM_MAX_HASH_BUCKECT, rrm_cellm_hashing_func, rrm_cmp_enb_id, rrm_keyof_func, table);
    rrm_meas_rpt_config_info.num_cell = RRM_ZERO;
    /* Init List enb_cell_list */

    for (ncl_cnt = RRM_ZERO; ncl_cnt < lte_ncl->num_valid_inter_freq_cell; ++ncl_cnt)
    {
        /* SPR 12910 start */
        if (X2_LOCALLY_CONNECTED_CELL == lte_ncl->inter_freq_cells[ncl_cnt].x2_status)
        {
            /* Local cell */
            continue;
        }
        /* SPR 12910 end */
        /* SPR 11490 start */
        if ((lte_ncl->inter_freq_cells[ncl_cnt].bitmask & RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT) && 
                (lte_ncl->inter_freq_cells[ncl_cnt].cell_access_mode != RRM_OAM_ACCESS_MODE_OPEN)) /* Its HeNodeB */
        {
            /* SPR 11490 end */
            /* This cell is HeNodeB, Its consist only one cell */
            /* SPR 11490 start */
            if ((HO_ALLOWED == lte_ncl->inter_freq_cells[ncl_cnt].ho_status) &&/* Check HO status is enable */
                    (RRM_FALSE == lte_ncl->inter_freq_cells[ncl_cnt].blacklisted))
            {
                /* SPR 11490 end */
                if ((RRM_TRUE == lte_ncl->inter_freq_cells[ncl_cnt].x2_link_up_status) ||
                        (X2_ALLOWED_CONNECTED == lte_ncl->inter_freq_cells[ncl_cnt].x2_status))
                {
                    rrm_meas_rpt_config_info.cell_index = cell_index;
                    RRM_MEMCPY(&rrm_meas_rpt_config_info.cell_info[RRM_ZERO].global_cell_id,
                            &lte_ncl->inter_freq_cells[ncl_cnt].cell_id, sizeof (\
                                rrm_oam_eutran_global_cell_id_t));
                    /*  report_characteristics =
                        Bit 1: PRB Periodic report is requested
                        Bit 2: TNL load Ind Periodic is requested
                        Bit 3: Load Ind Periodic is requested
                        Bit 4: Composite Available Capacity Periodic is requested
                     */
                    /* Build and send X2AP_RRM_RSU_RRM_START_REQ */
                    rrm_meas_rpt_config_info.num_cell++;
                    /*SPR 18994 START*/
                    rrm_set_report_charaterstics(&report_characteristics,RRM_PRB_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_COMPOSITE_CAPACITY_REPORT_CHAR_SET);
                    ret_val = build_and_send_rrm_x2ap_rrm_rsu_start_req (&rrm_meas_rpt_config_info, report_characteristics, /* report_characteristics */
                            periodic);
                    /*SPR 18994 END*/
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                            "Link is not UP for inter freq neighbor pci: %d",
                            lte_ncl->inter_freq_cells[ncl_cnt].phy_cell_id );
                    ret_val = RRM_FAILURE;
                }
            }
            else /* HO is not enable so no Resource Status Update request will be sent */
            {
                /* SPR 11490 start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "HO %s, cell is %s, Load Report cannot be configured on inter freq neighbor pci: %d",
                        (HO_ALLOWED == lte_ncl->inter_freq_cells[ncl_cnt].ho_status ? "allowed" : "not allowed"),
                        (RRM_FALSE == lte_ncl->inter_freq_cells[ncl_cnt].blacklisted ? "not blacklisted" : "blacklisted"),
                        lte_ncl->inter_freq_cells[ncl_cnt].phy_cell_id);
                /* SPR 11490 end */
                ret_val = RRM_FAILURE;
            }
            rrm_meas_rpt_config_info.num_cell = RRM_ZERO;
        }
        else /* Its Macro eNodeB */
        {
            /* SPR 11490 start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell at Idx[%u] of Inter frequency NCL is on MACRO eNB", ncl_cnt);
            /* SPR 11490 end */
            p_enb_hnode = (rrm_cellm_enb_id_hnode_t*)yhFind(&rrm_enbid_hash, (rrm_void_t *)
                    &(lte_ncl->inter_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]));
            if (RRM_PNULL == p_enb_hnode)
            {
                p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_hnode_t));
                if ( p_enb_hnode == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_hnode failed" );
                    /* Coverity 54341 fix start */
                    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
                    /* Coverity 54341 fix end */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                RRM_MEMCPY(&p_enb_hnode->enb_id, &(lte_ncl->inter_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]),
                        sizeof(p_enb_hnode->enb_id));
                ylInit(&p_enb_hnode->list);
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );
                    /* SPR 21251 End */
                    RRM_MEM_FREE(p_enb_hnode);
                    /* Coverity 54341 fix start */
                    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
                    /* Coverity 54341 fix end */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                /* SPR 19337 fix start */
                /* SPR Fix 18895 Start */
                RRM_MEMSET(p_enb_lnode, RRM_ZERO, sizeof(rrm_cellm_enb_id_lnode_t));
                /* SPR Fix 18895 End */

                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->inter_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                /* SPR 19337 fix stop */
                p_enb_lnode->enb_info.x2_status = lte_ncl->inter_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->inter_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->inter_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->inter_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->inter_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
                yhInsert(&rrm_enbid_hash, &(p_enb_hnode->node));
            }
            else
            {
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );
                    /* SPR 21251 End */
                    /* Coverity 54341 fix start */
                    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
                    /* Coverity 54341 fix end */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }
                 /* SPR 19337 Fix start */
                /* SPR Fix 18895 Start */
                RRM_MEMSET(p_enb_lnode, RRM_ZERO, sizeof(rrm_cellm_enb_id_lnode_t));
                /* SPR Fix 18895 End */
                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->inter_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                /* SPR 19337 Fix stop */
                p_enb_lnode->enb_info.x2_status = lte_ncl->inter_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->inter_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->inter_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->inter_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->inter_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
            }
        }
    }
    for (ncl_cnt = 0; ncl_cnt < lte_ncl->num_valid_intra_freq_cell; ++ncl_cnt)
    {
        /* SPR 12910 start */
        if (X2_LOCALLY_CONNECTED_CELL == lte_ncl->intra_freq_cells[ncl_cnt].x2_status)
        {
            /* This is a local cell */
            continue;
        }
        /* SPR 12910 end */
        /* SPR 11490 start */
        if ((lte_ncl->intra_freq_cells[ncl_cnt].bitmask & RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                (lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode != RRM_OAM_ACCESS_MODE_OPEN)) /* Its HeNodeB */
        {
            /* SPR 11490 end */
            /* This cell is HeNodeB, Its consist only one cell */
            /* SPR 11490 start */
            if ((HO_ALLOWED == lte_ncl->intra_freq_cells[ncl_cnt].ho_status) && /* Check HO status is enable */
                    (RRM_FALSE == lte_ncl->intra_freq_cells[ncl_cnt].blacklisted))
            {
                /* SPR 11490 end */
                if ((RRM_TRUE == lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status) ||
                        (X2_ALLOWED_CONNECTED == lte_ncl->intra_freq_cells[ncl_cnt].x2_status))
                {
                    rrm_meas_rpt_config_info.cell_index = cell_index;
                    RRM_MEMCPY(&rrm_meas_rpt_config_info.cell_info[RRM_ZERO].global_cell_id,
                            &lte_ncl->intra_freq_cells[ncl_cnt].cell_id, sizeof (\
                                rrm_oam_eutran_global_cell_id_t));
                    /*  report_characteristics =
                        Bit 1: PRB Periodic report is requested
                        Bit 2: TNL load Ind Periodic is requested
                        Bit 3: Load Ind Periodic is requested
                        Bit 4: Composite Available Capacity Periodic is requested
                     */
                    /* Build and send X2AP_RRM_RSU_RRM_START_REQ */
                    rrm_meas_rpt_config_info.num_cell++;
                    /*SPR 18994 START*/
                    rrm_set_report_charaterstics(&report_characteristics,RRM_PRB_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET);
                    rrm_set_report_charaterstics(&report_characteristics,RRM_COMPOSITE_CAPACITY_REPORT_CHAR_SET);
                    ret_val = build_and_send_rrm_x2ap_rrm_rsu_start_req (&rrm_meas_rpt_config_info, report_characteristics, /* report_characteristics */
                            periodic);
                    /*SPR 18994 END*/
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Link is not UP for intra freq neighbor pci: %d",
                            lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id );
                    ret_val = RRM_FAILURE;
                }
            }
            else /* HO is not enable so no Resource Status Update request will be sent */
            {
                /* SPR 11490 start */
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "HO %s, cell is %s, Load Report cannot be configured on inter freq neighbor pci: %d",
                        (HO_ALLOWED == lte_ncl->intra_freq_cells[ncl_cnt].ho_status ? "allowed" : "not allowed"),
                        (RRM_FALSE == lte_ncl->intra_freq_cells[ncl_cnt].blacklisted ? "not blacklisted" : "blacklisted"),
                        lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                /* SPR 11490 end */
                ret_val = RRM_FAILURE;
            }
            rrm_meas_rpt_config_info.num_cell = RRM_ZERO;
        }
        else
        {
            /* SPR 11490 start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell at Idx[%u] of Intra frequency NCL is on MACRO eNB", ncl_cnt);
            /* SPR 11490 end */
            p_enb_hnode = (rrm_cellm_enb_id_hnode_t*)yhFind(&rrm_enbid_hash, (rrm_void_t *)
                    &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]));
            if (RRM_PNULL == p_enb_hnode)
            {
                p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_hnode_t));
                if ( p_enb_hnode == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_hnode failed" );
                    /* Coverity 54341 fix start */
                    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
                    /* Coverity 54341 fix end */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_hnode->enb_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]),
                        sizeof(p_enb_hnode->enb_id));
                ylInit(&p_enb_hnode->list);
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );
                    /* SPR 21251 End */
                    RRM_MEM_FREE(p_enb_hnode);
                    /* Coverity 54341 fix start */
                    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
                    /* Coverity 54341 fix end */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
                yhInsert(&rrm_enbid_hash, &(p_enb_hnode->node));
            }
            else
            {
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    /* SPR 21251 Start */
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );
                    /* SPR 21251 End */
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
            }
        }
    }
    /* Sending the RSU req to each Macro eNodeB and free the hash and list */
    /* SPR 11490 start */
    p_enb_hnode = (rrm_cellm_enb_id_hnode_t*)yhFirst((const YHASH *)&rrm_enbid_hash);
    while (RRM_PNULL != p_enb_hnode)
    {
        ret_val = rrm_build_and_send_rsu_req_to_macro_enb(p_enb_hnode, periodic, cell_index);
        p_enb_hnode = (rrm_cellm_enb_id_hnode_t*)yhNext (&rrm_enbid_hash, &p_enb_hnode->node);
    }
    /* SPR 11490 end */

    rrm_free_load_info_resource_on_error(&rrm_enbid_hash);
    /*Coverity fix 54341 removed causing crash*/

    /*SPR 16829 Fix start*/
    /*Code removed*/
    /*SPR 16829 Fix stop*/

    RRM_UT_TRACE_EXIT ();
    return ret_val;
}


rrm_return_et rrm_hndl_rsu_start_req_for_ncl
(
 rrm_cell_context_t *p_cell_ctx,
 U32 periodic
 )
{
	lte_ncl_t *lte_ncl =RRM_PNULL;
	rrm_return_et ret_val = RRM_SUCCESS; 
	RRM_UT_TRACE_ENTER ();
	lte_ncl = rrm_cellm_get_lte_ncl_info (p_cell_ctx->cell_index);
    if(RRM_PNULL != lte_ncl)
    {
	    ret_val = rrm_cellm_find_and_send_rsu_req_to_cells_on_same_enb (lte_ncl, p_cell_ctx->cell_index, periodic); 
    }
	RRM_UT_TRACE_EXIT ();
	return ret_val;
}

rrm_void_t rrm_cpy_prb_usage_son
(
 rrm_son_rrs_load_ind_t *p_son_rrs_ind,
 rrm_rs_prb_t       *p_rr_load
 )
{
	RRM_UT_TRACE_ENTER();

	p_son_rrs_ind->dl_gbr_prb_usage = p_rr_load->dl_gbr_prb_usage;
	p_son_rrs_ind->ul_gbr_prb_usage = p_rr_load->ul_gbr_prb_usage;
	p_son_rrs_ind->dl_non_gbr_prb_usage = p_rr_load->dl_non_gbr_prb_usage;
	p_son_rrs_ind->ul_non_gbr_prb_usage = p_rr_load->ul_non_gbr_prb_usage;
	p_son_rrs_ind->dl_total_prb_usage = p_rr_load->dl_total_prb_usage;
	p_son_rrs_ind->ul_total_prb_usage = p_rr_load->ul_total_prb_usage;

	RRM_UT_TRACE_EXIT();
	return;
}

/** eICIC feature changes start */

rrm_void_t rrm_cpy_prb_usage_oam_for_ncl
(
 rrm_rrs_load_ind_t *p_son_rrs_ind,
 rrm_rs_prb_t       *p_rr_load
 )
{
	RRM_UT_TRACE_ENTER();

	p_son_rrs_ind->dl_gbr_prb_usage = p_rr_load->dl_gbr_prb_usage;
	p_son_rrs_ind->ul_gbr_prb_usage = p_rr_load->ul_gbr_prb_usage;
	p_son_rrs_ind->dl_non_gbr_prb_usage = p_rr_load->dl_non_gbr_prb_usage;
	p_son_rrs_ind->ul_non_gbr_prb_usage = p_rr_load->ul_non_gbr_prb_usage;
	p_son_rrs_ind->dl_total_prb_usage = p_rr_load->dl_total_prb_usage;
	p_son_rrs_ind->ul_total_prb_usage = p_rr_load->ul_total_prb_usage;

	RRM_UT_TRACE_EXIT();
	return;
}

/** eICIC feature changes end */
/* Coverity_ID : 67322,67323,67324,67325,67326,67327 */
/****************************************************************************
 * Function Name  : rrm_map_rrm_oam_ld_lvl_for_rsu
 * Inputs         : rrm_x2ap_rsu_load_ind_et rrm_ld_lvl
 * Outputs        : rrm_rs_load_lvl_et son_ld_lvl
 * Returns        : rrm_rs_load_lvl_et
 * Description    : Map rrm load level to son load level
 ****************************************************************************/
rrm_rs_load_lvl_et
rrm_map_rrm_oam_ld_lvl_for_rsu
(
 rrm_x2ap_rsu_load_ind_et rrm_ld_lvl
 )
{
	rrm_rs_load_lvl_et son_ld_lvl = RRM_LOW_LOAD_LVL;
	switch (rrm_ld_lvl)
	{
		case RRM_X2AP_RSU_LOAD_LOW:
			{
				son_ld_lvl = RRM_LOW_LOAD_LVL;
				break;
			}
		case RRM_X2AP_RSU_LOAD_MEDIUM:
			{
				son_ld_lvl = RRM_MID_LOAD_LVL;
				break; 
			}
		case RRM_X2AP_RSU_LOAD_HIGH:
			{
				son_ld_lvl = RRM_HIGH_LOAD_LVL;
				break;
			}
		case RRM_X2AP_RSU_LOAD_OVER:
			{
				son_ld_lvl = RRM_OVERLOAD_LVL;
				break;
			}
		default:
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
						"RRM Invalid load lvl rcved assiging low by default");
				son_ld_lvl = RRM_LOW_LOAD_LVL;
				break;
			}
	}
	return son_ld_lvl;
}
/** eICIC feature changes start */
/** eICIC feature changes end */
/* Coverity_ID : 41387, 41388, 41390, 41392, 22539, 22537, 22533, 22535 */
/****************************************************************************
 * Function Name  : rrm_map_rrm_son_ld_lvl
 * Inputs         : rrm_x2ap_rsu_load_ind_et rrm_ld_lvl
 * Outputs        : rrm_son_rs_load_lvl_et son_ld_lvl
 * Returns        : rrm_son_rs_load_lvl_et
 * Description    : Map rrm load level to son load level
 ****************************************************************************/
rrm_son_rs_load_lvl_et
rrm_map_rrm_son_ld_lvl
(
 rrm_x2ap_rsu_load_ind_et rrm_ld_lvl
 )
{
	rrm_son_rs_load_lvl_et son_ld_lvl = RRM_INVALID_LOAD_LVL;
	switch (rrm_ld_lvl)
	{
		case RRM_X2AP_RSU_LOAD_LOW:
			{
				son_ld_lvl = RRM_SON_LOW_LOAD_LVL;
				break;
			}
		case RRM_X2AP_RSU_LOAD_MEDIUM:
			{
				son_ld_lvl = RRM_SON_MID_LOAD_LVL;
				break; 
			}
		case RRM_X2AP_RSU_LOAD_HIGH:
			{
				son_ld_lvl = RRM_SON_HIGH_LOAD_LVL;
				break;
			}
		case RRM_X2AP_RSU_LOAD_OVER:
			{
				son_ld_lvl = RRM_SON_OVERLOAD_LVL;
				break;
			}
		default:
			{
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
						"RRM Invalid load lvl[%d] rcved assiging low by default", rrm_ld_lvl);
				son_ld_lvl = RRM_SON_LOW_LOAD_LVL;
				break;
			}
	}
	return son_ld_lvl;
}
/** eICIC feature changes start */
rrm_void_t rrm_cpy_s1_tnl_load_oam_for_ncl
(
 rrm_s1_tnl_load_ind_t *p_son_s1_tnl_load,
 rrm_rs_tnl_load_t     *p_rs_tnl
 )
{
	RRM_UT_TRACE_ENTER();
	p_son_s1_tnl_load->dl = rrm_map_rrm_oam_ld_lvl_for_rsu(p_rs_tnl->dl); /* Coverity_ID : 22537,67390 */
	p_son_s1_tnl_load->ul = rrm_map_rrm_oam_ld_lvl_for_rsu(p_rs_tnl->ul); /* Coverity_ID : 22539,67391 */

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes end */

rrm_void_t rrm_cpy_s1_tnl_load_son
(
 rrm_son_s1_tnl_load_ind_t *p_son_s1_tnl_load,
 rrm_rs_tnl_load_t     *p_rs_tnl
 )
{
	RRM_UT_TRACE_ENTER();
	p_son_s1_tnl_load->dl = rrm_map_rrm_son_ld_lvl(p_rs_tnl->dl); /* Coverity_ID : 22537 */
	p_son_s1_tnl_load->ul = rrm_map_rrm_son_ld_lvl(p_rs_tnl->ul); /* Coverity_ID : 22539 */

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes start */
rrm_void_t rrm_cpy_hw_load_oam_for_ncl
(
 rrm_hw_load_ind_t  *p_son_hw_load,
 rrm_rs_hw_load_t   *p_hw_load_ind
 )
{
	RRM_UT_TRACE_ENTER();
	p_son_hw_load->dl = rrm_map_rrm_oam_ld_lvl_for_rsu(p_hw_load_ind->dl); /* Coverity_ID : 22533,67388 */
	p_son_hw_load->ul = rrm_map_rrm_oam_ld_lvl_for_rsu(p_hw_load_ind->ul); /* Coverity_ID : 22535,67389 */

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes end */

rrm_void_t rrm_cpy_hw_load_son
(
 rrm_son_hw_load_ind_t *p_son_hw_load,
 rrm_rs_hw_load_t  *p_hw_load_ind
 )
{
	RRM_UT_TRACE_ENTER();
	p_son_hw_load->dl = rrm_map_rrm_son_ld_lvl(p_hw_load_ind->dl); /* Coverity_ID : 22533 */
	p_son_hw_load->ul = rrm_map_rrm_son_ld_lvl(p_hw_load_ind->ul); /* Coverity_ID : 22535 */

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes start */
rrm_void_t rrm_cpy_comp_avl_cap_oam_for_ncl
(
 rrm_comp_avl_cap_grp_t  *p_son_avl_cap,
 rrm_rs_cacg_t           *p_avl_cap
 )
{
	RRM_UT_TRACE_ENTER();

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->dl.bitmask)
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->dl_comp_avl_cap.cell_cap_class_val = p_avl_cap->dl.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->dl_comp_avl_cap.cap_val = p_avl_cap->dl.cell_cap_val;

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->ul.bitmask)
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->ul_comp_avl_cap.cell_cap_class_val = p_avl_cap->ul.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->ul_comp_avl_cap.cap_val = p_avl_cap->ul.cell_cap_val;

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes end*/
rrm_void_t rrm_cpy_comp_avl_cap_son
(
 rrm_son_comp_avl_cap_grp_t *p_son_avl_cap,
 rrm_rs_cacg_t          *p_avl_cap
 )
{
	RRM_UT_TRACE_ENTER();

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->dl.bitmask)
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->dl_comp_avl_cap.cell_cap_class_val = p_avl_cap->dl.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->dl_comp_avl_cap.cap_val = p_avl_cap->dl.cell_cap_val;

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->ul.bitmask)
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->ul_comp_avl_cap.cell_cap_class_val = p_avl_cap->ul.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->ul_comp_avl_cap.cap_val = p_avl_cap->ul.cell_cap_val;

	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes start */
rrm_void_t rrm_cpy_abs_status_oam
(
 rrm_oam_abs_status_t   *p_son_abs_status,
 rrm_x2ap_abs_status_t       *p_abs_status
)
{
	U8 abs_pattern_index;
    
    RRM_UT_TRACE_ENTER();

	p_son_abs_status->dl_abs_status = p_abs_status->dl_abs_status;

	if (RRM_TDD_FDD_CONFIG_PRESENT & p_abs_status->bitmask)
	{
		p_son_abs_status->bitmask |= RRM_SON_TDD_FDD_CONFIG_PRESENT;
		p_son_abs_status->tdd_fdd_config = p_abs_status->tdd_fdd_config;
	}
	else
	{
		p_son_abs_status->bitmask = RRM_ZERO;
	}


	for(abs_pattern_index=0;abs_pattern_index<RRM_MAX_PATTERN_BYTE;abs_pattern_index++)
    {
    
       p_son_abs_status->usable_abs_pattern_info_tdd[abs_pattern_index] = p_abs_status->usable_abs_pattern[abs_pattern_index];   
    
    }
	RRM_UT_TRACE_EXIT();
	return;
}



rrm_void_t rrm_cpy_abs_status
(
 rrm_son_abs_status_t   *p_son_abs_status,
 rrm_x2ap_abs_status_t       *p_abs_status
)
{
	U8 abs_pattern_index;
    
    RRM_UT_TRACE_ENTER();

	p_son_abs_status->dl_abs_status = p_abs_status->dl_abs_status;

	if (RRM_TDD_FDD_CONFIG_PRESENT & p_abs_status->bitmask)
	{
		p_son_abs_status->bitmask |= RRM_SON_TDD_FDD_CONFIG_PRESENT;
		p_son_abs_status->tdd_fdd_config = p_abs_status->tdd_fdd_config;
	}
	else
	{
		p_son_abs_status->bitmask = RRM_ZERO;
	}


	for(abs_pattern_index=0;abs_pattern_index<RRM_MAX_PATTERN_BYTE;abs_pattern_index++)
    {
    
       p_son_abs_status->usable_abs_pattern_info_tdd[abs_pattern_index] = p_abs_status->usable_abs_pattern[abs_pattern_index];   
    
    }


	RRM_UT_TRACE_EXIT();
	return;
}
/** eICIC feature changes end*/

/* RRM ES Start */
/****************************************************************************
 * Function Name  : rrm_fill_srv_cell_load_info
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : rrm_son_load_report_ind_t   *p_resrc_upd
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update periodic resource in FSM
 ****************************************************************************/
rrm_return_et
rrm_fill_srv_cell_load_info
(
 rrm_cell_context_t *p_cell_ctx,        /* cell context */
 rrm_son_load_report_ind_t   *p_resrc_upd
 )
{

    //U32 *cell_id = (U32 *)(p_resrc_upd->serv_cell_load_info.g_cell_id.cell_identity);

    RRM_UT_TRACE_ENTER();

    p_resrc_upd->serv_cell_load_info.bitmask = RRM_ZERO;
    p_resrc_upd->serv_cell_load_info.g_cell_id = p_cell_ctx->global_cell_id;

    /* Filling serving cell information */
    if(RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->svr_cell_load_info.bitmask)
    {
        p_resrc_upd->serv_cell_load_info.bitmask |= RRM_OAM_RRS_LOAD_PRESENT;
        rrm_cpy_prb_usage_son(&p_resrc_upd->serv_cell_load_info.rrs, &p_cell_ctx->svr_cell_load_info.rr_load);
    }

    if(RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->svr_cell_load_info.bitmask)
    {
        p_resrc_upd->serv_cell_load_info.bitmask |= RRM_OAM_S1_TNL_LOAD_PRESENT;
        /* coverity : CID 41546, 41547 */ 
        /* Coverity_ID : 41388 */
        p_resrc_upd->serv_cell_load_info.s1_tnl_load.dl = 
            rrm_map_rrm_son_ld_lvl(p_cell_ctx->svr_cell_load_info.tnl_ld_lvl);
        //(rrm_son_rs_load_lvl_et)p_cell_ctx->svr_cell_load_info.tnl_ld_lvl; /* Coverity: CID 41388 */
        /* Coverity_ID : 41392 */
        p_resrc_upd->serv_cell_load_info.s1_tnl_load.ul =
            rrm_map_rrm_son_ld_lvl(p_cell_ctx->svr_cell_load_info.tnl_ld_lvl);
        //(rrm_son_rs_load_lvl_et)p_cell_ctx->svr_cell_load_info.tnl_ld_lvl; /* Coverity: CID 41391, 41392 */
    }

    if(RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->svr_cell_load_info.bitmask)
    {
        /* coverity : CID 41544, 41545 */
        /* Coverity : CID 41387, 41389, 41390 */
        p_resrc_upd->serv_cell_load_info.bitmask |= RRM_OAM_HW_LOAD_PRESENT;
        /* Coverity_ID : 41387 */
        p_resrc_upd->serv_cell_load_info.hw_load.dl = 
            rrm_map_rrm_son_ld_lvl(p_cell_ctx->svr_cell_load_info.hw_ld_lvl);
            //(rrm_son_rs_load_lvl_et)p_cell_ctx->svr_cell_load_info.hw_ld_lvl;
        /* Coverity_ID : 41390 */
        p_resrc_upd->serv_cell_load_info.hw_load.ul = 
            rrm_map_rrm_son_ld_lvl(p_cell_ctx->svr_cell_load_info.hw_ld_lvl);
            //(rrm_son_rs_load_lvl_et)p_cell_ctx->svr_cell_load_info.hw_ld_lvl;
    }

    if(RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT & p_cell_ctx->svr_cell_load_info.bitmask)
    {
        p_resrc_upd->serv_cell_load_info.bitmask |= RRM_OAM_COMP_LOAD_PRESENT;
        rrm_cpy_comp_avl_cap_son(&p_resrc_upd->serv_cell_load_info.comp_avl_cap_grp, &p_cell_ctx->svr_cell_load_info.comp_avl_cap_grp);
    }

    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/* RRM ES End */
/****************************************************************************
 * Function Name  : build_and_send_rsu_to_son
 * Inputs         : rrm_cell_context_t *p_cell_ctx  : cell context
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles update periodic resource in FSM
 ****************************************************************************/
rrm_return_et
build_and_send_rsu_to_son
(
 rrm_cell_context_t *p_cell_ctx        /* cell context */
 )
{
    rrm_son_load_report_ind_t   resrc_upd;
    U8                          i               = RRM_ZERO;
    U16                         max_batch_size  = RRM_ZERO;
    rrm_return_et               ret_val         = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    resrc_upd.serv_cell_load_info.bitmask = RRM_ZERO;
    resrc_upd.count = RRM_ZERO;
    /* RRM ES Start */
    rrm_fill_srv_cell_load_info(p_cell_ctx, &resrc_upd);
    /* RRM ES End */
    U32 *cell_id = (U32 *)(resrc_upd.serv_cell_load_info.g_cell_id.cell_identity);
    max_batch_size = sizeof(resrc_upd.neigh_cell_load_info)/sizeof(resrc_upd.neigh_cell_load_info[RRM_ZERO]);

    /* Filling Intra frequency neighbouring cell information */
    if (RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctx->ran_info.ncl_params.bitmask)
    {
        for (i = RRM_ZERO; i < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; i++)
        {
            if ((HO_ALLOWED == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].ho_status) &&/* Check HO status is enable */
                    (RRM_TRUE == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].broadcast_status) &&
                    (RRM_FALSE == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].blacklisted) &&
                    (RRM_FALSE == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.is_reported))
            {
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.is_reported = RRM_TRUE;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask = RRM_ZERO;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].g_cell_id = p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].cell_id;
                if(RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_RRS_PRESENT;
                    rrm_cpy_prb_usage_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].rrs,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.rr_load);
                }

                if(RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_HW_LOAD_PRESENT;
                    rrm_cpy_s1_tnl_load_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].s1_tnl_load, 
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.s1_tnl_load);
                }

                if(RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_HW_LOAD_PRESENT;
                    rrm_cpy_hw_load_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].hw_load,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.hw_load);
                }

                if(RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_COMP_AVL_CAP_GRP_PRESENT;
                    rrm_cpy_comp_avl_cap_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].comp_avl_cap_grp,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.comp_avl_cap_grp);
                }
                /** eICIC feature changes start */
                 if(RRM_ABS_STATUS_INFO_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_ABS_STATUS_PRESENT;
                    rrm_cpy_abs_status(&resrc_upd.neigh_cell_load_info[resrc_upd.count].abs_status,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.abs_status);
                }
                /** eICIC feature changes end */

                resrc_upd.count++;
                if (resrc_upd.count == max_batch_size)
                {
                    if (RRM_SUCCESS != (ret_val = rrm_son_send_rrm_son_load_report_ind(&resrc_upd, 
                                                                                       RRM_MODULE_ID, 
                                                                                       RRM_SON_MLB_MODULE_ID, 
                                                                                       RRM_ZERO,
                                                                                       p_cell_ctx->cell_index)))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_ERROR,"Failed to send LOAD Report to SON for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Successfully sent LOAD Report to SON for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }

                    resrc_upd.count = RRM_ZERO;
                }
            }
        }

        /* Filling Inter frequency neighbouring cell information */
        for (i = RRM_ZERO; i < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell; i++)
        {
            if ((HO_ALLOWED == p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].ho_status) &&/* Check HO status is enable */
                    (RRM_TRUE == p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].broadcast_status) &&
                    (RRM_FALSE == p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].blacklisted) &&
                    (RRM_FALSE == p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.is_reported))
            {
                p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.is_reported = RRM_TRUE;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask = RRM_ZERO;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].g_cell_id = p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].cell_id;
                if(RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_RRS_PRESENT;
                    rrm_cpy_prb_usage_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].rrs,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.rr_load);
                }

                if(RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_HW_LOAD_PRESENT;
                    rrm_cpy_s1_tnl_load_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].s1_tnl_load,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.s1_tnl_load);
                }

                if(RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_CELL_LOAD_INFO_HW_LOAD_PRESENT;
                    rrm_cpy_hw_load_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].hw_load, 
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.hw_load);
                }

                if(RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT & p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_SON_COMP_AVL_CAP_GRP_PRESENT;
                    rrm_cpy_comp_avl_cap_son(&resrc_upd.neigh_cell_load_info[resrc_upd.count].comp_avl_cap_grp,
                            &p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].resrc_report.comp_avl_cap_grp);
                }

                resrc_upd.count++;
                if (resrc_upd.count == max_batch_size)
                {
                    if (RRM_SUCCESS != (ret_val = rrm_son_send_rrm_son_load_report_ind(&resrc_upd, 
                                                                                        RRM_MODULE_ID, 
                                                                                        RRM_SON_MLB_MODULE_ID, 
                                                                                        RRM_ZERO,
                                                                                        p_cell_ctx->cell_index)))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_ERROR,"Failed to send LOAD Report to SON for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Successfully sent LOAD Report to SON for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }

                    resrc_upd.count = RRM_ZERO;
                }
            }
        }
    }

    if ((RRM_ZERO != (resrc_upd.count % max_batch_size)) ||
            ((RRM_ZERO == p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell) &&
             (RRM_ZERO ==  p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell)) || 
            (!(RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctx->ran_info.ncl_params.bitmask)))
    {
        if (p_cell_ctx->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
        {
            if (RRM_SUCCESS != (ret_val = rrm_son_send_rrm_son_load_report_ind(&resrc_upd, 
                                                                                RRM_MODULE_ID, 
                                                                                RRM_SON_MLB_MODULE_ID, 
                                                                                RRM_ZERO,
                                                                                p_cell_ctx->cell_index)))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_ERROR,"Failed to send LOAD Report to SON for serving cell[0x%x]",
                        RRM_NTOHL(*(cell_id)));
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Successfully sent LOAD Report to SON for serving cell[0x%x]",
                        RRM_NTOHL(*(cell_id)));
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

rrm_void_t rrm_cpy_prb_usage_oam
(
 rrm_rrs_load_ind_t *p_son_rrs_ind,
 rrm_rs_prb_t       *p_rr_load
 )
{
	RRM_UT_TRACE_ENTER();

	p_son_rrs_ind->dl_gbr_prb_usage = p_rr_load->dl_gbr_prb_usage;
	p_son_rrs_ind->ul_gbr_prb_usage = p_rr_load->ul_gbr_prb_usage;
	p_son_rrs_ind->dl_non_gbr_prb_usage = p_rr_load->dl_non_gbr_prb_usage;
	p_son_rrs_ind->ul_non_gbr_prb_usage = p_rr_load->ul_non_gbr_prb_usage;
	p_son_rrs_ind->dl_total_prb_usage = p_rr_load->dl_total_prb_usage;
	p_son_rrs_ind->ul_total_prb_usage = p_rr_load->ul_total_prb_usage;

	RRM_UT_TRACE_EXIT();
	return;
}

rrm_void_t rrm_cpy_s1_tnl_load_oam
(
 rrm_s1_tnl_load_ind_t *p_son_s1_tnl_load,
 /* coverity : CID 29653,29639,29638*/
 rrm_rs_load_lvl_et     ld_lvl 
 )
{
	RRM_UT_TRACE_ENTER();

	p_son_s1_tnl_load->dl = ld_lvl; /* Coverity: CID 29651,29465,29464 */
	p_son_s1_tnl_load->ul = ld_lvl; /* Coverity: CID 29653,29465,29466 */

	RRM_UT_TRACE_EXIT();
	return;
}

rrm_void_t rrm_cpy_hw_load_oam
(
 rrm_hw_load_ind_t *p_son_hw_load,
 /* coverity : CID 29637,29636*/
 rrm_rs_load_lvl_et ld_lvl 
 )
{
	RRM_UT_TRACE_ENTER();

	p_son_hw_load->dl = ld_lvl; /* Coverity: CID 29647,29461,29460 */
	p_son_hw_load->ul = ld_lvl; /* Coverity: CID 29649,29461,29462 */

	RRM_UT_TRACE_EXIT();
	return;
}

rrm_void_t rrm_cpy_comp_avl_cap_oam
(
 rrm_comp_avl_cap_grp_t *p_son_avl_cap,
 rrm_rs_cacg_t          *p_avl_cap
 )
{
	RRM_UT_TRACE_ENTER();

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->dl.bitmask)
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->dl_comp_avl_cap.cell_cap_class_val = p_avl_cap->dl.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->dl_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->dl_comp_avl_cap.cap_val = p_avl_cap->dl.cell_cap_val;

	if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_avl_cap->ul.bitmask)
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_SON_CELL_CAP_CLASS_VAL_PRESENT;
		p_son_avl_cap->ul_comp_avl_cap.cell_cap_class_val = p_avl_cap->ul.cell_cap_class_val;
	}
	else
	{
		p_son_avl_cap->ul_comp_avl_cap.bitmask = RRM_ZERO;
	}
	p_son_avl_cap->ul_comp_avl_cap.cap_val = p_avl_cap->ul.cell_cap_val;

	RRM_UT_TRACE_EXIT();
	return;
}

rrm_return_et
build_and_send_rsu_to_oam
(
 rrm_cell_context_t *p_cell_ctxt        /* cell context */
 )
{
    rrm_oam_load_report_ind_t resrc_upd;
    U8                          i               = RRM_ZERO;
    U16                         max_batch_size  = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();

	resrc_upd.serv_cell_load_info.bitmask = RRM_ZERO;
	resrc_upd.serv_cell_load_info.g_cell_id = p_cell_ctxt->global_cell_id;
	resrc_upd.count = RRM_ZERO;

    U32 *cell_id = (U32 *)(resrc_upd.serv_cell_load_info.g_cell_id.cell_identity);
    max_batch_size = sizeof(resrc_upd.neigh_cell_load_info)/sizeof(resrc_upd.neigh_cell_load_info[RRM_ZERO]);

    if(RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
    {
        resrc_upd.serv_cell_load_info.bitmask |= RRM_OAM_RRS_LOAD_PRESENT;
        rrm_cpy_prb_usage_oam(&resrc_upd.serv_cell_load_info.rrs, &p_cell_ctxt->svr_cell_load_info.rr_load);

    }
    if(RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
    {
        resrc_upd.serv_cell_load_info.bitmask |= RRM_OAM_S1_TNL_LOAD_PRESENT;
        /* Coverity: CID 29639,29638,29456,29455 Typecasting done */
        rrm_cpy_s1_tnl_load_oam(&resrc_upd.serv_cell_load_info.s1_tnl_load, rrm_map_rrm_oam_ld_lvl((rrm_load_type)p_cell_ctxt->svr_cell_load_info.tnl_ld_lvl));
	}

	if(RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
	{
		resrc_upd.serv_cell_load_info.bitmask |= RRM_OAM_HW_LOAD_PRESENT;
		/* Coverity: CID 29456,29454,29636,29637 Typecasting done */
        rrm_cpy_hw_load_oam(&resrc_upd.serv_cell_load_info.hw_load, rrm_map_rrm_oam_ld_lvl((rrm_load_type)p_cell_ctxt->svr_cell_load_info.hw_ld_lvl));
	}

    if(RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
    {
        resrc_upd.serv_cell_load_info.bitmask |= RRM_OAM_COMP_LOAD_PRESENT;
        rrm_cpy_comp_avl_cap_oam(&resrc_upd.serv_cell_load_info.comp_avl_cap_grp, &p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp);
    }
    /** eICIC feature changes start */
    if (RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctxt->ran_info.ncl_params.bitmask)
    {
        for (i = RRM_ZERO; i < p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; i++)
        {
            if ((HO_ALLOWED == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].ho_status) &&/* Check HO status is enable */
                    (RRM_TRUE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].broadcast_status) &&
                    (RRM_FALSE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].blacklisted) &&
                    (RRM_FALSE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.is_reported))
            {
                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.is_reported = RRM_TRUE;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask = RRM_ZERO;
                resrc_upd.neigh_cell_load_info[resrc_upd.count].g_cell_id = p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].cell_id;
                if(RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_OAM_RRS_LOAD_PRESENT;
                    rrm_cpy_prb_usage_oam_for_ncl(&resrc_upd.neigh_cell_load_info[resrc_upd.count].rrs,
                            &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.rr_load);
                }

                if(RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_OAM_S1_TNL_LOAD_PRESENT;
                    rrm_cpy_s1_tnl_load_oam_for_ncl(&resrc_upd.neigh_cell_load_info[resrc_upd.count].s1_tnl_load, 
                            &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.s1_tnl_load);
                }

                if(RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_OAM_HW_LOAD_PRESENT;
                    rrm_cpy_hw_load_oam_for_ncl(&resrc_upd.neigh_cell_load_info[resrc_upd.count].hw_load,
                            &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.hw_load);
                }

                if(RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_OAM_COMP_LOAD_PRESENT;
                    rrm_cpy_comp_avl_cap_oam_for_ncl(&resrc_upd.neigh_cell_load_info[resrc_upd.count].comp_avl_cap_grp,
                            &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.comp_avl_cap_grp);
                }
                /** eICIC feature changes start */
                if(RRM_ABS_STATUS_INFO_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.bitmask)
                {
                    resrc_upd.neigh_cell_load_info[resrc_upd.count].bitmask |= RRM_OAM_ABS_STATUS_PRESENT;
                    rrm_cpy_abs_status_oam(&resrc_upd.neigh_cell_load_info[resrc_upd.count].abs_status,
                            &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].resrc_report.abs_status);
                }
                /** eICIC feature changes end */

                resrc_upd.count++;
                if (resrc_upd.count == max_batch_size)
                {

                    ret_val = rrm_oam_send_rrm_oam_load_report_ind(&resrc_upd, RRM_MODULE_ID, RRM_OAM_MODULE_ID,RRM_ZERO,p_cell_ctxt->cell_index);

                    if (RRM_SUCCESS != ret_val)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_ERROR,"Failed to send LOAD Report to OAM for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                RRM_DETAILED,"Successfully sent LOAD Report to OAM for serving cell[0x%x]",
                                RRM_NTOHL(*(cell_id)));
                    }
                    resrc_upd.count = RRM_ZERO;
                }
            }
        }

    }  
    /* Filling Inter frequency neighbouring cell information */
    if ((RRM_ZERO != (resrc_upd.count % max_batch_size)) ||
            ((RRM_ZERO == p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell) &&
             (RRM_ZERO ==  p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell)) || 
            (!(RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctxt->ran_info.ncl_params.bitmask)))
    {
        if (p_cell_ctxt->registered_mod_by_son & CELL_ALREADY_REGISTERD_FOR_MLB)
        {
            ret_val = rrm_oam_send_rrm_oam_load_report_ind(&resrc_upd, RRM_MODULE_ID, RRM_OAM_MODULE_ID,RRM_ZERO,p_cell_ctxt->cell_index);

            if (RRM_SUCCESS != ret_val)
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_ERROR,"Failed to send LOAD Report to OAM for serving cell[0x%x]",
                        RRM_NTOHL(*(cell_id)));
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                        RRM_DETAILED,"Successfully sent LOAD Report to OAM for serving cell[0x%x]",
                        RRM_NTOHL(*(cell_id)));
            }
        }
    }
    /** eICIC feature changes end */    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}    

/*Load end*/

/* DYNAMIC ICIC CHANGES START */

/*****************************************************************************
 * Array Name     : build_and_send_uem_update_ue_info 
 * Inputs         : Pointer to partition info
 * Outputs        : None
 * Returns        : None
 * Description    : This function will send the UEM update_ue_info API
 ****************************************************************************/
rrm_return_et build_and_send_uem_update_ue_info
(
   rrm_cell_context_t                       *p_cell_ctx,
   rrmuem_cm_update_ue_info_req_t           *p_update_ue_info
)
{
    rrm_return_et ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    if (RRM_FAILURE == rrm_send_internal_msg ((U16)RRM_UEM_MODULE_ID,
                RRMUEM_CM_UPDATE_UE_INFO_REQ,
                sizeof(rrmuem_cm_update_ue_info_req_t),
                (void *)p_update_ue_info))

    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "failure in sending :%d for cell index:%d",
                RRMUEM_CM_UPDATE_UE_INFO_REQ,
                p_cell_ctx->cell_index);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "success in sending :%d for cell index:%d",
                RRMUEM_CM_UPDATE_UE_INFO_REQ,
                p_cell_ctx->cell_index);
        ret_val = RRM_SUCCESS;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/****************************************************************************
 * Function Name  : rrm_cellm_cell_ue_update_ue_info_process_msg
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *		  : U16 api_id : api id
 *		  : U16 data_len : data length
 *		  : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context 
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the ue delete response from UE to cell
 ****************************************************************************/
rrm_return_et  
rrm_cellm_cell_ue_update_ue_info_process_msg(
	 	 rrm_void_t *p_api,/*pointer pt api buffer*/
		 U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
		 )
{
    rrm_cell_index_t                  cell_index=RRM_ZERO;
    rrm_return_et                     ret_val = RRM_SUCCESS;
    rrmuem_cm_update_ue_info_resp_t  *rrmcm_uem_info_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrmcm_uem_info_resp =
        (rrmuem_cm_update_ue_info_resp_t *)p_api;

    cell_index = rrmcm_uem_info_resp->cell_index;
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);

    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"Cell context not found for cell index: %d", cell_index);
        /* SPR 21251 End */
        return RRM_FAILURE;
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api; 
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = RRMUEM_CM_UPDATE_UE_INFO_RESP;

    if (RRM_FAILURE == cellm_fsm_process_event (
                RRM_UEM_OR_L2_RESPONSE_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "UEM->CellM:RRMUEM_CM_UPDATE_UE_INFO_RESP:[CELL:%d] failed to process", cell_index);
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO, 
                "UEM->CellM:RRMUEM_CM_UPDATE_UE_INFO_RESP:[CELL:%d] successfully processed", cell_index);
        ret_val = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_START */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_stop_broadcast_resp
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *                : U16 api_id         : api id
 *                : U16 data_len       : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell stop broadcast response
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_stop_broadcast_resp(
         rrm_void_t *p_api,/*pointer pt api buffer*/
         U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
         )
{
    rrm_cell_index_t                        cell_index = RRM_ZERO;
    rrm_return_et                           ret_val = RRM_SUCCESS;
    rrmuem_cm_cell_stop_broadcast_resp_t *p_rrmuem_cm_cell_stop_broadcast_resp;

    RRM_UT_TRACE_ENTER();

    p_rrmuem_cm_cell_stop_broadcast_resp = (rrmuem_cm_cell_stop_broadcast_resp_t*)p_api;

    /* This Cell Index is the Scell Index from which the cell_info_change_ind was received */
    cell_index = p_rrmuem_cm_cell_stop_broadcast_resp->scell_index;

    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
            "UEM->CellM:RRMUEM_CM_CELL_STOP_RESP:[CELL:%d]with status: %d",
            cell_index, p_rrmuem_cm_cell_stop_broadcast_resp->status);
    if(p_rrmuem_cm_cell_stop_broadcast_resp->status)
    {
        if (RRM_FAILURE == cellm_fsm_process_event (
                    RRMUEM_CM_CELL_STOP_BROADCAST_RESP_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "UEM->RRMUEM_CM_CELL_STOP_RESP->CellM failed to process");
            ret_val = RRM_FAILURE;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_INFO,
                    "UEM->RRMUEM_CM_CELL_STOP_RESP->CellM successfully processed");
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Status should not be Failure. Status[%d]",p_rrmuem_cm_cell_stop_broadcast_resp->status);
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* BUG_11648_FIX_END */
/* CA_Stage3_Change: Start */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_info_change_ind_resp
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *                : U16 api_id         : api id
 *                : U16 data_len       : data length
 *                : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the cell info change response
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_info_change_ind_resp(
         rrm_void_t *p_api,/*pointer pt api buffer*/
         U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
         )
{
    rrm_cell_index_t                        cell_index = RRM_ZERO;
    rrm_return_et                           ret_val = RRM_SUCCESS;
    rrmuem_cm_cell_info_change_ind_resp_t   *p_uem_cm_cell_info_change_ind_resp;

    RRM_UT_TRACE_ENTER();

    p_uem_cm_cell_info_change_ind_resp = (rrmuem_cm_cell_info_change_ind_resp_t *)p_api;

    /* This Cell Index is the Scell Index from which the cell_info_change_ind was received */
    cell_index = p_uem_cm_cell_info_change_ind_resp->scell_index;

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
	        "UEM->CellM:RRMUEM_CM_CELL_INFO_CHANGE_RESP:[CELL:%d] with status: %d",
            cell_index, p_uem_cm_cell_info_change_ind_resp->status);
    
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    if(p_uem_cm_cell_info_change_ind_resp->status)
    {

        /*SPR 13316:start*/
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ongoing_trans_id = 
                p_uem_cm_cell_info_change_ind_resp->trans_id;
        /*SPR 13316:end*/
        if (RRM_FAILURE == cellm_fsm_process_event (
                    RRMUEM_CM_CELL_INFO_CHANGE_RESP_EVENT,
                    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
        {
            ret_val = RRM_FAILURE;
        }
        else
        {
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Status should not be Failure. Status[%d]",p_uem_cm_cell_info_change_ind_resp->status);
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA_Stage3_Change: End */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : fill_otdoa_information_from_cellm
 * Inputs         : rrm_cell_index_t cell_index : Cell index for which date need to fetch
 *                : U32 otdoa_info_item : otdoa_info_item
 *                : S1ap_rrm_lppa_otdoa_info_resp_t * rrm_s1ap_lppa_otdoa_info_resp : pointer
 * Outputs        : None
 * Returns        : return_status 
 * Description    : FILL OTDOA information from cell context  from the RRC
 ****************************************************************************/
rrm_return_et
fill_otdoa_information_from_cellm_lppa_tac(rrm_cell_index_t                cell_index ,
                                           rrm_cell_context_t              *p_cell_ctxt ,
                                           s1ap_rrm_lppa_otdoa_info_resp_t *p_rrm_s1ap_lppa_otdoa_info_resp ,
                                           U16                             otdoa_cell_count ,
                                           U8                              otdoa_cell_info_count)
{
    U16                                  index                   = RRM_ZERO;
    rrm_return_et                        return_status           = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if ( p_cell_ctxt->epc_info.epc_params.bitmask & RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "OTDOA_INFO_REQ filling LAPP_TAC at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                otdoa_cell_info_count,otdoa_cell_count,cell_index);
        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
            LPPA_OTDOA_CELLS_TAC_PRESENT;
        for(index=RRM_ZERO; index < MAX_TAC_SIZE ; index ++ )
        {
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].otdoa_cells_tac.tac[index]=
                p_cell_ctxt->epc_info.epc_params.general_epc_params.tac[index];
        }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "LAPP_TAC not present at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                otdoa_cell_info_count,otdoa_cell_count,cell_index);
        /* SPR 21251 End */
        return_status = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return return_status ;
}
/****************************************************************************
 * Function Name  : fill_otdoa_information_from_cellm_lppa_e_utran
 * Inputs         : rrm_cell_index_t cell_index : Cell index for which date need to fetch
 *                : U32 otdoa_info_item : otdoa_info_item
 *                : S1ap_rrm_lppa_otdoa_info_resp_t * rrm_s1ap_lppa_otdoa_info_resp : pointer
 * Outputs        : None
 * Returns        : return_status
 * Description    : FILL OTDOA information from cell context  from the RRC
 ****************************************************************************/
rrm_return_et
fill_otdoa_information_from_cellm_lppa_e_utran(rrm_cell_index_t                 cell_index ,
                                               rrm_cell_context_t               *p_cell_ctxt ,
                                               s1ap_rrm_lppa_otdoa_info_resp_t  *p_rrm_s1ap_lppa_otdoa_info_resp ,
                                               U16                              otdoa_cell_count ,
                                               U8                               otdoa_cell_info_count)
{
    rrm_return_et                        return_status           = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    if ( RRMCM_RMIF_EUTRAN_ACCESS_POINT_POS_PRESENT & p_cell_ctxt->operator_info.bitmask)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "LPPA_E_UTRANACCESSPOINTPOSITION at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                otdoa_cell_info_count,otdoa_cell_count,cell_index);
        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
            LPPA_OTDOA_CELLS_ACCESS_POINT_POS_PRESENT;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.latitude_sign = p_cell_ctxt->operator_info.eutran_access_point_pos.latitude_sign;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.deg_of_latitude = p_cell_ctxt->operator_info.eutran_access_point_pos.deg_of_latitude;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.deg_of_longitude = p_cell_ctxt->operator_info.eutran_access_point_pos.deg_of_longitude;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.deg_of_altitude =  p_cell_ctxt->operator_info.eutran_access_point_pos.dir_of_altitude;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.altitude = p_cell_ctxt->operator_info.eutran_access_point_pos.altitude;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.uncertainty_semi_major =  p_cell_ctxt->operator_info.eutran_access_point_pos.uncertainty_semi_major;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.uncertainty_semi_minor = p_cell_ctxt->operator_info.eutran_access_point_pos.uncertainty_semi_minor;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.orientation_of_major_axis = p_cell_ctxt->operator_info.eutran_access_point_pos.orientation_of_major_axis;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.uncertainty_altitude = p_cell_ctxt->operator_info.eutran_access_point_pos.uncertainty_altitude;

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
            e_utran_acces_point_pos.confidence   =  p_cell_ctxt->operator_info.eutran_access_point_pos.confidence;

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_ERROR,
                "EUTRAN ACCESS POINT POS information is not present"); 

        return_status = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return return_status ;
}
/****************************************************************************
 * Function Name  : fill_otdoa_information_from_cellm_lppa_prsmuticonfiguration
 * Inputs         : rrm_cell_index_t cell_index : Cell index for which date need to fetch
 *                : U32 otdoa_info_item : otdoa_info_item
 *                : S1ap_rrm_lppa_otdoa_info_resp_t * rrm_s1ap_lppa_otdoa_info_resp : pointer
 * Outputs        : None
 * Returns        : return_status
 * Description    : FILL OTDOA information from cell context  from the RRC
 ****************************************************************************/
rrm_return_et
fill_otdoa_information_from_cellm_lppa_prsmuticonfiguration(rrm_cell_index_t                cell_index ,
                                                            rrm_cell_context_t              *p_cell_ctxt ,
                                                            s1ap_rrm_lppa_otdoa_info_resp_t *p_rrm_s1ap_lppa_otdoa_info_resp ,
                                                            U16                             otdoa_cell_count ,
                                                            U8                              otdoa_cell_info_count)
{
    rrm_return_et                        return_status           = RRM_SUCCESS;
    U8                                   first_eight_mutting_bits = RRM_ZERO;
    U8                                   last_eight_mutting_bits  = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    if (p_cell_ctxt->ran_info.physical_layer_params.bitmask & RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                "LPPA_PRSMUTICONFIGURATION at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                otdoa_cell_info_count,otdoa_cell_count,cell_index);

        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
        p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
            LPPA_OTDOA_CELLS_PRS_MUTING_CONFIG_PRESENT;

        /*****Copy Muting two******/
        if (p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
        {	
            first_eight_mutting_bits = p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_two;	
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    " muting_config_two=%d  cellindex =%d ",
                    p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_two,
                    cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.bitmask |= LPPA_PRS_MUTING_CONFIG_TWO_PRESENT;

            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.muting_config_two.two = first_eight_mutting_bits; 

        }
        /*****Copy Muting four*****/
        else if (p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    " muting_config_four=%d cellindex =%d ",
                    p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_four,
                    cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.bitmask |= LPPA_PRS_MUTING_CONFIG_FOUR_PRESENT;

            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.muting_config_four.four = 
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_four;
        }
        /*****Copy Muting eight****/
        else if(p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask &  RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    " muting_config_eight=%d cellindex =%d ",
                    p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_eight,
                    cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.bitmask |= LPPA_PRS_MUTING_CONFIG_EIGHT_PRESENT;

            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.muting_config_eight.eight[MUTING_OCTET_ONE - RRM_ONE] = 
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_eight;
        }
        /*****Copy Muting sixteen**/
        else if(p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
        { 
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.bitmask |= LPPA_PRS_MUTING_CONFIG_SIXTEEN_PRESENT;
            first_eight_mutting_bits = 
                (p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_sixteen & RRM_U16_LOW_BYTE_MASK);
            last_eight_mutting_bits = 
                ((p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_sixteen >> RRM_EIGHT) & RRM_U16_LOW_BYTE_MASK);

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                    " muting_config_sixteen=%d  first_eight_mutting =%d, last_eight_mutting =%d, cellindex =%d ",
                    p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_muting_configration.muting_config_sixteen,
                    first_eight_mutting_bits,last_eight_mutting_bits,
                    cell_index);

            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.muting_config_sixteen.sixteen[RRM_ZERO] = first_eight_mutting_bits;
	    /* SPR 19838 : CID 12168 Fix Start */
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].\
                prs_muting_config.muting_config_sixteen.sixteen[RRM_ONE] = last_eight_mutting_bits; 
	    /* SPR 19838 : CID 12168 Fix End */
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_ERROR,
                    "PRS muting information is not present"); 
            return_status = RRM_FAILURE;
        }
    }
    else 
    {
        RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_ERROR,
                "PRS information is not present"); 
        return_status = RRM_FAILURE;
    }	
    RRM_UT_TRACE_EXIT();
    return return_status ;
}
/*Klockwork_fix_end*/
/****************************************************************************
 * Function Name  : fill_otdoa_information_from_cellm
 * Inputs         : rrm_cell_index_t cell_index : Cell index for which date need to fetch
 *                : U32 otdoa_info_item : otdoa_info_item 
 *                : S1ap_rrm_lppa_otdoa_info_resp_t * rrm_s1ap_lppa_otdoa_info_resp : pointer
 * Outputs        : None
 * Returns        : void
 * Description    : FILL OTDOA information from cell context  from the RRC
 ****************************************************************************/

rrm_return_et fill_otdoa_information_from_cellm
(
   rrm_cell_index_t cell_index, 
   U32 otdoa_info_item,
   s1ap_rrm_lppa_otdoa_info_resp_t * p_rrm_s1ap_lppa_otdoa_info_resp,
   rrm_cause_t *p_otdoa_cause
)
{
    rrm_return_et                        return_status           = RRM_SUCCESS;
    rrm_cell_context_t                   *p_cell_ctxt            = RRM_PNULL;
    U16                                  otdoa_cell_count        = RRM_ZERO; 
    U8                                   otdoa_cell_info_count   = RRM_ZERO;	
    RRM_UT_TRACE_ENTER();

    p_cell_ctxt =  rrm_cellm_get_cell_context(cell_index);
    if( p_cell_ctxt == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
                "p_cell_ctxt is NULL for cell index: %d", cell_index);
        /* SPR 21251 End */
        return RRM_FAILURE;
    }

    otdoa_cell_count = p_rrm_s1ap_lppa_otdoa_info_resp->otdoa_cell_count; 
    otdoa_cell_info_count = p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count;

    switch(otdoa_info_item)
    {
        case LPPA_PCI:
             RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "OTDOA_INFO_REQ filling PCI at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
           
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask 
                |= LPPA_OTDOA_CELLS_PCI_PRESENT;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].pci =
                p_cell_ctxt->ran_info.rf_params.rf_configurations.phy_cell_id;
            break;

        case LPPA_CELL_Id:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "OTDOA_INFO_REQ filling CELL_Id at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_CELL_ID_PRESENT;
            return_status = rrm_convert_rrm_ecgi_into_rrc_ecgi(p_cell_ctxt->global_cell_id,
                    &(p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].cell_id));	
            break;

        case LPPA_TAC:
             /*Klockwork_fix_start*/
             return_status = fill_otdoa_information_from_cellm_lppa_tac(cell_index,p_cell_ctxt ,
                      p_rrm_s1ap_lppa_otdoa_info_resp ,otdoa_cell_count ,otdoa_cell_info_count);
             /*Klockwork_fix_end*/
            break;
        case LPPA_EARFCN:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_EARFCN at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_EARFCN_PRESENT;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].earfcn =
                p_cell_ctxt->ran_info.rf_params.rf_configurations.dl_earfcn;	
            break;
        case LPPA_PRSBANDWIDTH:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_PRSBANDWIDTH at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_PRS_BAND_WIDTH_PRESENT;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].prs_band_width =
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.num_prs_resource_blocks;

            break;
        case LPPA_PRSCONFIGINDEX:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_PRSCONFIGINDEX at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_CONFIG_INDEX_PRESENT;

            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].prs_config_index =
                p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.prs_configuration_index;
            break;
        case LPPA_CPLENGTH:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_CPLENGTH at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_CP_LENGTH_PRESENT;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].cp_length =
                (U32)p_cell_ctxt->operator_info.sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length;

            break;
        case LPPA_NODIFRAMES:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_NODIFRAMES at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_DL_FRAMES_PRESENT;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].no_of_dl_frames =
                (U32)p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_prs.num_consecutive_prs_subfames;
            break;
        case LPPA_NONANTENAPORTS:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                      "LPPA_NONANTENAPORTS at otdoa_cell_info_count=%d,otdoa_cell_count=%d, cellindex =%d ",
                       otdoa_cell_info_count,otdoa_cell_count,cell_index);
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otdoa_cell_info_count += RRM_ONE;
            p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].bitmask |=
                LPPA_OTDOA_CELLS_ANTENA_PORTS_PRESENT;
            if((p_cell_ctxt->ran_info.antenna_info.antenna_ports_count_number == ANTENNA_PORTS_COUNT_AN1) || 
               (p_cell_ctxt->ran_info.antenna_info.antenna_ports_count_number == ANTENNA_PORTS_COUNT_AN2) )
            {
                 p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].no_of_antenna_ports =
                                             RRM_ZERO;
            }
            else
            {
                 p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[otdoa_cell_count].otda_cells_info_arr[otdoa_cell_info_count].no_of_antenna_ports =
                                             RRM_ONE;
            }
            break;
        case LPPA_E_UTRANACCESSPOINTPOSITION:
            /*Klockwork_fix_start*/
            return_status = fill_otdoa_information_from_cellm_lppa_e_utran(cell_index ,p_cell_ctxt ,
                           p_rrm_s1ap_lppa_otdoa_info_resp ,otdoa_cell_count ,otdoa_cell_info_count);
            /*Klockwork_fix_end*/


            break;
        case LPPA_PRSMUTICONFIGURATION:
            /*Klockwork_fix_start*/
            return_status = fill_otdoa_information_from_cellm_lppa_prsmuticonfiguration(cell_index ,p_cell_ctxt ,
                                       p_rrm_s1ap_lppa_otdoa_info_resp ,otdoa_cell_count ,otdoa_cell_info_count);
            /*Klockwork_fix_end*/

            break;
        case LPPA_SFNINITTIME:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "LPPA_SFNINITTIME not supported by RRM  cell_index =%d",cell_index);
            return_status = RRM_FAILURE;
            p_otdoa_cause->type   = RRM_ECID_RADIO_NW_LAYER_CAUSE;
            p_otdoa_cause->value  = RRM_RNL_REQUESTED_ITEM_NOT_SUPPORTED;
            break;

        default:
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Invalid OTDOA Quantifier recevied %d cell_index= %d",otdoa_info_item,cell_index);
            return_status = RRM_FAILURE;
            p_otdoa_cause->type   = RRM_ECID_RADIO_NW_LAYER_CAUSE;
            p_otdoa_cause->value  = RRM_RNL_REQUESTED_ITEM_NOT_SUPPORTED;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return return_status;
} 
/****************************************************************************
 * Function Name  : rrm_rrc_lppa_otdoa_info_req_process_msg
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rrc_rrm_lppa_otdoa_info_req message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_lppa_otdoa_info_req_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len, /* incoming data length*/
 U16     trans_id /* Incoming transaction Id*/
 )
{
    rrm_return_et                         ret_val                         = RRM_SUCCESS;
    s1ap_rrm_lppa_otdoa_info_req_t        *p_s1ap_rrm_lppa_otdoa_info_req = RRM_NULL;
    rrm_cell_index_t  	                  cell_index                      = RRM_ZERO;
    //s1ap_rrm_lppa_otdoa_info_resp_t       rrm_s1ap_lppa_otdoa_info_resp;	
    s1ap_rrm_lppa_otdoa_info_resp_t       *p_rrm_s1ap_lppa_otdoa_info_resp = RRM_NULL ;	
    U16                                   requested_otdoa_counter         = RRM_ZERO;
    s1ap_rrm_lppa_otdoa_info_fail_t       rrm_s1ap_lppa_otdoa_info_fail;
    rrm_bool_et                           avl_supp_otdoa_info             = RRM_TRUE;
    rrm_return_et                         return_status                   = RRM_FAILURE;
    rrm_cause_t                           cause                           = {RRM_ZERO};


    S32 length = RRM_NULL;
    RRM_UT_TRACE_ENTER();

    p_s1ap_rrm_lppa_otdoa_info_req = (s1ap_rrm_lppa_otdoa_info_req_t*)rrm_mem_get(sizeof
            (s1ap_rrm_lppa_otdoa_info_req_t));

    p_rrm_s1ap_lppa_otdoa_info_resp = (s1ap_rrm_lppa_otdoa_info_resp_t *)rrm_mem_get(sizeof
                                       (s1ap_rrm_lppa_otdoa_info_resp_t));
    if(RRM_PNULL == p_s1ap_rrm_lppa_otdoa_info_req || RRM_PNULL == p_rrm_s1ap_lppa_otdoa_info_resp )
    {
        if(RRM_PNULL == p_s1ap_rrm_lppa_otdoa_info_req)
        {
            RRM_MEM_FREE(p_rrm_s1ap_lppa_otdoa_info_resp);
        }
        else 
        {
            RRM_MEM_FREE(p_s1ap_rrm_lppa_otdoa_info_req);
        }
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "MEMEORY allocation failure for api:%d ",api_id);
        return RRM_FAILURE;
    }

    RRM_MEMSET( p_rrm_s1ap_lppa_otdoa_info_resp , RRM_ZERO, sizeof(s1ap_rrm_lppa_otdoa_info_resp_t));
    RRM_MEMSET(&rrm_s1ap_lppa_otdoa_info_fail, RRM_ZERO, sizeof(s1ap_rrm_lppa_otdoa_info_fail_t));


    /* Parse  the incoming message from RRC */
    if (RRM_FAILURE == rrm_il_parse_s1ap_rrm_lppa_otdoa_info_req(
                p_s1ap_rrm_lppa_otdoa_info_req,
                p_api,
                data_len,
                &length))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "RRC->RRM:S1AP_RRM_LPPA_OTDOA_INFO_REQ failed to parse");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
                "RRC->RRM:S1AP_RRM_LPPA_OTDOA_INFO_REQ successfully parsed");
        cause.type   = RRM_ECID_RADIO_NW_LAYER_CAUSE;
        cause.value  = RRM_RNL_REQUESTED_ITEM_TEMPORARILLY_NOT_AVAILABLE;

        for (cell_index = RRM_ZERO; cell_index < RRM_MAX_NUM_CELLS; cell_index++)
        {
            SET_CELL_INDEX(cell_index);
            return_status = RRM_FAILURE;
            avl_supp_otdoa_info = RRM_TRUE;

            if ((p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index] != RRM_PNULL) && 
                    (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_state == CELL_STATE_ACTIVE))
            {
                if(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable)
                {
                    for(requested_otdoa_counter = RRM_ZERO; 
                            requested_otdoa_counter < p_s1ap_rrm_lppa_otdoa_info_req->otdoa_info_count && avl_supp_otdoa_info;
                            requested_otdoa_counter++)
                    {
                        return_status = fill_otdoa_information_from_cellm(cell_index, 
                                p_s1ap_rrm_lppa_otdoa_info_req->otda_info_type_arr[requested_otdoa_counter].otdoa_info_item, 
                                p_rrm_s1ap_lppa_otdoa_info_resp ,&cause);
                        if(return_status == RRM_FAILURE)
                        {
                            avl_supp_otdoa_info = RRM_FALSE;
                        }		

                    }
                    if(RRM_FAILURE == return_status ) 
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                "NO filling OTDOA info for the cellindex =%d ",
                                cell_index);
                        RRM_MEMSET(&(p_rrm_s1ap_lppa_otdoa_info_resp->otda_cells_arr[p_rrm_s1ap_lppa_otdoa_info_resp->otdoa_cell_count]), 
                                RRM_ZERO, sizeof(lppa_otdoa_cells_t));
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                "filling OTDOA info resp for the cellindex =%d ",
                                cell_index);
                        p_rrm_s1ap_lppa_otdoa_info_resp->otdoa_cell_count += RRM_ONE;
                    }
                }
                else
                {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED, 
                                "PRS_ENABLE=%d is FALSE for the cellindex =%d ",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.physical_layer_params.physical_layer_param_prs.prs_enable,
                                cell_index);
                }
            }	
        }
        if (p_rrm_s1ap_lppa_otdoa_info_resp->otdoa_cell_count > RRM_ZERO)
        {
            /****Copy MME_ID information from requested OTDOA information to response***/ 
            p_rrm_s1ap_lppa_otdoa_info_resp->mme_id = p_s1ap_rrm_lppa_otdoa_info_req->mme_id;

            /****Copy routing_id information from requested OTDOA information to response***/ 
            p_rrm_s1ap_lppa_otdoa_info_resp->routing_id = p_s1ap_rrm_lppa_otdoa_info_req->routing_id;

            /****Copy lppa_trans_id information from requested OTDOA information to response***/ 
            p_rrm_s1ap_lppa_otdoa_info_resp->lppa_trans_id = p_s1ap_rrm_lppa_otdoa_info_req->lppa_trans_id;

            /****Send RRM->RRC API S1AP_RRM_LPPA_OTDOA_INFO_RESP****/
            if ( RRM_SUCCESS != rrm_il_send_s1ap_rrm_lppa_otdoa_info_resp( p_rrm_s1ap_lppa_otdoa_info_resp , 
                        RRM_MODULE_ID, 
                        RRC_MODULE_ID, 
                        trans_id, RRM_ZERO))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Error in sending S1AP_RRM_LPPA_OTDOA_INFO_RESP ");
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix start*/
                if( RRM_NULL != p_rrm_s1ap_lppa_otdoa_info_resp )
                    RRM_MEM_FREE(p_rrm_s1ap_lppa_otdoa_info_resp);
                if( RRM_NULL != p_s1ap_rrm_lppa_otdoa_info_req )
                    RRM_MEM_FREE ( p_s1ap_rrm_lppa_otdoa_info_req );
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix end*/
                /* SPR: 15922 Fix Start */
                ret_val =  RRM_FAILURE;
                /* SPR: 15922 Fix End */
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " Sucessfully sending S1AP_RRM_LPPA_OTDOA_INFO_RESP ");
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix start*/
                if( RRM_NULL != p_rrm_s1ap_lppa_otdoa_info_resp )
                    RRM_MEM_FREE(p_rrm_s1ap_lppa_otdoa_info_resp);
                if( RRM_NULL != p_s1ap_rrm_lppa_otdoa_info_req )
                    RRM_MEM_FREE ( p_s1ap_rrm_lppa_otdoa_info_req );
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix end*/
                /* SPR: 15922 Fix Start */
                ret_val =  RRM_SUCCESS;
                /* SPR: 15922 Fix End */
            }
        }
        else /** Sending S1AP_RRM_LPPA_OTDOA_INFO_FAIL API from RRM***/
        {
            /****Copy MME_ID information from requested OTDOA information to response***/
            rrm_s1ap_lppa_otdoa_info_fail.mme_id = p_s1ap_rrm_lppa_otdoa_info_req->mme_id;

            /****Copy routing_id information from requested OTDOA information to response***/
            rrm_s1ap_lppa_otdoa_info_fail.routing_id =  p_s1ap_rrm_lppa_otdoa_info_req->routing_id;

            /****Copy lppa_trans_id information from requested OTDOA information to response***/
            rrm_s1ap_lppa_otdoa_info_fail.lppa_trans_id = p_s1ap_rrm_lppa_otdoa_info_req->lppa_trans_id;

            rrm_s1ap_lppa_otdoa_info_fail.cause.type = cause.type;
            rrm_s1ap_lppa_otdoa_info_fail.cause.value = cause.value;


            /****Send RRM->RRC API S1AP_RRM_LPPA_OTDOA_INFO_FAIL***/
            if ( RRM_SUCCESS != rrm_il_send_s1ap_rrm_lppa_otdoa_info_fail(&rrm_s1ap_lppa_otdoa_info_fail,
                        RRM_MODULE_ID,
                        RRC_MODULE_ID,
                        trans_id, RRM_ZERO))
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Error in sending S1AP_RRM_LPPA_OTDOA_INFO_FAIL ");
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix start*/
                if( RRM_NULL != p_rrm_s1ap_lppa_otdoa_info_resp )
                    RRM_MEM_FREE(p_rrm_s1ap_lppa_otdoa_info_resp);
                if( RRM_NULL != p_s1ap_rrm_lppa_otdoa_info_req )
                    RRM_MEM_FREE ( p_s1ap_rrm_lppa_otdoa_info_req );
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix end*/
                /* SPR: 15922 Fix Start */
                ret_val =  RRM_FAILURE;
                /* SPR: 15922 Fix End */
            }
            else
            {

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " Sucessfully sending S1AP_RRM_LPPA_OTDOA_INFO_FAIL ");
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix start*/
                if( RRM_NULL != p_rrm_s1ap_lppa_otdoa_info_resp )
                    RRM_MEM_FREE(p_rrm_s1ap_lppa_otdoa_info_resp);
                if( RRM_NULL != p_s1ap_rrm_lppa_otdoa_info_req )
                    RRM_MEM_FREE ( p_s1ap_rrm_lppa_otdoa_info_req );
                /* COVERITY : RESOURCE LEAK : CID : 54349,54350 fix end*/
                /* SPR: 15922 Fix Start */
                ret_val =  RRM_SUCCESS;
                /* SPR: 15922 Fix End */
            }
        } 
    }
    RRM_MEM_FREE(p_s1ap_rrm_lppa_otdoa_info_req);
    RRM_MEM_FREE( p_rrm_s1ap_lppa_otdoa_info_resp );
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_rrc_x2ap_rrm_load_info_res_process_msg 
 * Inputs         : U8 *p_api :pointer to input API buffer
 *                : U16 api_id :api id
 *                : U16 data_len : data length
 *                : rrm_global_context_t *p_g_rrm_cell_ctx : pointer
 *                :  to cell global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Processes rrm_load_info_res_process_msg message from the RRC
 ****************************************************************************/
rrm_return_et
rrm_rrc_x2ap_rrm_load_info_res_process_msg
(
 U8      *p_api, /* Pointer to incoming Api buffer*/
 U16     api_id, /* incoming api id*/
 U16     data_len, /* incoming data length*/
 U16     trans_id /* Incoming transaction Id*/
 )
{
	rrm_return_et                         ret_val = RRM_SUCCESS;
	x2ap_rrm_load_information_resp_t      *p_x2ap_rrm_load_info_res = RRM_PNULL;
  S32 length = RRM_NULL;

	RRM_UT_TRACE_ENTER();
	p_x2ap_rrm_load_info_res = (x2ap_rrm_load_information_resp_t *) \
				       rrm_mem_get (sizeof (x2ap_rrm_load_information_resp_t));
    if ( p_x2ap_rrm_load_info_res == RRM_PNULL)
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_x2ap_rrm_load_info_res failed" );
        /* SPR 21251 End */
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
	if (RRM_FAILURE == rrm_parse_x2ap_rrm_load_information_resp(
				p_x2ap_rrm_load_info_res,
				p_api,
				data_len,
				&length))
	{
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
				"RRC->:CellM:X2AP_RRM_LI_ENB_LOAD_INFORMATION_RES unable to parse");
		ret_val = RRM_FAILURE;
	}
	else
	{
		if (RRM_SUCCESS != p_x2ap_rrm_load_info_res->response)
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,\
					"RRC->RRM:X2AP_RRM_LI_ENB_LOAD_INFORMATION_RES with response: %d", p_x2ap_rrm_load_info_res->response);
		}
		else /* Response != RRM_FAILURE */
		{
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
					"RRC->RRM:X2AP_RRM_LI_ENB_LOAD_INFORMATION_RES with response: %d", p_x2ap_rrm_load_info_res->response);
		}
	}
	RRM_MEM_FREE (p_x2ap_rrm_load_info_res);

	RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_build_and_send_load_info_req_to_macro_enb 
 * Inputs         : rrm_cellm_enb_id_hnode_t *p_enb_hnode :pointer 
                                         to nodebId
 *                : rrm_cell_context_t *p_cell_ctxt : pointer
 *                :  to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Sends Load Information Req to RRC
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_load_info_req_to_macro_enb
(
 rrm_cellm_enb_id_hnode_t *p_enb_hnode,
 rrm_cell_context_t       *p_cell_ctxt        /* cell context */
)
{
	rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    U16                               num_cell = RRM_ZERO;
	rrm_return_et                     ret_val = RRM_SUCCESS;
    rrm_oam_eutran_global_cell_id_t   eutran_global_cell_id_arr[MAX_NUM_CELLS_IN_MACRO_ENB] ;

    RRM_MEMSET(&eutran_global_cell_id_arr, 
                RRM_ZERO, 
                (sizeof(rrm_oam_eutran_global_cell_id_t) * MAX_NUM_CELLS_IN_MACRO_ENB));

    RRM_UT_TRACE_ENTER ();

	RRM_ASSERT (RRM_PNULL != p_enb_hnode);

	while (RRM_PNULL != (p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)ylPopHead(&p_enb_hnode->list)))
	{
		if ((HO_ALLOWED == p_enb_lnode->enb_info.ho_status) && /* Check HO status is enable */
            (RRM_TRUE   == p_enb_lnode->enb_info.broadcast_status) &&
            (RRM_FALSE  == p_enb_lnode->enb_info.blacklisted))
		{
			if ((RRM_TRUE == p_enb_lnode->enb_info.x2_link_up_status) ||
    			(X2_ALLOWED_CONNECTED == p_enb_lnode->enb_info.x2_status))
			{
				RRM_MEMCPY(&eutran_global_cell_id_arr[num_cell],
						&p_enb_lnode->enb_info.cell_id, sizeof (rrm_oam_eutran_global_cell_id_t));
				num_cell++;
			}
			else
			{
                /* SPR 21251 Start */
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Link is not UP for neighbor cell cnt: %d",
						num_cell + RRM_ONE);
                /* SPR 21251 End */
				ret_val = RRM_FAILURE;
			}
		}
		else /* HO is not enable so no Resource Status Update request will be sent */
		{
            /* SPR 21251 Start */
			RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
					"Load Report not allowed on neighbor cell cnt: %d",
					num_cell + RRM_ONE);
           /* SPR 21251 End */
			ret_val = RRM_FAILURE;
		}
        RRM_MEM_FREE (p_enb_lnode);
	}
    /* SPR 20007 : CID 110658 Fix Start */
    if (RRM_ZERO == num_cell)
    {
        /* SPR 21251 Start */
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
				"number of cell is equal to zero");
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }
    /* SPR 20007 : CID 110658 Fix End */
    if (RRM_SUCCESS == ret_val)
    {
	     build_and_send_x2ap_rrm_load_information_req(
                      p_cell_ctxt, &eutran_global_cell_id_arr[RRM_ZERO],
			          num_cell, RRM_ENB_TYPE_MACRO);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "x2ap_rrm_load_information_req should not be sent to Macro Cell");
    }
    RRM_UT_TRACE_EXIT();
	return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_build_and_send_x2ap_rrm_hii_req_to_macro_enb 
 * Inputs         : rrm_cellm_enb_id_hnode_t *p_enb_hnode :pointer 
                                         to nodebId
 *                : rrm_cell_context_t *p_cell_ctxt : pointer
 *                :  to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Sends Load Information Req to RRC
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_x2ap_rrm_hii_req_to_macro_enb
(
 rrm_cellm_enb_id_hnode_t *p_enb_hnode,
 rrm_cell_context_t       *p_cell_ctxt        /* cell context */
)
{
	rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    U16                               num_cell = RRM_ZERO;
	rrm_return_et                     ret_val = RRM_SUCCESS;
    rrm_oam_eutran_global_cell_id_t   eutran_global_cell_id_arr[MAX_NUM_CELLS_IN_MACRO_ENB] ;

    RRM_MEMSET(&eutran_global_cell_id_arr, 
                RRM_ZERO, 
                (sizeof(rrm_oam_eutran_global_cell_id_t) * MAX_NUM_CELLS_IN_MACRO_ENB));

    RRM_UT_TRACE_ENTER ();

	RRM_ASSERT (RRM_PNULL != p_enb_hnode);

	while (RRM_PNULL != (p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)ylPopHead(&p_enb_hnode->list)))
	{
		if ((HO_ALLOWED == p_enb_lnode->enb_info.ho_status) && /* Check HO status is enable */
            (RRM_TRUE   == p_enb_lnode->enb_info.broadcast_status) &&
            (RRM_FALSE  == p_enb_lnode->enb_info.blacklisted))
		{
			if ((RRM_TRUE == p_enb_lnode->enb_info.x2_link_up_status) ||
    			(X2_ALLOWED_CONNECTED == p_enb_lnode->enb_info.x2_status))
			{
				RRM_MEMCPY(&eutran_global_cell_id_arr[num_cell],
						&p_enb_lnode->enb_info.cell_id, sizeof (rrm_oam_eutran_global_cell_id_t));
				num_cell++;
			}
			else
			{
                /* SPR 21251 Start */
				RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
						"Link is not UP for neighbor cell identity : [%x%x%x%x] cnt: %d",
						p_enb_lnode->enb_info.cell_id.cell_identity[RRM_ZERO],
                        p_enb_lnode->enb_info.cell_id.cell_identity[RRM_ONE],
                        p_enb_lnode->enb_info.cell_id.cell_identity[RRM_TWO],
                        p_enb_lnode->enb_info.cell_id.cell_identity[RRM_THREE],
                        num_cell + RRM_ONE);
                /* SPR 21251 End */
				ret_val = RRM_FAILURE;
			}
		}
        else /* HO is not enable so no Resource Status Update request will be sent */
        {
            /* SPR 21251 Start */
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Load Report not allowed on neighbor cell identity : [%x%x%x%x] cnt: %d",
                    p_enb_lnode->enb_info.cell_id.cell_identity[RRM_ZERO],
                    p_enb_lnode->enb_info.cell_id.cell_identity[RRM_ONE],
                    p_enb_lnode->enb_info.cell_id.cell_identity[RRM_TWO],
                    p_enb_lnode->enb_info.cell_id.cell_identity[RRM_THREE],
                    num_cell + RRM_ONE);
            /* SPR 21251 End */
            ret_val = RRM_FAILURE;
        }
        RRM_MEM_FREE (p_enb_lnode);
	}
    /* SPR 20007 : CID 110657 Fix Start */
    if (RRM_ZERO == num_cell)
    {
        /* SPR 21251 Start */
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
		    	"num_cell should not be equal to 0 hence not sending HII request");
        /* SPR 21251 End */
        ret_val = RRM_FAILURE;
    }
    /* SPR 20007 : CID 110657 Fix End */
    if (RRM_SUCCESS == ret_val)
    {
	      build_and_send_x2ap_rrm_hii_req(
                      p_cell_ctxt, &eutran_global_cell_id_arr[RRM_ZERO],
			          num_cell, RRM_ENB_TYPE_MACRO);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "x2ap_rrm_hii_req should not be sent to Macro Cell");
    }
    RRM_UT_TRACE_EXIT();
	return ret_val;
}


/****************************************************************************
 * Function Name  : build_and_send_x2ap_icic_load_information 
 * Inputs         : rrm_cell_context_t *p_cell_ctxt : pointer
 *                :  to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Sends Load Information Req to RRC
 ****************************************************************************/
rrm_return_et build_and_send_x2ap_icic_load_information
(
 rrm_cell_context_t *p_cell_ctxt        /* cell context */
)
{
    lte_ncl_t                         *lte_ncl = RRM_PNULL;
    rrm_oam_eutran_global_cell_id_t   eutran_global_cell_id_arr[MAX_NUM_CELLS_IN_MACRO_ENB] ;
    U8                                ncl_cnt = RRM_ZERO;
    U16                               num_cell = RRM_ZERO;
    YHASH                             rrm_enbid_hash;
    YHNODE                            *p_hnode = RRM_PNULL;
    rrm_cellm_enb_id_hnode_t          *p_enb_hnode = RRM_PNULL;
    rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    rrm_return_et                     ret_val = RRM_SUCCESS; 

    //	RRM_UT_TRACE_ENTER ();

    RRM_MEMSET( &eutran_global_cell_id_arr,
            RRM_ZERO,
            ((sizeof(rrm_oam_eutran_global_cell_id_t) * MAX_NUM_CELLS_IN_MACRO_ENB)));

    lte_ncl = rrm_cellm_get_lte_ncl_info (p_cell_ctxt->cell_index);

    /*spr 7011 start*/
    if(RRM_PNULL == lte_ncl)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "lte ncl is not present,can't send x2ap_rrm_load_information_req");
        return RRM_FAILURE;
    }
    /*spr 7011 end*/

    /* Getting Memory For Hash Table */
    YHNODE **table = (YHNODE **)rrm_mem_get(((RRM_CELLM_MAX_HASH_BUCKECT) * sizeof (YHNODE *)));

    if(RRM_PNULL == table) /* Coverity: CID 42114 */
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Memory allocation to table failed");
        return RRM_FAILURE;
    }
    /* Init Hash Table rrm_enbid_hash */
    yhInit (&rrm_enbid_hash, RRM_CELLM_MAX_HASH_BUCKECT, rrm_cellm_hashing_func, rrm_cmp_enb_id, rrm_keyof_func, table);

    for (ncl_cnt = RRM_ZERO; ncl_cnt < lte_ncl->num_valid_intra_freq_cell; ++ncl_cnt)
    {
        /*spr_13531_fix_start */
        /*If the cell access mode is present and access mode is closed then we treat it as Home eNB else Macro */
        /* SPR 20409 Fix Start */
        if(( lte_ncl->intra_freq_cells[ncl_cnt].bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT ) &&
        /* SPR 20409 Fix End */
                (( RRM_OAM_ACCESS_MODE_CLOSE == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode ) ||
                       /* SPR Fix 18895 Start */
                       ( RRM_OAM_ACCESS_MODE_HYBRID == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode )||
                       ( RRM_OAM_ACCESS_MODE_OPEN_FEMTO == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode)))
                       /* SPR Fix 18895 End */
        {
            /* SPR 21843 Fix Start */
            /* This cell is HeNodeB, Its consist only one cell */
            if ((RRM_TRUE == lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status) ||
                    (X2_ALLOWED_CONNECTED == lte_ncl->intra_freq_cells[ncl_cnt].x2_status))
            {
                RRM_MEMCPY(&eutran_global_cell_id_arr[num_cell], 
                        &lte_ncl->intra_freq_cells[ncl_cnt].cell_id,
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                num_cell++;
                /* Build and send X2AP_RRM_LI_RRM_LOAD_INFORMATION_REQ*/
                build_and_send_x2ap_rrm_load_information_req(p_cell_ctxt,
                        &eutran_global_cell_id_arr[num_cell - RRM_ONE],
                        num_cell, RRM_ENB_TYPE_HOME);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Link is not UP for intra freq neighbor pci: %d",
                        lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id );
                ret_val = RRM_FAILURE;
            }
            num_cell = RRM_ZERO;
            /* SPR 21843 Fix End */
        }
        else
        {	 /* Coverity CID 100116 Fix Start */	
            p_hnode = yhFind((const YHASH *) &rrm_enbid_hash, (rrm_void_t *)
                    &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]));
            /* Coverity CID 100116 Fix End */	
            if (RRM_PNULL == p_hnode)
            {
                p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_hnode_t));
                if ( p_enb_hnode == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_hnode failed" );

                    /* free the memory resources */  
                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix start*/
                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix end*/

                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_hnode->enb_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]),
                        sizeof(p_enb_hnode->enb_id));
                ylInit(&p_enb_hnode->list);
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );
                    /* free the memory resources */  
                    /* COVERITY : RESOURCE LEAK : CID : 54336 ,54337,54338 fix start*/
                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                    /* COVERITY : RESOURCE LEAK : CID : 54336 ,54337,54338 fix end*/
                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
                yhInsert(&rrm_enbid_hash, &(p_enb_hnode->node));
            }
            else
            {
                p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)((unsigned long)p_hnode - \
                        (unsigned long)(&((rrm_cellm_enb_id_hnode_t *)RRM_ZERO)->node));
                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                if ( p_enb_lnode == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_enb_lnode failed" );

                    /* free the memory resources */ 
                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix start*/
                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix end*/

                    RRM_UT_TRACE_EXIT();
                    return RRM_FAILURE;
                }

                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
            }
        }
        /*spr_13531_fix_end */
    }
    /* Sending the ICIC Load req to each Macro eNodeB and free the hash and list */
    p_hnode = yhFirst((const YHASH *)&rrm_enbid_hash);
    while (RRM_PNULL != p_hnode)
    {
        p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)((unsigned long)p_hnode - \
                (unsigned long)(&((rrm_cellm_enb_id_hnode_t *)RRM_ZERO)->node));
        ret_val = rrm_build_and_send_load_info_req_to_macro_enb (p_enb_hnode, p_cell_ctxt);
        p_hnode = yhNext (&rrm_enbid_hash, (YHNODE *)p_enb_hnode);
        yhDelete (&rrm_enbid_hash, (YHNODE *)p_enb_hnode);
        RRM_MEM_FREE (p_enb_hnode);
    }

    /* COVERITY : RESOURCE LEAK : CID : 54338 fix start*/
    /*SPR 16829 Fix start*/
    if( RRM_PNULL != rrm_enbid_hash.table )
    {
    /*SPR 16829 Fix end*/    
        RRM_MEM_FREE( rrm_enbid_hash.table);
        /*SPR 16829 Fix start*/
        rrm_enbid_hash.table = RRM_PNULL;
        /*SPR 16829 Fix end*/
    }
    /* COVERITY : RESOURCE LEAK : CID : 54338 fix end */

    /*SPR 16829 Fix start*/
    /*Code removed*/
    /*SPR 16829 Fix stop*/

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*****************************************************************************
 * Array Name     : reconfigure_cell_center_region 
 * Inputs         : Pointer to partition info
 * Outputs        : None
 * Returns        : None
 * Description    : This function will fill repartition the cell center region
 *		            based on new cell edge region.
 ****************************************************************************/
rrm_void_t 
reconfigure_cell_center_region
(
   rrm_resource_partition_info_t      *p_resource_partition_info, 
   U32                                 prb_configured_in_srv_cell
)
{
    U32              ce_prb_count = RRM_ZERO;
    U32              ce_prb_start_pos = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_resource_partition_info);

    ce_prb_count = p_resource_partition_info->cell_edge_region.num_of_rb;
    ce_prb_start_pos = p_resource_partition_info->cell_edge_region.start_rb;

    if (ce_prb_start_pos != RRM_ZERO)
    {
       p_resource_partition_info->num_of_cell_center_region = RRM_ONE;
       p_resource_partition_info->cell_center_region[RRM_ZERO].start_rb = RRM_ZERO;
       p_resource_partition_info->cell_center_region[RRM_ZERO].num_of_rb = 
                       ce_prb_start_pos;
       if (ce_prb_start_pos + ce_prb_count < prb_configured_in_srv_cell)
       {
           p_resource_partition_info->num_of_cell_center_region++;
           p_resource_partition_info->cell_center_region[RRM_ONE].start_rb = 
                        ce_prb_start_pos + ce_prb_count;
           p_resource_partition_info->cell_center_region[RRM_ONE].num_of_rb = 
                             prb_configured_in_srv_cell - (ce_prb_start_pos + ce_prb_count);
       }
    }
    else
    {
        /* SPR 19754 fix Start */
        /* Code Removed */
        /* SPR 19754 fix end */
       p_resource_partition_info->cell_center_region[RRM_ZERO].start_rb = 
                       ce_prb_start_pos + ce_prb_count;
       p_resource_partition_info->cell_center_region[RRM_ZERO].num_of_rb = 
                       prb_configured_in_srv_cell - ce_prb_count;

        /* SPR 19754 fix Start */
       if (RRM_ZERO != p_resource_partition_info->cell_center_region[RRM_ZERO].num_of_rb)
       {
           p_resource_partition_info->num_of_cell_center_region = RRM_ONE;
       }
        /* SPR 19754 fix end */
    }

    RRM_UT_TRACE_EXIT();
}
/*****************************************************************************
 * Array Name     : get_minimum_interfered_prb_region 
 * Inputs         : Pointer to CE Region
 *                  PRB Count 
 *                  Value by which CE should be truncated
 * Outputs        : None
 * Returns        : Start RB for new CE Region
 * Description    : This function will perform actions based on HII, OI and 
 *		            RNTP reports received on X2
 ****************************************************************************/
rrm_void_t 
get_minimum_interfered_prb_region
(
   U8        *p_start_region,
   U32        ce_region_start_rb,
   U32        ce_region_num_of_rb,
   U32        new_requested_prbs_for_ce,
   U32        prb_configured_in_srv_cell,
   U32        *p_new_start_index_for_ce_region
)
{
    U32             rb_count = RRM_ZERO;
    /* SPR 21843 Fix Start */
    U32             count = RRM_ZERO;
    U32             intf_free_region_count = RRM_ZERO;
    U32             intf_free_region_start_position = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    /* This part will be executed when the requested region is squeezed 
       from what has been configured
    */
    if (new_requested_prbs_for_ce < ce_region_num_of_rb)
    {
        while (rb_count < ce_region_num_of_rb)
        {
            if(RRM_ZERO == p_start_region[rb_count])
            {
                /* 
                   This will store the initial position of the region where
                   interference is ZERO
                */
                intf_free_region_start_position = rb_count;
                for (count = rb_count + RRM_ONE; (count < ce_region_num_of_rb) && (intf_free_region_count < new_requested_prbs_for_ce); count++)
                {
                    if (RRM_ZERO != p_start_region[count])
                    {
                        break;
                    }
                    intf_free_region_count++;
                }
                if (intf_free_region_count == new_requested_prbs_for_ce)
                {
                    break;
                }
            }
            rb_count++;
        }
        /* 
           Validate if the start index calculated has the requested number 
           of free CE regions
         */
        if ((intf_free_region_start_position + new_requested_prbs_for_ce) > ce_region_num_of_rb)
        {
            mandate_search_for_region_to_left_or_right_of_cnfg_partition(
                            ce_region_start_rb, ce_region_num_of_rb, 
                            new_requested_prbs_for_ce,
                            p_new_start_index_for_ce_region, prb_configured_in_srv_cell);

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO, 
                  "A: Requested was [%d], Interference Free found is [%d] Num RB %d"
                  " Intference Free Region Modified mew Start RB[%d], Num of RB [%d] Prev Start RB %d",
                  new_requested_prbs_for_ce, intf_free_region_count,
                  ce_region_num_of_rb, *p_new_start_index_for_ce_region,
                  new_requested_prbs_for_ce, ce_region_start_rb);
        }
        else
        {
            *p_new_start_index_for_ce_region = intf_free_region_start_position + ce_region_start_rb;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO, 
                  "B: Intference Free Region that can be Modified for Serving Start RB[%d], Count [%d] Prev Start RB %d",
                  *p_new_start_index_for_ce_region, new_requested_prbs_for_ce, ce_region_start_rb);
        }

    }
    else
    /* This part will be executed when the requested region is expanded 
       as compared to the originaly configured.
     */
    {
        /* This check validates if CE region starts from zeroth RB.
           If this is the case then expand cell region beyond the
           configured value
           */
        if (RRM_ZERO == ce_region_start_rb)
        {
            *p_new_start_index_for_ce_region = RRM_ZERO;
        }
        else if((ce_region_start_rb + ce_region_num_of_rb) == prb_configured_in_srv_cell)
        {
            /* This check validates if CE region lies in the last bracket of frequency division.
               If this is the case then cell region end point can't be expanded beyond the
               configured value as it will overshoot the upper bound of max prb so shifting the
               start position of the ce region
               */
            *p_new_start_index_for_ce_region = ce_region_start_rb -
                (new_requested_prbs_for_ce - ce_region_num_of_rb);
        }
        else
        {
            /* This check will hit when the CE region lies in the middle of frequency band.
               It means either the CE region can be expanded towards left of the start position
               or it can be moved to the end of the ending index. In both the cases,
               check should be done to make sure that start index doesn't go less than ZERO
               or beyond the maximum configured PRBs.
               */
            if ((S32)(ce_region_start_rb - (new_requested_prbs_for_ce - ce_region_num_of_rb) ) < RRM_ZERO )
            {
                *p_new_start_index_for_ce_region = ce_region_start_rb;
            }
            else
            {
                *p_new_start_index_for_ce_region = ce_region_start_rb -
                    (new_requested_prbs_for_ce - ce_region_num_of_rb);
            }
        }
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO, 
                "New CE Region Start RB %d, PRB configured %d Num of RB %d,Requested RB %d Prev Start %d",
                *p_new_start_index_for_ce_region, prb_configured_in_srv_cell,
                new_requested_prbs_for_ce, ce_region_start_rb);
    /* SPR 21843 Fix End */
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : compare_x2_reported_global_cell_id_with_serving 
 * Inputs         :
 *                : rrm_oam_eutran_global_cell_id_t  p_recvd
 *                : rrm_oam_eutran_global_cell_id_t  p_stored
 * Outputs        :
 * Returns        : SUCCESS/FAILURE
 * Description    : This function compares the received and stored global cell
 *                  id
 ****************************************************************************/
 rrm_return_et compare_x2_reported_global_cell_id_with_serving(
             rrm_cell_global_id_eutra_t          *p_rcvd,
             rrm_global_cell_id_t                *p_strd)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8 index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT(RRM_PNULL != p_rcvd);
    RRM_ASSERT(RRM_PNULL != p_strd);

    /* Comparing MCC Id */
    if (p_rcvd->plmn_identity.presence_bitmask & PLMN_IDENTITY_MCC_PRESENCE_FLAG)
    {
        for (index=RRM_ZERO; index< MAX_MCC_DIGITS; index++)
        {
            if (p_rcvd->plmn_identity.mcc[index] !=
                    p_strd->primary_plmn_id.mcc[index])
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "stored MCC[%d]  Recvd MCC[%d] "
                        "at INDEX[%d]",
                        p_strd->primary_plmn_id.mcc[index],
                        p_rcvd->plmn_identity.mcc[index],
                        index);
                ret_val = RRM_FAILURE;
                break;
            }
        }
    }
    if (ret_val != RRM_FAILURE)
    {
        /**Comparing MNC Id **/
        if (p_rcvd->plmn_identity.mnc.count ==
                p_strd->primary_plmn_id.num_mnc_digit)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "No of MNC matches");
            for (index=RRM_ZERO; index< p_rcvd->plmn_identity.mnc.count && index < MAX_MNC_DIGITS; index++)
            {
                if (p_rcvd->plmn_identity.mnc.mnc[index] !=
                        p_strd->primary_plmn_id.mnc[index])
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "stored MNC[%d] "
                            "Recvd MNC[%d]  at INDEX [%d]",
                            p_strd->primary_plmn_id.mnc[index],
                            p_rcvd->plmn_identity.mnc.mnc[index], index);
                    ret_val = RRM_FAILURE;
                    break;
                }
            }/*for loop ends*/
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "stored num_mnc_digit[%d] "
                    "Recvd num_mnc_digit[%d]",
                    p_strd->primary_plmn_id.num_mnc_digit,
                    p_rcvd->plmn_identity.mnc.count);
            ret_val = RRM_FAILURE;
        }
    }

    if (ret_val != RRM_FAILURE)
    {

        /* Comparing Cell Identity */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Comparing Cell Ident");
        for (index=RRM_ZERO; index < MAX_CELL_IDENTITY_OCTETS; index++)
        {
            if (p_strd->cell_identity[index] != p_rcvd->cell_identity[index])
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "stored CELL_ID[%d] "
                        "Recvd CELL_ID[%d] at INDEX[%d]",
                        p_strd->cell_identity[index],
                        p_rcvd->cell_identity[index], index);
                ret_val = RRM_FAILURE;
                break;
            }
        }/*for loop ends*/
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* DYNAMIC ICIC CHANGES END */

/* SRS_FREQ_HOPPING_START */
/*
 ** As per Table 5.5.3.2-2 of 3GPP specs 36.211
 */
U8 srs_rb_allocation_tbl_bw_10[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO]= 
{
	{
		{48,1},{24,2 },{12,2},{4,3}
	},
	{
		{48,1},{16,3},{8,2},{4,2}
	},
	{
		{40,1},{20,2},{4,5},{4,1}
	},
	{
		{36,1},{12,3},{4,3},{4,1}
	},
	{
		{32,1},{16,2},{8,2},{4,2}
	},
	{
		{24,1},{4,6},{4,1},{4,1}
	},
	{
		{20,1},{4,5},{4,1},{4,1}
	},
	{
		{16,1},{4,4},{4,1},{4,1}
	}
};

/*
 ** As per Table 5.5.3.2-3 of 3GPP specs 36.211
 */
U8 srs_rb_allocation_tbl_bw_15[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO] =
{
	{
		{72,1},{24,3 },{12,2},{4,3}
	},
	{
		{64,1},{32,2},{16,2},{4,4}
	},
	{
		{60,1},{20,3},{4,5},{4,1}
	},
	{
		{48,1},{24,2},{12,2},{4,3}
	},
	{
		{48,1},{16,3},{8,2},{4,2}
	},
	{
		{40,1},{20,2},{4,5},{4,1}
	},
	{
		{36,1},{12,3},{4,3},{4,1}
	},
	{
		{32,1},{16,2},{8,2},{4,2}
	}
};

/*
 ** As per Table 5.5.3.2-4 of 3GPP specs 36.211
 */
U8 srs_rb_allocation_tbl_bw_20[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO] =
{
	{
		{96,1},{48,2},{24,2},{4,6}
	},
	{
		{96,1},{32,3},{16,2},{4,4}
	},
	{
		{80,1},{40,2},{20,2},{4,5}
	},
	{
		{72,1},{24,3},{12,2},{4,3}
	},
	{
		{64,1},{32,2},{16,2},{4,4}
	},
	{
		{60,1},{20,3},{4,5},{4,1}
	},
	{
		{48,1},{24,2},{12,2},{4,3}
	},
	{
		{48,1},{16,3},{8,2},{4,2}
	}
};

/*
 ** As per Table 5.5.3.2-1 of 3GPP specs 36.211
 */
U8 srs_rb_allocation_tbl_bw_upto_5[MAX_SRS_BW_CONFIG][MAX_SRS_BW][RRM_TWO] =
{
	{
		{36,1},{12,3},{4,3},{4,1}
	},
	{
		{32,1},{16,2},{8,2},{4,2}
	},
	{
		{24,1},{4,6},{4,1},{4,1}
	},
	{
		{20,1},{4,5},{4,1},{4,1}
	},
	{
		{16,1},{4,4},{4,1},{4,1}
	},
	{
		{12,1},{4,3},{4,1},{4,1}
	},
	{
		{8,1},{4,2},{4,1},{4,1}
	},
	{
		{4,1},{4,1},{4,1},{4,1}
	}
};
/* SRS_FREQ_HOPPING_END */

/* MLB Changes start */

rrm_void_t rrm_update_link_status_ind(
        x2ap_rrm_x2_link_up_ind_st  *p_x2ap_link_up_ind,
		x2_gb_enb_id_t *p_peer_enb_id,
		U16 api_id)
{
    rrm_global_context_t    *p_rrm_gbl_ctx  = RRM_PNULL;
    rrm_cell_context_t      *p_cell_ctxt    = RRM_PNULL;
    U8                      plmn[MAX_PLMN_ID_BYTES] = {RRM_ZERO};
    U32                     enb_id_rptd     = RRM_ZERO;
    U32                     enb_id_sav      = RRM_ZERO;
    rrm_oam_cell_plmn_info_t *p_plmn_info   = RRM_ZERO;
    U8                      i               = RRM_ZERO;
    rrm_rsu_meas_id_node_t  *p_meas_node    = RRM_PNULL;
    rrm_rsu_meas_info_node_t *p_rsu_ctrl = RRM_PNULL;
    rrm_cell_meas_gb_t        p_key = {RRM_ZERO};
    YHNODE *p_hnode = RRM_PNULL;
    rrm_rsu_meas_srv_cell_info_node_t *p_serv_node = RRM_PNULL;
    rrm_rsu_meas_srv_cell_info_node_t *p_serv_node_next = RRM_PNULL;
    U32 enb_id = RRM_ZERO;
    /* Rel10_CRs 408 start */
    U8  max_served_cell_cnt = RRM_ZERO;
    /* Rel10_CRs 408 end */
    /* BUG_825_Fix Start */
    U8 num_of_cell_cnt      = RRM_ZERO;
    /* BUG_825_Fix End */
#ifdef LTE_EMBMS_SUPPORTED
    U8 mbsfn_count                                   = RRM_ZERO;
    rrmcm_mbsfn_subframe_config_list_t *p_mbsfn_info = RRM_PNULL;
    x2ap_mbsfn_subframe_info_t *p_mbsfn_from_x2ap    = RRM_PNULL;
    /* CID 97701:start*/
    /*delete*/
    /* CID 97701:end*/
#endif

    p_rrm_gbl_ctx = (rrm_global_context_t*)qvThisContext();

    U32 *p_cell_id = RRM_PNULL;
    if (X2AP_OAM_MACRO_ENB_ID_PRESENT & p_peer_enb_id->enb_id.presence_bitmask)
    {
        RRM_MEMCPY(&enb_id,&p_peer_enb_id->enb_id.macro_enb_id.eNB_id,RRM_THREE);
        enb_id_rptd = (RRM_NTOHL(enb_id)) >> RRM_TWELVE;
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_BRIEF,"Reporting eNB[0x%x] is MACRO ENB", enb_id_rptd);
    }
    else
    {
        RRM_MEMCPY(&enb_id,&p_peer_enb_id->enb_id.home_enb_id.eNB_id,RRM_FOUR);
        enb_id_rptd = RRM_NTOHL(enb_id);
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                RRM_BRIEF,"Reporting eNB[0x%x] is HOME ENB", enb_id_rptd);
    }
    /*coverity , id: 30218 , added if condition to check return value of qvThisContext function*/
    if(RRM_PNULL != p_rrm_gbl_ctx)
    {
        /* BUG_825_Fix Start */
        for (num_of_cell_cnt = RRM_ZERO; num_of_cell_cnt < RRM_MAX_NUM_CELLS; num_of_cell_cnt++)
        {
        /* BUG_825_Fix End */

            if (RRM_PNULL != (p_cell_ctxt = p_rrm_gbl_ctx->p_rrm_cell_ctx[num_of_cell_cnt]))
            {
                for (i = RRM_ZERO; i < p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; i++)
                {
                    p_plmn_info = &p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].cell_id.primary_plmn_id;
                    plmn[RRM_ZERO] = (U8)((U8)(p_plmn_info->mcc[RRM_ONE] << RRM_FOUR)| p_plmn_info->mcc[RRM_ZERO]);
                    plmn[RRM_ONE] = (U8)(p_plmn_info->mcc[RRM_TWO]);
                    p_cell_id = (U32 *)(p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].cell_id.cell_identity);
                    if (RRM_THREE == p_plmn_info->num_mnc_digit)
                    {
                        plmn[RRM_ONE] = ((U8)(p_plmn_info->mnc[RRM_ZERO] << RRM_FOUR)| plmn[RRM_ONE]);
                        plmn[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_TWO] << RRM_FOUR))| p_plmn_info->mnc[RRM_ONE]);
                    }
                    else
                    {
                        plmn[RRM_ONE] = (U8)((plmn[RRM_ONE])|RRM_HIGH_NIBBLE);
                        plmn[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_ONE] << RRM_FOUR))| p_plmn_info->mnc[RRM_ZERO]);
                    }

                    if (RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].bitmask)
                    {
                        /* Home eNodeB */
                        enb_id_sav = RRM_NTOHL(*(p_cell_id));
                    }
                    else
                    {
                        /* Macro eNodeB */
                        enb_id_sav = RRM_NTOHL(*(p_cell_id)) >> RRM_TWELVE;
                    }
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                            RRM_BRIEF,"Reported PLMN[0x%x%x%x]->eNbId[0x%x], PLMN in list[0x%x%x%x]->eNbId[0x%x]",
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_ZERO],
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_ONE],
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_TWO], enb_id_rptd, plmn[RRM_ZERO],plmn[RRM_ONE],plmn[RRM_TWO], enb_id_sav);
                    if ((enb_id_sav == enb_id_rptd) && (!RRM_MEMCMP(plmn, p_peer_enb_id->plmn_identity.plmn_id, MAX_PLMN_ID_BYTES)))
                    {
                        switch(api_id)
                        {
                            case X2AP_RRM_LINK_UP_IND:
                                {
                                    /* Coverity_ID : 53572 */
                                    if (p_x2ap_link_up_ind != RRM_PNULL)
                                    {    
                                        /* Rel10_CRs 408 start */
                                        /* MENB CHANGES - START */
                                        for (max_served_cell_cnt = RRM_ZERO; (max_served_cell_cnt < p_x2ap_link_up_ind->eutra_cell_info.num_served_cell) 
                                                && (max_served_cell_cnt < MAX_SERVED_CELLS); max_served_cell_cnt++ )
                                        {
                                            if (X2AP_CSG_ID_INFO_PRESENT & 
                                                    p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.bitmask)
                                            {
                                                if (!RRM_MEMCMP(&p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.cell_id.eutran_cell_id\
                                                            ,&p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].cell_id.cell_identity,MAX_CELL_IDENTITY_OCTETS))
                                                {
                                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].bitmask |= 
                                                        RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT;
                                                    RRM_MEMCPY(p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].csg_identity,
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.
                                                            served_cell_info.csg_identity, RRM_OAM_MAX_NUM_CSG_OCTETS);
                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                                            "CSG ID in X2 LINK UP IND [0x%x%x%x%x], CSG ID copy to CELL Context [0x%x%x%x%x]\
                                                            for RRC_RRM_HO_ADM_REQ",\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[0],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[1],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[2],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[3],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].csg_identity[0],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].csg_identity[1],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].csg_identity[2],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].csg_identity[3]);

#ifdef LTE_EMBMS_SUPPORTED
                                                    if (X2AP_MBSFN_SUBFRAME_INFO_PRESENT &
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].
                                                            ngh_dir_cell_arr.served_cell_info.bitmask)
                                                    {
                                                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].bitmask |= 
                                                            RRMCM_RMIF_INTRA_MBSFN_CONFIG_LIST_PRESENT;
                                                        p_mbsfn_info=
                                                            &(p_cell_ctxt->ran_info.ncl_params.lte_ncl.
                                                            intra_freq_cells[i].mbsfn_subframe_config_list); 
                                                        p_mbsfn_from_x2ap =
                                                            &(p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].
                                                                    ngh_dir_cell_arr.served_cell_info.mbsfn_subframe_info);
                                                        p_mbsfn_info->count = p_mbsfn_from_x2ap->num_mbsfn;
                                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "No of mbsfn info received from X2AP[%d] for NCL[%d]",
                                                                    p_mbsfn_info->count, i);
                                                        for (mbsfn_count = RRM_ZERO; mbsfn_count < p_mbsfn_info->count;
                                                                mbsfn_count++)
                                                        {

                                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "Filling mbsfn info for mbsfn config index[%d]", mbsfn_count);

                                                            p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].bitmask
                                                                        = RRM_ZERO;
                                                            if (X2AP_SUBFRAME_ALLOC_ONE_FRAME_INFO_PRESENT & 
                                                                p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.bitmask )
                                                            {
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "subframe allocation is in oneframe");
                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                subframe_allocation.sf_alloc_choice = RRM_ZERO;
                                                                            
                                                                rrm_maps_frame_allocation_period_for_cellm(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                     radio_frame_allocation_period,
                                                                     p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].
                                                                     radioframe_alloc_period);

                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                radio_frame_allocation_offset =
                                                                p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].radioframe_alloc_period;
                                                                
                                                                RRM_MEMSET(p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    RRM_ZERO, SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);

                                                                RRM_MEMCPY(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    &p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.oneframe,
                                                                    RRM_ONE);
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                          "subframe allocation is in oneframe, "
                                                                          "radioframe_alloc_period[%d],radioframe_alloc_offset[%d]"
                                                                          "sf_alloc_choice[%d]",
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_period,
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_offset,
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          subframe_allocation.sf_alloc_choice);

                                                            }
                                                            else
                                                            {
                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.sf_alloc_choice = RRM_ONE;

                                                                rrm_maps_frame_allocation_period_for_cellm(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                     radio_frame_allocation_period,
                                                                     p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].
                                                                     radioframe_alloc_period);

                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    radio_frame_allocation_offset =
                                                                    p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].radioframe_alloc_period;

                                                                RRM_MEMSET(p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    RRM_ZERO, SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);

                                                                RRM_MEMCPY(
                                                                        &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                        subframe_allocation.subframe_allocation,
                                                                        &p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.fourframe,
                                                                        SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                          "subframe allocation is in fourframe, "
                                                                          "radioframe_alloc_period[%d],radioframe_alloc_offset[%d]"
                                                                          "sf_alloc_choice[%d]",
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_period,
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_offset,
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          subframe_allocation.sf_alloc_choice);

                                                            }

                                                        }
                                                    }

#endif
                                                    break;
                                                }
                                            }
                                        }
                                        /* MENB CHANGES - END */

                                        /* Rel10_CRs 408 end */
                                        if (RRM_TRUE != p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_link_up_status)
                                        {
                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_link_up_status = RRM_TRUE;
                                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                                    RRM_BRIEF,"Marking Link UP for PCI[%u]",
                                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].phy_cell_id);
                                        }
                                            
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                                RRM_DETAILED, "Intra: Pointer to X2AP Link Up Indication is NULL passed to this function");
                                    }
                                }
                                break;

                            case X2AP_RRM_LINK_DOWN_IND:
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                            RRM_BRIEF,"Intra Freq pending meas report [%u]", ylCount(&p_cell_ctxt->rsu_meas_id_list));

                                    p_meas_node = (rrm_rsu_meas_id_node_t*)ylFirst(&p_cell_ctxt->rsu_meas_id_list);
                                    while (RRM_PNULL != p_meas_node)
                                    {
                                        p_key.meas_id = p_meas_node->rsu_meas_id; 
                                        RRM_MEMCPY(&(p_key.g_enb_id),p_peer_enb_id,sizeof(x2_gb_enb_id_t)); 
                                        /*Find the node in hash table and delete the node for controlling enb*/
                                        /* Coverity CID 100112 Fix Start */	
                                        p_hnode = yhFind((const YHASH *)&(p_g_rrm_cell_ctx->rsu_measid_hash_tbl),
                                                (rrm_void_t *)&(p_key));
                                        /* Coverity CID 100112 Fix End */	

                                        if(RRM_PNULL != p_hnode)
                                        {
                                            /*Delete the node in hash table*/
                                            p_rsu_ctrl = (rrm_rsu_meas_info_node_t *)p_hnode;
                                            yhDelete (&(p_rrm_gbl_ctx->rsu_measid_hash_tbl), (YHNODE *)p_rsu_ctrl);
                                            RRM_MEM_FREE(p_rsu_ctrl);
                                        }
                                        p_meas_node = (rrm_rsu_meas_id_node_t *)ylNext(&p_meas_node->node);
                                    }
                                    /*For serving cell search all the meas_id for a particular enb_id and delete the hash */
                                    p_serv_node = (rrm_rsu_meas_srv_cell_info_node_t *)yhFirst(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl));
                                    /*serving node next is also pointing to first node of table */
                                    p_serv_node_next = p_serv_node;
                                    while(p_serv_node_next != RRM_PNULL)
                                    {
                                        if(RRM_ZERO == RRM_MEMCMP(&(p_serv_node->rsu_id.g_enb_id), p_peer_enb_id, sizeof(x2_gb_enb_id_t)))
                                        {
                                            /* BUG_825_Fix Start */
                                            /* Stoping RSU Timer */
                                            if (RRM_TRUE == qvTimerRunning(p_serv_node_next->timer_id))
                                            {
                                                rrm_ue_stop_timer(p_serv_node_next->timer_id);
                                            }
                                            /* BUG_825_Fix End */
                                            /*delete the node from hash*/
                                            yhDelete (&(p_rrm_gbl_ctx->rsu_measid_hash_tbl), (YHNODE *)p_serv_node_next);
                                        }
                                        p_serv_node_next = (rrm_rsu_meas_srv_cell_info_node_t *)yhNext(&(p_g_rrm_cell_ctx->rsu_measid_serving_hash_tbl), (YHNODE *)p_serv_node);
                                    }
                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].x2_link_up_status = RRM_FALSE;
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                            RRM_BRIEF,"Marking Link Down for PCI[%u]",
                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[i].phy_cell_id);
                                   
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
                for (i = RRM_ZERO; i < p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell; i++)
                {
                    p_cell_id = (U32 *)(p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].cell_id.cell_identity);
                    p_plmn_info = &p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].cell_id.primary_plmn_id;
                    plmn[RRM_ZERO] = (U8)((U8)(p_plmn_info->mcc[RRM_ONE] << RRM_FOUR)| p_plmn_info->mcc[RRM_ZERO]);
                    plmn[RRM_ONE] = (U8)(p_plmn_info->mcc[RRM_TWO]);
                    if (RRM_THREE == p_plmn_info->num_mnc_digit)
                    {
                        plmn[RRM_ONE] = ((U8)(p_plmn_info->mnc[RRM_ZERO] << RRM_FOUR)| plmn[RRM_ONE]);
                        plmn[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_TWO] << RRM_FOUR))| p_plmn_info->mnc[RRM_ONE]);
                    }
                    else
                    {
                        /*+ Coverity CID : 25672 +*/
                        plmn[RRM_ONE] = (U8)((plmn[RRM_ONE])|RRM_HIGH_NIBBLE);
                        plmn[RRM_TWO] = (U8)(((U8)(p_plmn_info->mnc[RRM_ONE] << RRM_FOUR))| p_plmn_info->mnc[RRM_ZERO]);
                    }

                    if (RRMCM_RMIF_CSG_ID_PRESENT & p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].bitmask)
                    {
                        /* Home eNodeB */
                        enb_id_sav = RRM_NTOHL(*(p_cell_id));
                    }
                    else
                    {
                        /* Macro eNodeB */
                        enb_id_sav = RRM_NTOHL(*(p_cell_id)) >> RRM_TWELVE;
                    }
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                            RRM_BRIEF,"Reported PLMN[0x%x%x%x]->eNbId[0x%x], PLMN in list[0x%x%x%x]->eNbId[0x%x]",
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_ZERO],
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_ONE],
                            p_peer_enb_id->plmn_identity.plmn_id[RRM_TWO], enb_id_rptd, plmn[RRM_ZERO],plmn[RRM_ONE],plmn[RRM_TWO], enb_id_sav);
                    if ((enb_id_sav == enb_id_rptd) && (!RRM_MEMCMP(plmn, p_peer_enb_id->plmn_identity.plmn_id, MAX_PLMN_ID_BYTES)))
                    {
                        switch(api_id)
                        {
                            case X2AP_RRM_LINK_UP_IND:
                                {
                                    /* Rel10_CRs 408 start */
                                    if (RRM_PNULL != p_x2ap_link_up_ind)
                                    {
                                        /* MENB CHANGES - START */
                                        for (max_served_cell_cnt = RRM_ZERO; (max_served_cell_cnt < p_x2ap_link_up_ind->eutra_cell_info.num_served_cell) 
                                                && (max_served_cell_cnt < MAX_SERVED_CELLS); max_served_cell_cnt++ )
                                        {
                                            if (X2AP_CSG_ID_INFO_PRESENT & 
                                                    p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.bitmask)
                                            {
                                                if (!RRM_MEMCMP(&p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.cell_id.eutran_cell_id\
                                                            ,&p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].cell_id.cell_identity,MAX_CELL_IDENTITY_OCTETS))
                                                {
                                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].bitmask |= 
                                                        RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT;
                                                    RRM_MEMCPY(p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].csg_identity,
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.
                                                            served_cell_info.csg_identity, RRM_OAM_MAX_NUM_CSG_OCTETS);
                                                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,\
                                                            "CSG ID in X2 LINK UP IND [0x%x%x%x%x], CSG ID copy to CELL Context [0x%x%x%x%x]\
                                                            for RRC_RRM_HO_ADM_REQ",\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[0],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[1],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[2],\
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].ngh_dir_cell_arr.served_cell_info.csg_identity[3],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].csg_identity[0],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].csg_identity[1],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].csg_identity[2],\
                                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].csg_identity[3]);
#ifdef LTE_EMBMS_SUPPORTED
                                                    if (X2AP_MBSFN_SUBFRAME_INFO_PRESENT &
                                                            p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].
                                                            ngh_dir_cell_arr.served_cell_info.bitmask)
                                                    {
                                                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].bitmask |= 
                                                            RRMCM_RMIF_INTER_MBSFN_CONFIG_LIST_PRESENT;
                                                        p_mbsfn_info=
                                                            &(p_cell_ctxt->ran_info.ncl_params.lte_ncl.
                                                            inter_freq_cells[i].mbsfn_subframe_config_list); 
                                                        p_mbsfn_from_x2ap =
                                                            &(p_x2ap_link_up_ind->eutra_cell_info.cell_info[max_served_cell_cnt].
                                                                    ngh_dir_cell_arr.served_cell_info.mbsfn_subframe_info);
                                                        p_mbsfn_info->count = p_mbsfn_from_x2ap->num_mbsfn;
                                                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "No of mbsfn info received from X2AP[%d] for NCL[%d]",
                                                                    p_mbsfn_info->count, i);
                                                        for (mbsfn_count = RRM_ZERO; mbsfn_count < p_mbsfn_info->count;
                                                                mbsfn_count++)
                                                        {

                                                            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "Filling mbsfn info for mbsfn config index[%d]", mbsfn_count);

                                                            p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].bitmask
                                                                        = RRM_ZERO;
                                                            if (X2AP_SUBFRAME_ALLOC_ONE_FRAME_INFO_PRESENT & 
                                                                p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.bitmask )
                                                            {
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                    "subframe allocation is in oneframe");
                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                subframe_allocation.sf_alloc_choice = RRM_ZERO;
                                                                            
                                                                rrm_maps_frame_allocation_period_for_cellm(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                     radio_frame_allocation_period,
                                                                     p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].
                                                                     radioframe_alloc_period);

                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                radio_frame_allocation_offset =
                                                                p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].radioframe_alloc_period;
                                                                
                                                                RRM_MEMSET(p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    RRM_ZERO, SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);

                                                                RRM_MEMCPY(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    &p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.oneframe,
                                                                    RRM_ONE);
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                          "subframe allocation is in oneframe, "
                                                                          "radioframe_alloc_period[%d],radioframe_alloc_offset[%d]"
                                                                          "sf_alloc_choice[%d]", 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_period, 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_offset, 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          subframe_allocation.sf_alloc_choice);

                                                            }
                                                            else
                                                            {
                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.sf_alloc_choice = RRM_ONE;

                                                                rrm_maps_frame_allocation_period_for_cellm(
                                                                    &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                     radio_frame_allocation_period,
                                                                     p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].
                                                                     radioframe_alloc_period);

                                                                p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    radio_frame_allocation_offset =
                                                                    p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].radioframe_alloc_period;

                                                                RRM_MEMSET(p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                    subframe_allocation.subframe_allocation,
                                                                    RRM_ZERO, SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);

                                                                RRM_MEMCPY(
                                                                        &p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                        subframe_allocation.subframe_allocation,
                                                                        &p_mbsfn_from_x2ap->mbsfn_info[mbsfn_count].subframe_alloc.fourframe,
                                                                        SUB_FRAME_ALLOC_FOUR_FRAME_OCTET_SIZE);
                                                                RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                                                          "subframe allocation is in fourframe, "
                                                                          "radioframe_alloc_period[%d],radioframe_alloc_offset[%d]"
                                                                          "sf_alloc_choice[%d]", 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_period, 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          radio_frame_allocation_offset, 
                                                                          p_mbsfn_info->mbsfn_subframe_config_info[mbsfn_count].
                                                                          subframe_allocation.sf_alloc_choice);

                                                            }

                                                        }
                                                    }

#endif

                                                    break;
                                                }
                                            }
                                        }
                                        /* MENB CHANGES - END */

                                        /* Rel10_CRs 408 end */
                                        /* Send resource status request */
                                        if (RRM_TRUE != p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].x2_link_up_status)
                                        {
                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].x2_link_up_status = RRM_TRUE;
                                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                                    RRM_BRIEF,"Marking Link UP for PCI[%u]",
                                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].phy_cell_id);
                                        }
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                                RRM_DETAILED, "Inter: Pointer to X2AP Link Up Indication is NULL passed to this function");
                                    }
                                }
                                break;
                            case X2AP_RRM_LINK_DOWN_IND:
                                {
                                    /* First sending stop to clear the previous request if any pending on peer */
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                            RRM_BRIEF,"Inter Freq Pending meas report [%u]", ylCount(&p_cell_ctxt->rsu_meas_id_list));
                                    p_meas_node = (rrm_rsu_meas_id_node_t*)ylFirst(&p_cell_ctxt->rsu_meas_id_list);
                                    while (RRM_PNULL != p_meas_node)
                                    {
                                        p_key.meas_id = p_meas_node->rsu_meas_id; 
                                        RRM_MEMCPY(&(p_key.g_enb_id),p_peer_enb_id,sizeof(x2_gb_enb_id_t)); 
                                        /*Find the node in hash table and delete the node for controlling enb*/
                                        p_hnode = yhFind(&(p_rrm_gbl_ctx->rsu_measid_hash_tbl),
                                                (rrm_void_t *)&(p_key));
                                        if(RRM_PNULL != p_hnode)
                                        {
                                            /*Delete the node in hash table*/
                                            p_rsu_ctrl = (rrm_rsu_meas_info_node_t *)p_hnode;
                                            yhDelete (&(p_rrm_gbl_ctx->rsu_measid_hash_tbl), (YHNODE *)p_rsu_ctrl);
                                            RRM_MEM_FREE(p_rsu_ctrl);
                                        }
                                        p_meas_node = (rrm_rsu_meas_id_node_t*)ylNext(&p_meas_node->node);
                                    }
                                    /*For serving cell search all the meas_id for a particular enb_id and delete the hash */
                                    p_serv_node = (rrm_rsu_meas_srv_cell_info_node_t *)yhFirst(&(p_rrm_gbl_ctx->rsu_measid_serving_hash_tbl));
                                    /*serving node next is also pointing to first node of table */
                                    p_serv_node_next = p_serv_node;
                                    while(p_serv_node_next != RRM_PNULL)
                                    {
                                        if(RRM_ZERO == RRM_MEMCMP(&(p_serv_node->rsu_id.g_enb_id), p_peer_enb_id, sizeof(x2_gb_enb_id_t)))
                                        {
                                            /* BUG_825_Fix Start */
                                            /* Stoping RSU Timer */
                                            if (RRM_TRUE == qvTimerRunning(p_serv_node_next->timer_id))
                                            {
                                                rrm_ue_stop_timer(p_serv_node_next->timer_id);
                                            }
                                            /* BUG_825_Fix End */
                                            /*delete the node from hash*/
                                            yhDelete (&(p_rrm_gbl_ctx->rsu_measid_hash_tbl), (YHNODE *)p_serv_node_next);
                                        }
                                        p_serv_node_next = (rrm_rsu_meas_srv_cell_info_node_t *)yhNext(&(p_rrm_gbl_ctx->rsu_measid_serving_hash_tbl), (YHNODE *)p_serv_node);
                                    }
                                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].x2_link_up_status = RRM_FALSE;
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                                            RRM_BRIEF,"Marking Link Down for PCI[%u]",
                                            p_cell_ctxt->ran_info.ncl_params.lte_ncl.inter_freq_cells[i].phy_cell_id);
                                }
                            default:
                                break;
                        }
                    }
                }
#ifdef LTE_EMBMS_SUPPORTED
                if (MBMS_SIB_2_ON_BROADCAST &
                    p_cell_ctxt->rrm_cell_embms_data.current_sibs_on_boradcast)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "SIB2 is on broadcast");
                    p_cell_ctxt->rrm_cell_embms_data.align_drx_cqi |= 
                                MBMS_LINK_UP_DOWN_IND_PRESENT;
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Calculating neigh_cell_config IE for both intra/inter freq cells");

                    rrm_process_link_up_down_nrt_for_mbms(p_cell_ctxt);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "SIB2 not on broadcast...!!!");
                }
#endif

                if ((X2AP_RRM_LINK_UP_IND == api_id) && (RRM_ZERO != p_cell_ctxt->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]))
                {
                    rrm_hndl_rsu_start_req_for_ncl (p_cell_ctxt, p_cell_ctxt->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO]);
                }
            }
        /* BUG_825_Fix Start */
        }
        /* BUG_825_Fix End */
    }
    else
    {
        RRM_TRACE(RRM_TRUE, p_rrm_event_facility_name, RRM_BRIEF,
                "NULL returned by qvThisContext to top_rrm_gbl_ctx ");
    }
}
/* MLB Changes end */

rrm_void_t
update_si_index_in_etws_warning_list
(
 YLIST *p_scheduled_etws_warning_list,
 U8 cmas_updated_index,
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();
	YLNODE *p_temp = RRM_PNULL;

	p_temp = p_scheduled_etws_warning_list->node.next;

	while(p_temp)
	{
		if(cmas_updated_index < ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] )
		{
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]--;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]--;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX]--;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX]--;
            /* DYNAMIC SIB SCHEDULING START */
            ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity =
                          p_cell_context->si_segment_data_sib_scheduling
                          [((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].si_segment_periodicity;
            
            ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity_second_sib =
                          p_cell_context->si_segment_data_sib_scheduling
                          [((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX]].si_segment_periodicity;
            /* DYNAMIC SIB SCHEDULING END */
		}
		p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
	} 

	RRM_UT_TRACE_EXIT();
}

rrm_void_t
update_si_index_in_cmas_warning_list
(
 YLIST *p_scheduled_cmas_warning_list,
 U8 etws_updated_index,
 rrm_cell_context_t *p_cell_context
 )
{
	RRM_UT_TRACE_ENTER();
	YLNODE *p_temp = RRM_PNULL;

	p_temp = p_scheduled_cmas_warning_list->node.next;

	while(p_temp)
	{
		if(etws_updated_index < ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX])
		{
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX] = etws_updated_index;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_END_IDX] = etws_updated_index ;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_START_IDX] = etws_updated_index ;
			((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_PREV_END_IDX] = etws_updated_index ;
             /* DYNAMIC SIB SCHEDULING START */
             ((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_periodicity =
                          p_cell_context->si_segment_data_sib_scheduling
                          [((scheduled_pws_data_node_t *)p_temp)->scheduled_pws_data.si_index[RRM_SI_CURR_START_IDX]].si_segment_periodicity;
             /* DYNAMIC SIB SCHEDULING END */
		}
		p_temp = ((scheduled_pws_data_node_t *)p_temp)->pNode.next;
	} 
	
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_cellm_ttt_update_ind_process_msg
 * Inputs         : void *p_api  : pointer to api buffer
 *                : U16 api_id   : api id
 *                : U16 data_len : data length
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Handles the RRMCM_RMIF_TTT_UPDATE_IND_REQ message from mif
 ****************************************************************************/
rrm_return_et
rrm_cellm_ttt_update_ind_process_msg
(
        void *p_api,/*pointer pt api buffer*/
        U16 api_id /*API id of incoming message*/
            /*SPR 17777 +-*/
)
{
    rrm_cell_index_t cell_index = RRM_ZERO;
    rrm_return_et    ret_val    = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    cell_index = ((rrmcm_rmif_ttt_update_ind_t *)p_api)->cell_index;
    SET_CELL_INDEX(cell_index);

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "MIF->RRMCM_RMIF_TTT_UPDATE_IND_REQ->CellM:[CELL:%d]", cell_index);
    
    if (RRM_MAX_NUM_CELLS > cell_index)
    {
		if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
		{
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;

			/* message processing to FSM */
			p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id =
				RRMCM_RMIF_TTT_UPDATE_IND_REQ;

			if (RRM_FAILURE == (ret_val = cellm_fsm_process_event (
										  RRMCM_RMIF_TTT_UPDATE_IND_EVENT,
										  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])))
			{
					RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR, 
							  "could not process api id %d in fsm", api_id);
			}
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                      "p_g_rrm_cell_ctx->p_rrm_cell_ctx[%d] is NULL",cell_index);
			ret_val = RRM_FAILURE;
		}
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                         "Cell index[%d] is invalid", cell_index);
        ret_val = RRM_FAILURE;
    }
    
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*DYNAMIC SIB SCHEDULING START*/
rrm_void_t
rrm_cellm_init_si_segment_data
(
 rrm_cell_context_t *p_cell_context
 )
{
  U8 si_count = RRM_ZERO;
	RRM_UT_TRACE_ENTER();
  for(si_count = RRM_ZERO; si_count < RRM_ELEVEN ; si_count++ )
  {
    p_cell_context->si_segment_data_sib_scheduling[si_count].si_segment_id = RRM_ZERO;
    p_cell_context->si_segment_data_sib_scheduling[si_count].si_segment_periodicity = RRM_EVENT_U32_INVALID_VALUE;
    p_cell_context->si_segment_data_sib_scheduling[si_count].is_periodicity_changed = RRM_FALSE;
  }

  RRM_UT_TRACE_EXIT();
}
/*DYNAMIC SIB SCHEDULING END*/



U16 rrm_inter_freq_count(rrm_cell_index_t cell_index)
{
        RRM_UT_TRACE_ENTER();
        if (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index] != RRM_PNULL)
        {
                RRM_UT_TRACE_EXIT();
                return  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell;
        }
        else
        {
                RRM_UT_TRACE_EXIT();
                return RRM_ZERO;
        }

}

/*DYNAMIC ICIC START*/

/**************************************************************************
 * Function Name  : rrm_cellm_increment_dynamic_icic_counter_in_cell 
 * Inputs         : cell_index , counter_to_be_updated
 * Outputs        : None
 * Returns        : None
 * Description    : This functions increments the dynamic icic related counter
 *                  that is specified in the input by one.
 ****************************************************************************/
rrm_void_t
rrm_cellm_increment_dynamic_icic_counter_in_cell
( 
  rrm_cell_index_t  cell_index,
  rrm_cellm_dynamic_icic_counters_et counter_to_be_updated
) 
{
  RRM_UT_TRACE_ENTER();
  
  switch(counter_to_be_updated)
  {
    case RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES:

        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_edge++;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"CE UE's are incremented");
    break;
    case RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES:

       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_center++;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"CC UE's are incremented");
    break;

    case RRM_CELLM_DYNAMIC_ICIC_HANDOUT_UES:
    
       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_handout_in_olpc++;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"HO UE's are incremented");
    break;
   
    case RRM_CELLM_DYNAMIC_ICIC_P_MAX_UES:

       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_vd_max_p_a_val++;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"UE's with max P_A are incremented");
    break;
  }
  
  RRM_UT_TRACE_EXIT();
}

/**************************************************************************
 * Function Name  : rrm_cellm_decrement_dynamic_icic_counter_in_cell 
 * Inputs         : cell_index , counter_to_be_updated
 * Outputs        : None
 * Returns        : None
 * Description    : This functions decrements the dynamic icic related counter
 *                  that is specified in the input by one.
 ****************************************************************************/
rrm_void_t
rrm_cellm_decrement_dynamic_icic_counter_in_cell
( 
  rrm_cell_index_t  cell_index,
  rrm_cellm_dynamic_icic_counters_et counter_to_be_updated
) 
{
  RRM_UT_TRACE_ENTER();
  
  switch(counter_to_be_updated)
  {
    case RRM_CELLM_DYNAMIC_ICIC_CELL_EDGE_UES:

        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_edge--;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"CE UE's are decremented");
    break;
    case RRM_CELLM_DYNAMIC_ICIC_CELL_CENTER_UES:

       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_in_cell_center--;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"CC UE's are decremented");
    break;

    case RRM_CELLM_DYNAMIC_ICIC_HANDOUT_UES:
    
       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_handout_in_olpc--;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"HO UE's are decremented");
    break;
   
    case RRM_CELLM_DYNAMIC_ICIC_P_MAX_UES:

       p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->dynamic_icic_data.num_ues_vd_max_p_a_val--;
	   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
				  RRM_DETAILED,"UE's with max P_A are decremented");
    break;
  }
  
  RRM_UT_TRACE_EXIT();
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_icic_scheme_configured_in_cell 
 * Inputs         : cell_index 
 * Outputs        : NONE
 * Returns        : ICIC Scheme configured
 * Description    : This functions returns the ICIC scheme configured in cell
 *                  by operator from OAM.
 ****************************************************************************/
rrm_icic_scheme_type_et
rrm_cellm_get_icic_scheme_configured_in_cell
( 
  rrm_cell_index_t  cell_index
) 
{
    operator_info_t            *p_operator_info = RRM_PNULL;
    rrm_icic_scheme_type_et    ret_val = ICIC_SCHEME_NONE; 

    RRM_UT_TRACE_ENTER();

    p_operator_info = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info);
    RRM_ASSERT(RRM_PNULL != p_operator_info);
    if((RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & p_operator_info->bitmask) && 
       (RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT & p_operator_info->dynamic_icic_info.bitmask))
    {
        ret_val = p_operator_info->dynamic_icic_info.icic_scheme_type;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/**************************************************************************
 * Function Name  : rrm_cellm_ce_partition_configured_in_cell 
 * Inputs         : cell_index 
 * Outputs        : NONE
 * Returns        : RRM_TRUE : Cell Edge Partition is configured
 *                  RRM_FALSE: Cell Edge Partition is NOT configured
 * Description    : This functions returns whether Cell Edge Partition is 
 *                  configured or not .
 ****************************************************************************/
rrm_bool_et
rrm_cellm_ce_partition_configured_in_cell
( 
  rrm_cell_index_t  cell_index
) 
{
    operator_info_t            *p_operator_info = RRM_PNULL;
    rrm_bool_et                 ret_val         = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    p_operator_info = &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info);

    RRM_ASSERT(RRM_PNULL != p_operator_info);
    
    if(RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT & p_operator_info->bitmask)
    {
           if((p_operator_info->dynamic_icic_info.bitmask & 
                    RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT)  &&
              (p_operator_info->dynamic_icic_info.dl_resource_partition_info.bitmask & 
                             RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT) &&
              (RRM_ZERO != p_operator_info->dynamic_icic_info.dl_resource_partition_info.
                           num_of_cell_edge_region))
           {
                     ret_val = RRM_TRUE;
           }
           if((RRM_FALSE == ret_val) &&
              (p_operator_info->dynamic_icic_info.bitmask & 
                    RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT)  &&
              (p_operator_info->dynamic_icic_info.ul_resource_partition_info.bitmask & 
                             RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT) &&
              (RRM_ZERO != p_operator_info->dynamic_icic_info.ul_resource_partition_info.
                           num_of_cell_edge_region))
           {
                     ret_val = RRM_TRUE;
           }
    }


    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/**************************************************************************
 * Function Name  : rrm_cellm_get_initial_ue_loc_configured_in_cell 
 * Inputs         : cell_index 
 * Outputs        : NONE
 * Returns        : Initial_UE location configured
 * Description    : This functions returns Initial_UE location configured
 ****************************************************************************/
rrm_ue_position_et
rrm_cellm_get_initial_ue_loc_configured_in_cell
( 
  rrm_cell_index_t  cell_index
) 
{
    RRM_UT_TRACE_ENTER();

    RRM_UT_TRACE_EXIT();
     /* coverity  : CID 41548 */
     return ((rrm_ue_position_et)(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.
                             admission_control_info.ue_service_profile.initial_ue_location));
    
}

#ifdef ENDC_ENABLED
/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms_higher_range_r15
 * Inputs         : rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle
 * Outputs        : drx_sf_in_ms_r15
 * Returns        : drx_sf_in_ms_r15
 * Description    : Returns the DRX SF config r15 in ms.
 ****************************************************************************/
U32
rrm_convert_drx_sf_in_ms_higher_range_r15
(
    rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle
)
{
    U32   drx_sf_in_ms  = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch ( long_drx_cycle )
    {

        case RRM_OAM_R15_SF320: 
            drx_sf_in_ms = RRM_DRX_SF320_IN_MSECS;
            break;
        case RRM_OAM_R15_SF512: 
            drx_sf_in_ms = RRM_DRX_SF512_IN_MSECS;
            break;
        case RRM_OAM_R15_SF640: 
            drx_sf_in_ms = RRM_DRX_SF640_IN_MSECS;
            break;
        case RRM_OAM_R15_SF1024: 
            drx_sf_in_ms = RRM_DRX_SF1024_IN_MSECS;
            break;
        case RRM_OAM_R15_SF1280: 
            drx_sf_in_ms = RRM_DRX_SF1280_IN_MSECS;
            break;
        case RRM_OAM_R15_SF2048: 
            drx_sf_in_ms = RRM_DRX_SF2048_IN_MSECS;
            break;
        case RRM_OAM_R15_SF2560: 
            drx_sf_in_ms = RRM_DRX_SF2560_IN_MSECS;
            break;
        case RRM_OAM_R15_SF5120: 
            drx_sf_in_ms = RRM_DRX_SF5120_IN_MSECS;
            break;
        case RRM_OAM_R15_SF10240: 
            drx_sf_in_ms = RRM_DRX_SF10240_IN_MSECS;
            break;

        default:
        drx_sf_in_ms = RRM_MIN_UE_RX_TX_MEASURE_TIME;
        break;
    }

    RRM_UT_TRACE_EXIT();

    return drx_sf_in_ms;
}

/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms_lower_range_r15
 * Inputs         : rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle
 * Outputs        : drx_sf_in_ms_r15
 * Returns        : drx_sf_in_ms_r15
 * Description    : Returns the DRX SF config R15 in ms.
 ****************************************************************************/
U32
rrm_convert_drx_sf_in_ms_lower_range_r15
(
    rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle
)
{
    U32   drx_sf_in_ms  = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch ( long_drx_cycle )
    {
        case RRM_OAM_R15_SF10:
            drx_sf_in_ms = RRM_DRX_SF10_IN_MSECS;
            break;
        case RRM_OAM_R15_SF20:
            drx_sf_in_ms = RRM_DRX_SF20_IN_MSECS;
            break;
        case RRM_OAM_R15_SF32:
            drx_sf_in_ms = RRM_DRX_SF32_IN_MSECS;
            break;
        case RRM_OAM_R15_SF40:
            drx_sf_in_ms = RRM_DRX_SF40_IN_MSECS;
            break;
        case RRM_OAM_R15_SF64:
            drx_sf_in_ms = RRM_DRX_SF64_IN_MSECS;
            break;
        case RRM_OAM_R15_SF80:
            drx_sf_in_ms = RRM_DRX_SF80_IN_MSECS;
            break;
        case RRM_OAM_R15_SF128:
            drx_sf_in_ms = RRM_DRX_SF128_IN_MSECS;
            break;
        case RRM_OAM_R15_SF160:
            drx_sf_in_ms = RRM_DRX_SF160_IN_MSECS;
            break;
        case RRM_OAM_R15_SF256: 
            drx_sf_in_ms = RRM_DRX_SF256_IN_MSECS;
            break;
        default:
            drx_sf_in_ms = RRM_MIN_UE_RX_TX_MEASURE_TIME;
            break;
    }

    RRM_UT_TRACE_EXIT();

    return drx_sf_in_ms;
}

/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms_r15
 * Inputs         : 
 * Outputs        : 
 * Returns        : drx_sf_in_ms_r15
 * Description    : Returns the DRX SF R15 config in ms.
 ****************************************************************************/
U32 
rrm_convert_drx_sf_in_ms_r15
(
    rrm_oam_long_drx_cycle_start_offset_r15_et  long_drx_cycle
)
{
    U32   drx_sf_in_ms  = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    
    if ( long_drx_cycle <= RRM_OAM_R15_SF256 )

    {
        drx_sf_in_ms = rrm_convert_drx_sf_in_ms_lower_range_r15(long_drx_cycle);
    }
    else
    {
        drx_sf_in_ms = rrm_convert_drx_sf_in_ms_higher_range_r15(long_drx_cycle);
    }

    RRM_UT_TRACE_EXIT();

    return drx_sf_in_ms;
}
#endif

/*DYNAMIC ICIC END*/
/* UE positioning start */
/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms_higher_range
 * Inputs         : rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle
 * Outputs        : drx_sf_in_ms
 * Returns        : drx_sf_in_ms
 * Description    : Returns the DRX SF config in ms.
 ****************************************************************************/
/*klock_works_changes_start*/
U32
rrm_convert_drx_sf_in_ms_higher_range(
        rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle
        )
{
    U32   drx_sf_in_ms  = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    switch (long_drx_cycle)
    {

        case RRM_OAM_SF256: 
            drx_sf_in_ms= RRM_DRX_SF256_IN_MSECS;
            break;
        case RRM_OAM_SF320: 
            drx_sf_in_ms= RRM_DRX_SF320_IN_MSECS;
            break;
        case RRM_OAM_SF512: 
            drx_sf_in_ms=  RRM_DRX_SF512_IN_MSECS;
            break;
        case RRM_OAM_SF640: 
            drx_sf_in_ms=  RRM_DRX_SF640_IN_MSECS;
            break;
        case RRM_OAM_SF1024: 
            drx_sf_in_ms= RRM_DRX_SF1024_IN_MSECS;
            break;
        case RRM_OAM_SF1280: 
            drx_sf_in_ms= RRM_DRX_SF1280_IN_MSECS;
            break;
        case RRM_OAM_SF2048: 
            drx_sf_in_ms= RRM_DRX_SF2048_IN_MSECS;
            break;
        case RRM_OAM_SF2560: 
            drx_sf_in_ms= RRM_DRX_SF2560_IN_MSECS;
            break;

        default:
        drx_sf_in_ms = RRM_MIN_UE_RX_TX_MEASURE_TIME;
        break;
    }
    RRM_UT_TRACE_EXIT();
    return drx_sf_in_ms;

}
/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms_lower_range
 * Inputs         : rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle
 * Outputs        : drx_sf_in_ms
 * Returns        : drx_sf_in_ms
 * Description    : Returns the DRX SF config in ms.
 ****************************************************************************/
U32
rrm_convert_drx_sf_in_ms_lower_range(
        rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle
        )
{
    U32   drx_sf_in_ms  = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    switch (long_drx_cycle)
    {
        case RRM_OAM_SF10:
            drx_sf_in_ms = RRM_DRX_SF10_IN_MSECS;
            break;
        case RRM_OAM_SF20:
            drx_sf_in_ms= RRM_DRX_SF20_IN_MSECS;
            break;
        case RRM_OAM_SF32:
            drx_sf_in_ms= RRM_DRX_SF32_IN_MSECS;
            break;
        case RRM_OAM_SF40:
            drx_sf_in_ms= RRM_DRX_SF40_IN_MSECS;
            break;
        case RRM_OAM_SF64:
            drx_sf_in_ms= RRM_DRX_SF64_IN_MSECS;
            break;
        case RRM_OAM_SF80:
            drx_sf_in_ms= RRM_DRX_SF80_IN_MSECS;
            break;
        case RRM_OAM_SF128:
            drx_sf_in_ms= RRM_DRX_SF128_IN_MSECS;
            break;
        case RRM_OAM_SF160:
            drx_sf_in_ms= RRM_DRX_SF160_IN_MSECS;
            break;
        default:
            drx_sf_in_ms = RRM_MIN_UE_RX_TX_MEASURE_TIME;
            break;
    }
    RRM_UT_TRACE_EXIT();
    return drx_sf_in_ms;

}
/*klock_works_changes_end*/
/****************************************************************************
 * Function Name  : rrm_convert_drx_sf_in_ms
 * Inputs         : 
 * Outputs        : 
 * Returns        : drx_sf_in_ms
 * Description    : Returns the DRX SF config in ms.
 ****************************************************************************/
U32 
rrm_convert_drx_sf_in_ms(
rrm_oam_long_drx_cycle_start_offset_et  long_drx_cycle
)
{
    U32   drx_sf_in_ms  = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    /*klock_works_changes_start*/
    if (long_drx_cycle<=RRM_OAM_SF160)

    {
        drx_sf_in_ms = rrm_convert_drx_sf_in_ms_lower_range(long_drx_cycle);

    }
    else
    {
        drx_sf_in_ms = rrm_convert_drx_sf_in_ms_higher_range(long_drx_cycle);

    }

    RRM_UT_TRACE_EXIT();
    return drx_sf_in_ms;
    /*klock_works_changes_end*/

}
/****************************************************************************
 * Function Name  : rrm_get_drx_cycle_period
 * Inputs         : 
 * Outputs        : drx_sf_in_ms
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Determine DRX cycle period based on DRX cycle.
 ****************************************************************************/
/* SPR 10450 Fix Start */
U32 
rrm_get_drx_cycle_period(
        rrm_cell_index_t                cell_index,
        U32                             applied_drx_profile_index
        )
{
    rrm_cell_context_t          *p_cell_context = RRM_PNULL;
    U32                         drx_sf_in_ms = RRM_MIN_UE_RX_TX_MEASURE_TIME;
    RRM_UT_TRACE_ENTER(); 
    p_cell_context = rrm_cellm_get_cell_context(cell_index);
    if(p_cell_context != RRM_PNULL && applied_drx_profile_index < MAX_NO_DRX_PROFILE)
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                "ran_info.bitmask=%d, mac_layer_params.bitmask=%d applied_drx_profile_index=%d",
                p_cell_context->ran_info.bitmask,
                p_cell_context->ran_info.mac_layer_params.bitmask,
                applied_drx_profile_index);

        if(p_cell_context->ran_info.bitmask & RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "drx_sf_in_ms will be depend on DRX configuration drx_enabled =%d, long_drx_cycle =%d",
                    p_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_enabled,
                    p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle);
            #ifdef ENDC_ENABLED
            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "drx_sf_in_ms will be depend on DRX configuration drx_enabled =%d, long_drx_cycle_r15 =%d",
                    p_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_enabled,
                    p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle_r15);
            #endif
            if (p_cell_context->ran_info.mac_layer_params.mac_layer_param_drx.drx_enabled == RRM_TRUE)
            {
                #ifdef ENDC_ENABLED
                if ( RRM_OAM_R15_SF5120 <=
                    p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle_r15 )
                {
                    if (p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle_r15 > RRM_OAM_R15_SF40)
                    {
                        drx_sf_in_ms = 
                            rrm_convert_drx_sf_in_ms_r15(p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle_r15);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "drx_sf_in_ms =%d ",
                                drx_sf_in_ms);
                        drx_sf_in_ms = drx_sf_in_ms * RRM_MAX_DRX_CYCLE;
                    }
                }
                else
                {
                    if (p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle > RRM_OAM_SF40)
                    {
                        drx_sf_in_ms = 
                            rrm_convert_drx_sf_in_ms(p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle);
                        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                                "drx_sf_in_ms =%d ",
                                drx_sf_in_ms);
                        drx_sf_in_ms = drx_sf_in_ms * RRM_MAX_DRX_CYCLE;
                    }
                }
                #else
                if (p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle > RRM_OAM_SF40)
                {
                    drx_sf_in_ms = 
                  rrm_convert_drx_sf_in_ms(p_cell_context->rrm_cell_drx_config_resources.drx_res_arr[applied_drx_profile_index].long_drx_cycle);
                    RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                            "drx_sf_in_ms =%d ",
                            drx_sf_in_ms);
                    drx_sf_in_ms = drx_sf_in_ms * RRM_MAX_DRX_CYCLE;
                }
                #endif
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return drx_sf_in_ms;
}
/* SPR10450 Fix End */

/* UE positioning end */

/*Bug:9237 start*/
/******************************************************************************
 *   FUNCTION NAME: rrm_cell_init_queue 
 *   DESCRIPTION:
 *           function to initialize the queue
 *   RETURNS:
 *		void
 ******************************************************************************/
 rrm_void_t 
rrm_cell_init_queue
(
 rrm_cell_proc_queue_t *p_procedure_queue
 )
{
    ylInit(p_procedure_queue);
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cell_mgr_enqueue_req 
 *   DESCRIPTION:
 *          Function to queue the message.
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_return_et
rrm_cell_mgr_enqueue_req
(
  rrm_cell_procedure_queue_t * p_cell_proc_msg,
        /* SPR_17763_FIX_START */
  rrm_cell_context_t *p_cell_ctxt,
  rrm_bool_et         push_at_tail
        /* SPR_17763_FIX_END */
)
{
    rrm_cell_procedure_record_t         *p_cell_procedure_record = RRM_PNULL;
    rrm_return_et                       ret_val = RRM_SUCCESS;
    
        /* SPR_17763_FIX_START */
    RRM_UT_TRACE_ENTER();
        /* SPR_17763_FIX_END */
    p_cell_procedure_record = (rrm_cell_procedure_record_t *) rrm_mem_get
        (sizeof(rrm_cell_procedure_record_t));
    if (RRM_PNULL == p_cell_procedure_record)
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Unable to alocate the memory for record");
        ret_val = RRM_FAILURE;
    }
    else
    {
        /* SPR_17763_FIX_START */
        RRM_MEMSET(&(p_cell_procedure_record->proc_queue), RRM_ZERO, sizeof(rrm_cell_procedure_queue_t));
        /* SPR_17763_FIX_END */
        RRM_MEMCPY((rrm_void_t *)&p_cell_procedure_record->proc_queue,
                p_cell_proc_msg,
                sizeof(rrm_cell_procedure_queue_t));
        /* SPR_17763_FIX_START */
        if (RRM_TRUE == push_at_tail)
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "transId getting pushed at tail[%d]", p_cell_procedure_record->proc_queue.trans_id);
            ylPushTail(&p_cell_ctxt->procedure_queue, &(p_cell_procedure_record)->s_node);
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "transId getting pushed at head[%d]", p_cell_procedure_record->proc_queue.trans_id);
            ylPushHead(&p_cell_ctxt->procedure_queue, &(p_cell_procedure_record)->s_node);
        }
        /* SPR_17763_FIX_END */
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;

}

/******************************************************************************
 *   FUNCTION NAME: rrmcm_dequeue_message
 *   DESCRIPTION:
 *          Function to dequeue the message.
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_void_t
rrmcm_dequeue_message(
rrm_cell_context_t *p_cell_ctxt
)
{

    rrm_cell_procedure_record_t  *p_rrm_cell_procedure_record = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    /* Bug 3860 start */ 
    if(p_cell_ctxt->cell_state == CELL_STATE_W_FOR_CELL_START_RESP ||
       p_cell_ctxt->cell_state == CELL_STATE_W_FOR_CELL_START)
    {
       p_rrm_cell_procedure_record = (rrm_cell_procedure_record_t *)ylFirst(&(p_cell_ctxt->procedure_queue));
 
       if(NULL != p_rrm_cell_procedure_record)
       {
	      if(p_rrm_cell_procedure_record->proc_queue.api_id == RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ)
	      {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
              "Received event :%d for cell index:%d in state CELL_STATE_W_FOR_CELL_START or START_RESP, so dequeueing is not done",
                    p_rrm_cell_procedure_record->proc_queue.event_id,
                    p_cell_ctxt->cell_index);
	         return;
	      }
       }
    }
    p_rrm_cell_procedure_record = RRM_PNULL;
    /* Bug 3860 end */
    p_rrm_cell_procedure_record = (rrm_cell_procedure_record_t *)ylPopHead(&(p_cell_ctxt->procedure_queue));
    if (RRM_PNULL != p_rrm_cell_procedure_record )
    {
        /*depending on the event generate event and call fsm*/
        p_cell_ctxt->p_incoming_api_info = p_rrm_cell_procedure_record->proc_queue.p_proc_data;
        p_cell_ctxt->ongoing_trans_id = p_rrm_cell_procedure_record->proc_queue.trans_id;
        /*TRANS ID FIX */
        p_cell_ctxt->api_id = p_rrm_cell_procedure_record->proc_queue.api_id;
        p_cell_ctxt->event_id = p_rrm_cell_procedure_record->proc_queue.event_id;
            
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_DETAILED,"message dequeued  event :%d trans id : %d api is %d for cell index:%d",
                    p_rrm_cell_procedure_record->proc_queue.event_id,
                    p_rrm_cell_procedure_record->proc_queue.trans_id,
                    p_rrm_cell_procedure_record->proc_queue.api_id,
                    p_cell_ctxt->cell_index);

        if (RRM_SUCCESS == cellm_fsm_process_event(
                    p_rrm_cell_procedure_record->proc_queue.event_id,
                    p_cell_ctxt))
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_DETAILED,"success in event :%d for cell index:%d",
                    p_rrm_cell_procedure_record->proc_queue.event_id,
                    p_cell_ctxt->cell_index);

        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
                    RRM_BRIEF,"failure in event :%d for cell index:%d",
                    p_rrm_cell_procedure_record->proc_queue.event_id,
                    p_cell_ctxt->cell_index);
        }
        /*SPR 21322 START*/
        if(RRM_PNULL != p_rrm_cell_procedure_record->proc_queue.p_proc_data)
        {
            RRM_MEM_FREE(p_rrm_cell_procedure_record->proc_queue.p_proc_data);
        }
        /*SPR 21322 END*/

        /*SPR 18597: Fix Start*/
#ifdef LTE_EMBMS_SUPPORTED

        if(M2AP_RRM_MBMS_SF_INFO_REQ == p_cell_ctxt->api_id)
        {

            rrm_send_sf_info_resp_for_m2ap_after_dequeing(
                    p_cell_ctxt->p_incoming_api_info,
                    p_cell_ctxt->ongoing_trans_id);
        }
#endif
        /*SPR 18597: Fix End*/

        if(RRM_PNULL != p_rrm_cell_procedure_record)
        {
            RRM_MEM_FREE(p_rrm_cell_procedure_record); 
        }
    }
    RRM_UT_TRACE_EXIT();
}
/******************************************************************************
 *   FUNCTION NAME: rrm_clean_cell_queue 
 *   DESCRIPTION:
 *          Function to free the allocated memory for queue
 *   RETURNS:
 *		void
 ******************************************************************************/
rrm_void_t
rrm_clean_cell_queue
(
    rrm_cell_context_t *p_cell_ctxt
)
{
    rrm_cell_procedure_record_t  *p_rrm_cell_procedure_record = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    while(RRM_PNULL != (p_rrm_cell_procedure_record = (rrm_cell_procedure_record_t *)ylPopHead(&(p_cell_ctxt->procedure_queue))))
    {
        if (RRM_PNULL != p_rrm_cell_procedure_record->proc_queue.p_proc_data)
        {
            RRM_MEM_FREE(p_rrm_cell_procedure_record->proc_queue.p_proc_data);
            p_rrm_cell_procedure_record->proc_queue.p_proc_data = RRM_PNULL;
        }
        /*Coverity_fix_start_62522*/
        RRM_MEM_FREE(p_rrm_cell_procedure_record);
        p_rrm_cell_procedure_record = RRM_NULL;
        /*Coverity_fix_end_62522*/
    }
    RRM_UT_TRACE_EXIT();
}
/*Bug:9237 end*/
/* Carrier_Aggregation_Start */
/****************************************************************************
 * Function Name  : rrm_update_cell_change_object
 * Inputs         : cell_index, cell_change_notify_bitmask
 * Outputs        : 
 * Returns        : Void
 * Description    : This function update cell change notification in global context
 *                : for a particular cell.
 ****************************************************************************/
rrm_void_t
rrm_update_cell_change_object
(
    rrm_cell_index_t cell_index,
    U64 cell_change_notify_bitmask
)
{
    RRM_UT_TRACE_ENTER();
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
				  "Updating cell change notification in global context"
                  "for cell_index[%d]",cell_index);
    if (RRM_PNULL != p_g_rrm_cell_ctx)
    {
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_modify_notification_obj.is_cell_changed = RRM_TRUE;
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_modify_notification_obj.cell_transfer_obj.cell_index = cell_index;
        p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask |=
            cell_change_notify_bitmask;
    }
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF, 
            "Value of cell change notification bitmask is %llu "
                  "for cell_index[%d]",cell_change_notify_bitmask,cell_index);
    RRM_UT_TRACE_EXIT();

}
/* Carrier_Aggregation_End */

/* CA: SCell Selection start */
/**************************************************************************
 * Function Name  : rrm_sort_scell_list_by_cell_capacity
 * Inputs         : scell_list
 *                : scell_cap_list
 *                : count
 * Outputs        : NONE
 * Description    : This function returns an array of Scell-eligible cells
 *                  arranged in the descending order of their cell capacity.
 **************************************************************************/
rrm_void_t
rrm_sort_scell_list_by_cell_capacity(
                rrm_cell_index_t            *scell_list,
                rrm_cell_index_t            *scell_cap_list,
                U8                           count
                )
{
    U8        temp,temp2 = RRM_OUT_OF_RANGE;
    U8        i = RRM_ZERO; 
    S8        j = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    
    for(i = 1 ; i < count; i++)
    {
        if(RRM_OUT_OF_RANGE != scell_list[i] &&
           RRM_OUT_OF_RANGE != scell_cap_list[i])
        {
            /* Sorting the list according to the cell capacity */
            temp = scell_cap_list[i];
            temp2 = scell_list[i];
            j = i - 1;

            while((temp > scell_cap_list[j]) && (j >= 0))
            {
                scell_cap_list[j+1] = scell_cap_list[j];
                scell_list[j+1] = scell_list[j];
                j = j - 1;
            }
            scell_cap_list[j+1] = temp;
            scell_list[j+1] = temp2;
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "Element at index: %d has not been populated in the array.\
                The values are scell_list[%d] and scell_cap_list[%d]", 
                i, scell_list[i], scell_cap_list[i]);
        }
    }

    /* Displaying the contents of the sorted array */
    for(i = RRM_ZERO; i < count; i++)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "scell_list[%d] and scell_cap_list[%d]", 
            scell_list[i], scell_cap_list[i]);
    }

    RRM_UT_TRACE_EXIT();
}
/**************************************************************************
 * Function Name  : rrm_update_scell_list_and_scell_cap_list 
 * Inputs         : p_scell_index, p_scell_list, p_scell_cap_list, p_inter_freq,
 *                : p_cell_index_of_scell
 * Description    : This function update scell list on basis of scell capacity. 
 * Outputs        : NONE
 **************************************************************************/
rrm_void_t
rrm_update_scell_list_and_scell_cap_list(U8 *p_scell_index, 
                                         rrm_cell_index_t *p_scell_list,
                                         rrm_cell_index_t *p_scell_cap_list,
                                         inter_freq_cells_t *p_inter_freq,
                                         rrm_cell_index_t *p_cell_index_of_scell)
{
    RRM_UT_TRACE_ENTER();
    p_scell_list[*p_scell_index] = *p_cell_index_of_scell;

    if(p_inter_freq->resrc_report.bitmask & 
            RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT)
    {
        /* Storing the cell capacity values of the scell eligible cells
           in a separate array */

        p_scell_cap_list[*p_scell_index] = 
            p_inter_freq->resrc_report.comp_avl_cap_grp.dl.cell_cap_val;
    }
    else
    {
        p_scell_cap_list[*p_scell_index] = RRM_MAX_AVLB_CAPCTY;
    }

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Local cell with cell_id: %d added to the scell_list at index %d with cell capacity value: %d",
            *p_cell_index_of_scell, *p_scell_index,
            p_inter_freq->resrc_report.comp_avl_cap_grp.dl.cell_cap_val);

    RRM_UT_TRACE_EXIT();
}
/**************************************************************************
 * Function Name  : rrm_validate_ncl_cell_for_scell_selection 
 * Inputs         : p_inter_freq, cell_index, p_scell_deactivated_flag
 *                : p_cell_index_of_scell
 * Outputs        : NONE
 * Description    : This function validate NCL to be selected as scell. 
 *                : Found cell context for that NCL.Update scell final list
 **************************************************************************/
rrm_return_et
rrm_validate_ncl_cell_for_scell_selection(inter_freq_cells_t *p_inter_freq, 
        U8 cell_index, rrm_bool_et *p_scell_deactivated_flag, rrm_cell_index_t *p_cell_index_of_scell)
{
    U8 index = RRM_ZERO;
    U8                     resc_cnt = RRM_ZERO;
    rrm_cell_context_t *p_cell_context = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    
    p_cell_context = rrm_cellm_get_cell_context(cell_index);
    if (RRM_PNULL == p_cell_context)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "cell context is null for cell index: %d", cell_index);
        RRM_UT_TRACE_EXIT();
        return RRM_FAILURE;
    }
    /*Broadcast status removed*/
    if((X2_LOCALLY_CONNECTED_CELL == p_inter_freq->x2_status) &&
            (RRM_ZERO == p_inter_freq->blacklisted))
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "X2_status[%d] blacklisted[%d]", 
                p_inter_freq->x2_status,p_inter_freq->blacklisted);

        for(index = RRM_ZERO; (index < RRM_MAX_NUM_CELLS); index++)
        {
            /* If the index is of the PCell itself, then skip 
             ** the execution and continue the loop */

            if(index == cell_index)
                continue;

            /*
             ** Some checking criteria are to be checked from NCL list and some from the
             ** cell_global_context, so in order to be in sync, global cell ids of the cells
             ** picked from both, need to be compared, so as to perform the operation on the
             ** same cell.
             */

            if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[index])
            {
                if(RRM_ZERO == RRM_MEMCMP(&(p_inter_freq->cell_id),
                            &p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->global_cell_id, 
                            sizeof(rrm_global_cell_id_t)))
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "Global Cell ids matched for local cell with cell index: %d",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                    *p_cell_index_of_scell = p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index;
                    *p_scell_deactivated_flag = RRM_FALSE;
                    /* 
                     ** A local cell will be considered to be a SCell, if -
                     ** 1- Its boolean variable 'is_ca_eligible' configured from OAM, is set to TRUE
                     ** 2- The state of the Cell is ACTIVE.
                     ** 3- In case of CA TDD, TDD DL/UL config and special subframe configuration of
                     **    Scell and Pcell must be same.
                     ** 4- The MAC instance id of both PCell and SCell are same.
                     */

                    if((RRM_TRUE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible) &&
                            (CELL_STATE_ACTIVE == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state) &&
                            /* SPR 13383 changes start */
                            /* deleted code for pcell_bandwidth == scell_bandwidth */
                            /* SPR 13383 changes end */
                            (p_cell_context->operator_info.l2_instance == p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance))
                    {
                        /* CA TDD changes start */
#ifdef TDD_MODE_FLAG
                        /* In case of CA TDD, TDD DL/UL config and special subframe configuration of
                         * Scell and Pcell must be same.*/
                        if((p_cell_context->ran_info.physical_layer_params.
                                physical_layer_param_tdd_frame_structure.sub_frame_assignment != 
                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.physical_layer_params.
                                 physical_layer_param_tdd_frame_structure.sub_frame_assignment) ||
                                (p_cell_context->ran_info.physical_layer_params.
                                 physical_layer_param_tdd_frame_structure.special_sub_frame_patterns !=
                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.physical_layer_params.
                                 physical_layer_param_tdd_frame_structure.special_sub_frame_patterns))
                        {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Cannot select cell[%d] because of tdd config mismatch among two cells ",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);
                                *p_scell_deactivated_flag= RRM_TRUE;
                                break;
                        }

#endif
                        /* CA TDD changes end */

                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "SCell eligibility criteria matched for the local cell with the cell index: %d",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "For the local cell with cell_index: %d, is_ca_eligible: %d, cell_state: %d," 
                                "dl_bandwidth: %d, l2_instance: %d",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance);

                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "PCell with cell_index: %d has frequency band indicator: %d and l2_instance: %d",
                                p_cell_context->cell_index,
                                p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                p_cell_context->operator_info.l2_instance);

                        if(RRM_CELL_LOAD_COMPOSITE_PRESENT == 
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.choice)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Load Action choice is 1 i.e. comp_load_info");
                            if( p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.comp_load_info.actn_status & 
                                    RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Cannot select cell[%d] due to action RRMCM_ACTN_RRM_SCELL_DEACTIVATE on the cell",
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                                *p_scell_deactivated_flag= RRM_TRUE;
                            }
                        }
                        else if(RRM_CELL_LOAD_RESRC_SPEC_PRESENT == 
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.choice)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Load Action choice is 2 i.e. resrc_spec_info");

                            for(resc_cnt = RRM_ZERO; 
                                    resc_cnt < p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.resrc_spec_info.count; 
                                    resc_cnt++)
                            {
                                if( p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.resrc_spec_info.resrc_spec_info[resc_cnt].ld_actn.actn_status & 
                                        RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                            "Cannot select cell[%d] due to action RRMCM_ACTN_RRM_SCELL_DEACTIVATE on the cell",
                                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                                    *p_scell_deactivated_flag= RRM_TRUE;
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "SCell eligibility criteria did not match for the local cell. \
                                cell_state: %d, is_ca_eligible: %d, dl_bandwidth: %d \
                                l2_instance: %d for cell_index: %d",
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance,
                                p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);
                        *p_scell_deactivated_flag = RRM_TRUE;
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "Global Cell ids did not match for local cell with cell index: %d",
                            p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);
                    *p_scell_deactivated_flag = RRM_TRUE;
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                        "Cell_context of cell_index[%d] is NULL", index);
                *p_scell_deactivated_flag = RRM_TRUE;
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "X2_status[%d] blacklisted[%d]", 
                p_inter_freq->x2_status,p_inter_freq->blacklisted);
        *p_scell_deactivated_flag = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*************************************************************************
 * Function Name  : rrm_fetch_scell_eligible_cells_from_cellm
 * Inputs         : rrm_cell_index_t   cell_index
 *                : rrm_cell_index_t  *scell_list
 * Outputs        : NONE
 * Description    : This function prepares a list of Scell-eligible cells
 *                  from the list of same eNB cells for the primary cell,
 *                  whose cell index is received as an input.
 *************************************************************************/
rrm_void_t
rrm_fetch_scell_eligible_cells_from_cellm(
                rrm_cell_index_t                cell_index,
                rrm_cell_index_t               *scell_list
                )
{
    rrm_cell_context_t    *p_cell_context = RRM_PNULL;
    U8                     ncl_index = RRM_ZERO;
    U8                     total_inter_freq_nbrs = RRM_ZERO;
    rrm_cell_index_t       scell_cap_list[RRM_MAX_SCELL] = {RRM_OUT_OF_RANGE};
    U8                     count = RRM_ZERO;
    U8                     scell_index = RRM_ZERO;
    lte_ncl_t             *p_lte_ncl = RRM_PNULL;
    rrm_bool_et            scell_deactivated_flag = RRM_FALSE;
    rrm_cell_index_t       cell_index_of_scell = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    
    /* Initializing the array */
    for(count = RRM_ZERO; count < RRM_MAX_SCELL; count++)
    {
        scell_cap_list[count] = RRM_OUT_OF_RANGE;
    }

    /* Fetching the cell context for PCell */
    p_cell_context = rrm_cellm_get_cell_context(cell_index);

    if(RRM_PNULL != p_cell_context)
    {
        p_lte_ncl = rrm_cellm_get_lte_ncl_info(cell_index);
        
        if(RRM_PNULL != p_lte_ncl)
        {
            total_inter_freq_nbrs = p_lte_ncl->num_valid_inter_freq_cell;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "total_inter_freq_nbrs = %d", total_inter_freq_nbrs);

            for(ncl_index = RRM_ZERO; ncl_index < total_inter_freq_nbrs; ncl_index++)
            {
                 scell_deactivated_flag = RRM_FALSE;
                 rrm_validate_ncl_cell_for_scell_selection(&(p_lte_ncl->inter_freq_cells[ncl_index]),
                        cell_index, &scell_deactivated_flag, &cell_index_of_scell);
                if (RRM_FALSE == scell_deactivated_flag)
                {
                    rrm_update_scell_list_and_scell_cap_list(&scell_index, scell_list, scell_cap_list, 
                                                         &(p_lte_ncl->inter_freq_cells[ncl_index]), &cell_index_of_scell);
                    /* scell_index incremented for the next index to be used */
                    scell_index++;
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                            "Cell with cell index: %d is deactivated", 
                            cell_index_of_scell);
                }
            }
        
            if(scell_index > RRM_ONE)
            {
                /* 
                ** Sorting the received scell_list in descending 
                ** order of the scell's capacity value, so that the 
                ** least loaded cell gets picked up first. Also, if one 
                ** scell can not be used later for any reason, the next 
                ** best candidate can be picked.
                */
            
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Number of elements in scell list[%d] is greater than 1, so sorting required", 
                    scell_index);

                rrm_sort_scell_list_by_cell_capacity(scell_list, 
                                                         scell_cap_list, 
                                                         scell_index);
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Number of elements in scell list[%d] is 0 or 1, so no sorting required", 
                    scell_index);
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "NCL of the PCell is NULL");
        }
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
            "p_cell_context is NULL for cell index: %d", cell_index);
        /* SPR 21251 End */
    }
    
    RRM_UT_TRACE_EXIT();
}
/* CA: SCell Selection end */

/* CA: Stage3 HO code start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_cell_index_from_ncl_pci
 *   INPUT        : U8                 num_of_scell
 *                : rrm_cell_index_t  *p_arr_cell_index
 *                : rrm_oam_eutran_global_cell_id_t  cell_id
 *   OUTPUT       : NONE
 *   DESCRIPTION  : Extracts Cell Index for a cell whose PCI from the NCL is known
 *   RETURNS      : void
 ******************************************************************************/
rrm_void_t
rrm_get_cell_index_from_ncl_pci(
            U8                                   num_of_scell,
            rrm_cell_index_t                    *p_arr_cell_index,
            rrm_oam_eutran_global_cell_id_t      cell_id 
            )
{
    U8     index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    
    for(index = RRM_ZERO; (index < RRM_MAX_NUM_CELLS); index++)
    {
        if(RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index])
        {
            if(RRM_ZERO == RRM_MEMCMP(&cell_id,
                                      & p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->global_cell_id, 
                                      sizeof(rrm_oam_eutran_global_cell_id_t)))
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                        "Global Cell ids matched for local cell with cell index: %d",
                         p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                p_arr_cell_index[num_of_scell] = index;
                break;
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}

/******************************************************************************
 *   FUNCTION NAME: rrm_fetch_scell_candidate_cell_index_from_cellm
 *   DESCRIPTION: Fetches cell index from CellM for the eligible scell candidates
 *                coming in HO_ADM_REQ.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_void_t
rrm_fetch_scell_candidate_cell_index_from_cellm(
                    U16                   *scell_pci_list,
                    rrm_cell_index_t      *scell_index_list,
                    rrm_cell_context_t    *p_cell_context
                    )
{
    U8                     ncl_index = RRM_ZERO;
    U8                     index = RRM_ZERO;
    U8                     total_inter_freq_nbrs = RRM_ZERO;
    U8                     count = RRM_ZERO;
    lte_ncl_t             *p_lte_ncl = RRM_PNULL;
    U8                     resc_cnt = RRM_ZERO;
    rrm_bool_et            p_scell_deactivated_flag = RRM_FALSE;
    U8                     list_count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(RRM_PNULL != p_cell_context)
    {
        p_lte_ncl = rrm_cellm_get_lte_ncl_info(p_cell_context->cell_index);
        
        if(RRM_PNULL != p_lte_ncl)
        {
            total_inter_freq_nbrs = p_lte_ncl->num_valid_inter_freq_cell;

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "total_inter_freq_nbrs = %d", total_inter_freq_nbrs);

            for(count = RRM_ZERO; count < RRM_EIGHT; count++)
            {
                for(ncl_index = RRM_ZERO; ncl_index < total_inter_freq_nbrs; ncl_index++)
                {
                    if(scell_pci_list[count] == p_lte_ncl->inter_freq_cells[ncl_index].phy_cell_id)
                    {
                        for(index = RRM_ZERO; index < RRM_MAX_NUM_CELLS; index++)
                        {
                            if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index])
                            {
                                if(RRM_ZERO == RRM_MEMCMP(& p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->global_cell_id,
                                            &p_lte_ncl->inter_freq_cells[ncl_index].cell_id,
                                            sizeof(rrm_oam_eutran_global_cell_id_t)))
                                {
                                    if((RRM_TRUE ==  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible) &&
                                            (CELL_STATE_ACTIVE ==  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state) &&
                                            /* SPR 13383 changes start */
                                            /* code deleted for pcell bandwidth ==  scell bandwidth */
                                            /* SPR 13383 changes end */
                                            (p_cell_context->operator_info.l2_instance ==  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance) &&
                                            X2_LOCALLY_CONNECTED_CELL == p_lte_ncl->inter_freq_cells[ncl_index].x2_status && 
                                            RRM_ZERO == p_lte_ncl->inter_freq_cells[ncl_index].blacklisted)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                "SCell eligibility criteria matched for the local cell with the cell index: %d",
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                "For the cell with cell_index: %d, is_ca_eligible: %d, cell_state: %d, \
                                                dl_bandwidth: %d, l2_instance: %d",
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance);

                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                "PCell with cell_index: %d has frequency band indicator: %d and l2_instance: %d",
                                                p_cell_context->cell_index,
                                                p_cell_context->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                                p_cell_context->operator_info.l2_instance);

                                        if(RRM_CELL_LOAD_COMPOSITE_PRESENT == 
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.choice)
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "Load Action choice is 1 i.e. comp_load_info");

                                            if( p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.comp_load_info.actn_status & 
                                                    RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
                                            {
                                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                                        "Cannot select cell[%d] due to action RRMCM_ACTN_RRM_SCELL_DEACTIVATE on the cell",
                                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                                                p_scell_deactivated_flag = RRM_TRUE;
                                            }
                                        }
                                        else if(RRM_CELL_LOAD_RESRC_SPEC_PRESENT == 
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.choice)
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "Load Action choice is 2 i.e. resrc_spec_info");

                                            for(resc_cnt = RRM_ZERO; 
                                                    resc_cnt <  p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.resrc_spec_info.count; 
                                                    resc_cnt++)
                                            {
                                                if( p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.u.resrc_spec_info.resrc_spec_info[resc_cnt].
                                                        ld_actn.actn_status & RRMCM_ACTN_RRM_SCELL_DEACTIVATE)
                                                {
                                                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                            "Cannot select cell[%d] due to action RRMCM_ACTN_RRM_SCELL_DEACTIVATE on the cell",
                                                             p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);

                                                    p_scell_deactivated_flag = RRM_TRUE;
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "Invalid Load Action choice: %d", 
                                                     p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_load_action.choice);
                                        }

                                        if(RRM_FALSE == p_scell_deactivated_flag)
                                        {
                                            scell_index_list[list_count] = index;
                                            list_count++;
                                        }
                                    }
                                    else
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                                "SCell eligibility criteria did not match for the local cell. \
                                                cell_state: %d, is_ca_eligible: %d, dl_bandwidth: %d \
                                                l2_instance: %d for cell_index: %d",
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_state,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.ca_config.is_ca_eligible,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->ran_info.rf_params.rf_configurations.dl_bandwidth,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->operator_info.l2_instance,
                                                 p_g_rrm_cell_ctx->p_rrm_cell_ctx[index]->cell_index);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* CA: Stage3 HO code end */

/* CA getter functions: Start */
/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_dl_num_harq_process
 *   DESCRIPTION: Fetches dl_num_harq_process value of provided Cell Index.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_dl_num_harq_process(
	rrm_cell_index_t cell_index,
	U8 *dl_num_harq_process)
{
    RRM_UT_TRACE_ENTER();
    const rrm_cell_context_t* p_rrm_cell_ctx;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    *dl_num_harq_process = p_rrm_cell_ctx->operator_info.rrm_mac_config.dl_num_harq_process;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_dl_i_mcs
 *   DESCRIPTION: Fetches dl_i_mcs value of provided Cell Index.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_dl_i_mcs(
	rrm_cell_index_t cell_index,
	U8 *dl_i_mcs)
{
    RRM_UT_TRACE_ENTER();
    const rrm_cell_context_t* p_rrm_cell_ctx;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    *dl_i_mcs = p_rrm_cell_ctx->operator_info.admission_control_info.snr_map.\
		snr_dep_params.downlink_snr_dep_params.dl_mcs; 
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}
/*cov fix start 63905*/
/******************************************************************************
 *   FUNCTION NAME: rrm_map_transmission_mode_ue_service_profile
 *   DESCRIPTION: This function map the value of transmission_mode
 *
 *   RETURNS: Void
 *
 ******************************************************************************/
void rrm_map_transmission_mode_ue_service_profile
                    (transmission_mode_ue_service_profile_et *transmission_mode,
                      U8 map_transmission_mode)
{
    RRM_UT_TRACE_ENTER();
    switch(map_transmission_mode)
    {
        case RRM_ZERO:
        *transmission_mode = TRANSMISSION_MODE_TM1;
        break;
        case RRM_ONE:
        *transmission_mode = TRANSMISSION_MODE_TM2;
        break;
        case RRM_TWO:
        *transmission_mode = TRANSMISSION_MODE_TM3;
        break;
        case RRM_THREE:
        *transmission_mode = TRANSMISSION_MODE_TM4;
        break;
        case RRM_FOUR:
        *transmission_mode = TRANSMISSION_MODE_TM5;
        break;
        case RRM_FIVE:
        *transmission_mode = TRANSMISSION_MODE_TM6;
        break;
        case RRM_SIX:
        *transmission_mode = TRANSMISSION_MODE_TM7;
        break;
        case RRM_SEVEN:
        *transmission_mode = TRANSMISSION_MODE_TM8_V920;
        break;
        default:
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name,
            RRM_WARNING, "Incorrect transmission_mode = %u",
            map_transmission_mode);
        break;
    }
    RRM_UT_TRACE_EXIT();
}
/*cov fix end 63905*/
/* CA_Stage_3_Scell_TM_change: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_get_scell_transmission_mode
 *   DESCRIPTION: Finds num_of_layer based on Cell Context & UE Category.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et
rrm_get_scell_transmission_mode(
     rrm_ue_context_t *p_rrm_ue_context,
     rrm_cell_index_t scell_cell_index,
     transmission_mode_ue_service_profile_et *transmission_mode)
{
    U8 scell_arr_idx = RRM_ZERO;
    rrm_return_et ret_val = RRM_FAILURE;
    /*cov fix start 63905*/
    U8 map_transmission_mode = RRM_ZERO;
   /*cov fix end 63905*/
    RRM_UT_TRACE_ENTER();
    if(p_rrm_ue_context != RRM_PNULL)
    {
        if(rrm_is_scell_valid_for_ue(p_rrm_ue_context, scell_cell_index, &scell_arr_idx))
        {
            /*cov fix start 63905*/
            map_transmission_mode = p_rrm_ue_context->ue_scell_add_params.rrm_scell_info_for_ue[scell_arr_idx]
                                                           .scell_antenna_info_dedicated_r10.transmission_mode;
            rrm_map_transmission_mode_ue_service_profile(transmission_mode,map_transmission_mode);
            /*cov fix end 63905*/
            ret_val = RRM_SUCCESS;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "NULL POINTER EXCEPTION for ue context!!");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA_Stage_3_Scell_TM_change: End */
/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_num_of_layer
 *   DESCRIPTION: Finds num_of_layer based on Cell Context & UE Category.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_num_of_layer(
	rrm_cell_index_t scell_cell_index,
	U8 *num_of_layer,
	rrm_ue_context_t *p_rrm_ue_context)
{
    RRM_UT_TRACE_ENTER();

    rrm_antenna_mxn_et mxn_support;
    rrm_return_et ret_val = RRM_SUCCESS;
    transmission_mode_ue_service_profile_et scell_tm = TRANSMISSION_MODE_TM1;
    rrm_ue_category_et ue_category = (rrm_ue_category_et)rrm_get_ue_category(p_rrm_ue_context);
    /* CA_Stage_3_Scell_TM_change: Start */
    if(rrm_get_scell_transmission_mode(p_rrm_ue_context, scell_cell_index, &scell_tm))
    {
        /* CA_Stage_3_Scell_TM_change: End */
    if(RRM_SUCCESS ==  rrm_get_mxn_anetnna_support( scell_cell_index, &mxn_support ))
    {
	if(RRM_SUCCESS == rrm_get_num_of_layer_for_ue_on_tx_mode_mxn( mxn_support,
                        scell_tm ,
		    ue_category,
		    num_of_layer ))
	{
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Num of Layers for SCELL = %d", *num_of_layer );
            }
            else
            {
                ret_val = RRM_FAILURE;
            }
	}
	else
	{
	    ret_val = RRM_FAILURE;
	}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Transmission Mode not set for the Scell or UE Context NULL!!");
	ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_code_book_index
 *   DESCRIPTION: Fetches code_book_index for the given Cell Index.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_code_book_index(
            /*SPR 17777 +-*/
	U8 *code_book_index)
{
    RRM_UT_TRACE_ENTER();
    *code_book_index = CODE_BOOK_INDEX;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_user_location_type
 *   DESCRIPTION: Fetches user_location_type for given Cell Index.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_user_location_type(
            /*SPR 17777 +-*/
	U8 *user_location_type)
{
    RRM_UT_TRACE_ENTER();
    /*to be updated when the implementation changes for further releases */
    rrm_cell_region_et ue_present_position = RRM_CELL_CENTER_UE;
    *user_location_type = (U8)ue_present_position;
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: get_scell_mac_main_config_ext_scell_activate_status
 *   DESCRIPTION: Fetches scell_activate_status for given Cell Index. 
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
rrm_return_et 
get_scell_mac_main_config_ext_scell_activate_status(
            /*SPR 17777 +-*/
	U8 *scell_activate_status)
{
    RRM_UT_TRACE_ENTER();
    *scell_activate_status = RRM_ONE; //1 -> Active : 0 -> Inactive
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_phy_pdsch_config_pa
 *   DESCRIPTION: Fetches phy_pdsch_config->p_a value for given Scell Index.
 *           
 *   RETURNS:  p_rrm_cell_ctx->ran_info.physical_layer_params.
 *                       physical_layer_param_pdsch.p_a
 ******************************************************************************/
U8 rrm_cellm_get_scell_phy_pdsch_config_pa
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    U8 scell_phy_pdsch_config_pa = RRM_ZERO;
    const rrm_cell_context_t* p_rrm_cell_ctx;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    scell_phy_pdsch_config_pa = p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a;
    RRM_UT_TRACE_EXIT();
    return scell_phy_pdsch_config_pa;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_pdsch_ref_signal_power 
 *   DESCRIPTION: Returns ref_signal_power for Scell Index.
 *           
 *   RETURNS: p_rrm_cell_ctx->ran_info.rf_params.
 *                  rf_configurations.reference_signal_power
 *       
 ******************************************************************************/
S8 rrm_cellm_get_scell_non_ul_config_pdsch_ref_signal_power
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.reference_signal_power;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_pdsch_pb
 *   DESCRIPTION: Returns pb for Scell Index.
 *           
 *   RETURNS: p_rrm_cell_ctx->ran_info.physical_layer_params.
 *                   physical_layer_param_pdsch.p_b
 ******************************************************************************/
U8 rrm_cellm_get_scell_non_ul_config_pdsch_pb
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_pdsch.p_b;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_phich_resource
 *   DESCRIPTION: Returns phich_resource for Scell Index.
 *           
 *   RETURNS: p_rrm_cell_ctx->operator_info.phich_config.phich_resource
 *       
 ******************************************************************************/
U8 rrm_cellm_get_scell_non_ul_config_phich_resource
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->operator_info.phich_config.phich_resource;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_phich_duration
 *   DESCRIPTION: Returns phich_duration for Scell Index.
 *           
 *   RETURNS: p_rrm_cell_ctx->operator_info.phich_config.phich_duration
 *
 ******************************************************************************/
U8 rrm_cellm_get_scell_non_ul_config_phich_duration 
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->operator_info.phich_config.phich_duration;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_antenna_port_count
 *   DESCRIPTION: Returns antenna_port_count for Scell Index.
 *           
 *   RETURNS: antenna_port_count of Scell.
 *       
 ******************************************************************************/
U8 rrm_cellm_get_scell_non_ul_config_antenna_port_count
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    U8  antenna_port_count = RRM_ZERO;
    if(RRM_FAILURE == rrm_cellm_get_scell_antenna_port(cell_index,&antenna_port_count))
    {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
		"Failure getting Scell antenna port count");
    }
    RRM_UT_TRACE_EXIT();
    return antenna_port_count;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_non_ul_config_dl_bandwidth 
 *   DESCRIPTION: Returns dl_bandwidth for Scell Index.
 *           
 *   RETURNS: dl_bandwidth of Scell
 *       
 ******************************************************************************/
U8 rrm_cellm_get_scell_non_ul_config_dl_bandwidth
(
 rrm_cell_index_t cell_index
)
{
    U8                        dl_bandwidth;
    const rrm_cell_context_t* p_rrm_cell_ctx;

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    switch(p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth)
	{  
	    case RRM_OAM_BW_N_6:
		dl_bandwidth = RRM_RRC_BW_N_6;
		break;
	    case RRM_OAM_BW_N_15:
		dl_bandwidth = RRM_RRC_BW_N_15;
		break;
	    case RRM_OAM_BW_N_25:
		dl_bandwidth = RRM_RRC_BW_N_25;
		break;
	    case RRM_OAM_BW_N_50:
		dl_bandwidth = RRM_RRC_BW_N_50;
		break;
	    case RRM_OAM_BW_N_75:
		dl_bandwidth = RRM_RRC_BW_N_75;
		break;
	    case RRM_OAM_BW_N_100:
		dl_bandwidth = RRM_RRC_BW_N_100;
		break;
	    default:
		dl_bandwidth = p_rrm_cell_ctx->ran_info.rf_params.\
		  rf_configurations.dl_bandwidth;
		RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, 
			RRM_WARNING, "Incorrect dl_band_width = %u",
			p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_bandwidth);
		break;
	}
    return dl_bandwidth;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_dl_carrier_freq
 *   DESCRIPTION: Returns dl earfcn for the Scell Index given.
 *           
 *   RETURNS: p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn
 *       
 ******************************************************************************/
U16 rrm_cellm_get_scell_dl_carrier_freq
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.dl_earfcn;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_pci 
 *   DESCRIPTION: Returns pci of the SCell Index as input.
 *           
 *   RETURNS: p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id
 *       
 ******************************************************************************/
rrc_phys_cell_id_t  rrm_cellm_get_scell_pci 
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    rrm_cell_context_t* p_rrm_cell_ctx = RRM_PNULL;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    RRM_UT_TRACE_EXIT();
    return (p_rrm_cell_ctx->ran_info.rf_params.rf_configurations.phy_cell_id);
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_ecg_id_of_scell
 *   DESCRIPTION: Returns Global Cell Id for the Scell Index as input.
 *           
 *   RETURNS: p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->global_cell_id
 *
 ******************************************************************************/
const rrm_global_cell_id_t *rrm_get_ecg_id_of_scell
(
 rrm_cell_index_t cell_index
)
{
    RRM_UT_TRACE_ENTER();
    RRM_UT_TRACE_EXIT();
    if (RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        return &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->global_cell_id);
    }
    else
    {
        return RRM_PNULL;
    }
}

/******************************************************************************
 *   FUNCTION NAME: rrm_get_scell_deact_timer_for_rrc 
 *   DESCRIPTION: Maps Scell Deactivation timer from OAM->RRM to RRM->RRC enum.
 *           
 *   RETURNS:
 *       RRM_SUCCESS on Success
 *       RRM_FAILURE on Failure
 ******************************************************************************/
    rrm_return_et
rrm_get_scell_deact_timer_for_rrc(rrm_scell_deactivation_timer_et scell_deactivation_timer, U8 *scell_deact_timer)
{
    rrm_return_et                             ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    switch(scell_deactivation_timer)
    {
        case RRM_SCELL_RF2:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_2;
              break;
        case RRM_SCELL_RF4:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_4;
              break;
        case RRM_SCELL_RF8:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_8;
              break;
        case RRM_SCELL_RF16:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_16;
              break;
        case RRM_SCELL_RF32:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_32;
              break;
        case RRM_SCELL_RF64:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_64;
              break;
        case RRM_SCELL_RF128:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_128;
              break;
        case RRM_SCELL_RFINFINITY:
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_INFINITY;
              break;
        default:
             RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,\
                       "Invalid value[%d] in Cell Context for SCell Deact Timer. Setting it to Infinity(255)", scell_deactivation_timer);
             *scell_deact_timer = (U8)RRC_RADIO_FRAME_INFINITY;
             break;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* CA changes : Start */
/* CA Stage 3 Start */
/**************************************************************************
 * Function Name  : rrmcm_check_updated_ncl_for_csg_id_and_bl_change
 * Inputs         : p_cell_ctx,
                  : bitmask
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles Scell release if the Scell's CSG ID has changed
                    (in case it was required for PCell and SCell compatibility) 
                    or SCell becomes blacklisted.
 ****************************************************************************/
rrm_return_et
rrmcm_check_updated_ncl_for_csg_id_and_bl_change(
                rrm_cell_context_t            *p_cell_ctx,
                U16                             bitmask
                )
{
   U8                            valid_inter_freq_ncl_count = RRM_ZERO;
   U8                            ncl_count = RRM_ZERO;
   U8                            scell_count = RRM_ZERO;
   /*cov fix start 63902*/
   rrm_cell_index_t              arr_scell_index[RRM_MAX_SCELL];
   /*cov fix end 63902*/
   const rrm_global_cell_id_t   *ecg_id_inter_freq_ncl;
   const rrm_global_cell_id_t   *ecg_id_scell;
   U32                           ret = RRM_ZERO;
   U8                            count = RRM_ZERO;
   U8                            counter=RRM_ZERO;
   
   RRM_UT_TRACE_ENTER();   
   
   /* Check if Inter freq. NCL was changed. If changed then compare the ECG Id of Scell & 
      Inter Freq NCL cells */
    if((bitmask & RRM_INTER_FREQ_BROADCAST_NBRS_UPDATED) || 
       (bitmask & RRM_INTER_FREQ_NON_BROADCAST_NBRS_UPDATED))
    {
        /* Compare ECG IDs on the Inter Freq. NCL & Scells */
        if(p_cell_ctx->ran_info.ncl_params.bitmask & RRMCM_RMIF_LTE_NCL_PRESENT)
        {
           
            valid_inter_freq_ncl_count = p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_inter_freq_cell;
            for(ncl_count = RRM_ZERO; ncl_count < valid_inter_freq_ncl_count; ncl_count++) 
            {
                ecg_id_inter_freq_ncl = &(p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[ncl_count].cell_id);
           
                for(scell_count = RRM_ZERO; scell_count < RRM_MAX_NUM_CELLS; scell_count++)
                {
                    
                    if(p_cell_ctx->scell_info[scell_count].scell_index != RRM_ZERO)
                    {

                        ecg_id_scell = rrm_get_ecg_id_of_scell(p_cell_ctx->scell_info[scell_count].scell_index);
                        if(RRM_PNULL != ecg_id_scell)
                        {
                            ret = RRM_MEMCMP(ecg_id_inter_freq_ncl, ecg_id_scell, sizeof(rrm_global_cell_id_t)); 
                            if(ret == RRM_ZERO)   /* both ecg ids are same */
                            {
                                if(p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[ncl_count].blacklisted == RRM_ONE) 
                                    /* BL Cell 0->False 1->True */
                                {
                                    arr_scell_index[counter] = p_cell_ctx->scell_info[scell_count].scell_index;
                                    counter++;
                                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                            "Scell Index: [%d] Blacklisted.", p_cell_ctx->scell_info[scell_count].scell_index);

                                }

                                else if(RRM_OAM_ACCESS_MODE_CLOSE == p_cell_ctx->access_mgmt_params.access_mode &&
                                        RRM_OAM_ACCESS_MODE_CLOSE == p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[ncl_count].cell_access_mode)
                                {
                                    for(count = RRM_ZERO; count < RRM_OAM_MAX_NUM_CSG_OCTETS; count++)
                                    {
                                        if(p_cell_ctx->access_mgmt_params.csg_id[count] == 
                                                p_cell_ctx->ran_info.ncl_params.lte_ncl.inter_freq_cells[ncl_count].csg_identity[count])
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "CSG ID of CLOSED PCell and SCell are same in NRT update at index %d", count);
                                        }
                                        else
                                        {
                                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                    "CSG ID of CLOSED PCell and SCell are different in NRT update at index %d", count);
                                            break;
                                        }
                                    }
                                    if(count == RRM_OAM_MAX_NUM_CSG_OCTETS)
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                "PCell and SCell both are CLOSED and their CSG ID is also equal");
                                    }
                                    else
                                    {
                                        arr_scell_index[counter] = p_cell_ctx->scell_info[scell_count].scell_index;
                                        counter++;
                                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                                "Scell Index: [%d] CSG ID doesn't match with that of PCell", p_cell_ctx->scell_info[scell_count].scell_index);

                                    }
                                }
                            }
                        }
                    }
                    else
                    {
		                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
		       	            "Cell Index: [%d] not in use as scell.", scell_count);
                    }
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
            "Intra Freq. Nbr cell info not changed, hence Scell Blacklist status or CSG ID is same as before.");
    }
    /*cov fix start 63902*/
    if((counter > RRM_ZERO) && (counter < RRM_MAX_SCELL)) 
    {
        /*SPR 13316:start*/
        rrm_fill_scell_to_remove_list(RRM_PNULL, p_cell_ctx->cell_index,counter, arr_scell_index, RRM_ZERO, RRM_ZERO);
        /*SPR 13316:end*/
    }
    /*cov fix end 63902*/
    RRM_UT_TRACE_EXIT();
    return RRM_SUCCESS;
}


/****************************************************************************
 * Function Name  : rrm_get_scell_list_of_cell  
 * Inputs         : pcell_index , scell_index  
 * Outputs        : 
 * Returns        : rrm_scell_user_list_t * 
 * Description    : getter function of scelllist  
 ****************************************************************************/
YLIST * rrm_get_scell_list_of_cell( rrm_cell_index_t  pcell_index,
                                    rrm_cell_index_t  scell_index )
{

    rrm_cell_context_t	    *pointer_current_pcell_context = RRM_NULL;
    YLIST                   *p_scell_user_list = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    pointer_current_pcell_context = rrm_cellm_get_cell_context( pcell_index );
    
    if( RRM_NULL != pointer_current_pcell_context )
    {
	if( scell_index < RRM_MAX_NUM_CELLS )
	{
	    p_scell_user_list = &( pointer_current_pcell_context->scell_info[scell_index].list );
	}
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "cell context null pointer retrived for cell index [%d]",pcell_index);
    }

    RRM_UT_TRACE_EXIT();

    return p_scell_user_list ;

}


/****************************************************************************
 * Function Name  : rrm_scell_search_ue_by_ue_index 
 * Inputs         : p_scell_node 
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    : key of function for scell list 
 ****************************************************************************/
const void * rrm_scell_search_ue_by_ue_index( const YLNODE * p_scell_node )
{

    rrm_ue_context_t	*p_ue_context = RRM_NULL;
    rrm_ue_index_t       ue_index = RRM_OUT_OF_RANGE_TWO_BYTE ;


    /* dont need to check the null pointer as this function 
       is called from ylFind and it null check is already there
       in for loop */
    p_ue_context = (rrm_ue_context_t* )((rrm_scell_node_t*)p_scell_node)->p_ue_context;


    if( RRM_NULL != p_ue_context )
    {
	    ue_index = p_ue_context->ue_index;
    }
    else
    {
	
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "ue context  null pointer retrived in rrm_scell_search_ue_by_ue_index()");
    }
    RRM_UT_TRACE_EXIT();

/* SPR 20636 Changes Start*/
    return ((void *) (U32_U32Long_Bit)ue_index) ;
/* SPR 20636 Changes End*/
    
}


/****************************************************************************
 * Function Name  : rrm_compare_scell_key_value  
 * Inputs         : p_seach_ue_index , p_match_ue  
 * Outputs        : 
 * Returns        : U8
 * Description    : compare function for scell list 
 ****************************************************************************/
int rrm_compare_scell_key_value( const void * p_seach_ue_index, const void * p_match_ue )
{

/* SPR 20636 Changes Start*/
    rrm_ue_index_t	search_ue = (rrm_ue_index_t)(U32_U32Long_Bit)p_seach_ue_index;
    rrm_ue_index_t	match_ue = (rrm_ue_index_t)(U32_U32Long_Bit)p_match_ue;
/* SPR 20636 Changes Start*/
    int                 ret_val = RRM_ONE ;


    if( ( RRM_OUT_OF_RANGE_TWO_BYTE != search_ue ) && ( RRM_OUT_OF_RANGE_TWO_BYTE != match_ue ) )
    {
        if( search_ue == match_ue )
        {
            ret_val = RRM_ZERO;
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "ue context  null pointer retrived in rrm_scell_search_ue_by_ue_index()");
    }

    return ret_val;
}


/****************************************************************************
 * Function Name  : rrm_add_ue_in_scell_list_of_cell  
 * Inputs         : pcell_index,scell_index,ue_context
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    : adding the ue as node in scell list 
 ****************************************************************************/
rrm_void_t rrm_add_ue_in_scell_list_of_cell( rrm_cell_index_t    pcell_index,
                                             rrm_cell_index_t    scell_index,
				             rrm_ue_context_t    *p_ue_context )
{

    YLIST                  	*p_scell_user_list = RRM_NULL;	
    rrm_scell_node_t            *p_scell_node = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_scell_user_list = rrm_get_scell_list_of_cell( pcell_index , 
					            scell_index );

    if( RRM_NULL != p_scell_user_list )
    {
        p_scell_node = (rrm_scell_node_t *)rrm_mem_get( sizeof(rrm_scell_node_t) );

        if( RRM_NULL != p_scell_node )
        {
            p_scell_node->p_ue_context = p_ue_context;

	    ylPushHead( p_scell_user_list ,&( p_scell_node->node ) );
        }
        else
        {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "Memory allocation failed for rrm_scell_node_t ");
        }
    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "scell ue list null pointer retrived for pcell index[%d], scell index[%d]",pcell_index,scell_index);
    }

    RRM_UT_TRACE_EXIT();	
	
}


/****************************************************************************
 * Function Name  :rrm_delete_ue_in_scell_list_of_cell
 * Inputs         : pcell_index , scell_index , p_ue_context
 * Outputs        :
 * Returns        : rrm_void_t
 * Description    : delete ue in scell list function
 ****************************************************************************/
rrm_void_t rrm_delete_ue_in_scell_list_of_cell (rrm_cell_index_t   pcell_index, 
                                                rrm_cell_index_t   scell_index,
                                                rrm_ue_context_t   *p_ue_context)
{
    YLIST                	*p_scell_user_list = RRM_NULL;
    rrm_scell_node_t            *p_scell_node = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_scell_user_list = rrm_get_scell_list_of_cell( pcell_index , 
					            scell_index );

    if( RRM_NULL != p_scell_user_list )
    {
       if( RRM_NULL != p_ue_context )
       {
           if(ylCount(p_scell_user_list))
           {
               /* SPR 20430 Changes Start  */
               p_scell_node = (rrm_scell_node_t *)ylFind( p_scell_user_list,
                                                          (void*)(U32Long)p_ue_context->ue_index,
                                                          rrm_scell_search_ue_by_ue_index,
                                                          rrm_compare_scell_key_value );
               /* SPR 20430 Changes End  */
               
               if( RRM_NULL != p_scell_node )
               {
	               ylDelete(  p_scell_user_list ,&(p_scell_node->node));
                   
                   RRM_MEM_FREE(p_scell_node);
      
               }
               else
               {
                   RRM_TRACE(g_uem_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
                   "Node pointer does not exist in list ");
		
               }
           }
           else
           {
               RRM_TRACE(g_uem_log_on_off, p_rrm_cellm_facility_name, RRM_WARNING,
               "UE count on scell list is zero,could not remove the ue from scell list");
           }
       }
       else
       {
            RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
            "ue context  null pointer passed into function");
       }	

    }
    else
    {
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
        "scell ue list null pointer retrived for pcell index[%d], scell index[%d]",pcell_index,scell_index);
    }

    RRM_UT_TRACE_EXIT();

}




/****************************************************************************
 * Function Name  : rrm_notify_ue_mgr_for_num_user_scell_deact 
 * Inputs         : pcell_index , scell_index , p_ue_context  
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    : delete ue in scell list function  
 ****************************************************************************/
rrm_void_t rrm_notify_ue_mgr_for_num_user_scell_deact( rrm_scell_deactivation_notification_t
                                                               *p_scell_deact )            
{

    rrm_return_et                                ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != p_scell_deact )
    {

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	"pcell_index [%d] can have some UE's those have added scell_index[%d]"
        "This scell have some CA related configuration is reconfigured",
        p_scell_deact->cell_index,p_scell_deact->scell_deact_user.cell_index );

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	"Sending notifation to UE Mgr");
	
	ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
					 RRMUEM_CM_SCELL_DEACT_ON_LOAD ,
					 sizeof( rrm_scell_deactivation_notification_t ),
					 (void *)( p_scell_deact ));

        if( RRM_SUCCESS == ret_val )
        {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	    "Successfully send notifation to UE Mgr");
        }
        else
        {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	    "Failed to send notifation to UE Mgr");
        }

    }
    else
    {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
	"null pointer error in  cells notification object");
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_notify_to_ue_mgr_about_cell_change
 * Inputs         : pcell_index , scell_index , p_ue_context  
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    : delete ue in scell list function  
 ****************************************************************************/
rrm_void_t rrm_notify_to_ue_mgr_about_cell_change(rrm_cell_change_notification_object_t  
                                                              *cell_chnage_notify_obj )
{

    rrm_return_et                                ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != cell_chnage_notify_obj )
    {

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	"pcell_index [%d] can have some UE's those have added scell_index[%d] "
        "This scell have some CA related configuration is reconfigured "
        "Sending notifation to UE Mgr",
        cell_chnage_notify_obj->cell_index,cell_chnage_notify_obj->cell_broadcast_ca_info.cell_index );

	
	ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
					 RRMUEM_CM_CELL_INFO_CHNANGE_IND ,
					 sizeof( rrm_cell_change_notification_object_t ),
					 (void *)( cell_chnage_notify_obj ));

        if( RRM_FAILURE == ret_val )
        {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	    "Failed to send notifation to UE Mgr");
        }

    }
    else
    {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
	"null pointer error in  cells notification object");
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_cell_have_scell_ue   
 * Inputs         : p_ue_context  
 * Outputs        : 
 * Returns        : rrm_bool_et
 * Description    :   
 ****************************************************************************/
rrm_bool_et
rrm_cell_have_scell_ue( rrm_cell_context_t   *p_cell_context )
{

    U8           index = RRM_ZERO;
    rrm_bool_et  scell_ue = RRM_FALSE;   

    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != p_cell_context )
    {
        for( index = RRM_ZERO; index < RRM_MAX_NUM_CELLS ; index++ )
        {
            if( ylCount( &(p_cell_context->scell_info[index].list) ))
            {
                scell_ue = RRM_TRUE;
	        break;
            }
        }
    }

    RRM_UT_TRACE_EXIT();

    return scell_ue;
}


/****************************************************************************
 * Function Name  : rrm_cell_changed_from_CA_to_NON_CA  
 * Inputs         : pcell_index , scell_index , p_ue_context  
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    :   
 ****************************************************************************/
rrm_void_t
rrm_cell_changed_from_CA_to_NON_CA( rrm_cell_index_t  cell_index, U16 trans_id)
{

    rrm_cell_info_transfer_object   cell_info = { RRM_ZERO};
    rrm_return_et                   ret_val;

    RRM_UT_TRACE_ENTER();

    cell_info.cell_index = cell_index;
    /*SPR 13316:start*/
    cell_info.trans_id = trans_id;
    /*SPR 13316:end*/

    ret_val = rrm_send_internal_msg((U16)RRM_UEM_MODULE_ID,
				     RRMUEM_CM_SCELL_DEACT_ON_CA_TO_NON_CA ,
				     sizeof( rrm_cell_info_transfer_object),
				     (void *)(&cell_info ));

    if( RRM_FAILURE == ret_val )
    {
	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
	"Failed to send notifation to UE Mgr");
    }

    RRM_UT_TRACE_EXIT();

}


/****************************************************************************
 * Function Name  : rrm_get_all_cells_context_at_eNB 
 * Inputs         : pcell_index , scell_index , p_ue_context  
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    : delete ue in scell list function  
 ****************************************************************************/
/* + SPR 17439 */
rrm_cell_context_t** rrm_get_all_cells_context_at_eNB(void)
/* - SPR 17439 */
{

    rrm_cell_context_t  **p_all_cell_ctxt =  RRM_NULL ;
    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != p_g_rrm_cell_ctx )
    {
        p_all_cell_ctxt = p_g_rrm_cell_ctx->p_rrm_cell_ctx; 
    }

    RRM_UT_TRACE_EXIT();

    return p_all_cell_ctxt;
}



/****************************************************************************
 * Function Name  : rrm_cell_have_locally_cell_in_same_eNB  
 * Inputs         : rrm_cell_context_t   
 * Outputs        : 
 * Returns        : rrm_bool_et
 * Description    :   
 ****************************************************************************/
rrm_bool_et
rrm_cell_have_locally_cell_in_same_eNB(    rrm_cell_context_t   *p_cell_context,
                                           rrm_cell_index_t     cell_index)
{

    rrm_bool_et         locally_cell_available = RRM_FALSE;
    lte_ncl_t           *p_lte_ncl = RRM_NULL;
    U8                  index = RRM_ZERO;
    /*Cell context of cell whose neighbour is x2_locally_connected with others*/
    rrm_cell_context_t *p_cell_ctxt_for_x2_status_chk = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_cell_ctxt_for_x2_status_chk = rrm_cellm_get_cell_context(cell_index);
    if(RRM_PNULL != p_cell_ctxt_for_x2_status_chk)
    {
        if( ( RRMCM_RMIF_NCL_PARAMS_PRESENT & p_cell_ctxt_for_x2_status_chk->ran_info.bitmask )&&
                ( RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctxt_for_x2_status_chk->ran_info.ncl_params.bitmask ) )
        {
            p_lte_ncl = &(p_cell_ctxt_for_x2_status_chk->ran_info.ncl_params.lte_ncl);
            
            for( index = RRM_ZERO; index < p_lte_ncl->num_valid_intra_freq_cell; index++ )
            {
                if( X2_LOCALLY_CONNECTED_CELL == p_lte_ncl->intra_freq_cells[index].x2_status )
                {
                    if (RRM_SUCCESS == compare_global_cell_id (
                                (rrm_oam_eutran_global_cell_id_t *)&(p_cell_context->global_cell_id), 
                                (rrm_oam_eutran_global_cell_id_t *)&(p_lte_ncl->intra_freq_cells[index].cell_id)))
                    {
                        locally_cell_available = RRM_TRUE;

                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                "Cell index [%d] have locally connected cell at same eNB",p_cell_context->cell_index );

                        break;
                    }
                }    
            }

            if( RRM_FALSE == locally_cell_available )
                for( index = RRM_ZERO; index < p_lte_ncl->num_valid_inter_freq_cell ; index++ )
                {
                    if( X2_LOCALLY_CONNECTED_CELL == p_lte_ncl->inter_freq_cells[index].x2_status )
                    {
                        if (RRM_SUCCESS == compare_global_cell_id (
                                    (rrm_oam_eutran_global_cell_id_t *)&(p_cell_context->global_cell_id), 
                                    (rrm_oam_eutran_global_cell_id_t *)&(p_lte_ncl->inter_freq_cells[index].cell_id)))
                        {
                            locally_cell_available = RRM_TRUE;

                            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Cell index [%d] have locally connected cell at same eNB",p_cell_context->cell_index );

                            break;
                        }
                    }    
                }
        }
    }
    RRM_UT_TRACE_EXIT();

    return locally_cell_available;
}

/****************************************************************************
 * Function Name  : rrm_broadcast_resource_update_info_at_eNB  
 * Inputs         : p_timer_buf   
 * Outputs        : 
 * Returns        : rrm_return_et
 * Description    :   
 ****************************************************************************/
rrm_void_t
rrm_broadcast_resource_update_info_at_eNB( const cell_timer_buf_t   *p_timer_buf )
{
    rrm_cell_rsu_load_update_info_t       rsu_report_info = { RRM_ZERO };
    rrm_cell_context_t                  **p_enb_cell_ctxt = RRM_NULL;
    rrm_cell_context_t                   *p_cell_context = RRM_NULL;
    U16                                   cell_count_index = RRM_ZERO;
    rrm_return_et                         ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if( RRM_NULL != p_timer_buf )
    {
        /* This fucntion get the all cell context at eNB */
        p_enb_cell_ctxt = rrm_get_all_cells_context_at_eNB();

        if( RRM_NULL != p_enb_cell_ctxt )
        {
            /* function fill the resource load info */
            rrm_fill_report_resource_update_info_at_same_enodeB_cells( p_timer_buf->cell_index , 
                    &rsu_report_info );

            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                    "Cell Id[%d]",p_timer_buf->cell_index);
            for( cell_count_index = RRM_ZERO; 
                    cell_count_index < RRM_MAX_NUM_CELLS ; cell_count_index++  )
            {
                /* get the one by one cell context from cell context pool */
                p_cell_context = p_enb_cell_ctxt[cell_count_index];

                if( RRM_NULL != p_cell_context )
                {
                    /* RRM will send the load info to each cell at current working eNB
                       except to itself*/
                    if( p_timer_buf->cell_index != p_cell_context->cell_index )
                    {

                        if( RRM_TRUE == rrm_cell_have_locally_cell_in_same_eNB(p_cell_context, p_timer_buf->cell_index))
                        {
                            /* assign the one by one destination cell index */
                            rsu_report_info.cell_index = p_cell_context->cell_index;

                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Sending load boadcasting info of cell index [%d] to cell index [%d]",
                                    p_timer_buf->cell_index, p_cell_context->cell_index );

                            ret_val = rrm_send_internal_msg((U16)RRM_CM_MODULE_ID,
                                    RRM_CELL_LOAD_MULTICAST_INFO_IND ,
                                    sizeof(rrm_cell_rsu_load_update_info_t ),
                                    (void *)(&rsu_report_info ));
                            if( RRM_SUCCESS ==  ret_val )
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED ,
                                        "Succesfully sent load boadcasting info of cell index [%d] to cell index [%d]",
                                        p_timer_buf->cell_index, p_cell_context->cell_index);
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "Failed to Send load boadcasting info of cell index [%d] to cell index [%d]",
                                        p_timer_buf->cell_index, p_cell_context->cell_index);
                            }
                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED ,
                                    "Cell index [%d] dont have locally connected cell", p_cell_context->cell_index );
                        }
                    }   
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            " NULL pointer retrived for cell context");
                }
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "NULL pointer reterived to get all cell context at eNB ");
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
                "NULL pointer reterived to get timer info ");
    }

    RRM_UT_TRACE_EXIT();

}



/****************************************************************************
 * Function Name  : rrm_process_carrier_agg_boradcasted_info   
 * Inputs         : p_timer_buf   
 * Outputs        : 
 * Returns        : rrm_return_et
 * Description    :   
 ****************************************************************************/
rrm_return_et
rrm_process_carrier_agg_boradcasted_info( rrm_void_t    *p_api,
            /*SPR 17777 +-*/
                                          U16            data_len )
{
    rrm_cell_change_notification_object_t      ca_config_info = { RRM_ZERO };
    rrm_cell_change_notification_object_t      *temp_api = (rrm_cell_change_notification_object_t *)p_api;

    RRM_UT_TRACE_ENTER();
    
    if( data_len < sizeof( rrm_cell_change_notification_object_t ) )
    {
        /* invalid message ignore*/
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
        "Failed to receive the cells ca related broadcasted info due to data length error");
    }
    else /* process the message */
    {
        SET_CELL_INDEX(temp_api->cell_index);
        RRM_TRACE(g_uem_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED ,
        "carrier aggregation broadcasted message is received for cell index [%d]",temp_api->cell_index);

        ca_config_info.cell_index = temp_api->cell_index;
        ca_config_info.cell_broadcast_ca_info = temp_api->cell_broadcast_ca_info;
        /*SPR 13316:start*/
        ca_config_info.trans_id = temp_api->trans_id;
        /*SPR 13316:end*/

        /* start notify to ue mgr for changed cells ca config info to current cell */

        rrm_notify_to_ue_mgr_about_cell_change( &ca_config_info );
    }

    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}




/******************************************************************************
 * Function Name  : rrm_broadcast_carrier_agg_configuration_change_event_at_eNB   
 * Inputs         : p_timer_buf   
 * Outputs        : 
 * Returns        : rrm_return_et
 * Description    :   
 ******************************************************************************/
rrm_void_t
rrm_broadcast_carrier_agg_configuration_change_event_at_eNB( rrm_cell_index_t  cell_index,
                                                             U64               ca_config_bitmap, 
                                                             U16               trans_id)
{

    rrm_cell_context_t                         **p_enb_cell_ctxt = RRM_NULL;
    rrm_cell_context_t                          *p_cell_context = RRM_NULL;
    U16                                          cell_count_index = RRM_ZERO;
    rrm_return_et                                ret_val = RRM_SUCCESS;
    rrm_cell_change_notification_object_t        cell_broadcast_info = { RRM_ZERO };  

    RRM_UT_TRACE_ENTER();
    
    /* get the all cells context at eNB */
    p_enb_cell_ctxt = rrm_get_all_cells_context_at_eNB();

    if( RRM_NULL != p_enb_cell_ctxt )
    {
	 for( cell_count_index = RRM_ZERO; 
		      cell_count_index < RRM_MAX_NUM_CELLS ; cell_count_index++  )
	 {
             /* get the one by one cell context from cell context pool */
	     p_cell_context = p_enb_cell_ctxt[cell_count_index];

	     if( RRM_NULL != p_cell_context )
         {
             /* SPR 21251 +- */
             if( p_cell_context->cell_index != cell_index )
             { 
                 /* assign the destination cell index to message */
                 cell_broadcast_info.cell_index = p_cell_context->cell_index;

                 /* assign the cell index whose info is being broadcast*/
                 cell_broadcast_info.cell_broadcast_ca_info.cell_index = cell_index;
                 cell_broadcast_info.cell_broadcast_ca_info.ca_config_bitmask = ca_config_bitmap ;
                 /*SPR 13316:start*/
                 cell_broadcast_info.trans_id  = trans_id;
                 /*SPR 13316:end*/

                 ret_val = rrm_send_internal_msg((U16)RRM_CM_MODULE_ID,
                         RRM_CELL_CA_CONFIG_CHANGE_MULTICAST_INFO_IND ,
                         sizeof( rrm_cell_change_notification_object_t ),
                         (void *)(&cell_broadcast_info ));
                 if( RRM_SUCCESS ==  ret_val )
                 {
                     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF ,
                             "Succesfully sent ca related changed boadcasting info of cell index [%d] to cell index [%d]",
                             cell_index ,p_cell_context->cell_index );
                 }
                 else
                 {
                     RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR ,
                             "Could not sent ca related changed boadcasting info of cell index [%d] to cell index [%d]",
                             cell_index ,p_cell_context->cell_index );
                 }
             }
         }
	     else
	     {
             /* BUG_11648_FIX_START */
	         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	         "Cell context not present at position [%d] in Global Context",cell_count_index);
             /* BUG_11648_FIX_START */
	     }
	 }
     if (RRM_PNULL !=  p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
     {
          p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_modify_notification_obj.is_cell_changed = RRM_FALSE;
          p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->cell_modify_notification_obj.cell_transfer_obj.ca_config_bitmask = RRM_ZERO;
     }

     }
     else
     {
         RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	 "NULL pointer reterived to get all cell context at eNB ");
     }

    RRM_UT_TRACE_EXIT();

}

/*klock_works_changes_start*/
rrm_void_t
rrm_fill_hw_load_info_and_comp_avl_cap_info
(
rrm_cell_context_t              *p_cell_ctxt,
rrm_cell_rsu_load_update_info_t *p_rsu_report_info
)
{  
    RRM_UT_TRACE_ENTER();

    if (RRM_HW_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
	{
		p_rsu_report_info->rsu_load_info.rsu_info.bitmask |= RRM_BROADCAST_HW_LOAD_PERIODIC_REPORT_PRESENT ;

		p_rsu_report_info->rsu_load_info.rsu_info.hw_load.dl =
                                                          p_cell_ctxt->svr_cell_load_info.hw_ld_lvl;

		p_rsu_report_info->rsu_load_info.rsu_info.hw_load.ul =
                                                          p_cell_ctxt->svr_cell_load_info.hw_ld_lvl;
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	                    "rsu_info.hw_load.dl [%d] rsu_info.hw_load.ul [%d]",
                        p_rsu_report_info->rsu_load_info.rsu_info.hw_load.dl,
                        p_rsu_report_info->rsu_load_info.rsu_info.hw_load.ul);

	}

	if (RRM_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT &  p_cell_ctxt->svr_cell_load_info.bitmask)
	{
		p_rsu_report_info->rsu_load_info.rsu_info.bitmask |= RRM_BROADCAST_COMP_AVL_CAP_PERIODIC_REPORT_PRESENT ;

		p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.dl.bitmask = RRM_ZERO;


		if (RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT &  p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.bitmask)
		{
			p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
                        dl.bitmask |= CELL_CAPACITY_CLASS_VALUE_PRESENT;


			p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
                        dl.cell_cap_class_val =
			p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_class_val;

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	                "dl.cell_cap_class_val [%d]",p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
                                                     dl.cell_cap_class_val );

		}
		p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.dl.cell_cap_val =
		p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.dl.cell_cap_val;

                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
	        "comp_avl_cap_grp.dl.cell_cap_val [%d]",p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.dl.cell_cap_val );

		if(RRM_CELL_CAPACITY_CLASS_VALUE_PRESENT & p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.bitmask)
		{
			p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
                        ul.bitmask |= CELL_CAPACITY_CLASS_VALUE_PRESENT;

			p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
                        ul.cell_cap_class_val =
			p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_class_val;

                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "comp_avl_cap_grp.ul.cell_cap_class_val [%d]",
                                p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.ul.cell_cap_class_val );

        }

        p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.
            ul.cell_cap_val =
            p_cell_ctxt->svr_cell_load_info.comp_avl_cap_grp.ul.cell_cap_val;

        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "comp_avl_cap_grp.ul.cell_cap_val [%d]",
                p_rsu_report_info->rsu_load_info.rsu_info.comp_avl_cap_grp.ul.cell_cap_val );
    }
    RRM_UT_TRACE_EXIT();   
}    
/*klock_works_changes_end*/ 

/****************************************************************************
 * Function Name  : rrm_fill_report_resource_update_info_at_same_enodeB_cells 
 * Inputs         : cell_index , p_rsu_report_info  
 * Outputs        : 
 * Returns        : rrm_void_t
 * Description    :
 ****************************************************************************/
rrm_void_t
rrm_fill_report_resource_update_info_at_same_enodeB_cells( rrm_cell_index_t    cell_index,
        rrm_cell_rsu_load_update_info_t 
        *p_rsu_report_info )
{

    rrm_cell_context_t                  *p_cell_ctxt = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    p_cell_ctxt = rrm_cellm_get_cell_context( cell_index );

    if( RRM_NULL != p_cell_ctxt  )
    {
        /* copy the global cell id */
        rrm_memcpy_rrm_global_cell_id( (rrm_global_cell_id_t*)(&(p_rsu_report_info->rsu_load_info.cell_id)),
                &(p_cell_ctxt->global_cell_id) );

        if (RRM_RR_LOAD_PERIODIC_REPORT_PRESENT & p_cell_ctxt->svr_cell_load_info.bitmask)
        {
            p_rsu_report_info->rsu_load_info.rsu_info.bitmask |=  RRM_BROADCAST_RR_LOAD_PERIODIC_REPORT_PRESENT ;
            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_gbr_prb_usage  = 
                p_cell_ctxt->svr_cell_load_info.rr_load.dl_gbr_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.dl_gbr_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_gbr_prb_usage);

            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_gbr_prb_usage = 
                p_cell_ctxt->svr_cell_load_info.rr_load.ul_gbr_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.ul_gbr_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_gbr_prb_usage);

            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_non_gbr_prb_usage = 
                p_cell_ctxt->svr_cell_load_info.rr_load.dl_non_gbr_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.dl_non_gbr_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_non_gbr_prb_usage );

            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_non_gbr_prb_usage = 
                p_cell_ctxt->svr_cell_load_info.rr_load.ul_non_gbr_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.ul_non_gbr_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_non_gbr_prb_usage );

            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_total_prb_usage = 
                p_cell_ctxt->svr_cell_load_info.rr_load.dl_total_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.dl_total_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.dl_total_prb_usage );

            p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_total_prb_usage = 
                p_cell_ctxt->svr_cell_load_info.rr_load.ul_total_prb_usage;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    "rr_load.ul_total_prb_usage [%d]", p_rsu_report_info->rsu_load_info.rsu_info.rr_load.ul_total_prb_usage );

        }

        if (RRM_TNL_LOAD_PERIODIC_REPORT_PRESENT &  p_cell_ctxt->svr_cell_load_info.bitmask)
        {
            p_rsu_report_info->rsu_load_info.rsu_info.bitmask |= RRM_BROADCAST_TNL_LOAD_PERIODIC_REPORT_PRESENT ;

            p_rsu_report_info->rsu_load_info.rsu_info.s1_tnl_load.dl  =
                p_cell_ctxt->svr_cell_load_info.tnl_ld_lvl;

            p_rsu_report_info->rsu_load_info.rsu_info.s1_tnl_load.ul = 
                p_cell_ctxt->svr_cell_load_info.tnl_ld_lvl;

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    " rsu_info.s1_tnl_load.dl [%d]", p_rsu_report_info->rsu_load_info.rsu_info.s1_tnl_load.dl );

            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                    " rsu_info.s1_tnl_load.ul [%d]", p_rsu_report_info->rsu_load_info.rsu_info.s1_tnl_load.ul );

        }

        /*klock_works_changes_start*/	
        rrm_fill_hw_load_info_and_comp_avl_cap_info(p_cell_ctxt, p_rsu_report_info); 
        /*klock_works_changes_end*/
    }

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_parse_cell_broadcasted_resource_load_msg  
 * Inputs         : p_api , api_id , data_len   
 * Outputs        : 
 * Returns        : rrm_return_et 
 * Description    :
 ****************************************************************************/
rrm_return_et
rrm_parse_cell_broadcasted_resource_load_msg( rrm_void_t    *p_api,
            /*SPR 17777 +-*/
                                              U16            data_len )
{

    rrm_cell_rsu_load_update_info_t    rsu_info = { RRM_ZERO };
    rrm_cell_rsu_load_update_info_t    *temp_api = (rrm_cell_rsu_load_update_info_t *)p_api;
    rrm_cell_context_t                 *p_cell_context = RRM_NULL;
    lte_ncl_t                           *p_lte_ncl = RRM_NULL;
    rrm_eutran_cell_types_et            cell_type = RRM_EUTRAN_INVALID_FREQ_CELL;
    U16                                 nbr_cell_idx = RRM_ZERO;
    rrm_return_et                       ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    
    if( data_len < sizeof( rrm_cell_rsu_load_update_info_t ) )
    {
        /* invalid message ignore*/
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR ,
        "Failed to receive the cells rsu load broadcasted info due to data length error");

        ret_val = RRM_FAILURE;
    }
    else /* process the message */
    {
        SET_CELL_INDEX(temp_api->cell_index);

        rsu_info.cell_index = temp_api->cell_index;
        rsu_info.rsu_load_info = temp_api->rsu_load_info;
        p_cell_context = rrm_cellm_get_cell_context( rsu_info.cell_index );

        if( RRM_NULL != p_cell_context )
        {
             p_lte_ncl = &(p_cell_context->ran_info.ncl_params.lte_ncl);
 
  	     rrm_get_eutran_cell_type_for_global_cell_id ( &(rsu_info.rsu_load_info.cell_id),
                                                           p_cell_context, 
							   &cell_type, 
							   &nbr_cell_idx );

             if (RRM_EUTRAN_INTRA_FREQ_CELL == cell_type) /* EUTRAN Intra cell neighbor */
             {
                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.bitmask |= 
                 rsu_info.rsu_load_info.rsu_info.bitmask;
                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.rr_load = 
                 rsu_info.rsu_load_info.rsu_info.rr_load;
                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.s1_tnl_load = 
                 rsu_info.rsu_load_info.rsu_info.s1_tnl_load ;
                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.hw_load = 
                 rsu_info.rsu_load_info.rsu_info.hw_load ;
                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.comp_avl_cap_grp = 
                 rsu_info.rsu_load_info.rsu_info.comp_avl_cap_grp ;

                 p_lte_ncl->intra_freq_cells[nbr_cell_idx].resrc_report.is_reported = RRM_FALSE;
             }
             else if( RRM_EUTRAN_INTER_FREQ_CELL == cell_type )/* EUTRAN Inter Cell neighbor */
             {
                 p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.bitmask |= 
                 rsu_info.rsu_load_info.rsu_info.bitmask;
                 p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.rr_load = 
                 rsu_info.rsu_load_info.rsu_info.rr_load ;
                 p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.s1_tnl_load = 
                 rsu_info.rsu_load_info.rsu_info.s1_tnl_load ;
                 p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.hw_load = 
                 rsu_info.rsu_load_info.rsu_info.hw_load ;
                 p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.comp_avl_cap_grp = 
                 rsu_info.rsu_load_info.rsu_info.comp_avl_cap_grp ;
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                                    "Cell Id[%d] load report of ncl dl[%d] ul[%d]",temp_api->cell_index, 
                p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.comp_avl_cap_grp.dl.cell_cap_val,
                p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.comp_avl_cap_grp.ul.cell_cap_val);
                p_lte_ncl->inter_freq_cells[nbr_cell_idx].resrc_report.is_reported = RRM_FALSE;
             }
             else
             {
                 /* SPR 21251 Start */
	            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	            "Wrong cell type %d retrived from rrm_get_eutran_cell_type_for_global_cell_id()", cell_type);
                /* SPR 21251 End */
             }
        }
        else
        {
	    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
	    "NULL pointer retrived for cell context");

             ret_val = RRM_FAILURE;
        }

    }

    RRM_UT_TRACE_EXIT();

    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_process_cellm_message  
 * Inputs         : p_api , p_rrm_gb_ctx/   
 * Outputs        : 
 * Returns        : rrm_return_et 
 * Description    :
 ****************************************************************************/
rrm_return_et
rrm_process_cellm_message( void                    *p_api/*pointer to input API buffer*/)
            /*SPR 17777 +-*/
{
    void                  *p_data      = RRM_PNULL;
    U16                    data_length = RRM_ZERO;
    U16	                   api_id    = RRM_ZERO;
    U16	                   msg_size  = RRM_ZERO;
    rrm_return_et          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    api_id = rrm_get_api_id(p_api);
    msg_size = rrm_get_word_from_header((U8*)(p_api) + RRM_MSG_SIZE_INDEX/*8*/);

    /* removing CSPL header
     */
    p_data   = p_api + RRM_API_HEADER_SIZE;  
    /*extracting message size
     */
    data_length = msg_size - RRM_API_HEADER_SIZE;         

    switch( api_id )
    {
        case RRM_CELL_LOAD_MULTICAST_INFO_IND:
        {
            /*SPR 17777 +-*/
            ret_val = rrm_parse_cell_broadcasted_resource_load_msg( p_data ,data_length);

            if( RRM_FAILURE != ret_val )
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
		                "CellM->CellM:RRM_CELL_LOAD_MULTICAST_INFO_IND successfully processed");
            }
            break;
        }
        case RRM_CELL_CA_CONFIG_CHANGE_MULTICAST_INFO_IND:
        {
            ret_val = rrm_process_carrier_agg_boradcasted_info( p_data ,data_length );

            if( RRM_FAILURE != ret_val )
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
		                "CellM->CellM:RRM_CELL_CA_CONFIG_CHANGE_MULTICAST_INFO_IND successfully processed");
            }
            break;
        }
        /* Carrier_Aggregation_Start */
	case RRMCM_CELL_LOAD_ACTN_SCELL_DEACT_IND:
        /*Coverity 82917 Fix Start*/
	    ret_val  = rrm_load_actn_scell_deact_ind_process_msg( p_data);
            /*SPR 17777 +-*/
        if( RRM_FAILURE != ret_val )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
		            "CellM->CellM:RRMCM_CELL_LOAD_ACTN_SCELL_DEACT_IND successfully processed");
        }
        /*Coverity 82917 Fix End*/
	    break;
        /* Carrier_Aggregation_End */
       default:
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR, "unexpected api %d ",api_id);
            break;
        }
    }
   
    RRM_UT_TRACE_EXIT();

    return RRM_SUCCESS;
}
/* Carrier Aggregation end */ 
/* Carrier_Aggregation_Start */
/*Klockwork_fix_start*/
/****************************************************************************
 * Function Name  : rrm_cellm_chk_and_change_x2_status_inter_freq
 * Inputs         : *lte_ncl
 * Outputs        : x2_status
 * Returns        : VOID
 * Description    : This function is used to update the x2_status value as
 *                : locally connected if the neighbour value reported by
 *                : OAM is allowed and the cell is present on the same eNodeB.
 ****************************************************************************/
rrm_bool_et
rrm_cellm_chk_and_change_x2_status_inter_freq(lte_ncl_t           *p_lte_ncl ,
                                              rrm_cell_context_t  *p_cell_ctx ,
                                              rrm_cell_context_t  *p_ngbr_cell_ctx ,
                                              U8                   cell_count)
{
    U8 ncl_index                        = RRM_ZERO;
    rrm_bool_et         locally_cell_available = RRM_FALSE;
    U8 ngbr_cell_count                  = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for(ncl_index = RRM_ZERO; ((ncl_index < p_lte_ncl->num_valid_inter_freq_cell) &&
                (ncl_index < MAX_INTER_FREQ_CELLS)); ncl_index++)
    {
        for (ngbr_cell_count = RRM_ZERO; ngbr_cell_count < RRM_MAX_NUM_CELLS; ngbr_cell_count++)
        {
            if (cell_count != ngbr_cell_count)
            {
                if ( RRM_PNULL != (p_ngbr_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[ngbr_cell_count]))
                {
                    if (!RRM_MEMCMP(&p_lte_ncl->inter_freq_cells[ncl_index].cell_id,
                                &p_ngbr_cell_ctx->global_cell_id, sizeof(rrm_global_cell_id_t)))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                "Global Cell ids matched for local cell with cell index: %d",
                                p_cell_ctx->cell_index);
                        locally_cell_available = RRM_TRUE;
                        if((X2_ALLOWED == p_lte_ncl->inter_freq_cells[ncl_index].x2_status) ||
                                (X2_ALLOWED_CONNECTED == p_lte_ncl->inter_freq_cells[ncl_index].x2_status))
                        {
                            p_lte_ncl->inter_freq_cells[ncl_index].x2_status = X2_LOCALLY_CONNECTED_CELL;
                        }
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return locally_cell_available ;
}

/*Klockwork_fix_end*/

/****************************************************************************
 * Function Name  : rrm_cellm_chk_and_change_x2_status
 * Inputs         : *lte_ncl 
 * Outputs        : x2_status
 * Returns        : VOID
 * Description    : This function is used to update the x2_status value as 
 *                : locally connected if the neighbour value reported by 
 *                : OAM is allowed and the cell is present on the same eNodeB. 
 ****************************************************************************/
/* + SPR 17439 */
rrm_void_t
rrm_cellm_chk_and_change_x2_status(void)
/* - SPR 17439 */
{
    /* SPR 10779, 10782 start */
    U8 ncl_index                        = RRM_ZERO;
    U8 cell_count                       = RRM_ZERO;
    rrm_cell_context_t *p_cell_ctx      = RRM_PNULL;
    lte_ncl_t           *p_lte_ncl      = RRM_PNULL;
    U8 ngbr_cell_count                  = RRM_ZERO;
    rrm_cell_context_t *p_ngbr_cell_ctx = RRM_PNULL;
    rrm_bool_et         locally_cell_available = RRM_FALSE;

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_g_rrm_cell_ctx);
    for (cell_count = RRM_ZERO; cell_count < RRM_MAX_NUM_CELLS; cell_count++)
    {
        if ( RRM_PNULL != (p_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_count]))
        {
            if ((RRMCM_RMIF_NCL_PARAMS_PRESENT & p_cell_ctx->ran_info.bitmask) &&
                    (RRMCM_RMIF_LTE_NCL_PRESENT & p_cell_ctx->ran_info.ncl_params.bitmask))
            {
                p_lte_ncl = &p_cell_ctx->ran_info.ncl_params.lte_ncl;

                /*Klockwork_fix_start*/
                locally_cell_available = rrm_cellm_chk_and_change_x2_status_inter_freq(p_lte_ncl ,
                                                         p_cell_ctx ,p_ngbr_cell_ctx ,cell_count);
                /*Klockwork_fix_end*/
                if(locally_cell_available == RRM_FALSE)
                {
                    for(ncl_index = RRM_ZERO; ((ncl_index < p_lte_ncl->num_valid_intra_freq_cell) &&
                                (ncl_index < MAX_INTRA_FREQ_CELLS)); ncl_index++)
                    {
                        for (ngbr_cell_count = RRM_ZERO; ngbr_cell_count < RRM_MAX_NUM_CELLS; ngbr_cell_count++)
                        {
                            if (cell_count != ngbr_cell_count)
                            {
                                if ( RRM_PNULL != (p_ngbr_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[ngbr_cell_count]))
                                {
                                    if (!RRM_MEMCMP(&p_lte_ncl->intra_freq_cells[ncl_index].cell_id,
                                                &p_ngbr_cell_ctx->global_cell_id, sizeof(rrm_global_cell_id_t)))
                                    {
                                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                                                "Global Cell ids matched for local cell with cell index: %d",
                                                p_cell_ctx->cell_index);
                                        if((X2_ALLOWED == p_lte_ncl->intra_freq_cells[ncl_index].x2_status) ||
                                                (X2_ALLOWED_CONNECTED == p_lte_ncl->intra_freq_cells[ncl_index].x2_status))
                                        {
                                            p_lte_ncl->intra_freq_cells[ncl_index].x2_status = X2_LOCALLY_CONNECTED_CELL;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    /* SPR 10779, 10782 end */
}
/* Carrier_Aggregation_End */

/* CA_Stage_3_Scell_TM_change: Start */
/******************************************************************************
 *   FUNCTION NAME: rrm_check_cqi_mode_config_aperiodic_on_scell 
 *   INPUT      : cell_index
 *   OUTPUT     : none
 *   DESCRIPTION: Returns TRUE if Aperiodic Mode is supported for the cell.
 *   RETURNS    :
 *               RRM_TRUE on Success
 *               RRM_FALSE on Failure
*******************************************************************************/
rrm_bool_et
rrm_check_cqi_mode_config_aperiodic_on_scell(rrm_cell_index_t cell_index)
{
    rrm_bool_et ret_val = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
    /* If RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED or RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED,
         then return TRUE else FALSE */
    if((p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.admission_control_info.ue_service_profile.
                            radio_res_config.physical_config_dedicated.cqi_reporting.
                            rrm_cqi_reporting_mode_configured == RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED) ||
       (p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->operator_info.admission_control_info.ue_service_profile.
                            radio_res_config.physical_config_dedicated.cqi_reporting.
                            rrm_cqi_reporting_mode_configured == RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED))
    {
        ret_val = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/******************************************************************************
 *   FUNCTION NAME: rrm_check_cqi_mode_config_aperiodic_on_scell 
 *   INPUT      : cell_index
 *   OUTPUT     : none
 *   DESCRIPTION: Returns TRUE if Aperiodic Mode is supported for the cell.
 *   RETURNS    :
 *               RRM_TRUE on Success
 *               RRM_FALSE on Failure
*******************************************************************************/
U8
rrm_cellm_get_scell_phy_pdsch_config_pa_for_ce_ue
(
 rrm_cell_index_t cell_index
 )
{
    RRM_UT_TRACE_ENTER();
    U8 scell_phy_pdsch_config_pa_ce_ue = RRM_ZERO;
    const rrm_cell_context_t* p_rrm_cell_ctx;
    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    scell_phy_pdsch_config_pa_ce_ue = p_rrm_cell_ctx->dynamic_icic_data.pdsch_config_params.
                                                                  pdsch_dedicated_config.pa_for_ce_ue;
    RRM_UT_TRACE_EXIT();
    return scell_phy_pdsch_config_pa_ce_ue;
}
/**************************************************************************
 * Function Name  : rrm_cellm_get_scell_antenna_port
 * Inputs         : cell_index
 * Outputs        : antenna_ports_count_number
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : return antenna_ports_count_number from antenna_info
 ****************************************************************************/
rrm_return_et 
rrm_cellm_get_scell_antenna_port
( 
 rrm_cell_index_t cell_index, 
 U8 *antenna_port
 )
{
	rrm_return_et ret_val = RRM_SUCCESS;
	antenna_ports_count_et antenna_enum; 

	antenna_enum = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->ran_info.antenna_info.antenna_ports_count_number ; 

	switch(antenna_enum)
	{
		case ANTENNA_PORTS_COUNT_AN1:
			*antenna_port = RRM_RRC_AN1;
			break;
		case ANTENNA_PORTS_COUNT_AN2:
			*antenna_port = RRM_RRC_AN2;
			break;
		case ANTENNA_PORTS_COUNT_AN4:
			*antenna_port = RRM_RRC_AN4;
			break;
		case ANTENNA_PORTS_COUNT_SPARE1:
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,"antenna port count spare1");
			break;
		default:
			RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,"antenna port not avail");
			ret_val = RRM_FAILURE;
	}

	return ret_val;
}

/*SPR 10329:start*/
/**************************************************************************
 * Function Name  : rrm_cellm_enb_config_update_ind
 * Inputs         : p_api,
 *                : api_id
 *                : data_len
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : processs enb_config_update_ind 
 ****************************************************************************/
rrm_return_et
rrm_cellm_enb_config_update_ind
(
 void *p_api/*pointer to api buffer*/
            /*SPR 17777 +-*/
 )
{
    rrm_return_et ret_val                                        = RRM_SUCCESS;
    rrmcm_rmif_enb_config_update_ind_t *p_enb_config_update_ind  = RRM_PNULL;
    U8    mme_id_add_count                                       = RRM_ZERO;
    U8    mme_id_del_count                                       = RRM_ZERO;
    rrm_enb_gu_group_id_node_t    *p_enb_id_node                 = RRM_PNULL; 
    rrm_gu_group_id_node_t    *p_gu_group_id_node                = RRM_PNULL;
    rrm_gu_group_id_list_t    *p_gu_group_id_list                = RRM_PNULL;
    rrm_enb_gu_group_id_list_t    *p_enb_gu_group_id_list                       = RRM_PNULL;
    p_enb_gu_group_id_list = &(p_g_rrm_cell_ctx->rrm_enb_gu_group_id_list);
    p_enb_config_update_ind = (rrmcm_rmif_enb_config_update_ind_t *)p_api;


    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_ENB_CONFIG_UPDATE_IND->CellM");

    if((ylCount(p_enb_gu_group_id_list) == RRM_ZERO))  
    {
        if((RRMCM_RMIF_GU_GROUP_ID_TO_ADD_LIST_PRESENT & p_enb_config_update_ind->bitmask))
        {
            p_enb_id_node  = add_enb_id_to_global_list(&(p_enb_config_update_ind->nbr_enb_id) );
            if(RRM_NULL != p_enb_id_node)
            {
                /*Updating the NCL Enb pointer*/

                updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);
                /*Adding gu group Id to the Enb List */
                for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_enb_config_update_ind->add_gu_id.num_gu_group_id) &&
                        (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                {
                    ret_val =  add_gu_group_id_to_global_list(
                            &(p_enb_config_update_ind->add_gu_id.\
                                gu_id_list[mme_id_add_count]), p_enb_id_node 
                            );
                    if(RRM_SUCCESS == ret_val)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Successfully added gu group id to the List");

                    }
                }

            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    " Requested to delete gu_group id for an eNb that does not exists");

        }

    }

    else
    {
        p_enb_id_node = search_enb_id_in_global_list(&(p_enb_config_update_ind->nbr_enb_id));
        if((RRM_PNULL == p_enb_id_node))
        { 
            /*10329_START*/
            if(p_enb_config_update_ind->delete_gu_id.num_gu_group_id && 
                    (p_enb_config_update_ind->bitmask & RRMCM_RMIF_GU_GROUP_ID_TO_DELETE_LIST_PRESENT ))
                /*10329_END*/
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        " Requested to delete gu_group id for an eNb that does not exists");
            }

            /*10329_START*/
            if ((p_enb_config_update_ind->add_gu_id.num_gu_group_id) && 
                    (p_enb_config_update_ind->bitmask & RRMCM_RMIF_GU_GROUP_ID_TO_ADD_LIST_PRESENT ))
                /*10329_END*/
            {
                p_enb_id_node = add_enb_id_to_global_list(&(p_enb_config_update_ind->nbr_enb_id) );
                /*Updating the NCL Enb pointer*/

                if(RRM_PNULL != p_enb_id_node)
                {
                    updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_FALSE);

                    for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_enb_config_update_ind->add_gu_id.num_gu_group_id) &&
                            (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                    {
                        ret_val =  add_gu_group_id_to_global_list(
                                &(p_enb_config_update_ind->add_gu_id.\
                                    gu_id_list[mme_id_add_count]), p_enb_id_node 
                                );
                        if(RRM_SUCCESS == ret_val)
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Successfully added gu group id to the List");

                        }
                    }

                }

            }

        }
        else
        {
            /*10329_START*/
            if(p_enb_config_update_ind->bitmask & RRMCM_RMIF_GU_GROUP_ID_TO_DELETE_LIST_PRESENT )
            {
                for(mme_id_del_count = RRM_ZERO; mme_id_del_count < p_enb_config_update_ind->delete_gu_id.num_gu_group_id 
                        ; mme_id_del_count++ )
                    /*10329_END*/
                {
                    if(RRM_NULL != p_enb_id_node)
                    {
                        p_gu_group_id_node = search_gu_group_id_from_list(
                                &(p_enb_config_update_ind->delete_gu_id.gu_id_list[mme_id_del_count]),
                                p_enb_id_node
                                );
                        if(RRM_PNULL != p_gu_group_id_node )
                        {
                            /*10329_START*/
                            p_gu_group_id_list = &(p_enb_id_node->gu_group_id_list);
                            ylDelete(p_gu_group_id_list, &p_gu_group_id_node->s_node);
                            RRM_MEM_FREE(p_gu_group_id_node);
                            if(RRM_NULL != p_enb_id_node && ((ylCount(p_gu_group_id_list)) == RRM_ZERO))
                            {
                                /*Updating the NCL Enb pointer*/
                                updating_enb_id_node_in_ncl_info(p_enb_id_node,RRM_TRUE);
                                ylDelete(p_enb_gu_group_id_list, &p_enb_id_node->s_node);
                                RRM_MEM_FREE(p_enb_id_node);
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "eNb ID send for deletion is not exist");
                            }
                            /*10329_END*/
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                " Requested to delete gu_group id for an eNb that does not exists");
                    }

                }

            }
            /*10329_START*/
            if(p_enb_config_update_ind->bitmask & RRMCM_RMIF_GU_GROUP_ID_TO_ADD_LIST_PRESENT )
                /*10329_END*/
            {
                for(mme_id_add_count = RRM_ZERO; (mme_id_add_count < p_enb_config_update_ind->add_gu_id.num_gu_group_id) &&
                        (mme_id_add_count < RRM_MME_MAX_POOLS) ; mme_id_add_count++)
                {
                    /*search gu_group_id and if found returns the node */
                    p_gu_group_id_node = search_gu_group_id_from_list
                        (
                         /*10329_START*/
                         &(p_enb_config_update_ind->add_gu_id.gu_id_list[mme_id_add_count]),
                         /*10329_END*/
                         p_enb_id_node
                        );
                    if(RRM_PNULL != p_gu_group_id_node)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                "FAILURE:Request to add gu_group_id that has been already present in the list");

                    }
                    else
                    {
                        /*SPR 10329:fix start*/
                        p_gu_group_id_list = &(p_enb_id_node->gu_group_id_list); 
                        /*SPR 10329:fix end */
                        if(ylCount(p_gu_group_id_list) < RRM_MME_MAX_POOLS )
                        {
                            ret_val =  add_gu_group_id_to_global_list
                                (
                                 &(p_enb_config_update_ind->add_gu_id.\
                                     gu_id_list[mme_id_add_count]), p_enb_id_node 
                                );
                            if(RRM_SUCCESS == ret_val)
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Successfully added gu group id to the List");

                            }

                        }
                        else
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                    " Maximum limit[%d] for gu_group_id reached ",RRM_MME_MAX_POOLS ); 

                        }
                    }
                }
            }
        }
    }
    RRM_UT_TRACE_ENTER();
    return ret_val; 
}
/*SPR 10329:end*/

/* Spr 16142 Fix Start */
/**************************************************************************
 * Function Name  : rrm_cellm_handle_stop_tnl_discovery_ind
 * Inputs         : p_api,
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : Handles tnl Stop Ind for nr enb
 ****************************************************************************/
rrm_return_et
rrm_cellm_handle_stop_tnl_discovery_ind(
        void *p_api /*pointer pt api buffer*/
        )
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t *p_tnl_dis_stop_req = RRM_PNULL;

    p_tnl_dis_stop_req = (rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t *)p_api;
    
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "MIF->RRMCM_RMIF_STOP_TNL_DISCOVERY_FROM_ANR_REQ->CellM");

    if(RRM_FAILURE == rrm_remove_tnl_discovery_trans_id(p_tnl_dis_stop_req->target_enb_id))
    {
        RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_ERROR,
                "Failed To Remove Trans ID For TNL Discovery");

        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/**************************************************************************
 * Function Name  : rrm_remove_tnl_discovery_trans_id
 * Inputs         : target_enb_id
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : removes the trans id for previously stored tnl discovery
 ****************************************************************************/
rrm_return_et
rrm_remove_tnl_discovery_trans_id
(
 rrm_global_enb_id_t     target_enb_id
 )
{
    rrm_tnl_discovery_trans_id_list_t   *p_tnl_dis_tid_list = RRM_PNULL;
    rrm_tnl_discovery_trans_id_node_t   *p_tnl_dis_tid_node = RRM_PNULL;
    YLNODE                              *p_node             = RRM_PNULL;
    rrm_return_et                       ret_val             = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_tnl_dis_tid_list = &(p_g_rrm_cell_ctx->rrm_tnl_discovery_trans_id_list);

    p_node = rrm_get_first_list_node(p_tnl_dis_tid_list);

    while(RRM_PNULL != p_node)
    {
        p_tnl_dis_tid_node =  YMEMBEROF(rrm_tnl_discovery_trans_id_node_t, sNode, p_node);
        if(!RRM_MEMCMP(&p_tnl_dis_tid_node->enb_id, &target_enb_id,
                    sizeof(rrm_global_enb_id_t)))
        {
            rrm_list_delete_node(p_tnl_dis_tid_list, (YLNODE *)p_tnl_dis_tid_node);

            RRM_TRACE(g_uem_log_on_off, p_rrm_uem_facility_name, RRM_DETAILED,
                    "Target ENB found in list. Removed Transaction ID : %d"
                    " of TNL discovery",p_tnl_dis_tid_node->trans_id);

            RRM_MEM_FREE(p_tnl_dis_tid_node);
            ret_val = RRM_SUCCESS;
            break;
        }
        p_node = rrm_get_next_list_node(p_node);
    }
    if(ret_val == RRM_FAILURE)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Target ENB not found in TNL Discovery Req list at RRM");
    }
    return ret_val;
    RRM_UT_TRACE_EXIT();
}
/* Spr 16142 Fix End */

/* SPR 10450 Fix Start */
/**************************************************************************
 * Function Name  : rrm_cellm_get_drx_config_resource 
 * Inputs         : cell_index
 * Outputs        : None
 * Returns        : addess of drx_config_resource 
 * Description    : returns addess of drx_config_resource
 ****************************************************************************/

rrm_cell_drx_config_resources_t* 
rrm_cellm_get_drx_config_resource
(
 rrm_cell_index_t cell_index
 )
{
	return  &(p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->rrm_cell_drx_config_resources);
}

rrm_void_t
rrm_set_drx_resources_free
(
 rrm_cell_context_t *p_cell_ctx
 )
{
  U8 drx_res_count = RRM_ZERO ;
  U8 drx_prfl_idx  = RRM_ZERO ;
  RRM_UT_TRACE_ENTER();

  for(drx_prfl_idx = RRM_ZERO ; drx_prfl_idx <RRM_OAM_MAX_NUM_QCI_CLASSES ; drx_prfl_idx++)
  {
      if( RRM_TRUE == p_cell_ctx->rrm_cell_drx_config_resources.drx_res_arr[drx_prfl_idx].drx_enabled )
      {
          for( drx_res_count = RRM_ZERO; drx_res_count < p_cell_ctx->rrm_cell_drx_config_resources.drx_res_arr[drx_prfl_idx].
                  total_drx_offset ; drx_res_count++)
          {
              p_cell_ctx->rrm_cell_drx_config_resources.drx_res_arr[drx_prfl_idx].
                  drx_res_tree[drx_res_count].res_status = RRM_RES_FREE;
          }
      }

  }
  RRM_UT_TRACE_EXIT();
}
/* SPR 10450 Fix End */

/* SPR_13117_FIX_START */
/**************************************************************************
 * Function Name  : rrm_get_cellm_log_level
 * Inputs         : log_level_enable
 *                : log_level_for_uem
 * Outputs        : None
 * Returns        : None
 * Description    : send the log_level and log_enabled from globel_cell_context
 ****************************************************************************/

void rrm_get_cellm_log_level(U8 *log_level_enable,
        U8 *log_level_for_uem)
{
    RRM_UT_TRACE_ENTER();
    *log_level_enable = p_g_rrm_cell_ctx->log_enabled;
    *log_level_for_uem = p_g_rrm_cell_ctx->log_level;
    RRM_UT_TRACE_EXIT();
}
/* SPR_13117_FIX_END */
/* eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 * Function Name  : build_and_send_x2ap_eicic_load_information 
 * Inputs         : rrm_cell_context_t *p_cell_ctxt : pointer
 *                :  to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Sends Load Information Req to RRC
 ****************************************************************************/
/* bug_13898_start */  
rrm_eicic_load_info_send_status_et build_and_send_x2ap_eicic_load_information
/* b_ug_13898_end */  
(
 rrm_cell_context_t             *p_cell_ctxt ,       /* cell context */
 rrm_eicic_load_info_type_et     load_info_type,
 U8                              target_ncl_count
 )
{
    lte_ncl_t                         *lte_ncl = RRM_PNULL;
    rrm_oam_eutran_global_cell_id_t    eutran_global_cell_id_arr ;
    U8                                 ncl_cnt = RRM_ZERO;
                            /* bug_13972_start */ 
    rrm_return_et                      ret_val = RRM_FAILURE; 
                            /* bug_13972_start */ 
/* bug_13898_start */  
    rrm_eicic_load_info_send_status_et load_info_sent  = EICIC_LOAD_INFO_SEND_FAILURE; 
/* bug_13898_end */  
    U8                                 context_index = RRM_ZERO;
/* bug_13972_start */  
    YHASH                             rrm_enbid_hash;
    YHNODE                            *p_hnode = RRM_PNULL;
    rrm_cellm_enb_id_hnode_t          *p_enb_hnode = RRM_PNULL;
    rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    rrm_bool_et                        macro_enb_present = RRM_FALSE;
    rrm_cellm_enb_id_hnode_t          *p_enb_hnode_existing = RRM_PNULL;
/* bug_13972_end */

    RRM_UT_TRACE_ENTER ();

    RRM_MEMSET( &eutran_global_cell_id_arr,
            RRM_ZERO,sizeof(rrm_oam_eutran_global_cell_id_t));

    lte_ncl = rrm_cellm_get_lte_ncl_info (p_cell_ctxt->cell_index);

    if(RRM_PNULL == lte_ncl)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "lte ncl is not present,can't send x2ap_rrm_load_information_req");
        /* CID_69665_FIX_START */
        return EICIC_LOAD_INFO_SEND_FAILURE;
        /* CID_69665_FIX_END */
    }

    if( LOAD_INFO_EICIC_INVOKE == load_info_type )
    {
        /* CID_69668_FIX_START */
        /* bug_13972_start */  
        /* Getting Memory For Hash Table */
        YHNODE **table = (YHNODE **)rrm_mem_get(((RRM_CELLM_MAX_HASH_BUCKECT) * sizeof (YHNODE *)));

        if(RRM_PNULL == table) /* Coverity: CID 42114 */
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to table failed");
            /* CID_69665_FIX_START */
            return EICIC_LOAD_INFO_SEND_FAILURE;
            /* CID_69665_FIX_END */
        }
        /* Init Hash Table rrm_enbid_hash */
        yhInit (&rrm_enbid_hash, RRM_CELLM_MAX_HASH_BUCKECT, rrm_cellm_hashing_func, rrm_cmp_enb_id, rrm_keyof_func, table);
        /* bug_13972_end */  
        /* CID_69668_FIX_END */
        for (ncl_cnt = RRM_ZERO; ncl_cnt < lte_ncl->num_valid_intra_freq_cell; ++ncl_cnt)
        {
            /* This cell is HeNodeB, Its consist only one cell */
            /* _bug_13935_start */  
            if ((HO_ALLOWED == lte_ncl->intra_freq_cells[ncl_cnt].ho_status) && /* Check HO status is enable */
                    (RRM_TRUE   == lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status) &&
                    (RRM_FALSE  == lte_ncl->intra_freq_cells[ncl_cnt].blacklisted) && 
                    (RRM_OAM_ACTIVATE_EICIC == lte_ncl->intra_freq_cells[ncl_cnt].interference_scheme))
                /* bug_13935_end */  
            {
                if ((RRM_TRUE == lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status) ||
                        (X2_ALLOWED_CONNECTED == lte_ncl->intra_freq_cells[ncl_cnt].x2_status))
                {
                    RRM_MEMCPY(&eutran_global_cell_id_arr, 
                            &lte_ncl->intra_freq_cells[ncl_cnt].cell_id,
                            sizeof(rrm_oam_eutran_global_cell_id_t));
                    /* Build and send X2AP_RRM_LI_RRM_LOAD_INFORMATION_REQ*/
                    if( (lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.bitmask &
                                RRMCM_INTRA_NCL_INVOKE_IND_STATUS_PRESENT ) &&
                            (RRM_EICIC_SEND_INVOKE == lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.invoke_ind_status)
                      )
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Neighbour having PCI[%d] is aggressor, Send Invoke Ind",
                                lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                        /* bug_13972_start */ 
                        /* SPR 19502 Fix start */
                        if(( lte_ncl->intra_freq_cells[ncl_cnt].bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                        /* SPR 19502 Fix end */
                                (( RRM_OAM_ACCESS_MODE_CLOSE == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode )|| 
                                /*SPR 15572 fix start */
                                ( RRM_OAM_ACCESS_MODE_HYBRID == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode )||
                                ( RRM_OAM_ACCESS_MODE_OPEN_FEMTO == lte_ncl->intra_freq_cells[ncl_cnt].cell_access_mode)))
                                /*SPR 15572 fix end */
                            /* bug_13972_end */  
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "CSG CELL, send invoke indication");
                            ret_val =  rrm_cellm_fill_x2ap_eicic_load_info_ind(p_cell_ctxt,
                                    &eutran_global_cell_id_arr,
                                    RRM_ENB_TYPE_HOME,load_info_type);
                        }
                        else
                        {
                            /* bug_13972_start */ 
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "MACRO CELL, buffer the cell for cummulative invoke");
                            macro_enb_present = RRM_TRUE;
                            p_hnode =  yhFind(&rrm_enbid_hash, (rrm_void_t *)
                                    &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]));
                            if (RRM_PNULL == p_hnode)
                            {
                                p_enb_hnode = (rrm_cellm_enb_id_hnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_hnode_t));
                                if ( p_enb_hnode == RRM_PNULL)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Memory allocation to p_enb_hnode failed" );

                                    /* free the memory resources */  
                                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix start*/
                                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix end*/

                                    RRM_UT_TRACE_EXIT();
                                    /* CID_69669_FIX_START */
                                    if( RRM_NULL != rrm_enbid_hash.table )
                                    {
                                        RRM_MEM_FREE( rrm_enbid_hash.table);
                                        /* SPR 20007 : CID 69668 Fix Start */
                                        /* Code Removed */
                                        /* SPR 20007 : CID 69668 Fix End */
                                    }
                                    /* CID_69669_FIX_END */
                                    /* CID_69665_FIX_START */
                                    return EICIC_LOAD_INFO_SEND_FAILURE;
                                    /* CID_69665_FIX_END */
                                }

                                RRM_MEMCPY(&p_enb_hnode->enb_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity[RRM_ZERO]),
                                        sizeof(p_enb_hnode->enb_id));
                                ylInit(&p_enb_hnode->list);
                                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                                if ( p_enb_lnode == RRM_PNULL)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Memory allocation to p_enb_lnode failed" );
                                    /* free the memory resources */  
                                    /* COVERITY : RESOURCE LEAK : CID : 54336 ,54337,54338 fix start*/
                                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                                    /* COVERITY : RESOURCE LEAK : CID : 54336 ,54337,54338 fix end*/
                                    RRM_UT_TRACE_EXIT();
                                    /* CID_69669_FIX_START */
                                    RRM_MEM_FREE( p_enb_hnode );
                                    /* CID_69669_FIX_END */
                                    /* CID_69665_FIX_START */
                                    return EICIC_LOAD_INFO_SEND_FAILURE;
                                    /* CID_69665_FIX_END */
                                }

                                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                                        sizeof(rrm_oam_eutran_global_cell_id_t));
                                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                                p_enb_lnode->enb_info.invoke_ind_status =  lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.invoke_ind_status;
                                ylPushHead(&p_enb_hnode->list, &p_enb_lnode->node);
                                yhInsert(&rrm_enbid_hash, &(p_enb_hnode->node));
                            }
                            else
                            {
                                    /* CID_69669_FIX_START */
                                p_enb_hnode_existing = (rrm_cellm_enb_id_hnode_t *)((unsigned long)p_hnode - \
                                        (unsigned long)(&((rrm_cellm_enb_id_hnode_t *)RRM_ZERO)->node));
                                    /* CID_69669_FIX_END */
                                p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)rrm_mem_get(sizeof(rrm_cellm_enb_id_lnode_t));
                                if ( p_enb_lnode == RRM_PNULL)
                                {
                                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                            "Memory allocation to p_enb_lnode failed" );

                                    /* free the memory resources */ 
                                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix start*/
                                    rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
                                    /* COVERITY : RESOURCE LEAK : CID : 54336,54337,54338 fix end*/

                                    RRM_UT_TRACE_EXIT();
                                    /* CID_69669_FIX_END */
                                    /* CID_69666_FIX_START */
                                    return EICIC_LOAD_INFO_SEND_FAILURE;
                                    /* CID_69666_FIX_END */
                                }

                                RRM_MEMCPY(&p_enb_lnode->enb_info.cell_id, &(lte_ncl->intra_freq_cells[ncl_cnt].cell_id),
                                        sizeof(rrm_oam_eutran_global_cell_id_t));
                                p_enb_lnode->enb_info.x2_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_status;
                                p_enb_lnode->enb_info.ho_status = lte_ncl->intra_freq_cells[ncl_cnt].ho_status;
                                p_enb_lnode->enb_info.x2_link_up_status = lte_ncl->intra_freq_cells[ncl_cnt].x2_link_up_status;
                                p_enb_lnode->enb_info.broadcast_status = lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status;
                                p_enb_lnode->enb_info.blacklisted = lte_ncl->intra_freq_cells[ncl_cnt].blacklisted;
                                p_enb_lnode->enb_info.invoke_ind_status =  lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.invoke_ind_status;
                                ylPushHead(&p_enb_hnode_existing->list, &p_enb_lnode->node);
                            }
                            /* bug_13972_start */ 
                        }
                        if( RRM_SUCCESS == ret_val ) 
                        {
                            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                    "Invoke Indication is successfully sent to Neighbour with PCI[%d]",
                                    lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                            lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.invoke_ind_status = RRM_EICIC_INVOKE_SENT;
                            lte_ncl->intra_freq_cells[ncl_cnt].rrm_intra_ncl_eicic_data.
                                bitmask |= RRMCM_INTRA_NCL_INVOKE_IND_STATUS_PRESENT;
                            p_cell_ctxt->rrm_eicic_cell_info.num_x2ap_invoke_ind_sent++;
                            /* bug_13898_start */ 
                            load_info_sent = EICIC_LOAD_INFO_SEND_SUCCESS;
                            /* bug_13898_end */ 
                        }
                        else
                        {
                            if(RRM_FALSE == macro_enb_present)
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Failed to send Invoke Indication to Neighbour with PCI[%d]",
                                        lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                            }
                            /* bug_13972_start */ 
                            else
                            {
                                load_info_sent = EICIC_LOAD_INFO_SEND_SUCCESS;
                            }
                            /* bug_13972_end */ 
                        }
                    }
                }
                else if ( X2_LOCALLY_CONNECTED_CELL == lte_ncl->intra_freq_cells[ncl_cnt].x2_status)
                {
                    /* bug_13898_start */  
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Neighbour having PCI[%d] is aggressor, No need to send Invoke Ind"
                            "Get ABS pattern locally",lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                    /* bug_13898_end */  
                    for( context_index = RRM_ZERO; context_index < RRM_MAX_NUM_CELLS ; context_index++)
                    {
                        if(RRM_PNULL != p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index])
                        {
                            if(!RRM_MEMCMP( p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index]->global_cell_id.cell_identity,
                                        lte_ncl->intra_freq_cells[ncl_cnt].cell_id.cell_identity, MAX_CELL_IDENTITY_OCTETS))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Aggressor Cell found at context index [%d] in same eNb",context_index);
                                /* bug_13935_start */  
                                rrm_cellm_process_abs_info_frm_agg_same_enb(p_cell_ctxt,
                                        p_g_rrm_cell_ctx->p_rrm_cell_ctx[context_index],
                                        ncl_cnt,RRM_EICIC_TEMP_ABS);               
                                /* bug_13935_end */  
                                /* bug_13898_start */  
                                load_info_sent = EICIC_LOAD_INFO_SEND_NOT_REQUIRED;
                                break;
                                /* bug_13898_end */  
                            }
                        }
                    }
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                            "Link is not UP for intra freq neighbor pci: %d",
                            lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id );
                }
            }
            else /* HO is not enable so no Load Information request will be sent */
            {
                /* bug_13935_start */  
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                        "Broadcast is %s, HO %s, cell is %s, EICIC is %s Load Report cannot be configured on intra freq neighbor pci: %d",
                        (RRM_TRUE == lte_ncl->intra_freq_cells[ncl_cnt].broadcast_status ? "allowed": "not allowed"), 
                        (HO_ALLOWED == lte_ncl->intra_freq_cells[ncl_cnt].ho_status ? "allowed" : "not allowed"),
                        (RRM_FALSE == lte_ncl->intra_freq_cells[ncl_cnt].blacklisted ? "not blacklisted" : "blacklisted"),
                        (RRM_OAM_ACTIVATE_EICIC == lte_ncl->intra_freq_cells[ncl_cnt].interference_scheme ? "EICIC ACTIVATED" : "EICIC NOT ACTIVATED"),
                        lte_ncl->intra_freq_cells[ncl_cnt].phy_cell_id);
                /* bug_13935_end */  
            }
        }

        /* bug_13972_start */  
        /* Sending the ICIC Load req to each Macro eNodeB and free the hash and list */
        p_hnode = yhFirst((const YHASH *)&rrm_enbid_hash);
        while (RRM_PNULL != p_hnode)
        {
            p_enb_hnode_existing = (rrm_cellm_enb_id_hnode_t *)((unsigned long)p_hnode - \
                    (unsigned long)(&((rrm_cellm_enb_id_hnode_t *)RRM_ZERO)->node));
            /*Coverity ID 82661 Fix Start*/
            rrm_build_and_send_eicic_load_info_req_to_macro_enb (p_enb_hnode_existing, p_cell_ctxt);
            /*Coverity ID 82661 Fix End*/
            p_hnode = yhNext (&rrm_enbid_hash, (YHNODE *)p_enb_hnode_existing);
            yhDelete (&rrm_enbid_hash, (YHNODE *)p_enb_hnode_existing);
            RRM_MEM_FREE (p_enb_hnode_existing);
        }

        rrm_free_load_info_resource_on_error( &rrm_enbid_hash );    
        /* SPR 20007 : CID 69668 Fix Start */
        /* Code Removed */
        /* SPR 20007 : CID 69668 Fix End */
        /* 13972_end */  
    }
    else
    {
        /*SPR 15480 start*/
        /*SPR 21083 Fix Start*/
        if ((HO_ALLOWED == lte_ncl->intra_freq_cells[target_ncl_count].ho_status) && /* Check HO status is enable */
                (RRM_TRUE   == lte_ncl->intra_freq_cells[target_ncl_count].broadcast_status) &&
                (RRM_FALSE  == lte_ncl->intra_freq_cells[target_ncl_count].blacklisted) && 
                (RRM_OAM_ACTIVATE_EICIC == lte_ncl->intra_freq_cells[target_ncl_count].interference_scheme))
        {
            if ((RRM_TRUE == lte_ncl->intra_freq_cells[target_ncl_count].x2_link_up_status) ||
                    (X2_ALLOWED_CONNECTED == lte_ncl->intra_freq_cells[target_ncl_count].x2_status))
            { 
                RRM_MEMCPY(&eutran_global_cell_id_arr, 
                        &lte_ncl->intra_freq_cells[target_ncl_count].cell_id,
                        sizeof(rrm_oam_eutran_global_cell_id_t));
                /* SPR 19503 Fix start */
                if(( lte_ncl->intra_freq_cells[target_ncl_count].bitmask & RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT) &&
                        (( RRM_OAM_ACCESS_MODE_CLOSE == lte_ncl->intra_freq_cells[target_ncl_count].cell_access_mode )|| 
                         ( RRM_OAM_ACCESS_MODE_HYBRID == lte_ncl->intra_freq_cells[target_ncl_count].cell_access_mode )||
                         ( RRM_OAM_ACCESS_MODE_OPEN_FEMTO == lte_ncl->intra_freq_cells[target_ncl_count].cell_access_mode)))
                    /* SPR 19503 Fix end */    
                {
                    ret_val =  rrm_cellm_fill_x2ap_eicic_load_info_ind(p_cell_ctxt,
                            &eutran_global_cell_id_arr,
                            RRM_ENB_TYPE_HOME,load_info_type);
                }
                else
                {
                    ret_val =  rrm_cellm_fill_x2ap_eicic_load_info_ind(p_cell_ctxt,
                            &eutran_global_cell_id_arr,
                            RRM_ENB_TYPE_MACRO,load_info_type);
                }
                if( RRM_SUCCESS == ret_val ) 
                {
                    if( LOAD_INFO_EICIC_ABS_PATTERN == load_info_type)
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "ABS pattern is successfully sent to Neighbour with PCI[%d]",
                                lte_ncl->intra_freq_cells[target_ncl_count].phy_cell_id);
                        lte_ncl->intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent = RRM_EICIC_ABS_PATTERN;
                        RRM_MEMCPY( lte_ncl->intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.abs_pattern_sent,
                                p_cell_ctxt->rrm_eicic_cell_info.serving_abs_pattern_applied,
                                RRM_MAX_PATTERN_BYTE );
                        lte_ncl->intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.
                            bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_SENT_PRESENT;
                        //    bitmask |= RRMCM_INTRA_NCL_ABS_PATTERN_SENT_PRESENT;
                        if((p_cell_ctxt->operator_info.eicic_info.bitmask &  RRMCM_RMIF_ABS_INFO_PRESENT) &&
                                (p_cell_ctxt->operator_info.eicic_info.abs_info.bitmask & RRMCM_RMIF_NUM_ABS_REPORT_PRESENT) &&
                                (p_cell_ctxt->operator_info.eicic_info.abs_info.num_abs_report != RRM_ZERO) )
                        {
                            lte_ncl->intra_freq_cells[target_ncl_count].resrc_report.abs_status.num_abs_report = RRM_ZERO;
                            lte_ncl->intra_freq_cells[target_ncl_count].resrc_report.abs_status.bitmask = 0x00;
                            lte_ncl->intra_freq_cells[target_ncl_count].resrc_report.abs_status.bitmask |= RRM_NUM_OF_ABS_REPORT_PRESENT;
                            lte_ncl->intra_freq_cells[target_ncl_count].resrc_report.abs_status.abs_change_type = RRM_ABS_INCREASE;
                        }
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "ABS INACTIVE is successfully sent to Neighbour with PCI[%d]",
                                lte_ncl->intra_freq_cells[target_ncl_count].phy_cell_id);
                        lte_ncl->intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent = RRM_EICIC_ABS_INACTIVE;
                       /*SPR 21351 Fix Start*/ 
                        lte_ncl->intra_freq_cells[target_ncl_count].rrm_intra_ncl_eicic_data.invoke_ind_status = RRM_EICIC_INVOKE_NOT_SENT;  
                        /*SPR 21351 Fix Stop*/
                    }
                    //coverity_fix_req
                    /* bug_13898_start */
                    load_info_sent = EICIC_LOAD_INFO_SEND_SUCCESS;
                    /* bug_13898_start */
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Failed to send Invoke Indication to Neighbour with PCI[%d]",
                            lte_ncl->intra_freq_cells[target_ncl_count].phy_cell_id);
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        "Failed to send load Indication to Neighbour with PCI[%d] as X2 is not UP with this neghbour",
                        lte_ncl->intra_freq_cells[target_ncl_count].phy_cell_id);
            }    
        }
        /*SPR 21083 Fix Stop*/
        /*SPR 15480 end*/
    }
    RRM_UT_TRACE_EXIT();
    return load_info_sent;
}
/* eICIC_PHASE_1_2_CHANGES_START */

/****************************************************************************
 * Function Name  : rrm_cellm_cell_ue_update_aggressor_info
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *        : U16 api_id : api id
 *        : U16 data_len : data length
 *        : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Updates the aggressor information provided by the UEm
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_ue_update_aggressor_info(
         rrm_void_t *p_api,/*pointer pt api buffer*/
         U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
         )
{
    rrm_cell_index_t                cell_index                = RRM_ZERO;
    rrm_return_et                   ret_val                   = RRM_SUCCESS;
    rrmuem_cm_get_aggressor_resp_t  *rrmcm_uem_aggressor_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrmcm_uem_aggressor_resp =
        (rrmuem_cm_get_aggressor_resp_t *)p_api;

    cell_index = rrmcm_uem_aggressor_resp->cell_index;
    /* Fill the other information provided by the API */
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "UEM->CellM:RRMUEM_CM_GET_AGGRESSOR_RESP:[CELL:%d] with response: %d",
            cell_index, rrmcm_uem_aggressor_resp->response);
    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "Cell context not found at cell index [%d]",cell_index);
        return RRM_FAILURE;
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = RRMUEM_CM_GET_AGGRESSOR_RESP;

    if (RRM_FAILURE == cellm_fsm_process_event (
                RRM_UEM_GET_AGGRESSOR_RESP_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        ret_val = RRM_FAILURE;
    }
    else
    {
        ret_val = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/** eICIC_PHASE_1_2_CHANGES_START */
/****************************************************************************
 * Function Name  : rrm_cellm_cell_ue_provision_reconfig_resp 
 * Inputs         : rrm_void_t *p_api  : pointer to api buffer
 *        : U16 api_id : api id
 *        : U16 data_len : data length
 *        : rrm_global_context_t *p_gl_ctx   : pointer to cell
 *                : global context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : reconfig eicic provision type
 ****************************************************************************/
rrm_return_et
rrm_cellm_cell_ue_provision_reconfig_resp(
         rrm_void_t *p_api,/*pointer pt api buffer*/
         U16 api_id /*ADI id of incoming message*/
            /*SPR 17777 +-*/
         )
{
    rrm_cell_index_t                  cell_index=RRM_ZERO;
    rrm_return_et                     ret_val = RRM_SUCCESS;
    rrmuem_cellm_eicic_provision_reconfig_resp_t  *rrmuem_cellm_eicic_provision_reconfig_resp = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    rrmuem_cellm_eicic_provision_reconfig_resp =
        (rrmuem_cellm_eicic_provision_reconfig_resp_t *)p_api;

    cell_index = rrmuem_cellm_eicic_provision_reconfig_resp->cell_index;
    /* Fill the other information provided by the API */
    RRM_ASSERT(cell_index< RRM_MAX_NUM_CELLS);
    SET_CELL_INDEX(cell_index);
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
            "UEM->CellM:RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP:[CELL:%d] with response: %d",
            cell_index, rrmuem_cellm_eicic_provision_reconfig_resp->response);
    if(RRM_PNULL == p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index])
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                  "Cell context is not found at [%d]",cell_index);
        return RRM_FAILURE;
    }

    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->p_incoming_api_info = (void *)p_api;
    p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]->api_id = RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP;

    if (RRM_FAILURE == cellm_fsm_process_event (
                RRM_UEM_OR_L2_RESPONSE_EVENT,
                p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index]))
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "UEM->RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP->CellM failed to process");
        ret_val = RRM_FAILURE;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                "UEM->RRMUEM_CELLM_EICIC_PROVISION_RECONFIG_RESP->CellM successfully processed");
        ret_val = RRM_SUCCESS;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/** eICIC_PHASE_1_2_CHANGES_END */

/****************************************************************************
 * Function Name  : rrm_uem_get_aggressor_resp_process_info
 * Inputs         : p_cell_ctx
 *                : p_api
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Process the aggressor information provided by the UEm and 
 *                  send them Load Invoke Indication.
 ****************************************************************************/
rrm_return_et
rrm_uem_get_aggressor_resp_process_info(
 rrm_cell_context_t *p_cell_ctx
 )
{
    rrm_cell_index_t                 cell_index               = RRM_ZERO;
    rrm_return_et                    ret_val                  = RRM_SUCCESS;
    rrmuem_cm_get_aggressor_resp_t  *rrmcm_uem_aggressor_resp = RRM_PNULL;
    cell_timer_buf_t                 timer_buf; 
    U8                               agg_count                = RRM_ZERO;
    U8                               ncl_pos                  = RRM_INVALID_TARGET_NCL;
    rrm_bool_et                      aggressor_found          = RRM_FALSE;
    /* bug_13898_start */
    rrm_eicic_load_info_send_status_et load_send_status       = EICIC_LOAD_INFO_SEND_FAILURE;
    /* bug_13898_end */
    RRM_UT_TRACE_ENTER();
	
    RRM_ASSERT(RRM_PNULL != p_cell_ctx);

    rrmcm_uem_aggressor_resp =
        (rrmuem_cm_get_aggressor_resp_t *)p_cell_ctx->p_incoming_api_info;
    
    RRM_ASSERT(RRM_PNULL != rrmcm_uem_aggressor_resp);

    cell_index = rrmcm_uem_aggressor_resp->cell_index;

    if (RRM_FAILURE == rrmcm_uem_aggressor_resp->response)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "Failure is received from UEM in RRMUEM_CM_GET_AGGRESSOR_RESP"
                  "So, No need to send Load INVOKE request.");
        /*
        ** Send RRMUEM_CM_SCHEDULE_VICTIM_UE_IND 
        */

		/* SPR 14576 start */ 
        build_and_send_uem_schedule_victim_ind(p_cell_ctx, RRM_VICTIM_SCHEDULE_WITH_NO_ABS_CHANGE);
		/* SPR 14576 end */


        /*SPR 14810 start*/
        /*SPR 21081 Fix Start*/
        if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
        {
        p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                                     eicic_timer_info.aggressor_sel_timer;
        /*SPR 14810 stop*/
        /* Restart the timer */
        if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
        {
            cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
            timer_buf.cell_index = cell_index;
            timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
            p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                        (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
        }
    }
        /*SPR 21081 Fix Stop*/
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                  "Success is received from UEM in RRMUEM_CM_GET_AGGRESSOR_RESP"
                  "So, now send Load INVOKE request to aggressor nodes");
        for(agg_count = RRM_ZERO; 
                   agg_count < rrmcm_uem_aggressor_resp->num_of_aggressor ;agg_count++)
        {
             rrm_cellm_get_aggressor_pos_in_ncl(p_cell_ctx, rrmcm_uem_aggressor_resp->phy_cell_id[agg_count],
                                                            &ncl_pos);
             if(RRM_INVALID_TARGET_NCL != ncl_pos)
             {
                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                           "Aggressor PCI[%d] is present at [%d] pos in NCL",
                           rrmcm_uem_aggressor_resp->phy_cell_id[agg_count],ncl_pos);
                 /* bug_13935_start */
                 p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_pos].
                     rrm_intra_ncl_eicic_data.aggressor_priority = RRM_CELLM_HIGHEST_AGGRESSOR_PRIORITY - agg_count;
                 /* bug_13935_end */
                 p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_pos].
                     rrm_intra_ncl_eicic_data.invoke_ind_status = RRM_EICIC_SEND_INVOKE; 
                 p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_pos].
                     rrm_intra_ncl_eicic_data.bitmask |= RRMCM_INTRA_NCL_INVOKE_IND_STATUS_PRESENT; 
                 aggressor_found = RRM_TRUE;
             }
             else
             {
                 RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                           "Aggressor PCI[%d] is not present at in NCL",
                           rrmcm_uem_aggressor_resp->phy_cell_id[agg_count]);
             }
        }

        if( RRM_TRUE == aggressor_found )
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                      "Aggressor(s) are found in NCL list, try sending INVOKE ind to them");
            
            /*
            ** Send LOAD_INFO_EICIC_INVOKE to all the possible aggressors present
            ** in NCL list with RRM_EICIC_SEND_INVOKE as invoke status. 
            ** RRM_INVALID_TARGET_NCL is sent as no specific target is present.
            */
            /* bug_13898_start */
            if( EICIC_LOAD_INFO_SEND_SUCCESS == (load_send_status = build_and_send_x2ap_eicic_load_information( p_cell_ctx,
                                                        LOAD_INFO_EICIC_INVOKE,
                                                        RRM_INVALID_TARGET_NCL
                                                      )))
            {
                /*
                 ** Start the guard timer to Guard the responses from the aggressor Nodes 
                 ** on X2AP
                 */
                if((p_cell_ctx->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT) &&
                        (p_cell_ctx->operator_info.eicic_info.eicic_timer_info.bitmask & RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT))
                { 
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Starting Load Information Guard timer with [%d] value",
                            p_cell_ctx->operator_info.eicic_info.eicic_timer_info.load_information_guard_timer);
                    p_cell_ctx->timer_val[CELL_GUARD_TIMER_FOR_ABS_PATTERN] = p_cell_ctx->operator_info.eicic_info.
                        eicic_timer_info.load_information_guard_timer; 
                    timer_buf.cell_index = cell_index;
                    timer_buf.timer_type = CELL_GUARD_TIMER_FOR_ABS_PATTERN;
                    p_cell_ctx->rrm_eicic_cell_info.cell_guard_timer =
                        cell_start_timer ( CELL_GUARD_TIMER_FOR_ABS_PATTERN , (rrm_void_t *)&timer_buf,
                                sizeof (cell_timer_buf_t), p_cell_ctx);
                }
                else
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                            "Unable to start Load Information Guard timer as"
                            " Timer info is not provided by operator");
                }
            }
            else if( EICIC_LOAD_INFO_SEND_NOT_REQUIRED == load_send_status)
	    {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                              " Load Invoke is not send as aggressor is from same eNB."
                              " Start finding common abs pattern");
                    rrm_cellm_find_and_apply_common_abs_pattern(p_cell_ctx);
	    }
            /* bug_13898_end */
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                        " Not able to send Load info(INVOKE), So no need to start guard timer"
                        "Restart Aggres sel timer");
                /* Restart the timer */
                /*SPR 14810 start*/
                /*SPR 21081 Fix Start*/
                if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
                {
                p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                                        eicic_timer_info.aggressor_sel_timer;
                /*SPR 14810 stop*/
                if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
                {
                    cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
                    timer_buf.cell_index = cell_index;
                    timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                    p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                        cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                                (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
                }
                }
                /*SPR 21081 Fix Stop*/
            }
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                    " None of the Aggressor in NCL, Will not send invoke and restart the"
                    " CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL timer");
            /* Restart the timer */
            /*SPR 14810 start*/
            /*SPR 21081 Fix Start*/
            if(p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type == RRM_OAM_ACT_AS_VICTIM)
            {
            p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL] = p_cell_ctx->operator_info.eicic_info.
                                       eicic_timer_info.aggressor_sel_timer;
            /*SPR 14810 stop*/
            if (RRM_ZERO !=  p_cell_ctx->timer_val[CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL])
            {
                cell_stop_timer ( p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer );
                timer_buf.cell_index = cell_index;
                timer_buf.timer_type = CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL;
                p_cell_ctx->rrm_eicic_cell_info.cell_aggressor_sel_timer =
                    cell_start_timer(CELL_PERIODIC_TIMER_FOR_AGGRESSOR_SEL,
                            (rrm_void_t *)&timer_buf, sizeof (cell_timer_buf_t), p_cell_ctx);
            }
                /*SPR 21081 Fix Stop*/
            }
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : rrm_cellm_get_aggressor_pos_in_ncl 
 * Inputs         : p_cell_ctx
 *                : aggressor_pci
 * Outputs        : p_ncl_pos
 * Returns        : None
 * Description    : This function returns the position of aggressor in NCL.
 ****************************************************************************/
rrm_void_t
rrm_cellm_get_aggressor_pos_in_ncl
(
 rrm_cell_context_t *p_cell_ctx,
 U16                 aggressor_pci,
 U8                 *p_ncl_pos
)
{
    U8      ncl_count = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    for(ncl_count = RRM_ZERO ; 
            ncl_count < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ncl_count++)
    {
        if( aggressor_pci == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id)
        {
            *p_ncl_pos = ncl_count;
            break;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR14157start */
/****************************************************************************
 * Function Name  : rrm_check_for_x2_link_status 
 * Inputs         : p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : This function checks whether X2 link is up or not 
 ****************************************************************************/
rrm_bool_et
rrm_check_for_x2_link_status
(
 rrm_cell_context_t *p_cell_ctx
)
{
	rrm_bool_et x2_up_flag = RRM_FALSE;
        U8 ncl_cnt = RRM_ZERO;
	RRM_UT_TRACE_ENTER();

	for (ncl_cnt = RRM_ZERO; ncl_cnt < p_cell_ctx->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell; ++ncl_cnt)
	{
        /*SPR 19841 Fix Start*/
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,\
                "intra_freq_cells[%d].interference_scheme :%d,"
                "intra_freq_cells[ncl_cnt].x2_link_up_status: %d,"
                "intra_freq_cells[ncl_cnt].x2_status : %d",\
                ncl_cnt,p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].interference_scheme,\
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_link_up_status,\
                p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_status);
        /*SPR 19841 Fix Stop*/

        if ((X2_PROHIBITED_CONNECTED == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_status ) ||
                (X2_ALLOWED_CONNECTED == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_status ) || 
                /*SPR 19841 Fix Start*/
                ((X2_LOCALLY_CONNECTED_CELL == p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_status)
                 && (RRM_OAM_ACTIVATE_EICIC ==
                     p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].interference_scheme)) ||
                /*SPR 19841 Fix Stop*/
                (p_cell_ctx->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_cnt].x2_link_up_status == RRM_TRUE))
        {
            x2_up_flag = RRM_TRUE;
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                    " X2 is Up with one of the neighbours ");

        }
    }
	RRM_UT_TRACE_EXIT();
	return x2_up_flag;

}
/* SPR14157end */
/****************************************************************************
 * Function Name  : rrm_cellm_is_victim_node 
 * Inputs         : p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : This function checks whether the requested cell is configured 
 *                  as Victim or not.
 *                  RRM_TRUE  = Cell is configured as Victim
 *                  RRM_FALSE = Cell is NOT configured as Victim
 ****************************************************************************/
rrm_bool_et
rrm_cellm_is_victim_node
(
 rrm_cell_context_t *p_cell_ctx
)
{
    rrm_bool_et is_victim = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_EICIC_INFO_PRESENT ) &&
        ( p_cell_ctx->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT ) &&
        (( RRM_OAM_ACT_AS_VICTIM == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type ) ||
         ( RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type))
      )
    {
          is_victim = RRM_TRUE;
         /* bug_13898_start */  
    }
    /* bug_13898_end */      
    //coverity_fix_req
    RRM_UT_TRACE_EXIT();
    return is_victim;
    
}

/****************************************************************************
 * Function Name  : rrm_cellm_is_aggressor_node 
 * Inputs         : p_cell_ctx
 * Outputs        : None
 * Returns        : RRM_TRUE / RRM_FALSE
 * Description    : This function checks whether the requested cell is configured 
 *                  as Aggressor or not.
 *                  RRM_TRUE  = Cell is configured as Aggressor
 *                  RRM_FALSE = Cell is NOT configured as Aggressor
 ****************************************************************************/
rrm_bool_et
rrm_cellm_is_aggressor_node
(
 rrm_cell_context_t *p_cell_ctx
)
{
    rrm_bool_et is_aggressor = RRM_FALSE;
    RRM_UT_TRACE_ENTER();

    if( ( p_cell_ctx->operator_info.bitmask & RRMCM_RMIF_EICIC_INFO_PRESENT) &&
        ( p_cell_ctx->operator_info.eicic_info.bitmask & RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT) &&
        (( RRM_OAM_ACT_AS_AGGRESSOR == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type ) ||
         ( RRM_OAM_ACT_AS_AGGRESSOR_AND_VICTIM == p_cell_ctx->operator_info.eicic_info.eicic_provisioned_type )
        )
      )
    {
          is_aggressor = RRM_TRUE;
         /* bug_13898_start */  
    }
    /* bug_13898_end */      
    //coverity_fix_req
    RRM_UT_TRACE_EXIT();
    return is_aggressor;
    
}
/****************************************************************************
 * Function Name  : rrm_cellm_l2_eicic_meas_report 
 * Inputs         : *p_api, api_id, data_len,cell_index
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function processes the eicic meas reports from L2 
 ****************************************************************************/
rrm_return_et rrm_cellm_l2_eicic_meas_report 
(
    void *p_api,
            /*SPR 17777 +-*/
    U8  cell_index
)
{
    rrm_return_et                    ret_val = RRM_SUCCESS;
    MacRrMEICICAbsReportInd          *rrm_mac_l2_eicic_meas_report = RRM_PNULL;
    rrm_cell_context_t               *p_rrm_cell_ctx = RRM_PNULL;
    /* SPR 14509 start */
    U8 index = RRM_ZERO;
    U8 abs_per_qci_dl = RRM_ZERO;
    /* SPR 14509 end */
    RRM_UT_TRACE_ENTER();

    rrm_mac_l2_eicic_meas_report = (MacRrMEICICAbsReportInd*)p_api;
    RRM_ASSERT(RRM_PNULL != rrm_mac_l2_eicic_meas_report);

	RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO, 
	        "MAC->RRM:RRM_MAC_EICIC_REPORT_IND:[CELL:%d]", cell_index);
    if(RRM_MAX_NUM_CELLS <= cell_index)
    {
        /*++SPR 20009 */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell index[%d] is invalid in EICIC_MEAS_REPORT", cell_index);
        /*--SPR 20009 */
        return RRM_FAILURE;
    }

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    /* SPR 14465 start */
    
    if(RRM_PNULL != p_rrm_cell_ctx) 
    {
        p_rrm_cell_ctx->svr_cell_load_info.bitmask |= RRM_ABS_STATUS_INFO_PRESENT;
        p_rrm_cell_ctx->svr_cell_load_info.abs_status.dl_abs_status = rrm_mac_l2_eicic_meas_report->absPrbUsage;

        p_rrm_cell_ctx->cell_resource_info.dl_gbr_absprb_in_use = RRM_ZERO; 
        p_rrm_cell_ctx->cell_resource_info.dl_ngbr_absprb_in_use = RRM_ZERO; 
        /* SPR 14509 start */
        for(index = RRM_ZERO;index < RRM_MAX_QCI; index++)
        {
            abs_per_qci_dl = rrm_mac_l2_eicic_meas_report->absPerQci[index]; 
            /*++SPR 20009 */
            /*Code Removed*/
            /*--SPR 20009 */

            if(index < MAX_NUM_GBR)
            {
                p_rrm_cell_ctx->cell_resource_info.dl_gbr_absprb_in_use  
                    += abs_per_qci_dl;
            }
            else
            {
                p_rrm_cell_ctx->cell_resource_info.dl_ngbr_absprb_in_use  
                    += abs_per_qci_dl;

            }
        }
        /* SPR 14509 end */

        /*++SPR 20009 */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "absPrbUsage:%d absPerQci1:%d absPerQci2:%d absPerQci3:%d absPerQci4:%d absPerQci5:%d "
            "absPerQci6:%d absPerQci7:%d absPerQci8:%d absPerQci9:%d Total GBR:%u NGBR:%u",
             rrm_mac_l2_eicic_meas_report->absPrbUsage,
             rrm_mac_l2_eicic_meas_report->absPerQci[0], rrm_mac_l2_eicic_meas_report->absPerQci[1],
             rrm_mac_l2_eicic_meas_report->absPerQci[2], rrm_mac_l2_eicic_meas_report->absPerQci[3],
             rrm_mac_l2_eicic_meas_report->absPerQci[4], rrm_mac_l2_eicic_meas_report->absPerQci[5],			
	         rrm_mac_l2_eicic_meas_report->absPerQci[6], rrm_mac_l2_eicic_meas_report->absPerQci[7],
	         rrm_mac_l2_eicic_meas_report->absPerQci[8], p_rrm_cell_ctx->cell_resource_info.dl_gbr_absprb_in_use,
             p_rrm_cell_ctx->cell_resource_info.dl_ngbr_absprb_in_use);


    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "Cell Context for index [%d] is invalid in EICIC_MEAS_REPORT", cell_index);
    }
    /*--SPR 20009 */
    /* SPR 14465 end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
            
/****************************************************************************
 * Function Name  : rrm_send_rsr_start_req_to_targt_cell 
 * Inputs         : *p_cell_ctxt, target_ncl_cnt,periodicity 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function processes the eicic meas reports from L2 
 ****************************************************************************/
rrm_return_et
rrm_send_rsr_start_req_to_targt_cell
(
 rrm_cell_context_t   *p_cell_ctxt,
 U8                    target_ncl_cnt,
 U8                    periodicity,
/*Bug 586 Changes Start*/
 rrm_bool_et           abs_enable
/*Bug 586 Changes End*/

)
{
	rrm_meas_rpt_config_info_t  rrm_meas_rpt_config_info;
    U32 report_characteristics = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
	
    rrm_meas_rpt_config_info.num_cell = RRM_ZERO;

    if ((HO_ALLOWED == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].ho_status) && /* Check HO status is enable */
        (RRM_FALSE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].blacklisted))
    {
        /* SPR 11490 end */
        if ((RRM_TRUE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].x2_link_up_status) ||
                (X2_ALLOWED_CONNECTED == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].x2_status))
        {
            rrm_meas_rpt_config_info.cell_index = p_cell_ctxt->cell_index;
            RRM_MEMCPY(&rrm_meas_rpt_config_info.cell_info[RRM_ZERO].global_cell_id,
                    &(p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].cell_id), sizeof (\
                        rrm_oam_eutran_global_cell_id_t));
            /*  report_characteristics =
                Bit 1: PRB Periodic report is requested
                Bit 2: TNL load Ind Periodic is requested
                Bit 3: Load Ind Periodic is requested
                Bit 4: Composite Available Capacity Periodic is requested
                Bit 5: ABS status periodic is requested
             */
            /* Build and send X2AP_RRM_RSU_RRM_START_REQ */
            rrm_meas_rpt_config_info.num_cell++;
            /*SPR 14290 start*/
            /*deleted setting unwanted bitmask*/
            /*SPR 14290 end*/
        /*SPR 18994 START*/
        /*code deleted*/
	    if (RRM_TRUE == abs_enable)
	    {
           rrm_set_report_charaterstics(&report_characteristics,RRM_ABS_STATUS_REPORT_CHAR_SET);
        }
        rrm_set_report_charaterstics(&report_characteristics,RRM_PRB_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_TNL_LOAD_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_HW_LOAD_REPORT_CHAR_SET);
        rrm_set_report_charaterstics(&report_characteristics,RRM_COMPOSITE_CAPACITY_REPORT_CHAR_SET);
        /*SPR 18994 END*/

        /* SPR 20674 Fix Start */
        /* Code Deleted */
        /* SPR 20674 Fix End */
            ret_val = build_and_send_rrm_x2ap_rrm_rsu_start_req (&rrm_meas_rpt_config_info, 
                                                                  report_characteristics,
                                                                  periodicity);
        }
        else
        {
            RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                    "Link is not UP for intra freq neighbor pci: %d",
                    p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].phy_cell_id );
            ret_val = RRM_FAILURE;
        }
    }
    else /* HO is not enable so no Resource Status Update request will be sent */
    {
        /* SPR 11490 start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "HO %s, cell is %s, Load Report cannot be configured on inter freq neighbor pci: %d",
                (HO_ALLOWED == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].ho_status ? "allowed" : "not allowed"),
                (RRM_FALSE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].blacklisted ? "not blacklisted" : "blacklisted"),
                 p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[target_ncl_cnt].phy_cell_id);
        /* SPR 11490 end */
        ret_val = RRM_FAILURE;
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_cellm_increase_abs 
 * Inputs         : *p_abs_used_by_victim, *p_abs_configured_at_aggr,
                     total_num_of_abs
 * Outputs        : *p_new_abs_pattern 
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function process abs pattern 
 ****************************************************************************/
rrm_bool_et
rrm_cellm_increase_abs
(
 U8   *p_abs_used_by_victim,
 U8   *p_abs_configured_at_aggr,
 U8    total_num_of_abs,
 U8   *p_new_abs_pattern
)
{
    RRM_UT_TRACE_ENTER();
    U8           abs_count      = RRM_ZERO;
    U8           abs_bit        = RRM_ZERO;
    rrm_bool_et  abs_tune_done  = RRM_FALSE;
    U8           is_abs_sent    = RRM_ZERO;
    U8           is_abs_aggrsr  = RRM_ZERO;
    U8           num_of_abs_in_sent_pattern = RRM_ZERO;
    U8           num_of_abs_in_configured_pattern = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(p_new_abs_pattern, p_abs_used_by_victim, RRM_MAX_PATTERN_BYTE);
    
    num_of_abs_in_sent_pattern       = rrm_get_num_of_abs_count(p_abs_used_by_victim,total_num_of_abs);
    num_of_abs_in_configured_pattern = rrm_get_num_of_abs_count(p_abs_configured_at_aggr,total_num_of_abs);

    if( num_of_abs_in_sent_pattern == num_of_abs_in_configured_pattern )
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                  "Maximum possible ABS is already shared .Can't increase it further");
    }
    else
    {
        for(abs_count = RRM_ZERO ; ( (abs_count < total_num_of_abs) &&
                    (abs_tune_done == RRM_FALSE)); abs_count++)
        {
            for(abs_bit = RRM_ZERO; abs_bit < RRM_EIGHT ; abs_bit++)
            {
                is_abs_sent   = p_abs_used_by_victim[abs_count] & ( RRM_ONE_TWENTY_EIGHT >> abs_bit);
                is_abs_aggrsr = p_abs_configured_at_aggr[abs_count] & ( RRM_ONE_TWENTY_EIGHT >> abs_bit);
                /* SPR 14422 start */
                if((RRM_ZERO != is_abs_aggrsr) && (RRM_ZERO == is_abs_sent))
                {
                    /* SPR 14422 end */
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Turn ON abs_bit[%d] at [%d] pos in abs_pattern", abs_bit,abs_count);
                    /* bug_14010_start */  
                    p_new_abs_pattern[abs_count] |= (RRM_ONE_TWENTY_EIGHT >> abs_bit);
                    /* bug_14010_end */  
                    abs_tune_done= RRM_TRUE;
                    break;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return abs_tune_done;
}
/****************************************************************************
 * Function Name  : rrm_cellm_decrease_abs 
 * Inputs         : *p_abs_sent_to_victim, *p_meas_abs_applied,
                     total_num_of_abs
 * Outputs        : *p_new_abs_pattern 
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function process abs pattern 
 ****************************************************************************/
rrm_bool_et
rrm_cellm_decrease_abs
(/*SPR 14400 start*/
            /*SPR 17777 +-*/
 /*SPR 14400 end*/
 U8   *p_abs_sent_to_victim,
 U8   *p_meas_abs_applied,
 U8    total_num_of_abs,
 U8   *p_new_abs_pattern
 )
{
    U8           abs_count     = RRM_ZERO;
    rrm_bool_et  abs_tune_done = RRM_FALSE;
    U8           is_abs_sent   = RRM_ZERO;
    U8           abs_bit        = RRM_ZERO;
    /* SPR 14523 start */
    /*code deleted*/
    /* SPR 14523 end */
    U8           num_of_abs_in_sent_pattern = RRM_ZERO;
    U8            num_of_abs_in_meas_pattern = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    RRM_MEMCPY(p_new_abs_pattern, p_abs_sent_to_victim, RRM_MAX_PATTERN_BYTE);

    num_of_abs_in_sent_pattern = rrm_get_num_of_abs_count(p_abs_sent_to_victim,RRM_MAX_ABS_PATTERN_BYTE_FDD);
    num_of_abs_in_meas_pattern = rrm_get_num_of_abs_count(p_meas_abs_applied,RRM_MAX_ABS_PATTERN_BYTE_FDD);

    if( num_of_abs_in_sent_pattern == num_of_abs_in_meas_pattern)
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "Minimum possible ABS is already shared .Can't decrease it further");
    /* SPR 14523 start */
    /*code deleted*/
    /* SPR 14523 end */
    }
    else
    {
        for(abs_count = RRM_ZERO ; ( (abs_count < total_num_of_abs) &&
                    (abs_tune_done == RRM_FALSE)); abs_count++)
        {
            for(abs_bit = RRM_ZERO; abs_bit < RRM_EIGHT ; abs_bit++)
            {
                is_abs_sent  = p_abs_sent_to_victim[abs_count] & ( RRM_ONE_TWENTY_EIGHT >> abs_bit);
                /* SPR 14421 start */
                if(RRM_ZERO != is_abs_sent)
                {
                    /* SPR 14421 end */
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                            "Turn off abs_bit[%d] at [%d] pos in abs_pattern", abs_bit,abs_count);
                    /* bug_14010_start */  
                    p_new_abs_pattern[abs_count] &= ~(RRM_ONE_TWENTY_EIGHT >> abs_bit);
                    /* bug_14010_end */  
                    abs_tune_done= RRM_TRUE;
                    break;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return abs_tune_done;
}
/****************************************************************************
 * Function Name  : rrm_cellm_tune_abs_pattern
 * Inputs         : rrm_cell_context_t     *p_cell_ctxt
                    
 * Outputs        : tuned abs pattern
 * Returns        : None
 * Description    : This function process abs pattern 
 ****************************************************************************/
rrm_void_t
rrm_cellm_tune_abs_pattern
(
 rrm_cell_context_t     *p_cell_ctxt
)
{

    U8     valid_ncl_count = RRM_ZERO;
    U8     increase_count = RRM_ZERO;
    U8     decrease_count = RRM_ZERO;
    rrm_bool_et   abs_pattern_tuned = RRM_FALSE;
    rrm_x2ap_abs_status_t    *p_rsr_abs_info = RRM_PNULL;
    U8         new_abs_pattern[RRM_MAX_PATTERN_BYTE];
    U8         load_abs_pattern[RRM_MAX_PATTERN_BYTE];
    U8          ncl_count = RRM_ZERO;
    /*EICIC_TDD_CHANGES_START*/
    U8                          abs_size = RRM_ZERO;
    /*EICIC_TDD_CHANGES_END*/
    RRM_UT_TRACE_ENTER();
    /*EICIC_TDD_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    abs_size = rrm_find_abs_frame_size(& p_cell_ctxt->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure);
#else
    abs_size = RRM_MAX_ABS_PATTERN_BYTE_FDD;
#endif
    /*EICIC_TDD_CHANGES_END*/ 
    RRM_MEMSET(new_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(load_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);

    for(ncl_count = RRM_ZERO ; 
            ncl_count < p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;
            ncl_count++)
    {
        if(RRM_EICIC_ABS_PATTERN == 
                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent)
        {
            valid_ncl_count++;
            p_rsr_abs_info = &(p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].
                    resrc_report.abs_status);

            if( ABS_USAGE_UPDATE == p_rsr_abs_info->abs_usage_rep_status )
            {  
                /*SPR 17869 START*/
                if( ( RRM_ABS_INCREASE == p_rsr_abs_info->abs_change_type ) &&
                        (p_cell_ctxt->operator_info.eicic_info.abs_info.num_abs_report <=
                         p_rsr_abs_info->num_abs_report))
                {
                    increase_count++;
                }
                else if( ( RRM_ABS_DECREASE == p_rsr_abs_info->abs_change_type ) &&
                        (p_cell_ctxt->operator_info.eicic_info.abs_info.num_abs_report <=
                         p_rsr_abs_info->num_abs_report))
                {
                    decrease_count++;
                }
                /*SPR 14523 start*/
                else if ( ( RRM_DL_ABS_STATUS_ZERO == p_rsr_abs_info->abs_change_type ) &&
                        (p_cell_ctxt->operator_info.eicic_info.abs_info.num_abs_report <=
                         p_rsr_abs_info->num_abs_report))
                {
                    /*SPR 17869 END*/

                    if(EICIC_LOAD_INFO_SEND_SUCCESS == build_and_send_x2ap_eicic_load_information(
                                p_cell_ctxt,LOAD_INFO_EICIC_ABS_INACTIVE,ncl_count))
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Successfully send ABS inactive with Neighbour[%d]",
                                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.
                            abs_info_sent = RRM_EICIC_ABS_INACTIVE;
                        rrm_hndl_rsu_stop_req_for_ncl(p_cell_ctxt,
                                &(p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count]));
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Successfully send RSU STOP to Neighbour[%d]",
                                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                        /*eICIC_Changes_Start*/
                        /*Bug 783 Changes Start */
                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Resetting  abs_usage_rep_status to  [%d] in case of ABS Inactive.",
                                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status);
                        if (RRM_ZERO !=  p_cell_ctxt->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO])
                        {
                            if( RRM_SUCCESS == rrm_send_rsr_start_req_to_targt_cell(p_cell_ctxt,ncl_count,
                                        p_cell_ctxt->timer_val[CELL_PERIODIC_TIMER_FOR_NEIGH_LOAD_INFO], RRM_FALSE))
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                        "Successfuly sent RSR start req to Target Cell[%d] in case of ABS Inactive",
                                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                            }
                            else
                            {
                                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                                        "Unable to send RSR start req to Target Cell[%d] in case of ABS Inactive",
                                        p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].resrc_report.abs_status.abs_usage_rep_status = ABS_USAGE_NONE;
                            }
                        }
                        /*Bug 783 Changes End */
                        /*eICIC_Changes_End*/
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_BRIEF,
                                "Unable to share ABS inactive with Neighbour[%d]",
                                p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].phy_cell_id);
                    }
                    /*SPR 21277 Fix Start*/
                    for(ncl_count = RRM_ZERO;
                            ncl_count < p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell;
                            ncl_count++)
                    {
                        if((RRM_EICIC_ABS_NOT_SENT == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent) 
                                || (RRM_EICIC_ABS_INACTIVE == p_cell_ctxt->ran_info.ncl_params.lte_ncl.intra_freq_cells[ncl_count].rrm_intra_ncl_eicic_data.abs_info_sent))
                        {
                            continue;
                        }
                        else
                        {
                            break;
                        }
                    }
                    /* abs_pattern_tuned is set to true, because abs_info_sent is set as inactive/not-sent for all the neighbours. 
                     * So ABS pattern needs to be modified that was applied on L2 at aggressor cell*/
                    if (p_cell_ctxt->ran_info.ncl_params.lte_ncl.num_valid_intra_freq_cell == ncl_count)
                    {
                        abs_pattern_tuned = RRM_TRUE;
                    }
                    else
                    {
                        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                                "No need to tune ABS pattern shared with victim");
                    }
                    /*SPR 21277 Fix End*/
                }   
                /*SPR 14523 end*/
            }
        }
    }


    /* SPR 14422 start */
    if( increase_count == valid_ncl_count && valid_ncl_count != RRM_ZERO )
    {
        /* SPR 14422 end */
        /*15003_start*/
        if(RRM_FAILURE != rrm_cellm_get_current_load_abs_pattern(p_cell_ctxt,load_abs_pattern))
        {    
            abs_pattern_tuned = rrm_cellm_increase_abs(
                    p_cell_ctxt->rrm_eicic_cell_info.serving_abs_pattern_applied,
                    load_abs_pattern,
                    abs_size,
                    new_abs_pattern);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    " ABS_PATTERN FOR CURRENT LOAD_LEVEL IS NOT PRESENT ");
        }    
        /*15003_end*/
    }
    /* SPR 14421 start */
    else if( decrease_count  == valid_ncl_count && valid_ncl_count != RRM_ZERO )
    {
        /* SPR 14421 end */
        abs_pattern_tuned = rrm_cellm_decrease_abs(/*SPR 17777 +-*/ 
                p_cell_ctxt->rrm_eicic_cell_info.serving_abs_pattern_applied,
                p_cell_ctxt->rrm_eicic_cell_info.serving_meas_abs_pattern_applied,
                abs_size,
                new_abs_pattern);
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "No need to tune ABS pattern shared with victim");
    }

    if(RRM_TRUE == abs_pattern_tuned)
    {
        /* Send this updated information to MAC */
        /* Send this common ABS pattern to L2 */
        /* bug_13935_start */  

        /* bug_14010_start */  
        RRM_MEMSET(p_cell_ctxt->rrm_eicic_cell_info.temp_srv_abs_pattern,
                RRM_ZERO,RRM_MAX_ABS_PATTERN_BYTE_FDD);
        RRM_MEMCPY(p_cell_ctxt->rrm_eicic_cell_info.temp_srv_abs_pattern,
                new_abs_pattern,abs_size);
        rrm_copy_tdd_bits(abs_size, p_cell_ctxt->rrm_eicic_cell_info.temp_srv_abs_pattern);
        /* bug_14010_end */
        if( RRM_FALSE == rrm_compare_configured_abs_pattern_vd_new_abs(p_cell_ctxt) )
        {
            /* bug_13935_end */  
            if( RRM_FAILURE == build_and_send_l2_cell_config_req( RRM_PNULL,
                        RRM_PNULL,
                        new_abs_pattern,
                        RRM_PNULL,
                        p_cell_ctxt->cell_index,
                        p_cell_ctxt->ongoing_trans_id))
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "Failure returned during the processing of l2_cell_config_req");
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "Success returned during the processing of l2_cell_config_req");
                p_cell_ctxt->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_ABS_PATTERN_FLAG_PRESENT;
                p_cell_ctxt->rrm_eicic_cell_info.reconfig_param_bitmask |= RRM_CTXT_SRV_ABS_RECONFIG_INFO_PRESENT;
                CELL_M_FSM_SET_STATE(p_cell_ctxt,CELL_STATE_UEM_W_FOR_ICIC_ACTION_FRM_UEM_OR_L2);
            }
            /* bug_13935_start */  
        }
        /* bug_13935_end */  
    }

    RRM_UT_TRACE_EXIT();
}
/* _13898_start */ 
/****************************************************************************
 * Function Name  : rrm_print_abs_pattern 
 * Inputs         : *p_abs_pattern
 * Outputs        : NONE 
 * Returns        : NONE
 * Description    : This function print abs pattern 
 ****************************************************************************/
rrm_void_t
rrm_print_abs_pattern
(
  U8 *p_abs_pattern
)
{

	U8 count = RRM_ZERO ; 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
			"ABS Pattern is :-");

	for(count = RRM_ZERO ; count < RRM_MAX_PATTERN_BYTE ; count++)
	{
		RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
				"ABS Pattern [%d] :- [%d]",count,p_abs_pattern[count]);
	}

}
/* 13898_start */  
/* 13972_start */
/****************************************************************************
 * Function Name  : rrm_build_and_send_eicic_load_info_req_to_macro_enb 
 * Inputs         : rrm_cellm_enb_id_hnode_t *p_enb_hnode :pointer 
                                         to nodebId
 *                : rrm_cell_context_t *p_cell_ctxt : pointer
 *                :  to cell context
 * Outputs        : None
 * Returns        : RRM_FAILURE/RRM_SUCCESS
 * Description    : Sends Load Information Req to RRC
 ****************************************************************************/
rrm_return_et
rrm_build_and_send_eicic_load_info_req_to_macro_enb
(
 rrm_cellm_enb_id_hnode_t *p_enb_hnode,
 rrm_cell_context_t       *p_cell_ctxt        /* cell context */
)
{
	rrm_cellm_enb_id_lnode_t          *p_enb_lnode = RRM_PNULL;
    U16                               num_cell = RRM_ZERO;
	rrm_return_et                     ret_val = RRM_SUCCESS;
    rrm_oam_eutran_global_cell_id_t   eutran_global_cell_id_arr[MAX_NUM_CELLS_IN_MACRO_ENB] ;
    /* SPR 14586 Fix start */
    U8                                invoke_index = RRM_ZERO;
    /* SPR 14586 Fix end */

    RRM_MEMSET(&eutran_global_cell_id_arr, 
                RRM_ZERO, 
                (sizeof(rrm_oam_eutran_global_cell_id_t) * MAX_NUM_CELLS_IN_MACRO_ENB));

    RRM_UT_TRACE_ENTER ();

	RRM_ASSERT (RRM_PNULL != p_enb_hnode);

	while (RRM_PNULL != (p_enb_lnode = (rrm_cellm_enb_id_lnode_t *)ylPopHead(&p_enb_hnode->list)))
    {
        if ((RRM_TRUE == p_enb_lnode->enb_info.x2_link_up_status) ||
                (X2_ALLOWED_CONNECTED == p_enb_lnode->enb_info.x2_status))
        {
            RRM_MEMCPY(&eutran_global_cell_id_arr[num_cell],
                    &p_enb_lnode->enb_info.cell_id, sizeof (rrm_oam_eutran_global_cell_id_t));
            num_cell++;
            p_cell_ctxt->rrm_eicic_cell_info.num_x2ap_invoke_ind_sent++;
        }
        RRM_MEM_FREE (p_enb_lnode);
    }
    if (RRM_SUCCESS == ret_val)
    {
        /* SPR 14586 fix start */
        for ( invoke_index = RRM_ZERO; invoke_index < num_cell; invoke_index++ )
        {
            ret_val = rrm_cellm_fill_x2ap_eicic_load_info_ind(
                                p_cell_ctxt,
                                &eutran_global_cell_id_arr[invoke_index],
                                RRM_ENB_TYPE_MACRO,LOAD_INFO_EICIC_INVOKE);
        }
        /* SPR 14586 fix end */
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_WARNING,
                "x2ap_rrm_load_information_req should not be sent to Macro Cell");
    }
    RRM_UT_TRACE_EXIT();
	return ret_val;
}
/****************************************************************************
 * Function Name  : rrm_get_num_of_abs_count 
 * Inputs         : *p_abs_pattern, total_num_of_abs
 * Outputs        : NONE
 * Returns        : U8 type count of abs
 * Description    : This function count abs  
 ****************************************************************************/

U8 rrm_get_num_of_abs_count
(
   U8    *p_abs_pattern,
   U8    total_num_of_abs
)
{
   U8 abs_count   = RRM_ZERO;
   U8 abs_bit = RRM_ZERO;
   U8 num_abs = RRM_ZERO;

   for(abs_count = RRM_ZERO; abs_count < total_num_of_abs ; abs_count++)
   {
       for(abs_bit = RRM_ZERO; abs_bit < RRM_EIGHT ; abs_bit++)
       {
            /* SPR 14422 start */
            if(RRM_ZERO != (p_abs_pattern[abs_count] & (RRM_ONE_TWENTY_EIGHT >> abs_bit)))
            {
                /* SPR 14422 end */
                num_abs++;
            }
       }
   }
   RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
             " Num of ABS is : %d ",num_abs);
   return num_abs;
}
/* bug_13972_end */
/* eICIC_PHASE_1_2_CHANGES_END */
/* CA TDD changes start */

/******************************************************************************
 *   FUNCTION NAME: rrm_cellm_get_scell_tdd_config
 *   DESCRIPTION: Returns tdd config for Scell Index.
 *           
 *   RETURNS: tdd config of Scell
 *       
 ******************************************************************************/
tdd_frame_structure_t rrm_cellm_get_scell_tdd_config
(
 rrm_cell_index_t cell_index
 )
{
    const rrm_cell_context_t* p_rrm_cell_ctx;

    p_rrm_cell_ctx = p_g_rrm_cell_ctx->p_rrm_cell_ctx[cell_index];
    return p_rrm_cell_ctx->ran_info.physical_layer_params.physical_layer_param_tdd_frame_structure;

}
/* CA TDD changes end */

/* SPR 16427 fix start */
/**************************************************************************
 * Function Name  : rrm_get_sr_periodicity_in_ms
 * Inputs         : p_cell_context
 * Outputs        : p_sr_periodicity_ms - SR periodicity in ms
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function returns SR periodicity in ms based on the
 *                  enum
 ****************************************************************************/
rrm_return_et
rrm_get_sr_periodicity_in_ms(
        rrm_cell_context_t *p_cell_context,
        U8 *p_sr_periodicity_ms)
{
    U16 sr_periodicity = RRM_ZERO;
    U16 n_one_pucch_an = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;

    find_sr_periodicity_from_cell_context(p_cell_context,  &sr_periodicity, &n_one_pucch_an);
    switch (sr_periodicity)
    {
        case SR_PERIODICITY_0:
            *p_sr_periodicity_ms = SR_PERIODICITY_5MS;
            break;

        case SR_PERIODICITY_1:
            *p_sr_periodicity_ms = SR_PERIODICITY_10MS;
            break;

        case SR_PERIODICITY_2:
            *p_sr_periodicity_ms = SR_PERIODICITY_20MS;
            break;

        case SR_PERIODICITY_3:
            *p_sr_periodicity_ms = SR_PERIODICITY_40MS;
            break;

        case SR_PERIODICITY_4:
            *p_sr_periodicity_ms = SR_PERIODICITY_80MS;
            break;
            /* SPR 18871 Fix Start */
        case SR_PERIODICITY_5:
            *p_sr_periodicity_ms = SR_PERIODICITY_2MS;
            break;
        case SR_PERIODICITY_6:
            *p_sr_periodicity_ms = SR_PERIODICITY_1MS;
            break;
            /* SPR 18871 Fix End */

        default:
            *p_sr_periodicity_ms = SR_PERIODICITY_10MS;
            ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/**************************************************************************
 * Function Name  : rrm_get_cqi_periodicity_in_ms
 * Inputs         : p_cell_context
 * Outputs        : p_cqi_periodicity_ms - CQI periodicity in ms
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function returns CQI periodicity in ms based on the
 *                  enum
 ****************************************************************************/
rrm_return_et
rrm_get_cqi_periodicity_in_ms(
        rrm_cell_context_t *p_rrm_cell_ctx,
        U8 *p_cqi_periodicity_ms)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U16           cqi_periodicity  = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    find_cqi_periodicity_from_cell_context(p_rrm_cell_ctx, &cqi_periodicity);
    switch (cqi_periodicity)
    {
#ifdef TDD_MODE_FLAG
        case CQI_PERIODICITY_0:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_1MS;
            break;
#else
        case CQI_PERIODICITY_0:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_2MS;
            break;
#endif

        case CQI_PERIODICITY_1:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_5MS;
            break;

        case CQI_PERIODICITY_2:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_10MS;
            break;

        case CQI_PERIODICITY_3:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_20MS;
            break;

        case CQI_PERIODICITY_4:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_40MS;
            break;

        case CQI_PERIODICITY_5:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_80MS;
            break;

        case CQI_PERIODICITY_6:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_160MS;
            break;

        default:
            *p_cqi_periodicity_ms = CQI_PERIODICITY_10MS;
            ret_val = RRM_FAILURE;
            break;

    }

    RRM_UT_TRACE_ENTER();
    return ret_val;
}

/*SPR 22347 Fix Start*/
/**************************************************************************
 * Function Name  : rrm_is_sr_measgap_collide
 * Inputs         : sr_offset, sr_periodicity_ms
 *                  measgap_offset, measgap_periodicity_ms
 * Outputs        : None
 * Returns        : True or False
 * Description    : This function checks if any instance of SR and measgap offset
 *                  collide
 ****************************************************************************/
rrm_bool_et
rrm_is_sr_measgap_collide(
        U8 sr_offset,
        U8 sr_periodicity_ms,
        U8 measgap_offset,
        U8 measgap_periodicity_ms)
{
    RRM_UT_TRACE_ENTER();
    rrm_bool_et ret_val = RRM_FALSE;
    U8 mod_val   = RRM_ZERO;

    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_INFO,
            "sr_offset[%d],sr_periodicity_ms[%d],measgap_offset[%d],measgap_periodicity_ms[%d]",
            sr_offset,sr_periodicity_ms,measgap_offset,measgap_periodicity_ms);

    if (sr_periodicity_ms < measgap_periodicity_ms)
    {
        mod_val = sr_periodicity_ms;
    }
    else 
    {
        mod_val = measgap_periodicity_ms;
    }
    if ((sr_offset % mod_val) == (measgap_offset % mod_val)) 
    {
        ret_val = RRM_TRUE;

    }
    else if(((measgap_offset + RRM_FIVE) % mod_val) >= sr_offset)
    {
        ret_val = RRM_TRUE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/*SPR 22347 Fix Stop*/

/**************************************************************************
 * Function Name  : rrm_is_sr_cqi_collide
 * Inputs         : sr_sub_frame_offset, sr_periodicity_ms
 *                  cqi_sub_frame_offset, cqi_periodicity_ms
 * Outputs        : None
 * Returns        : True or False
 * Description    : This function checks if any instance of SR and CQI offset
 *                  collide
 ****************************************************************************/
rrm_bool_et
rrm_is_sr_cqi_collide(
        U8 sr_sub_frame_offset,
        U8 sr_periodicity_ms,
        U8 cqi_sub_frame_offset,
        U8 cqi_periodicity_ms)
{
    RRM_UT_TRACE_ENTER();
    rrm_bool_et ret_val = RRM_FALSE;

    if (sr_periodicity_ms < cqi_periodicity_ms)
    {
        if (sr_sub_frame_offset == (cqi_sub_frame_offset % sr_periodicity_ms))
        {
            ret_val = RRM_TRUE;
        }
    }
    else if (sr_periodicity_ms > cqi_periodicity_ms)
    {
        if ((sr_sub_frame_offset % cqi_periodicity_ms) == cqi_sub_frame_offset)
        {
            ret_val = RRM_TRUE;
        }
    }
    else
    {
        if (sr_sub_frame_offset == cqi_sub_frame_offset)
        {
            ret_val = RRM_TRUE;
        }
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* SPR 16427 fix end */
/*SPR 16477 Fix Start*/
/**************************************************************************
 * Function Name  : rrm_cellm_add_gummei_info_to_enb_context 
 * Inputs         : mme_id
 *                : p_connected_mme_gummei_info
 * Outputs        : rrm_connected_mme_node_t *
 * Returns        : pointer to rrm_connected MME node
 * Description    : cellmanager add the connected mme node in global list. 
 ****************************************************************************/
rrm_return_et
rrm_cellm_add_gummei_info_to_enb_context
(
    U8                                      mme_id,
    rrm_connected_mme_gummei_info_t         *p_connected_mme_gummei_info
)
{
    rrm_connected_mme_node_t            *p_rrm_connected_mme_node = RRM_PNULL;
    rrm_return_et                       ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    p_rrm_connected_mme_node = (rrm_connected_mme_node_t *)rrm_mem_get(sizeof(rrm_connected_mme_node_t));

    if(RRM_PNULL != p_rrm_connected_mme_node)
    {
        p_rrm_connected_mme_node->mme_key_id = mme_id;
        RRM_MEMCPY(&(p_rrm_connected_mme_node->connected_gummei_info),
                   p_connected_mme_gummei_info,
                   sizeof(rrm_connected_mme_gummei_info_t));
        ylPushTail(&(p_g_rrm_cell_ctx->enb_context.connected_mme_list),
                   &(p_rrm_connected_mme_node->s_node));
        ret_val = RRM_SUCCESS;
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
                  "RRM connected mme node allocation is failed");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/**************************************************************************
 * Function Name  : rrm_cellm_mme_id_key 
 * Inputs         : p_ylnode 
 * Outputs        : const void *
 * Returns        : pointer to mme key node
 * Description    : Function pointer to get the mme_key_id
 ****************************************************************************/
const void *
rrm_cellm_mme_id_key
(
    const YLNODE    *p_ylnode
)
{
    return  &(((rrm_connected_mme_node_t *)p_ylnode)->mme_key_id);
}
/**************************************************************************
 * Function Name  : rrm_cellm_mme_id_data_key_compare 
 * Inputs         : p_key_1
 *                  p_key_2
 * Outputs        : SUCCESS/FAILURE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : callback to compare the mme id.
 ****************************************************************************/
int
rrm_cellm_mme_id_data_key_compare
(
    const rrm_void_t        *p_key_1,
    const rrm_void_t        *p_key_2
)
{
    if(*(U8 *)p_key_1 == *(U8 *)p_key_2)
    {
        return RRM_FAILURE;
    }
    else
    {
        return RRM_SUCCESS;
    }
}
/**************************************************************************
 * Function Name  : rrm_cellm_search_gummei_info_in_global_list 
 * Inputs         : mme_id
 * Outputs        : rrm_connected_mme_node_t *
 * Returns        : pointer to connected mme_node
 * Description    : cellmanager search for connected mme node based on key
 *                  mme_id.
 ****************************************************************************/
rrm_connected_mme_node_t *
rrm_cellm_search_connected_mme_node_in_global_list
(
    U8              mme_id
)
{
    rrm_connected_mme_node_t            *p_rrm_connected_mme_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrm_connected_mme_node = (rrm_connected_mme_node_t *)ylFind(&(p_g_rrm_cell_ctx->enb_context.connected_mme_list),
                                                                  &mme_id,
                                                                  rrm_cellm_mme_id_key,
                                                                  rrm_cellm_mme_id_data_key_compare);
    RRM_UT_TRACE_EXIT();
    return p_rrm_connected_mme_node;
}
/**************************************************************************
 * Function Name  : rrm_rrc_s1ap_mme_info_process_msg
 * Inputs         : p_api,
 *                : api_id
 *                : data_len
 * Outputs        : NONE
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : processs S1AP MME information
 ****************************************************************************/
rrm_return_et
rrm_rrc_s1ap_mme_info_process_msg
(
    U8      *p_api,     /* Pointer to incoming API buffer */
    U16     data_len   /* Incoming data length */
            /*SPR 17777 +-*/
)
{
    rrm_return_et                               ret_val = RRM_SUCCESS;
    s1ap_rrm_mme_info_t                         s1ap_rrm_mme_info = {RRM_ZERO};
    S32                                         length = RRM_ZERO;
    rrm_connected_mme_list_t                    *p_rrm_connected_mme_list = RRM_PNULL;
    rrm_connected_mme_node_t                    *p_rrm_connected_mme_node = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    p_rrm_connected_mme_list = &(p_g_rrm_cell_ctx->enb_context.connected_mme_list);
    /* Parse the incoming message form RRC */
    if(RRM_FAILURE != rrm_il_parse_s1ap_rrm_mme_info(&s1ap_rrm_mme_info,
                                                      p_api,
                                                      data_len,
                                                      &length))
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_INFO,
                  "RRC->RRM:S1AP_RRM_MME_INFO successfully parsed");
        if((ylCount(p_rrm_connected_mme_list) == RRM_ZERO))
        {
            /* Check served GUMMEI information is present or not */
            if(S1AP_SERVED_GUMMEI_INFO_PRESENT & s1ap_rrm_mme_info.mme_info.bitmask)
            {
                /*Add the GUMMEI information info to enb context*/
                ret_val = rrm_cellm_add_gummei_info_to_enb_context(s1ap_rrm_mme_info.mme_id,
                                                                    &s1ap_rrm_mme_info.mme_info.\
                                                                    served_gummei_info);
                if(RRM_SUCCESS == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Successfully added connected mme GUMMEI information");
                }
            }
            else
            {
                RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                          "GUMMEI information does not exist for connected MME");
            }
        }
        else
        {
            /* Check served GUMMEI information is present or not */
            if(S1AP_SERVED_GUMMEI_INFO_PRESENT & s1ap_rrm_mme_info.mme_info.bitmask)
            {
                /*SPR_18624_START*/
                p_rrm_connected_mme_node = rrm_cellm_search_connected_mme_node_in_global_list(s1ap_rrm_mme_info.mme_id);

                if(RRM_PNULL != p_rrm_connected_mme_node)
                {
                    RRM_MEMCPY(&(p_rrm_connected_mme_node->connected_gummei_info),
                                &s1ap_rrm_mme_info.mme_info.served_gummei_info,
                                sizeof(rrm_connected_mme_gummei_info_t));
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Successfully replaced connected mme GUMMEI information of mme_id [%d]",
                             s1ap_rrm_mme_info.mme_id);
                }
                else
                {
                /*Add the GUMMEI information info to enb context*/
                ret_val = rrm_cellm_add_gummei_info_to_enb_context(s1ap_rrm_mme_info.mme_id,
                                                                    &s1ap_rrm_mme_info.mme_info.\
                                                                    served_gummei_info);
                if(RRM_SUCCESS == ret_val)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
                            "Successfully added connected mme GUMMEI information");
                }

               }
                /*SPR_18624_END*/
            }
            else
            {
                p_rrm_connected_mme_node = rrm_cellm_search_connected_mme_node_in_global_list(s1ap_rrm_mme_info.mme_id);

                if(RRM_PNULL != p_rrm_connected_mme_node)
                {
                    ylDelete(p_rrm_connected_mme_list,&p_rrm_connected_mme_node->s_node);
                    RRM_MEM_FREE(p_rrm_connected_mme_node);
                }
            }
        }
    }
    else
    {
        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_ERROR,
                  "RRC_>CellM:S1AP_RRM_MME_INFO failed to parse");
        ret_val = RRM_FAILURE;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/* SPR_21459 Fix - Start */
/**************************************************************************
 * Function Name  : rrm_checks_for_x2_ho_based_on_gummei_info
 * Inputs         : p_enb_gu_group_id_list
 *                : p_connected_mme_list
 *                : p_rrc_rrm_ho_required
 * Outputs        : RRM_TRUE/RRM_FALSE
 * Returns        : RRM_TRUE/RRM_FALSE
 * Description    : This function checks for exact match source and target
 *                  GUMMEI
 ****************************************************************************/
rrm_bool_et
rrm_checks_for_x2_ho_based_on_gummei_info
(
    rrm_gu_group_id_list_t      *p_enb_gu_group_id_list,
    rrm_connected_mme_list_t    *p_connected_mme_list,
    rrc_rrm_ho_required_t       *p_rrc_rrm_ho_required,
    U8                          mme_id
)
/* SPR_21459 Fix - End */
{
    rrm_gu_group_id_node_t                  *p_enb_gu_group_id_node = RRM_PNULL;
    rrm_connected_mme_node_t                *p_mme_id_node = RRM_PNULL;
    rrm_bool_et                             is_x2_ho = RRM_FALSE;
    rrm_bool_et                             is_plmn_matched = RRM_FALSE;
    rrm_bool_et                             is_mmegi_matched = RRM_FALSE;
    U8                                      served_gummei_index = RRM_ZERO;
    U8                                      served_plmn_index = RRM_ZERO;
    /* SPR_17367_Start */
    U8                                      temp_plmnid_1[MAX_PLMN_ID_BYTES] = {RRM_ZERO};
    /* SPR_17367_End */
    rrm_oam_cell_plmn_info_t *p_input_plmn = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /* SPR_21459 Fix - Start */
    /* Compare MME ID (stored in UE context, received at the time of Attach/Hand IN
     * with MME Node Key ID, If equal check other info, else traverse next Node */
    p_mme_id_node = (rrm_connected_mme_node_t *)ylFirst(p_connected_mme_list);
    while(p_mme_id_node)
    {
        if (mme_id == p_mme_id_node->mme_key_id)
        {
            for(served_gummei_index = RRM_ZERO;
                    served_gummei_index < p_mme_id_node->connected_gummei_info.num_served_group_ids;
                    served_gummei_index++)
            {
                p_enb_gu_group_id_node = (rrm_gu_group_id_node_t *)ylFirst(p_enb_gu_group_id_list);
                while(p_enb_gu_group_id_node)
                {
                    if(!(RRM_MEMCMP(&p_mme_id_node->connected_gummei_info.\
                                    served_group_id[served_gummei_index].mmegi,
                                    &p_enb_gu_group_id_node->mme_group_id_key.mme_group_id,
                                    MAX_MME_GRP_BYTES)))
                    {
                        RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name,RRM_DETAILED,
                                "source GUMMEI [%d%d] matched with target GUMMEI[%d%d]",
                                p_mme_id_node->connected_gummei_info.served_group_id[served_gummei_index].mmegi[RRM_ZERO],
                                p_mme_id_node->connected_gummei_info.served_group_id[served_gummei_index].mmegi[RRM_ONE],
                                p_enb_gu_group_id_node->mme_group_id_key.mme_group_id[RRM_ZERO],
                                p_enb_gu_group_id_node->mme_group_id_key.mme_group_id[RRM_ONE]);
                        is_mmegi_matched = RRM_TRUE;
                        break;
                    }
                    p_enb_gu_group_id_node = (rrm_gu_group_id_node_t *)ylNext(&p_enb_gu_group_id_node->s_node);
                }
                if(RRM_TRUE == is_mmegi_matched)
                {
                    break;
                }
            }
            for(served_plmn_index = RRM_ZERO;
                    served_plmn_index < p_mme_id_node->connected_gummei_info.num_served_plmns;
                    served_plmn_index++)
            {
                p_enb_gu_group_id_node = (rrm_gu_group_id_node_t *)ylFirst(p_enb_gu_group_id_list);
                while(p_enb_gu_group_id_node)
                {
                    p_input_plmn = (rrm_oam_cell_plmn_info_t *)&p_enb_gu_group_id_node->mme_group_id_key.plmn_id;
                    /* Decode the plmnid received S1AP RRM MME INFO */
                    rrm_plmnid_from_mcc_mnc(temp_plmnid_1,p_input_plmn);
                    /* SPR_17367_Start */
                    if(!RRM_MEMCMP(temp_plmnid_1,
                        p_mme_id_node->connected_gummei_info.plmn_identity[served_plmn_index].plmn_id,
                        MAX_PLMN_ID_BYTES))
                    {
                        is_plmn_matched = RRM_TRUE;
                        break;
                    }
                    /* SPR_17367_End */
                    p_enb_gu_group_id_node = (rrm_gu_group_id_node_t *)ylNext(&p_enb_gu_group_id_node->s_node);
                }
                if(RRM_TRUE == is_plmn_matched)
                {
                    break;
                }
            }
            /* coverity_fix 88581 ++ */
            if((RRM_TRUE == is_plmn_matched) && (RRM_TRUE == is_mmegi_matched) && (PNULL != p_enb_gu_group_id_node))
            /* coverity_fix 88581 -- */
            {
                p_rrc_rrm_ho_required->bitmask |= RRC_RRM_UE_HO_REQUIRED_GUMMEI_INFO_PRESENT;
                p_rrc_rrm_ho_required->gummei_info.plmn_identity.presence_bitmask |= PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.plmn_identity.mcc,
                        &p_enb_gu_group_id_node->mme_group_id_key.plmn_id.mcc,
                        MAX_MCC_DIGITS);

                p_rrc_rrm_ho_required->gummei_info.plmn_identity.mnc.count =
                    p_enb_gu_group_id_node->mme_group_id_key.plmn_id.num_mnc_digit;

                RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.plmn_identity.mnc.mnc,
                        &p_enb_gu_group_id_node->mme_group_id_key.plmn_id.mnc,
                        p_enb_gu_group_id_node->mme_group_id_key.plmn_id.num_mnc_digit);

                RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.mme_group_id,
                        &p_enb_gu_group_id_node->mme_group_id_key.mme_group_id,
                        MAX_MME_GRP_BYTES);

                RRM_MEMCPY(&p_rrc_rrm_ho_required->gummei_info.mmec,
                        &p_mme_id_node->connected_gummei_info.served_mmec[RRM_ZERO].mmec,
                        sizeof(U8));
                is_x2_ho = RRM_TRUE;
            }
        }
        /* SPR_21459 Fix - End */
        if(RRM_TRUE == is_x2_ho)
        {
            break;
        }
        else
        {
            p_mme_id_node = (rrm_connected_mme_node_t *)ylNext(&p_mme_id_node->s_node);
        }
    }
    RRM_UT_TRACE_EXIT();
    return is_x2_ho;
}
/*SPR 16477 Fix Stop*/
/* SPR_17367_Start */
/**************************************************************************
 * Function Name  : rrm_cellm_is_trgt_enb_associated_with_source_plmn
 * Inputs         : p_plmn_id
 *                : p_connected_mme_list
 * Outputs        : None
 * Returns        : RRM_TRUE/RRM_FALSE 
 * Description    : This function checks if the PLMN of the target eNB matches with the PLMN of source connected MMEs.
 *                  if it matches then it returns true else false
 ****************************************************************************/
rrm_bool_et rrm_cellm_is_trgt_enb_associated_with_source_plmn(
    rrm_oam_cell_plmn_info_t *p_plmn_id,
    rrm_connected_mme_node_t *p_rrm_connected_mme_node)
{
    U8 i = RRM_ZERO;
    U8 convt_plmn[MAX_PLMN_ID_BYTES] = {RRM_ZERO};

    RRM_UT_TRACE_ENTER();

    rrm_plmnid_from_mcc_mnc(convt_plmn, p_plmn_id);
    for (i = RRM_ZERO; i < p_rrm_connected_mme_node->connected_gummei_info.num_served_plmns; i++)
    {
        if (!RRM_MEMCMP(convt_plmn, p_rrm_connected_mme_node->connected_gummei_info.plmn_identity[i].plmn_id, MAX_PLMN_ID_BYTES))
        {
            RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name, RRM_BRIEF,
                    "PLMN ID [0x%x%x%x] at Idx[%d] match with MME Id[%d]", convt_plmn[RRM_ZERO], 
                    convt_plmn[RRM_ONE], convt_plmn[RRM_TWO], i, p_rrm_connected_mme_node->mme_key_id);
            RRM_UT_TRACE_EXIT();
            return RRM_TRUE;
        }
    }

    RRM_TRACE(g_cellm_log_on_off,p_rrm_cellm_facility_name, RRM_WARNING,
            "PLNM ID [0x%x%x%x] does not match with MME Id[%d]", convt_plmn[RRM_ZERO],
            convt_plmn[RRM_ONE], convt_plmn[RRM_TWO], p_rrm_connected_mme_node->mme_key_id);

    RRM_UT_TRACE_EXIT();
    return RRM_FALSE;
}
/* SPR_17367_End */
#ifdef LTE_EMBMS_SUPPORTED
    
rrm_bool_et
rrm_cellm_check_mbms_sf
(
    U8    cqi_offset
)
{
    U8            count = RRM_ZERO;
    rrm_bool_et   ret_val = RRM_FALSE;
    RRM_UT_TRACE_ENTER();
#ifndef TDD_MODE_FLAG
    for( count = RRM_ZERO; count < RRM_SIX ; count++)
    {
        if ( cqi_offset == mbms_sf_list_fdd[count])
        {
            ret_val = RRM_TRUE;
            break;
        }
    }
#else
    for( count = RRM_ZERO; count < RRM_FIVE ; count++)
    {
        if ( cqi_offset == mbms_sf_list_tdd[count])
        {
            ret_val = RRM_TRUE;
            break;
        }
    }
#endif
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

#endif

/*SPR 18994 START*/
void  
    rrm_set_report_charaterstics
(
 U32 *p_report_characteristics,
 rrm_report_characteristics_et characteristics
 )
{
    RRM_UT_TRACE_ENTER();
    *p_report_characteristics |= (RRM_ONE << (RRM_THIRTY_ONE - characteristics));
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Final value of *report_characteristics= %x", *p_report_characteristics);
    RRM_UT_TRACE_EXIT();
}    

rrm_bool_et
    rrm_check_set_report_charaterstics
(
 U32 *p_report_characteristics,
 rrm_report_characteristics_et characteristics
 )          
{       
    RRM_UT_TRACE_ENTER();
    /* SPR 18994 Fix Start */
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Value of Characterstic %d present in report_characteristics %x = %x",
            characteristics, *p_report_characteristics, (RRM_ONE << (RRM_THIRTY_ONE - characteristics)));
    /* SPR 18994 Fix End */
    RRM_UT_TRACE_EXIT();
    /* Coverity CID 110894 Fix Start */
    if (*p_report_characteristics & (RRM_ONE << (RRM_THIRTY_ONE - characteristics)))
    {
        return RRM_TRUE;
    }
    else
    {
        /* SPR 21251 Start */
        RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_ERROR,
                "report characheristic not set");
        /* SPR 21251 End */
        return RRM_FALSE;
    }
    /* Coverity CID 110894 Fix End */
} 

void
    rrm_reset_report_charaterstics
(
 U32 *p_report_characteristics,
 rrm_report_characteristics_et characteristics
 )          
{       
    RRM_UT_TRACE_ENTER();
    *p_report_characteristics &= ~(RRM_ONE << (RRM_THIRTY_ONE - characteristics));
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Final value of *report_characteristics= %x",*p_report_characteristics);
    RRM_UT_TRACE_EXIT();
}

void 
    rrm_rearrange_report_characteristics_bits
(
 U32 *p_report_characteristics
 )
{
    U32 start = RRM_ZERO;
    U32 last = RRM_THIRTY_ONE;
    U32 final_report_characteristics = RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Previous value of *report_characteristics= %x",*p_report_characteristics);
    while(start < last)
    {
        final_report_characteristics |= ((( *p_report_characteristics >> last) & RRM_ONE) << start);
        final_report_characteristics |= ((( *p_report_characteristics >> start) & RRM_ONE) << last);
        start++;
        last--;
    }
    *p_report_characteristics = final_report_characteristics;
    RRM_TRACE(g_cellm_log_on_off, p_g_rrm_cellm_facility_name, RRM_DETAILED,
            "Final value of *report_characteristics= %x",*p_report_characteristics);
    RRM_UT_TRACE_EXIT();
}    



/*SPR 18994 END*/
