/* vim: ts=4:et:ai:ci:sw=4
*/
/****************************************************************************
 *
 *  ARICENT GROUP
 *
 *  Copyright (C) 2012 Aricent Inc. All Rights Reserved.
 *
 ****************************************************************************
 * File Details
 * ------------
 *  $$Id: rrm_mif_interface.c $
 ****************************************************************************
 *
 *  File Description :
 *      This file contains contains the interface functions for the
 *      MIF modules
 *
 ****************************************************************************
 *
 *  Revision Details
 * ----------------
 *
 * DATE         AUTHOR          REFERENCE              REASON
 * 2012/01/31   gur29990        Inital
 * 2013/01/29   gur27278                              Added code for SPS feature
 * 2013/03/21   gur29220        SPR 5692            Fixed Access Class Barring 
 *                                                  Functionality in Sib-2
 * 2013/04/17   gur29220        SPR 5883            Measurement gap pattern gp1 
 *                                                  is not getting configured
 * 2013/04/17   gur29220        SPR 5882            B2 not configured when A2
 *                                                  measurement is received by RRM
 * 2013/04/22   gur29220        SPR 6008            Sys_time_info was absent
 * 2013/05/15   gur11056        SPR 490             Min Bit Rate per QCI for ngbr
 * 2014/05/05   gur29990        SPR-10949           Bug Fixed.
 * 2014/05/28   gur26991        SPR-11442           Lots of warnings are 
 *                                                  observed in RRM logs
 * 2014/06/06   gur29990        SPR-11575           SIB 4 broadcast issue fix
 * 2014/06/06   gur29990        SPR-11317           OLPC Redesigned
 * 2014/06/1    gur13083        SPR 10811           RRM was crashing during
 *                                                  handling of RRM_OAM_RAC_ENABLE_DISABLE_REQ
 * 2014/05/05   gur29990        SPR-10949           Bug Fixed.
 * 2014/05/27   gur29831        SPR-11366           Bug Fixed.
 * 2014/05/28   gur26991        SPR-11442           Lots of warnings are 
 *                                                  observed in RRM logs
 * 2014/03/01   gur32417        CA STG 3            Carrier Aggrigation Stage 3 
 *                                                  code changes.
 * 2014/06/06   gur26515        SPR 10730           Added code changes for SPR 10730
 * 2014/06/19   gur35095        SPR 11769           CSR 00082391 Fix
 * 17 Jun,2014  gur30784        SPR 11564           DL forwarding list population
 * 13 Jun 2014  gur27356        SPR 10489           Support additional causes in RWR.
 * 20 Jun 2014  gur21481        SPR 11977           mapping of param pucch_cqi_sinr 
 *                                                  for cell config was missing 
 * 2 July,2014  gur25767        SPR 10498           Inter-freq Daho Support
 * 2014/06/20   gur34951        SPR 10329           Enhancement of GU GROUP ID
 * 2 July,2014  gur25767        SPR 10498           Inter-freq Daho Support
 * 7 July,2014  gur30784        SPR 11831           PCI updation for GERAN cells
 * 28 July,2014 gur30784        SPR 12796           Cell state change ind for Rach 
 * 28 Aug,2014  gur35932        SPR 13113           Incorrect Assignment for CSFB
 * 03 March 2016   RAVIP      Bug-4397/18936 - q_qual_min_r9 should not be included if not configured from OAM
 ****************************************************************************/

/****************************************************************************
 * Header File Includes 
 ****************************************************************************/
#include "rrm_stats.h"
#include "rrm_mif_msg_handler.h"
#include "rrm_uem_rrmim_intf.h"
#include "rrm_son_composer.h"
#include "rrm_mem_utils.h"
#include "rrm_utils.h"
#include "rrm_defines.h"
#include "rrm_event_defines.h"
#ifdef LTE_EMBMS_SUPPORTED
#include "rrm_mif_embms_proto.h"

/****************************************************************************
 * Exported Variables/Functions
 ****************************************************************************/
#endif

/** function prototypes */
extern 
rrm_void_t
rrm_fill_intra_rat_ncl_params_for_cellm
(
    rrmcm_rmif_intra_rat_neighbor_cell_list_t *p_out_intra_cell,
        son_rrm_intra_rat_neighbor_cell_list_t *p_in_intra_cell
);

rrm_void_t
rrm_fill_intra_rat_neighbor_list
(
 U8 list_size,
 rrmcm_rmif_intra_rat_neighbor_list_t *p_out_ncl_list,
 son_rrm_intra_rat_neighbor_list_t    *p_in_ncl_list
 );
#ifdef LTE_EMBMS_SUPPORTED
extern
rrm_void_t
    rrm_fills_mbsfn_info_from_son
(
 U8 count,
 rrmcm_mbsfn_config_info_t *p_out_mbsfn_config,
 son_mbsfn_info_t          *p_in_mbsfn_info
 );
#endif
#define MIF_INVALID_TRANS_ID     0xFFFF
#define STARTING_POWER_SIGNAL    60
#define POWER_SIGNAL_IN_ONE_DB   100


/* function prototype of event raise function */
void rrm_raise_event_cell_setup_reject(U16 fail_cause);
/* SPR 15393 Fix Start */
rrm_void_t rrm_populate_geran_neighbour_list(rrmcm_rmif_updated_nrt_info_t *p_out_updated_nrt_info_msg,son_anr_rrm_updated_nrt_info_t *p_in_updated_nrt_info_msg);
/* SPR 15393 Fix Stop */
static rrmcm_rmif_cell_x2_status_et 
	rrm_son_x2_status_enum_mapping
(
 son_x2_status_et son_x2_status
 );


/*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
/***********************************************************************
 * Function Name  : son_cellm_attribute_id_mapping
 * Inputs         : -son_attr_id - attribute id from SON
 * Outputs        : attribute id for cellm 
 * Returns        : rrm_attr_id_et
 * Description    : This function maps son attribute id to cellm 
 attribute id
 **********************************************************************/
    static rrm_cellm_attribute_id_et son_cellm_attribute_id_mapping
( rrm_attr_id_et son_attr_id )
{
    RRM_UT_TRACE_ENTER();
    rrm_cellm_attribute_id_et cellm_attr_id;

    switch(son_attr_id)
    {
        case RRM_ATTR_CELL_STATE :
            cellm_attr_id = RRM_MIF_CELLM_ATTR_CELL_STATE;
            break;

        case RRM_ATTR_ACTIVE_UE_COUNT_REPORT :
            cellm_attr_id = RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT;
            break;

        case RRM_ATTR_ACTIVE_UE_THRESHOLD :
            cellm_attr_id = RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD;
            break;

        case RRM_ATTR_S1_MSG_NOTIFICATION :
            cellm_attr_id = RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION;
            break;

            /* UE MEAS CHANGES : STARTS */
        case RRM_ATTR_MEAS_UE_COUNT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT;
            break;

        case RRM_ATTR_MEAS_REPORTING_INTERVAL:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL;
            break;
            /* UE MEAS CHANGES : ENDS */
        case RRM_ATTR_HO_REPORT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_HO_REPORT;
            break;
            /* MRO code changes start */
            /* MRO: Added cases for HO Attempt indication and HO failure report */
        case RRM_ATTR_HO_ATTEMPT_IND:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND;
            break;
            /* MRO code changes end */

        case RRM_ATTR_HO_FAILURE_REPORT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT;
            break;

            /* MLB Changes start */
        case RRM_ATTR_NEIGHBOR_LOAD_REPORT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_MLB_NBR;
            break;

        case RRM_ATTR_LOAD_REPORT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_MLB_SELF;
            break;

            /* MLB Changes end */
            /* RRM ES Start */
        case RRM_ATTR_SRV_CELL_LOAD_REPORT:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_ES_LD_SELF;
            break;
            /* RRM ES End */
            /* LTE_RRM_MALL, CID 11121 */
            /* SPR 20653 Fix Start */
        case RRM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD;
            break;

        case RRM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD:
            cellm_attr_id = RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD;
            break;
            /* SPR 20653 Fix End */
        case RRM_ATTR_UNDEF:
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                    RRM_DETAILED, "Bitmask RRM_ATTR_UNDEF is present");
            /* Fix for Coverity, LTE_RRM_MALL:CID:11121 [Prasant] */
            cellm_attr_id = RRM_MIF_CELLM_ATTR_UNDEF;
            break;
        default:
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                    RRM_ERROR,"attribute not defined:%d",son_attr_id);
            cellm_attr_id = RRM_MIF_CELLM_ATTR_UNDEF;
            break;
    }

    RRM_UT_TRACE_EXIT();
    return cellm_attr_id;
}

/***********************************************************************
 * Function Name  : fill_cellm_trigger_type
 * Inputs         : -p_out_cell_register_req- msg to be sent to CellM 
 *                  -p_in_cell_register_req_msg- msg received from SON
 * Outputs        : None 
 * Returns        : void
 * Description    : fills cell_m trigger type in req msg corresponding 
 to incoming son trigger type
 *********************************************************************/
    static void fill_cellm_trigger_type 
(
 rrmcm_rmif_cell_son_register_deregister_req_t* p_out_cell_register_req ,
 rrm_son_register_req_t* p_in_cell_register_req_msg,
 U8 attrListCnt
 )
{
    U8                                      triggerListCnt = 0;

    RRM_UT_TRACE_ENTER();
    for (triggerListCnt = 0; triggerListCnt <
            p_out_cell_register_req->attribute_list[attrListCnt].
            trigger_list; triggerListCnt++)
    {

        switch(p_in_cell_register_req_msg->register_req.object.p_attr_lst
                [attrListCnt].trgr_list[triggerListCnt].id)
        {
            case RRM_TRGR_PERIODIC:
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_PERIODIC;
                if (p_in_cell_register_req_msg->register_req.object.
                        p_attr_lst[attrListCnt].trgr_list[triggerListCnt].bitmask & RRM_TRIGGER_TYPE_PERIODIC)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_PERIODIC is present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.periodic =
                        p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].
                        periodic.interval;
                }
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_PERIODIC is not present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.periodic = 0;

                }
                break;
            case RRM_TRGR_THRESHOLD:
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_THRESHOLD;

                if (p_in_cell_register_req_msg->register_req.object.
                        p_attr_lst[attrListCnt].trgr_list[triggerListCnt].bitmask & RRM_TRIGGER_TYPE_THRESHOLD)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_THRESHOLD is present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.threshold =
                        p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].threshold.count;
                }
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_THRESHOLD is not present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.threshold = 0;
                }
                break;
            case RRM_TRGR_EVENT:
                p_out_cell_register_req->attribute_list[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_EVENT;
                if (p_in_cell_register_req_msg->register_req.object.
                        p_attr_lst[attrListCnt].trgr_list[triggerListCnt].bitmask & RRM_TRIGGER_TYPE_EVENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_EVENT is present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.event =
                        p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].
                        event.enable;
                }
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_EVENT is not present");
                    p_out_cell_register_req->attribute_list[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.event = 0;
                }
                break;
                /* LTE_RRM_MALL, CID 11120 */
            case RRM_TRGR_UNDEF:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "Bitmask RRM_TRIGGER_TYPE_UNDEF is not present");
                p_out_cell_register_req->attribute_list[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id = RRM_MIF_CELLM_TRGR_UNDEF;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "Trigger type[%u] is invalid", 
                        p_in_cell_register_req_msg->register_req.object.p_attr_lst
                        [attrListCnt].trgr_list[triggerListCnt].id);
                p_out_cell_register_req->attribute_list[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id = RRM_MIF_CELLM_TRGR_UNDEF;
                break;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : build_and_send_init_config_req_to_mif
 * Inputs         : -p_gl_ctxt- Global Context of MIF 
 *                  -log_level_from_oam- Log level received from OAM 
 *                  -log_on_off_val_from_oam- Log Enable/Disable
 * Outputs        : None 
 * Returns        : void
 * Description    : build init config request for cellm using parameters from OAM
 ****************************************************************************/
static void
build_and_send_init_config_req_to_mif 
(rrm_mif_gb_context_t * p_gl_ctxt,
 rrm_oam_log_level_et
 log_level_from_oam, rrm_oam_log_on_off_et log_on_off_val_from_oam)
{
    rrm_oam_log_on_off_et log_on_off = RRM_OAM_LOG_ON;
    rrm_oam_log_level_et log_level = RRM_OAM_BRIEF;

    RRM_UT_TRACE_ENTER();
    switch (log_on_off_val_from_oam)
    {
        case RRM_OAM_LOG_ON:
            log_on_off = RRM_OAM_LOG_ON;
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "LOG Enabled: RRM_TRUE");
            break;

        case RRM_OAM_LOG_OFF:
            log_on_off = RRM_OAM_LOG_OFF;
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "LOG Enabled: RRM_FALSE");
            break;

        default:
            log_on_off = RRM_OAM_LOG_ON;
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "LOG Enabled: (Using Default)");
            break;
    }
    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "DEBUG: LogLevel(%d) from OAM", log_level_from_oam);

    if(log_level_from_oam > RRM_OAM_DETAILEDALL) /*kshitij Coverity, CID 15853 */
    {
        log_level = RRM_OAM_BRIEF;
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                "Invalid Log Level(%d). Using BRIEF as default", log_level_from_oam);
    }
    else
        log_level = log_level_from_oam;

    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Loog Level(%d) Log On/Off(%d)", log_level, log_on_off);

    rrm_mif_log_enable_disable_cmd (p_gl_ctxt, log_on_off, log_level);

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : build_and_send_init_config_req_to_cellm
 * Inputs         : -oam_log_level- Log level received from OAM
 *                  -oam_log_on_off_val- Log Enable/Disable
 *                  -trans_id - Transaction ID of request 
 * Outputs        : None 
 * Returns        : void
 * Description    : build init config request for cellm using parameters from OAM
 ****************************************************************************/
static void build_and_send_init_config_req_to_cellm
(
 rrm_oam_log_level_et oam_log_level , 
 rrm_oam_log_on_off_et oam_log_on_off_val,
 /* Spr 16211 Changes Start*/
 U16 trans_id,
 rrm_bool_et rim_enable_disable
 /* Spr 16211 Changes End*/
 )
{
    rrmcm_rmif_init_config_req_t   *p_out_init_config_req_to_cellm = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_out_init_config_req_to_cellm = 
        rrm_mem_get(sizeof(rrmcm_rmif_init_config_req_t));
    if ( p_out_init_config_req_to_cellm == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_init_config_req_to_cellm failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }   

    /*CID 97169 Start*/
    RRM_MEMSET(p_out_init_config_req_to_cellm,0,sizeof(rrmcm_rmif_init_config_req_t));
    /*CID 97169 End*/



    p_out_init_config_req_to_cellm->transaction_id = trans_id;

    if (oam_log_on_off_val > RRM_OAM_LOG_ON) /*Kshitij_start coverity CID:15854 Kshitij_end */
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_WARNING, "Invalid Log command[%d] received, using ON as default", oam_log_on_off_val);
        p_out_init_config_req_to_cellm->log_on_off = RRM_OAM_LOG_ON;
    }
    else
        p_out_init_config_req_to_cellm->log_on_off = oam_log_on_off_val;

    /*coverity 15852, rel2.0.1*/
    if (oam_log_level > RRM_OAM_DETAILEDALL)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "InCorrect log level %d", 
                oam_log_level);
        p_out_init_config_req_to_cellm->log_level = RRM_OAM_BRIEF;
    }
    else
        p_out_init_config_req_to_cellm->log_level = oam_log_level;

    /* Spr 16211 Changes Start*/
    p_out_init_config_req_to_cellm->rim_enable_disable = rim_enable_disable;
    p_out_init_config_req_to_cellm->bitmask |= RRMCM_RMIF_INIT_RIM_INFO_PRESENT;
    /* Spr 16211 Changes End*/

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"Sending Init Config Request to %d", 
            RRM_OAM_CM_MODULE_ID);
    /* Sending Init Config Request to CellM */
    rrm_mif_send_internal_msg(RRM_OAM_CM_MODULE_ID,
            RRMCM_RMIF_INIT_CONFIG_REQ,
            sizeof(rrmcm_rmif_init_config_req_t),
            p_out_init_config_req_to_cellm);
    RRM_MEM_FREE(p_out_init_config_req_to_cellm);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_assign_log_on_off
 * Inputs         :
 *                  -oam_log_on_off_val- Log Enable/Disable
 *                  -p_out_init_config_req_to_uem
 * Outputs        : None
 * Returns        : void
 * Description    :  Assigns oam_log_on_off_val for uem using parameters from OAM
 ****************************************************************************/

    void
rrm_assign_log_on_off(rrm_oam_log_on_off_et oam_log_on_off_val,
        rrmuem_rmif_init_config_req_t * p_out_init_config_req_to_uem)
{
    RRM_UT_TRACE_ENTER();
    switch(oam_log_on_off_val)
    {
        case RRM_OAM_LOG_OFF:
            p_out_init_config_req_to_uem->log_on_off = RRM_UEM_LOG_OFF;
            break;
        case RRM_OAM_LOG_ON:
            p_out_init_config_req_to_uem->log_on_off = RRM_UEM_LOG_ON;
            break;
        default :
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "Invalid[%d] log on off value", oam_log_on_off_val);
            break;
    }

    RRM_UT_TRACE_EXIT();
}
/*Cov_fix_63407_start*/

/****************************************************************************
 * Function Name  : build_and_send_init_config_req_to_uem
 * Inputs         : -oam_log_level-  Log level received from OAM
 *                  -oam_log_on_off_val- Log Enable/Disable
 *                  -trans_id- Transaction ID of request
 * Outputs        : None 
 * Returns        : void
 * Description    : build init config request for uem using parameters from OAM
 ****************************************************************************/
    static void build_and_send_init_config_req_to_uem
(
 rrm_oam_log_level_et oam_log_level , 
 rrm_oam_log_on_off_et oam_log_on_off_val,
 U16 trans_id
 )
{
    rrmuem_rmif_init_config_req_t   *p_out_init_config_req_to_uem = RRM_PNULL;

    RRM_UT_TRACE_ENTER();
    p_out_init_config_req_to_uem = rrm_mem_get(sizeof(rrmuem_rmif_init_config_req_t));
    if ( p_out_init_config_req_to_uem == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_init_config_req_to_uem failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    p_out_init_config_req_to_uem->bitmask = 0x00;
    p_out_init_config_req_to_uem->transaction_id = trans_id;

    /* Bug 10484 (Fixed by Nikhil) */
    p_out_init_config_req_to_uem->log_on_off = RRM_UEM_LOG_OFF;
    if (oam_log_on_off_val > RRM_OAM_LOG_ON)    /*Kshitij Coverity CID:15852 */
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_WARNING, "Invalid[%d] Log command received, using ON as default", oam_log_on_off_val);
        p_out_init_config_req_to_uem->log_on_off = RRM_UEM_LOG_ON;
    }
    else
    {
        /*Cov_fix_63407_start*/
        rrm_assign_log_on_off(oam_log_on_off_val,p_out_init_config_req_to_uem);
        /*Cov_fix_63407_end*/
    }
    /* Bug 10484 (Fixed by Nikhil) */

    /*coverity id: 15854, aditya rel 2.0.1*/
    if (oam_log_level > RRM_OAM_DETAILEDALL)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "InCorrect log level %d", 
                oam_log_level);
        /* coverity : CID 16479*/
        p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_BRIEF;
    }
    else
    {
        /* CID:63407 Fix Start */
        switch(oam_log_level)
        {
            case RRM_OAM_CRITICAL:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_CRITICAL;
                break;

            case RRM_OAM_ERROR:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_ERROR;
                break;

            case RRM_OAM_WARNING:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_WARNING;
                break;

            case RRM_OAM_INFO:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_INFO;
                break;

            case RRM_OAM_BRIEF:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_BRIEF;
                break;

            case RRM_OAM_DETAILED:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_DETAILED;
                break;

            case RRM_OAM_DETAILEDALL:
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_DETAILEDALL;
                break;

            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "InCorrect log level %d", 
                        oam_log_level);
                p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_BRIEF;
        }
        /* CID:63407 Fix End */
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, " Sending Init Config Request to %d", 
            RRM_OAM_UEM_MODULE_ID);
    /* Sending Init Config Request to UeM */
    rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
            RRMUEM_RMIF_INIT_CONFIG_REQ,
            sizeof(rrmuem_rmif_init_config_req_t),
            p_out_init_config_req_to_uem);
    RRM_MEM_FREE(p_out_init_config_req_to_uem);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : mif_rrm_cell_state_mapping
 * Inputs         : -mif_cell_state- Cell state at MIF
 * Outputs        : returns cell state for rrm as per the MIF's cell state. 
 * Returns        : rrm_cell_operational_state_et
 * Description    : This function maps MIF cell state to the RRM cell state. 
 ****************************************************************************/
rrm_cell_operational_state_et mif_rrm_cell_state_mapping(rrm_mif_cellm_cell_operational_state_et mif_cell_state)
{
    rrm_cell_operational_state_et rrm_cell_state;

    RRM_UT_TRACE_ENTER();
    switch(mif_cell_state)
    {

        case RRM_MIF_CELLM_CELL_OPERATIONAL:
            rrm_cell_state = RRM_CELL_OPERATIONAL;
            break;

        case RRM_MIF_CELLM_CELL_UNOPERATIONAL_DUE_TO_SWITCHOFF:
            rrm_cell_state = RRM_CELL_UNOPERATIONAL;
            break;

        case RRM_MIF_CELLM_CELL_UNOPERATIONAL_DUE_TO_CELL_DELETE:
            rrm_cell_state = RRM_CELL_DELETED;
            break;
        case RRM_MIF_CELLM_CELL_STATE_UNDEFINED:
        default:
            /*coverity 16474, aditya, rel2.0.1*/
            rrm_cell_state = RRM_CELL_STATE_UNDEFINED;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,"cell state not defined");
            break;
    }
    RRM_UT_TRACE_EXIT();
    return rrm_cell_state;
}

/****************************************************************************
 * Function Name  : mif_rrm_cell_state_change_cause_mapping
 * Inputs         : -mif_state_change_cause- Change cause for cell state
 * Outputs        : returns cell state change cause for rrm as per the MIF's cell 
 *                  state change cause. 
 * Returns        : rrm_cell_state_change_cause_et
 * Description    : This function maps MIF cell state change cause to the RRM 
 *                  cell state change cause. 
 ****************************************************************************/
    static rrm_cell_state_change_cause_et mif_rrm_cell_state_change_cause_mapping
(rrm_mif_cellm_cell_state_change_cause_et mif_state_change_cause)
{
    rrm_cell_state_change_cause_et cell_state_change_cause;
    RRM_UT_TRACE_ENTER();
    switch(mif_state_change_cause)
    {
        case RRM_MIF_CELLM_CELL_ADD:
            cell_state_change_cause = RRM_CELL_ADD;
            break;

        case RRM_MIF_CELLM_CELL_DELETE:
            cell_state_change_cause = RRM_CELL_DELETE;
            break;

        case RRM_MIF_CELLM_CELL_STOP:
            cell_state_change_cause = RRM_CELL_STOP;
            break;

        case RRM_MIF_CELLM_CELL_START:
            cell_state_change_cause = RRM_CELL_START;
            break;
        case RRM_MIF_CELLM_CELL_STATE_CHANGE_CAUSE_UNDEFINED:
        default:
            /*coverity 16465, aditya, rel2.0.1*/
            cell_state_change_cause =
                RRM_CELL_STATE_CHANGE_CAUSE_UNDEFINED;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "cell state change cause not defined:%d",
                    mif_state_change_cause);
            break;
    }

    RRM_UT_TRACE_EXIT();
    return cell_state_change_cause;
}

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_1
 * Inputs         : - pucch_format_1 - pucch format1 info from cfg
 *                  -*cellm_pucch_format_1-pucch format1 be sent
 *                                          to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_1 from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
    static void fill_delta_f_pucch_format_1
(
 S32 pucch_format_1, /* Coverity_ID : 53605, 53606 */
 rrmc_delta_f_pucch_format_one_et * cellm_pucch_format_1)
{

    RRM_UT_TRACE_ENTER();
    switch (pucch_format_1)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF_2_CFG:
            {
                *cellm_pucch_format_1 = RRMC_DELTAF_NEG_TWO;
                /* Coverity_ID : 53632 */
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF0_CFG:
            {
                *cellm_pucch_format_1 = RRMC_DELTAF_ZERO;
                /* Coverity_ID : 53632 */
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF2_CFG:
            {
                *cellm_pucch_format_1 = RRMC_DELTAF_POS_TWO;
                /* Coverity_ID : 53632 */
                break;
            }
        default:
            {
                *cellm_pucch_format_1 = RRMC_DELTAF_NEG_TWO;
                /* Coverity_ID : 53632 */
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "fill_delta_f_pucch_format_1: Incorrect pucch_format_1 = %d", pucch_format_1);
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_1b
 * Inputs         : -cfg_pucch_format_1b - pucch format1b info from cfg
 *                  -*cellm_pucch_format_1b - pucch format1 info to be
 *                                            sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_1b from 
 *                  cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
static void
fill_delta_f_pucch_format_1b (
        S32 pucch_format_1b, /* Coverity_ID : 53605, 53606 */
        rrmc_delta_f_pucch_format_one_b_et *
        cellm_pucch_format_1b)
{

    RRM_UT_TRACE_ENTER();
    switch (pucch_format_1b)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_DELTAF1_CFG:
            {
                *cellm_pucch_format_1b = RRMC_DELTA_F1;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_DELTAF3_CFG:
            {
                *cellm_pucch_format_1b = RRMC_DELTA_F3;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_DELTAF5_CFG:
            {
                *cellm_pucch_format_1b = RRMC_DELTA_F5;
                break;
            }
        default:
            {
                *cellm_pucch_format_1b = RRMC_DELTA_F1;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "fill_delta_f_pucch_format_1b: Incorrect pucch_format_1b %d",pucch_format_1b);
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_2
 * Inputs         : -cfg_pucch_format_2-pucch format2 info from cfg
 *                  -*cellm_pucch_format_2-pucch format2 info to be
 *                                            sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_2 from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
    static void fill_delta_f_pucch_format_2
(
 S32 pucch_format_2, /* Coverity_ID : 53605, 53606*/
 rrmc_delta_f_pucch_format_two_et * cellm_pucch_format_2)
{
    RRM_UT_TRACE_ENTER();
    switch (pucch_format_2)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_2_CFG_DELTAF_2_CFG:
            {
                *cellm_pucch_format_2 = RRMC_FORMAT2_DELTA_NEG_TWO;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_2_CFG_DELTAF0_CFG:
            {
                *cellm_pucch_format_2 = RRMC_FORMAT2_DELTA_ZERO;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_2_CFG_DELTAF1_CFG:
            {
                *cellm_pucch_format_2 = RRMC_FORMAT2_DELTA_POS_ONE;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_2_CFG_DELTAF2_CFG:
            {
                *cellm_pucch_format_2 = RRMC_FORMAT2_DELTA_POS_TWO;
                break;
            }
        default:
            {
                *cellm_pucch_format_2 = RRMC_FORMAT2_DELTA_NEG_TWO;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "fill_delta_f_pucch_format_2: Incorrect pucch_format_2 %d",
                        pucch_format_2);
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_2a
 * Inputs         : -cfg_pucch_format_2a-pucch format2a info from cfg 
 *                  -*cellm_pucch_format_2a-pucch format2a info to be
 *                                            sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_2a from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
    static void fill_delta_f_pucch_format_2a
(
 S32 pucch_format_2a, /* Coverity_ID : 53605, 53606*/
 rrmc_delta_f_pucch_format_two_ab_et * cellm_pucch_format_2a)
{
    RRM_UT_TRACE_ENTER();
    switch (pucch_format_2a)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF_2_CFG:
            {
                *cellm_pucch_format_2a = RRMC_DELTA_NEG_TWO;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF0_CFG:
            {
                *cellm_pucch_format_2a = RRMC_DELTA_ZERO;
                break;
            }
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF2_CFG:
            {
                *cellm_pucch_format_2a = RRMC_DELTA_POS_TWO;
                break;
            }
        default:
            {
                *cellm_pucch_format_2a = RRMC_DELTA_NEG_TWO;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "fill_delta_f_pucch_format_2a: Incorrect pucch_format_2a %d", pucch_format_2a);
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */

/* CA_Stage3_PUCCH_Format_Enh: Start */
/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_1b_cs_r10
 * Inputs         : -cfg_pucch_format_1b_cs-v1020- pucch format1b_cs-v1020 
 *                                                 info from cfg
 *                  -*cellm_pucch_format_2b- pucch format2a info to be
 *                                          sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_1b_cs_r10
 *                  from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
static void
    fill_delta_f_pucch_format_1b_cs_r10
(
 S32                                        pucch_format_1b_cs_r10,
 rrmc_delta_f_pucch_format_one_b_cs_r10_et *cellm_pucch_format_1b_cs_r10
 )
{
    RRM_UT_TRACE_ENTER();
    switch(pucch_format_1b_cs_r10)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_CS_R10_DELTAF1_CFG:
            *cellm_pucch_format_1b_cs_r10 = RRMC_FORMAT_1B_CS_R10_DELTA_POS_ONE;

            break;

        case RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_CS_R10_DELTAF2_CFG: 
            *cellm_pucch_format_1b_cs_r10 = RRMC_FORMAT_1B_CS_R10_DELTA_POS_TWO;

            break;
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_3_r10
 * Inputs         : -cfg_pucch_format_3-v1020- pucch format3-v1020 info from cfg
 *                  -*cellm_pucch_format_3-v1020- pucch format3-v1020 info to be
 *                                          sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_2b from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
static void
    fill_delta_f_pucch_format_3_r10
(
 S32                                     pucch_format_3_r10,
 rrmc_delta_f_pucch_format_three_r10_et  *cellm_pucch_format_3_r10
 )
{
    RRM_UT_TRACE_ENTER();
    switch(pucch_format_3_r10)
    {
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF_1_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_NEG_ONE;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF0_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_ZERO;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF1_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_ONE;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF2_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_TWO;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF3_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_THREE;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF4_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_FOUR;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF5_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_FIVE;

            break;
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_3_R10_DELTAF6_CFG:
            *cellm_pucch_format_3_r10 = RRMC_FORMAT_3_R10_DELTA_POS_SIX;

            break;
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */
/* CA_Stage3_PUCCH_Format_Enh: End */

/****************************************************************************
 * Function Name  : fill_delta_f_pucch_format_2b
 * Inputs         : -cfg_pucch_format_2b- pucch format2b info from cfg
 *                  -*cellm_pucch_format_2b- pucch format2a info to be
 *                                          sent to cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control_pucch_format_2b from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
static void 
    fill_delta_f_pucch_format_2b
(
 S32 pucch_format_2b, /* Coverity_ID : 53605, 53606 */
 rrmc_delta_f_pucch_format_two_ab_et * cellm_pucch_format_2b
 )
{
    RRM_UT_TRACE_ENTER();
    switch (pucch_format_2b)
    {
        /* Coverity_ID : 53605, 53606 */
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF_2_CFG: /* RRM_ZERO */
            {
                /* coverity : CID 16487*/
                *cellm_pucch_format_2b = RRMC_DELTA_NEG_TWO;
                break;
            }
            /* Coverity_ID : 53605, 53606 */    
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF0_CFG: /* RRM_ONE */
            {
                /* coverity : CID 16489*/
                *cellm_pucch_format_2b = RRMC_DELTA_ZERO;
                break;
            }
            /* Coverity_ID : 53605, 53606 */    
        case RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF2_CFG: /* RRM_TWO */
            {
                /* coverity : CID 16488*/
                *cellm_pucch_format_2b = RRMC_DELTA_POS_TWO;
                break;
            }
        default:
            {
                *cellm_pucch_format_2b = RRMC_DELTA_NEG_TWO;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "fill_delta_f_pucch_format_2b: Incorrect pucch_format_2b %d",pucch_format_2b);
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */
/* BUG_371 FIX START */ 
/****************************************************************************
 * Function Name  : fill_sib_2_ul_power_control_data 
 * Inputs         : -*p_phy_cfg_params - phy info from cfg
 *                  -*p_sib2_ul_pwr_ctrl_info_to_cellm -sib2 info to be sent to cellm 
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills ul_power_control data for cellm 
 *                  from cfg param 
 ****************************************************************************/
/* SPR 20653 Fix Start */
    static void fill_sib_2_ul_power_control_data 
(rrm_oam_power_control_params_t    *p_power_control_from_oam,
 rrm_operator_ul_pwr_ctrl_t        *p_sib2_ul_pwr_ctrl_info_to_cellm)
{
    rrm_oam_power_control_enable_t *p_power_control_enable_from_oam = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /*SPR 329 start*/
    if (p_power_control_from_oam->bitmask & RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
    {
        p_power_control_enable_from_oam = &p_power_control_from_oam->rrm_power_control_enable;

        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_1_PRESENT)
        {
            fill_delta_f_pucch_format_1(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_1,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_1));
        }
        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_PRESENT)
        {
            fill_delta_f_pucch_format_1b(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_1b,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_1b));
        }
        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_2_PRESENT)
        {
            fill_delta_f_pucch_format_2(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_2,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_2));
        }

        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_2A_PRESENT)
        {
            fill_delta_f_pucch_format_2a(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_2a,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_2a));
        }

        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_2B_PRESENT)
        {
            fill_delta_f_pucch_format_2b(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_2b,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_2b));
        }
        /*Bug:238*/
        /* CA_Stage3_PUCCH_Format_Enh: Start */
        /* If neither pucch_format_1b_cs_r10 nor pucch_format_3_r10 is received then bitmask RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT 
         * shall not be enabled and the mentioned pucch formats shall not be broadcasted in SIBs.
         * Else if any one is present then bitmask RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT will be enabled and the value of the other 
         * one will be set to default and thus both formats will be broadcasted in SIBs.
         * */
        if(p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_1B_CS_R10_PRESENT)
        {
            fill_delta_f_pucch_format_1b_cs_r10(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_1b_cs_r10,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_1b_cs_r10));

            p_sib2_ul_pwr_ctrl_info_to_cellm->bitmask |= RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT;
        }

        if(p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_F_PUCCH_FORMAT_3_R10_PRESENT)
        {
            fill_delta_f_pucch_format_3_r10(p_power_control_from_oam->rrm_power_control_enable.
                    delta_f_pucch_format_3_r10,
                    &(p_sib2_ul_pwr_ctrl_info_to_cellm->delta_f_pucch_format_3_r10));

            p_sib2_ul_pwr_ctrl_info_to_cellm->bitmask |= RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT;
        }
        /* CA_Stage3_PUCCH_Format_Enh: End */
        if (p_power_control_enable_from_oam->bitmask & RRM_OAM_DELTA_PREAMBLE_MSG_PRESENT)
        {
            p_sib2_ul_pwr_ctrl_info_to_cellm->delta_preamble_msg_3 =
                p_power_control_from_oam->rrm_power_control_enable.delta_preamble_msg_3;
        }
    }
    /*SPR 329 end*/

    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */
/* BUG_371 FIX END */ 


/****************************************************************************
 * Function Name  : fill_cellm_comPramsp_mob_info
 * Inputs         : -*comPramsp_mob_info_from_oam- idle mode Mobility 
 *                    common params received from OAM
 *                  -*comPramsp_mob_info_to_cellm- idle mode Mobility 
 common params to be sent to Cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills common parameters for CellM with the 
 *                  params from OAM. 
 ****************************************************************************/
    static void fill_cellm_comPramsp_mob_info
(rrm_oam_common_params_t * comPramsp_mob_info_from_oam,
 common_params_t * comPramsp_mob_info_to_cellm)
{
    comPramsp_mob_info_to_cellm->bitmask = 0x00;
    comPramsp_mob_info_to_cellm->q_hyst = comPramsp_mob_info_from_oam->q_hyst;

    RRM_UT_TRACE_ENTER();
    if (RRM_OAM_SPEED_STATE_PARAMS_PRESENT &
            comPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT");
        comPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_SPEED_STATE_PARAMS_PRESENT;

        /*speed_state_params - start */
        comPramsp_mob_info_to_cellm->speed_state_params.q_hyst_sf_medium =
            comPramsp_mob_info_from_oam->speed_state_params.q_hyst_sf_medium;

        comPramsp_mob_info_to_cellm->speed_state_params.q_hyst_sf_high =
            comPramsp_mob_info_from_oam->speed_state_params.q_hyst_sf_high;

        comPramsp_mob_info_to_cellm->speed_state_params.t_evaluation =
            comPramsp_mob_info_from_oam->speed_state_params.t_evaluation;

        comPramsp_mob_info_to_cellm->speed_state_params.t_hyst_normal =
            comPramsp_mob_info_from_oam->speed_state_params.t_hyst_normal;

        comPramsp_mob_info_to_cellm->speed_state_params.n_cell_change_medium =
            comPramsp_mob_info_from_oam->speed_state_params.n_cell_change_medium;

        comPramsp_mob_info_to_cellm->speed_state_params.n_cell_change_high =
            comPramsp_mob_info_from_oam->speed_state_params.n_cell_change_high;
        /*speed_state_params - end */
    }
    /*Coverity_fix_start_54933*/
    RRM_UT_TRACE_EXIT();
    /*Coverity_fix_end_54933*/
}

/****************************************************************************
 * Function Name  : fill_cellm_intraFreqPramsp_mob_info
 * Inputs         : -*intraFreqPramsp_mob_info_from_oam - idle mode 
 *                    mobility intra freq params from oam
 *                  -*intraFreqPramsp_mob_info_to_cellm - idle mode
 *                    mobility intra freq params for cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills intra freq parameters for CellM with the 
 *                  params from OAM. 
 ****************************************************************************/
    static void fill_cellm_intraFreqPramsp_mob_info
(rrm_oam_intra_freq_params_t * intraFreqPramsp_mob_info_from_oam,
 intra_freq_params_t * intraFreqPramsp_mob_info_to_cellm)
{

    RRM_UT_TRACE_ENTER();
    intraFreqPramsp_mob_info_to_cellm->bitmask = 0x00;

    intraFreqPramsp_mob_info_to_cellm->q_rx_lev_min_sib_1 =
        intraFreqPramsp_mob_info_from_oam->q_rx_lev_min_sib_1;

    intraFreqPramsp_mob_info_to_cellm->q_rx_lev_min_sib_3 =
        intraFreqPramsp_mob_info_from_oam->q_rx_lev_min_sib_3;

    if (RRM_OAM_Q_RX_LEV_MIN_OFFSET_PRESENT &
            intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->q_rx_lev_min_offset =
            intraFreqPramsp_mob_info_from_oam->q_rx_lev_min_offset;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_Q_RX_LEV_MIN_OFFSET_PRESENT;
    }

    if (RRM_OAM_S_INTRA_SEARCH_PRESENT &
            intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_S_INTRA_SEARCH_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->s_intra_search =
            intraFreqPramsp_mob_info_from_oam->s_intra_search;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_S_INTRA_SEARCH_PRESENT;
    }
    intraFreqPramsp_mob_info_to_cellm->t_reselection_eutra =
        intraFreqPramsp_mob_info_from_oam->t_reselection_eutra;

    if (RRM_OAM_S_NON_INTRA_SEARCH_PRESENT &
            intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->s_non_intra_search =
            intraFreqPramsp_mob_info_from_oam->s_non_intra_search;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_S_NON_INTRA_SEARCH_PRESENT;
    }

    intraFreqPramsp_mob_info_to_cellm->cell_reselection_priority =
        intraFreqPramsp_mob_info_from_oam->cell_reselection_priority;

    if (RRM_OAM_P_MAX_SIB1_PRESENT & intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_P_MAX_SIB1_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->p_max_sib_1 =
            intraFreqPramsp_mob_info_from_oam->p_max_sib_1;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_P_MAX_SIB1_PRESENT;
    }

    if (RRM_OAM_P_MAX_SIB3_PRESENT & intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_P_MAX_SIB3_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->p_max_sib_3 =
            intraFreqPramsp_mob_info_from_oam->p_max_sib_3;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_P_MAX_SIB3_PRESENT;
    }

    intraFreqPramsp_mob_info_to_cellm->thresh_serving_low =
        intraFreqPramsp_mob_info_from_oam->thresh_serving_low;

    if (RRM_OAM_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT &
            intraFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT");
        intraFreqPramsp_mob_info_to_cellm->speed_scale_factors.
            t_reselection_eutra_sf_medium =
            intraFreqPramsp_mob_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_medium;
        intraFreqPramsp_mob_info_to_cellm->speed_scale_factors.
            t_reselection_eutra_sf_high =
            intraFreqPramsp_mob_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_high;
        intraFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT;
    }

    intraFreqPramsp_mob_info_to_cellm->neigh_cell_config =
        intraFreqPramsp_mob_info_from_oam->neigh_cell_config;

    /*idle mode mobility intra freq params - end */
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_cellm_interFreqPramsp_mob_info
 * Inputs         : -*interFreqPramsp_mob_info_from_oam - idle mode
 *                    mobility inter freq params from oam
 *                   -*interFreqPramsp_mob_info_to_cellm - idle mode
 *                     mobility inter freq params for cellm
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills inter freq parameters for CellM with the 
 *                  params from OAM. 
 ****************************************************************************/
    static void fill_cellm_interFreqPramsp_mob_info
(rrm_oam_inter_freq_params_t * interFreqPramsp_mob_info_from_oam,
 inter_freq_params_t * interFreqPramsp_mob_info_to_cellm)
{
    RRM_UT_TRACE_ENTER();
    interFreqPramsp_mob_info_to_cellm->bitmask = 0x00;

    interFreqPramsp_mob_info_to_cellm->eutra_carrier_arfcn =
        interFreqPramsp_mob_info_from_oam->eutra_carrier_arfcn;

    interFreqPramsp_mob_info_to_cellm->q_rx_lev_min_sib_5 =
        interFreqPramsp_mob_info_from_oam->q_rx_lev_min_sib_5;

    interFreqPramsp_mob_info_to_cellm->q_offset_freq =
        interFreqPramsp_mob_info_from_oam->q_offset_freq;

    interFreqPramsp_mob_info_to_cellm->t_reselection_eutra =
        interFreqPramsp_mob_info_from_oam->t_reselection_eutra;
    /* OFFSET CHANGES */
    if (RRM_OAM_CM_OFFSET_FREQ_PRESENT &
            interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_CM_OFFSET_FREQ_PRESENT");
        interFreqPramsp_mob_info_to_cellm->cm_offset_freq =
            interFreqPramsp_mob_info_from_oam->cm_offset_freq;
        interFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;
    }
    else
    {
        interFreqPramsp_mob_info_to_cellm->cm_offset_freq =
            interFreqPramsp_mob_info_from_oam->q_offset_freq;
        interFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_CM_OFFSET_FREQ_PRESENT;
    }
    /* end */

    if (RRM_OAM_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT &
            interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT");
        interFreqPramsp_mob_info_to_cellm->cell_reselection_priority =
            interFreqPramsp_mob_info_from_oam->cell_reselection_priority;
        interFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_INTER_FREQ_CELL_RESELECTION_PRIORITY_PRESENT;
    }

    interFreqPramsp_mob_info_to_cellm->thresh_x_high =
        interFreqPramsp_mob_info_from_oam->thresh_x_high;

    interFreqPramsp_mob_info_to_cellm->thresh_x_low =
        interFreqPramsp_mob_info_from_oam->thresh_x_low;
    if (RRM_OAM_P_MAX_PRESENT & interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_P_MAX_PRESENT");
        interFreqPramsp_mob_info_to_cellm->p_max =
            interFreqPramsp_mob_info_from_oam->p_max;
        interFreqPramsp_mob_info_to_cellm->bitmask |= RRMCM_RMIF_P_MAX_PRESENT;
    }

    interFreqPramsp_mob_info_to_cellm->neigh_cell_config =
        interFreqPramsp_mob_info_from_oam->neigh_cell_config;

    if (RRM_OAM_T_EUTR_SPEED_SCALE_FACTOR_PRESENT &
            interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1");
        interFreqPramsp_mob_info_to_cellm->speed_scale_factors.
            t_reselection_eutra_sf_medium =
            interFreqPramsp_mob_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_medium;
        interFreqPramsp_mob_info_to_cellm->speed_scale_factors.
            t_reselection_eutra_sf_high =
            interFreqPramsp_mob_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_high;
        interFreqPramsp_mob_info_to_cellm->bitmask |=
            RRMCM_RMIF_T_RESELECTION_EUTR_SPEED_SCALE_FACTOR_PRESENT1;
    }

    interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.bitmask =
        0x00;
    interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
        allowed_meas_bandwidth =
        interFreqPramsp_mob_info_from_oam->measurement_bandwidth;
    interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
        presence_antenna_port1 =
        interFreqPramsp_mob_info_from_oam->presence_antenna_port1;

    if (RRM_OAM_Q_QUAL_MIN_R9_PRESENT &
            interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_Q_QUAL_MIN_R9_PRESENT");
        interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
            q_qual_min_r9 = interFreqPramsp_mob_info_from_oam->q_qual_min_r9;
        interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
            bitmask |= RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT;
    }

    if (RRM_OAM_THRESHX_Q_R9_PRESENT &
            interFreqPramsp_mob_info_from_oam->bitmask)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_THRESHX_Q_R9_PRESENT");
        interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
            threshx_q_r9.thresh_serving_highq_r9 =
            interFreqPramsp_mob_info_from_oam->threshx_q_r9.
            thresh_serving_highq_r9;

        interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
            threshx_q_r9.thresh_serving_lowq_r9 =
            interFreqPramsp_mob_info_from_oam->threshx_q_r9.
            thresh_serving_lowq_r9;

        interFreqPramsp_mob_info_to_cellm->inter_freq_params_op_specific.
            bitmask |= RRMCM_RMIF_THRESHOLDX_Q_R9_PRESENT;
    }
    /*Coverity_fix_start_54934*/  
    RRM_UT_TRACE_EXIT();
    /*Coverity_fix_end_54934*/
}

/****************************************************************************
 * Function Name  : fill_cellm_set_attribute_req_trigger_type
 * Inputs         : -*p_in_son_set_attributes_req_msg - Msg fom SON
 *                  -*p_out_cell_set_attr_req - Msg to be sent to cellm 
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function fills cell_m trigger type in req msg corresponding 
 *                  to incoming son trigger type params from OAM  for set_attribute 
 *                  request
 ****************************************************************************/
    static void fill_cellm_set_attribute_req_trigger_type
(rrm_son_set_attribute_value_req_t * p_in_son_set_attributes_req_msg,
 /* SPR 20653 Fix Start */
 rrmcm_rmif_cell_set_attr_req * p_out_cell_set_attr_req,
 U8 attrListCnt)
{
    U8 triggerListCnt = 0;
    RRM_UT_TRACE_ENTER();
    for (triggerListCnt = 0; triggerListCnt <
            p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list_size; triggerListCnt++)
    {

        switch (p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list[triggerListCnt].
                id)
        {
            case RRM_TRGR_PERIODIC:
                p_out_cell_set_attr_req->attribute[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_PERIODIC;
                if (p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list[triggerListCnt].
                        bitmask & RRM_TRIGGER_TYPE_PERIODIC)
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_PERIODIC is present");

                    p_out_cell_set_attr_req->attribute[attrListCnt].
                        trigger_type[triggerListCnt].trigger_type.periodic =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].periodic.interval;
                }
                else
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_PERIODIC is not present");
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                        trigger_type.periodic = 0;
                }
                break;

            case RRM_TRGR_THRESHOLD:
                p_out_cell_set_attr_req->attribute[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_THRESHOLD;

                if (p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list[triggerListCnt].
                        bitmask & RRM_TRIGGER_TYPE_THRESHOLD)
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_THRESHOLD is present");
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                        trigger_type.threshold =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].threshold.count;
                }
                else
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_THRESHOLD is not present");
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                        trigger_type.threshold = 0;
                }
                break;
            case RRM_TRGR_EVENT:
                p_out_cell_set_attr_req->attribute[attrListCnt].
                    trigger_type[triggerListCnt].trigger_id =
                    RRM_MIF_CELLM_TRGR_EVENT;

                if (p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list[triggerListCnt].
                        bitmask & RRM_TRIGGER_TYPE_EVENT)
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_DETAILED,
                            "Bitmask RRM_TRIGGER_TYPE_EVENT is present");
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                        trigger_type.event =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].
                        trgr_list[triggerListCnt].event.enable;
                }
                else
                {
                    RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                            RRM_WARNING,
                            "Bitmask RRM_TRIGGER_TYPE_EVENT is not present");
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                        trigger_type.event = 0;
                }
                break;
            case RRM_TRGR_UNDEF:
            default:
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "trigger type is invalid[%d]", 
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list[triggerListCnt].id);
                p_out_cell_set_attr_req->attribute[attrListCnt].trigger_type[triggerListCnt].
                    trigger_id = RRM_MIF_CELLM_TRGR_UNDEF;
                break;
        }
    }
    /* Coverity 54975 fix start */
    RRM_UT_TRACE_EXIT();
    /* Coverity 54975 fix end */
}

/* SPR 20653 Fix Start */
/****************************************************************************
 * Function Name  : populate_operator_mac_param_for_cell_config
 * Inputs         : -*p_operator_info_to_cellm -operator info from cellm
 *                  -*p_operator_cfg_params -operator info from cfg
 *                  -*p_operator_info_from_oam -operator info from oam
 *                  -*p_mac_layer_params_from_oam - mac layer params
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates mac param of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
    static void populate_operator_mac_param_for_cell_config
(operator_info_t * p_operator_info_to_cellm,
 rrm_oam_operator_info_t * p_operator_info_from_oam,
 rrm_oam_mac_layer_params_t      *p_mac_layer_params_from_oam
 )
{

    rrm_ul_dl_freq_selective_sched_et        ul_dl_freq_value = 
        RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    rrm_oam_dci_format_for_si_msgs_et dci_format_for_si_msg  ;

    /* + SPR 17665 + */
    U8 count = 0;
    /* - SPR 17665 - */
 
    RRM_UT_TRACE_ENTER();


    p_operator_info_to_cellm->rrm_mac_config.dl_num_harq_process =
        p_mac_layer_params_from_oam->dl_num_harq_process;


    p_operator_info_to_cellm->rrm_mac_config.start_rarnti_range =
        p_operator_info_from_oam->rrm_mac_config.start_rarnti_range;

    p_operator_info_to_cellm->rrm_mac_config.end_rarnti_range =
        p_operator_info_from_oam->rrm_mac_config.end_rarnti_range;

    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/
    
    p_operator_info_to_cellm->rrm_mac_config.periodic_report_required =
        p_operator_info_from_oam->rrm_mac_config.periodic_report_required;

    p_operator_info_to_cellm->rrm_mac_config.periodic_report_periodicity =
        p_operator_info_from_oam->rrm_mac_config.periodic_report_periodicity;

    p_operator_info_to_cellm->rrm_mac_config.periodic_report_ue_batch_size =
        p_operator_info_from_oam->rrm_mac_config.periodic_report_ue_batch_size;

    p_operator_info_to_cellm->radio_cong_threshold.sampling_normal_time = 
        p_operator_info_from_oam->rrm_mac_config.sampling_normal_time;

    /* Populating enable_frequency_selective_scheduling of Mac Config params */


    if (p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_TPC_RNTI_RANGE_PRESENT)
    {
        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPucch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPucch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPucch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPucch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPusch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPusch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPusch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPusch;
    }
    else
    {
        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPucch = RRM_DEFINED_DEFAULT_VALUE_FOR_START_TPC_RNTI_PUCCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPucch = RRM_DEFINED_DEFAULT_VALUE_FOR_END_TPC_RNTI_PUCCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPusch = RRM_DEFINED_DEFAULT_VALUE_FOR_START_TPC_RNTI_PUSCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPusch = RRM_DEFINED_DEFAULT_VALUE_FOR_END_TPC_RNTI_PUSCH;

    }
    if (p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
    {
        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_HARQ_BLER_CLPC_PUCCH_ENABLE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                harqBlerClpcPucchEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.harqBlerClpcPucchEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                harqBlerClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_HARQ_BLER_CLPC_PUCCH_ENABLE;
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CQI_SINR_CLPC_PUCCH_ENABLE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                cqiSinrClpcPucchEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.cqiSinrClpcPucchEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                cqiSinrClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CQI_SINR_CLPC_PUCCH_ENABLE; 
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CLPC_PUSCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.clpcPuschEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_ENABLE;
        }
        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.pdcchPowOrAggregationEnable =
            p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.pdcchPowOrAggregationEnable;

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CLPC_PUSCH_FREQ_SELECTIVE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschfreqSelectiveEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.clpcPuschfreqSelectiveEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschfreqSelectiveEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_FREQ_SEL_ENABLE;
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_DCI_3_3A_PUCCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUCCH_enabled =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.
                dci_3_3a_based_power_control_for_pucch_enable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUCCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUCCH_ENABLE;
        }
        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_DCI_3_3A_PUSCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUSCH_enabled =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.
                dci_3_3a_based_power_control_for_pusch_enable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUSCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUSCH_ENABLE;
        }
    }
    else
    {
        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            harqBlerClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_HARQ_BLER_CLPC_PUCCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            cqiSinrClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CQI_SINR_CLPC_PUCCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            clpcPuschEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            pdcchPowOrAggregationEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_PDCCH_POW_OR_AGG_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            clpcPuschfreqSelectiveEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_FREQ_SEL_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            tpc_pdcch_ConfigPUCCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUCCH_ENABLE; 

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            tpc_pdcch_ConfigPUSCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUSCH_ENABLE;
    }

    /*
     ** Power Control params will always be passed on to cellm (either from OAM or internal cfg file)
     ** so always set this bitmask.
     */
    p_operator_info_to_cellm->rrm_mac_config.bitmask |= RRMCM_RMIF_POWER_CONTROL_ENABLE_PRESENT;

    /*+ SPR 11442 Fix +*/
    /*Deleted unneccessary traces */
    /*- SPR 11442 Fix -*/
    /* Filling rrm_mac_enable_frequency_selective_scheduling_t */

    /* sub band cqi fix start*/
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity: CID 54854 */
        ul_dl_freq_value = 
            (rrm_ul_dl_freq_selective_sched_et)p_operator_info_from_oam->additional_packet_scheduling_params.frequency_selective_scheduling;
    }
    else
    {
        ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    }
    switch(ul_dl_freq_value)
    {
        case RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY:
            /* SPR 8497 FIX START*/
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            /* SPR 8497 FIX END*/
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            break;

        default:
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "Incorrect Value(%d).. so Disbaling Frequency Selective Scheduling in both UL/DL",
                    ul_dl_freq_value);
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
    }
    /* sub band cqi fix end */

    /* Additional parameters for Cell Config Added STARTS*/
    /* CHANGES_FRM_XML_TO_CFG START */
    /* + SPR 17665 + */
    dci_format_for_si_msg = 
        p_mac_layer_params_from_oam->dci_format_for_si_msg;
    switch(dci_format_for_si_msg)
    {

        case RRM_OAM_RBS_PER_TBS_DCI_1A:
        {
            p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
                RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A;
            for(count = RRM_ZERO; count < RBS_FOR_DCI_1A_SIZE; count++)
            {

                p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1a[count] =
                    p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1a[count];
            }

            break;
        }

        case RRM_OAM_RBS_PER_TBS_DCI_1C:
        {
            p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
                RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C;
            for(count = RRM_ZERO; count < RBS_FOR_DCI_1C_SIZE; count++)
            {

                p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1c[count] =
                    p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1c[count];
            }

            break;
        }
        default:
        p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
            RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A;
    }

    /* - SPR 17665 - */

     RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */
/****************************************************************************
 * Function Name  : populate_operator_mac_param_for_cell_reconfig
 * Inputs         : -*p_operator_info_to_cellm -operator info from cellm
 *                  -*p_operator_cfg_params -operator info from cfg
 *                  -*p_operator_info_from_oam -operator info from oam
 *                  -*p_mac_layer_params_from_oam - mac layer params
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates mac param of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
static void populate_operator_mac_param_for_cell_reconfig
(operator_info_t * p_operator_info_to_cellm,
 /* BUG_371 FIX START */ 
 rrm_oam_operator_info_t * p_operator_info_from_oam,
 rrm_oam_mac_layer_params_t      *p_mac_layer_params_from_oam
 /* BUG_371 FIX END */ 
 /* SPR 20653 Fix End */
 )
{

    rrm_ul_dl_freq_selective_sched_et        ul_dl_freq_value = 
        RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    /* CHANGES_FRM_XML_TO_CFG START */
    rrm_oam_dci_format_for_si_msgs_et dci_format_for_si_msg  ;
    /* CHANGES_FRM_XML_TO_CFG END */

    /* + SPR 17665 + */
    U8 count = 0;
    /* - SPR 17665 - */

    RRM_UT_TRACE_ENTER();


    /* CHANGES_FRM_XML_TO_CFG START */
    p_operator_info_to_cellm->rrm_mac_config.dl_num_harq_process =
        p_mac_layer_params_from_oam->dl_num_harq_process;

    /* CHANGES_FRM_XML_TO_CFG END */

    p_operator_info_to_cellm->rrm_mac_config.start_rarnti_range =
        p_operator_info_from_oam->rrm_mac_config.start_rarnti_range;

    p_operator_info_to_cellm->rrm_mac_config.end_rarnti_range =
        p_operator_info_from_oam->rrm_mac_config.end_rarnti_range;
    /*SPR_19066_START*/
    /* Code deleted */
    /*SPR_19066_END*/

    /* SPR 20653 Fix Start */   

    if(p_operator_info_from_oam->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_REQUIRED_PRESENT)
    {
        p_operator_info_to_cellm->rrm_mac_config.periodic_report_required =
            p_operator_info_from_oam->rrm_mac_config.periodic_report_required;
    }

    if(p_operator_info_from_oam->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_PERIODICITY_PRESENT)
    {
        p_operator_info_to_cellm->rrm_mac_config.periodic_report_periodicity =
            p_operator_info_from_oam->rrm_mac_config.periodic_report_periodicity;
    }

    if(p_operator_info_from_oam->rrm_mac_config.bitmask & RRM_OAM_PERIODIC_REPORT_UE_BATCH_SIZE_PRESENT)
    {
        p_operator_info_to_cellm->rrm_mac_config.periodic_report_ue_batch_size =
            p_operator_info_from_oam->rrm_mac_config.periodic_report_ue_batch_size;
    }

    if (p_operator_info_from_oam->rrm_mac_config.bitmask & RRM_OAM_SAMPLING_NORMAL_TIME)
    {
        p_operator_info_to_cellm->radio_cong_threshold.sampling_normal_time = 
            p_operator_info_from_oam->rrm_mac_config.sampling_normal_time;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_RADIO_CONG_THRESHOLD_PRESENT;
        /* SPR 21429 Fix End */
    }
    /* SPR 20653 Fix End */    

    /* Populating enable_frequency_selective_scheduling of Mac Config params */

    if (p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_TPC_RNTI_RANGE_PRESENT)
    {
        /* SPR 20653 Fix Start */
        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPucch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPucch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPucch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPucch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPusch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.startTpcRntiPusch;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPusch =
            p_operator_info_from_oam->rrm_power_control_params.rrm_tpc_rnti_range.endTpcRntiPusch;
    }
    else
    {
        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPucch = RRM_DEFINED_DEFAULT_VALUE_FOR_START_TPC_RNTI_PUCCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPucch = RRM_DEFINED_DEFAULT_VALUE_FOR_END_TPC_RNTI_PUCCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            startTpcRntiPusch = RRM_DEFINED_DEFAULT_VALUE_FOR_START_TPC_RNTI_PUSCH;

        p_operator_info_to_cellm->rrm_mac_config.mac_tpc_rnti_range.
            endTpcRntiPusch = RRM_DEFINED_DEFAULT_VALUE_FOR_END_TPC_RNTI_PUSCH;

    }
    if (p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
    {
        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_HARQ_BLER_CLPC_PUCCH_ENABLE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                harqBlerClpcPucchEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.harqBlerClpcPucchEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                harqBlerClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_HARQ_BLER_CLPC_PUCCH_ENABLE;
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CQI_SINR_CLPC_PUCCH_ENABLE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                cqiSinrClpcPucchEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.cqiSinrClpcPucchEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                cqiSinrClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CQI_SINR_CLPC_PUCCH_ENABLE; 
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CLPC_PUSCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.clpcPuschEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_ENABLE;
        }
        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.pdcchPowOrAggregationEnable =
            p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.pdcchPowOrAggregationEnable;

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_CLPC_PUSCH_FREQ_SELECTIVE_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschfreqSelectiveEnable =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.clpcPuschfreqSelectiveEnable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                clpcPuschfreqSelectiveEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_FREQ_SEL_ENABLE;
        }

        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_DCI_3_3A_PUCCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUCCH_enabled =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.
                dci_3_3a_based_power_control_for_pucch_enable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUCCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUCCH_ENABLE;
        }
        if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask &
                RRM_OAM_DCI_3_3A_PUSCH_PRESENT)
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUSCH_enabled =
                p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.
                dci_3_3a_based_power_control_for_pusch_enable;
        }
        else
        {
            p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
                tpc_pdcch_ConfigPUSCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUSCH_ENABLE;
        }
    }
    else
    {
        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            harqBlerClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_HARQ_BLER_CLPC_PUCCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            cqiSinrClpcPucchEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CQI_SINR_CLPC_PUCCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            clpcPuschEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            pdcchPowOrAggregationEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_PDCCH_POW_OR_AGG_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            clpcPuschfreqSelectiveEnable = RRM_DEFINED_DEFAULT_VALUE_FOR_CLPC_PUSCH_FREQ_SEL_ENABLE;

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            tpc_pdcch_ConfigPUCCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUCCH_ENABLE; 

        p_operator_info_to_cellm->rrm_mac_config.mac_power_control_enable.
            tpc_pdcch_ConfigPUSCH_enabled = RRM_DEFINED_DEFAULT_VALUE_FOR_TPC_PDCCH_CONFIG_PUSCH_ENABLE;
    }

    /*
     ** Power Control params will always be passed on to cellm (either from OAM or internal cfg file)
     ** so always set this bitmask.
     */
    p_operator_info_to_cellm->rrm_mac_config.bitmask |= RRMCM_RMIF_POWER_CONTROL_ENABLE_PRESENT;

    /*+ SPR 11442 Fix +*/
    /*Deleted unneccessary traces */
    /*- SPR 11442 Fix -*/
    /* Filling rrm_mac_enable_frequency_selective_scheduling_t */

    /* sub band cqi fix start*/
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity: CID 54854 */
        ul_dl_freq_value = 
            (rrm_ul_dl_freq_selective_sched_et)p_operator_info_from_oam->additional_packet_scheduling_params.frequency_selective_scheduling;
    }
    else
    {
        ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    }
    switch(ul_dl_freq_value)
    {
        case RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY:
            /* SPR 8497 FIX START*/
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            /* SPR 8497 FIX END*/
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE;
            break;

        default:
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "Incorrect Value(%d).. so Disbaling Frequency Selective Scheduling in both UL/DL",
                    ul_dl_freq_value);
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.dl_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
            p_operator_info_to_cellm->rrm_mac_config.
                enable_frequency_selective_scheduling.ul_freq_selective_enable = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE;
    }
    /* sub band cqi fix end */

    /* Additional parameters for Cell Config Added STARTS*/
    /* CHANGES_FRM_XML_TO_CFG START */

    /* + SPR 17665 + */
    if(p_mac_layer_params_from_oam->bitmask & RRM_OAM_DCI_FORMAT_FOR_SI_MSG_PRESENT)
    {
        dci_format_for_si_msg = 
            p_mac_layer_params_from_oam->dci_format_for_si_msg;
        p_operator_info_to_cellm->rrm_mac_config.bitmask |= RRMCM_RMIF_DCI_FORMAT_FOR_SI_MSG_PRESENT; 

        switch(dci_format_for_si_msg)
        {

            case RRM_OAM_RBS_PER_TBS_DCI_1A:
            {
                p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
                    RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A;

                if(p_mac_layer_params_from_oam->bitmask & RRM_OAM_NUM_OF_RB_DCI_FORMAT_1A_PRESENT)
                {    
                    for(count = RRM_ZERO; count < RBS_FOR_DCI_1A_SIZE; count++)
                    {

                        p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1a[count] =
                            p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1a[count];
                    }
                    p_operator_info_to_cellm->rrm_mac_config.bitmask |=  RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT; 
                }
                break;
            }

            case RRM_OAM_RBS_PER_TBS_DCI_1C:
            {
                p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
                    RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1C;

                if(p_mac_layer_params_from_oam->bitmask & RRM_OAM_NUM_OF_RB_DCI_FORMAT_1C_PRESENT)
                { 
                    for(count = RRM_ZERO; count < RBS_FOR_DCI_1C_SIZE; count++)
                    {

                        p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1c[count] =
                            p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1c[count];
                    }

                    p_operator_info_to_cellm->rrm_mac_config.bitmask |=  RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT; 
                }
                break;
            }
            default:
            p_operator_info_to_cellm->rrm_mac_config.rrm_dci_format_for_si_msg =
                RRM_DCI_FORMAT_FORMAT_FOR_SI_MSG_IS_1A;
        }


    }
    else if (p_mac_layer_params_from_oam->bitmask & RRM_OAM_NUM_OF_RB_DCI_FORMAT_1A_PRESENT)
    {

        for(count = RRM_ZERO; count < RBS_FOR_DCI_1A_SIZE; count++)
        {
            p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1a[count] =
                p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1a[count];
        }
        p_operator_info_to_cellm->rrm_mac_config.bitmask |=  RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1A_PRESENT; 
    }
    else if(p_mac_layer_params_from_oam->bitmask & RRM_OAM_NUM_OF_RB_DCI_FORMAT_1C_PRESENT) 
    {

        for(count = RRM_ZERO; count < RBS_FOR_DCI_1C_SIZE; count++)
        {

            p_operator_info_to_cellm->rrm_mac_config.num_rbs_per_tbs_dci_1c[count] =
                p_mac_layer_params_from_oam->num_rbs_per_tbs_dci_1c[count];
        }
        p_operator_info_to_cellm->rrm_mac_config.bitmask |=  RRMCM_RMIF_NUM_OF_RB_DCI_FORMAT_1C_PRESENT; 
    } 

    /* - SPR 17665 - */
    /* SPR 20653 Fix End */
    /* CHANGES_FRM_XML_TO_CFG END */

    /* BUG_371 FIX START */ 
    /* BUG_371 FIX END */ 
    /* Additional parameters for Cell Config Added  ENDS*/
    /* SPR 8505  FIX START */
    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */
    /* SPR 8505  FIX END */
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix End */
/****************************************************************************
 * Function Name  : populate_operator_sib1_info
 * Inputs         : -*p_operator_info_from_oam- operator info from oam
 *                  -*p_operator_cfg_params-operator info from cfg 
 *                  -*p_operator_info_to_cellm -operator info to cellm
 *                  -*intra_freq_reselection_from_oam - intra frequency                       reselection value from oam.
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates sib1 data of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
static void populate_operator_sib1_info
(rrm_oam_operator_info_t * p_operator_info_from_oam,
 /* BUG_371 FIX START */ 
 operator_info_t * p_operator_info_to_cellm
 //rrm_oam_intra_freq_reselection_et intra_freq_reselection_from_oam
 /* BUG_371 FIX END */ 
 /* SPR 20653 Fix End */
 )
{

    /*DYNAMIC SIB SCHEDULING START*/
    U8   si_count = 0;
    U8   sib_map_count = 0;
    /* CSR 00051178 CHANGES START */
    S32  sib_type;
    /* CSR 00051178 CHANGES  END*/
    /*DYNAMIC SIB SCHEDULING END*/
    S32 sib_invalid_type = 0xFFFFFFFF;
    RRM_UT_TRACE_ENTER();


    p_operator_info_to_cellm->sib_1_info.bitmask = 0x00;

    /* BUG_371 FIX START */ 
    /* p_operator_info_to_cellm->sib_1_info.cell_access_info.
       intra_frequency_reselection = intra_freq_reselection_from_oam; */
    /* BUG_371 FIX END */ 

    /* Populating sib_1_info */
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB1_INFO_PRESENT)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_ADDL_SIB1_INFO_PRESENT");

        /* CSR 00051178 CHANGES START */
        if (p_operator_info_from_oam->sib_1_info.bitmask & 
                RRM_OAM_SI_WINDOW_SIZE_PRESENT)
        {
            /* Coverity_ID : 54440 */
            p_operator_info_to_cellm->sib_1_info.si_window_length =
                (rrm_si_window_length_et)p_operator_info_from_oam->sib_1_info.si_window_length; /* Coverity: CID 54440 */
            /* SPR 20653 Fix Start */
        }
        else
        {
            /* Coverity_ID : 54440 */
            /* CID 112395 Start */
            p_operator_info_to_cellm->sib_1_info.si_window_length = (rrm_si_window_length_et)RRM_DEFINED_DEFAULT_VALUE_FOR_SI_WINDOW_LEN;
            /* CID 112395 End */
        }
        /* CID 112328 Start */
        p_operator_info_to_cellm->sib_1_info.scheduling_info_list.count =
            p_operator_info_from_oam->sib_1_info.si_count;
        /* CID 112328 End */

        for (si_count = 0; si_count <
                p_operator_info_from_oam->sib_1_info.si_count; si_count++)
        {
            p_operator_info_to_cellm->sib_1_info.scheduling_info_list.
                scheduling_info[si_count].si_periodicity =
                p_operator_info_from_oam->sib_1_info.scheduling_info[si_count].si_periodicity;

            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "SI Count [%d], SI Periodicity [%d], Details of SIBs in this SI are below..", si_count, 
                    p_operator_info_from_oam->sib_1_info.scheduling_info[si_count].si_periodicity);

            /*  (sib_map_count < MAX_SI_MSG_NUM) check is added under coverity fix. 
                as array size from mif to cellm is only 31 .but from oam to mif its
                size is 32. 
                */  
            /* coverity : CID 62001*/
            for (sib_map_count = 0;sib_map_count < MAX_SI_MSG_NUM ;sib_map_count++)
            {
                sib_type = p_operator_info_from_oam->sib_1_info.scheduling_info[si_count].
                    sib_mapping_info[sib_map_count].sib_type;
                if(sib_invalid_type == sib_type)
                {
                    break;
                }
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "SIB Type [%d]", sib_type);
                #ifdef LTE_EMBMS_SUPPORTED
                if (RRM_SEVEN == sib_type)
                {
		    /* SPR 22248 MBMS Changes Start */ 
                    /* code deleted */
                    /* SPR 22248 MBMS Changes Stop */
                    p_operator_info_to_cellm->sib_1_info.scheduling_info_list.scheduling_info[si_count].
                    sib_mapping_info.sib_type[sib_map_count] = RRM_TEN;
                }
                else
                {
                #endif
                p_operator_info_to_cellm->sib_1_info.
                    scheduling_info_list.scheduling_info[si_count].
                    sib_mapping_info.sib_type[sib_map_count] = sib_type;
                #ifdef LTE_EMBMS_SUPPORTED
                }
                #endif
            }

            p_operator_info_to_cellm->sib_1_info.scheduling_info_list.
                scheduling_info[si_count].sib_mapping_info.count = sib_map_count;
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "Total SIBs in this SI [%d]", sib_map_count);
        }

        /*> Populating SIB1 ims_emergency_support_r9 */
        p_operator_info_to_cellm->sib_1_info.ims_emergency_support_r9 =
            RRM_FALSE;
        if (p_operator_info_from_oam->sib_1_info.
                bitmask & RRM_OAM_IMS_EMERGENCY_SUPPORT_R9_PRESENT)
        {
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_IMS_EMERGENCY_SUPPORT_R9_PRESENT");
            if (RRM_OAM_IMS_SUPPORT_TRUE ==
                    p_operator_info_from_oam->sib_1_info.ims_emergency_support_r9)
            {
                p_operator_info_to_cellm->sib_1_info.ims_emergency_support_r9 =
                    RRM_TRUE;
            }
        }

        if (p_operator_info_from_oam->sib_1_info.bitmask &
                RRM_OAM_CELL_SELECTION_INFO_R9_PRESENT)
        {
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_CELL_SELECTION_INFO_R9_PRESENT");
            p_operator_info_to_cellm->sib_1_info.bitmask |=
                RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT;
            /* > Populating SIB1.cell_selection_info */
            p_operator_info_to_cellm->sib_1_info.cell_selection_info.bitmask =
                0x00;

            p_operator_info_to_cellm->sib_1_info.cell_selection_info.
                q_qual_min_r9 =
                p_operator_info_from_oam->sib_1_info.cell_selection_info.
                q_qual_min_r9;

            if (p_operator_info_from_oam->sib_1_info.cell_selection_info.
                    bitmask & RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT)
            {
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name,
                        RRM_DETAILED,
                        "RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT");
                p_operator_info_to_cellm->sib_1_info.cell_selection_info.
                    bitmask |= RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT;
                p_operator_info_to_cellm->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present =
                    p_operator_info_from_oam->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;
            }
            else
            {
                p_operator_info_to_cellm->sib_1_info.cell_selection_info.bitmask |= RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT;
                p_operator_info_to_cellm->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present =
                    RRM_DEFINED_DEFAULT_VALUE_FOR_Q_QUAL_MIN_OFFSET_R9_PRESENT;
            }
        }
    }
    else
    {
        /* Coverity_ID : 54441 */
        /* CID 112396 Start */
        p_operator_info_to_cellm->sib_1_info.si_window_length = (rrm_si_window_length_et)RRM_DEFINED_DEFAULT_VALUE_FOR_SI_WINDOW_LEN; 
        /* CID 112396 End */
        p_operator_info_to_cellm->sib_1_info.scheduling_info_list.count = RRM_DEFINED_DEFAULT_VALUE_FOR_SI_SCHEDULING_COUNT;

        /*DYNAMIC SIB SCHEDULING START*/
        for (si_count = 0; si_count < p_operator_info_to_cellm->sib_1_info.scheduling_info_list.count; si_count++)
        {
            p_operator_info_to_cellm->sib_1_info.
                scheduling_info_list.scheduling_info[si_count].si_periodicity = RRM_DEFINED_DEFAULT_VALUE_FOR_SI_PERIODICITY;

            p_operator_info_to_cellm->sib_1_info.
                scheduling_info_list.scheduling_info[si_count].sib_mapping_info.count = RRM_DEFINED_DEFAULT_VALUE_FOR_PER_SI_SIB_MAPPING_COUNT;
            for (sib_map_count = 0; sib_map_count < p_operator_info_to_cellm->sib_1_info.scheduling_info_list.
                    scheduling_info[si_count].sib_mapping_info.count;
                    sib_map_count++)
            {
                p_operator_info_to_cellm->sib_1_info.
                    scheduling_info_list.scheduling_info[si_count].
                    sib_mapping_info.sib_type[sib_map_count] = sib_map_count; 
                /* SPR 20653 Fix End */
            }
        }
    }
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix Start */
/* Code Removed */
/* SPR 20653 Fix End */

/* HO Enh start */
/*******************************************************************************************
 * Function Name  : populate_rat_priority_info
 * Inputs         : Cell Mgr operator Info,  configured operator Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the RAT Priority Info into the Cell config request
 ********************************************************************************************/
static rrm_void_t populate_rat_priority_info(
        operator_info_t   *p_operator_info_to_cellm,
        /* SPR 20653 Fix Start */
        rrm_oam_operator_info_t *p_operator_info_from_oam
        /* SPR 20653 Fix End */
        )
/* SPR 20653 Fix Start */
{
    U8 count = RRM_ZERO;
    for(count = RRM_ZERO; count < RRM_IRAT_PRIORITY_MAX; count ++)
    {
        p_operator_info_to_cellm->rat_priority_info.irat_priority_list_cfg[count] = 
            p_operator_info_from_oam->admission_control_info.spid_table.default_rat_priority_info.irat_priority_list_cfg[count];
    }
}
/* SPR 20653 Fix End */
/* HO Enh end */

/* DYNAMIC ICIC START */
/*******************************************************************************************
 * Function Name  : populate_dynamic_icic_periodicity_info 
 * Inputs         : Cell Mgr operator Info,  configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the dynamic icic perodicity information into the Cell config request
 ********************************************************************************************/
 /* SPR 20653 Fix Start */
static rrm_void_t  populate_dynamic_icic_periodicity_info(
        operator_info_t   *p_operator_info_to_cellm,
        rrm_oam_report_config_info_t *p_report_config_info_from_oam
        )
 /* SPR 20653 Fix End */
{
    RRM_UT_TRACE_ENTER();
    rrm_report_config_info_t *p_report_config_info = RRM_PNULL;

    p_report_config_info = &(p_operator_info_to_cellm->dynamic_icic_info.report_config_info);


    /* SPR 20653 Fix Start */
    if(RRM_OAM_L1_MEAS_REPORT_CONFIG_INFO_PRESENT & p_report_config_info_from_oam->bitmask)
    {
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->dynamic_icic_info.bitmask |= RRMCM_RMIF_REPORT_CONFIG_INFO_PRESENT; 
        /* SPR 21429 Fix End */
        p_report_config_info->l1_meas_report_config_info.layer1_meas_report_required =
            p_report_config_info_from_oam->l1_meas_report_config_info.layer1_meas_report_required;

        p_report_config_info->l1_meas_report_config_info.layer1_meas_report_avg_enabled =
            p_report_config_info_from_oam->l1_meas_report_config_info.layer1_meas_report_avg_enabled;

        p_report_config_info->l1_meas_report_config_info.layer1_meas_report_perodicity =
            p_report_config_info_from_oam->l1_meas_report_config_info.layer1_meas_report_periodicity;
        p_report_config_info->bitmask |=  RRM_L2_l1_MEAS_REPORT_CONFIG_INFO;

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    " RRM_L2_l1_MEAS_REPORT_CONFIG_INFO present");
    }

    if(RRM_OAM_L2_MEAS_REPORT_CONFIG_INFO_PRESENT & p_report_config_info_from_oam->bitmask)
    {
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->dynamic_icic_info.bitmask |= RRMCM_RMIF_REPORT_CONFIG_INFO_PRESENT; 
        /* SPR 21429 Fix End */

        p_report_config_info->l2_meas_report_config_info.cell_edge_prb_usage_required = 
            p_report_config_info_from_oam->l2_meas_report_config_info.cell_edge_prb_usage_required;
        
        p_report_config_info->l2_meas_report_config_info.l2_icic_report_perodicity =
            p_report_config_info_from_oam->l2_meas_report_config_info.l2_icic_report_periodicity;

       p_report_config_info-> bitmask |= RRM_L2_l2_MEAS_REPORT_CONFIG_INFO;
        
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    " RRM_L2_l2_MEAS_REPORT_CONFIG_INFO present");
    }       
    /* SPR 20653 Fix End */       
     RRM_UT_TRACE_EXIT();
}


 /* SPR 20653 Fix Start */
static rrm_void_t  populate_dynamic_icic_info(
        rrm_dynamic_icic_info_t                          *p_icic_info_to_cellm,
        rrm_oam_dynamic_icic_info_t                      *p_icic_info_from_oam,
        rrm_oam_alpha_et                                 alpha
        )
 /* SPR 20653 Fix End */
{
    U8 count    = RRM_ZERO;
    U8 count2 = RRM_ZERO;
 /* SPR 20653 Fix Start */
    /* Code Removed */
 /* SPR 20653 Fix End */
    U8 array_idx_to_be_updated = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    p_icic_info_to_cellm->bitmask = RRM_ZERO;

    /* To copy icic_scheme_type */
    if(RRM_OAM_ICIC_SCHEME_TYPE_PRESENT & p_icic_info_from_oam->bitmask)
    {
        switch(p_icic_info_from_oam->icic_scheme_type)
        {
            case RRM_ZERO:
                p_icic_info_to_cellm->icic_scheme_type = ICIC_SCHEME_HFR;
                p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT;   
                break;
            case RRM_ONE:
                p_icic_info_to_cellm->icic_scheme_type = ICIC_SCHEME_FFR;
                p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT;   
                break;
            case RRM_TWO:
                p_icic_info_to_cellm->icic_scheme_type = ICIC_SCHEME_SFR;
                p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT;   
                break;
            default:
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "Incorrect value entered for ICIC_SCHEME_TYPE %d",
                        p_icic_info_from_oam->icic_scheme_type);
        }
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " RRMCM_RMIF_ICIC_SCHEME_TYPE_PRESENT present");
    }

    /* To copy dl_resource_partition_info */
    if(RRM_OAM_DL_RESOURCE_PARTITON_INFO_PRESENT & p_icic_info_from_oam->bitmask)
    {
        (p_icic_info_to_cellm->dl_resource_partition_info).bitmask = 0x00;

        (p_icic_info_to_cellm->dl_resource_partition_info).num_of_cell_center_region =
            (p_icic_info_from_oam->dl_resource_partition_info).num_of_cell_center_region;

        (p_icic_info_to_cellm->dl_resource_partition_info).num_of_cell_edge_region = 
            (p_icic_info_from_oam->dl_resource_partition_info).num_of_cell_edge_region;

        for(count = RRM_ZERO; count < 
                p_icic_info_to_cellm->dl_resource_partition_info.
                num_of_cell_center_region; count++)
        {
            rrm_memcpy_mif_resource_partition(
                    &p_icic_info_to_cellm->dl_resource_partition_info.cell_center_region[count],
                    &p_icic_info_from_oam->dl_resource_partition_info.cell_center_region[count]);
        }

        if(RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT &
                (p_icic_info_from_oam->dl_resource_partition_info).bitmask)
        {

            rrm_memcpy_mif_resource_partition(
                    &(p_icic_info_to_cellm->dl_resource_partition_info).cell_edge_region,
                    &(p_icic_info_from_oam->dl_resource_partition_info).cell_edge_region);

            (p_icic_info_to_cellm->dl_resource_partition_info).bitmask |=
                RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
        }

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_DL_RESOURCE_PARTITION_INFO_PRESENT;   
        RRM_MEMCPY(&(p_icic_info_to_cellm->original_configured_dl_resource_partition_info),
                &(p_icic_info_to_cellm->dl_resource_partition_info),
                sizeof(rrm_resource_partition_info_t));
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_DL_RESOURCE_PARTITON_INFO_PRESENT present");
    }

    /* To copy ul_resource_partition_info */
    if(RRM_OAM_UL_RESOURCE_PARTITION_INFO_PRESENT & p_icic_info_from_oam->bitmask)
    {
        (p_icic_info_to_cellm->ul_resource_partition_info).bitmask = 0x00;

        (p_icic_info_to_cellm->ul_resource_partition_info).num_of_cell_center_region =
            (p_icic_info_from_oam->ul_resource_partition_info).num_of_cell_center_region;

        (p_icic_info_to_cellm->ul_resource_partition_info).num_of_cell_edge_region = 
            (p_icic_info_from_oam->ul_resource_partition_info).num_of_cell_edge_region;

        for(count = RRM_ZERO; count < p_icic_info_to_cellm->ul_resource_partition_info.
                num_of_cell_center_region; count++)
        {
            rrm_memcpy_mif_resource_partition(
                    &p_icic_info_to_cellm->ul_resource_partition_info.cell_center_region[count],
                    &p_icic_info_from_oam->ul_resource_partition_info.cell_center_region[count]);
        }

        if(RRM_OAM_RESOURCE_PARTITION_CELL_EDGE_PRESENT &
                (p_icic_info_from_oam->ul_resource_partition_info).bitmask)
        {
            rrm_memcpy_mif_resource_partition(
                    &(p_icic_info_to_cellm->ul_resource_partition_info).cell_edge_region,
                    &(p_icic_info_from_oam->ul_resource_partition_info).cell_edge_region);

            (p_icic_info_to_cellm->ul_resource_partition_info).bitmask |=
                RRMCM_RMIF_RESOURCE_PARTITION_CELL_EDGE_PRESENT;
        }

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT;   
        RRM_MEMCPY(&(p_icic_info_to_cellm->original_configured_ul_resource_partition_info),
                &(p_icic_info_to_cellm->ul_resource_partition_info),
                sizeof(rrm_resource_partition_info_t));
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " RRMCM_RMIF_UL_RESOURCE_PARTITION_INFO_PRESENT present");
    }

    /* To copy cc_power_mask    */
    if(RRM_OAM_UL_POWER_MASK_PRESENT & p_icic_info_from_oam->bitmask)
    {

        (p_icic_info_to_cellm->ul_power_mask).cell_center_user_power_mask= 
            (p_icic_info_from_oam->ul_power_mask).cell_center_user_power_mask;

        (p_icic_info_to_cellm->ul_power_mask).cell_edge_user_power_mask= 
            (p_icic_info_from_oam->ul_power_mask).cell_edge_user_power_mask;

        for(count = RRM_ZERO; count < RRM_OAM_MAX_QCI_VAL; count++)
        {
            p_icic_info_to_cellm->ul_power_mask.qci_delta_power_mask[count] = 
                p_icic_info_from_oam->ul_power_mask.qci_delta_power_mask[count];
        }

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_UL_POWER_MASK_PRESENT;   
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_UL_POWER_MASK_PRESENT present");
    }

    /* To copy rntp_report_config_info */
    if(RRM_OAM_RNTP_REPORT_CONFIG_INFO_PRESENT & p_icic_info_from_oam->bitmask)
    {
        (p_icic_info_to_cellm->rntp_report_config_info).bitmask = 0x00;

        (p_icic_info_to_cellm->rntp_report_config_info).rntp_report_on_X2_required= 
            (p_icic_info_from_oam->rntp_report_config_info).rntp_report_on_X2_required;

        if( RRM_OAM_RNTP_THRESHOLD_PRESENT & (p_icic_info_from_oam->rntp_report_config_info).bitmask)
        {
            /* SPR 20653 Fix Start */
            (p_icic_info_to_cellm->rntp_report_config_info).rntp_threshold =
                (p_icic_info_from_oam->rntp_report_config_info).rntp_threshold;
        }
        else
        {
            (p_icic_info_to_cellm->rntp_report_config_info).rntp_threshold = RRM_DEFINED_DEFAULT_VALUE_FOR_RNTP_THRESHOLD;
        }
        /* SPR 20653 Fix End */

        if( RRM_OAM_MAX_NOMINAL_EPRE_PRESENT & (p_icic_info_from_oam->rntp_report_config_info).bitmask)
        {
            (p_icic_info_to_cellm->rntp_report_config_info).max_nominal_epre =  
                (p_icic_info_from_oam->rntp_report_config_info).max_nominal_epre;
            (p_icic_info_to_cellm->rntp_report_config_info).bitmask |= 
                RRMCM_RMIF_MAX_NOMINAL_EPRE_PRESENT;
        }

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_RNTP_REPORT_CONFIG_INFO_PRESENT;   
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "  RRMCM_RMIF_RNTP_REPORT_CONFIG_INFO_PRESENT present");
    }

    /* SPR 20653 Fix Start */
    if (p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_TPC_FOR_MSG3_PRESENT)
    {
        p_icic_info_to_cellm->tpc_for_msg3 = p_icic_info_from_oam->tpc_info.tpc_for_msg3; 
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_TPC_FOR_MSG3_PRESENT;   
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_TPC_FOR_MSG3_PRESENT present");
    }
    if (p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_TPC_DCI_INFO_PRESENT)
    {
        if (p_icic_info_from_oam->tpc_info.dci_params.bitmask & RRM_OAM_TPC_TRIGGER_WAITTIME_FOR_PUSCH_DCI0_PRESENT)
        {
            p_icic_info_to_cellm->tpc_trigger_waittime_for_pusch_DCI0 = p_icic_info_from_oam->tpc_info.dci_params.tpc_trigger_waittime_for_pusch_DCI0; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUSCH_DCI0_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUSCH_DCI0_PRESENT present");
        }

        if (p_icic_info_from_oam->tpc_info.dci_params.bitmask & RRM_OAM_TPC_TRIGGER_WAITTIME_FOR_PUCCH_DCI1_X2X_PRESENT)
        {
            p_icic_info_to_cellm->tpc_trigger_waittime_for_pucch_DCI1x2x = p_icic_info_from_oam->tpc_info.dci_params.tpc_trigger_waittime_for_pucch_DCI1x2x; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUCCH_DCI1x2x_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_TPC_TRIGGER_WAIT_TIME_PUCCH_DCI1x2x_PRESENT present");
        }

        if (p_icic_info_from_oam->tpc_info.dci_params.bitmask & RRM_OAM_TPC_NUM_UE_THRESHOLD_FOR_PUCCH_DCI3A_PRESENT)
        {
            p_icic_info_to_cellm->tpc_num_ue_threshold_for_pucch_DCI3A = p_icic_info_from_oam->tpc_info.dci_params.tpc_num_ue_threshold_for_pucch_DCI3A; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUCCH_DCI3A_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUCCH_DCI3A_PRESENT present");
        }

        if (p_icic_info_from_oam->tpc_info.dci_params.bitmask & RRM_OAM_TPC_NUM_UE_THRESHOLD_FOR_PUSCH_DCI3A_PRESENT)
        {
            p_icic_info_to_cellm->tpc_num_ue_threshold_for_pusch_DCI3A = p_icic_info_from_oam->tpc_info.dci_params.tpc_num_ue_threshold_for_pusch_DCI3A; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUSCH_DCI3A_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_TPC_NUM_UE_THRESHOLD_PUSCH_DCI3A_PRESENT present");
        }
    }
    if (p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_COOLOFF_PERIOD_PRESENT)
    {
        if (p_icic_info_from_oam->tpc_info.cooloff_period.bitmask & RRM_OAM_COOLOFF_PERIOD_FOR_BLER_TRIGGERED_PUCCH_TPC_PRESENT)
        {
            p_icic_info_to_cellm->cooloff_period_for_bler_triggered_pucchTPC = p_icic_info_from_oam->tpc_info.cooloff_period.cooloff_period_for_bler_triggered_pucchTPC; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_COOL_OFF_PRD_FOR_BLER_BIT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_COOL_OFF_PRD_FOR_BLER_BIT present");
        }

        if (p_icic_info_from_oam->tpc_info.cooloff_period.bitmask & RRM_OAM_COOLOFF_PERIOD_FOR_PUCCH_TPC_PRESENT)
        {
            p_icic_info_to_cellm->cooloff_period_for_pucchTPC = p_icic_info_from_oam->tpc_info.cooloff_period.cooloff_period_for_pucchTPC; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_COOL_OFF_PERIOD_FOR_PUCCHTPC_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_COOL_OFF_PERIOD_FOR_PUCCHTPC_PRESENT present");
        }

        if (p_icic_info_from_oam->tpc_info.cooloff_period.bitmask & RRM_OAM_COOLOFF_PERIOD_FOR_PUSCH_TPC_PRESENT)
        {
            p_icic_info_to_cellm->cooloff_period_for_puschTPC = p_icic_info_from_oam->tpc_info.cooloff_period.cooloff_period_for_puschTPC; 
            p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_COOL_OFF_PERIOD_PUSCHTPC_PRESENT;   
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRMCM_RMIF_COOL_OFF_PERIOD_PUSCHTPC_PRESENT present");
        }

    }
    /*  copy delta_sinr_tpc_map_pusch_info*/
    if(p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_DELTA_SINR_TPC_MAP_PUSCH_INFO_PRESENT)
    {
        (p_icic_info_to_cellm->delta_sinr_tpc_map_pusch_info).count =
            p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pusch_info.count;

        for(count = RRM_ZERO; (count < (p_icic_info_to_cellm->delta_sinr_tpc_map_pusch_info).count) &&
                (count < RRM_MAX_NUM_TPC_FOR_PUSCH); count++)
        {
            p_icic_info_to_cellm->delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].start_delta_sinr =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].start_delta_sinr;

            p_icic_info_to_cellm->delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].end_delta_sinr =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].end_delta_sinr;

            p_icic_info_to_cellm->delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].pusch_tpc =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pusch_info.delta_sinr_to_tpc_map_pusch_info[count].pusch_tpc;

        }
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUSCH_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUSCH_PRESENT present");
    }

    /*  copy bler_to_tpc_map_for_pucch*/
    if(p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT)
    {
        p_icic_info_to_cellm->bler_to_tpc_map_for_pucch.pucch_bler_target =
            p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.pucch_bler_target;

        p_icic_info_to_cellm->bler_to_tpc_map_for_pucch.count = 
            p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.count;

        for(count = RRM_ZERO; (count < p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.count)  
                ;count++)
        {
            p_icic_info_to_cellm->bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].start_bler =
                p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].start_bler;

            p_icic_info_to_cellm->bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].end_bler =
                p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].end_bler;

            p_icic_info_to_cellm->bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].pucch_tpc =
                p_icic_info_from_oam->tpc_info.bler_to_tpc_map_for_pucch.delta_bler_tpc_map_pucch_info[count].pucch_tpc;
        }
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_BLER_TO_TPC_MAP_FOR_PUCCH_PRESENT present");
    }

    /*  copy delta_sinr_tpc_map_pucch_info  */
    if(p_icic_info_from_oam->tpc_info.bitmask & RRM_OAM_DELTA_SINR_TPC_MAP_PUCCH_INFO_PRESENT)
    {
        if(p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.bitmask & RRM_OAM_PUCCH_SINR_TARGET_PRESENT)
        {
            p_icic_info_to_cellm->delta_sinr_tpc_map_pucch_info.pucch_sint_target =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.pucch_sinr_target;
        }
        p_icic_info_to_cellm->delta_sinr_tpc_map_pucch_info.count =
            p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.count;

        for(count = RRM_ZERO; (count < p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.count) 
                ; count++)
        {
            p_icic_info_to_cellm->delta_sinr_tpc_map_pucch_info.delta_sinr_tpc_map_for_pucch_Info[count].start_sinr =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.delta_sinr_to_tpc_map_for_pucch_info[count].start_sinr;

            p_icic_info_to_cellm->delta_sinr_tpc_map_pucch_info.delta_sinr_tpc_map_for_pucch_Info[count].end_sinr =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.delta_sinr_to_tpc_map_for_pucch_info[count].end_sinr;

            p_icic_info_to_cellm->delta_sinr_tpc_map_pucch_info.delta_sinr_tpc_map_for_pucch_Info[count].pucch_tpc =
                p_icic_info_from_oam->tpc_info.delta_sinr_tpc_map_pucch_info.delta_sinr_to_tpc_map_for_pucch_info[count].pucch_tpc;
        }

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUCCH_PRESENT;

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_DELTA_SINR_TO_TPC_MAP_FOR_PUCCH_PRESENT present");
    }
    if (p_icic_info_from_oam->bitmask & RRM_OAM_SRS_SUBBAND_GROUP_SIZE_PRESENT)
    {
        p_icic_info_to_cellm->srs_subband_group_size = p_icic_info_from_oam->srs_subband_group_size; 
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_SRS_SUBBAND_GRP_SIZE_PRESENT;   
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_SRS_SUBBAND_GRP_SIZE_PRESENT present");
    }
    /* SPR 20653 Fix End */    

    /* copy rrm_alpha_based_pathloss_target_sinr_map */
    if(RRM_OAM_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT & p_icic_info_from_oam->bitmask)
    {
        /* SPR 20653 Fix Start */    
        /* Code Removed */
        /* SPR 20653 Fix End */    
        p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.default_path_loss =
            p_icic_info_from_oam->alpha_pathloss_target_sinr_map.default_path_loss;

        p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].count = 
            p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].count;

        switch(alpha)
        {
            case RRM_OAM_AL_0:
                array_idx_to_be_updated = RRM_ZERO;
                break;
            case RRM_OAM_AL_0_4:
                array_idx_to_be_updated = RRM_ONE;
                break;
            case RRM_OAM_AL_0_5:
                array_idx_to_be_updated = RRM_TWO;
                break;
            case RRM_OAM_AL_0_6:
                array_idx_to_be_updated = RRM_THREE;
                break;
            case RRM_OAM_AL_0_7:
                array_idx_to_be_updated = RRM_FOUR;
                break;
            case RRM_OAM_AL_0_8:
                array_idx_to_be_updated = RRM_FIVE;
                break;
            case RRM_OAM_AL_0_9:
                array_idx_to_be_updated = RRM_SIX;
                break;
            case RRM_OAM_AL_1:
                array_idx_to_be_updated = RRM_SEVEN;
                break;
        }

        p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.
            path_loss_target_sinr_map[array_idx_to_be_updated].count = 
            p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].count;
        for(count2 = RRM_ZERO; 
                (count2 < p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.
                 path_loss_target_sinr_map[array_idx_to_be_updated].count) &&
                (count2 < RRM_OAM_MAX_NUM_PATHLOSS_TO_SINR_COUNT); count2++)
        {
            p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[array_idx_to_be_updated].
                path_loss_to_target_sinr_map_info[count2].start_PL = 
                p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                path_loss_to_target_sinr_map_info[count2].start_PL;

            p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[array_idx_to_be_updated].
                path_loss_to_target_sinr_map_info[count2].end_PL = 
                p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                path_loss_to_target_sinr_map_info[count2].end_PL;
            p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[array_idx_to_be_updated].
                path_loss_to_target_sinr_map_info[count2].target_SINR = 
                p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                path_loss_to_target_sinr_map_info[count2].target_SINR;
        }

        /* RRM_ALPHA_Fix_Start */
        for(count = RRM_ZERO; count < RRM_MAX_NUM_ALPHA_COUNT; count++)
        {
            for(count2 = RRM_ZERO; 
                    (count2 < p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.
                     path_loss_target_sinr_map[array_idx_to_be_updated].count) &&
                    (count2 < RRM_OAM_MAX_NUM_PATHLOSS_TO_SINR_COUNT); count2++)
            {
                p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[count].
                    path_loss_to_target_sinr_map_info[count2].start_PL = 
                    p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                    path_loss_to_target_sinr_map_info[count2].start_PL;

                p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[count].
                    path_loss_to_target_sinr_map_info[count2].end_PL = 
                    p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                    path_loss_to_target_sinr_map_info[count2].end_PL;
                p_icic_info_to_cellm->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[count].
                    path_loss_to_target_sinr_map_info[count2].target_SINR = 
                    p_icic_info_from_oam->alpha_pathloss_target_sinr_map.path_loss_target_sinr_map[0].
                    path_loss_to_target_sinr_map_info[count2].target_SINR;
            }
        }
        /* RRM_ALPHA_Fix_End */

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT present");
    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /*  for copy pdcch_aggregation_power_offset*/
    if(RRM_OAM_PDCCH_AGG_AND_POW_OFFSET_PRESENT & p_icic_info_from_oam->bitmask)
    {
        p_icic_info_to_cellm->pdcch_aggregation_power_offset.bitmask = RRM_ZERO;

        RRM_MEMCPY(&(p_icic_info_to_cellm->pdcch_aggregation_power_offset).aggregation_power_offset_cc_user,
                &(p_icic_info_from_oam->pdcch_aggregation_power_offset).aggregation_power_offset_cc_user,
                (sizeof(rrm_oam_aggregation_power_offset_on_cqi_basis_t) * RRM_OAM_NUM_DCI_SIZE_CATEGORY));

        RRM_MEMCPY(&(p_icic_info_to_cellm->pdcch_aggregation_power_offset).aggregation_power_offset_ce_user,
                &(p_icic_info_from_oam->pdcch_aggregation_power_offset).aggregation_power_offset_ce_user,
                (sizeof(rrm_oam_aggregation_power_offset_on_cqi_basis_t) * RRM_OAM_NUM_DCI_SIZE_CATEGORY));

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_PDCCH_AGG_AND_POW_OFFSET_PRESENT present");
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_PDCCH_AGG_AND_POW_OFFSET_PRESENT;
    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    /* to copy cqi_to_phich_power */
    if(RRM_OAM_CQI_TO_PHICH_POW_PRESENT & p_icic_info_from_oam->bitmask)
    {
        RRM_MEMCPY(&(p_icic_info_to_cellm->cqi_to_phich_power).cqi_to_phich_power_info,
                &(p_icic_info_from_oam->cqi_to_phich_power).cqi_to_phich_power_info,
                (sizeof(U32)* RRM_OAM_MAX_CQI_VALUE));

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_CQI_TO_PHICH_POW_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_CQI_TO_PHICH_POW_PRESENT present");
    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /* To copy min_rb_for_pl_phr_calc */
    if( RRM_OAM_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT & p_icic_info_from_oam->bitmask)
    {
        p_icic_info_to_cellm->min_rb_for_pl_phr_calc = 
            p_icic_info_from_oam->min_rb_for_pl_phr_calc;

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT present");
    }
    /* SPR_14230_start */
    else
    {
        p_icic_info_to_cellm->min_rb_for_pl_phr_calc = RRM_MIN_RB_FOR_PL_PHR_CALC;
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " RRMCM_RMIF_MIN_RB_FOR_PL_PHR_CALC_BIT_PRESENT present");
    }

    /* SPR_14230_stop */
    /*  To copy sps_dl_scheduling_Info_per_tti */
    if(RRM_OAM_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT & p_icic_info_from_oam->bitmask)
    {
        p_icic_info_to_cellm->sps_dl_scheduling_Info_per_tti.max_dl_sps_dci_per_tti = 
            p_icic_info_from_oam->sps_dl_scheduling_Info_per_tti.max_dl_sps_dci_per_tti ;

        p_icic_info_to_cellm->sps_dl_scheduling_Info_per_tti.max_dl_sps_Occasion_Per_tti = 
            p_icic_info_from_oam->sps_dl_scheduling_Info_per_tti.max_dl_sps_Occasion_Per_tti;

        p_icic_info_to_cellm->sps_dl_scheduling_Info_per_tti.max_dl_sps_rbs_per_tti = 
            p_icic_info_from_oam->sps_dl_scheduling_Info_per_tti.max_dl_sps_rbs_per_tti;

        for(count = RRM_ZERO; count < RRM_OAM_MAX_SPS_INTERVALS; count++)
        {
            (p_icic_info_to_cellm->sps_dl_scheduling_Info_per_tti).max_dl_sps_rbs_per_tti_per_interval[count]=
                (p_icic_info_from_oam->sps_dl_scheduling_Info_per_tti).max_dl_sps_rbs_per_tti_per_interval[count];
        }
        /*
           RRM_MEMCPY(&(p_icic_info_to_cellm->sps_dl_scheduling_Info_per_tti).max_dl_sps_rbs_per_tti_per_interval,
           &(p_icic_info_from_oam->sps_dl_scheduling_Info_per_tti).max_dl_sps_rbs_per_tti_per_interval,
           (sizeof(U32)* RRMCM_RMIF_MAX_SPS_INTERVALS));
           */                    
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_SPS_DL_SCHEDULING_INFO_PER_TTI_PRESENT present");
    }

    /*  To copy sps_ul_scheduling_Info_per_tti  */
    /*spr_22058_changes_start*/
    if(RRM_OAM_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT & p_icic_info_from_oam->bitmask)
    /*spr_22058_changes_end*/
    {
        p_icic_info_to_cellm->sps_ul_scheduling_Info_per_tti.max_ul_sps_dci_per_tti =
            p_icic_info_from_oam->sps_ul_scheduling_Info_per_tti.max_ul_sps_dci_per_tti;

        p_icic_info_to_cellm->sps_ul_scheduling_Info_per_tti.max_ul_sps_occasion_per_tti = 
            p_icic_info_from_oam->sps_ul_scheduling_Info_per_tti.max_ul_sps_occasion_per_tti;

        p_icic_info_to_cellm->sps_ul_scheduling_Info_per_tti.max_ul_sps_rbs_per_tti = 
            p_icic_info_from_oam->sps_ul_scheduling_Info_per_tti.max_ul_sps_rbs_per_tti;

        for(count = RRM_ZERO; count < RRM_OAM_MAX_SPS_INTERVALS; count++)
        {
            (p_icic_info_to_cellm->sps_ul_scheduling_Info_per_tti).max_ul_sps_rbs_tti_per_interval[count] =
                (p_icic_info_from_oam->sps_ul_scheduling_Info_per_tti).max_ul_sps_rbs_tti_per_interval[count];
        }
        /*
           RRM_MEMCPY(&(p_icic_info_to_cellm->sps_ul_scheduling_Info_per_tti).max_ul_sps_rbs_tti_per_interval,
           &(p_icic_info_from_oam->sps_ul_scheduling_Info_per_tti).max_ul_sps_rbs_tti_per_interval,
           (sizeof(U32)* RRMCM_RMIF_MAX_SPS_INTERVALS));
           */
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_SPS_UL_SCHEDULING_INFO_PER_TTI_PRESENT present");
    }

    /*  To copy alpha_pathloss_target_sinr_map_sps  */
    if(RRM_OAM_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_SPS_PRESENT & p_icic_info_from_oam->bitmask)
    {
        /* 
           p_icic_info_to_cellm->alpha_pathloss_target_sinr_map_sps.default_path_loss =
           p_icic_info_from_oam->alpha_pathloss_target_sinr_map_sps.default_path_loss;

           RRM_MEMCPY(&(p_icic_info_to_cellm->alpha_pathloss_target_sinr_map_sps).path_loss_target_sinr_map,
           &(p_icic_info_from_oam->alpha_pathloss_target_sinr_map_sps).path_loss_target_sinr_map,
           (sizeof(rrm_oam_path_loss_to_target_sinr_map_t) * RRM_OAM_MAX_NUM_ALPHA_COUNT));
           */
        rrm_memcpy_oam_alpha_pathloss_target_sinr_map(
                &(p_icic_info_to_cellm->alpha_pathloss_target_sinr_map_sps),
                &(p_icic_info_from_oam->alpha_pathloss_target_sinr_map_sps));

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_SPS_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_ALPHA_BASED_PATH_LOSS_TO_SINR_MAP_PRESENT present");

    }

    /*  To copy dynamic_cfi_extension_param */
    if( RRM_OAM_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT & p_icic_info_from_oam->bitmask)
    {
        for( count = RRM_ZERO; count < RRM_OAM_MAX_POSSIBLE_AGGREGAITION_LEVELS; count++)
        {
            (p_icic_info_to_cellm->dynamic_cfi_extension_params).cce_correction_step_up_factor[count] =
                (p_icic_info_from_oam->dynamic_cfi_extension_params).cce_correction_step_up_factor[count];

            (p_icic_info_to_cellm->dynamic_cfi_extension_params).cce_correction_step_down_factor[count] = 
                (p_icic_info_from_oam->dynamic_cfi_extension_params).cce_correction_step_down_factor[count];

            (p_icic_info_to_cellm->dynamic_cfi_extension_params).cce_adjust_factor[count] = 
                (p_icic_info_from_oam->dynamic_cfi_extension_params).cce_adjust_factor[count];
        }
        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT; 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_DYNAMIC_CFI_EXTENSION_PARAM_PRESENT present");
    }

    /* To copy atb_config */
    if(p_icic_info_from_oam->bitmask & RRM_OAM_ATB_CONFIG_PRESENT)
    {
        p_icic_info_to_cellm->atb_config.min_mcs_index_for_atb = 
            p_icic_info_from_oam->atb_config.min_mcs_index_for_atb;

        p_icic_info_to_cellm->atb_config.min_prb_val_for_atb = 
            p_icic_info_from_oam->atb_config.min_prb_val_for_atb ;

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_ATB_CONFIG_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_ATB_CONFIG_PRESENT present");
    }

    /*  To copy ul_mu_mimo_type  */
    /*spr_22058_changes_start*/
    if(RRM_OAM_UL_MU_MIMO_TYPE_PRESENT & p_icic_info_from_oam->bitmask)
    /*spr_22058_changes_end*/
    {
        p_icic_info_to_cellm->ul_mu_mimo_type =
            p_icic_info_from_oam->ul_mu_mimo_type;

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_UL_MU_MIMO_TYPE_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_UL_MU_MIMO_TYPE_PRESENT present");
    }

    /* To copy msc_threshold_ul_mu_mimo  */ 
    if(RRM_OAM_MSC_THRESHOLD_UL_MU_MIMO_PRESENT & p_icic_info_from_oam->bitmask)
    {
        p_icic_info_to_cellm->msc_threshold_ul_mu_mimo = 
            p_icic_info_from_oam->msc_threshold_ul_mu_mimo;

        p_icic_info_to_cellm->bitmask |= RRMCM_RMIF_MSC_THRESHOLD_UL_MU_MIMO_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_MSC_THRESHOLD_UL_MU_MIMO_PRESENT present");
    }

    RRM_UT_TRACE_EXIT();
}


/* DYNAMIC ICIC END */

/*HO OScillation Start */
/*******************************************************************************************
 * Function Name  : populate_ho_oscillation_cfg_info_for_cell_reconfig 
 * Inputs         : Cell Mgr operator Info,  configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the GERAN cell information into the Cell config request
 ********************************************************************************************/
  /* SPR 20653 Fix Start */
static rrm_void_t populate_ho_oscillation_cfg_info_for_cell_reconfig(
        operator_info_t   *p_operator_info_to_cellm,
        rrm_oam_ho_oscillation_cfg_t *p_ho_oscillation_params_from_oam
         )
  /* SPR 20653 Fix End */
{
  /* SPR 20653 Fix Start */
  if(p_ho_oscillation_params_from_oam->bitmask & RRM_OAM_TIME_OF_STAY_THRESHOLD_PRESENT)
  {
    p_operator_info_to_cellm->ho_oscillation_cfg.time_of_stay_threshold = 
        p_ho_oscillation_params_from_oam->time_of_stay_threshold;
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->ho_oscillation_cfg.bitmask |= RRMCM_TIME_OF_STAY_THRESHOLD_PRESENT;
  }

  if(p_ho_oscillation_params_from_oam->bitmask & RRM_OAM_MIN_NUM_OF_OSCILLATION_LOOP_PRESENT)
  {
    p_operator_info_to_cellm->ho_oscillation_cfg.min_num_of_oscillation_loop = 
        p_ho_oscillation_params_from_oam->min_num_of_oscillation_loop;
    p_operator_info_to_cellm->ho_oscillation_cfg.bitmask |= RRMCM_MIN_NUM_OF_OSCILLATION_LOOP_PRESENT;
  }

  if(p_ho_oscillation_params_from_oam->bitmask & RRM_OAM_MAX_LAST_VISITED_CELLS_SEARCHED_PRESENT)
  {
    p_operator_info_to_cellm->ho_oscillation_cfg.max_last_visited_cells_searched = 
        p_ho_oscillation_params_from_oam->max_last_visited_cells_searched;
    p_operator_info_to_cellm->ho_oscillation_cfg.bitmask |= RRMCM_MAX_LAST_VISITED_CELLS_SEARCHED_PRESENT;
  }

  if(p_ho_oscillation_params_from_oam->bitmask & RRM_OAM_HO_OSCILLATION_CIO_OFFSET_PRESENT)
  {
    p_operator_info_to_cellm->ho_oscillation_cfg.ho_oscillation_cio_step = 
        (rrm_oam_q_offset_range_et)p_ho_oscillation_params_from_oam->ho_oscillation_cio_offset;
    p_operator_info_to_cellm->ho_oscillation_cfg.bitmask |= RRMCM_HO_OSCILLATION_CIO_STEP_PRESENT;
    /* SPR 21429 Fix End */
  }
  /* SPR 20653 Fix End */

}
/* SPR 20653 Fix Start */
/*******************************************************************************************
 * Function Name  : populate_ho_oscillation_cfg_info_for_cell_config 
 * Inputs         : Cell Mgr operator Info,  configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the GERAN cell information into the Cell config request
 ********************************************************************************************/
static rrm_void_t populate_ho_oscillation_cfg_info_for_cell_config(
        operator_info_t   *p_operator_info_to_cellm,
        rrm_oam_ho_oscillation_cfg_t *p_ho_oscillation_params_from_oam
         )
{
	p_operator_info_to_cellm->ho_oscillation_cfg.time_of_stay_threshold = 
		p_ho_oscillation_params_from_oam->time_of_stay_threshold;

	p_operator_info_to_cellm->ho_oscillation_cfg.min_num_of_oscillation_loop = 
		p_ho_oscillation_params_from_oam->min_num_of_oscillation_loop;

	p_operator_info_to_cellm->ho_oscillation_cfg.max_last_visited_cells_searched = 
		p_ho_oscillation_params_from_oam->max_last_visited_cells_searched;

	p_operator_info_to_cellm->ho_oscillation_cfg.ho_oscillation_cio_step = 
		(rrm_oam_q_offset_range_et)p_ho_oscillation_params_from_oam->ho_oscillation_cio_offset;

}
/* SPR 20653 Fix End */
/* BLR TEAM geran changes start */
/*******************************************************************************************
 * Function Name  : populate_operator_geran_cell_info
 * Inputs         : Cell Mgr operator Info, OAM configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the GERAN cell information into the Cell config request
 ********************************************************************************************/
static rrm_void_t populate_operator_geran_cell_info(
        operator_info_t   *p_operator_info_to_cellm)
{	
    rrm_geran_freq_priority_list_info_t  *p_cellm_geran_freq_priority_list_info = RRM_PNULL;
    p_cellm_geran_freq_priority_list_info = &(p_operator_info_to_cellm->freq_priority_list.geran_freq_priority_list_info);

    p_cellm_geran_freq_priority_list_info->count = 5;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[0].cell_reselection_priority = 2;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[0].carrier_freq.starting_arfcn = 11;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[0].carrier_freq.band_ind = RRM_SON_GERAN_PCS_1900;


    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].cell_reselection_priority = 7;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].carrier_freq.starting_arfcn = 21;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].carrier_freq.band_ind = RRM_SON_GERAN_PCS_1900;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].carrier_freq.following_arfcns.bitmask = 1;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].carrier_freq.following_arfcns.arfcn_bmp_list_size = 1;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[1].carrier_freq.following_arfcns.arfcn_bmp_list[0] = 2;

    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].cell_reselection_priority = 5;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.starting_arfcn = 31;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.band_ind = RRM_SON_GERAN_PCS_1900;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.following_arfcns.bitmask = 1;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.following_arfcns.exp_arfcn_list_size = 2;
    /* SPR 19838 : CID 11893 Fix Start */
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.following_arfcns.exp_arfcn_list[0] = 5;
    /* SPR 19838 : CID 11893 Fix End */
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[2].carrier_freq.following_arfcns.exp_arfcn_list[1] = 15;


    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].cell_reselection_priority = 3;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].carrier_freq.starting_arfcn = 41;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].carrier_freq.band_ind = RRM_SON_GERAN_PCS_1900;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].carrier_freq.following_arfcns.bitmask = 2;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].carrier_freq.following_arfcns.arfcn_spacing = 4;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[3].carrier_freq.following_arfcns.num_of_following_arfcn = 1;

    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[4].cell_reselection_priority = 0;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[4].carrier_freq.starting_arfcn = 51;
    p_cellm_geran_freq_priority_list_info->geran_freq_priority_info[4].carrier_freq.band_ind = RRM_SON_GERAN_PCS_1900;

}
/*BLR TEAM geran changes end */
/* BLR TEAM cdma changes start */
/*******************************************************************************************
 * Function Name  : populate_operator_cdma_cell_info
 * Inputs         : Cell Mgr operator Info, OAM configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the CDMA cell information into the Cell config request
 ********************************************************************************************/
static rrm_void_t populate_operator_cdma_cell_info(
        operator_info_t   *p_operator_info_to_cellm)
{	
    rrm_cdma_freq_priority_list_info_t  *p_cellm_cdma_freq_priority_list_info = RRM_PNULL;
    p_cellm_cdma_freq_priority_list_info = &(p_operator_info_to_cellm->freq_priority_list.cdma_freq_priority_list_info);

    p_cellm_cdma_freq_priority_list_info->count = 5;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[0].band_class = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[0].arfcn = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[0].cell_reselection_priority = 3;

    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[1].band_class = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[1].arfcn = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[1].cell_reselection_priority = 3;

    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[2].band_class = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[2].arfcn = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[2].cell_reselection_priority = 3;

    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[3].band_class = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[3].arfcn = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[3].cell_reselection_priority = 3;

    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[4].band_class = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[4].arfcn = 1;
    p_cellm_cdma_freq_priority_list_info->cdma_freq_priority_info[4].cell_reselection_priority = 3;
}

/***************************************************************************
 * Function Name  : populate_ho_config_params_info 
 * Inputs         : Cell Mgr operator Info, OAM configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the HO configuration params
 ***************************************************************************/
static rrm_void_t populate_ho_config_params_info(
        operator_info_t            *p_operator_info_to_cellm,
        rrm_oam_operator_info_t    *p_operator_info_from_oam)
{
    if(p_operator_info_from_oam->ho_configuration.bitmask & RRM_OAM_TARGET_CELL_SELECTION_PARAMS_PRESENT)
    {
        p_operator_info_to_cellm->ho_config_params.target_cell_selection_params.neighboring_cell_load_based_ho_enable=
            p_operator_info_from_oam->ho_configuration.target_cell_selection_params.neighboring_cell_load_based_ho_enable;

        p_operator_info_to_cellm->ho_config_params.target_cell_selection_params.ue_history_based_ho_enable=
            p_operator_info_from_oam->ho_configuration.target_cell_selection_params.ue_history_based_ho_enable;

        p_operator_info_to_cellm->ho_config_params.target_cell_selection_params.spid_based_ho_enable=
            p_operator_info_from_oam->ho_configuration.target_cell_selection_params.spid_based_ho_enable;

        p_operator_info_to_cellm->ho_config_params.target_cell_selection_params.ue_measurement_based_ho_enable=
            p_operator_info_from_oam->ho_configuration.target_cell_selection_params.ue_measurement_based_ho_enable;

        p_operator_info_to_cellm->ho_config_params.target_cell_selection_params.daho_cell_based_ho_enable=
            p_operator_info_from_oam->ho_configuration.target_cell_selection_params.daho_cell_based_ho_enable;

    }

    /* SPR 22311 Changes - Starts */
    /* SPR 20635 Fix - SRVCC to GERAN - Starts */
    if(p_operator_info_from_oam->ho_configuration.bitmask & RRM_OAM_UE_MEAS_DURATION_FOR_HO_PRESENT)
    {
        p_operator_info_to_cellm->ho_config_params.ue_meas_duration_for_ho=
            p_operator_info_from_oam->ho_configuration.ue_meas_duration_for_ho;
        p_operator_info_to_cellm->ho_config_params.bitmask |= RRMCM_RMIF_UE_MEAS_DURATION_HO_PRESENT;
    }
    /* SPR 20635 Fix - SRVCC to GERAN - Ends */
    /* SPR 22311 Changes - Ends */

    if(p_operator_info_from_oam->ho_configuration.bitmask & RRM_OAM_HO_RETRY_PARAMS_PRESENT)
    {
        p_operator_info_to_cellm->ho_config_params.bitmask |= RRMCM_RMIF_HO_RETRY_PARAMS_PRESENT; 

        /* SPR 22311 Changes - Starts */
        /* Code Deleted */
        /* SPR 22311 Changes - Ends */

        /* Bug 4618 start */
        if(p_operator_info_from_oam->ho_configuration.ho_retry_params.bitmask & RRMCM_RMIF_HO_RETRY_COUNT_PRESENT)
        {
            p_operator_info_to_cellm->ho_config_params.ho_retry_params.ho_retry_count=
                p_operator_info_from_oam->ho_configuration.ho_retry_params.ho_retry_count;
        }
        else
        {
            p_operator_info_to_cellm->ho_config_params.ho_retry_params.ho_retry_count = RRM_ONE;
        }
        /* Bug 4618 end */
     }   
     /* Bug 4618 start */
     else 
     {
         p_operator_info_to_cellm->ho_config_params.bitmask |= RRMCM_RMIF_HO_RETRY_PARAMS_PRESENT;
        /* SPR 22311 Changes - Starts */
        /* Code Deleted */
        /* SPR 22311 Changes - Ends */
         p_operator_info_to_cellm->ho_config_params.ho_retry_params.ho_retry_count= RRM_ONE;
     }
     /* Bug 4618 end */

   /* SPR 20653 Fix Start */
   if(p_operator_info_from_oam->ho_configuration.bitmask & RRM_OAM_HO_OSCILLATION_CFG_PRESENT)
   {
       populate_ho_oscillation_cfg_info_for_cell_reconfig(p_operator_info_to_cellm,
               &p_operator_info_from_oam->ho_configuration.ho_oscillation_cfg);
   }
   /* SPR 20653 Fix End */
}
/* HO config params end */

/* Limiting UE meas start */
/***************************************************************************
 * Function Name  : populate_meas_config_info
 * Inputs         : Cell Mgr operator Info, OAM configured operaotor Info
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This function fills the meas_config_info (for 
 *                  E-UTRAN/UTRAN/GERAN/CDMA200) into the Cell config request
 ***************************************************************************/
static rrm_void_t populate_meas_config_info(
        operator_info_t            *p_operator_info_to_cellm,
        rrm_oam_operator_info_t    *p_operator_info_from_oam)
{

    /* SPR 14060 FIX : code removed */        
    p_operator_info_to_cellm->meas_config_info.bitmask |= RRMCM_RMIF_MEAS_GAP_CONFIG_PRESENT;

    /* SPR 5883 starts */
    p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask = 0x00;

    if(p_operator_info_from_oam->measurement_configuration.meas_gap_config.bitmask &
            RRM_OAM_E_UTRAN_GAP_OFFSET_TYPE_PRESENT)
    {
        p_operator_info_to_cellm->meas_config_info.meas_gap_config.eutran_gap_offset_type  = 
            p_operator_info_from_oam->measurement_configuration.meas_gap_config.eutran_gap_offset_type;

        p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask |=
            RRMCM_RMIF_EUTRAN_GAP_OFFSET_TYPE_PRESENT;
    }

    if(p_operator_info_from_oam->measurement_configuration.meas_gap_config.bitmask &
            RRM_OAM_UTRAN_GAP_OFFSET_TYPE_PRESENT)
    {
        p_operator_info_to_cellm->meas_config_info.meas_gap_config.utran_gap_offset_type = 
            p_operator_info_from_oam->measurement_configuration.meas_gap_config.utran_gap_offset_type;

        p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask |=
            RRMCM_RMIF_UTRAN_GAP_OFFSET_TYPE_PRESENT;
    }

    if(p_operator_info_from_oam->measurement_configuration.meas_gap_config.bitmask &
            RRM_OAM_GERAN_GAP_OFFSET_TYPE_PRESENT)
    {
        p_operator_info_to_cellm->meas_config_info.meas_gap_config.geran_gap_offset_type = 
            p_operator_info_from_oam->measurement_configuration.meas_gap_config.geran_gap_offset_type;

        p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask |=
            RRMCM_RMIF_GERAN_GAP_OFFSET_TYPE_PRESENT;
    }

    if(p_operator_info_from_oam->measurement_configuration.meas_gap_config.bitmask &
            RRM_OAM_CDMA2000_GAP_OFFSET_TYPE_PRESENT)
    {
        p_operator_info_to_cellm->meas_config_info.meas_gap_config.cdma2000_gap_offset_type = 
            p_operator_info_from_oam->measurement_configuration.meas_gap_config.cdma2000_gap_offset_type;

        p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask |=
            RRMCM_RMIF_CDMA2000_GAP_OFFSET_TYPE_PRESENT;
    }
    /* SPR 5883 end */
#ifdef ENDC_ENABLED
    if(p_operator_info_from_oam->measurement_configuration.meas_gap_config.bitmask &
            RRM_OAM_ENDC_GAP_OFFSET_TYPE_PRESENT)
    {
        p_operator_info_to_cellm->meas_config_info.meas_gap_config.endc_gap_offset_type = 
            p_operator_info_from_oam->measurement_configuration.meas_gap_config.endc_gap_offset_type;

        p_operator_info_to_cellm->meas_config_info.meas_gap_config.bitmask |=
            RRMCM_RMIF_ENDC_GAP_OFFSET_TYPE_PRESENT;
    }
#endif
    p_operator_info_to_cellm->meas_config_info.bitmask |= RRMCM_RMIF_SI_GAP_ENABLE_PRESENT;


    p_operator_info_to_cellm->meas_config_info.si_gap_enable = 
        p_operator_info_from_oam->measurement_configuration.si_gap_enable;

    /*csfb target selection start*/
    if(p_operator_info_from_oam->measurement_configuration.bitmask & RRM_OAM_CSFB_TGT_SELECTION_PRESENT) 
    {
        p_operator_info_to_cellm->meas_config_info.bitmask |= RRMCM_RMIF_CSFB_TGT_SELECTION_PRESENT;
        if(p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.bitmask &
                RRM_OAM_UTRAN_CSFB_TGT_SELECTION_PRESENT)
        {
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.bitmask |= 
                RRMCM_RMIF_UTRAN_CSFB_TGT_SELECTION_PRESENT;
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.utran_csfb_tgt_selection =
                p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.utran_csfb_tgt_selection;

        }
        if(p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.bitmask &
                RRM_OAM_GERAN_CSFB_TGT_SELECTION_PRESENT)
        {
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.bitmask |= 
                RRMCM_RMIF_GERAN_CSFB_TGT_SELECTION_PRESENT;
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.geran_csfb_tgt_selection =
                p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.geran_csfb_tgt_selection;

        }
        if(p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.bitmask &
                RRM_OAM_CDMA2000_CSFB_TGT_SELECTION_PRESENT)
        {
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.bitmask |= 
                RRMCM_RMIF_CDMA2000_CSFB_TGT_SELECTION_PRESENT;
            p_operator_info_to_cellm->meas_config_info.csfb_tgt_selection.cdma2000_csfb_tgt_selection =
                p_operator_info_from_oam->measurement_configuration.csfb_tgt_selection.cdma2000_csfb_tgt_selection;

        }

    }
    /*csfb target selection end*/

}
/* Limiting UE meas end */
/* BLR TEAM cdma changes end */

/****************************************************************************
 * Function Name  : rrm_mif_fill_ssac_barring_r9_info
 * Inputs         : *ssac_barring_r9_to_cellm, *ssac_barring_r9_from_oam
 *                  
 * Outputs        : None.
 * Returns        : Void
 * Description    : This function populates sib2 ssac_barring_r9_info info
 *                  for cellM.
 ****************************************************************************/
void rrm_mif_fill_ssac_barring_r9_info(
        rrm_ssac_barring_for_mmtel_r9_t       *ssac_barring_r9_to_cellm, 
        rrm_oam_ssac_barring_for_mmtel_r9_t   *ssac_barring_r9_from_oam)
{
    RRM_UT_TRACE_ENTER();

    ssac_barring_r9_to_cellm->bitmask = 0;

    /*filling mmtel_voice_r9 Info*/
    if (RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT == 
            (ssac_barring_r9_from_oam->bitmask& RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT))
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT");
        /* coverity : CID 16497*/
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_voice_r9.ac_barring_factor= 
            (rrm_mif_ac_barring_factor_et) ssac_barring_r9_from_oam->ssac_barring_for_mmtel_voice_r9.ac_barring_factor; 
        /* coverity : CID 16498*/
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_voice_r9.ac_barring_time= 
            (rrm_mif_ac_barring_time_et) ssac_barring_r9_from_oam->ssac_barring_for_mmtel_voice_r9.ac_barring_time; 
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac= 
            ssac_barring_r9_from_oam->ssac_barring_for_mmtel_voice_r9.ac_barring_for_special_ac; 

        ssac_barring_r9_to_cellm->bitmask |= RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT;
    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT not set");
    }

    /*filling mmtel_video_r9 Info*/
    if (RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT == 
            (ssac_barring_r9_from_oam->bitmask& RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT))
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT");

        /* coverity : CID 16495*/
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_video_r9.ac_barring_factor= 
            (rrm_mif_ac_barring_factor_et) ssac_barring_r9_from_oam->ssac_barring_for_mmtel_video_r9.ac_barring_factor; 
        /* coverity : CID 16496*/
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_video_r9.ac_barring_time= 
            (rrm_mif_ac_barring_time_et) ssac_barring_r9_from_oam->ssac_barring_for_mmtel_video_r9.ac_barring_time; 
        ssac_barring_r9_to_cellm->ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac= 
            ssac_barring_r9_from_oam->ssac_barring_for_mmtel_video_r9.ac_barring_for_special_ac; 

        ssac_barring_r9_to_cellm->bitmask |= RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT;
    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT not set");
    }

    RRM_UT_TRACE_EXIT();
}

void rrm_mif_fill_access_barring_info( 
        rrm_access_barring_info_t       *p_access_barring_info_to_cellm, 
        rrm_oam_access_barring_info_t   *p_access_barring_info_from_oam)
{
    RRM_UT_TRACE_ENTER();

    p_access_barring_info_to_cellm->bitmask = RRM_ZERO;

    if (RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT == 
            (p_access_barring_info_from_oam->bitmask & RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT");
        p_access_barring_info_to_cellm->bitmask |= RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT;

        /* coverity : CID 16493*/
        p_access_barring_info_to_cellm->ac_barring_for_mo_signalling.ac_barring_factor =
            (rrm_mif_ac_barring_factor_et) p_access_barring_info_from_oam->ac_barring_for_mo_signalling.ac_barring_factor;    
        /* coverity : CID 16494*/
        p_access_barring_info_to_cellm->ac_barring_for_mo_signalling.ac_barring_time =  
            (rrm_mif_ac_barring_time_et) p_access_barring_info_from_oam->ac_barring_for_mo_signalling.ac_barring_time;
        p_access_barring_info_to_cellm->ac_barring_for_mo_signalling.ac_barring_for_special_ac= 
            p_access_barring_info_from_oam->ac_barring_for_mo_signalling.ac_barring_for_special_ac;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT not set");
    }  

    if (RRM_OAM_AC_BARRING_MO_DATA_PRESENT == 
            (p_access_barring_info_from_oam->bitmask & RRM_OAM_AC_BARRING_MO_DATA_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_AC_BARRING_MO_DATA_PRESENT");
        p_access_barring_info_to_cellm->bitmask |= RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT;

        /* coverity : CID 16491*/
        p_access_barring_info_to_cellm->ac_barring_for_mo_data.ac_barring_factor=
            (rrm_mif_ac_barring_factor_et) p_access_barring_info_from_oam->ac_barring_for_mo_data.ac_barring_factor;
        /* coverity : CID 16492*/
        p_access_barring_info_to_cellm->ac_barring_for_mo_data.ac_barring_time=
            (rrm_mif_ac_barring_time_et) p_access_barring_info_from_oam->ac_barring_for_mo_data.ac_barring_time;
        p_access_barring_info_to_cellm->ac_barring_for_mo_data.ac_barring_for_special_ac=
            p_access_barring_info_from_oam->ac_barring_for_mo_data.ac_barring_for_special_ac;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_AC_BARRING_MO_DATA_PRESENT not set");
    }

    if (RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT ==
            (p_access_barring_info_from_oam->bitmask & RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT");
        p_access_barring_info_to_cellm->bitmask |= RRMCM_RMIF_SSAC_BARRING_FOR_MMTEL_PRESENT;

        rrm_mif_fill_ssac_barring_r9_info(
                &p_access_barring_info_to_cellm->ssac_barring_r9, 
                &p_access_barring_info_from_oam->ssac_barring_r9);
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT not set");
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : populate_operator_sib2_info
 * Inputs         : -*p_operator_info_from_oam -operator info from oam
 *                  -*p_operator_cfg_params- operator info from cfg
 *                  -*p_operator_info_to_cellm-operator info for cellm
 *                  -rf_cnfig_ul_bandwidth - UL bandwith from cfg
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates sib2 data of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
static void populate_operator_sib2_info(
        operator_info_t           *p_operator_info_to_cellm,
        rrm_oam_operator_info_t   *p_operator_info_from_oam,
        rrm_oam_band_width_et     rf_cnfig_ul_bandwidth)
 /* SPR 20653 Fix End */
{
    RRM_UT_TRACE_ENTER();

    /* Populating SIB2 Info */

    /* common_sib - start */
    if (p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT");
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_bcch_config.modification_period_coeff =
            p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            modification_period_coeff;
    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_MODIFICATION_PERIOD_COEFF_PRESENT");
        /* Coverity_ID : 55810 */
        /* Assigning by default corresponding enum of RRM_RRC_MOD_PERIOD_COFF_CFG 
        */
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_bcch_config.modification_period_coeff = RRM_OAM_MOD_PERIOD_COEFF_N2;
    }

    if (p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_DEFAULT_PAGING_CYCLE_PRESENT");
        /* SPR 20653 Fix Start */
            p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_pcch_config.default_paging_cycle =
            p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            default_paging_cycle;
    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_MACRO_DEFAULT_PAGING_CYCLE_PRESENT");
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_pcch_config.default_paging_cycle = RRM_OAM_DEF_PAG_CYCLE_RF128; 
    }

    if (p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_NB_PRESENT)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_NB_PRESENT");
            p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_pcch_config.nB =
            p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.nB;
    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_CFG_NB_PRESENT");
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            rrm_pcch_config.nB = RRM_OAM_NB_ONE_T; 
    }

    if (p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_UL_CYCLIC_PREFIX_LEN_PRESENT)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_UL_CYCLIC_PREFIX_LEN_PRESENT");
        /* Coverity_ID : 53618 */
        p_operator_info_to_cellm->
            sib_2_info.radio_res_config_common_sib.ul_cyclic_prefix_length =
            p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            ul_cyclic_prefix_length;

    }
    else
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_CFG_UL_CYCLIC_PREFIX_LEN_PRESENT");
        /* coverity : CID 16460*/
        /* CID 112401 Start */
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
            ul_cyclic_prefix_length = (rrm_oam_ul_cyclic_prefix_length_et)RRM_RRC_UL_CYC_PREFIX_LEN_1_CFG;
        /* CID 112401 End */
    }
/* SPR 20653 Fix End */

    p_operator_info_to_cellm->sib_2_info.
        radio_res_config_common_sib.bitmask = 0x00;
    if (p_operator_info_from_oam->sib_2_info.radio_res_config_common_sib.
            bitmask & RRM_OAM_BARRING_INFO_PRESENT)
    {
        /* access barring info */
        rrm_mif_fill_access_barring_info(
                &p_operator_info_to_cellm->sib_2_info.
                radio_res_config_common_sib.access_barring_info,
                &p_operator_info_from_oam->sib_2_info.
                radio_res_config_common_sib.access_barring_info);

        p_operator_info_to_cellm->sib_2_info.
            radio_res_config_common_sib.bitmask |= RRMCM_RMIF_BARRING_INFO_PRESENT;
    }

    /* common_sib - end */
    /* SPR 5692 */
    if((p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
                access_barring_info.bitmask & RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT) ||
            (p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
             access_barring_info.bitmask & RRM_OAM_AC_BARRING_MO_DATA_PRESENT) ||
            (p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.
             access_barring_info.bitmask & RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT))
    {
        p_operator_info_to_cellm->sib_2_info.radio_res_config_common_sib.bitmask |= 
            RRMCM_RMIF_BARRING_INFO_PRESENT;
    }
    /* SPR 5692 */

    p_operator_info_to_cellm->sib_2_info.rrm_freq_info.bitmask = 0x00;

    p_operator_info_to_cellm->sib_2_info.rrm_freq_info.ul_carrier_freq =
        rf_cnfig_ul_bandwidth;

    p_operator_info_to_cellm->sib_2_info.rrm_freq_info.
        additional_spectrum_emission =
        p_operator_info_from_oam->sib_2_info.additional_spectrum_emission;

    p_operator_info_to_cellm->sib_2_info.time_alignment_timer =
        p_operator_info_from_oam->sib_2_info.time_alignment_timer_common;
    /*added for access params by gur30308 */
    /*SPR_15289_changes_Start*/
    if(p_operator_info_from_oam->sib_2_info.presence_bitmask & RRM_OAM_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG)
    {
        RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG");
        p_operator_info_to_cellm->sib_2_info.presence_bitmask = RRM_ZERO;
        p_operator_info_to_cellm->sib_2_info.presence_bitmask |= RRMCM_RMIF_AC_BARRING_PARAM_CSFB_R10_PRESENCE_FLAG;
        p_operator_info_to_cellm->sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor =
            (rrm_mif_ac_barring_factor_et)p_operator_info_from_oam->sib_2_info.ac_barring_for_csfb_r10.ac_barring_factor;/*cov 83673 +-*/
        p_operator_info_to_cellm->sib_2_info.ac_barring_for_csfb_r10.ac_barring_time=
            (rrm_mif_ac_barring_time_et)p_operator_info_from_oam->sib_2_info.ac_barring_for_csfb_r10.ac_barring_time;/*cov 83667+-*/
        p_operator_info_to_cellm->sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac =
            p_operator_info_from_oam->sib_2_info.ac_barring_for_csfb_r10.ac_barring_for_special_ac;
    }
    /*SPR_15289_changes_End*/

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : populate_operator_sib3_info
 * Inputs         : -*p_operator_info_from_oam - operator info from oam
 *                  -*p_operator_info_to_cellm - operator info for cellm
 *                  -*p_operator_cfg_params - cfg params
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates sib3 data of operator info
 *                  for cell_m using the param from OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
    static void populate_operator_sib3_info
(operator_info_t * p_operator_info_to_cellm,
 rrm_oam_operator_info_t * p_operator_info_from_oam
 )
 /* SPR 20653 Fix End */
{
    RRM_UT_TRACE_ENTER();
    /* Populating SIB3*/
    p_operator_info_to_cellm->sib_3_info.bitmask = 0x00;

    /* Populating SIB3.intra_freq_reselection_info params*/
    p_operator_info_to_cellm->sib_3_info.intra_freq_reselection_info.bitmask = 0x00;

    if (p_operator_info_from_oam->sib_3_info.intra_freq_reselection_info.bitmask &
            RRM_OAM_MEAS_BW_PRESENT)
    {
        p_operator_info_to_cellm->sib_3_info.intra_freq_reselection_info.bitmask |=
            RRMCM_RMIF_MEASUREMENT_BW_PRESENT;
        p_operator_info_to_cellm->sib_3_info.
            intra_freq_reselection_info.measurement_bandwidth =
            p_operator_info_from_oam->sib_3_info.
            intra_freq_reselection_info.measurement_bandwidth;
    }

    p_operator_info_to_cellm->sib_3_info.intra_freq_reselection_info.
        presence_antenna_port1 =
        p_operator_info_from_oam->sib_3_info.intra_freq_reselection_info.
        presence_antenna_port1;

    if (p_operator_info_from_oam->sib_3_info.bitmask &
            RRM_OAM_S_INTRA_SEARCH_V920_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_S_INTRA_SEARCH_V920_PRESENT");
        /* > Populating SIB3.s_intra_search params*/
        p_operator_info_to_cellm->sib_3_info.bitmask |=
            RRMCM_RMIF_S_INTRA_SEARCH_V920_PRESENT;
        p_operator_info_to_cellm->sib_3_info.s_intra_search.s_intra_search_p_r9=
            p_operator_info_from_oam->sib_3_info.s_intra_search.s_intra_search_p_r9;
        p_operator_info_to_cellm->sib_3_info.s_intra_search.s_intra_search_q_r9=
            p_operator_info_from_oam->sib_3_info.s_intra_search.s_intra_search_q_r9;
    }

    if (p_operator_info_from_oam->sib_3_info.bitmask&
            RRM_OAM_S_NON_INTRA_SEARCH_V920_PRESENT)
    {
        /* > Populating SIB3.s_intra_search params*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_S_NON_INTRA_SEARCH_V920_PRESENT");
        p_operator_info_to_cellm->sib_3_info.bitmask|=
            RRMCM_RMIF_S_NON_INTRA_SEARCH_V920_PRESENT;
        p_operator_info_to_cellm->sib_3_info.s_non_intra_search.s_non_intra_search_p_r9=
            p_operator_info_from_oam->sib_3_info.s_non_intra_search.s_non_intra_search_p_r9;
        p_operator_info_to_cellm->sib_3_info.s_non_intra_search.s_non_intra_search_q_r9=
            p_operator_info_from_oam->sib_3_info.s_non_intra_search.s_non_intra_search_q_r9;
    }

    if (p_operator_info_from_oam->sib_3_info.bitmask &
            RRM_OAM_Q_QUAL_MIN_R9_PRESENT1)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_Q_QUAL_MIN_R9_PRESENT1");
        p_operator_info_to_cellm->sib_3_info.bitmask|=
            RRMCM_RMIF_Q_QUAL_MIN_R9_PRESENT1;
        p_operator_info_to_cellm->sib_3_info.q_qual_min_r9 =
            p_operator_info_from_oam->sib_3_info.q_qual_min_r9;
    }
/* SPR 20653 Fix End */

    if (p_operator_info_from_oam->sib_3_info.bitmask&
            RRM_OAM_THRESHOLD_SERVING_LOW_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_THRESHOLD_SERVING_LOW_PRESENT");
        p_operator_info_to_cellm->sib_3_info.bitmask|=
            RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT;
        p_operator_info_to_cellm->sib_3_info.thresh_serving_lowq_r9=
            p_operator_info_from_oam->sib_3_info.thresh_serving_lowq_r9;
    }

    /* BUG_11575_CHANGES_START */
    /* Code Deleted */
    /* BUG_11575_CHANGES_END */
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_spid_info 
 * Inputs         : -*spid_table_info_cellm 
 *                  -*spid_table_info_oam 
 * Outputs        : None.
 * Returns        : Void
 * Description    : This function populates admsn_control_info of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
static void fill_spid_info(rrm_oam_spid_table_t *spid_table_info_cellm, 
        rrm_oam_spid_table_t *spid_table_info_oam)
{
    U8 i = 0;
    /* SPR 20653 Fix Start */
    U8 count = RRM_ZERO, 
       count1 = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    spid_table_info_cellm->spid_count = spid_table_info_oam->spid_count;

    for (i=0; i < spid_table_info_oam->spid_count; i ++ )
    {
        spid_table_info_cellm->spid_config[i].spid = spid_table_info_oam->spid_config[i].spid;

        spid_table_info_cellm->spid_config[i].rrm_rat_priority_list.rat_count = 
            spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rat_count;
        for(count = 0; count < spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rat_count; count++)
        {
            spid_table_info_cellm->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].rat_type = 
                spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].rat_type;

            spid_table_info_cellm->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_count = 
                spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_count;

            for(count1 = 0; count1 < spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_count; count1 ++)
            {
                /* SPR 22516 Fix Start */
                spid_table_info_cellm->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_priority[count1].freq = 
                    spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_priority[count1].freq;
                /* SPR 22516 Fix End */

                spid_table_info_cellm->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_priority[count1].new_priority = 
                    spid_table_info_oam->spid_config[i].rrm_rat_priority_list.rrm_rat_priority_info[count].freq_priority[count1].new_priority;

            }
        }
    }
                /* SPR 20653 Fix End */

    RRM_UT_TRACE_EXIT();

}

/* Coverity_ID : 54853 start */
/****************************************************************************
 * Function Name  : rrm_map_cqi_reporting_mode
 * Inputs         : S32 rrm_oam_cqi_reporting_mode
 * Outputs        : None. 
 * Returns        : rrm_cqi_reporting_mode_et
 * Description    : This function map cqi reporting mode
 ****************************************************************************/
    rrm_cqi_reporting_mode_et
rrm_map_cqi_reporting_mode ( S32 rrm_oam_cqi_reporting_mode )
{
    rrm_cqi_reporting_mode_et rrm_cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;
    RRM_UT_TRACE_ENTER();
    switch (rrm_oam_cqi_reporting_mode)
    {
        case RRM_ZERO:
            rrm_cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;
            break;
        case RRM_ONE:
            rrm_cqi_reporting_mode = RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED;
            break;
        case RRM_TWO:
            rrm_cqi_reporting_mode = RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED;
            break;
        case RRM_THREE:
            rrm_cqi_reporting_mode = RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED;
            break;
        default:
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,\
                    "Incorrect Value(%d).. so Disbaling cqi reporting mode",\
                    rrm_oam_cqi_reporting_mode);
            break;
    }
    RRM_UT_TRACE_EXIT();
    return rrm_cqi_reporting_mode;

}
/* Coverity_ID : 54853 end */
/****************************************************************************
 * Function Name  : populate_operator_admsn_control_info_for_cell_reconfig
 * Inputs         : -*p_operator_info_from_oam - operator info from oam
 *                  -*p_operator_info_to_cellm - operator info for cellm
 *                  -*p_operator_cfg_params - operator info from cfg
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates admsn_control_info of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
static void populate_operator_admsn_control_info_for_cell_reconfig
(operator_info_t * p_operator_info_to_cellm,
 rrm_oam_operator_info_t * p_operator_info_from_oam,
     /*SPR 17777 +-*/
 rrm_oam_physical_layer_params_t *p_plp_params_from_oam,
 /* SPR 20653 Fix End */
     /*SPR 17777 +-*/
 rrm_oam_band_width_et channel_bandwith
 )
{
    U8 dl_prb_budget =  RRM_ZERO;
    U8 ul_prb_budget =  RRM_ZERO;
    rrm_ul_dl_freq_selective_sched_et        ul_dl_freq_value = 
        RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    rrm_cqi_reporting_mode_et                cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;

    RRM_UT_TRACE_ENTER();
    /* SPR 20563 Fix Start */
    /* Code Removed */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_WAIT_TIME_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            wait_time = p_operator_info_from_oam->load_params.
            wait_time;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_UE_SERVICE_PROFILE_PRESENT;
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_WAIT_TIME_PRESENT;
        /* SPR 21429 Fix End */
    }
    if(p_operator_info_from_oam->bitmask & RRM_OAM_EXTENDED_WAIT_TIME_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            extended_wait_time = p_operator_info_from_oam->load_params.
            extended_wait_time;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_UE_SERVICE_PROFILE_PRESENT;
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT;
        /* SPR 21429 Fix End */
    }
    if(p_operator_info_from_oam->dynamic_icic_info.bitmask & RRM_OAM_INITIAL_UE_LOCATION_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            initial_ue_location = p_operator_info_from_oam->dynamic_icic_info.initial_ue_location;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_UE_SERVICE_PROFILE_PRESENT;
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.bitmask |= RRM_SERVICE_PROFILE_UE_ADM_INITIAL_UE_LOC_PRESENT;
        /* SPR 21429 Fix End */
    }
    if( p_plp_params_from_oam->physical_layer_param_srs.bitmask & RRM_OAM_SRS_PERIODICITY_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.srs_periodicity= 
            p_plp_params_from_oam->physical_layer_param_srs.srs_periodicity;     
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_SRS_PERIODICITY_PRESENT;
        /* SPR 21429 Fix End */
    }
    /* SPR 20563 Fix End */
    /* radio_res_config - start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask = 0x00;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.bitmask = 0x00;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.bitmask = 0;

    /* SPR_14372_start */
    /* code removed */
    /* SPR_14372_stop */

    /* phr_config - start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.bitmask |=
        RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;

    rrc_phr_config_ue_service_profile_t *p_phr_config_to_cellm = RRM_NULL;
    p_phr_config_to_cellm = &p_operator_info_to_cellm->admission_control_info.
        ue_service_profile.radio_res_config.mac_config.mac_main_config.phr_config;

    p_phr_config_to_cellm->bitmask |=
        RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT;
    /* phr_config - end */


    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.bitmask |=
        RRM_SERVICE_PROFILE_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask |=
        RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT;
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.bitmask = 0x00;

    /* SPR 20653 Fix Start */
    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask & NOM_PDSCH_RS_EPRE_OFFSET_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            radio_res_config.physical_config_dedicated.cqi_reporting.
            nom_pdsch_rs_epre_offset =
            p_operator_info_from_oam->additional_packet_scheduling_params.
            nom_pdsch_rs_epre_offset;
    }
    /* SPR 20653 Fix End */

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.cqi_reporting.
        cqi_reporting_periodic.bitmask = 0x00;

    /* SPR 20653 Fix Start */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ACK_NACK_CQI_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            radio_res_config.physical_config_dedicated.cqi_reporting.
            cqi_reporting_periodic.cqi_reporting_periodic_param.
            simultaneous_ack_nack_and_cqi =
            p_operator_info_from_oam->simultaneous_ack_nack_and_cqi;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            radio_res_config.physical_config_dedicated.cqi_reporting.
            cqi_reporting_periodic.cqi_reporting_periodic_param.
            simultaneous_ack_nack_and_cqi =  RRM_DEFINED_DEFAULT_VALUE_FOR_SIMULTANEOUS_ACK_NACK_CQI;
    }

    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity_ID : 54854 */
        switch (p_operator_info_from_oam->additional_packet_scheduling_params.frequency_selective_scheduling)
        {
            case RRM_ZERO:
                ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
                break;    
            case RRM_ONE:
                ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY;
                break;    
            case RRM_TWO:
                ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY;
                break;    
            case RRM_THREE:
                ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH;
                break;   
            default:
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "Incorrect Value(%d).. so Disbaling Frequency Selective Scheduling in both UL/DL",
                        p_operator_info_from_oam->additional_packet_scheduling_params.frequency_selective_scheduling);
                ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
                break;

        }
    }
    else
    {
        ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    }
    switch(ul_dl_freq_value)
    {
        case RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH; 
            break;
        /* CID 112357 Start */
        /* Code Removed */
        /* CID 112357 End */
    }
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity_ID : 54853 */
        cqi_reporting_mode = rrm_map_cqi_reporting_mode (
                p_operator_info_from_oam->additional_packet_scheduling_params.cqi_reporting_mode);
    }
    else
    {
        cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;
    }
    switch(cqi_reporting_mode)
    {
        case RRM_DISABLE_CQI_REPORTING:
                p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            break;

        case RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED:
                p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            break;

        case RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED:
                p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            /*SPR_10091_FIX_START */
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            /* SPR_10091_FIX_END */

            break;

        case RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED:
                p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            break;
        default :
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "Incorrect value received for CQI Reporting Mode %d.. so enabling periodic cqi by default",
                    cqi_reporting_mode);
                p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
    }
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.bitmask |=
        RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT;


    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask |=
        RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT;

    /* radio_res_config - end */

    /* p_operator_info_to_cellm->admission_control_info.cpu_utilization_limit is not required */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_UE_PER_CELL_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.max_num_ue_per_cell =
            p_operator_info_from_oam->admission_control_info.max_num_ue_per_cell;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.max_num_ue_per_cell = RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_NUM_UE_PER_CELL;
    }
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_NUM_UE_PER_CELL_PRESENT;
    /* SPR 21429 Fix End */

    /* SPS related changes start */
    p_operator_info_to_cellm->admission_control_info.max_sps_ues =
        p_operator_info_from_oam->admission_control_info.max_sps_ues;
    /* SPS related changes end */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_gbr_drbs_per_ue =
            p_operator_info_from_oam->admission_control_info.
            max_num_gbr_drbs_per_ue;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_gbr_drbs_per_ue = MAX_NUM_GBR_DRBS_PER_UE;
    }
    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_ngbr_drbs_per_ue =
            p_operator_info_from_oam->admission_control_info.
            max_num_non_gbr_drbs_per_ue;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_ngbr_drbs_per_ue = MAX_NUM_NON_GBR_DRBS_PER_UE;
    }

    /*Cov_fix_start_54951*/
    /*strt snr map populate*/
    /* uplink_snr_dep_params - start */
    /* Coverity 54951 fix start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.bitmask = 0x00;
    /* Coverity 54951 fix end */

    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_UL_MCS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs =
            p_operator_info_from_oam->additional_packet_scheduling_params.ul_mcs;

    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_MCS;
    }
    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_MIN_SR_PERIODICITY_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.min_sr_periodicity =  
                p_operator_info_from_oam->additional_packet_scheduling_params.min_sr_periodicity;
    }
    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_MIN_RI_PERIODICITY_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.min_ri_periodicity =  
                p_operator_info_from_oam->additional_packet_scheduling_params.min_ri_periodicity;
    }
    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_MIN_CQI_PERIODICITY_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.min_cqi_periodicity =  
                p_operator_info_from_oam->additional_packet_scheduling_params.min_cqi_periodicity;
    }

    if(p_plp_params_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
            beta_offset_ack_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_ack_index;

        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
            beta_offset_ri_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_ri_index;

        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
            beta_offset_cqi_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_cqi_index;

        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.bitmask |=
            PUSCH_INFO_SNR_MAP_PRESENT;

        p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
            physical_config_dedicated.pusch_configuration_dedicated.beta_offset_ack_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_ack_index;

        p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
            physical_config_dedicated.pusch_configuration_dedicated.beta_offset_ri_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_ri_index;

        p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
            physical_config_dedicated.pusch_configuration_dedicated.beta_offset_cqi_index =
            p_plp_params_from_oam->physical_layer_param_pusch.
            beta_offset_cqi_index;

        p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
            physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT; 
        /* SPR 21429 Fix End */
    }
    /* SPR 20653 Fix End */

    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /* SPR_14230_start */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_POWER_CONTROL_INFO_PRESENT)
    {
        if(p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
        {
            if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask & RRM_OAM_DELTA_MCS_ENABLED_PRESENT)
            {
                p_operator_info_to_cellm->admission_control_info.snr_map.
                    snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
                    delta_mcs_enabled = p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.delta_mcs_enabled;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "delta_mcs_enabled is populated from OAM : %d",
                        p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.delta_mcs_enabled);
            }
            if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask & RRM_OAM_ACCUMULATION_ENABLED_PRESENT)
            {
                p_operator_info_to_cellm->admission_control_info.snr_map.
                    snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
                    accumulation_enabled = p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.accumulation_enabled;
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "accumulation_enabled is populated from OAM : %d",
                        p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.accumulation_enabled);
            }
        }
    }
    /* SPR_14230_stop */
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.bitmask |=
        UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT;

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps =
        p_operator_info_from_oam->admission_control_info.
        prb_estimation_factor.ul_prb_per_bps;

    /* downlink_snr_dep_params - start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.downlink_snr_dep_params.bitmask = 0x00;

    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_DL_MCS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs =
            p_operator_info_from_oam->additional_packet_scheduling_params.dl_mcs;

    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_MCS;
    }
    if(p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_PRB_ESTIMATION_FACTOR_PRESENT)
    {
        if(p_operator_info_from_oam->admission_control_info.prb_estimation_factor.bitmask & RRM_OAM_DL_PRB_PER_BPS_PRESENT)
        {
            p_operator_info_to_cellm->admission_control_info.snr_map.
                snr_dep_params.downlink_snr_dep_params.dl_prb_per_bps =
                p_operator_info_from_oam->admission_control_info.
                prb_estimation_factor.dl_prb_per_bps;
        }
    }

    /*end snr map populate*/

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_GBR_PRB_BUDGET)
    {
            p_operator_info_to_cellm->admission_control_info.dl_prb_budget_gbr =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget_gbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_gbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_GBR;
    }
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_TOTAL_DL_GBR_PRB_BUDGET;
    /* SPR 21429 Fix End */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_GBR_PRB_BUDGET)
    {
            p_operator_info_to_cellm->admission_control_info.ul_prb_budget_gbr =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget_gbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_gbr = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_PRB_BUDGET_GBR;
    }
    /* SPR 21429 Fix Start */
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_TOTAL_UL_GBR_PRB_BUDGET;
    /* SPR 21429 Fix End */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_NGBR_PRB_BUDGET)
    {
            p_operator_info_to_cellm->admission_control_info.dl_prb_budget_ngbr =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget_ngbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_ngbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_NGBR;
    }
    /* SPR 21429 Fix Start */
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_TOTAL_DL_NGBR_PRB_BUDGET;
    /* SPR 21429 Fix End */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_NGBR_PRB_BUDGET)
    {
            p_operator_info_to_cellm->admission_control_info.ul_prb_budget_ngbr =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget_ngbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_ngbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_NGBR;
    }
    /* SPR 21429 Fix Start */
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_TOTAL_UL_NGBR_PRB_BUDGET;
    /* SPR 21429 Fix End */
    /* SPR 20653 Fix End */

    /* TDD changes*/
    if(p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_PRB_BUDGET )
    {
        p_operator_info_to_cellm->admission_control_info.dl_total_bw_prbs =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget;
    }
    else
    {
#ifdef TDD_MODE_FLAG
        get_dl_prb_bdgt_frm_total_bw_in_tdd(channel_bandwith,
                &(p_plp_params_from_oam->physical_layer_param_tdd_frame_structure),
                &dl_prb_budget);
#else
        get_num_of_rb_frm_chanl_bw(channel_bandwith , &dl_prb_budget);
#endif

        p_operator_info_to_cellm->admission_control_info.dl_total_bw_prbs = dl_prb_budget; 

    }    

    if(p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_PRB_BUDGET )
    {
        p_operator_info_to_cellm->admission_control_info.ul_total_bw_prbs =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget;
    }
    else
    {
#ifdef TDD_MODE_FLAG
        get_ul_prb_bdgt_frm_total_bw_in_tdd(channel_bandwith,
                &(p_plp_params_from_oam->physical_layer_param_tdd_frame_structure),
                &ul_prb_budget);
#else
        get_num_of_rb_frm_chanl_bw(channel_bandwith , &ul_prb_budget);
#endif

        p_operator_info_to_cellm->admission_control_info.ul_total_bw_prbs = ul_prb_budget; 

    }


    /*GBR LIMIT START */
    p_operator_info_to_cellm->admission_control_info.bitmask =0x000;         

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_AVAILABLE_GBR_LIMIT_PRESENT)
    {
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_AVAILABLE_GBR_LIMIT_PRESENT;
        /* SPR 21429 Fix End */
        p_operator_info_to_cellm->admission_control_info.avail_gbr_limit.dl_gbr_limit =
            p_operator_info_from_oam->admission_control_info.available_gbr_limit.dl_gbr_limit;
        p_operator_info_to_cellm->admission_control_info.avail_gbr_limit.ul_gbr_limit =
            p_operator_info_from_oam->admission_control_info.available_gbr_limit.ul_gbr_limit;
    }
    /*GBR LIMIT END */
    if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_RESOURCE_RESERVED_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.resource_reserved_for_existing_users=
            p_operator_info_from_oam->admission_control_info.resource_reserved_for_existing_users;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_RMIF_RESOURCE_RESERVED_PRESENT;
    }
    /*csg proximity start*/
    if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_PROXIMITY_IND_STATUS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.proximity_indication_status = 
            p_operator_info_from_oam->admission_control_info.proximity_indication_status;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT;
    }
    /*csg proximity end*/
    /** TNL feature Start*/
    p_operator_info_to_cellm->admission_control_info.
        tnl_capacity.total_backhaul_capacity=
        p_operator_info_from_oam->admission_control_info.total_backhaul_capacity;
    p_operator_info_to_cellm->admission_control_info.
        tnl_capacity.capacity_threshold=
        p_operator_info_from_oam->admission_control_info.capacity_threshold;
    /** TNL feature End*/

    /*SPR 18654 START*/
    /* SPR 21429 Fix Start */
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_DL_BW_FOR_CONTROL_PRBS)
  {
     p_operator_info_to_cellm->admission_control_info.
      dl_bw_for_control_prbs=
     p_operator_info_from_oam->admission_control_info.dl_bw_for_control_prbs;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_DL_BW_FOR_CONTROL_PRBS;
  }
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_RB_FACTOR_FOR_BITRATE)
  {
     p_operator_info_to_cellm->admission_control_info.
      rb_factor_for_bitrate=
     p_operator_info_from_oam->admission_control_info.rb_factor_for_bitrate;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_RB_FACTOR_FOR_BITRATE;
  }
  /* SPR 20653 Fix Start */
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_SRB_BIT_RATE_PRESENT)
  {
     p_operator_info_to_cellm->admission_control_info.srb_bit_rate=
        p_operator_info_from_oam->admission_control_info.srb_bit_rate;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_SRB_BIT_RATE_PRESENT;
  }
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_MIN_BITRATE_PRESENT)
  {
     p_operator_info_to_cellm->admission_control_info.minimum_bitrate=
        p_operator_info_from_oam->admission_control_info.minimum_bitrate;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MIN_BITRATE_PRESENT;
  }
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_NGBR_THRESHOLD_PRESENT)
  {
     p_operator_info_to_cellm->admission_control_info.ngbr_threshold=
        p_operator_info_from_oam->admission_control_info.ngbr_threshold;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_NGBR_THRESHOLD_PRESENT;
  }
  if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT)
  {
     p_operator_info_to_cellm->admission_control_info.non_default_bearer_multiplier=
        p_operator_info_from_oam->admission_control_info.non_default_bearer_multiplier;
     p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_NON_DEFAULT_BEARER_MULTIPLIER_PRESENT;
  }
  /* SPR 21429 Fix End */
  p_operator_info_to_cellm->admission_control_info.max_eicic_ues=
      p_operator_info_from_oam->admission_control_info.max_eicic_ues;
  /* SPR 20653 Fix End */

    /*SPR 18654 END*/
  /* SPR 20653 Fix Start */
  if(p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_SPID_TABLE_PRESENT)
  {
      if(p_operator_info_from_oam->admission_control_info.spid_table.bitmask & RRM_OAM_RAT_PRIORITY_INFO_PRESENT)
      {
          p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_RAT_PRIORITY_INFO_CFG_PRESENT; 
          populate_rat_priority_info(p_operator_info_to_cellm, p_operator_info_from_oam);
      }
      if(RRM_ZERO != p_operator_info_from_oam->admission_control_info.spid_table.spid_count)
      {
          p_operator_info_to_cellm->bitmask |= RRMCM_SPID_TABLE_PRESENT;
          fill_spid_info (&p_operator_info_to_cellm->spid_table, 
                  &p_operator_info_from_oam->admission_control_info.spid_table);
      }
  }
    /* SPR_15537_Fix_Start */
    /*SPR 18654 START*/
    /* code deleted */
    /*SPR 18654 END*/
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.dl_bw_for_control_prbs =
        p_operator_info_from_oam->admission_control_info.dl_bw_for_control_prbs;
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_DL_BW_FOR_CONTROL_PRBS;
    /* SPR 21429 Fix End */
  /* SPR 20653 Fix End */
    /* SPR_15537_Fix_End */
    /* SPR 20653 Fix Start */
    if (p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_UL_POWER_CONTROL_DEDICATED_PRESENT)
    { 
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_UE_SERVICE_PROFILE_PRESENT;
        /* SPR 21429 Fix End */

        /*SPR 21480 Fixed START */
        p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pusch = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p0_ue_pusch;

        p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pucch = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p0_ue_pucch;

        p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p_srs_offset = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p_srs_offset;

        p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.filter_coefficient = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.filter_coefficient;
        /*SPR 21480 Fixed END */

        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |= RRC_SERVICE_PROFILE_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT;
        /* SPR 21429 Fix End */

    }
    /* SPR 20653 Fix End */

    RRM_UT_TRACE_EXIT();
    /*Cov_fix_end_54951*/
}
/****************************************************************************
 * Function Name  : populate_operator_admsn_control_info_for_cell_config
 * Inputs         : -*p_operator_info_from_oam - operator info from oam
 *                  -*p_operator_info_to_cellm - operator info for cellm
 *                  -*p_operator_cfg_params - operator info from cfg
 * Outputs        : None. 
 * Returns        : Void
 * Description    : This function populates admsn_control_info of operator info
 *                  for cell_m using the param from cfg and OAM.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
static void populate_operator_admsn_control_info_for_cell_config
(operator_info_t * p_operator_info_to_cellm,
 rrm_oam_operator_info_t * p_operator_info_from_oam,
     /*SPR 17777 +-*/
 rrm_oam_physical_layer_params_t *p_plp_params_from_oam,
 /* SPR 20653 Fix End */
     /*SPR 17777 +-*/
 rrm_oam_band_width_et channel_bandwith
 )
{
    U8 dl_prb_budget =  RRM_ZERO;
    U8 ul_prb_budget =  RRM_ZERO;
    rrm_ul_dl_freq_selective_sched_et        ul_dl_freq_value = 
        RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    rrm_cqi_reporting_mode_et                cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;

    RRM_UT_TRACE_ENTER();
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        wait_time = p_operator_info_from_oam->load_params.wait_time;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        extended_wait_time = p_operator_info_from_oam->load_params.extended_wait_time;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        initial_ue_location = p_operator_info_from_oam->dynamic_icic_info.initial_ue_location;
    /* SPR 20653 Fix End */

    /*Rel10 CR 588 changes start*/
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        bitmask |= RRM_SERVICE_PROFILE_UE_ADM_EXTENDED_WAIT_TIME_PRESENT;
    /*Rel10 CR 588 changes end*/

    /* radio_res_config - start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask = 0x00;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.bitmask = 0x00;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.bitmask = 0;

    /* ul_sch_config - start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.ul_sch_config.bitmask = 0x00;

    /* SPR_14372_start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.ul_sch_config.max_ul_harq_tx =
        RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_HARQ_TX_UE_ADMSN;

    /* SPR_14372_stop */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.ul_sch_config.bitmask |=
        RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.bitmask |=
        RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT;
    /* rrc_ul_sch_config_profile - end */

    /* phr_config - start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.mac_main_config.bitmask |=
        RRC_SERVICE_PROFILE_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT;

    rrc_phr_config_ue_service_profile_t *p_phr_config_to_cellm = RRM_NULL;
    p_phr_config_to_cellm = &p_operator_info_to_cellm->admission_control_info.
        ue_service_profile.radio_res_config.mac_config.mac_main_config.phr_config;

    p_phr_config_to_cellm->bitmask |=
        RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT;
    /* phr_config - end */


    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.mac_config.bitmask |=
        RRM_SERVICE_PROFILE_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask |=
        RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT;
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.bitmask = 0x00;
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.min_sr_periodicity =  
        p_operator_info_from_oam->additional_packet_scheduling_params.min_sr_periodicity;
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MIN_SR_PERIODICITY_PRESENT;

    p_operator_info_to_cellm->admission_control_info.min_ri_periodicity =  
        p_operator_info_from_oam->additional_packet_scheduling_params.min_ri_periodicity;
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MIN_RI_PERIODICITY_PRESENT;

    p_operator_info_to_cellm->admission_control_info.min_cqi_periodicity =  
        p_operator_info_from_oam->additional_packet_scheduling_params.min_cqi_periodicity;
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MIN_CQI_PERIODICITY_PRESENT;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.cqi_reporting.
        nom_pdsch_rs_epre_offset =
        p_operator_info_from_oam->additional_packet_scheduling_params.
        nom_pdsch_rs_epre_offset;
        
    p_operator_info_to_cellm->admission_control_info.srs_periodicity= 
        p_plp_params_from_oam->physical_layer_param_srs.srs_periodicity;     
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_SRS_PERIODICITY_PRESENT;
    /* SPR 21429 Fix End */
    /* SPR 20653 Fix End */

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.cqi_reporting.
        cqi_reporting_periodic.bitmask = 0x00;

  /* SPR 20653 Fix Start */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ACK_NACK_CQI_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            radio_res_config.physical_config_dedicated.cqi_reporting.
            cqi_reporting_periodic.cqi_reporting_periodic_param.
            simultaneous_ack_nack_and_cqi =
            p_operator_info_from_oam->simultaneous_ack_nack_and_cqi;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ue_service_profile.
            radio_res_config.physical_config_dedicated.cqi_reporting.
            cqi_reporting_periodic.cqi_reporting_periodic_param.
            simultaneous_ack_nack_and_cqi = RRM_DEFINED_DEFAULT_VALUE_FOR_SIMULTANEOUS_ACK_NACK_CQI; 
    }

    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity: CID 54854 */
        ul_dl_freq_value = 
            (rrm_ul_dl_freq_selective_sched_et)p_operator_info_from_oam->additional_packet_scheduling_params.frequency_selective_scheduling;
    }
    else
    {
        ul_dl_freq_value = RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH;
    }
    switch(ul_dl_freq_value)
    {
        case RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_DL_ONLY; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_ONLY; 
            break;

        case RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_ENABLE_UL_DL_BOTH; 
            break;

        default:
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "Incorrect Value(%d).. so Disbaling Frequency Selective Scheduling in both UL/DL",
                    ul_dl_freq_value);
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_ul_dl_freq_selective_sched = 
                RRM_FREQ_SELECTIVE_SCHEDULING_DISABLE_UL_DL_BOTH; 
    }
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_PACKET_SCH_PARAMS_PRESENT)
    {
        /* Coverity_ID : 54853 */
        cqi_reporting_mode = rrm_map_cqi_reporting_mode (
                p_operator_info_from_oam->additional_packet_scheduling_params.cqi_reporting_mode);
    }
    else
    {
        cqi_reporting_mode = RRM_DISABLE_CQI_REPORTING;
    }
    switch(cqi_reporting_mode)
    {
        case RRM_DISABLE_CQI_REPORTING:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            break;

        case RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            break;

        case RRM_APERIODIC_REPORTING_OF_CQI_SUPPORTED:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            /* SPR_10091_FIX_START */
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            /* SPR_10091_FIX_END */

            break;

        case RRM_PERIODIC_APERIODIC_CQI_REPORTING_SUPPORTED:
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = cqi_reporting_mode;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
            break;
        default :
            RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "Incorrect value received for CQI Reporting Mode %d.. so enabling periodic cqi by default",
                    cqi_reporting_mode);
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                rrm_cqi_reporting_mode_configured = RRM_PERIODIC_REPORTING_OF_CQI_SUPPORTED;
            p_operator_info_to_cellm->admission_control_info.ue_service_profile.
                radio_res_config.physical_config_dedicated.cqi_reporting.
                cqi_reporting_periodic.bitmask |=
                RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT;
    }
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.physical_config_dedicated.bitmask |=
        RRC_SERVICE_PROFILE_PHY_CQI_REPORTING_PRESENT;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.
        radio_res_config.bitmask |=
        RRM_SERVICE_PROFILE_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT;

    /* radio_res_config - end */

    /* p_operator_info_to_cellm->admission_control_info.cpu_utilization_limit is not required */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_UE_PER_CELL_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.max_num_ue_per_cell =
            p_operator_info_from_oam->admission_control_info.max_num_ue_per_cell;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.max_num_ue_per_cell = RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_NUM_UE_PER_CELL;
    }
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_NUM_UE_PER_CELL_PRESENT; 
    /* SPR 21429 Fix End */
    /* SPR 20653 Fix End */
    /* SPS related changes start */
    p_operator_info_to_cellm->admission_control_info.max_sps_ues =
        p_operator_info_from_oam->admission_control_info.max_sps_ues;
    /* SPS related changes end */

    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.max_eicic_ues =
        p_operator_info_from_oam->admission_control_info.max_eicic_ues;
    /* SPR 20653 Fix End */

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_gbr_drbs_per_ue =
            p_operator_info_from_oam->admission_control_info.
            max_num_gbr_drbs_per_ue;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_gbr_drbs_per_ue = MAX_NUM_GBR_DRBS_PER_UE;
    }
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_NUM_GBR_DRBS_PER_UE_PRESENT; 
    /* SPR 21429 Fix End */
    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_ngbr_drbs_per_ue =
            p_operator_info_from_oam->admission_control_info.
            max_num_non_gbr_drbs_per_ue;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.
            max_num_ngbr_drbs_per_ue = MAX_NUM_NON_GBR_DRBS_PER_UE;
    }
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_MAX_NUM_NGBR_DRBS_PER_UE_PRESENT; 
    /* SPR 21429 Fix End */
    /*Coverity_fix_start_54949*/
    /*strt snr map populate*/
    /* uplink_snr_dep_params - start */
    /* Coverity 54949 fix start */
    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_SNR_MAP_PRESENT; 
    /* SPR 21429 Fix End */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.bitmask = 0x00;
    /* Coverity 54949 fix end */
    /* SPR 20653 Fix Start */
    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_UL_MCS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs =
            p_operator_info_from_oam->additional_packet_scheduling_params.ul_mcs;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.uplink_snr_dep_params.ul_mcs = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_MCS;
    }
    /* SPR 20653 Fix End */

    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
        beta_offset_ack_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_ack_index;

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
        beta_offset_ri_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_ri_index;

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.pusch_config_dedicated.
        beta_offset_cqi_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_cqi_index;
    
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
        physical_config_dedicated.pusch_configuration_dedicated.beta_offset_ack_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_ack_index;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
        physical_config_dedicated.pusch_configuration_dedicated.beta_offset_ri_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_ri_index;

    p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.
        physical_config_dedicated.pusch_configuration_dedicated.beta_offset_cqi_index =
        p_plp_params_from_oam->physical_layer_param_pusch.
        beta_offset_cqi_index;
    /* SPR 20653 Fix End */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.bitmask |=
        PUSCH_INFO_SNR_MAP_PRESENT;
    /*SPR 20653 Fix Start */
    /*SPR 21480 Fixed start */
    
    p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pusch = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p0_ue_pusch;
    
    p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p0_ue_pucch = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p0_ue_pucch;
    
    p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.p_srs_offset = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p_srs_offset;
    
    p_operator_info_to_cellm->admission_control_info.snr_map.snr_dep_params.uplink_snr_dep_params.uplink_pow_control.filter_coefficient 
    = p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.filter_coefficient;
    /*SPR 20653 Fix End */
    /*SPR 21480 Fixed END */
    /*SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.ue_service_profile.radio_res_config.physical_config_dedicated.bitmask |=
       RRC_SERVICE_PROFILE_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT; 
    /*SPR 21429 Fix End */

    /* SPR_14230_start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
        delta_mcs_enabled = RRM_DELTA_MCS_ENABLED;

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
        accumulation_enabled = RRM_ACCUMULATION_ENABLED;

    if(p_operator_info_from_oam->bitmask & RRM_OAM_POWER_CONTROL_INFO_PRESENT)
    {
        if(p_operator_info_from_oam->rrm_power_control_params.bitmask & RRM_OAM_POWER_CONTROL_ENABLE_PRESENT)
	{
		if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask & RRM_OAM_DELTA_MCS_ENABLED_PRESENT)
		{
			p_operator_info_to_cellm->admission_control_info.snr_map.
				snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
				delta_mcs_enabled = p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.delta_mcs_enabled;
			RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
					"delta_mcs_enabled is populated from OAM : %d",
					p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.delta_mcs_enabled);
		}
		if(p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.bitmask & RRM_OAM_ACCUMULATION_ENABLED_PRESENT)
		{
			p_operator_info_to_cellm->admission_control_info.snr_map.
				snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
				accumulation_enabled = p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.accumulation_enabled;
			RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
					"accumulation_enabled is populated from OAM : %d",
					p_operator_info_from_oam->rrm_power_control_params.rrm_power_control_enable.accumulation_enabled);
		}
		//TB_FIX 
		p_operator_info_to_cellm->admission_control_info.snr_map.
			snr_dep_params.uplink_snr_dep_params.uplink_pow_control.
			p_srs_offset =
			p_operator_info_from_oam->rrm_power_control_params.uplink_power_control_dedicated.p_srs_offset;
	}
    }
    /* SPR_14230_stop */

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.uplink_snr_dep_params.bitmask |=
        UPLINK_POW_CONTROL_INFO_SNR_MAP_PRESENT;

    /* SPR 20653 Fix Start */
    if(p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_PRB_ESTIMATION_FACTOR_PRESENT)
    {
        if(p_operator_info_from_oam->admission_control_info.prb_estimation_factor.bitmask & RRM_OAM_UL_PRB_PER_BPS_PRESENT)
        {
            p_operator_info_to_cellm->admission_control_info.snr_map.
                snr_dep_params.uplink_snr_dep_params.ul_prb_per_bps =
                p_operator_info_from_oam->admission_control_info.
                prb_estimation_factor.ul_prb_per_bps;

            /* SPR 21429 Fix Start */
            p_operator_info_to_cellm->admission_control_info.snr_map.
                snr_dep_params.uplink_snr_dep_params.bitmask |= UL_PRB_PER_BPS_PRESENT;
            /* SPR 21429 Fix End */
        }
    }
    /* uplink_snr_dep_params - end */

    /* downlink_snr_dep_params - start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.downlink_snr_dep_params.bitmask = 0x00;

    if(p_operator_info_from_oam->additional_packet_scheduling_params.bitmask &
            RRM_OAM_DL_MCS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs =
            p_operator_info_from_oam->additional_packet_scheduling_params.dl_mcs;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.snr_map.
            snr_dep_params.downlink_snr_dep_params.dl_mcs = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_MCS;
    }

    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.downlink_snr_dep_params.dl_prb_per_bps =
        p_operator_info_from_oam->admission_control_info.
        prb_estimation_factor.dl_prb_per_bps;

    /* SPR 21429 Fix Start */
    p_operator_info_to_cellm->admission_control_info.snr_map.
        snr_dep_params.downlink_snr_dep_params.bitmask |= DL_PRB_PER_BPS_PRESENT;
    /* SPR 21429 Fix End */
    /*end snr map populate*/

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_GBR_PRB_BUDGET)
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_gbr =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget_gbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_gbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_GBR;
    }

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_GBR_PRB_BUDGET)
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_gbr =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget_gbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_gbr = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_PRB_BUDGET_GBR;
    }

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_NGBR_PRB_BUDGET)
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_ngbr =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget_ngbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.dl_prb_budget_ngbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_NGBR;
    }
    /*Coverity_fix_end_54949*/
    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_NGBR_PRB_BUDGET)
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_ngbr =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget_ngbr;
    }
    else
    {
        p_operator_info_to_cellm->admission_control_info.ul_prb_budget_ngbr = RRM_DEFINED_DEFAULT_VALUE_FOR_DL_PRB_BUDGET_NGBR;
    }
    /* SPR 20653 Fix End */

    /* TDD changes*/
    if(p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_DL_PRB_BUDGET )
    {
        p_operator_info_to_cellm->admission_control_info.dl_total_bw_prbs =
            p_operator_info_from_oam->admission_control_info.dl_prb_budget;
    }
    else
    {
#ifdef TDD_MODE_FLAG
        get_dl_prb_bdgt_frm_total_bw_in_tdd(channel_bandwith,
                &(p_plp_params_from_oam->physical_layer_param_tdd_frame_structure),
                &dl_prb_budget);
#else
        get_num_of_rb_frm_chanl_bw(channel_bandwith , &dl_prb_budget);
#endif

        p_operator_info_to_cellm->admission_control_info.dl_total_bw_prbs = dl_prb_budget; 

    }    

    if(p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_MAX_TOTAL_UL_PRB_BUDGET )
    {
        p_operator_info_to_cellm->admission_control_info.ul_total_bw_prbs =
            p_operator_info_from_oam->admission_control_info.ul_prb_budget;
    }
    else
    {
#ifdef TDD_MODE_FLAG
        get_ul_prb_bdgt_frm_total_bw_in_tdd(channel_bandwith,
                &(p_plp_params_from_oam->physical_layer_param_tdd_frame_structure),
                &ul_prb_budget);
#else
        get_num_of_rb_frm_chanl_bw(channel_bandwith , &ul_prb_budget);
#endif

        p_operator_info_to_cellm->admission_control_info.ul_total_bw_prbs = ul_prb_budget; 

    }


    /*GBR LIMIT START */
    p_operator_info_to_cellm->admission_control_info.bitmask =0x000;         

    if (p_operator_info_from_oam->admission_control_info.bitmask &
            RRM_OAM_AVAILABLE_GBR_LIMIT_PRESENT)
    {
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->admission_control_info.bitmask |=RRMCM_AVAILABLE_GBR_LIMIT_PRESENT;
        /* SPR 21429 Fix End */
        p_operator_info_to_cellm->admission_control_info.avail_gbr_limit.dl_gbr_limit =
            p_operator_info_from_oam->admission_control_info.available_gbr_limit.dl_gbr_limit;
        p_operator_info_to_cellm->admission_control_info.avail_gbr_limit.ul_gbr_limit =
            p_operator_info_from_oam->admission_control_info.available_gbr_limit.ul_gbr_limit;
    }
    /*GBR LIMIT END */
    if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_RESOURCE_RESERVED_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.resource_reserved_for_existing_users=
            p_operator_info_from_oam->admission_control_info.resource_reserved_for_existing_users;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_RMIF_RESOURCE_RESERVED_PRESENT;
    }
    /*csg proximity start*/
    if (p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_PROXIMITY_IND_STATUS_PRESENT)
    {
        p_operator_info_to_cellm->admission_control_info.proximity_indication_status = 
            p_operator_info_from_oam->admission_control_info.proximity_indication_status;
        p_operator_info_to_cellm->admission_control_info.bitmask |= RRMCM_RMIF_PROXIMITY_IND_STATUS_PRESENT;
    }
    /*csg proximity end*/
    /** TNL feature Start*/
    p_operator_info_to_cellm->admission_control_info.
        tnl_capacity.total_backhaul_capacity=
        p_operator_info_from_oam->admission_control_info.total_backhaul_capacity;
    p_operator_info_to_cellm->admission_control_info.
        tnl_capacity.capacity_threshold=
        p_operator_info_from_oam->admission_control_info.capacity_threshold;
    /** TNL feature End*/

    /*SPR 18654 START*/
    p_operator_info_to_cellm->admission_control_info.
        dl_bw_for_control_prbs=
        p_operator_info_from_oam->admission_control_info.dl_bw_for_control_prbs;

    p_operator_info_to_cellm->admission_control_info.
        rb_factor_for_bitrate=
        p_operator_info_from_oam->admission_control_info.rb_factor_for_bitrate;
    /*SPR 18654 END*/
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.
        srb_bit_rate=
        p_operator_info_from_oam->admission_control_info.srb_bit_rate;

    p_operator_info_to_cellm->admission_control_info.
        minimum_bitrate=
        p_operator_info_from_oam->admission_control_info.minimum_bitrate;

    p_operator_info_to_cellm->admission_control_info.
        ngbr_threshold=
        p_operator_info_from_oam->admission_control_info.ngbr_threshold;

    p_operator_info_to_cellm->admission_control_info.
        non_default_bearer_multiplier=
        p_operator_info_from_oam->admission_control_info.non_default_bearer_multiplier;

    p_operator_info_to_cellm->admission_control_info.max_eicic_ues=
        p_operator_info_from_oam->admission_control_info.max_eicic_ues;
    /* SPR 20653 Fix End */

    if(p_operator_info_from_oam->admission_control_info.bitmask & RRM_OAM_SPID_TABLE_PRESENT)
    {
        p_operator_info_to_cellm->bitmask |= RRMCM_SPID_TABLE_PRESENT;
        fill_spid_info (&p_operator_info_to_cellm->spid_table, 
                &p_operator_info_from_oam->admission_control_info.spid_table);
    }
    /* SPR_15537_Fix_Start */
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->admission_control_info.dl_bw_for_control_prbs =
        p_operator_info_from_oam->admission_control_info.dl_bw_for_control_prbs;
    /* SPR 20653 Fix End */
    /*SPR 18654 START*/
    /* code deleted */
    /*SPR 18654 END*/
    /* SPR_15537_Fix_End */

    RRM_UT_TRACE_EXIT();
}
void build_and_send_cell_platform_to_cellm 
(
 /*SPR 17777 +-*/
 rrm_mif_context             *p_mif_context,
 rrm_plat_cell_load_t   *p_in_cell_plat_ind,
 rrmcm_rmif_cell_platform_t *p_out_cell_platform
 )
{
    U8 index = RRM_ZERO;
    p_out_cell_platform->cell_index = p_mif_context->cell_index; 
    p_out_cell_platform->ind_type = p_in_cell_plat_ind->ind_type; 
    p_out_cell_platform->count = p_in_cell_plat_ind->count; 

    for(index = RRM_ZERO;index <p_in_cell_plat_ind->count; index++)
    {
        /* coverity : CID 29717*/
        p_out_cell_platform->cell_load[index].load_src  = (rrm_oam_load_src_et) p_in_cell_plat_ind->load_source[index].load_src;
        /* Coverity_ID : 54442 */
        p_out_cell_platform->cell_load[index].load_level= (rrm_load_type)p_in_cell_plat_ind->load_source[index].load_level;
    }
    /* Sending config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_PLATFORM_IND,
            sizeof(rrmcm_rmif_cell_platform_t),
            (void *)p_out_cell_platform);
}
/****************************************************************************
 * Function Name  : build_and_send_cell_ecn_capacity_enhance_req_to_cellm 
 * Inputs         : -p_gl_ctxt
 *                  -p_mif_context
 *                  -p_in_cell_ecn_confgiure_bitrate
 *                  -p_out_cell_ecn_config_req
 * Outputs        : None.
 * Returns        : Void
 * Description    : This function populates ecn_capacity_enhace_req to CELLM 
 ****************************************************************************/
void build_and_send_cell_ecn_capacity_enhance_req_to_cellm 
(
 /*SPR 17777 +-*/
 rrm_mif_context             *p_mif_context,
 rrm_ecn_configure_cell_list_t *p_in_cell_ecn_confgiure_bitrate,
 rrmcm_rmif_cell_ecn_config_req_t *p_out_cell_ecn_config_req
 )
{
    U8 index= RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_cell_ecn_confgiure_bitrate);
    RRM_ASSERT (RRM_PNULL != p_out_cell_ecn_config_req);

    p_out_cell_ecn_config_req->cell_index= p_mif_context->cell_index; 
    p_out_cell_ecn_config_req->transaction_id= p_mif_context->currently_processed_api_trans_d;

    p_out_cell_ecn_config_req->num_of_ue = p_in_cell_ecn_confgiure_bitrate->num_of_ue;
    p_out_cell_ecn_config_req->bitrate.bitmask = p_in_cell_ecn_confgiure_bitrate->bitrate.bitmask;
    p_out_cell_ecn_config_req->bitrate.count =  p_in_cell_ecn_confgiure_bitrate->bitrate.count;

    for(index = RRM_ZERO;index< p_out_cell_ecn_config_req->bitrate.count;index++)
    {
        p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].qci=
            p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].qci;
        if (p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].bitmask &
                RRM_OAM_ECN_UL_BITRATE_PRESENT)
        {
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].bitmask |= RRMCM_RMIF_ECN_UL_BITRATE;
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].ul_bitrate.max_bitrate=
                p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].ul_bitrate.max_bitrate;
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].ul_bitrate.min_bitrate=
                p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].ul_bitrate.min_bitrate;
        }
        if (p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].bitmask &
                RRM_OAM_ECN_DL_BITRATE_PRESENT)
        {
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].bitmask |= RRMCM_RMIF_ECN_DL_BITRATE;
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].dl_bitrate.max_bitrate=
                p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].dl_bitrate.max_bitrate;
            p_out_cell_ecn_config_req->bitrate.bitrate_for_qci[index].dl_bitrate.min_bitrate=
                p_in_cell_ecn_confgiure_bitrate->bitrate.bitrate_for_qci[index].dl_bitrate.min_bitrate;
        }
    }
    /* Sending config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_ECN_CAPACITY_REQ,
            sizeof(rrmcm_rmif_cell_ecn_config_req_t),
            (void *)p_out_cell_ecn_config_req);

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : build_and_send_cell_config_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_config_req_from_oam - It's not null pointer.
 *                  -p_out_cell_config_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Config Request to CellM
 ****************************************************************************/
void build_and_send_cell_config_req_to_cellm(rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context, 
        rrm_oam_cell_config_req_t *p_in_cell_config_req_from_oam, 
        rrmcm_rmif_cell_config_req_t    *p_out_cell_config_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();
    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_cell_config_req_from_oam);
    RRM_ASSERT (RRM_PNULL != p_out_cell_config_req_to_cellm);
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "DEBUG : ECGI matched in cell config ");

        p_out_cell_config_req_to_cellm->bitmask = 0x00;
        p_out_cell_config_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
        /* cell_index_from_api_header_start */
        p_out_cell_config_req_to_cellm->cell_index = p_mif_context->cell_index;
        /* cell_index_from_api_header_end */
        rrm_memcpy_rrm_oam_eutran_global_cell_id(
                &(p_out_cell_config_req_to_cellm->global_cell_id),
                &(p_in_cell_config_req_from_oam->global_cell_info.eutran_global_cell_id));

        /* filling Cell Config Request Message */
    /* SPR 20653 Fix Start */
        fill_cell_config_request_for_cellm(p_out_cell_config_req_to_cellm, 
                p_in_cell_config_req_from_oam);
    /* SPR 20653 Fix End */

        /* Sending config request to RRMCM*/
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_CONFIG_REQ,
                /* SPR 20653 Fix start */
                sizeof(rrmcm_rmif_cell_config_req_t),
                /* SPR 20653 Fix End */
                (void *)p_out_cell_config_req_to_cellm);

    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : build_and_send_cell_reconfig_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_reconfig_req_from_oam - It's not null pointer.
 *                  -p_out_cell_config_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell ReConfig Request to CellM
 ****************************************************************************/
void build_and_send_cell_reconfig_req_to_cellm(rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context, 
        rrm_oam_cell_reconfig_req_t *p_in_cell_reconfig_req_from_oam, 
        rrmcm_rmif_cell_reconfig_req_t    *p_out_cell_reconfig_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL !=p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_cell_reconfig_req_from_oam);
    RRM_ASSERT (RRM_PNULL !=p_out_cell_reconfig_req_to_cellm);

    /* SPR 20653 Fix Start */
    /* Code Removed */

    p_out_cell_reconfig_req_to_cellm->bitmask = 0x00;
    p_out_cell_reconfig_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_reconfig_req_to_cellm->cellindex = p_mif_context->cell_index;

    /* filling Cell Re-Config Request Message */
    fill_cell_reconfig_request_for_cellm(p_out_cell_reconfig_req_to_cellm, 
            p_in_cell_reconfig_req_from_oam);

    /* SPR 20653 Fix End */
    /* SPR_17763_FIX_START */
    RRM_GETTIMEOFDAY(&(p_out_cell_reconfig_req_to_cellm->incoming_time_stamp),RRM_PNULL);
    /* SPR_17763_FIX_END */

    /* SPR 21496 Fix Start */
    /* Sending config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_RECONFIG_REQ,
            /*SPR 21110-21113 Fix start*/
            sizeof(rrmcm_rmif_cell_reconfig_req_t),
            /*SPR 21110-21113 Fix end*/
            (void *)p_out_cell_reconfig_req_to_cellm);
    /* SPR 21496 Fix End */
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_cell_del_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_ut_cell_del_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Delete Request to CellM
 ****************************************************************************/
void build_and_send_cell_del_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context,
        /*SPR 21369 Start*/
        rrm_oam_cell_delete_req_t   *p_cell_delete_req_msg_from_oam, 
        /*SPR 21369 End*/
        rrmcm_rmif_cell_delete_req_t    *p_ut_cell_del_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_ut_cell_del_req_to_cellm);

    p_ut_cell_del_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_ut_cell_del_req_to_cellm->cellindex = p_mif_context->cell_index;
    /* SPR 21632 Start */
    p_ut_cell_del_req_to_cellm->bitmask = RRM_ZERO;
    /* SPR 21632 End */

        /*SPR 21369 Start*/
    if(RRM_OAM_INSTANCE_RESET_FLAG_PRESENT & p_cell_delete_req_msg_from_oam->bitmask)
    {
	/* SPR 21632 Start */
        p_ut_cell_del_req_to_cellm->bitmask |= RRMCM_RMIF_INSTANCE_RESET_FLAG_PRESENT;
	/* SPR 21632 End */
    }
    else
    {
        p_ut_cell_del_req_to_cellm->bitmask=RRM_ZERO;
    }
    /*SPR 21369 End*/
    /* Sending delete request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_DELETE_REQ,
            sizeof(rrmcm_rmif_cell_delete_req_t),
            (void *)p_ut_cell_del_req_to_cellm);


    RRM_UT_TRACE_EXIT();


}

/****************************************************************************
 * Function Name  : build_and_send_cell_stop_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_stop_req_from_oam - It's not null pointer.
 *                  -p_ut_cell_stop_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Stop Request to CellM
 ****************************************************************************/
void build_and_send_cell_stop_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context            *p_mif_context, 
        rrmcm_rmif_cell_stop_req_t *p_ut_cell_stop_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_ut_cell_stop_req_to_cellm);

    p_ut_cell_stop_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_ut_cell_stop_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* Sending stop request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_STOP_REQ,
            sizeof(rrmcm_rmif_cell_stop_req_t),
            (void *)p_ut_cell_stop_req_to_cellm);


    RRM_UT_TRACE_EXIT();


}

/*Cell update start*/
/****************************************************************************
 * Function Name  : fill_cell_update_request_for_cellm
 * Inputs         : - p_cell_update_req_to_cellm
 *                  - p_cell_update_req_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill Cell Update Info for CellM module.
 ****************************************************************************/
void fill_cell_update_request_for_cellm(
        rrmcm_rmif_cell_update_req_t   *p_cell_update_req_to_cellm,
        rrm_oam_cell_update_req_t      *p_cell_update_req_from_oam)
{
    U16    plmn_count;

    RRM_ASSERT (RRM_PNULL != p_cell_update_req_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_cell_update_req_from_oam);

    RRM_UT_TRACE_ENTER();

    p_cell_update_req_to_cellm->bitmask = 0;

    if (p_cell_update_req_from_oam->bitmask & RRM_OAM_PCI_VALUE_PRESENT) 
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_PCI_VALUE_PRESENT");
        p_cell_update_req_to_cellm->bitmask |= RRMCM_RMIF_PCI_VALUE_PRESENT;

        p_cell_update_req_to_cellm->pci_value =
            p_cell_update_req_from_oam->pci_value;
    }

    if (p_cell_update_req_from_oam->bitmask & RRM_OAM_UPDATED_PLMN_INFO_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_UPDATED_PLMN_INFO");
        p_cell_update_req_to_cellm->bitmask |= RRMCM_RMIF_UPDATED_PLMN_INFO;

        p_cell_update_req_to_cellm->updated_plmn_info.no_of_valid_plmns =
            p_cell_update_req_from_oam->updated_plmn_info.no_of_valid_plmns;

        for (plmn_count=0;
                ((plmn_count < p_cell_update_req_to_cellm->updated_plmn_info.no_of_valid_plmns)
                 && (plmn_count < RRM_OAM_MAX_NUM_PLMNS));
                plmn_count++)
        {
            fill_plmn_info(
                    &p_cell_update_req_to_cellm->updated_plmn_info.plmn_list[plmn_count],
                    &p_cell_update_req_from_oam->updated_plmn_info.plmn_list[plmn_count]);
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_cell_update_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_update_req_from_oam - It's not null pointer.
 *                  -p_out_cell_update_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Update Request to CellM
 ****************************************************************************/
void build_and_send_cell_update_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context                 *p_mif_context,
        rrm_oam_cell_update_req_t       *p_in_cell_update_req_from_oam,
        rrmcm_rmif_cell_update_req_t    *p_out_cell_update_req_to_cellm)
{
    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_cell_update_req_from_oam);
    RRM_ASSERT (RRM_PNULL !=p_out_cell_update_req_to_cellm);

    p_out_cell_update_req_to_cellm->bitmask = 0x00;
    p_out_cell_update_req_to_cellm->transaction_id = 
        p_mif_context->currently_processed_api_trans_d;
    p_out_cell_update_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* filling Cell Update Request Message */
    fill_cell_update_request_for_cellm(p_out_cell_update_req_to_cellm,
            p_in_cell_update_req_from_oam);


    /* Sending config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_UPDATE_REQ,
            sizeof(rrmcm_rmif_cell_update_req_t),
            (void *)p_out_cell_update_req_to_cellm);

    RRM_UT_TRACE_EXIT();
}
/*Cell update end*/

/****************************************************************************
 * Function Name  : build_and_send_cell_start_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_start_req_from_oam - It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_cell_start_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        rrmcm_rmif_cell_start_req_t   
        *p_ut_cell_start_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_ut_cell_start_req_to_cellm);

    p_ut_cell_start_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_ut_cell_start_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* Sending start request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_START_REQ,
            sizeof(rrmcm_rmif_cell_start_req_t),
            (void *)p_ut_cell_start_req_to_cellm);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_cell_stop_adm_req_for_cell_block_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_shutdown_req_from_oam - It's not null pointer.
 *                  -p_out_cell_stop_adm_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Stop Admission Request for cell block to CellM
 ****************************************************************************/
void build_and_send_cell_stop_adm_req_for_cell_block_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        rrmcm_rmif_cell_stop_adm_req_for_cell_block_t  
        *p_out_cell_stop_adm_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_out_cell_stop_adm_req_to_cellm);

    p_out_cell_stop_adm_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_stop_adm_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* SPR_17763_FIX_START */
    RRM_GETTIMEOFDAY(&(p_out_cell_stop_adm_req_to_cellm->incoming_time_stamp),RRM_PNULL);
    /* SPR_17763_FIX_END */
    /* Sending stop admission request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_STOP_ADMISSION_REQ_FOR_CELL_BLOCK,
            sizeof(rrmcm_rmif_cell_stop_adm_req_for_cell_block_t),
            (void *)p_out_cell_stop_adm_req_to_cellm);


    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name  : build_and_send_cell_stop_adm_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_shutdown_req_from_oam - It's not null pointer.
 *                  -p_out_cell_stop_adm_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Stop Admission Request to CellM
 ****************************************************************************/
void build_and_send_cell_stop_adm_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        rrmcm_rmif_cell_stop_adm_req_t  
        *p_out_cell_stop_adm_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_out_cell_stop_adm_req_to_cellm);

    p_out_cell_stop_adm_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_stop_adm_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* Sending stop admission request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_STOP_ADMISSION_REQ,
            sizeof(rrmcm_rmif_cell_stop_adm_req_t),
            (void *)p_out_cell_stop_adm_req_to_cellm);


    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name  : build_and_send_cell_start_adm_req_for_cell_unblock_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_switch_on_from_son - It's not null pointer.
 *                  -p_out_cell_start_adm_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Start Admission Request to CellM
 ****************************************************************************/
void build_and_send_cell_start_adm_req_for_cell_unblock_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        /*SPR 17777 +-*/
        rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t  
        *p_out_cell_start_adm_req_for_cell_unblock_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_out_cell_start_adm_req_for_cell_unblock_to_cellm);

    p_out_cell_start_adm_req_for_cell_unblock_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_start_adm_req_for_cell_unblock_to_cellm->cellindex = p_mif_context->cell_index;

    /*SPR 21322 START*/
    RRM_GETTIMEOFDAY(&(p_out_cell_start_adm_req_for_cell_unblock_to_cellm->incoming_time_stamp),RRM_PNULL);
    /*SPR 21322 END*/
    /* Sending stop admission request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_START_ADMISSION_REQ_FOR_CELL_UNBLOCK,
            sizeof(rrmcm_rmif_cell_start_adm_req_for_cell_unblock_t),
            (void *)p_out_cell_start_adm_req_for_cell_unblock_to_cellm);


    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_cell_start_adm_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_switch_on_from_son - It's not null pointer.
 *                  -p_out_cell_start_adm_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Start Admission Request to CellM
 ****************************************************************************/
void build_and_send_cell_start_adm_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        /*SPR 17777 +-*/
        rrmcm_rmif_cell_start_adm_req_t  
        *p_out_cell_start_adm_req_to_cellm)
{

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_out_cell_start_adm_req_to_cellm);
    /*SPR 15993 Fix Start*/
    p_out_cell_start_adm_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    /*SPR 15993 Fix End*/
    p_out_cell_start_adm_req_to_cellm->cellindex = p_mif_context->cell_index;


    /* Sending stop admission request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_START_ADMISSION_REQ,
            sizeof(rrmcm_rmif_cell_start_adm_req_t),
            (void *)p_out_cell_start_adm_req_to_cellm);


    RRM_UT_TRACE_EXIT();
}

/* UE MEAS CHANGES : STARTS */
/****************************************************************************
 * Function Name  : build_and_send_son_ue_meas_config_req_to_cellm 
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_meas_config_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Ue Meas Config Request to CellM
 ****************************************************************************/
void build_and_send_son_ue_meas_config_req_to_cellm
(
 /*SPR 17777 +-*/
 rrm_mif_context            *p_mif_context, 
 rrm_son_meas_config_req_t  *p_in_meas_config_req_msg
 /*SPR 17777 +-*/
 )
{
    rrmcm_rmif_cell_son_meas_config_req_t  *p_out_meas_config_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_meas_config_req_msg);

    p_out_meas_config_req = (rrmcm_rmif_cell_son_meas_config_req_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_meas_config_req_t));

    if ( p_out_meas_config_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_meas_config_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_out_meas_config_req->cellindex = p_mif_context->cell_index;
    p_out_meas_config_req->transaction_id = 
        p_mif_context->currently_processed_api_trans_d;

    RRM_MEMCPY(&(p_out_meas_config_req->meas_config_req),
            (p_in_meas_config_req_msg),
            sizeof(rrm_son_meas_config_req_t));

    /* Sending meas config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_MEAS_CONFIG_FROM_ANR_REQ,
            sizeof(rrmcm_rmif_cell_son_meas_config_req_t),
            (void *)p_out_meas_config_req);

    RRM_MEM_FREE(p_out_meas_config_req);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_son_ue_meas_config_obj_remove_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_meas_config_obj_remove_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Ue Meas Config Request to CellM
 ****************************************************************************/
void build_and_send_son_ue_meas_config_obj_remove_req_to_cellm
(
 /*SPR 17777 +-*/
 rrm_mif_context            *p_mif_context,
 rrm_son_meas_config_obj_remove_req_t  *p_in_meas_config_obj_remove_req_msg
 /*SPR 17777 +-*/
 )
{
    rrmcm_rmif_cell_son_meas_config_obj_remove_req_t  *p_out_meas_config_obj_remove_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_meas_config_obj_remove_req_msg);

    p_out_meas_config_obj_remove_req = (rrmcm_rmif_cell_son_meas_config_obj_remove_req_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_meas_config_obj_remove_req_t));
    if ( p_out_meas_config_obj_remove_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_meas_config_obj_remove_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    p_out_meas_config_obj_remove_req->cellindex = p_mif_context->cell_index;
    p_out_meas_config_obj_remove_req->transaction_id =
        p_mif_context->currently_processed_api_trans_d;

    RRM_MEMCPY(&(p_out_meas_config_obj_remove_req->meas_config_obj_remove_req),
            (p_in_meas_config_obj_remove_req_msg),
            sizeof(rrm_son_meas_config_obj_remove_req_t));

    /* Sending meas config request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_MEAS_CONFIG_OBJ_REMOVE_REQ,
            sizeof(rrmcm_rmif_cell_son_meas_config_obj_remove_req_t),
            (void *)p_out_meas_config_obj_remove_req);

    RRM_MEM_FREE(p_out_meas_config_obj_remove_req);

    RRM_UT_TRACE_EXIT();
}


/* UE MEAS CHANGES : ENDS */

/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : build_and_send_rach_info_req_to_uem
 * Inputs         : p_in_rach_info_req_msg - ptr to request msg
 *                  src  - source module id
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares RACH INFO req to UEM
 ****************************************************************************/
void 
build_and_send_rach_info_req_to_uem
(
 rrm_mif_context             *p_mif_context,
 rrm_son_rach_config_req_t   *p_in_rach_info_req_msg
 /*SPR 17777 +-*/
 )
{
    rrmuem_rmif_rach_info_ind_t  *p_out_rach_info_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL !=p_in_rach_info_req_msg);

    p_out_rach_info_ind = (rrmuem_rmif_rach_info_ind_t *)
        rrm_mem_get(sizeof(rrmuem_rmif_rach_info_ind_t));
    if ( p_out_rach_info_ind == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_rach_info_ind failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    RRM_MEMSET(p_out_rach_info_ind, RRM_ZERO, sizeof(rrmuem_rmif_rach_info_ind_t));

    p_out_rach_info_ind->cell_index = p_mif_context->cell_index;

    if(p_in_rach_info_req_msg->bitmask & UE_REPORT_PERIODICITY_PRESENT)
    {
        p_out_rach_info_ind->ue_reports_periodicity = 
            p_in_rach_info_req_msg->ue_reports_periodicity;
        p_out_rach_info_ind->bitmask |= RRM_UE_REPORT_PERIODICITY_PRESENT;
    }
    if(p_in_rach_info_req_msg->bitmask & RACH_SAMPLE_COUNT_PRESENT)
    {
        p_out_rach_info_ind->rach_sample_count = 
            p_in_rach_info_req_msg->rach_sample_count;
        p_out_rach_info_ind->bitmask |= RRM_UE_RACH_SAMPLE_COUNT_PRESENT;
    }
    if(p_in_rach_info_req_msg->bitmask & NUM_STRONGEST_CELLS_PRESENT)
    {
        p_out_rach_info_ind->num_of_strongest_cells = 
            p_in_rach_info_req_msg->num_of_strongest_cells;
        p_out_rach_info_ind->bitmask |= RRM_UE_NUM_STRONGEST_CELLS_PRESENT;
    }

    /* Sending RACH_INFO_REQ to RRMCM*/
    rrm_mif_send_internal_msg(RRM_UEM_MODULE_ID,
            RRMUEM_RMIF_RACH_INFO_IND,
            sizeof(rrmuem_rmif_rach_info_ind_t),
            (void *)p_out_rach_info_ind);

    RRM_MEM_FREE(p_out_rach_info_ind);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_rach_info_req_to_cellm
 * Inputs         : p_in_rach_info_req_msg - ptr to request msg
 *                  src  - source module id
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares RACH INFO req to CellM
 ****************************************************************************/
void 
build_and_send_rach_info_req_to_cellm
(
 rrm_mif_context             *p_mif_context,
 rrm_son_rach_config_req_t   *p_in_rach_info_req_msg
 /*SPR 17777 +-*/
 )
{
    rrmcm_rmif_rach_info_ind_t  *p_out_rach_info_ind = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_in_rach_info_req_msg);

    p_out_rach_info_ind = (rrmcm_rmif_rach_info_ind_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_rach_info_ind_t));
    if ( p_out_rach_info_ind == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_rach_info_ind failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_out_rach_info_ind->l2_reports_periodicity =
        p_in_rach_info_req_msg->l2_reports_periodicity;
    p_out_rach_info_ind->cell_index = p_mif_context->cell_index;
    /* Sending RACH_INFO_REQ to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_RACH_INFO_IND,
            sizeof(rrmcm_rmif_rach_info_ind_t),
            (void *)p_out_rach_info_ind);

    RRM_MEM_FREE(p_out_rach_info_ind);

    RRM_UT_TRACE_EXIT();
}
/* RACH_OPTIMIZATION_CHANGES_END */

/* TNL DISCOVERY : START */
/****************************************************************************
 * Function Name  : build_and_send_son_tnl_discovery_to_cellm
 * Inputs         : p_in_tnl_discovery_req_msg - ptr to request msg
 *                  src  - source module id
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares TNL DISCOVERY req to CellM
 ****************************************************************************/

void build_and_send_son_tnl_discovery_to_cellm 
(
 U16                         transaction_id,
 rrm_son_tnl_discovery_req_t *p_in_tnl_discovery_req_msg
 /*SPR 17777 +-*/
 )
{
    rrmcm_rmif_cell_son_tnl_discovery_req_t  *p_out_tnl_discovery_req = RRM_PNULL;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL !=p_in_tnl_discovery_req_msg);

    p_out_tnl_discovery_req = (rrmcm_rmif_cell_son_tnl_discovery_req_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_tnl_discovery_req_t));
    if ( p_out_tnl_discovery_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_tnl_discovery_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    /* Spr 16142 Fix Start */
    RRM_MEMSET((void *)p_out_tnl_discovery_req,0,
            sizeof(rrmcm_rmif_cell_son_tnl_discovery_req_t));
    /* Spr 16142 Fix End */

    p_out_tnl_discovery_req->transaction_id = transaction_id;

    rrm_memcpy_rrm_son_tnl_discovery_req(
            &(p_out_tnl_discovery_req->tnl_discovery_req),
            (p_in_tnl_discovery_req_msg));

    /* Sending TNL discovery request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_TNL_DISCOVERY_FROM_ANR_REQ,
            sizeof(rrmcm_rmif_cell_son_tnl_discovery_req_t),
            (void *)p_out_tnl_discovery_req);

    RRM_MEM_FREE(p_out_tnl_discovery_req);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_son_cell_register_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_register_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell register Request to CellM
 ****************************************************************************/
void build_and_send_son_cell_register_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        rrm_son_register_req_t *p_in_cell_register_req_msg,
        U16                     src)
{
    rrmcm_rmif_cell_son_register_deregister_req_t  *p_out_cell_register_req = RRM_PNULL;
    U8                                      attrListCnt = 0;
    rrm_cellm_attribute_id_et               cellm_attrb_id;

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_cell_register_req_msg);

    p_out_cell_register_req = (rrmcm_rmif_cell_son_register_deregister_req_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_register_deregister_req_t));

    if ( p_out_cell_register_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_cell_register_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    rrm_memset_son__and_dl_power_params_req(p_out_cell_register_req, RRM_ZERO);

    p_out_cell_register_req->cellindex = p_mif_context->cell_index;
    p_out_cell_register_req->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_register_req->attr_list_size = 
        p_in_cell_register_req_msg->register_req.object.attr_list_size;

    for (attrListCnt = 0 ; attrListCnt <  p_out_cell_register_req->attr_list_size ; attrListCnt++)
    {
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
        cellm_attrb_id = son_cellm_attribute_id_mapping(p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].id);
        p_out_cell_register_req->attribute_list[attrListCnt].id = cellm_attrb_id;
        /* SPR 20653 Fix Start */
        switch(cellm_attrb_id)
        {
            case RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT:
                p_out_cell_register_req->attribute_list[attrListCnt].value =
                    p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].value;
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_list = 
                    p_in_cell_register_req_msg->register_req.object.
                    p_attr_lst[attrListCnt].trgr_list_size;
                break;

                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            case RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD:
                p_out_cell_register_req->attribute_list[attrListCnt].value =
                    p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].value;
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_list = 
                    p_in_cell_register_req_msg->register_req.object.
                    p_attr_lst[attrListCnt].trgr_list_size;
                break;
            case RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD:
                p_out_cell_register_req->attribute_list[attrListCnt].value =
                    p_in_cell_register_req_msg->register_req.object.p_attr_lst[attrListCnt].value;
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_list = 
                    p_in_cell_register_req_msg->register_req.object.
                    p_attr_lst[attrListCnt].trgr_list_size;
                break;
            default:
                p_out_cell_register_req->attribute_list[attrListCnt].trigger_list = 
                    p_in_cell_register_req_msg->register_req.object.
                    p_attr_lst[attrListCnt].trgr_list_size;
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                fill_cellm_trigger_type(p_out_cell_register_req , p_in_cell_register_req_msg, attrListCnt);
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
        }
        /* SPR 20653 Fix End */


    }
    if (RRM_SON_ANR_MODULE_ID == src)
    {
        /* Sending Register request to RRMCM*/
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_REGISTER_FROM_ANR_REQ,
                sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                (void *)p_out_cell_register_req);
    }
    else if (RRM_SON_ES_MODULE_ID == src)
    {
        /* Sending Register request to RRMCM*/
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_REGISTER_FROM_ES_REQ,
                sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                (void *)p_out_cell_register_req);
    }
    else if (RRM_SON_MLB_MODULE_ID == src)
    {
        /* Sending Register request to RRMCM for MLB */
        rrm_mif_send_internal_msg (RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_REGISTER_FROM_MLB_REQ,
                sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                (void *)p_out_cell_register_req);
    }

    /* MRO code changes start */
    else if (RRM_SON_MRO_MODULE_ID == src)
    {
        /* Sending Register request to RRMCM for MRO */
        rrm_mif_send_internal_msg (RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_REGISTER_FROM_MRO_REQ,
                sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                (void *)p_out_cell_register_req);
    }
    /* MRO code changes end */

    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Message received from Invalid Source(%d)", src);
    }
    RRM_MEM_FREE(p_out_cell_register_req);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_son_cell_deregister_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_deregister_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Deregister Request to CellM
 ****************************************************************************/
void build_and_send_son_cell_deregister_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context, 
        rrm_son_deregister_req_t *p_in_cell_deregister_req_msg,
        U16                      src)
{
    rrmcm_rmif_cell_son_register_deregister_req_t    *p_out_cell_de_register_req = RRM_PNULL;
    U8                                                attrListCnt = 0;

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_cell_deregister_req_msg);

    p_out_cell_de_register_req = (rrmcm_rmif_cell_son_register_deregister_req_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_register_deregister_req_t));
    if ( p_out_cell_de_register_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_cell_de_register_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_out_cell_de_register_req->cellindex = p_mif_context->cell_index;
    p_out_cell_de_register_req->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_out_cell_de_register_req->attr_list_size = p_in_cell_deregister_req_msg->deregister_req.object.attr_list_size;

    for (attrListCnt = 0; attrListCnt <  p_out_cell_de_register_req->attr_list_size; attrListCnt++)
    {
        switch(p_in_cell_deregister_req_msg->deregister_req.object.p_attr_lst[attrListCnt].id)
        {
            case RRM_ATTR_CELL_STATE :
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_CELL_STATE;
                break; 

            case RRM_ATTR_ACTIVE_UE_COUNT_REPORT :
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = 
                    RRM_MIF_CELLM_ATTR_ACTIVE_UE_COUNT_REPORT;
                break; 

            case RRM_ATTR_ACTIVE_UE_THRESHOLD :
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = 
                    RRM_MIF_CELLM_ATTR_ACTIVE_UE_THRESHOLD;
                break; 

            case RRM_ATTR_S1_MSG_NOTIFICATION :
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = 
                    RRM_MIF_CELLM_ATTR_S1_MSG_NOTIFICATION;
                break;
                /* UE MEAS CHANGES : STARTS */
            case RRM_ATTR_MEAS_UE_COUNT:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = 
                    RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT;
                break;

            case RRM_ATTR_MEAS_REPORTING_INTERVAL:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = 
                    RRM_MIF_CELLM_ATTR_MEAS_REPORTING_INTERVAL;
                break;
                /* BLR Team HO status report to SON Changes Start */
            case RRM_ATTR_HO_REPORT:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_HO_REPORT;
                break;
                /* UE MEAS CHANGES : ENDS */
                /* MRO start */
            case RRM_ATTR_HO_ATTEMPT_IND:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_HO_ATTEMPT_IND;
                break;

            case RRM_ATTR_HO_FAILURE_REPORT:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_HO_FAILURE_REPORT;
                break;
                /* MRO ends */

                /* MLB Changes start */
            case RRM_ATTR_NEIGHBOR_LOAD_REPORT:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_MLB_NBR;
                break;

            case RRM_ATTR_LOAD_REPORT:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_MLB_SELF;
                break;
                /* MLB Changes end */
                /* SPR 20653 Fix Start */
            case RRM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD;
                break;

            case RRM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD:
                p_out_cell_de_register_req->attribute_list[attrListCnt].id =
                    RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD;
                break;
                /* SPR 20653 Fix End */

            case RRM_ATTR_UNDEF:
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                        RRM_ERROR,"Attribute[%u] is not defined",
                        p_in_cell_deregister_req_msg->deregister_req.object.p_attr_lst[attrListCnt].id);
                p_out_cell_de_register_req->attribute_list[attrListCnt].id = RRM_MIF_CELLM_ATTR_UNDEF;
                break;
        }

        p_out_cell_de_register_req->attribute_list[attrListCnt].trigger_list = 0;
    }

    switch (src)
    {
        case RRM_SON_ANR_MODULE_ID:
            {
                /* Sending Deregister request to RRMCM*/
                rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                        RRMCM_RMIF_CELL_DEREGISTER_FROM_ANR_REQ,
                        sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                        (void *)p_out_cell_de_register_req);
            }
            break;

        case RRM_SON_ES_MODULE_ID:
            {
                /* Sending Deregister request to RRMCM*/
                rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                        RRMCM_RMIF_CELL_DEREGISTER_FROM_ES_REQ,
                        sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                        (void *)p_out_cell_de_register_req);
            }
            break;

        case RRM_SON_MLB_MODULE_ID:
            {
                /* Sending Deregister request to RRMCM*/
                rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                        RRMCM_RMIF_CELL_DEREGISTER_FROM_MLB_REQ,
                        sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                        (void *)p_out_cell_de_register_req);
            }
            break;

            /* MRO code changes start */
        case RRM_SON_MRO_MODULE_ID:
            {
                /* Sending Deregister request to RRMCM*/
                rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                        RRMCM_RMIF_CELL_DEREGISTER_FROM_MRO_REQ,
                        sizeof(rrmcm_rmif_cell_son_register_deregister_req_t),
                        (void *)p_out_cell_de_register_req);
            }
            break;
            /* MRO code changes end */

        default:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Message received from Invalid Source(0x%x)", src);
            }
            break;
    }
    RRM_MEM_FREE(p_out_cell_de_register_req);
    RRM_UT_TRACE_EXIT();


}

/****************************************************************************
 * Function Name  : build_and_send_son_cell_set_attributes_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_cell_set_attributes_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Set Attributes Request to CellM
 ****************************************************************************/
void build_and_send_son_cell_set_attributes_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context       *p_mif_context, 
        rrm_son_set_attribute_value_req_t
        *p_in_son_set_attributes_req_msg,
        U16                    src)
{
    rrmcm_rmif_cell_set_attr_req                *p_out_cell_set_attr_req = RRM_PNULL; 
    rrm_cellm_attribute_id_et                    cellm_attrb_id;
    /* SPR 20653 Fix Start */
    U8                                           attrListCnt = 0;
    /* SPR 20653 Fix End */
    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_in_son_set_attributes_req_msg);

    p_out_cell_set_attr_req = (rrmcm_rmif_cell_set_attr_req *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_set_attr_req));
    if ( p_out_cell_set_attr_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_cell_set_attr_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    p_out_cell_set_attr_req->cellindex = p_mif_context->cell_index;
    p_out_cell_set_attr_req->transaction_id = p_mif_context->currently_processed_api_trans_d;

    /* SPR 20653 Fix Start */
    if (RRM_OBJ_CELL != p_in_son_set_attributes_req_msg->object.type)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Object Type(%d) is Unknown received from SON", 
                p_in_son_set_attributes_req_msg->object.type);
        /* coverity : CID 16482*/
        p_out_cell_set_attr_req->attribute[attrListCnt].id = RRM_MIF_CELLM_ATTR_UNDEF;
    }
    else
    {
        /* SPR 20653 Fix Start */
        p_out_cell_set_attr_req->attr_list_size = 
            p_in_son_set_attributes_req_msg->object.attr_list_size;

        for (attrListCnt = 0 ; attrListCnt <  p_out_cell_set_attr_req->attr_list_size ; attrListCnt++)
        {
            cellm_attrb_id = son_cellm_attribute_id_mapping(p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].id);
            p_out_cell_set_attr_req->attribute[attrListCnt].id = cellm_attrb_id;
            switch(cellm_attrb_id)
            {
                /* CID 112952, 112953, 112954 Start */
                case RRM_MIF_CELLM_ATTR_MEAS_UE_COUNT:
                    p_out_cell_set_attr_req->attribute[attrListCnt].value =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].value;
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_list = 
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list_size;
                    p_mif_context->id = p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].id;
                    break;

                case RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_DL_ANR_THRESHOLD:
                    p_out_cell_set_attr_req->attribute[attrListCnt].value =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].value;
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_list = 
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list_size;
                    p_mif_context->id = p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].id;
                    break;

                case RRM_MIF_CELLM_ATTR_UE_THROUGHPUT_UL_ANR_THRESHOLD:
                    p_out_cell_set_attr_req->attribute[attrListCnt].value =
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].value;
                    p_out_cell_set_attr_req->attribute[attrListCnt].trigger_list = 
                        p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].trgr_list_size;
                    p_mif_context->id = p_in_son_set_attributes_req_msg->object.p_attr_lst[attrListCnt].id;
                    break;
                    /* CID 112952, 112953, 112954 End */

                default:
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                    fill_cellm_set_attribute_req_trigger_type(p_in_son_set_attributes_req_msg , p_out_cell_set_attr_req, attrListCnt);
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            }
        }
    }
    /* SPR 20653 Fix End */

    if (RRM_SON_ANR_MODULE_ID == src)
    {
        /* Sending Set Attribute request to RRMCM*/
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.set_attribute_req_from_anr);
#endif        
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ANR_REQ,
                sizeof(rrmcm_rmif_cell_set_attr_req),
                (void *)p_out_cell_set_attr_req);
    }
    else if (RRM_SON_ES_MODULE_ID == src)
    {
        /* Sending Set Attribute request to RRMCM*/
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.set_attribute_req_from_es);
#endif        
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_ES_REQ,
                sizeof(rrmcm_rmif_cell_set_attr_req),
                (void *)p_out_cell_set_attr_req);
    }
    else if (RRM_SON_MLB_MODULE_ID == src)
    {
        /* Sending Set Attribute request to RRMCM*/
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmSonDebugStats.set_attribute_req_from_es);
#endif        
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MLB_REQ,
                sizeof(rrmcm_rmif_cell_set_attr_req),
                (void *)p_out_cell_set_attr_req);
    }
    /* MRO code changes start */
    else if (RRM_SON_MRO_MODULE_ID == src)
    {
        /* Sending Set Attribute request to RRMCM*/
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_CELL_SET_ATTRIBUTE_FROM_MRO_REQ,
                sizeof(rrmcm_rmif_cell_set_attr_req),
                (void *)p_out_cell_set_attr_req);
    }
    /* MRO code changes end */
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Message received from Invalid Source(%d)", src);
    }
    RRM_MEM_FREE(p_out_cell_set_attr_req);

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  :build_and_send_log_enable_disable_req 
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_in_cell_del_req_from_oam - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Log Enable/Disable Request to CellM/UeM
 ****************************************************************************/
void build_and_send_log_enable_disable_req(
        /*SPR 17777 +-*/
        rrm_oam_log_enable_disable_req_t  *p_in_set_log_level_req_from_oam,
        U16                                trans_id)
{
    rrmcm_rmif_log_enable_disable_req_t  OutLogEnDisReqToCellM = {0};
    rrmuem_rmif_log_enable_disable_req_t OutLogEnDisReqToUeM = {0};

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_in_set_log_level_req_from_oam);

    if ((p_in_set_log_level_req_from_oam->module_id == RRM_OAM_CM_MODULE_ID) ||
            (p_in_set_log_level_req_from_oam->module_id == RRM_MODULE_ID) ||
            (p_in_set_log_level_req_from_oam->module_id == RRM_ZERO))
    {
        OutLogEnDisReqToCellM.transaction_id = trans_id;
        switch(p_in_set_log_level_req_from_oam->log_config.log_on_off)
        {
            case RRM_OAM_LOG_ON:
                OutLogEnDisReqToCellM.log_on_off = RRM_OAM_LOG_ON;
                break;

            case RRM_OAM_LOG_OFF:
                OutLogEnDisReqToCellM.log_on_off = RRM_OAM_LOG_OFF;
                break;

            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                        RRM_WARNING, "Invalid Log command[%d] received, using ON as default", 
                        p_in_set_log_level_req_from_oam->log_config.log_on_off);
                /*coverity 16463, aditya, rel2.0.1*/
                OutLogEnDisReqToCellM.log_level = RRM_OAM_ERROR;
                break;
        }

        if (RRM_OAM_LOG_LEVEL_PRESENT == 
                (p_in_set_log_level_req_from_oam->log_config.bitmask&
                 RRM_OAM_LOG_LEVEL_PRESENT))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_LOG_LEVEL_PRESENT");

            switch(p_in_set_log_level_req_from_oam->log_config.log_level)
            {
                case RRM_OAM_CRITICAL:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_CRITICAL;
                    break;

                case RRM_OAM_ERROR:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_ERROR;
                    break;

                case RRM_OAM_WARNING:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_WARNING;
                    break;

                case RRM_OAM_INFO:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_INFO;
                    break;

                case RRM_OAM_BRIEF:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_BRIEF;
                    break;

                case RRM_OAM_DETAILED:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_DETAILED;
                    break;

                case RRM_OAM_DETAILEDALL:
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_DETAILEDALL;
                    break;

                default:
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                            RRM_WARNING, "Invalid Log Level[%d] received, using BRIEF as default",
                            p_in_set_log_level_req_from_oam->log_config.log_level);
                    OutLogEnDisReqToCellM.log_level = RRM_OAM_BRIEF;
                    break;
            }/*switch ends*/
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_LOG_LEVEL_PRESENTi not present");
            OutLogEnDisReqToCellM.log_level = RRM_OAM_NONE;
        }

        rrm_mif_send_internal_msg(RRM_OAM_CM_MODULE_ID,
                RRMCM_RMIF_LOG_ENABLE_DISABLE_REQ,
                sizeof(rrmcm_rmif_log_enable_disable_req_t),
                &OutLogEnDisReqToCellM);
    }

    if ((p_in_set_log_level_req_from_oam->module_id == RRM_OAM_UEM_MODULE_ID) ||
            (p_in_set_log_level_req_from_oam->module_id == RRM_MODULE_ID) ||
            (p_in_set_log_level_req_from_oam->module_id == RRM_ZERO))
    {
        OutLogEnDisReqToUeM.transaction_id = trans_id;
        switch(p_in_set_log_level_req_from_oam->log_config.log_on_off)
        {
            case RRM_OAM_LOG_ON:
                OutLogEnDisReqToUeM.log_on_off = RRM_UEM_LOG_ON;
                break;

            case RRM_OAM_LOG_OFF:
                OutLogEnDisReqToUeM.log_on_off = RRM_UEM_LOG_OFF;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                        RRM_WARNING, "Invalid Log command[%d] received, using ON as default",
                        p_in_set_log_level_req_from_oam->log_config.log_on_off);
                /*coverity 16464, aditya, rel2.0.1*/
                OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_ERROR;
                break;
        }

        if (RRM_OAM_LOG_LEVEL_PRESENT ==
                (p_in_set_log_level_req_from_oam->log_config.bitmask& 
                 RRM_OAM_LOG_LEVEL_PRESENT))
        {
            switch(p_in_set_log_level_req_from_oam->log_config.log_level)
            {
                case RRM_OAM_INFO:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_INFO;
                    break;

                case RRM_OAM_BRIEF:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_BRIEF;
                    break;

                case RRM_OAM_DETAILED:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_DETAILED;
                    break;

                case RRM_OAM_DETAILEDALL:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_DETAILEDALL;
                    break;

                case RRM_OAM_WARNING:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_WARNING;
                    break;

                case RRM_OAM_ERROR:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_ERROR;
                    break;

                case RRM_OAM_CRITICAL:
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_CRITICAL;
                    break;

                default:
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                            RRM_WARNING, "Invalid Log Level[%d] received , using BRIEF as default",
                            p_in_set_log_level_req_from_oam->log_config.log_level);
                    OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_BRIEF;
                    break;
            }/*switch ends*/
        }
        else
        {
            OutLogEnDisReqToUeM.log_level = RRM_UEM_LOG_LEVEL_NONE; 
        }

        rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
                RRMUEM_RMIF_LOG_ENABLE_DISABLE_REQ,
                sizeof(rrmuem_rmif_log_enable_disable_req_t),
                &OutLogEnDisReqToUeM);
    }
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : health_monitoring
 * Inputs         : thread id
 * Outputs        : None
 * Returns        : NULL
 * Description    : Used for updating the thread health status
 ****************************************************************************/

void *health_monitoring (void *p)
{
    lgr_thread_id_t thread_id = *((lgr_thread_id_t*)p);
    rrm_oam_set_status_for_health(thread_id);
    return RRM_NULL;
}


/****************************************************************************
 * Function Name  : build_and_send_init_config_request
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_in_cell_del_req_from_oam - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Init Config Request to CellM/UeM
 ****************************************************************************/
void build_and_send_init_config_request(rrm_mif_gb_context_t      *p_gl_ctxt,
        rrm_oam_init_config_req_t 
        *p_in_init_config_req_from_oam,
        U16                             trans_id)
{
    rrmcm_rmif_init_config_req_t   *p_out_init_config_req_to_cellm = RRM_PNULL;
    rrmuem_rmif_init_config_req_t  *p_out_init_config_req_to_uem = RRM_PNULL;
    U8                             moduleCount = 0;
    rrm_oam_log_on_off_et          log_on_off_val_from_oam ,
                                   log_on_off = RRM_OAM_LOG_ON; 
    rrm_oam_log_level_et           log_level_from_oam ,
                                   log_level = RRM_OAM_BRIEF;  

    /* Spr 16211 Changes Start*/
    rrm_bool_et                    rim_enable_disable = RRM_FALSE; 
    /* Spr 16211 Changes End*/
    /* CHANGES_FRM_XML_TO_CFG START */
#ifdef RRM_IN_MEM_LOGGER
    lgr_thread_id_t             i = RRM_ZERO;
    lgr_shm_logging_config_t    thrd_cfg[RRM_MAX_THREADS];
    lgr_thread_id_t             *p_cbk_arg = RRM_PNULL;
    rrm_logger_init_cfg_t       lgr_cfg;
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    U32                         shm_size = RRM_ZERO;
    U32                         log_file_sz = RRM_ZERO;
    U16                         log_chunk_cnt = RRM_ZERO;
    lgr_file_seq_num_t          file_cnt = RRM_ZERO;
    U8                          log_path[RRM_MAX_LOG_PATH_STR_LEN];

#endif
    /* CHANGES_FRM_XML_TO_CFG END */
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_in_init_config_req_from_oam);

    /* CHANGES_FRM_XML_TO_CFG START */
#ifdef RRM_IN_MEM_LOGGER
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    RRM_STRNCPY(thrd_cfg[RRM_ZERO].thread_name, "rrm_main", LGR_MAX_THREAD_NAME_LEN);
    thrd_cfg[RRM_ZERO].thread_name[LGR_MAX_THREAD_NAME_LEN - 1] = '\0';
    RRM_STRNCPY(thrd_cfg[RRM_ONE].thread_name, "rrm_logger", LGR_MAX_THREAD_NAME_LEN);
    thrd_cfg[RRM_ONE].thread_name[LGR_MAX_THREAD_NAME_LEN - 1] = '\0';

    RRM_STRNCPY(thrd_cfg[RRM_ZERO].lgr_region_name, "RRM_MAIN", LGR_MAX_REGION_NAME_LEN);
    thrd_cfg[RRM_ZERO].lgr_region_name[LGR_MAX_REGION_NAME_LEN - 1] = '\0';
    RRM_STRNCPY(thrd_cfg[RRM_ONE].lgr_region_name, "RRM_LOGGER", LGR_MAX_REGION_NAME_LEN);
    thrd_cfg[RRM_ONE].lgr_region_name[LGR_MAX_REGION_NAME_LEN - 1] = '\0';

    p_cbk_arg = (lgr_thread_id_t*)rrm_mem_get(sizeof(lgr_thread_id_t));
    if ( p_cbk_arg == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_cbk_arg failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    *p_cbk_arg = RRM_ONE;

    if(p_in_init_config_req_from_oam->bitmask & RRM_OAM_SHM_LOGGING_INFO_PRESENT)
    {
        shm_size = p_in_init_config_req_from_oam->rrm_shm_log_config.shm_size;
        log_file_sz = p_in_init_config_req_from_oam->rrm_shm_log_config.log_file_sz;
        log_chunk_cnt = p_in_init_config_req_from_oam->rrm_shm_log_config.log_chunk_cnt;
        file_cnt = p_in_init_config_req_from_oam->rrm_shm_log_config.file_cnt;

        RRM_MEMCPY( log_path, p_in_init_config_req_from_oam->rrm_shm_log_config.log_path, 
                RRM_STRLEN(p_in_init_config_req_from_oam->rrm_shm_log_config.log_path));

        log_path[RRM_STRLEN(p_in_init_config_req_from_oam->rrm_shm_log_config.log_path)] = RRM_ZERO;

        lgr_cfg.cpu_bitmap = p_in_init_config_req_from_oam->rrm_shm_log_config.cpu_bitmap;
        lgr_cfg.wait_interval = p_in_init_config_req_from_oam->rrm_shm_log_config.wait_interval;
    }
    else
    {
        /* SPR 20653 Fix Start */
        shm_size = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_SHM_SIZE;
        log_file_sz = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_FILE_SIZE;
        log_chunk_cnt = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_CHUNK_CNT;
        file_cnt = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_FILE_CNT;

        RRM_MEMCPY( log_path, RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_PATH, 
                RRM_STRLEN(RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_PATH)); 

        log_path[RRM_STRLEN(RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_PATH)] = RRM_ZERO;

        lgr_cfg.cpu_bitmap = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_CPU_BITMAP;
        lgr_cfg.wait_interval = RRM_DEFINED_DEFAULT_VALUE_FOR_LOG_WAIT_INTERVAL;
        /* SPR 20653 Fix End */

    }

    for (i = RRM_ZERO; i < RRM_MAX_THREADS; i++)
    {
        thrd_cfg[i].p_call_back = (call_back_pointer)health_monitoring;
        thrd_cfg[i].p_cbk_arg = p_cbk_arg;
        thrd_cfg[i].shm_size = shm_size;
        thrd_cfg[i].log_file_sz = log_file_sz;
        thrd_cfg[i].log_chunk_cnt = log_chunk_cnt;
        thrd_cfg[i].file_cnt = file_cnt;
    }

    if (LGR_SUCCESS != lgr_in_mem_logging_init(RRM_MAX_THREADS,
                thrd_cfg,
                (char*)log_path))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Failed to Initialize IN-MEMORY Logging configuration");
        rrm_abort ();
    }

    if( RRM_FAILURE == rrm_mif_send_internal_msg (RRM_LOGGER_MODULE_ID,
                RMIF_LOGGER_INIT_IND, 
                sizeof(lgr_cfg), 
                &lgr_cfg) )
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "failed to send to MIF RMIF_LOGGER_INIT_IND");
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Sent to MIF RMIF_LOGGER_INIT_IND");
    }
#endif

    /* Spr 16211 Changes Start*/
    if(p_in_init_config_req_from_oam->bitmask & RRM_OAM_RIM_CONFIG_INFO_PRESENT)
    {
        rim_enable_disable = p_in_init_config_req_from_oam->
            rrm_rim_config.rim_enable_disable;  
    }
    /* Spr 16211 Changes End*/
    /* CHANGES_FRM_XML_TO_CFG END */
    if (!(p_in_init_config_req_from_oam->bitmask & 
                RRM_OAM_MODULE_INIT_CONFIG_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Bitmask RRM_OAM_MODULE_INIT_CONFIG_PRESENT not present");

        /* Preparing Init Config Req for  Cell M */
        p_out_init_config_req_to_cellm = 
            rrm_mem_get(sizeof(rrmcm_rmif_init_config_req_t));
        if ( p_out_init_config_req_to_cellm == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_out_init_config_req_to_cellm failed" );
            RRM_UT_TRACE_EXIT();
            return ;
        }
        /*CID 97140 Start*/ 
        RRM_MEMSET(p_out_init_config_req_to_cellm,0,sizeof(rrmcm_rmif_init_config_req_t));
        /*CID 97140 End*/
        p_out_init_config_req_to_cellm->transaction_id = trans_id;

        p_out_init_config_req_to_cellm->log_on_off = RRM_OAM_LOG_ON;
        p_out_init_config_req_to_cellm->log_level = RRM_OAM_BRIEF;
        /* Spr 16211 Changes Start*/
        p_out_init_config_req_to_cellm->rim_enable_disable = rim_enable_disable;
        p_out_init_config_req_to_cellm->bitmask |= RRMCM_RMIF_INIT_RIM_INFO_PRESENT;
        /* Spr 16211 Changes End*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, " Sending Init Config Request to %d", 
                RRM_OAM_CM_MODULE_ID);
        /* Sending Init Config Request to CellM */
        rrm_mif_send_internal_msg(RRM_OAM_CM_MODULE_ID,
                RRMCM_RMIF_INIT_CONFIG_REQ,
                sizeof(rrmcm_rmif_init_config_req_t),
                p_out_init_config_req_to_cellm);
        RRM_MEM_FREE(p_out_init_config_req_to_cellm);

        /* Preparing Init Config Req for  UE M */
        p_out_init_config_req_to_uem = 
            rrm_mem_get(sizeof(rrmuem_rmif_init_config_req_t));
        if ( p_out_init_config_req_to_uem == RRM_PNULL)
        {
            RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                    "Memory allocation to p_out_init_config_req_to_uem failed" );
            RRM_MEM_FREE(p_out_init_config_req_to_cellm);
            RRM_UT_TRACE_EXIT();
            return ;
        }

        p_out_init_config_req_to_uem->transaction_id = trans_id;
        /* coverity : CID 16485*/
        p_out_init_config_req_to_uem->log_on_off = RRM_UEM_LOG_ON;
        /* coverity : CID 16484*/
        p_out_init_config_req_to_uem->log_level = RRM_UEM_LOG_LEVEL_BRIEF;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, " Sending Init Config Request to %d", 
                RRM_OAM_UEM_MODULE_ID);
        /* Sending Init Config Request to UeM */
        rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
                RRMUEM_RMIF_INIT_CONFIG_REQ,
                sizeof(rrmuem_rmif_init_config_req_t),
                p_out_init_config_req_to_uem);
        RRM_MEM_FREE(p_out_init_config_req_to_uem);

        /* Setting  Log Levels for MIF */
        log_on_off = RRM_OAM_LOG_ON;
        log_level = RRM_OAM_BRIEF;
        rrm_mif_log_enable_disable_cmd(p_gl_ctxt, log_on_off, log_level);
    }
    else
    {

        for (moduleCount = 0; moduleCount < RRM_MAX_NO_INT_MODULES; moduleCount++)
        {
            log_level_from_oam = p_in_init_config_req_from_oam->init_module_config[moduleCount].log_config.log_level;
            log_on_off_val_from_oam = p_in_init_config_req_from_oam->init_module_config[moduleCount].log_config.log_on_off;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Module Id(%d)", 
                    p_in_init_config_req_from_oam->
                    init_module_config[moduleCount].module_id);
            if (p_in_init_config_req_from_oam->
                    init_module_config[moduleCount].module_id == 
                    RRM_OAM_CM_MODULE_ID)
            {
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                /* Spr 16211 Changes Start*/
                build_and_send_init_config_req_to_cellm(log_level_from_oam , log_on_off_val_from_oam , trans_id ,rim_enable_disable);
                /* Spr 16211 Changes End*/
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            }
            else if (p_in_init_config_req_from_oam->
                    init_module_config[moduleCount].module_id == 
                    RRM_OAM_UEM_MODULE_ID)
            {
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                build_and_send_init_config_req_to_uem(log_level_from_oam , log_on_off_val_from_oam , trans_id);
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            }
            else if (p_in_init_config_req_from_oam->
                    init_module_config[moduleCount].module_id == 
                    RRM_OAM_MIF_MODULE_ID)
            {
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                build_and_send_init_config_req_to_mif(p_gl_ctxt,log_level_from_oam, log_on_off_val_from_oam);
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Incorrect Module Id %d",
                        p_in_init_config_req_from_oam->
                        init_module_config[moduleCount].module_id );
            }
        }
    }

    p_gl_ctxt->current_state = RMIF_STATE_INIT_CONFIG_ONGOING;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, "State %d", p_gl_ctxt->current_state);

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : build_and_send_non_registration_based_resp_to_son
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_rmif_generic_resp - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Generic Response to SON
 ****************************************************************************/
void build_and_send_non_registration_based_resp_to_son(rrm_mif_gb_context_t 
        *p_gl_ctxt,
        rrm_mif_context    *p_mif_context,
        rrmcm_rmif_generic_resp_t
        *p_rmif_generic_resp,
        U16        apiId)
{
    rrm_son_non_registration_based_res_t  *p_out_son_non_registration_based_resp = RRM_PNULL;
    rrm_son_cell_switch_on_res_t          *p_out_son_cell_switch_on_resp = RRM_PNULL;
    rrm_son_cell_switch_off_res_t         *p_out_son_cell_switch_off_resp = RRM_PNULL;
    rrm_son_meas_config_res_t             *p_out_son_meas_config_resp = RRM_PNULL;
    rrm_son_meas_config_obj_remove_res_t  *p_out_son_meas_config_obj_remove_resp = RRM_PNULL;
    U8                                     mif_ctxt_cnt = 0;
    U16                                    src_id = 0;
    U16                                    trans_id = 0;
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_rmif_generic_resp);

    RRM_UT_TRACE_ENTER();
    switch(apiId)
    {
        /* UE MEAS CHANGES : STARTS */  
        case RRM_SON_MEAS_CONFIG_RESP:
            {
                p_out_son_meas_config_resp = (rrm_son_meas_config_res_t *)
                    rrm_mem_get(sizeof(rrm_son_meas_config_res_t));
                if ( p_out_son_meas_config_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_out_son_meas_config_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return ;
                }
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                        "Mif Context %d matched for cell Idx[%u]", p_mif_context->mif_ctxt_id,
                        p_mif_context->cell_index);

                rrm_memset_rrm_son_meas_config_res(p_out_son_meas_config_resp, RRM_ZERO);
                p_out_son_non_registration_based_resp = 
                    &(p_out_son_meas_config_resp->meas_config_res);
                break;
            }    
        case RRM_SON_MEAS_CONFIG_OBJ_REMOVE_RESP:
            {
                p_out_son_meas_config_obj_remove_resp = (rrm_son_meas_config_obj_remove_res_t *)
                    rrm_mem_get(sizeof(rrm_son_meas_config_obj_remove_res_t));
                if ( p_out_son_meas_config_obj_remove_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_out_son_meas_config_obj_remove_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return ;
                }

                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "Mif Context %d matched for cell Idx[%u]", p_mif_context->mif_ctxt_id,
                        p_mif_context->cell_index);

                RRM_MEMSET(p_out_son_meas_config_obj_remove_resp, RRM_NULL,
                        sizeof(rrm_son_meas_config_obj_remove_res_t));
                p_out_son_non_registration_based_resp =
                    &(p_out_son_meas_config_obj_remove_resp->meas_config_obj_remove_res);
                break;
            }
            /* UE MEAS CHANGES : ENDS */  
        case RRM_SON_CELL_SWITCH_ON_RESP:
            {
                p_out_son_cell_switch_on_resp = (rrm_son_cell_switch_on_res_t *)
                    rrm_mem_get(sizeof(rrm_son_cell_switch_on_res_t));
                if ( p_out_son_cell_switch_on_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_out_son_cell_switch_on_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return ;
                }

                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                        "Mif Context %d matched for cell Idx[%u]", p_mif_context->mif_ctxt_id,
                        p_mif_context->cell_index);
                p_out_son_non_registration_based_resp = &(p_out_son_cell_switch_on_resp->cell_switchon_res);
                break;
            }    
        case RRM_SON_CELL_SWITCH_OFF_RESP:
            {
                p_out_son_cell_switch_off_resp = (rrm_son_cell_switch_off_res_t *)
                    rrm_mem_get(sizeof(rrm_son_cell_switch_off_res_t));
                if ( p_out_son_cell_switch_off_resp == RRM_PNULL)
                {
                    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                            "Memory allocation to p_out_son_cell_switch_off_resp failed" );
                    RRM_UT_TRACE_EXIT();
                    return ;
                }

                p_out_son_non_registration_based_resp = &(p_out_son_cell_switch_off_resp->cell_switchoff_res);
                break;
            }    
        default:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                        RRM_ERROR, "Invalid apiId[%d]", apiId);
                break;
            }
    }

    if (RRM_PNULL != p_out_son_non_registration_based_resp)
    {
        for (mif_ctxt_cnt = 0;
                mif_ctxt_cnt < MAX_NUM_MIF_CTXT;
                mif_ctxt_cnt++)
        {
            if ((RRM_TRUE == p_gl_ctxt->map_info[mif_ctxt_cnt].is_info_valid) &&
                    (p_gl_ctxt->map_info[mif_ctxt_cnt].mif_ctxt_id ==
                     p_mif_context->mif_ctxt_id))
            {
                rrm_memcpy_rrm_oam_eutran_global_cell_id(
                        &(p_out_son_non_registration_based_resp->cell_id),
                        &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id)); 


                if (RRM_SUCCESS == p_rmif_generic_resp->response)
                {
                    p_out_son_non_registration_based_resp->result = RRM_SUCCESS;
                    p_out_son_non_registration_based_resp->error_code = RRM_NO_ERROR;
                }
                else
                {
                    p_out_son_non_registration_based_resp->result = RRM_FAILURE;
                    p_out_son_non_registration_based_resp->error_code = p_rmif_generic_resp->fail_cause;
                }
                break;
            }
        }
    }


    /* UE MEAS CHANGES : STARTS */
    if(RRM_PNULL != p_mif_context)
    {

        /* Kshitij_start CID: 11470 */
        /*SPR 15993 Fix Start*/
        if(RRM_ZERO == (src_id = return_src_id_from_tcb(p_mif_context, 
                        p_rmif_generic_resp->transaction_id)))
            /*SPR 15993 Fix End*/
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                    "Msg return_src_id_from_tcb Failed");    
            ret_val = RRM_FAILURE; 
        }
        /* Kshitij_end */
        trans_id = p_mif_context->currently_processed_api_trans_d;
    }
    else
    {
        src_id   = RRM_SON_ANR_MODULE_ID;
        trans_id = p_rmif_generic_resp->transaction_id;
    }
    /* UE MEAS CHANGES : ENDS */

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "MIF FSM: Source of Cell Swicth On = 0x%x", src_id);
    /* Sending Set Attribute request to SON*/
    switch(apiId)
    {
        case RRM_SON_CELL_SWITCH_ON_RESP:
            {
                rrm_son_send_rrm_son_cell_switch_on_res(
                        p_out_son_cell_switch_on_resp,
                        RRM_MIF_MODULE_ID,
                        src_id,
                        trans_id,
                        p_rmif_generic_resp->cellindex);

                RRM_MEM_FREE(p_out_son_cell_switch_on_resp);
                break;
            }
        case RRM_SON_CELL_SWITCH_OFF_RESP:
            {
                rrm_son_send_rrm_son_cell_switch_off_res(
                        p_out_son_cell_switch_off_resp,
                        RRM_MIF_MODULE_ID,
                        src_id,
                        trans_id,
                        p_rmif_generic_resp->cellindex);

                RRM_MEM_FREE(p_out_son_cell_switch_off_resp);
                break;
            }

            /* UE MEAS CHANGES : STARTS */  
        case RRM_SON_MEAS_CONFIG_RESP:
            {
                rrm_son_send_rrm_son_meas_config_res(
                        p_out_son_meas_config_resp,
                        RRM_MIF_MODULE_ID,
                        src_id,
                        trans_id,
                        p_rmif_generic_resp->cellindex);

                RRM_MEM_FREE(p_out_son_meas_config_resp);
                break;
                /* UE MEAS CHANGES : ENDS */  
            }
        case RRM_SON_MEAS_CONFIG_OBJ_REMOVE_RESP:
            {
                rrm_son_send_rrm_son_meas_config_obj_remove_res(
                        p_out_son_meas_config_obj_remove_resp,
                        RRM_MIF_MODULE_ID,
                        src_id,
                        trans_id,
                        p_rmif_generic_resp->cellindex);

                RRM_MEM_FREE(p_out_son_meas_config_obj_remove_resp);
                break;
            }
        default:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Invalid apiId[%d]", apiId);
                break;
            }
    }
    if (RRM_PNULL != p_mif_context)
    {
        /* De- allocated TCB */
        ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
                /*SPR 15993 Fix Start*/
                p_rmif_generic_resp->transaction_id);
        /*SPR 15993 Fix End*/
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF: TCB De-Allocation Failed");
        }
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_registration_based_resp_to_son
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_rmif_generic_resp - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Generic Response to SON
 ****************************************************************************/
void build_and_send_registration_based_resp_to_son(rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context              *p_mif_context, 
        rrmcm_rmif_generic_resp_t *p_rmif_generic_resp,
        U16                        api_id)
{
    rrm_son_registration_based_res_t      out_son_registration_based_resp;
    rrm_son_set_attr_res_t                set_attr_resp_to_son;
    rrm_son_registration_res_t            reg_resp_to_son;
    rrm_son_deregistration_res_t          dereg_resp_to_son;
    U8                                    mif_ctxt_cnt = 0;
    rrm_attr_id_et                        resp_attr_id = RRM_ATTR_UNDEF;
    U16                                   src_id = 0;
    rrm_return_et                         ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_rmif_generic_resp);

    rrm_memset_rrm_son_registration_based_res(&out_son_registration_based_resp, RRM_ZERO);
    rrm_memset_rrm_son_set_attr_res(&set_attr_resp_to_son, RRM_ZERO);
    rrm_memset_rrm_son_registration_res(&reg_resp_to_son, RRM_ZERO);
    rrm_memset_rrm_son_deregistration_res(&dereg_resp_to_son, RRM_ZERO);

    if (RRM_PNULL != p_mif_context)
    {
        for (mif_ctxt_cnt = 0;
                mif_ctxt_cnt < MAX_NUM_MIF_CTXT;
                mif_ctxt_cnt++)
        {
            if(p_gl_ctxt->map_info[mif_ctxt_cnt].mif_ctxt_id ==
                    p_mif_context->mif_ctxt_id)
            {
                rrm_memcpy_rrm_oam_eutran_global_cell_id(
                        &(out_son_registration_based_resp.id.object_id.cell_id),
                        &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id));
                break;
            }
        }
        resp_attr_id = p_mif_context->id;
        if (RRM_SUCCESS == p_rmif_generic_resp->response)
        {
            out_son_registration_based_resp.result = RRM_SUCCESS;
            out_son_registration_based_resp.error_code = RRM_NO_ERROR;
        }
        else
        {
            out_son_registration_based_resp.result = RRM_FAILURE;
            out_son_registration_based_resp.error_code = p_rmif_generic_resp->fail_cause;
        }
        /* Kshitij Coverity, CID 11471 */
        /*SPR 15993 Fix Start*/
        if(RRM_ZERO == (src_id = return_src_id_from_tcb(p_mif_context, 
                        p_rmif_generic_resp->transaction_id)))
            /*SPR 15993 Fix End*/
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Msg return_src_id_from_tcb Failed");
        }
        /* Kshitij end */
        /*CID 87060 Start*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_BRIEF, 
                "Error Code %d", 
                out_son_registration_based_resp.error_code);

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_BRIEF, 
                "MIF FSM: Source of Cell Reg/De-Reg/Set-Attr = 0x%x", src_id);
        switch(api_id)
        {
            case RRMCM_RMIF_CELL_REGISTER_RESP:
                {
                    rrm_memcpy_rrm_son_registration_based_res(
                            &reg_resp_to_son.registration_resp,
                            &out_son_registration_based_resp);

                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                            RRM_BRIEF, 
                            "Sending Register Resp for API:%d",api_id);
                    /* Sending Registration resp to SON*/
                    rrm_son_send_rrm_son_registration_res(
                            &reg_resp_to_son,
                            RRM_MIF_MODULE_ID,
                            src_id,
                            /*SPR 15993 Fix Start*/
                            p_mif_context->currently_processed_api_trans_d,
                            /*SPR 15993 Fix End*/
                            p_rmif_generic_resp->cellindex);
                    break;
                }
            case RRMCM_RMIF_CELL_DEREGISTER_RESP:
                {
                    rrm_memcpy_rrm_son_registration_based_res(
                            &dereg_resp_to_son.deregistration_resp,
                            &out_son_registration_based_resp);
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                            RRM_BRIEF, 
                            "Sending Register Resp for API:%d",api_id);

                    /* Sending De- Regeister Resp to SON*/
                    rrm_son_send_rrm_son_deregistration_res(
                            &dereg_resp_to_son,
                            RRM_MIF_MODULE_ID,
                            src_id,
                            /*SPR 15993 Fix Start*/
                            p_mif_context->currently_processed_api_trans_d,
                            /*SPR 15993 Fix End*/
                            p_rmif_generic_resp->cellindex);
                    break;
                }
            case RRMCM_RMIF_CELL_SET_ATTRIBUTE_RESP:
                {
                    set_attr_resp_to_son.id = resp_attr_id;
                    rrm_memcpy_rrm_son_registration_based_res(
                            &set_attr_resp_to_son.set_attr_resp,
                            &out_son_registration_based_resp);
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                            RRM_BRIEF, 
                            "Sending Set Attr Resp for API:%d",api_id);

                    /* Sending Set Attribute request to SON*/
                    rrm_son_send_rrm_son_set_attr_res(
                            &set_attr_resp_to_son,
                            RRM_MIF_MODULE_ID,
                            src_id,
                            /*SPR 15993 Fix Start*/
                            p_mif_context->currently_processed_api_trans_d,
                            p_rmif_generic_resp->cellindex);
                    /*SPR 15993 Fix End */
                    break;
                }
            default:
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Invalid apiId[%d]", api_id);
                    break;
                }
        }

        /* De- allocated TCB */
        ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
                /*SPR 15993 Fix Start*/
                p_rmif_generic_resp->transaction_id);
        /*SPR 15993 Fix End*/
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF: TCB De-Allocation Failed");
        }
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_ERROR, 
                "Mif Context not found for Cell Id %d ", 
                p_rmif_generic_resp->cellindex);
        /* Coverity CID 108962 Start */
        /* Code Removed */
        /* Coverity CID 108962 End */
        /* Coverity 108963 Fix Start */ 
         /* Code Removed */
        /* Coverity 108963 Fix End */
    }
    /*CID 87060 Stop*/
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_config_resp_to_oam 
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_config_resp_to_oam(rrm_mif_gb_context_t          *p_gl_ctxt,
        rrm_mif_context               *p_mif_context,
        rrmcm_rmif_cell_config_resp   *p_in_resp_from_cellm,
        rrm_oam_cell_config_resp_t    *p_out_response_to_oam)
{
    /*SPR 15993 Fix Start*/
    /* Code Deleted */
    /*SPR 15993 Fix End*/
    rrm_return_et        ret_val = RRM_SUCCESS;
    /* Coverity_ID : 16486 */
    rrm_cell_setup_fail_cause_et cell_setup_fail_cause = RRM_EVENT_NO_ERROR;
    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    rrm_memcpy_rrm_oam_eutran_global_cell_id(
            &(p_out_response_to_oam->global_cell_id),
            &(p_in_resp_from_cellm->global_cell_id));

    /*SPR 15993 Fix Start*/
    /* Code Deleted */
    /*SPR 15993 Fix End*/

    if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;

#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_S);
#endif        

        /* De- allocated TCB */
        ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
                /*SPR 15993 Fix Start*/
                p_in_resp_from_cellm->transaction_id);
        /*SPR 15993 Fix End*/
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF FSM: TCB De-Allocation Failed");
        }

        /*Valgrind fix */ 
        rrm_mif_fsm_set_state(p_mif_context, MIF_FSM_STATE_W_FOR_CELL_CONFIG_RESP,
                MIF_FSM_STATE_ACTIVE);
    }
    /*DYNAMIC ICIC CHANGES START*/
    else if(RRM_PARTIAL_SUCCESS == p_in_resp_from_cellm->response)
    {
        p_out_response_to_oam->response = RRM_PARTIAL_SUCCESS;
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;

#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_config_resp_S);
#endif        

        /* De- allocated TCB */
        ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
                /*SPR 15993 Fix Start*/
                p_in_resp_from_cellm->transaction_id);
        /*SPR 15993 Fix End*/
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF FSM: TCB De-Allocation Failed");
        }

        /*Valgrind fix */ 
        rrm_mif_fsm_set_state(p_mif_context, MIF_FSM_STATE_W_FOR_CELL_CONFIG_RESP,
                MIF_FSM_STATE_ACTIVE);
    }
    /*DYNAMIC ICIC CHANGES END*/
    else
    {
        p_out_response_to_oam->response = RRM_FAILURE;
        /* Coverity_ID : 16486 */
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;
        /* De- allocated TCB */
        ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
                /*SPR 15993 Fix Start*/
                p_in_resp_from_cellm->transaction_id);
        /*SPR 15993 Fix End*/
        if(RRM_FAILURE == ret_val)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF FSM: TCB De-Allocation Failed");
        }

        /* SPR 21496 Fix Start */
        /* Code Removed */
        /* SPR 21496 Fix End */

        /* Coverity_ID : 16486 start */
        switch (p_in_resp_from_cellm->fail_cause)
        {
            case RRM_NO_ERROR:
                cell_setup_fail_cause = RRM_EVENT_NO_ERROR;
                break;
            case RRM_ERR_SYS_CPU_OVERLOAD:
                cell_setup_fail_cause = RRM_EVENT_CELL_SETUP_REJ_INVALID_PARAMS;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "Invalid fail cause[%d] received, Assigning RRM_EVENT_NO_ERROR by default",
                        p_in_resp_from_cellm->fail_cause);
        }
        /* Coverity_ID : 16486 end */
        /* Raise Event - RRM_EVENT_LOCAL_CELL_SETUP_REJECT START*/
        rrm_raise_event_cell_setup_reject(cell_setup_fail_cause);/* Coverity_ID : 16486 */
        /* Raise Event - RRM_EVENT_LOCAL_CELL_SETUP_REJECT END*/
    }
    rrm_oam_send_rrm_oam_cell_config_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            /*SPR 15993 Fix Start*/
            p_mif_context->currently_processed_api_trans_d ,
            /*SPR 15993 Fix End*/
            /* SPR 20653 Fix Start */
            p_mif_context->cell_index); 
            /* SPR 20653 Fix End */
    /* SPR 21496 Fix Start */
        if (RRM_FAILURE == p_out_response_to_oam->response)
        {
            rrm_dealloc_mif_context(p_mif_context, p_gl_ctxt);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
                    "MIF FSM: MIF Context De-Allocated");
        }
        /* SPR 21496 Fix End */
}

/****************************************************************************
 * Function Name  : build_and_send_reconfig_resp_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_reconfig_resp_to_oam(rrm_mif_gb_context_t       *p_gl_ctxt,
        rrm_mif_context              *p_mif_context,
        rrmcm_rmif_generic_resp_t    *p_in_resp_from_cellm,
        rrm_oam_cell_reconfig_resp_t *p_out_response_to_oam)
{
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(p_out_response_to_oam->global_cell_id),
            p_in_resp_from_cellm->cellindex);

    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Incorrect Mif Context for Cell Id %d ", p_in_resp_from_cellm->cellindex);
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = RRM_ERR_CELL_UNCONFIGURED;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_F_cell_unconfig); 
#endif        
    }
    else if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_S);
#endif        
    }
    /*DYNAMIC ICIC CHANGES START*/
    else if (RRM_PARTIAL_SUCCESS == p_in_resp_from_cellm->response)
    {
        /* coverity : CID 41565 */
        p_out_response_to_oam->response = RRM_PARTIAL_SUCCESS;
        p_out_response_to_oam->fail_cause =  (rrm_error_et) p_in_resp_from_cellm->fail_cause;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_reconfig_resp_S);
#endif        
    }
    /*DYNAMIC ICIC CHANGES END*/
    else
    {
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;
    }
    rrm_oam_send_rrm_oam_cell_reconfig_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            p_mif_context->currently_processed_api_trans_d,
            p_mif_context->cell_index);
    /* BUG_11576_FIX_START */
    /* De- allocated TCB */
    ret_val = de_allocate_tcb_from_mif_ctxt(p_mif_context,
            /*SPR 15993 Fix Start*/
            p_in_resp_from_cellm->transaction_id);
    /*SPR 15993 Fix End*/
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "MIF FSM: TCB De-Allocation Failed");
    }
    /* BUG_11576_FIX_END */
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_del_resp_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_del_resp_to_oam(rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_generic_resp_t   *p_in_resp_from_cellm,
        rrm_oam_delete_resp_t            *p_out_response_to_oam)
{
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(p_out_response_to_oam->global_cell_id),
            p_in_resp_from_cellm->cellindex);

    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Incorrect Mif Context for Cell Id %d ", p_in_resp_from_cellm->cellindex);
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_ERR_CELL_UNCONFIGURED;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F_cell_unonfig);
#endif        
    }
    else if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_S);
#endif        
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;
    }
    else
    {
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_delete_resp_F);
#endif        
    }
    rrm_oam_send_rrm_oam_delete_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            p_mif_context->currently_processed_api_trans_d,
            p_mif_context->cell_index);
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : build_and_send_start_resp_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_start_resp_to_oam(rrm_mif_gb_context_t         *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_generic_resp_t   *p_in_resp_from_cellm,
        rrm_oam_cell_start_resp_t   *p_out_response_to_oam)
{
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(p_out_response_to_oam->global_cell_id),
            p_in_resp_from_cellm->cellindex);

    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Incorrect Mif Context for Cell Id %d ", p_in_resp_from_cellm->cellindex);
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_ERR_CELL_UNCONFIGURED;
    }
    else if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_start_resp_S);
#endif        
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;
    }
    else
    {
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;
    }
    rrm_oam_send_rrm_oam_cell_start_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            p_mif_context->currently_processed_api_trans_d,
            p_mif_context->cell_index);
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_stop_resp_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_ut_cell_start_req_to_cellm - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
void build_and_send_stop_resp_to_oam(rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_generic_resp_t   *p_in_resp_from_cellm,
        rrm_oam_cell_stop_resp_t   *p_out_response_to_oam)
{
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(p_out_response_to_oam->global_cell_id),
            p_in_resp_from_cellm->cellindex);

    if (RRM_FAILURE == ret_val)
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_stop_resp_F);
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_stop_resp_F_cell_unonfig);
#endif        
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Incorrect Mif Context for Cell Id %d ", p_in_resp_from_cellm->cellindex);
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = RRM_ERR_CELL_UNCONFIGURED;
    }
    else if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_stop_resp_S);
#endif        
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;
    }
    else
    {
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.cell_stop_resp_F);
#endif        
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = p_in_resp_from_cellm->fail_cause;
    }
    rrm_oam_send_rrm_oam_cell_stop_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            p_mif_context->currently_processed_api_trans_d,
            p_mif_context->cell_index);
    RRM_UT_TRACE_EXIT();
}

/*Cell update start*/
/****************************************************************************
 * Function Name  : build_and_send_update_resp_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_resp_from_cellm- It's not null pointer.
 *                  -p_out_response_to_oam - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function builds and sends update resp to OAM
 ****************************************************************************/
void build_and_send_update_resp_to_oam(
        rrm_mif_gb_context_t         *p_gl_ctxt,
        rrm_mif_context              *p_mif_context,
        rrmcm_rmif_generic_resp_t    *p_in_resp_from_cellm,
        rrm_oam_cell_update_resp_t   *p_out_response_to_oam)
{
    rrm_return_et                          ret_val = RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_response_to_oam);

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(p_out_response_to_oam->global_cell_id),
            p_in_resp_from_cellm->cellindex);

    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Incorrect Mif Context for Cell Id %d ", p_in_resp_from_cellm->cellindex);
        p_out_response_to_oam->response = RRM_FAILURE;
        p_out_response_to_oam->fail_cause = RRM_ERR_CELL_UNCONFIGURED;
    }
    else if (RRM_SUCCESS == p_in_resp_from_cellm->response)
    {
        p_out_response_to_oam->response = RRM_SUCCESS;
        p_out_response_to_oam->fail_cause = RRM_NO_ERROR;
    }
    else
    {
        p_out_response_to_oam->response = RRM_FAILURE;
        /* coverity : CID 16486*/
        p_out_response_to_oam->fail_cause = (rrm_error_et) p_in_resp_from_cellm->fail_cause;
    }
    rrm_oam_send_rrm_oam_cell_update_resp(
            p_out_response_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            p_mif_context->currently_processed_api_trans_d,
            p_mif_context->cell_index);
    RRM_UT_TRACE_EXIT();
}
/*Cell update end*/

/****************************************************************************
 * Function Name  :build_and_send_emerg_call_active_req_to_uem 
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_ergency_call_active_req- It's not null pointer.
 *                  -trans_id.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Start Request to CellM
 ****************************************************************************/
/*SPR 15993 Fix Start*/
void build_and_send_emerg_call_active_req_to_uem(rrm_mif_gb_context_t  *p_gl_ctxt,
        /*SPR 17777 +-*/
        rrm_mif_context             *p_mif_context,
        rrmuem_rmif_emergency_call_active_req_t
        *p_ergency_call_active_req,
        U16                        trans_id)
/*SPR 15993 Fix End*/
{

    RRM_UT_TRACE_ENTER();
    /*SPR 15993 Fix Start*/
    RRM_ASSERT (RRM_PNULL !=p_gl_ctxt);
    /*SPR 15993 Fix End*/
    RRM_ASSERT (RRM_PNULL !=p_mif_context);
    RRM_ASSERT (RRM_PNULL !=p_ergency_call_active_req);

    /*SPR 15993 Fix Start*/
    p_ergency_call_active_req->transaction_id = trans_id;
    /*SPR 15993 Fix End*/
    p_ergency_call_active_req->cell_index = p_mif_context->cell_index;

    /* Sending start request to UEM*/
    rrm_mif_send_internal_msg(RRM_UEM_MODULE_ID,
            RRMUEM_RMIF_EMERGENCY_CALL_ACTIVE_REQ,
            sizeof(rrmuem_rmif_emergency_call_active_req_t),
            (void *)p_ergency_call_active_req);
    RRM_UT_TRACE_EXIT();
}

/*************************************************************************
 * Functionn Name  : build_and_send_active_ue_count_ind_to_son
 * Inputs         : -p_mif_context - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -InCellConfigReqFromOam_p - It's not null pointer.
 *                  -OutCellConfigReqToCellM_p - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Config Request to CellM
 ****************************************************************************/
void build_and_send_active_ue_count_ind_to_son(
        rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_cell_active_ue_report_ind_t 
        *p_cell_active_ue_report_ind,
        U16    api_id)
{
    rrm_son_active_ue_cnt_report_t        *p_active_ue_count = RRM_PNULL;
    U8                                     mif_ctxt_cnt = 0;
    U8                                     mif_ctxt_id = 0;
    rrm_return_et                          ret_val = RRM_FAILURE;
    rrm_bool_et                            check_flag = RRM_FALSE;
    U16                                    dest_id = 0;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_cell_active_ue_report_ind);

    p_active_ue_count = (rrm_son_active_ue_cnt_report_t *)
        rrm_mem_get(sizeof(rrm_son_active_ue_cnt_report_t));
    if ( p_active_ue_count == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_active_ue_count failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    } 
    ret_val = fetch_mif_ctxt_id_based_on_cell_id(p_gl_ctxt, 
            p_cell_active_ue_report_ind->cellindex,
            &mif_ctxt_cnt,
            &mif_ctxt_id);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Incorrect Mif Context for Cell Id %d ", 
                p_cell_active_ue_report_ind->cellindex);
        check_flag = RRM_TRUE;
    }
    else
    {
        p_mif_context = rrm_find_mif_context(p_gl_ctxt, mif_ctxt_id);
        if (RRM_PNULL != p_mif_context)
        {
            rrm_memcpy_rrm_oam_eutran_global_cell_id(
                    &(p_active_ue_count->cell_id),
                    &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id));

            p_active_ue_count->ue_cnt = p_cell_active_ue_report_ind->ue_cnt;

            if (api_id == RRMCM_RMIF_CELL_ACTIVE_UE_COUNT_REPORT_FOR_ANR_IND)
            {
                dest_id = RRM_SON_ANR_MODULE_ID;
            }
            else if (api_id == RRMCM_RMIF_CELL_ACTIVE_UE_COUNT_REPORT_FOR_ES_IND)
            {
                dest_id = RRM_SON_ES_MODULE_ID;
            }
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "Destination Id = 0x%x", dest_id);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
                    "Sending Active UE Indi to SON");
            rrm_son_send_rrm_son_active_ue_cnt_report(
                    p_active_ue_count,
                    RRM_MIF_MODULE_ID,
                    dest_id,
                    (U16)MIF_INVALID_TRANS_ID,
                    p_mif_context->cell_index);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Mif Context is NULL");
            check_flag = RRM_TRUE;
        }
    }
    if (RRM_TRUE == check_flag)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Unable to Parse active_ue_count ind from Cell M");
    }
    RRM_MEM_FREE(p_active_ue_count);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_active_threashold_reached_indto_son
 * Inputs         : -p_gl_ctxt- It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -InCellConfigReqFromOam_p - It's not null pointer.
 *                  -OutCellConfigReqToCellM_p - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Config Request to CellM
 ****************************************************************************/
void build_and_send_active_threashold_reached_indto_son(
        rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrm_ue_count_threshold_reached_ind_t          
        *p_ue_cnt_threshold_ind,
        U16      api_id)
{
    rrm_ue_count_threshold_hit_ind_t      *p_count_threshold = RRM_PNULL;
    U8                                     mif_ctxt_cnt = 0;
    U8                                     mif_ctxt_id = 0;
    rrm_return_et                          ret_val = RRM_FAILURE;
    rrm_bool_et                            check_flag = RRM_FALSE;
    U16                                    dest_id = 0;


    RRM_UT_TRACE_ENTER();


    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_ue_cnt_threshold_ind);

    p_count_threshold = (rrm_ue_count_threshold_hit_ind_t *)
        rrm_mem_get(sizeof(rrm_ue_count_threshold_hit_ind_t));
    if ( p_count_threshold == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_count_threshold failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    ret_val = fetch_mif_ctxt_id_based_on_cell_id(p_gl_ctxt, 
            p_ue_cnt_threshold_ind->cellindex,
            &mif_ctxt_cnt,
            &mif_ctxt_id);
    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Incorrect Mif Context for Cell Id %d ", 
                p_ue_cnt_threshold_ind->cellindex);
        check_flag = RRM_TRUE;
    }
    else
    {
        p_mif_context = rrm_find_mif_context(p_gl_ctxt, mif_ctxt_id);
        if (RRM_PNULL != p_mif_context)
        {
            rrm_memcpy_rrm_oam_eutran_global_cell_id(
                    &(p_count_threshold->cell_id),
                    &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id));
            switch(p_ue_cnt_threshold_ind->cause)
            {
                case RRM_MIF_CELLM_THRESHOLD_CROSSED:
                    p_count_threshold->cause = RRM_BELOW_TO_ABOVE_THRESHOLD;
                    break;

                case RRM_MIF_CELLM_BELOW_TH:
                    p_count_threshold->cause = RRM_ABOVE_TO_BELOW_THRESHOLD;
                    break;
            }

            if (api_id == RRMCM_RMIF_CELL_ACTIVE_THRESHOLD_REACHED_REPORT_FOR_ANR_IND)
            {
                dest_id = RRM_SON_ANR_MODULE_ID;
            }
            else if (api_id == RRMCM_RMIF_CELL_ACTIVE_THRESHOLD_REACHED_REPORT_FOR_ES_IND)
            {
                dest_id = RRM_SON_ES_MODULE_ID;
            }
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "Destination Id = 0x%x", dest_id);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
                    "Sending UE Cnt Indi to SON");
            rrm_son_send_rrm_ue_count_threshold_hit_ind(
                    p_count_threshold,
                    RRM_MIF_MODULE_ID,
                    dest_id,
                    (U16)MIF_INVALID_TRANS_ID,
                    p_mif_context->cell_index);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                    "Mif Context is NULL");
            check_flag = RRM_TRUE;
        }
    }
    if (RRM_TRUE == check_flag)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                RRM_ERROR, 
                "Unable to Parse ue_count_threshold_hit_ind from Cell M");
    }

    RRM_MEM_FREE(p_count_threshold);

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name   build_and_send_cell_state_change_ind_to_son:
 * Inputs         : -p_gl_ctxt- It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -InCellConfigReqFromOam_p - It's not null pointer.
 *                  -OutCellConfigReqToCellM_p - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Cell Config Request to CellM
 ****************************************************************************/
void build_and_send_cell_state_change_ind_to_son(
        rrm_mif_gb_context_t  *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_cell_state_change_ind_t
        *p_cell_state_change_ind,
        U16                    api_id)
{

    rrm_son_cell_state_change_ind_t        cell_state_change;
    U8                                     mif_ctxt_cnt = 0;
    U8                                     mif_ctxt_id = 0;
    rrm_return_et                          ret_val = RRM_FAILURE;
    rrm_bool_et                            check_flag = RRM_FALSE;
    U16                                    dest_id = 0;


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_cell_state_change_ind);


    ret_val = fetch_mif_ctxt_id_based_on_cell_id(p_gl_ctxt, 
            p_cell_state_change_ind->cellindex,
            &mif_ctxt_cnt,
            &mif_ctxt_id);

    if (RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Incorrect Mif Context for Cell Id %d ", 
                p_cell_state_change_ind->cellindex);
        check_flag = RRM_TRUE;
    }
    else
    {
        p_mif_context = rrm_find_mif_context(p_gl_ctxt, mif_ctxt_id);
        if (RRM_PNULL != p_mif_context)
        {
            rrm_memcpy_rrm_oam_eutran_global_cell_id(
                    &(cell_state_change.cell_id),
                    &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id));

            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
            cell_state_change.cell_state = mif_rrm_cell_state_mapping(p_cell_state_change_ind->cell_state);
            cell_state_change.cell_state_change_cause = mif_rrm_cell_state_change_cause_mapping( p_cell_state_change_ind->cell_state_change_cause);
            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

            switch (api_id)
            {
                case RRMCM_RMIF_CELL_STATE_CHANGE_FOR_ANR_IND:
                    dest_id = RRM_SON_ANR_MODULE_ID;
                    break;

                case RRMCM_RMIF_CELL_STATE_CHANGE_FOR_ES_IND:
                    dest_id = RRM_SON_ES_MODULE_ID;
                    break;

                case RRMCM_RMIF_CELL_STATE_CHANGE_FOR_MLB_IND:
                    dest_id = RRM_SON_MLB_MODULE_ID;
                    break;

                case RRMCM_RMIF_CELL_STATE_CHANGE_FOR_MRO_IND:
                    dest_id = RRM_SON_MRO_MODULE_ID;
                    break;
                    /* RACH_OPTIMIZATION_CHANGES_START */
                case RRMCM_RMIF_CELL_STATE_CHANGE_FOR_RACH_OPTI:
                    dest_id = RRM_SON_RACH_OPT_MODULE_ID;
                    /*bug_12796_changes_start*/
                    break;
                    /*bug_12796_changes_end*/
                    /* RACH_OPTIMIZATION_CHANGES_END */
                default:
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                            "Invalid API [%u] for cell state change received", api_id);
                    RRM_UT_TRACE_EXIT();
                    return;
            }
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "Destination Id = 0x%x", dest_id);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "Send Cell State Chng Indi");

            rrm_son_send_rrm_son_cell_state_change_ind(
                    &cell_state_change,
                    RRM_MIF_MODULE_ID,
                    dest_id,
                    (U16)MIF_INVALID_TRANS_ID,
                    p_mif_context->cell_index);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, "Mif Context is NULL");
            check_flag = RRM_TRUE;
        }
    }
    if (RRM_TRUE == check_flag)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Unable to Parse cell_state_change ind from Cell M");
    }


    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_cell_plmn_info
 * Inputs         : - p_cell_plmn_info_to_cellm
 *                  - p_cell_plmn_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill PLMN info for CellM module.
 ****************************************************************************/
void fill_cell_plmn_info(rrm_cell_plmn_info_t     *p_cell_plmn_info_to_cellm,
        rrm_oam_cell_plmn_info_t *p_cell_plmn_info_from_oam)
{
    U16 mcc_count = RRM_ZERO;
    U16 mnc_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_cell_plmn_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_cell_plmn_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating PLMN Info");

    p_cell_plmn_info_to_cellm->bitmask = 0;

    /*mcc info*/ 
    for (mcc_count=0; mcc_count< MAX_MCC_DIGITS; mcc_count++ )
    {
        p_cell_plmn_info_to_cellm->mcc[mcc_count] = 
            p_cell_plmn_info_from_oam->mcc[mcc_count];
        p_cell_plmn_info_to_cellm->bitmask |= RRMCM_MCC_PRESENCE_BITMASK;
    }  

    /*mnc info*/
    p_cell_plmn_info_to_cellm->num_mnc_digit = p_cell_plmn_info_from_oam->num_mnc_digit;
    for (mnc_count=0; 
            ((mnc_count<p_cell_plmn_info_to_cellm->num_mnc_digit)&& 
             (mnc_count< MAX_MNC_DIGITS)); mnc_count++)
    {
        p_cell_plmn_info_to_cellm->mnc[mnc_count] = 
            p_cell_plmn_info_from_oam->mnc[mnc_count];  
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_plmn_info
 * Inputs         : - p_plmn_info_to_cellm
 *                  - p_plmn_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill PLMN info for CellM module.
 ****************************************************************************/
void fill_plmn_info(rrm_oam_cell_plmn_info_t     *p_cell_plmn_info_to_cellm,
        rrm_oam_cell_plmn_info_t     *p_cell_plmn_info_from_oam)
{
    U16 mcc_count = RRM_ZERO;
    U16 mnc_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_cell_plmn_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_cell_plmn_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
            "Populating PLMN Info");

    /*mcc info*/
    for (mcc_count=0; mcc_count< MAX_MCC_DIGITS; mcc_count++ )
    {
        p_cell_plmn_info_to_cellm->mcc[mcc_count] =
            p_cell_plmn_info_from_oam->mcc[mcc_count];
    }

    /*mnc info*/
    p_cell_plmn_info_to_cellm->num_mnc_digit = 
        p_cell_plmn_info_from_oam->num_mnc_digit;

    for (mnc_count=0;
            ((mnc_count<p_cell_plmn_info_to_cellm->num_mnc_digit) &&
             (mnc_count< MAX_MNC_DIGITS)); 
            mnc_count++)
    {
        p_cell_plmn_info_to_cellm->mnc[mnc_count] =
            p_cell_plmn_info_from_oam->mnc[mnc_count];
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_phy_layer_info_for_cell_reconfig
 * Inputs         : - p_phy_info_to_cellm
 *                  - p_phy_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Physical Layer info for CellM module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_phy_layer_info_for_cell_reconfig(
        rrm_physical_layer_params_t       *p_phy_info_to_cellm,
        rrm_oam_physical_layer_params_t   *p_phy_info_from_oam)
    /* SPR 20653 Fix End */
    /*SPR 17777 +-*/
{
    RRM_ASSERT (RRM_PNULL != p_phy_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_phy_info_from_oam); 

    RRM_UT_TRACE_ENTER();

    /* Inititalize bitmask */
    p_phy_info_to_cellm->bitmask = 0x00;

    /* Physiacal Layer Parameters */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating PHY Information");

    /*pdsch - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_pdsch.p_b =
            p_phy_info_from_oam->physical_layer_param_pdsch.p_b;
        p_phy_info_to_cellm->physical_layer_param_pdsch.p_a =
            p_phy_info_from_oam->physical_layer_param_pdsch.p_a;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT;
    }
    /*pdsch - end*/

    /*srs - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_srs.bitmask = 0x00;

        switch (p_phy_info_from_oam->physical_layer_param_srs.srsEnabled)
        {
            case RRM_OAM_SRS_DISABLED:
                {
                    p_phy_info_to_cellm->physical_layer_param_srs.srsEnabled = RRM_FALSE;
                    break;
                }
            case RRM_OAM_SRS_ENABLED:
                {
                    p_phy_info_to_cellm->physical_layer_param_srs.srsEnabled = RRM_TRUE;
                    break;
                }
            default:
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                            "fill_phy_layer_info_for_cell_reconfig: Incorrect p_phy_info_from_oam->"
                            "physical_layer_param_srs.srsEnabled");
                    break; 
                }
        }

        p_phy_info_to_cellm->physical_layer_param_srs.srs_bandwidth_config =
            p_phy_info_from_oam->physical_layer_param_srs.srs_bandwidth_config;

        p_phy_info_to_cellm->physical_layer_param_srs.srs_subframe_config =
            p_phy_info_from_oam->physical_layer_param_srs.srs_subframe_config;

        /*BUG_931_CHANGES_START*/
#ifdef TDD_MODE_FLAG
        if ((p_phy_info_from_oam->physical_layer_param_srs.bitmask &
                    RRM_OAM_SRS_MAX_UP_PTS_PRESENT) &&
                (RRM_OAM_SRS_MAX_UP_PTS_TRUE == p_phy_info_from_oam->physical_layer_param_srs.srs_max_up_pts))
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT");
            p_phy_info_to_cellm->physical_layer_param_srs.srs_max_up_pts =
                p_phy_info_from_oam->physical_layer_param_srs.srs_max_up_pts;
            p_phy_info_to_cellm->physical_layer_param_srs.bitmask |= 
                RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT;    
        }
#endif
        /*BUG_931_CHANGES_END*/
        p_phy_info_to_cellm->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission=
            p_phy_info_from_oam->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission;
        /* SPR 20653 Fix Start */
        if( p_phy_info_from_oam->physical_layer_param_srs.bitmask & RRM_OAM_SRS_HOPPING_ENABLE_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_srs.srs_hopping_enable= 
                p_phy_info_from_oam->physical_layer_param_srs.srs_hopping_enable;    
            /* SPR 21429 Fix Start */
            p_phy_info_to_cellm->physical_layer_param_srs.bitmask |= RRMCM_SRS_HOPPING_ENABLE_PRESENT;
            /* SPR 21429 Fix End */
        }         
        if( p_phy_info_from_oam->physical_layer_param_srs.bitmask & RRM_OAM_SRS_DURATION_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_srs.srs_duration= 
                p_phy_info_from_oam->physical_layer_param_srs.srs_duration;   
            /* SPR 21429 Fix Start */
            p_phy_info_to_cellm->physical_layer_param_srs.bitmask |= RRMCM_SRS_DURATION_PRESENT; 
            /* SPR 21429 Fix End */
        }         
        /* SPR 20653 Fix End */
        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT;

    }

    /*srs - end*/

    /*prach - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_prach.root_sequence_index =
            p_phy_info_from_oam->physical_layer_param_prach.root_sequence_index;

        p_phy_info_to_cellm->physical_layer_param_prach.configuration_index =
            p_phy_info_from_oam->physical_layer_param_prach.configuration_index;

        p_phy_info_to_cellm->physical_layer_param_prach.high_speed_flag =
            p_phy_info_from_oam->physical_layer_param_prach.high_speed_flag;

        p_phy_info_to_cellm->physical_layer_param_prach.zero_correlation_zone_config =
            p_phy_info_from_oam->physical_layer_param_prach.zero_correlation_zone_config;

        p_phy_info_to_cellm->physical_layer_param_prach.frequency_offset =
            p_phy_info_from_oam->physical_layer_param_prach.frequency_offset;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT;
    }
    /*prach - end*/

    /*pucch - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_pucch.delta_pucch_shift =
            p_phy_info_from_oam->physical_layer_param_pucch.delta_pucch_shift;

        p_phy_info_to_cellm->physical_layer_param_pucch.n_rb_cqi =
            p_phy_info_from_oam->physical_layer_param_pucch.n_rb_cqi;
        /* SPR 20653 Fix Start */
        if((p_phy_info_from_oam->bitmask & RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT )&& 
                (p_phy_info_from_oam->addl_physical_layer_params.bitmask & RRM_OAM_ADDITIONAL_PUCCH_PARAMS_PRESENT) &&
                (p_phy_info_from_oam->addl_physical_layer_params.addl_pucch_parameters.bitmask & RRM_OAM_N1_CS_PRESENT))
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.n_cs_an =
                p_phy_info_from_oam->addl_physical_layer_params.addl_pucch_parameters.n1_cs;
        }
        else
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.n_cs_an = RRM_DEFINED_DEFAULT_VALUE_FOR_PUCCH_N_CS_AN;
        }

        /* for TDD mode only*/
        p_phy_info_to_cellm->physical_layer_param_pucch.bitmask = 0x00;
        if(p_phy_info_from_oam->physical_layer_param_pucch.bitmask & 
                RRM_OAM_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT  )
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.tdd_ack_nack_feedback_mode = 
                p_phy_info_from_oam->physical_layer_param_pucch.tdd_ack_nack_feedback_mode;
            p_phy_info_to_cellm->physical_layer_param_pucch.bitmask |= PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;
        }
        else
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.tdd_ack_nack_feedback_mode
                = RRM_DEFINED_DEFAULT_VALUE_FOR_TDD_ACK_NACK_FEEDBACK_MODE;
            p_phy_info_to_cellm->physical_layer_param_pucch.bitmask |= PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;
        }

        p_phy_info_to_cellm->physical_layer_param_pucch.n1_pucch_an =
            p_phy_info_from_oam->physical_layer_param_pucch.n1_pucch_an;
        /* BUG_371 FIX START */ 
        if(p_phy_info_from_oam->physical_layer_param_pucch.bitmask & RRM_OAM_PUCCH_CQI_SINR_VAL_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.pucch_cqi_sinr_value =
                p_phy_info_from_oam->physical_layer_param_pucch.pucch_cqi_sinr_value;
        }
        else
        {
            p_phy_info_to_cellm->physical_layer_param_pucch.pucch_cqi_sinr_value = RRM_DEFINED_DEFAULT_VALUE_FOR_PUCCH_CQI_SNR_VALUE;
        }
        /* SPR 20653 Fix End */
        /* BUG_371 FIX END */ 
        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT;
    }
    /*pucch - end*/

    /*pusch - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_pusch.n_sb =
            p_phy_info_from_oam->physical_layer_param_pusch.n_sb;

        p_phy_info_to_cellm->physical_layer_param_pusch.pusch_hopping_mode =
            p_phy_info_from_oam->physical_layer_param_pusch.pusch_hopping_mode;

        p_phy_info_to_cellm->physical_layer_param_pusch.hopping_offset =
            p_phy_info_from_oam->physical_layer_param_pusch.hopping_offset;

        if(p_phy_info_from_oam->addl_physical_layer_params.additional_pusch_parameters.bitmask & 
                RRM_OAM_PUSCH_ENABLE_64_QAM_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_pusch.enable_64_qam = 
                p_phy_info_from_oam->addl_physical_layer_params.additional_pusch_parameters.pusch_enable_64_qam;
        }
        /* SPR 20653 Fix Start */
        else
        {
            p_phy_info_to_cellm->physical_layer_param_pusch.enable_64_qam = RRM_DEFINED_DEFAULT_VALUE_FOR_ENABLE_64_QAM;
        }
        /* SPR 20653 Fix End */
    }
    /*pusch - end*/

    /*ul refernce signal - start*/

    if( p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_hopping_enabled =
            p_phy_info_from_oam->physical_layer_param_ul_reference_signal.group_hopping_enabled;

        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.sequence_hopping_enabled =
            p_phy_info_from_oam->physical_layer_param_ul_reference_signal.sequence_hopping_enabled;

        if((p_phy_info_from_oam->bitmask & RRM_OAM_ADDITIONAL_PHYSICAL_LAYER_PARAM_PRESENT )&& 
                (p_phy_info_from_oam->addl_physical_layer_params.bitmask & RRM_OAM_ADDITIONAL_UL_REF_SIGNAL_PARAMS_PRESENT)) 
        {
            /* SPR 20653 Fix Start */
            if (p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask &
                    RRM_OAM_GROUP_ASSIGMENT_PUSCH_PRESENT)
            {
                p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_assignment_pusch =
                    p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.group_assignment_pusch;
            }
            else
            {
                p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_assignment_pusch = 
                    RRM_DEFINED_DEFAULT_VALUE_FOR_GROUP_ASGMNT_PUSCH;
            }
            if(p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask & 
                    RRM_OAM_UL_REFER_SIGNAL_PUSCH_CYCLIC_SHIFT_PRESENT)
            {
                p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.cyclic_shift =
                    p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.ul_reference_signal_pusch_cyclicshift;
            }
            else
            {
                p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.cyclic_shift = 
                    RRM_DEFINED_DEFAULT_VALUE_FOR_UL_REF_SIG_PUSCH_CYCLIC_SHIFT;
            }
            /* SPR 20653 Fix End */
        }
    }
    /*ul refernce signal - end*/

    /*ul power control - start*/

    if(p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_ul_power_control.p_0_nominal_pusch =
            p_phy_info_from_oam->physical_layer_param_ul_power_control.p_0_nominal_pusch;

        p_phy_info_to_cellm->physical_layer_param_ul_power_control.alpha =
            p_phy_info_from_oam->physical_layer_param_ul_power_control.alpha;

        p_phy_info_to_cellm->physical_layer_param_ul_power_control.p_0_nominal_pucch =
            p_phy_info_from_oam->physical_layer_param_ul_power_control.p_0_nominal_pucch;

        /* BUG_371 FIX START */
        /* BUG_371 FIX END */
        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT;
    }
    /*ul_power_control - end*/

    /*prs - start*/
    if (p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "fill_phy_layer_info_for_cell_reconfig: RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT");

        p_phy_info_to_cellm->physical_layer_param_prs.bitmask =
            p_phy_info_from_oam->physical_layer_param_prs.bitmask;

        p_phy_info_to_cellm->physical_layer_param_prs.prs_enable =
            p_phy_info_from_oam->physical_layer_param_prs.prs_enable;

        p_phy_info_to_cellm->physical_layer_param_prs.num_prs_resource_blocks =
            p_phy_info_from_oam->physical_layer_param_prs.num_prs_resource_blocks;

        p_phy_info_to_cellm->physical_layer_param_prs.prs_configuration_index =
            p_phy_info_from_oam->physical_layer_param_prs.prs_configuration_index;

        p_phy_info_to_cellm->physical_layer_param_prs.num_consecutive_prs_subfames =
            p_phy_info_from_oam->physical_layer_param_prs.num_consecutive_prs_subfames;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT;

        if (p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_two =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_two;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_TWO_PRESENT;
        }

        if ( p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_four =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_four;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_FOUR_PRESENT;
        }

        if(p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask &  RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_eight =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_eight;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_EIGHT_PRESENT;
        } 
        if( p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_sixteen =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_sixteen ;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT;
        } 
        p_phy_info_to_cellm->physical_layer_param_prs.prs_transmission_power =
            (p_phy_info_from_oam->physical_layer_param_prs.prs_transmission_power + STARTING_POWER_SIGNAL) * (POWER_SIGNAL_IN_ONE_DB) ;

    }
    /*prs - end*/

    if (p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "fill_phy_layer_info_for_cell_reconfig: RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_PRESENT");

        p_phy_info_to_cellm->physical_layer_param_tdd_frame_structure.sub_frame_assignment =
            p_phy_info_from_oam->physical_layer_param_tdd_frame_structure.sub_frame_assignment;

        p_phy_info_to_cellm->physical_layer_param_tdd_frame_structure.special_sub_frame_patterns=
            p_phy_info_from_oam->physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT;
    }
  #ifdef LTE_EMBMS_SUPPORTED
  if (RRM_OAM_MBSFN_CONFIGURATION_INFO_PRESENT & p_phy_info_from_oam->bitmask)
  {
      rrm_fill_mbsfn_config_params(&(p_phy_info_to_cellm->
                physical_layer_param_mbsfn_config_info),
                &((p_phy_info_from_oam->mbsfn_subframe_config_list)));
      p_phy_info_to_cellm->bitmask |= 
               RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT;
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
           "MBSFN IE is reconfigured in SIB2 for eMBMS");
  }
  #endif
    RRM_UT_TRACE_EXIT();
}

/* Coverity_ID : 53622, 53623 start */
/* SPR 20653 Fix Start */
/* Code Removed */
/* SPR 20653 Fix End */
/* Coverity_ID : 53622, 53623 end */
/****************************************************************************
 * Function Name  : fill_mac_layer_info_for_cell_reconfig
 * Inputs         : - p_mac_info_to_cellm
 *                  - p_mac_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the MAC layer Info for CellM module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_mac_layer_info_for_cell_reconfig(mac_layer_params_t          *p_mac_info_to_cellm,
        rrm_oam_mac_layer_params_t  *p_mac_info_from_oam
        )
    /* SPR 20653 Fix End */
{
    U16 drx_profile_count = RRM_ZERO;
    U16 qci_count         = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_mac_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_mac_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating MAC Information");

    /* Inititalize bitmask */
    p_mac_info_to_cellm->bitmask = 0x00;
    /* rach - start */
    if(p_mac_info_from_oam->bitmask & RRM_OAM_MAC_LAYER_PARAM_RACH_PRESENT)
    {
        /* preamble_info - start */
        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.bitmask = 0x00;

        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.number_of_ra_preambles= 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_info.number_of_ra_preambles;

        if (p_mac_info_from_oam->mac_layer_param_rach.preamble_info.bitmask & 
                RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT");

            p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.bitmask |=
                RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT;
            p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a= 
                p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a;
            p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_size_group_a= 
                p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_size_group_a;
            p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b = 
                p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b;
        }
        /* preamble_info - end */

        p_mac_info_to_cellm->mac_layer_param_rach.power_ramping_step = 
            p_mac_info_from_oam->mac_layer_param_rach.power_ramping_step;

        p_mac_info_to_cellm->mac_layer_param_rach.preamble_initial_received_target_power = 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_initial_received_target_power;

        p_mac_info_to_cellm->mac_layer_param_rach.preamble_trans_max = 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_trans_max;

        p_mac_info_to_cellm->mac_layer_param_rach.response_window_size = 
            p_mac_info_from_oam->mac_layer_param_rach.response_window_size;

        p_mac_info_to_cellm->mac_layer_param_rach.contention_resolution_timer = 
            p_mac_info_from_oam->mac_layer_param_rach.contention_resolution_timer;


        p_mac_info_to_cellm->mac_layer_param_rach.max_harq_msg_3tx =
            p_mac_info_from_oam->mac_layer_param_rach.max_harq_msg_3tx;


        p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_RACH_PRESENT;
    }
    /* rach - end */

    /* drx - start */
    if(p_mac_info_from_oam->bitmask & RRM_OAM_MAC_LAYER_PARAM_DRX_PRESENT)
    {
        p_mac_info_to_cellm->mac_layer_param_drx.drx_enabled =
            p_mac_info_from_oam->mac_layer_param_drx.drx_enabled;
        p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles= 
            p_mac_info_from_oam->mac_layer_param_drx.num_valid_drx_profiles;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "DRX Enable [%d]  Number of Valid DRX profiles[%d]",
                p_mac_info_to_cellm->mac_layer_param_drx.drx_enabled,
                p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles);

        for (drx_profile_count=0;
                ((drx_profile_count < p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles)&&
                 (drx_profile_count < MAX_NO_DRX_PROFILE));
                drx_profile_count++)
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask = 0x00;

            /*qci info*/ 
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci =  
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].num_applicable_qci;

            for (qci_count = 0;
                    ((qci_count < p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci)&&
                     (qci_count < RRM_MAX_QCI )); qci_count++ )
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].qci[qci_count]=
                    p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].applicable_qci_list[qci_count]; 
            }/*for loop ends*/

            /*qci info*/ 
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci =  
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].num_applicable_qci;

            for (qci_count = 0;
                    ((qci_count < p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci)&&
                     (qci_count < RRM_MAX_QCI )); qci_count++ )
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].qci[qci_count]=
                    p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].applicable_qci_list[qci_count]; 
            }/*for loop ends*/


            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].on_duration_timer=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].on_duration_timer;

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_inactivity_timer=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_inactivity_timer;

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_retransmission_timer=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_retransmission_timer;

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle;

            #ifdef ENDC_ENABLED
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle_r15 =
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle_r15;
            #endif

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_start_offset=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_start_offset;

            if (p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].bitmask & 
                    RRM_OAM_SHORT_DRX_CYCLE_PRESENT)
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask |= 
                    RRMCM_RMIF_SHORT_DRX_CYCLE_PRESENT;

                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask |= 
                    RRMCM_RMIF_SHORT_DRX_CYCLE_TIMER_PRESENT;

                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle =
                    p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle.short_drx_cycle;
                p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_short_cycle_timer=
                    p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle.
                    drx_short_cycle_timer;
            }
        }/*outer for loop ends*/

        /* CSR_00053551_CHANGES_START */
        p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable =
            p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_command_enable;

        if(RRM_TRUE == p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_command_enable)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "DRX_MAC_CE_CMD is Enabled by operator");
            if(p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT)
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_timer_percentage =
                    p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_timer_percentage;
            }
            else
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_FALSE;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "DRX_MAC_CE_CMD is Disabled as drx_mac_ce_timer_percentage is not configured");
            }

            if(p_mac_info_from_oam->mac_layer_param_drx.bitmask &  RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT)
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_cmd_threshold =
                    p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_cmd_threshold;
            }
            else
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_FALSE;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "DRX_MAC_CE_CMD is Disabled as drx_mac_ce_cmd_threshold is not configured");
            }
            if((p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT) &&
                    (p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT))
            {
                p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_TRUE;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "DRX_MAC_CE_CMD is Enabled for further decisions at Cell Manager");
            }
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "DRX_MAC_CE_CMD is disabled by operator");
        }
        /* CSR_00053551_CHANGES_END */

        p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_DRX_PRESENT; 
    }
    /* drx - end */

    /* Fix for CSR: 00059124 */
    if(p_mac_info_from_oam->bitmask & RRM_OAM_MAC_LAYER_PARAM_CDRX_PRESENT)
    {
        p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_CDRX_PRESENT;

        p_mac_info_to_cellm->rrm_cdrx_config.on_duration_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.on_duration_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_inactivity_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_inactivity_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_retransmission_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_retransmission_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle=
            p_mac_info_from_oam->rrm_oam_cdrx_config.long_drx_cycle;

        #ifdef ENDC_ENABLED
        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle_r15 =
            p_mac_info_from_oam->rrm_oam_cdrx_config.long_drx_cycle_r15;
        #endif

        p_mac_info_to_cellm->rrm_cdrx_config.drx_start_offset=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_start_offset;
        /*SPR 20533 Fix Start*/
        /*Code Removed*/
        /*SPR 20533 Fix Stop*/
    }
    /* Fix for CSR: 00059124 */
    /* BUG_371 FIX START */ 
    if(p_mac_info_from_oam->bitmask & RRM_OAM_UL_SYNC_LOSS_TIMER_PRESENT)
    {
        switch(p_mac_info_from_oam->ul_sync_loss_timer)
        {
            case RRM_ZERO:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_INFINITY;
                    break;
                }
            case RRM_ONE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_100;
                    break;
                }
            case RRM_TWO:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_150;
                    break;
                }
            case RRM_THREE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_200;
                    break;
                }
            case RRM_FOUR:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_300;
                    break;
                }
            case RRM_FIVE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_400;
                    break;
                }
            case RRM_SIX:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_500;
                    break;
                }
            case RRM_SEVEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_750;
                    break;
                }
            case RRM_EIGHT:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_1280;
                    break;
                }
            case RRM_NINE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_1920;
                    break;
                }
            case RRM_TEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_2560;
                    break;
                }
            case RRM_ELEVEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_5120;
                    break;
                }
            case RRM_TWELVE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_10240;
                    break;
                }
            default:
                p_mac_info_to_cellm->ul_sync_loss_timer =
                    RRM_UL_SYNC_LOSS_TIMER_INFINITY;
        }

        /* SPR 20653 Fix Start */
        /* Code Removed */
    }
    else
    {
        /* Coverity_ID : 53622 */
        p_mac_info_to_cellm->ul_sync_loss_timer = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_SYNC_LOSS_TIMER;
        /* Code Removed */
        /* SPR 20653 Fix End */
    }
    p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_CONFIG_PRESENT; 
    if(p_mac_info_from_oam->bitmask & RRM_OAM_N_GAP_PRESENT)
    {
        switch(p_mac_info_from_oam->n_gap)
        {
            case RRM_ZERO:
                {
                    p_mac_info_to_cellm->n_gap =
                        RRM_NGAP_1;
                    break;
                }
            case RRM_ONE:
                {
                    p_mac_info_to_cellm->n_gap =
                        RRM_NGAP_2;
                    break;
                }
            default:
                p_mac_info_to_cellm->n_gap =
                    RRM_NGAP_1;
        }
    }
    /* SPR 20653 Fix Start */
    /* Code removed */
    /* SPR 20653 Fix End */
    /* BUG_371 FIX END */ 
}

/****************************************************************************
 * Function Name  : fill_rlc_layer_info
 * Inputs         : - p_rlc_info_to_cellm
 *                  - p_rlc_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill teh RLC layer info for CellM module.
 ****************************************************************************/
void fill_rlc_layer_info(
        /*SPR 17777 +-*/
        rlc_layer_params_t          *p_rlc_info_to_cellm,
        rrm_oam_rlc_layer_params_t  *p_rlc_info_from_oam)
{
    U16 srb_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_rlc_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_rlc_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating RLC Information");

    p_rlc_info_to_cellm->num_valid_srb_info = p_rlc_info_from_oam->num_valid_srb_info;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "SrbInfo Count[%d]", p_rlc_info_to_cellm->num_valid_srb_info);

    for(srb_count = 0;
            ((srb_count < p_rlc_info_to_cellm->num_valid_srb_info)&&(srb_count < MAX_NO_SRB));
            srb_count++)
    {
        p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].bitmask = 0x00;

        /*Populate Default Config */
        p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].default_configuration =
            p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].default_configuration;

        if (p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].bitmask & 
                RRM_OAM_SRB_INFO_PRESENT)
        {
            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].bitmask |= 
                RRMCM_RMIF_SRB_INFO_PRESENT;

            /*Populate SRB parameters*/
            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_poll_retransmit =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.t_poll_retransmit;

            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.poll_pdu =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.poll_pdu;

            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.poll_byte =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.poll_byte;

            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.max_retx_threshold =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.max_retx_threshold;

            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_reordering =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.t_reordering;

            p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_status_prohibit =
                p_rlc_info_from_oam->rlc_layer_param_srb[srb_count].srb_params.t_status_prohibit;

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, "Poll Retrans[%d]   Poll Pdu[%d]   Poll Bytes[%d]"
                    "Max Retx[%d]   T_Reodering[%d]   T_Status_Prohibit[%d]",
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_poll_retransmit,
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.poll_pdu,
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.poll_byte,
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.max_retx_threshold,
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_reordering,
                    p_rlc_info_to_cellm->rlc_layer_param_srb[srb_count].srb_params.t_status_prohibit);
        }
    }/*for loop ends*/

    RRM_UT_TRACE_EXIT();
}

/*BUG_866_CHANGES_START*/
/****************************************************************************
 * Function Name  : fill_cell_restriction_info
 * Inputs         : - p_cell_restrict_info_to_cellm
 *                  - p_cell_restrict_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill Cell Restriction Info for CellM module.
 ****************************************************************************/
void fill_cell_restriction_info_for_cell_config(cell_restriction_params_t         *p_cell_restrict_info_to_cellm,
        rrm_oam_cell_access_restriction_params_t *p_cell_restrict_info_from_oam)
    /*SPR 17777 +-*/
{
    RRM_ASSERT (RRM_PNULL != p_cell_restrict_info_to_cellm); 
    RRM_ASSERT (RRM_PNULL != p_cell_restrict_info_from_oam);  
    /* SPR Fix 17928 Start */
    /* Code Deleted */
    /* SPR Fix 17928 End */
    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Cell Restriction Info");

    /* SPR 10730 Fix Start */
    p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_barred =
        p_cell_restrict_info_from_oam->cell_barred;

    p_cell_restrict_info_to_cellm->cell_and_access_barring.barring_for_emergency =
        p_cell_restrict_info_from_oam->barring_for_emergency;

    /* BUG_371 FIX START */
    p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_access_info.intra_frequency_reselection  =
        p_cell_restrict_info_from_oam->intra_freq_reselection;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
            "Cell Barred[%d] Barring Emergency[%d] Intra Freq Reselection [%d]",
            p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_barred,
            p_cell_restrict_info_to_cellm->cell_and_access_barring.barring_for_emergency,
            p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_access_info.intra_frequency_reselection);  
    /* BUG_371 FIX END */
    /* SPR 10730 Fix End */

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : fill_cell_restriction_info_for_cell_reconfig
 * Inputs         : - p_cell_restrict_info_to_cellm
 *                  - p_cell_restrict_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill Cell Restriction Info for CellM module.
 ****************************************************************************/
void fill_cell_restriction_info_for_cell_reconfig(cell_restriction_params_t         *p_cell_restrict_info_to_cellm,
        rrm_oam_cell_access_restriction_params_t *p_cell_restrict_info_from_oam)
    /*SPR 17777 +-*/
{
    RRM_ASSERT (RRM_PNULL != p_cell_restrict_info_to_cellm); 
    RRM_ASSERT (RRM_PNULL != p_cell_restrict_info_from_oam);  
    /* Dont Add a NULl Check on EPC Info as it can come as NULL Value */
    //RRM_ASSERT (RRM_PNULL != p_epc_info_from_oam);  

    RRM_UT_TRACE_ENTER();


    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Cell Restriction Info");

    p_cell_restrict_info_to_cellm->cell_and_access_barring.bitmask = 0x00;

    p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_barred =
        p_cell_restrict_info_from_oam->cell_barred;

    p_cell_restrict_info_to_cellm->cell_and_access_barring.barring_for_emergency =
        p_cell_restrict_info_from_oam->barring_for_emergency;

    /* SPR 10730 Fix Start */

    /* BUG_371 FIX START */
    p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_access_info.intra_frequency_reselection  =
        p_cell_restrict_info_from_oam->intra_freq_reselection;

    /* SPR 10730 Fix Start */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, 
            "Cell Barred[%d] Barring Emergency[%d] Intra Freq Reselection [%d]",
            p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_barred,
            p_cell_restrict_info_to_cellm->cell_and_access_barring.barring_for_emergency,
            p_cell_restrict_info_to_cellm->cell_and_access_barring.cell_access_info.intra_frequency_reselection);  
    /* BUG_371 FIX END */
    /* SPR 10730 Fix End */

    RRM_UT_TRACE_EXIT();
}
/*BUG_866_CHANGES_END*/

/****************************************************************************
 * Function Name  : fill_irat_cdma2000_speed_scale_factors
 * Inputs         : - p_sf_info_to_cellm
 *                : - p_sf_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 speed scale factors param 
 for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_speed_scale_factors(speed_scale_factors_t
        *p_sf_info_to_cellm,
        rrm_oam_speed_scale_factors_t
        *p_sf_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_sf_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_sf_info_from_oam);

    RRM_UT_TRACE_ENTER();

    switch(p_sf_info_from_oam->t_reselection_eutra_sf_medium)
    {
        case RRM_OAM_O_DOT_25:
            p_sf_info_to_cellm->t_reselection_eutra_sf_medium = \
                                                                RRM_OAM_O_DOT_25;
            break;
        case RRM_OAM_O_DOT_5:
            p_sf_info_to_cellm->t_reselection_eutra_sf_medium = \
                                                                RRM_OAM_O_DOT_5;
            break;
        case RRM_OAM_O_DOT_75:
            p_sf_info_to_cellm->t_reselection_eutra_sf_medium = \
                                                                RRM_OAM_O_DOT_75;
            break;
        case RRM_OAM_l_DOT_0:
            p_sf_info_to_cellm->t_reselection_eutra_sf_medium = \
                                                                RRM_OAM_l_DOT_0;
            break;
        default:
            p_sf_info_to_cellm->t_reselection_eutra_sf_medium = \
                                                                p_sf_info_from_oam->t_reselection_eutra_sf_medium;
            break;
    }
    switch(p_sf_info_from_oam->t_reselection_eutra_sf_high)
    {
        case RRM_OAM_O_DOT_25:
            p_sf_info_to_cellm->t_reselection_eutra_sf_high = \
                                                              RRM_OAM_O_DOT_25;
            break;
        case RRM_OAM_O_DOT_5:
            p_sf_info_to_cellm->t_reselection_eutra_sf_high = \
                                                              RRM_OAM_O_DOT_5;
            break;
        case RRM_OAM_O_DOT_75:
            p_sf_info_to_cellm->t_reselection_eutra_sf_high = \
                                                              RRM_OAM_O_DOT_75;
            break;
        case RRM_OAM_l_DOT_0:
            p_sf_info_to_cellm->t_reselection_eutra_sf_high = \
                                                              RRM_OAM_l_DOT_0;
            break;
        default:
            p_sf_info_to_cellm->t_reselection_eutra_sf_high = \
                                                              p_sf_info_from_oam->t_reselection_eutra_sf_high;
            break;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_irat_cdma2000_band_class_info
 * Inputs         : p_band_class_list_to_cellm 
 *                : p_band_class_list_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 band class 
 *                  params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_band_class_info(rrmcm_rmif_band_class_list_cdma2000_t 
        *p_band_class_list_to_cellm,
        rrm_oam_band_class_list_cdma2000_t
        *p_band_class_list_from_oam)
{
    U8 band_class_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_band_class_list_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_band_class_list_from_oam);

    RRM_UT_TRACE_ENTER();

    rrmcm_rmif_band_class_info_cdma2000_t *p_band_class_info_to_cellm = \
                                                                        p_band_class_list_to_cellm->band_class_info_cdma2000;

    rrm_oam_band_class_info_cdma2000_t *p_band_class_info_from_oam = \
                                                                     p_band_class_list_from_oam->band_class_info_cdma2000;

    p_band_class_list_to_cellm->count = p_band_class_list_from_oam->count;

    for(band_class_count = 0; 
            band_class_count < p_band_class_list_from_oam->count;
            band_class_count++)
    {
        fill_cdma2000_band_class_params(
                &(p_band_class_info_to_cellm[band_class_count].band_class),
                &(p_band_class_info_from_oam[band_class_count].band_class));

        p_band_class_info_to_cellm[band_class_count].thresh_x_high = \
                                                                     p_band_class_info_from_oam[band_class_count].thresh_x_high;

        p_band_class_info_to_cellm[band_class_count].thresh_x_low = \
                                                                    p_band_class_info_from_oam[band_class_count].thresh_x_low;

        if(p_band_class_info_from_oam[band_class_count].presence_bitmask &
                RRM_OAM_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG)
        {
            p_band_class_info_to_cellm[band_class_count].presence_bitmask = 0;

            p_band_class_info_to_cellm[band_class_count]. \
                cell_reselection_priority = \
                p_band_class_info_from_oam[band_class_count]. \
                cell_reselection_priority;

            p_band_class_info_to_cellm[band_class_count].presence_bitmask |= \
                                                                             RRMCM_RMIF_BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG;
        }
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_irat_cdma2000_ac_barring_info
 * Inputs         : p_ac_barring_info_to_cellm 
 *                : p_ac_barring_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 idle mode mobility 
 *                   params for CellM module.
 ******************************************************************************/
rrm_void_t
fill_irat_cdma2000_ac_barring_info(rrmcm_rmif_ac_barring_config_1_xrtt_r9_t
        *p_ac_barring_info_to_cellm,
        rrm_oam_ac_barring_config_1_xrtt_r9_t
        *p_ac_barring_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_ac_barring_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ac_barring_info_from_oam);

    RRM_UT_TRACE_ENTER();

    p_ac_barring_info_to_cellm->ac_barring_0_to_9_r9 = \
                                                       p_ac_barring_info_from_oam->ac_barring_0_to_9_r9;

    p_ac_barring_info_to_cellm->ac_barring_10_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_10_r9;

    p_ac_barring_info_to_cellm->ac_barring_11_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_11_r9;

    p_ac_barring_info_to_cellm->ac_barring_12_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_12_r9;

    p_ac_barring_info_to_cellm->ac_barring_13_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_13_r9;

    p_ac_barring_info_to_cellm->ac_barring_14_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_14_r9;

    p_ac_barring_info_to_cellm->ac_barring_15_r9 = \
                                                   p_ac_barring_info_from_oam->ac_barring_15_r9;

    p_ac_barring_info_to_cellm->ac_barring_msg_r9 = \
                                                    p_ac_barring_info_from_oam->ac_barring_msg_r9;

    p_ac_barring_info_to_cellm->ac_barring_reg_r9 = \
                                                    p_ac_barring_info_from_oam->ac_barring_reg_r9;

    p_ac_barring_info_to_cellm->ac_barring_emg_r9 = \
                                                    p_ac_barring_info_from_oam->ac_barring_emg_r9;

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_irat_cdma2000_pre_reg_hrpd_info
 * Inputs         : p_pre_reg_hrpd_info_to_cellm 
 *                : p_pre_reg_hrpd_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 hrpd pre-registration info 
 *                   params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_pre_reg_hrpd_info(rrmcm_rmif_pre_reg_info_hrpd_t
        *p_pre_reg_hrpd_info_to_cellm,
        rrm_oam_pre_reg_info_hrpd_t
        *p_pre_reg_hrpd_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_pre_reg_hrpd_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_pre_reg_hrpd_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_pre_reg_hrpd_info_to_cellm->presence_bitmask = 0x00;

    p_pre_reg_hrpd_info_to_cellm->pre_reg_allowed = \
                                                    p_pre_reg_hrpd_info_from_oam->pre_reg_allowed;

    if(p_pre_reg_hrpd_info_from_oam->presence_bitmask &
            RRM_OAM_PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG)
    {
        p_pre_reg_hrpd_info_to_cellm->pre_reg_zone_id = \
                                                        p_pre_reg_hrpd_info_from_oam->pre_reg_zone_id;

        p_pre_reg_hrpd_info_to_cellm->presence_bitmask |= \
                                                          RRMCM_RMIF_PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG;
    }

    if(p_pre_reg_hrpd_info_from_oam->presence_bitmask &
            RRM_OAM_PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG)
    {
        p_pre_reg_hrpd_info_to_cellm->secondary_list.count = \
                                                             p_pre_reg_hrpd_info_from_oam->secondary_list.count;

        RRM_MEMCPY((U8*)p_pre_reg_hrpd_info_to_cellm->secondary_list. \
                pre_reg_zone_id, 
                (U8*)p_pre_reg_hrpd_info_from_oam->secondary_list. \
                pre_reg_zone_id,
                p_pre_reg_hrpd_info_to_cellm->secondary_list.count);

        p_pre_reg_hrpd_info_to_cellm->presence_bitmask |= \
                                                          RRMCM_RMIF_PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_irat_cdma2000_sib8_mobility_info
 * Inputs         : p_sib8_mob_info_to_cellm 
 *                : p_sib8_mob_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 sib8 mobility 
 params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_sib8_mobility_info(rrmcm_rmif_mobility_sib_8_params_t
        *p_sib8_mob_info_to_cellm,
        rrm_oam_mobility_sib_8_params_t
        *p_sib8_mob_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_sib8_mob_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_sib8_mob_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_sib8_mob_info_to_cellm->bitmask = 0x00;

    RRM_MEMCPY((U8*)p_sib8_mob_info_to_cellm->sid, \
            (U8*)p_sib8_mob_info_from_oam->sid,
            sizeof(p_sib8_mob_info_to_cellm->sid));

    RRM_MEMCPY((U8*)p_sib8_mob_info_to_cellm->nid, \
            (U8*)p_sib8_mob_info_from_oam->nid,
            sizeof(p_sib8_mob_info_to_cellm->nid));

    p_sib8_mob_info_to_cellm->multiple_sid = \
                                             p_sib8_mob_info_from_oam->multiple_sid;

    p_sib8_mob_info_to_cellm->multiple_nid = \
                                             p_sib8_mob_info_from_oam->multiple_nid;

    RRM_MEMCPY((U8*)p_sib8_mob_info_to_cellm->reg_zone, \
            (U8*)p_sib8_mob_info_from_oam->reg_zone,
            sizeof(p_sib8_mob_info_to_cellm->reg_zone));

    RRM_MEMCPY((U8*)p_sib8_mob_info_to_cellm->total_zone, \
            (U8*)p_sib8_mob_info_from_oam->total_zone,
            sizeof(p_sib8_mob_info_to_cellm->total_zone));

    RRM_MEMCPY((U8*)p_sib8_mob_info_to_cellm->zone_timer, \
            (U8*)p_sib8_mob_info_from_oam->zone_timer,
            sizeof(p_sib8_mob_info_to_cellm->zone_timer));

    if(p_sib8_mob_info_from_oam->bitmask &
            RRM_OAM_PACKET_ZONE_ID_INCLUDED_PRESENT)
    {
        p_sib8_mob_info_to_cellm->packet_zone_id = \
                                                   p_sib8_mob_info_from_oam->packet_zone_id;

        p_sib8_mob_info_to_cellm->bitmask |= \
                                             RRMCM_RMIF_PACKET_ZONE_ID_INCLUDED_PRESENT;
    }

    p_sib8_mob_info_to_cellm->home_reg = \
                                         p_sib8_mob_info_from_oam->home_reg;

    p_sib8_mob_info_to_cellm->foreign_sid_reg = \
                                                p_sib8_mob_info_from_oam->foreign_sid_reg;

    p_sib8_mob_info_to_cellm->foreign_nid_reg = \
                                                p_sib8_mob_info_from_oam->foreign_nid_reg;

    p_sib8_mob_info_to_cellm->parame_reg = \
                                           p_sib8_mob_info_from_oam->parame_reg;

    p_sib8_mob_info_to_cellm->power_up_reg = \
                                             p_sib8_mob_info_from_oam->power_up_reg;

    p_sib8_mob_info_to_cellm->reg_prd = \
                                        p_sib8_mob_info_from_oam->reg_prd;

    if(p_sib8_mob_info_from_oam->bitmask &
            RRM_OAM_POWER_DOWN_REG_INCLUDED_PRESENT)
    {
        p_sib8_mob_info_to_cellm->power_down_reg = \
                                                   p_sib8_mob_info_from_oam->power_down_reg;

        p_sib8_mob_info_to_cellm->bitmask |= \
                                             RRMCM_RMIF_POWER_DOWN_REG_INCLUDED_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
} 


/****************************************************************************
 * Function Name  : fill_irat_cdma2000_cell_params_info
 * Inputs         : p_cell_param_info_to_cellm 
 *                : p_cell_param_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 cell id and rand  
 params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_cell_params_info(rrmcm_rmif_cdma2000_cell_param_t 
        *p_cell_param_info_to_cellm,
        rrm_oam_cdma2000_cell_param_t
        *p_cell_param_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_cell_param_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_cell_param_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_cell_param_info_to_cellm->bitmask = 0x00;

    p_cell_param_info_to_cellm->cdma2000_rand.rand_seed = \
                                                          p_cell_param_info_from_oam->cdma2000_rand.rand_seed;

    p_cell_param_info_to_cellm->cdma2000_rand.rand_min = \
                                                         p_cell_param_info_from_oam->cdma2000_rand.rand_min;

    p_cell_param_info_to_cellm->cdma2000_rand.rand_max = \
                                                         p_cell_param_info_from_oam->cdma2000_rand.rand_max;

    p_cell_param_info_to_cellm->cdma2000_rand.rand_regenerate_timer = \
                                                                      p_cell_param_info_from_oam->cdma2000_rand.rand_regenerate_timer;

    if(p_cell_param_info_from_oam->bitmask &
            RRM_OAM_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG)
    {
        RRM_MEMCPY((U8*)p_cell_param_info_to_cellm->cell_id_1xrtt. \
                cdma2000_1xrtt_cell_id, 
                (U8*)p_cell_param_info_from_oam->cell_id_1xrtt. \
                cdma2000_1xrtt_cell_id,
                sizeof(p_cell_param_info_to_cellm->cell_id_1xrtt. \
                    cdma2000_1xrtt_cell_id));

        p_cell_param_info_to_cellm->bitmask |= \
                                               RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG;
    }

    if(p_cell_param_info_from_oam->bitmask &
            RRM_OAM_CDMA2000_PARAM_HRPD_SECTOR_ID_PRESENCE_FLAG)
    {
        RRM_MEMCPY((U8*)p_cell_param_info_to_cellm->cell_id_hrpd. \
                cdma2000_hrpd_cell_id, 
                (U8*)p_cell_param_info_from_oam->cell_id_hrpd. \
                cdma2000_hrpd_cell_id,
                RRM_CDMA2000_HRPD_CELL_ID_LENGTH);

        p_cell_param_info_to_cellm->bitmask |= \
                                               RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG;
    }
    /* CSR 00070260 FIX START */
    if(p_cell_param_info_from_oam->bitmask &
            RRM_OAM_CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG)
    {
        RRM_MEMCPY((U8*)p_cell_param_info_to_cellm->cdma2000_1xrtt_reference_cell_id, 
                (U8*)p_cell_param_info_from_oam->cdma2000_1xrtt_reference_cell_id,
                RRM_CDMA2000_1XRTT_REFERENCE_CELL_ID_LENGTH);

        p_cell_param_info_to_cellm->bitmask |= \
                                               RRMCM_RMIF_CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG;
    }

    if(p_cell_param_info_from_oam->bitmask &
            RRM_OAM_CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG)
    {
        RRM_MEMCPY((U8*)p_cell_param_info_to_cellm->cdma2000_hrpd_reference_cell_id, 
                (U8*)p_cell_param_info_from_oam->cdma2000_hrpd_reference_cell_id,
                RRM_CDMA2000_HRPD_REFERENCE_CELL_ID_LENGTH);

        p_cell_param_info_to_cellm->bitmask |= \
                                               RRMCM_RMIF_CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG;
    }
    /* CSR 00070260 FIX END */

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : fill_irat_cdma2000_v920_info
 * Inputs         : p_v920_info_to_cellm 
 *                : p_v920_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 inter rat cdma2000_v920 
 params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_irat_cdma2000_v920_info(rrmcm_rmif_irat_parameters_cdma2000_v920_t 
        *p_v920_info_to_cellm,
        rrm_oam_irat_parameters_cdma2000_v920_t
        *p_v920_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_v920_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_v920_info_from_oam);

    RRM_UT_TRACE_ENTER();

    switch(p_v920_info_from_oam->eCSFB_1xrtt_r9)
    {
        case RRM_OAM_ECSFB_1XRTT_R9_SUPPORTED:
            p_v920_info_to_cellm->eCSFB_1xrtt_r9 = \
                                                   RRM_OAM_ECSFB_1XRTT_R9_SUPPORTED;
            break;
        default:
            p_v920_info_to_cellm->eCSFB_1xrtt_r9 = \
                                                   p_v920_info_from_oam->eCSFB_1xrtt_r9;
            break;
    }
    if(p_v920_info_from_oam->bitmask &
            RRM_OAM_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG)
    {
        switch(p_v920_info_from_oam->eCSFB_conc_ps_mobility_1xrtt_r9)
        {
            case RRM_OAM_ECSFB_CONC_PS_MOBILITY_1XRTT_R9_SUPPORTED:
                p_v920_info_to_cellm->eCSFB_conc_ps_mobility_1xrtt_r9 = \
                                                                        RRM_OAM_ECSFB_CONC_PS_MOBILITY_1XRTT_R9_SUPPORTED;
                break;
            default:
                p_v920_info_to_cellm->eCSFB_conc_ps_mobility_1xrtt_r9 = \
                                                                        p_v920_info_from_oam->eCSFB_conc_ps_mobility_1xrtt_r9;
                break;
        }
        p_v920_info_to_cellm->bitmask |= RRMCM_RMIF_CDMA2000_PARAM_CONC_PS_MOBILITY_PRESENCE_FLAG;
    }

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : fill_cell_reselection_params_cdma2000
 * Inputs         : p_irat_cdma2000_info_to_cellm
 *                : p_irat_cdma2000_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 idle mode mobility
 params for CellM module.
 ****************************************************************************/
rrm_void_t
fill_cell_reselection_params_cdma2000(
        rrmcm_rmif_cell_reselection_params_cdma2000_t
        *p_resel_info_to_cellm,
        rrm_oam_cell_reselection_params_cdma2000_t
        *p_resel_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_resel_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_resel_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_resel_info_to_cellm->presence_bitmask = 0x00;

    p_resel_info_to_cellm->t_reselection_cdma2000 = \
                                                    p_resel_info_from_oam->t_reselection_cdma2000;

    if(p_resel_info_from_oam->presence_bitmask &
            RRMCM_RMIF_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG)
    {
        fill_irat_cdma2000_speed_scale_factors(
                &p_resel_info_to_cellm->t_reselection_cdma2000_sf,
                &p_resel_info_from_oam->t_reselection_cdma2000_sf);

        p_resel_info_to_cellm->presence_bitmask |= \
                                                   RRMCM_RMIF_CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG;
    }

    fill_irat_cdma2000_band_class_info(
            &p_resel_info_to_cellm-> \
            band_class_list,
            &p_resel_info_from_oam-> \
            band_class_list);

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_idle_mode_mobility_irat_cdma2000_info
 * Inputs         : p_irat_cdma2000_info_to_cellm 
 *                : p_irat_cdma2000_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 idle mode mobility 
 params for CellM module.
 ****************************************************************************/
rrm_void_t 
fill_idle_mode_mobility_irat_cdma2000_info(
        rrmcm_idle_mode_mobility_irat_cdma_params_t
        *p_irat_cdma2000_info_to_cellm,
        rrm_oam_idle_mode_mobility_inter_rat_cdma2000_params_t
        *p_irat_cdma2000_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_irat_cdma2000_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_cdma2000_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_irat_cdma2000_info_to_cellm->presence_bitmask = 0x00;

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {
        p_irat_cdma2000_info_to_cellm->search_window_size = \
                                                            p_irat_cdma2000_info_from_oam->search_window_size;

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_SEARCH_WIN_SIZE_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {
        switch(p_irat_cdma2000_info_from_oam-> \
                csfb_support_for_dual_rx_ues_r9)
        {
            case RRM_FALSE:
                p_irat_cdma2000_info_to_cellm-> \
                    csfb_support_for_dual_rx_ues_r9 = RRM_FALSE;
                break;
            case RRM_TRUE:
                p_irat_cdma2000_info_to_cellm-> \
                    csfb_support_for_dual_rx_ues_r9 = RRM_TRUE;
                /*coverity 22530, break added, aditya, rel1.3.1*/
                break;
            default :
                /*coverity : CID 31026 */
                p_irat_cdma2000_info_to_cellm-> \
                    csfb_support_for_dual_rx_ues_r9 = \
                    (rrm_bool_et)p_irat_cdma2000_info_from_oam-> \
                    csfb_support_for_dual_rx_ues_r9;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                        RRM_DETAILED, "Invalid csfb_support_for_dual_rx_ues_r9");
        }
        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG)
        /* Fix for SPR 13113 Start */
    {
        p_irat_cdma2000_info_to_cellm->csfb_registration_param_1xrtt_v920 = \
                                                                            p_irat_cdma2000_info_from_oam ->csfb_registration_param_1xrtt_v920;
        /* Fix for SPR 13113 End */

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_CSFB_REG_PARAM_1XRTT_V920_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {
        fill_irat_cdma2000_ac_barring_info(
                &p_irat_cdma2000_info_to_cellm-> \
                ac_barring_config_1_xrtt_r9,
                &p_irat_cdma2000_info_from_oam-> \
                ac_barring_config_1_xrtt_r9);

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_PRE_REG_INFO_HRPD_PRESENCE_FLAG)
    {

        fill_irat_cdma2000_pre_reg_hrpd_info(
                &p_irat_cdma2000_info_to_cellm-> \
                pre_reg_info_hrpd,
                &p_irat_cdma2000_info_from_oam-> \
                pre_reg_info_hrpd);
        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_PRE_REG_INFO_HRPD_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG)
    {
        fill_irat_cdma2000_sib8_mobility_info(
                &p_irat_cdma2000_info_to_cellm-> \
                mobility_sib_8_params,
                &p_irat_cdma2000_info_from_oam-> \
                mobility_sib_8_params);
        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_MOBILITY_SIB_8_PARAMS_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_CDMA2000_CELL_PARAMS_PRESENCE_FLAG)
    {
        fill_irat_cdma2000_cell_params_info(
                &p_irat_cdma2000_info_to_cellm-> \
                cdma2000_cell_param,
                &p_irat_cdma2000_info_from_oam-> \
                cdma2000_cell_param);

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG)
    {
        fill_irat_cdma2000_v920_info(
                &p_irat_cdma2000_info_to_cellm-> \
                inter_rat_parameters_cdma2000_v920,
                &p_irat_cdma2000_info_from_oam-> \
                inter_rat_parameters_cdma2000_v920);


        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_IRAT_PARAMS_CDMA2000_V920_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG)
    {
        fill_cell_reselection_params_cdma2000(
                &p_irat_cdma2000_info_to_cellm->cell_reselection_params_hrpd,
                &p_irat_cdma2000_info_from_oam->cell_reselection_params_hrpd);

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_CELL_RESEL_PARAMS_HRPD_CDMA2000_PRESENCE_FLAG;
    }

    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG)
    {
        fill_cell_reselection_params_cdma2000(
                &p_irat_cdma2000_info_to_cellm->cell_reselection_params_1xrtt,
                &p_irat_cdma2000_info_from_oam->cell_reselection_params_1xrtt);

        p_irat_cdma2000_info_to_cellm->presence_bitmask |= \
                                                           RRMCM_RMIF_CELL_RESEL_PARAMS_1XRTT_CDMA2000_PRESENCE_FLAG;
    }

    /* SPR 6008 */
    if(p_irat_cdma2000_info_from_oam->presence_bitmask &
            RRM_OAM_SYSTEM_TIME_INFO_PRESENCE_FLAG)
    {
        switch(p_irat_cdma2000_info_from_oam->system_time_info)
        {
            case RRM_OAM_SYN_SYS_TIME:
                p_irat_cdma2000_info_to_cellm->system_time_info = 
                    RRM_OAM_SYN_SYS_TIME;
                break;
            case RRM_OAM_ASYN_SYS_TIME:
                p_irat_cdma2000_info_to_cellm->system_time_info = 
                    RRM_OAM_ASYN_SYS_TIME;
                break;
            default:
                p_irat_cdma2000_info_to_cellm->system_time_info =
                    RRM_OAM_SYN_SYS_TIME;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "Wrong value of SYSTEM_TIME_INFO Recvd, so setting it to\
                        RRM_OAM_SYN_SYS_TIME");
        }
        p_irat_cdma2000_info_to_cellm->presence_bitmask |= 
            RRMCM_RMIF_SYSTEM_TIME_INFO_PRESENCE_FLAG;
    }
    /* SPR 6008 */

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_irat_eutra_geran_carrier_freq_list_info
 * Inputs         : - p_irat_carrier_freq_info_to_cellm
 *                  - p_irat_carrier_freq_info_from_oam
 *                  - p_ran_info_from_oam 
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the geran carrier freq info for CellM module.
 ****************************************************************************/
void fill_irat_eutra_geran_carrier_freq_list_info
(irat_eutran_geran_list_t                
 *p_irat_carrier_freq_info_list_to_cellm, 
 rrm_oam_carrier_freq_geran_param_list_t 
 *p_irat_carrier_freq_info_list_from_oam,
 rrm_oam_ran_t               *p_ran_info_from_oam)
{
    //U8 fdd_carrier_count = 0;
    U8            index   = 0;
    U8              exp_arfcn_index = 0;
    U8              arfcn_bmp_index = 0;


    RRM_ASSERT (RRM_PNULL != p_irat_carrier_freq_info_list_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_carrier_freq_info_list_from_oam);

    RRM_UT_TRACE_ENTER();

    p_irat_carrier_freq_info_list_to_cellm->num_irat_eutran_to_geran_carriers =
        p_irat_carrier_freq_info_list_from_oam->count_geran_carrier;

    for(index = 0; 
            (index < p_irat_carrier_freq_info_list_to_cellm->
             num_irat_eutran_to_geran_carriers\
             && p_irat_carrier_freq_info_list_to_cellm->\
             num_irat_eutran_to_geran_carriers <= MAX_GERAN_FREQ);
            index++)
    {
        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].bitmask = 0x00;

        /* ncc_peritted */
        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].ncc_permitted =\
            p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
            common_info.ncc_peritted[0];

        /* q_rx_lev_min */
        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].q_rx_lev_min =\
            p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
            common_info.q_rx_lev_min;

        /* thres_x_high */
        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].threshX_high =\
            p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
            common_info.\
            thres_x_high;

        /* thres_x_low */            
        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].threshX_low =\
            p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
            common_info.\
            thres_x_low;


        /* cell_reselection_priority*/
        if(RRM_OAM_CARRIER_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].
                common_info.\
                present_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].bitmask |= \
                RRMCM_GERAN_CFI_CELL_RESELECTION_PRIORITY_PRESENT;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].cell_reselection_priority =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].
                common_info.\
                cell_reselection_priority;
        }

        if(RRM_OAM_CARRIER_GERAN_P_MAX_GERAN_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                common_info.\
                present_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].bitmask |=\
                RRMCM_GERAN_P_MAX_GERAN_PRESENT;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].p_max_geran =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                common_info.\
                p_max_geran;
        }

        /* OFFSET CHANGES */
        if(RRM_OAM_CARRIER_GERAN_OFFSET_FREQ_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                common_info.\
                present_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].offset_freq =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                common_info.\
                offset_freq;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].bitmask |=\
                RRMCM_GERAN_OFFSET_FREQ_PRESENT;
        }
        else if(((RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT) == 
                    (p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT)) &&
                ((RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT) == 
                 (p_ran_info_from_oam->connected_mode_mobility_params.bitmask & 
                  RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "2. RRM_OAM_OFFSET_FREQ_PRESENT");
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].offset_freq =\
                p_ran_info_from_oam->connected_mode_mobility_params.irat.q_offset_geran;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].bitmask |=\
                RRMCM_GERAN_OFFSET_FREQ_PRESENT;
        }

        /* end */ 

        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].geran_car_freqs.\
            starting_arfcn =\
            p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
            carrier_freq.\
            starting_arfcn;

        /* filling band indicator */ 
        switch(p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.band_indicator)
        {
            case RRM_OAM_DCS1800:
                p_irat_carrier_freq_info_list_to_cellm->\
                    irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                    band_ind = RRM_SON_GERAN_DCS_1800;
                break;
            case RRM_OAM_PCS1900:
                p_irat_carrier_freq_info_list_to_cellm->\
                    irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                    band_ind = RRM_SON_GERAN_PCS_1900;
                break;
            default:
                /* Coverity_ID : 16462 start */
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,\
                        "Invalid value[%d] recieved for carrier freq band indicator from OAM so \
                        assigning RRM_SON_GERAN_DCS_1800 by default",p_irat_carrier_freq_info_list_from_oam->\
                        carrier_list[index].carrier_freq.band_indicator);
                p_irat_carrier_freq_info_list_to_cellm->\
                    irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                    /* coverity : CID 16462*/
                    band_ind = RRM_SON_GERAN_DCS_1800;
                /* Coverity_ID : 16462 end */
                break;
        } 

        p_irat_carrier_freq_info_list_to_cellm->\
            irat_eutran_to_geran_carriers[index].geran_car_freqs.\
            following_arfcns.bitmask = 0x00;

        if(RRM_OAM_GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.\
                following_arfcn.presence_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.bitmask = 0;
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.bitmask |=\
                RRM_SON_MC_GERAN_EXP_ARFCN_SET_PRESENT;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.exp_arfcn_list_size =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.following_arfcn.explicit_list_of_arfcns.\
                count_explicit_arfcn;


            for (exp_arfcn_index = 0;
                    exp_arfcn_index < RRM_SON_MAX_GERAN_EXP_ARFCN_LIST_SIZE;
                    exp_arfcn_index++)
            {
                p_irat_carrier_freq_info_list_to_cellm->\
                    irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                    following_arfcns.exp_arfcn_list[exp_arfcn_index] =\
                    p_irat_carrier_freq_info_list_from_oam->\
                    carrier_list[index].\
                    carrier_freq.following_arfcn.explicit_list_of_arfcns.\
                    data_explicit_arfcn[exp_arfcn_index];
            } 
        }

        if(RRM_OAM_GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->\
                carrier_list[index].carrier_freq.\
                following_arfcn.presence_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.bitmask |=\
                RRM_SON_MC_GERAN_EQ_SP_ARFCN_SET_PRESENT;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.arfcn_spacing =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.following_arfcn.equally_spaced_arfcns.\
                arfcn_spacing;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.num_of_following_arfcn =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.following_arfcn.equally_spaced_arfcns.\
                num_of_following_arfcns;
        }

        if(RRM_OAM_GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG &\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.\
                following_arfcn.presence_bitmask)
        {
            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.bitmask |=\
                RRM_SON_MC_GERAN_ARFCN_BITMAP_SET_PRESSENT;

            p_irat_carrier_freq_info_list_to_cellm->\
                irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                following_arfcns.arfcn_bmp_list_size =\
                p_irat_carrier_freq_info_list_from_oam->carrier_list[index].\
                carrier_freq.following_arfcn.var_bitmap_of_arfcns.\
                count_var_bit_map;

            for (arfcn_bmp_index = 0;
                    arfcn_bmp_index < RRM_SON_MAX_NUM_OF_OCTETS_IN_VAR_BITMAP;
                    arfcn_bmp_index++)
            {
                p_irat_carrier_freq_info_list_to_cellm->\
                    irat_eutran_to_geran_carriers[index].geran_car_freqs.\
                    following_arfcns.arfcn_bmp_list[arfcn_bmp_index] =\
                    p_irat_carrier_freq_info_list_from_oam->\
                    carrier_list[index].\
                    carrier_freq.following_arfcn.var_bitmap_of_arfcns.\
                    data_var_bitmap[arfcn_bmp_index];
            }
        }  


    }          

    RRM_UT_TRACE_EXIT();
}


/********************************************************************************
 * Function Name  : fill_irat_eutra_geran_reselection_info
 * Inputs         : - p_irat_reselection_info_from_oam
 *                  - p_irat_reselection_info_to_cellm
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the irat reselection info for CellM module.
 **********************************************************************************/
void fill_irat_eutra_geran_reselection_info
(irat_eutra_geran_reselection_params_t 
 *p_irat_reselection_info_to_cellm,
 rrm_oam_idle_mode_mobility_irat_eutra_to_geran_reselection_params_t  
 *p_irat_reselection_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_irat_reselection_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_reselection_info_from_oam);

    RRM_UT_TRACE_ENTER();

    p_irat_reselection_info_to_cellm->t_reselection_geran =\
                                                           p_irat_reselection_info_from_oam->t_reselection_geran;

    if (RRM_OAM_T_RESELECTION_GERAN_SPEED_SCALE_FACTOR_PRESENT &\
            p_irat_reselection_info_from_oam->bitmask)
    {
        p_irat_reselection_info_to_cellm->bitmask = 0;

        p_irat_reselection_info_to_cellm->bitmask |=\
                                                    RRMCM_RMIF_EUTRA_GERAN_RESELECTION_SPEED_STATE_PARAMS_PRESENT;

        switch(p_irat_reselection_info_from_oam->speed_scale_factors.\
                t_reselection_eutra_sf_medium)
        {
            case RRM_OAM_O_DOT_25:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_medium =\
                    RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_medium =\
                    RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_medium =\
                    RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_medium =\
                    RRM_OAM_l_DOT_0;
                break;
            default:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_medium =\
                    p_irat_reselection_info_from_oam->speed_scale_factors.\
                    t_reselection_eutra_sf_medium;
                break;
        }

        switch(p_irat_reselection_info_from_oam->speed_scale_factors.\
                t_reselection_eutra_sf_high)
        {
            case RRM_OAM_O_DOT_25:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_high =\
                    RRM_OAM_O_DOT_25;
                break;
            case RRM_OAM_O_DOT_5:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_high =\
                    RRM_OAM_O_DOT_5;
                break;
            case RRM_OAM_O_DOT_75:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_high =\
                    RRM_OAM_O_DOT_75;
                break;
            case RRM_OAM_l_DOT_0:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_high =\
                    RRM_OAM_l_DOT_0;
                break;
            default:
                p_irat_reselection_info_to_cellm->speed_state_scale_factor.\
                    t_reselection_eutra_sf_high =\
                    p_irat_reselection_info_from_oam->speed_scale_factors.\
                    t_reselection_eutra_sf_high;
                break;
        }
    }

    RRM_UT_TRACE_EXIT();
}


/******************************************************************************
 * Function Name  : fill_idle_mode_mobility_irat_geran_info
 * Inputs         : - p_irat_utra_info_to_cellm
 *                  - p_irat_utra_info_from_oam
 *                  - p_ran_info_from_oam 
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the mobility IRAT Info for CellM module.
 ********************************************************************************/
void fill_idle_mode_mobility_irat_geran_info
(idle_mode_mobility_irat_geran_params_t 
 *p_irat_geran_info_to_cellm,
 rrm_oam_idle_mode_mobility_inter_rat_geran_params_t 
 *p_irat_geran_info_from_oam,
 rrm_oam_ran_t               *p_ran_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_irat_geran_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_geran_info_from_oam);
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);

    RRM_UT_TRACE_ENTER();

    /*populating reselection params */
    fill_irat_eutra_geran_reselection_info
        (&p_irat_geran_info_to_cellm->irat_eutra_to_geran_reselection_params,
         &p_irat_geran_info_from_oam->geran_reselection_params);

    /*populating fdd list */
    p_irat_geran_info_to_cellm->bitmask = 0x00;

    if (p_irat_geran_info_from_oam->bitmask & 
            RRM_OAM_GERAN_CARRIER_FREQ_PARAMETER)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRM_OAM_IRAT_EUTRAN_GERAN_LIST_PRESENT");

        fill_irat_eutra_geran_carrier_freq_list_info
            (&p_irat_geran_info_to_cellm->irat_eutran_to_geran_list,
             &p_irat_geran_info_from_oam->carrier_freq_info_list,
             p_ran_info_from_oam);
        p_irat_geran_info_to_cellm->bitmask |= 
            RRMCM_RMIF_IRAT_EUTRAN_GERAN_FREQ_LIST_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}

/********************************************************************************
 * Function Name  : fill_irat_eutra_utran_reselction_info
 * Inputs         : - p_irat_reselection_info_from_oam
 *                  - p_irat_reselection_info_to_cellm
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the irat reselection info for CellM module.
 *********************************************************************************/
void fill_irat_eutra_utran_reselction_info(irat_eutra_utra_reselection_params_t                                *p_irat_reselection_info_to_cellm,
        rrm_oam_idle_mode_mobility_irat_eutra_to_utra_reselection_params_t  *p_irat_reselection_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_irat_reselection_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_reselection_info_from_oam);

    RRM_UT_TRACE_ENTER();

    p_irat_reselection_info_to_cellm->t_reselection_utra = 
        p_irat_reselection_info_from_oam->t_reselection_utra;

    if (p_irat_reselection_info_from_oam->bitmask& 
            RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT) 
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT");
        p_irat_reselection_info_to_cellm->speed_state_scale_factor.
            t_reselection_eutra_sf_medium = 
            p_irat_reselection_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_medium;

        p_irat_reselection_info_to_cellm->speed_state_scale_factor.
            t_reselection_eutra_sf_high=
            p_irat_reselection_info_from_oam->speed_scale_factors.
            t_reselection_eutra_sf_high;

        p_irat_reselection_info_to_cellm->bitmask |= 
            RRMCM_RMIF_EUTRA_UTRA_RESELECTION_SPEED_STATE_PARAMS_PRESENT;  
    }

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_irat_eutra_utran_tdd_list_info
 * Inputs         : - p_irat_tdd_list_info_to_cellm
 *                  - p_irat_tdd_list_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the irat tdd list Info for CellM module.
 ****************************************************************************/
void fill_irat_eutra_utran_tdd_list_info(irat_eutran_utran_tdd_list_t            *p_irat_tdd_list_info_to_cellm, 
        rrm_oam_irat_eutran_to_utran_tdd_list_t *p_irat_tdd_list_info_from_oam)
{
    U8 tdd_carrier_count = 0;

    RRM_ASSERT (RRM_PNULL != p_irat_tdd_list_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_tdd_list_info_from_oam);

    RRM_UT_TRACE_ENTER();

    p_irat_tdd_list_info_to_cellm->num_irat_eutran_to_utran_tdd_carriers = 
        p_irat_tdd_list_info_from_oam->num_irat_eutran_to_utran_tdd_carriers;

    for (tdd_carrier_count = 0; 
            ((tdd_carrier_count < p_irat_tdd_list_info_to_cellm->num_irat_eutran_to_utran_tdd_carriers) &&
             (tdd_carrier_count < MAX_NO_EUTRAN_TO_UTRAN_TDD)); tdd_carrier_count++)
    {
        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].utra_carrier_arfcn =
            p_irat_tdd_list_info_from_oam->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].utra_carrier_arfcn;

        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].q_rx_lev_min =
            p_irat_tdd_list_info_from_oam->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].q_rx_lev_min;

        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].bitmask = 0x00;

        if (p_irat_tdd_list_info_from_oam->
                irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].bitmask& 
                RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT");
            p_irat_tdd_list_info_to_cellm->
                irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].cell_reselection_priority =
                p_irat_tdd_list_info_from_oam->
                irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].cell_reselection_priority;
            p_irat_tdd_list_info_to_cellm->
                irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].bitmask |= 
                RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT;
        } 

        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].thresh_x_high = 
            p_irat_tdd_list_info_from_oam->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].threshold_x_high;
        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].thresh_x_low =
            p_irat_tdd_list_info_from_oam->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].threshold_x_low;
        p_irat_tdd_list_info_to_cellm->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].p_max_utra =
            p_irat_tdd_list_info_from_oam->
            irat_eutran_to_utran_tdd_carriers[tdd_carrier_count].p_max_utra;
    }/*for loop ends*/

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_irat_eutra_utran_fdd_list_info
 * Inputs         : - p_irat_fdd_list_info_to_cellm
 *                  - p_irat_fdd_list_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the irat fdd list Info for CellM module.
 ****************************************************************************/
void fill_irat_eutra_utran_fdd_list_info(irat_eutran_utran_fdd_list_t            *p_irat_fdd_list_info_to_cellm, 
        /* CSR_00057814_CHANGES_START */
        rrm_oam_irat_eutran_to_utran_fdd_list_t *p_irat_fdd_list_info_from_oam,
        rrm_oam_ran_t                           *p_ran_info_from_oam)
/* CSR_00057814_CHANGES_END */
{
    U8 fdd_carrier_count = 0;

    RRM_ASSERT (RRM_PNULL != p_irat_fdd_list_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_irat_fdd_list_info_from_oam);
    /* CSR_00057814_CHANGES_START */
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    /* CSR_00057814_CHANGES_END */

    RRM_UT_TRACE_ENTER();

    p_irat_fdd_list_info_to_cellm->num_irat_eutran_to_utran_fdd_carriers = 
        p_irat_fdd_list_info_from_oam->num_irat_eutran_to_utran_fdd_carriers;

    for (fdd_carrier_count = 0; 
            (fdd_carrier_count < p_irat_fdd_list_info_to_cellm->num_irat_eutran_to_utran_fdd_carriers&&
             (fdd_carrier_count < MAX_NO_EUTRAN_TO_UTRAN_FDD)); fdd_carrier_count++)
    {
        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].utra_carrier_arfcn=
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].utra_carrier_arfcn;

        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].q_rx_lev_min=
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].q_rx_lev_min;

        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].q_qual_min=
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].q_qual_min;

        if (p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask& 
                RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "RRM_OAM_CELL_RESELECT_PRIORITY_PRESENT");
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].cell_reselection_priority=
                p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].cell_reselection_priority;
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask|= 
                RRMCM_RMIF_CELL_RESELECT_PRIORITY_PRESENT;
        } 

        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].thresh_x_high= 
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].thresh_x_high;
        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].thresh_x_low=
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].thresh_x_low;
        p_irat_fdd_list_info_to_cellm->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].p_max_utra=
            p_irat_fdd_list_info_from_oam->
            irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].p_max_utra;

        if (p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask& 
                RRM_OAM_THRESHOLD_Q_R9_T_PRESENT)
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_THRESHX_Q_R9_PRESENT");
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].threshx_q_r9.thresh_serving_highq_r9=
                p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].threshx_q_r9.thresh_serving_highq_r9;
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].threshx_q_r9.thresh_serving_lowq_r9=
                p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].threshx_q_r9.thresh_serving_lowq_r9;

            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask |= 
                RRMCM_RMIF_THRESHX_Q_R9_PRESENT; 
        }
        /* OFFSET CHANGES */
        /*Coverity_fix_start_54935*/
        if (p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask&
                RRM_OAM_OFFSET_FREQ_PRESENT)
            /*Coverity_fix_end_54935*/     
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_OFFSET_FREQ_PRESENT");
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].offset_freq=
                p_irat_fdd_list_info_from_oam->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].offset_freq;
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask|=
                RRMCM_RMIF_OFFSET_FREQ_PRESENT;
        }
        /* Coverity 54935 fix end */
        /* CSR_00057814_CHANGES_START */
        else if(((RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT) == 
                    (p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT)) &&
                ((RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT) == 
                 (p_ran_info_from_oam->connected_mode_mobility_params.bitmask & 
                  RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "1. RRM_OAM_OFFSET_FREQ_PRESENT");
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].offset_freq =
                p_ran_info_from_oam->connected_mode_mobility_params.irat.qoffset_tutra;
            p_irat_fdd_list_info_to_cellm->
                irat_eutran_to_utran_fdd_carriers[fdd_carrier_count].bitmask|=
                RRMCM_RMIF_OFFSET_FREQ_PRESENT;
        }
        /* CSR_00057814_CHANGES_END */

    }/*for loop ends*/

    RRM_UT_TRACE_EXIT(); /* Coverity: CID 54935 */
}

/******************************************************************************
 * Function Name  : fill_idle_mode_mobility_irat_utra_info
 * Inputs         : - p_irat_utra_info_to_cellm
 *                  - p_irat_utra_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the mobility IRAT Info for CellM module.
 *******************************************************************************/
void fill_idle_mode_mobility_irat_utra_info(idle_mode_mobility_irat_utra_params_t *p_irat_utra_info_to_cellm, 
        /* CSR_00057814_CHANGES_START */
        rrm_oam_idle_mode_mobility_inter_rat_utra_params_t *p_irat_utra_info_from_oam,
        rrm_oam_ran_t               *p_ran_info_from_oam)
/* CSR_00057814_CHANGES_END */
{
    RRM_ASSERT (RRM_PNULL != p_irat_utra_info_to_cellm); 
    RRM_ASSERT (RRM_PNULL != p_irat_utra_info_from_oam);
    /* CSR_00057814_CHANGES_START */
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    /* CSR_00057814_CHANGES_END */

    RRM_UT_TRACE_ENTER();

    /*populating reselection params */
    fill_irat_eutra_utran_reselction_info(&p_irat_utra_info_to_cellm->irat_eutra_to_utra_reselection_params,
            &p_irat_utra_info_from_oam->irat_eutra_to_utra_reselection_params);

    /*populating tdd list */
    if (p_irat_utra_info_from_oam->bitmask & RRM_OAM_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT");

        fill_irat_eutra_utran_tdd_list_info(&p_irat_utra_info_to_cellm->irat_eutran_to_utran_tdd_list,
                &p_irat_utra_info_from_oam->irat_eutran_to_utran_tdd_list);
        p_irat_utra_info_to_cellm->bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_TDD_LIST_PRESENT;
    }

    /*populating fdd list */
    if (p_irat_utra_info_from_oam->bitmask & RRM_OAM_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT");

        fill_irat_eutra_utran_fdd_list_info(&p_irat_utra_info_to_cellm->irat_eutran_to_utran_fdd_list,
                /* CSR_00057814_CHANGES_START */
                &p_irat_utra_info_from_oam->irat_eutran_to_utran_fdd_list,
                p_ran_info_from_oam);
        /* CSR_00057814_CHANGES_END */
        p_irat_utra_info_to_cellm->bitmask |= RRMCM_RMIF_IRAT_EUTRAN_UTRAN_FDD_LIST_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_mobility_info_for_cell_reconfig
 * Inputs         : - p_mob_info_to_cellm
 *                  - p_mob_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Mobility Info for CellM module.
 ****************************************************************************/
void fill_mobility_info_for_cell_reconfig(mobility_params_t          *p_mob_info_to_cellm, 
        /* CSR_00057814_CHANGES_START */
        rrm_oam_mobility_params_t  *p_mob_info_from_oam,
        rrm_oam_ran_t               *p_ran_info_from_oam)
/* CSR_00057814_CHANGES_END */
{
    U16  inter_freq_param_count = RRM_ZERO;
    common_params_t                       *comPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_common_params_t               *comPramsp_mob_info_from_oam = RRM_NULL;
    intra_freq_params_t                   *intraFreqPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_intra_freq_params_t           *intraFreqPramsp_mob_info_from_oam = RRM_NULL; 
    inter_freq_params_t                   *interFreqPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_inter_freq_params_t           *interFreqPramsp_mob_info_from_oam = RRM_NULL;

    RRM_ASSERT (RRM_PNULL != p_mob_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_mob_info_from_oam);
    /* CSR_00057814_CHANGES_START */
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    /* CSR_00057814_CHANGES_END */

    RRM_UT_TRACE_ENTER();

    /* Populationg Mobility Parameters */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Mobility Information");
    p_mob_info_to_cellm->bitmask = 0x00;

    if( p_mob_info_from_oam->bitmask & RRM_OAM_IDLE_MODE_MOBILITY_PARAMS_PRESENT)
    {
        /* idle mode mobility common params - start */
        p_mob_info_to_cellm->idle_mode_mobility_params.bitmask = 0x00;
        if(p_mob_info_from_oam->idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT )
        {
            comPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
                idle_mode_mobility_common_params;
            comPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.
                idle_mode_mobility_common_params;

            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
            fill_cellm_comPramsp_mob_info(comPramsp_mob_info_from_oam , comPramsp_mob_info_to_cellm);
            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_RMIF_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT;
        }
        /* common params - end */

        /*idle mode mobility intra freq params - start*/
        if(p_mob_info_from_oam->idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_INTRA_FREQ_PRESENT )
        {
            intraFreqPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params;
            intraFreqPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.
                idle_mode_mobility_intra_freq_params;

            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
            fill_cellm_intraFreqPramsp_mob_info(intraFreqPramsp_mob_info_from_oam , intraFreqPramsp_mob_info_to_cellm);
            /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS;
        }
        /*idle mode mobility intra freq params - end*/

        /*inter freq params - start*/
        if(p_mob_info_from_oam->idle_mode_mobility_params.bitmask & RRM_OAM_IDLE_MODE_MOBILITY_INTER_FREQ_PRESENT )
        {

            p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list=
                p_mob_info_from_oam->idle_mode_mobility_params.
                idle_mode_inter_freq_params_list.num_valid_inter_freq_list;

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "No of Inter Freq [%d]",
                    p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list);

            for (inter_freq_param_count = 0;
                    ((inter_freq_param_count<p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list)&&
                     (inter_freq_param_count < MAX_NO_INTER_FREQ)); inter_freq_param_count++)
            {
                interFreqPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
                    idle_mode_mobility_inter_freq_params[inter_freq_param_count];
                interFreqPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.idle_mode_inter_freq_params_list.
                    idle_mode_mobility_inter_freq_params[inter_freq_param_count];
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
                fill_cellm_interFreqPramsp_mob_info(interFreqPramsp_mob_info_from_oam , interFreqPramsp_mob_info_to_cellm);
                /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

            }/*for loop ends here*/
            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_MIF_IDLE_MODE_MOBILITY_INTER_FREQ_PARAMS;
        }
        /*inter freq params - end*/

        /*populating irat utra params */
        if (p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
                RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT");
            fill_idle_mode_mobility_irat_utra_info(
                    &p_mob_info_to_cellm->idle_mode_mobility_params.
                    idle_mode_mobility_irat_utra_params,
                    &p_mob_info_from_oam->idle_mode_mobility_params.
                    /* CSR_00057814_CHANGES_START */
                    idle_mode_mobility_inter_rat_utra_params,
                    p_ran_info_from_oam);
            /* CSR_00057814_CHANGES_END */

            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask|= 
                RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT; 
        }

        /*populating irat geran params */
        if (p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
                RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT");
            fill_idle_mode_mobility_irat_geran_info(
                    &p_mob_info_to_cellm->idle_mode_mobility_params.
                    idle_mode_mobility_irat_geran_params,
                    &p_mob_info_from_oam->idle_mode_mobility_params.
                    idle_mode_mobility_inter_rat_geran_params,
                    p_ran_info_from_oam);

            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask|= 
                RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT; 
        }

        /*populating irat cdma2000 params */
        if(p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
                RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                    "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT");
            fill_idle_mode_mobility_irat_cdma2000_info(
                    &p_mob_info_to_cellm->idle_mode_mobility_params. \
                    idle_mode_mobility_irat_cdma_params, 
                    &p_mob_info_from_oam->idle_mode_mobility_params. \
                    idle_mode_mobility_inter_rat_cdma2000_params);

            p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= \
                                                                      RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT;
        }
        p_mob_info_to_cellm->bitmask |= RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT;
    } 
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_rrc_timer_constant_info_cell_config
 * Inputs         : - p_timer_info_to_cellm
 *                  - p_timer_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the RRC Timer & constants for 
 *                  CellM module
 ****************************************************************************/
void fill_rrc_timer_constant_info_cell_config(rrc_timers_and_constants_t         *p_timer_info_to_cellm, 
        rrm_oam_rrc_timers_and_constants_t *p_timer_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_timer_info_to_cellm); 
    RRM_ASSERT (RRM_PNULL != p_timer_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating RRC Timer & COnstants"); 

    /* RRC Timers*/
    p_timer_info_to_cellm->bitmask = 0x00;
    p_timer_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_TIMERS_PRESENT;
    p_timer_info_to_cellm->rrc_timers.t300 = p_timer_info_from_oam->rrc_timers.t300;
    p_timer_info_to_cellm->rrc_timers.t301 = p_timer_info_from_oam->rrc_timers.t301;
    p_timer_info_to_cellm->rrc_timers.t302 = p_timer_info_from_oam->rrc_timers.t302;
    p_timer_info_to_cellm->rrc_timers.t304_eutra = 
        p_timer_info_from_oam->rrc_timers.t304_eutra;
    p_timer_info_to_cellm->rrc_timers.t304_irat = 
        p_timer_info_from_oam->rrc_timers.t304_irat;
    p_timer_info_to_cellm->rrc_timers.t310 = p_timer_info_from_oam->rrc_timers.t310;
    p_timer_info_to_cellm->rrc_timers.t311 = p_timer_info_from_oam->rrc_timers.t311;
    p_timer_info_to_cellm->rrc_timers.t320 = p_timer_info_from_oam->rrc_timers.t320;

    /* RRC Constants*/
    p_timer_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_CONSTANTS_PRESENT;
    /* coverity : CID 16500*/
    /* SPR: 20859 Fix - Start */ 
    /* putting a check on the highest value of enum i.e. 7 */
    if(RRM_SEVEN >= p_timer_info_from_oam->rrc_constants.n310)
    {
        /* Coverity 69746 Fix Start */
        p_timer_info_to_cellm->rrc_constants.n310 = p_timer_info_from_oam->rrc_constants.n310;
        /* Coverity 69746 Fix Start */
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Value of rrc_constants.n310 exceeding 7 which is the highest value of enum"); 
    }
    /* SPR: 20859 Fix - End */ 
    /* coverity : CID 16501*/
    /* SPR: 20859 Fix - Start */ 
    /* putting a check on the highest value of enum i.e. 7 */
    if(RRM_SEVEN >= p_timer_info_from_oam->rrc_constants.n311)
    {
        /* Coverity 69745 Fix Start */
        p_timer_info_to_cellm->rrc_constants.n311 = p_timer_info_from_oam->rrc_constants.n311;
        /* Coverity 69745 Fix End */
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Value of rrc_constants.n311 exceeding 7 which is the highest value of enum"); 
    }
    /* SPR: 20859 Fix - End */ 
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_rrc_timer_constant_info_cell_reconfig
 * Inputs         : - p_timer_info_to_cellm
 *                  - p_timer_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the RRC Timer & constants for 
 *                  CellM module
 ****************************************************************************/
void fill_rrc_timer_constant_info_cell_reconfig(rrc_timers_and_constants_t         *p_timer_info_to_cellm, 
        rrm_oam_rrc_timers_and_constants_t *p_timer_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_timer_info_to_cellm); 
    RRM_ASSERT (RRM_PNULL != p_timer_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating RRC Timer & COnstants"); 

    /* RRC Timers*/
    p_timer_info_to_cellm->bitmask = 0x00;
    if(p_timer_info_from_oam->bitmask & RRM_OAM_RRC_TIMERS_PRESENT)
    {
        p_timer_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_TIMERS_PRESENT;
        p_timer_info_to_cellm->rrc_timers.t300 = p_timer_info_from_oam->rrc_timers.t300;
        p_timer_info_to_cellm->rrc_timers.t301 = p_timer_info_from_oam->rrc_timers.t301;
        p_timer_info_to_cellm->rrc_timers.t302 = p_timer_info_from_oam->rrc_timers.t302;
        p_timer_info_to_cellm->rrc_timers.t304_eutra = 
            p_timer_info_from_oam->rrc_timers.t304_eutra;
        p_timer_info_to_cellm->rrc_timers.t304_irat = 
            p_timer_info_from_oam->rrc_timers.t304_irat;
        p_timer_info_to_cellm->rrc_timers.t310 = p_timer_info_from_oam->rrc_timers.t310;
        p_timer_info_to_cellm->rrc_timers.t311 = p_timer_info_from_oam->rrc_timers.t311;
        p_timer_info_to_cellm->rrc_timers.t320 = p_timer_info_from_oam->rrc_timers.t320;
    }

    if(p_timer_info_from_oam->bitmask & RRM_OAM_RRC_CONSTANTS_PRESENT)
    {
        /* RRC Constants*/
        p_timer_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_CONSTANTS_PRESENT;
        /* Coverity 69745,69746 Fix Start  */
        /* SPR: 20859 Fix - Start */
        /* putting a check on the highest value of enum i.e. 7 */
        if(RRM_SEVEN >= p_timer_info_from_oam->rrc_constants.n310)
        {
            p_timer_info_to_cellm->rrc_constants.n310 = p_timer_info_from_oam->rrc_constants.n310;
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                    "Value of rrc_constants.n310 exceeding 7 which is the highest value of enum"); 
        }
        /* putting a check on the highest value of enum i.e. 7 */
        if(RRM_SEVEN >= p_timer_info_from_oam->rrc_constants.n311)
        {
            p_timer_info_to_cellm->rrc_constants.n311 = p_timer_info_from_oam->rrc_constants.n311;
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                    "Value of rrc_constants.n311 exceeding 7 which is the highest value of enum"); 
        }
        /* SPR: 20859 Fix - End */
        /* Coverity 69745,69746 Fix End  */
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_rf_info
 * Inputs         : - p_rf_info_to_cellm
 *                  - p_rf_info_from_oam
 *                  - p_ran_cfg_params
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the RF info for CellM module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_rf_info(rf_params_t         *p_rf_info_to_cellm,
        rrm_oam_rf_params_t *p_rf_info_from_oam
        )
    /* SPR 20653 Fix End */
{
    RRM_ASSERT (RRM_PNULL != p_rf_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_rf_info_from_oam);

    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating RF Info");

    /*Bug 602 Fix Start */
    p_rf_info_to_cellm->rf_configurations.bitmask = 0x00;
    /*Bug 602 Fix End */

    p_rf_info_to_cellm->rf_configurations.frequency_band_indicator= 
        p_rf_info_from_oam->rf_configurations.frequency_band_indicator; 

    p_rf_info_to_cellm->rf_configurations.dl_earfcn=
        p_rf_info_from_oam->rf_configurations.dl_earfcn; 

    /*Bug 602 Fix Start */
    if (RRM_OAM_RF_CONFIGURATION_UL_EARFCN_PRESENT == 
            (p_rf_info_from_oam->rf_configurations.bitmask & RRM_OAM_RF_CONFIGURATION_UL_EARFCN_PRESENT))
    {
        p_rf_info_to_cellm->rf_configurations.bitmask |=
            RRMCM_RMIF_RF_CONFIGURATION_UL_EARFCN_PRESENT;
        p_rf_info_to_cellm->rf_configurations.ul_earfcn=
            p_rf_info_from_oam->rf_configurations.ul_earfcn; 
    } 
    /*Bug 602 Fix End */
    p_rf_info_to_cellm->rf_configurations.dl_bandwidth=
        p_rf_info_from_oam->rf_configurations.dl_bandwidth; 

    /*Bug 602 Fix Start */
    if (RRM_OAM_RF_CONFIGURATION_UL_BW_PRESENT == 
            (p_rf_info_from_oam->rf_configurations.bitmask & RRM_OAM_RF_CONFIGURATION_UL_BW_PRESENT))
    {
        p_rf_info_to_cellm->rf_configurations.bitmask |=
            RRMCM_RMIF_RF_CONFIGURATION_UL_BW_PRESENT;
        p_rf_info_to_cellm->rf_configurations.ul_bandwidth=
            p_rf_info_from_oam->rf_configurations.ul_bandwidth; 
    }
    /*Bug 602 Fix End */
    p_rf_info_to_cellm->rf_configurations.reference_signal_power=
        p_rf_info_from_oam->rf_configurations.reference_signal_power; 

    p_rf_info_to_cellm->rf_configurations.phy_cell_id=
        p_rf_info_from_oam->rf_configurations.phy_cell_id; 

    p_rf_info_to_cellm->rf_configurations.psch_power_offset=
        p_rf_info_from_oam->rf_configurations.psch_power_offset; 

    p_rf_info_to_cellm->rf_configurations.ssch_power_offset=
        p_rf_info_from_oam->rf_configurations.ssch_power_offset; 

    p_rf_info_to_cellm->rf_configurations.pbch_power_offset=
        p_rf_info_from_oam->rf_configurations.pbch_power_offset; 

    /* SPR 20653 Fix Start */
    if (p_rf_info_from_oam->rf_configurations.bitmask & RRM_OAM_MAX_RS_EPRE_PRESENT)
    {
        p_rf_info_to_cellm->rf_configurations.max_rs_epre = 
            p_rf_info_from_oam->rf_configurations.max_rs_epre;
        p_rf_info_to_cellm->rf_configurations.bitmask |= 
            RRMCM_RMIF_MAX_RS_EPRE_PRESENT;
    }
    else
    {
        p_rf_info_to_cellm->rf_configurations.max_rs_epre = RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_RS_EPRE;
        p_rf_info_to_cellm->rf_configurations.bitmask |= RRMCM_RMIF_MAX_RS_EPRE_PRESENT;
    }
    /* SPR 20653 Fix End */

    /*spr_19151_changes_start*/
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /*spr_19151_changes_end*/

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_cdma2000_pz_hyst_params
 * Inputs         : - p_cellm_pz_hyst_params
 *                  - p_oam_pz_hyst_params
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 PZ HYST Info for CellM module
 ****************************************************************************/
rrm_void_t
fill_cdma2000_pz_hyst_params(rrmcm_rmif_pz_hyst_parameters_included_t
        *p_cellm_pz_hyst_params,
        rrm_oam_pz_hyst_parameters_included_t
        *p_oam_pz_hyst_params)
{
    RRM_ASSERT (RRM_PNULL != p_cellm_pz_hyst_params);
    RRM_ASSERT (RRM_PNULL != p_oam_pz_hyst_params);

    RRM_UT_TRACE_ENTER();
    p_cellm_pz_hyst_params->bitmask = 0x00;

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_ENABLD_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_enabled = \
                                                  p_oam_pz_hyst_params->pz_hyst_enabled;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_ENABLD_PRESENT;
    }

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_INFO_INCL_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_info_incl = \
                                                    p_oam_pz_hyst_params->pz_hyst_info_incl;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_INFO_INCL_PRESENT;
    }

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_LIST_LEN_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_list_len = \
                                                   p_oam_pz_hyst_params->pz_hyst_list_len;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_LIST_LEN_PRESENT;
    }

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_ACT_TIMER_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_act_timer = \
                                                    p_oam_pz_hyst_params->pz_hyst_act_timer;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_ACT_TIMER_PRESENT;
    }

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_TIMER_MUL_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_timer_mul = \
                                                    p_oam_pz_hyst_params->pz_hyst_timer_mul;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_TIMER_MUL_PRESENT;
    }

    if(p_oam_pz_hyst_params->bitmask &
            RRM_OAM_PZ_HYST_TIMER_EXP_PRESENT)
    {
        p_cellm_pz_hyst_params->pz_hyst_timer_exp = \
                                                    p_oam_pz_hyst_params->pz_hyst_timer_exp;

        p_cellm_pz_hyst_params->bitmask |= \
                                           RRMCM_RMIF_PZ_HYST_TIMER_EXP_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_cdma2000_fpc_fch_params
 * Inputs         : - p_cellm_fpc_fch_params
 *                  - p_oam_fpc_fch_params
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 fpc fch Info for 
 CellM module
 ****************************************************************************/
rrm_void_t
fill_cdma2000_fpc_fch_params(rrmcm_rmif_fpc_fch_included_t  
        *p_cellm_fpc_fch_params,
        rrm_oam_fpc_fch_included_t
        *p_oam_fpc_fch_params)
{
    RRM_ASSERT (RRM_PNULL != p_cellm_fpc_fch_params);
    RRM_ASSERT (RRM_PNULL != p_oam_fpc_fch_params);

    RRM_UT_TRACE_ENTER();
    p_cellm_fpc_fch_params->bitmask = 0x0;

    if(p_oam_fpc_fch_params->bitmask & \
            RRM_OAM_FPC_FCH_INIT_SETPT_RC3_PRESENT)
    {
        p_cellm_fpc_fch_params->fpc_fch_init_setpt_rc3 = \
                                                         p_oam_fpc_fch_params->fpc_fch_init_setpt_rc3;

        p_cellm_fpc_fch_params->bitmask |= \
                                           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC3_PRESENT;
    }

    if(p_oam_fpc_fch_params->bitmask & \
            RRM_OAM_FPC_FCH_INIT_SETPT_RC4_PRESENT)
    {
        p_cellm_fpc_fch_params->fpc_fch_init_setpt_rc4 = \
                                                         p_oam_fpc_fch_params->fpc_fch_init_setpt_rc4;

        p_cellm_fpc_fch_params->bitmask |= \
                                           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC4_PRESENT;
    }

    if(p_oam_fpc_fch_params->bitmask & \
            RRM_OAM_FPC_FCH_INIT_SETPT_RC5_PRESENT)
    {
        p_cellm_fpc_fch_params->fpc_fch_init_setpt_rc5 = \
                                                         p_oam_fpc_fch_params->fpc_fch_init_setpt_rc5;

        p_cellm_fpc_fch_params->bitmask |= \
                                           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC5_PRESENT;
    }
    /* Bug 12675 Fix Start */
    if(p_oam_fpc_fch_params->bitmask & \
            RRM_OAM_FPC_FCH_INIT_SETPT_RC11_PRESENT)
    {
        p_cellm_fpc_fch_params->fpc_fch_init_setpt_rc11 = \
                                                          p_oam_fpc_fch_params->fpc_fch_init_setpt_rc11;

        p_cellm_fpc_fch_params->bitmask |= \
                                           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC11_PRESENT;
    }

    if(p_oam_fpc_fch_params->bitmask & \
            RRM_OAM_FPC_FCH_INIT_SETPT_RC12_PRESENT)
    {
        p_cellm_fpc_fch_params->fpc_fch_init_setpt_rc12 = \
                                                          p_oam_fpc_fch_params->fpc_fch_init_setpt_rc12;

        p_cellm_fpc_fch_params->bitmask |= \
                                           RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC12_PRESENT;
    }
    /* Bug 12675 Fix Stop */
    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_cdma2000_cell_specific_params
 * Inputs         : - p_cellm_cdma2000_cell_spec_param
 *                  - p_oam_cdma2000_cell_spec_param
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 NCL Info for CellM module
 ****************************************************************************/
rrm_void_t
fill_cdma2000_cell_specific_params(rrmcm_rmif_cell_specific_params_t 
        *p_cellm_cdma2000_cell_spec_param,
        rrm_oam_cell_specific_params_t 
        *p_oam_cdma2000_cell_spec_param)
{
    RRM_ASSERT (RRM_PNULL != p_cellm_cdma2000_cell_spec_param);
    RRM_ASSERT (RRM_PNULL != p_oam_cdma2000_cell_spec_param);

    RRM_UT_TRACE_ENTER();
    p_cellm_cdma2000_cell_spec_param->bitmask = 0x00;

    if(p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_P_REV_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->p_rev = \
                                                  p_oam_cdma2000_cell_spec_param->p_rev;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_P_REV_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_MIN_P_REV_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->min_p_rev = \
                                                      p_oam_cdma2000_cell_spec_param->min_p_rev;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_MIN_P_REV_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->neg_slot_cycle_index_sup = \
                                                                     p_oam_cdma2000_cell_spec_param->neg_slot_cycle_index_sup;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_ENCRYPT_MODE_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->encrypt_mode = \
                                                         p_oam_cdma2000_cell_spec_param->encrypt_mode;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_ENCRYPT_MODE_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_ENC_SUPPORTED_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->enc_supported = \
                                                          p_oam_cdma2000_cell_spec_param->enc_supported;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_ENC_SUPPORTED_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_SIG_ENCRYPT_SUP_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->sig_encrypt_sup = \
                                                            p_oam_cdma2000_cell_spec_param->sig_encrypt_sup;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_SIG_ENCRYPT_SUP_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_MSG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->msg_integrity_sup = \
                                                              p_oam_cdma2000_cell_spec_param->msg_integrity_sup;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_MSG_INTEGRITY_SUP_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->sig_integrity_sup_incl = \
                                                                   p_oam_cdma2000_cell_spec_param->sig_integrity_sup_incl;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_SIG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->sig_integrity_sup = \
                                                              p_oam_cdma2000_cell_spec_param->sig_integrity_sup;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_SIG_INTEGRITY_SUP_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->ms_init_pos_loc_sup_ind = \
                                                                    p_oam_cdma2000_cell_spec_param->ms_init_pos_loc_sup_ind;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_BAND_CLASS_INFO_REQ_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->band_class_info_req = \
                                                                p_oam_cdma2000_cell_spec_param->band_class_info_req;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_BAND_CLASS_INFO_REQ_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_BAND_CLASS_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->band_class = \
                                                       p_oam_cdma2000_cell_spec_param->band_class;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_BAND_CLASS_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_ALT_BAND_CLASS_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->alt_band_class = \
                                                           p_oam_cdma2000_cell_spec_param->alt_band_class;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_ALT_BAND_CLASS_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_TKZ_MODE_SUPPORTED_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->tkz_mode_supported = \
                                                               p_oam_cdma2000_cell_spec_param->tkz_mode_supported;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_TKZ_MODE_SUPPORTED_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_TKZ_ID_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->tkz_id = \
                                                   p_oam_cdma2000_cell_spec_param->tkz_id;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_TKZ_ID_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_T_ADD_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->t_add = \
                                                  p_oam_cdma2000_cell_spec_param->t_add;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_T_ADD_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_PILOT_INC_INCLUDED_PRESENT)
    {
        p_cellm_cdma2000_cell_spec_param->pilot_inc = \
                                                      p_oam_cdma2000_cell_spec_param->pilot_inc;

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_PILOT_INC_INCLUDED_PRESENT;
    }

    if(p_oam_cdma2000_cell_spec_param->bitmask &
            RRM_OAM_PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT)
    {
        fill_cdma2000_pz_hyst_params(&(p_cellm_cdma2000_cell_spec_param-> \
                    pz_hyst_parameters_included),
                &(p_oam_cdma2000_cell_spec_param-> \
                    pz_hyst_parameters_included));

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT;
    }

    if (p_oam_cdma2000_cell_spec_param->bitmask & \
            RRM_OAM_FPC_FCH_INCLUDED_PRESENT)
    {
        fill_cdma2000_fpc_fch_params(&(p_cellm_cdma2000_cell_spec_param-> \
                    fpc_fch_included),
                &(p_oam_cdma2000_cell_spec_param-> \
                    fpc_fch_included));

        p_cellm_cdma2000_cell_spec_param->bitmask |= \
                                                     RRMCM_RMIF_FPC_FCH_INCLUDED_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : rrm_oam_fill_band_class_info_cdma2000
 * Inputs         : - p_cellm_cdma2000_band_class
 *                  - p_oam_cdma2000_band_class
 * Outputs        : None
 * Returns        : void
 * Description    : This function fills the cdma2000 band class Info for 
 CellM module
 ****************************************************************************/
    rrm_void_t
fill_cdma2000_band_class_params(U8 *p_cellm_cdma2000_band_class,
        U8 *p_oam_cdma2000_band_class)
{
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_cellm_cdma2000_band_class);
    RRM_ASSERT (RRM_PNULL != p_oam_cdma2000_band_class);

    switch(*(U8*)p_oam_cdma2000_band_class)
    {
        case RRM_OAM_BAND_CLASS_BC_0:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_0;
            break;

        case RRM_OAM_BAND_CLASS_BC_1:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_1;
            break;

        case RRM_OAM_BAND_CLASS_BC_2:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_2;
            break;

        case RRM_OAM_BAND_CLASS_BC_3:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_3;
            break;

        case RRM_OAM_BAND_CLASS_BC_4:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_4;
            break;

        case RRM_OAM_BAND_CLASS_BC_5:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_5;
            break;

        case RRM_OAM_BAND_CLASS_BC_6:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_6;
            break;

        case RRM_OAM_BAND_CLASS_BC_7:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_7;
            break;

        case RRM_OAM_BAND_CLASS_BC_8:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_8;
            break;

        case RRM_OAM_BAND_CLASS_BC_9:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_9;
            break;

        case RRM_OAM_BAND_CLASS_BC_10:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_10;
            break;

        case RRM_OAM_BAND_CLASS_BC_11:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_11;
            break;

        case RRM_OAM_BAND_CLASS_BC_12:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_12;
            break;

        case RRM_OAM_BAND_CLASS_BC_13:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_13;
            break;

        case RRM_OAM_BAND_CLASS_BC_14:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_14;
            break;

        case RRM_OAM_BAND_CLASS_BC_15:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_15;
            break;

        case RRM_OAM_BAND_CLASS_BC_16:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_16;
            break;

        case RRM_OAM_BAND_CLASS_BC_17:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC_17;
            break;

        case RRM_OAM_BAND_CLASS_BC18_V9A0:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC18_V9A0;
            break;

        case RRM_OAM_BAND_CLASS_BC19_V9A0:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC19_V9A0;
            break;

        case RRM_OAM_BAND_CLASS_BC20_V9A0:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC20_V9A0;
            break;

        case RRM_OAM_BAND_CLASS_BC21_V9A0:
            *(U8*)p_cellm_cdma2000_band_class = RRM_OAM_BAND_CLASS_BC21_V9A0;
            break;

        default:
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,\
                    "rrm_oam_fill_band_class_info_cdma2000: Incorrect \
                    bandclass");
            break;
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : fill_ncl_info_cdma2000
 * Inputs         : - p_ncl_info_to_cellm
 *                  - p_ncl_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the cdma2000 NCL Info for CellM module
 ****************************************************************************/
    rrm_void_t
fill_ncl_info_cdma2000(ncl_params_t          *p_ncl_info_to_cellm,
        rrm_oam_ncl_params_t  *p_ncl_info_from_oam)
{
    U16  cdma2000_cell_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_ncl_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ncl_info_from_oam); 

    RRM_UT_TRACE_ENTER();

    rrmcm_rmif_cdma2000_freq_cells_t *p_cellm_cdma2000_cells = \
                                                               p_ncl_info_to_cellm->inter_rat_ncl.cdma2000_freq_cells;

    rrm_oam_cdma2000_freq_cells_t *p_oam_cdma2000_cells = \
                                                          p_ncl_info_from_oam->inter_rat_ncl.cdma2000_freq_cells;

    p_ncl_info_to_cellm->inter_rat_ncl.num_valid_cdma2000_freq_cells = \
                                                                       p_ncl_info_from_oam->inter_rat_ncl.num_valid_cdma2000_freq_cells;

    U16 num_valid_cdma2000_cells = \
                                   p_ncl_info_from_oam->inter_rat_ncl.num_valid_cdma2000_freq_cells;

    if(num_valid_cdma2000_cells <= RRM_OAM_NUM_CDMA2000_FREQ_CELLS)
    {
        for(cdma2000_cell_count = RRM_ZERO; cdma2000_cell_count < \
                num_valid_cdma2000_cells; \
                cdma2000_cell_count++)
        {
            p_cellm_cdma2000_cells[cdma2000_cell_count].presence_bitmask = 0x00;

            p_cellm_cdma2000_cells[cdma2000_cell_count].arfcn = \
                                                                p_oam_cdma2000_cells[cdma2000_cell_count].arfcn;

            p_cellm_cdma2000_cells[cdma2000_cell_count].pn_offset = \
                                                                    p_oam_cdma2000_cells[cdma2000_cell_count].pn_offset;

            switch(p_oam_cdma2000_cells[cdma2000_cell_count].type)
            {
                case RRM_OAM_NCL_TYPE_1XRTT:
                    p_cellm_cdma2000_cells[cdma2000_cell_count].type = \
                                                                       RRM_OAM_NCL_TYPE_1XRTT;
                    break;

                case RRM_OAM_NCL_TYPE_HRPD:
                    p_cellm_cdma2000_cells[cdma2000_cell_count].type = \
                                                                       RRM_OAM_NCL_TYPE_HRPD;
                    break;

                default:
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, \
                            RRM_ERROR, "rrm_oam_fill_ncl_info_cdma2000: Incorrect \
                            ncl type");
                    break;
            }

            p_cellm_cdma2000_cells[cdma2000_cell_count].num_valid_count_cid = \
                                                                              p_oam_cdma2000_cells[cdma2000_cell_count].num_valid_count_cid;

            RRM_MEMCPY((U8*)p_cellm_cdma2000_cells[cdma2000_cell_count].CID, \
                    (U8*)p_oam_cdma2000_cells[cdma2000_cell_count].CID, \
                    sizeof(p_cellm_cdma2000_cells[cdma2000_cell_count].CID));

            fill_cdma2000_band_class_params(
                    &( p_cellm_cdma2000_cells[cdma2000_cell_count].band_class), \
                    &( p_oam_cdma2000_cells[cdma2000_cell_count].band_class));

            if(p_oam_cdma2000_cells[cdma2000_cell_count].presence_bitmask & 
                    RRM_OAM_CELL_SPECIFIC_PARAMS_PRESENCE_FLAG)
            {
                fill_cdma2000_cell_specific_params(
                        &( p_cellm_cdma2000_cells[cdma2000_cell_count]. \
                            cell_specific_params), \
                        &( p_oam_cdma2000_cells[cdma2000_cell_count]. \
                            cell_specific_params));

                p_cellm_cdma2000_cells[cdma2000_cell_count]. \
                    presence_bitmask |= \
                    RRMCM_RMIF_CELL_SPECIFIC_PARAMS_PRESENCE_FLAG;
            }
            /*daho clean up start*/
            if(p_oam_cdma2000_cells[cdma2000_cell_count].presence_bitmask &
                    RRM_OAM_CDMA_CELL_DAHO_IND_PRESENT)
            {
                p_cellm_cdma2000_cells[cdma2000_cell_count].presence_bitmask |=
                    RRMCM_RMIF_CDMA_CELL_DAHO_IND_PRESENT;
                p_cellm_cdma2000_cells[cdma2000_cell_count].daho_indication = 
                    p_oam_cdma2000_cells[cdma2000_cell_count].daho_indication;
            }
            /*daho clean up start*/
            /*Spr 10305: Start */
            if(p_oam_cdma2000_cells[cdma2000_cell_count].presence_bitmask & RRMCM_RMIF_CDMA_HO_STATUS_PRESENT)
            {
                /* Bug 12675 Fix Start */
                p_cellm_cdma2000_cells[cdma2000_cell_count].presence_bitmask |= RRMCM_RMIF_CDMA_HO_STATUS_PRESENT;
                /* Bug 12675 Fix Stop */ 
                p_cellm_cdma2000_cells[cdma2000_cell_count].ho_status = p_oam_cdma2000_cells[cdma2000_cell_count].ho_status;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "Ho status cdma %d ",
                        p_cellm_cdma2000_cells[cdma2000_cell_count].ho_status);
            }
            else 
            {
                /* Bug 12675 Fix Start */
                p_cellm_cdma2000_cells[cdma2000_cell_count].presence_bitmask |= RRMCM_RMIF_CDMA_HO_STATUS_PRESENT;
                p_cellm_cdma2000_cells[cdma2000_cell_count].ho_status = HO_ALLOWED;
                /* Bug 12675 Fix Stop */
            }
            /*Spr 10305: End */
        }
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,\
                "rrm_oam_fill_ncl_info_cdma2000: \
                num_valid_cdma2000_cells out of range");
    }

    RRM_UT_TRACE_EXIT();
}
/*spr_19395_changes_start*/
/****************************************************************************
 * Function Name  : rrm_is_lac_valid
 * Inputs         : lai_from_oam
 * Outputs        : None
 * Returns        : RRM_FALSE/RRM_TRUE
 * Description    : This function verifies LAC value provided by operator
 ****************************************************************************/
    rrm_bool_et
rrm_is_lac_valid(
        rrm_lai_t   *lai_from_oam)
{
    rrm_bool_et ret_val = RRM_TRUE;
    RRM_UT_TRACE_ENTER();

    if(((lai_from_oam->lac[RRM_ZERO] == RRM_ZERO) && (lai_from_oam->lac[RRM_ONE] == RRM_ZERO)) ||
            ((lai_from_oam->lac[RRM_ZERO] == 0xFE) && (lai_from_oam->lac[RRM_ONE] == 0xFF)))
    {
        ret_val = RRM_FALSE;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Invalid LAC value for IRAT cell provided, so ignoring this entry");
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/*spr_19395_changes_end*/

/* SPR 10498 Fix Start */
    rrm_eutran_inter_freq_daho_cell_config_info_t *
rrm_search_daho_cell_for_inter_freq(
        rrm_daho_cell_config_info_t     *p_daho_cfg,
        U16                             earfcn
        )
{
    U8 index = RRM_ZERO;
    rrm_eutran_inter_freq_daho_cell_config_info_t *p_inter_feq_daho = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    if(RRM_PNULL != p_daho_cfg)
    {
        if(EUTRA_INTER_FREQ_DAHO_CELL_PRESENT & p_daho_cfg->bitmask)
        {
            for(index = RRM_NULL; 
                    index < p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.count;
                    index++)
            {
                if(earfcn == p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.
                        rrm_eutran_inter_freq_daho_cell_config_info[index].earfcn)
                {
                    RRM_TRACE(g_uem_log_on_off,p_rrm_uem_facility_name,RRM_DETAILED,
                            "Inter-freq DAHO already added for EARFCN = %d pci = %d", earfcn,
                            p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.
                            rrm_eutran_inter_freq_daho_cell_config_info[index].phy_cell_id);

                    p_inter_feq_daho = &(p_daho_cfg->eutran_inter_freq_daho_cells_config_info_list.
                            rrm_eutran_inter_freq_daho_cell_config_info[index]);
                    break;
                }
            }
        }
    }
    RRM_UT_TRACE_EXIT();
    return p_inter_feq_daho;
}
/* SPR 10498 Fix End */

/****************************************************************************
 * Function Name  : fill_ncl_info
 * Inputs         : - p_ncl_info_to_cellm
 *                  - p_ncl_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the NCL Info for CellM module
 ****************************************************************************/
void fill_ncl_info(
        /*SPR 17777 +-*/
        ncl_params_t               *p_ncl_info_to_cellm,
        operator_info_t            *p_operator_info_to_cellm,
        rrm_oam_ncl_params_t       *p_ncl_info_from_oam)
{
    /*CID 64293:start*/
    U16  intra_freq_cell_count = RRM_ZERO;
    U16  inter_freq_cell_count = RRM_ZERO;
    U16  utran_cell_count = RRM_ZERO;
    /* SPR-9815-fix start */
    U16  utran_cell_id = RRM_ZERO;
    /* SPR-9815-fix end */
    /*daho clean up start*/
    rrm_bool_et  eutra_daho_count = RRM_FALSE;
    rrm_bool_et  utra_daho_count = RRM_FALSE;
    rrm_bool_et  geran_daho_count = RRM_FALSE;
    U8           intra_ncl_count = RRM_ZERO;
    /* SPR 10498 Fix Start */
    U8           inter_ncl_count = RRM_ZERO;
    /* SPR 10498 Fix End */
    U8           utra_freq_ncl_count = RRM_ZERO;
    U8           geran_freq_ncl_count = RRM_ZERO;
    /*daho clean up end*/
    U8           eutran_inter_freq_daho_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_ncl_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ncl_info_from_oam); 

    RRM_UT_TRACE_ENTER();

    p_ncl_info_to_cellm->bitmask = 0x00;

    if(p_ncl_info_from_oam->bitmask & RRM_OAM_LTE_NCL_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_LTE_NCL_PRESENT");

        p_ncl_info_to_cellm->lte_ncl.num_valid_intra_freq_cell= 
            p_ncl_info_from_oam->lte_ncl.num_valid_intra_freq_cell;

        for(intra_freq_cell_count=0; 
                ((intra_freq_cell_count < 
                  p_ncl_info_from_oam->lte_ncl.num_valid_intra_freq_cell)&&
                 (intra_freq_cell_count < MAX_INTRA_FREQ_CELLS)); intra_freq_cell_count++)
        {
            /*daho clean up start*/
            /*if multiple cells are indicated as daho only first occurence will
              be considerd as daho and rest will be considered as ncl*/
            if((p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_CELL_DAHO_IND_PRESENT) && 
                    (RRM_TRUE == p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].daho_indication) &&
                    (RRM_FALSE == eutra_daho_count))
            {
                /*This is the daho cell*/
                p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_DAHO_CELL_LIST ;
                p_operator_info_to_cellm->daho_cell_config_info.bitmask = 0x00;
                p_operator_info_to_cellm->daho_cell_config_info.bitmask |=
                    EUTRA_DAHO_CELL_PRESENT;
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                {
                    /*populate plmn info*/  
                    RRM_MEMCPY(p_operator_info_to_cellm->
                            daho_cell_config_info.
                            eutran_daho_cell_config_info.plmn_id.mcc,
                            p_ncl_info_from_oam->lte_ncl.
                            intra_freq_cells[intra_freq_cell_count].cell_id.
                            primary_plmn_id.mcc,MAX_MCC_DIGITS);

                    p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_daho_cell_config_info.plmn_id.bitmask |= RRMCM_MCC_PRESENCE_BITMASK;

                    p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_daho_cell_config_info.plmn_id.num_mnc_digit = 
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].cell_id.
                        primary_plmn_id.num_mnc_digit;

                    RRM_MEMCPY(p_operator_info_to_cellm->
                            daho_cell_config_info.
                            eutran_daho_cell_config_info.plmn_id.mnc,
                            p_ncl_info_from_oam->lte_ncl.
                            intra_freq_cells[intra_freq_cell_count].cell_id.
                            primary_plmn_id.mnc,MAX_MNC_DIGITS);

                    /*populate cell_identity*/
                    RRM_MEMCPY(p_operator_info_to_cellm->
                            daho_cell_config_info.
                            eutran_daho_cell_config_info.cell_identity,
                            p_ncl_info_from_oam->lte_ncl.
                            intra_freq_cells[intra_freq_cell_count].cell_id.
                            cell_identity,RRM_MAX_NUM_CELL_IDENTITY_OCTETS);
                }
                /*populate pci*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    eutran_daho_cell_config_info.phy_cell_id =
                    p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].phy_cell_id;

                /*populate q_offset*/
                /* coverity : CID 31029 */
                p_operator_info_to_cellm->daho_cell_config_info.
                    eutran_daho_cell_config_info.q_offset = (rrm_q_offset_range_et)
                    p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].q_offset;

                /*populate cell_individual_offset*/
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
                {
                    /*coverity : CID 31028 */
                    p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_daho_cell_config_info.cell_individual_offset = (rrm_q_offset_range_et)
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].cell_individual_offset;
                }

                /*populate r_stx_power*/
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT)
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_daho_cell_config_info.r_stx_power =
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].r_stx_power;
                }

                /*populate blacklisted*/
                /* coverity : CID 31027 */
                p_operator_info_to_cellm->daho_cell_config_info.
                    eutran_daho_cell_config_info.blacklisted = (rrm_bool_et) 
                    p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].blacklisted;

                /*populate tac*/
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_daho_cell_config_info.tac,
                        p_ncl_info_from_oam->lte_ncl.
                        intra_freq_cells[intra_freq_cell_count].tac,
                        RRM_OAM_MAX_NUM_TAC_OCTETS);

                eutra_daho_count = RRM_TRUE;
            }
            else /*ncl param*/
            {
                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].bitmask = 0x00;
                /*PLMN Info*/
                if (p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask & 
                        RRM_OAM_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].

                        bitmask |= RRMCM_RMIF_INTRA_FREQ_GLOBAL_CELL_ID_PRESENT;
                    rrm_memcpy_rrm_oam_eutran_global_cell_id(
                            &p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].cell_id,
                            &p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].cell_id);

                    /* BUG_371 FIX START */
                }
                /* Coverity 64293 fix start */
                RRM_MEMCPY(p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].tac,
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].tac,
                        MAX_TAC_SIZE);
                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].
                    bitmask |= RRMCM_RMIF_INTRA_FREQ_TAC_PRESENT;
                /* BUG_371 FIX END */
                /*SPR 10329:start*/
                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].p_enb_gu_group_id = RRM_PNULL;
                /*SPR 10329:end*/

                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].phy_cell_id=
                    p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].phy_cell_id;
                /* Coverity 64293 fix end */

                if ( p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_HO_STATUS_PRESENT )
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_INTRA_FREQ_HO_STATUS_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].
                        bitmask |= RRMCM_RMIF_INTRA_FREQ_HO_STATUS_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].ho_status =
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].ho_status;
                }
                /* Bug 896: Start */
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "HO Status not present Setting to Default: HO_ALLOWED");
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].
                        bitmask |= RRMCM_RMIF_INTRA_FREQ_HO_STATUS_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].ho_status = HO_ALLOWED;
                }
                /* Bug 896: End */
                /* Coverity 88477-80 Fix Start */
                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].q_offset=
                    rrm_map_q_offset_from_oam_to_cellm( p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].q_offset);
                /* Coverity 88477-80 Fix End */

                if (p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask & 
                        RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTRA_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].
                        bitmask |= RRMCM_RMIF_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                    /* Coverity 88477-80 Fix Start */
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].cio=
                        rrm_map_q_offset_from_oam_to_cellm(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].cell_individual_offset);
                    /* Coverity 88477-80 Fix End */
                }

                if (p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask & 
                        RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTRA_FREQ_R_STX_POWER_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].
                        bitmask |= RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].r_stx_power=
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].r_stx_power;
                }

                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].blacklisted=
                    p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].blacklisted;


                /*csg start*/
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_CSG_ID_PRESENT)
                {
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].bitmask |=
                        RRMCM_RMIF_INTRA_FREQ_CSG_ID_PRESENT;
                    RRM_MEMCPY(p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].csg_identity,
                            p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].csg_identity,RRM_OAM_MAX_NUM_CSG_OCTETS);
                }

                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT)
                {
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].bitmask |=
                        RRMCM_RMIF_INTRA_FREQ_CELL_ACCESS_MODE_PRESENT;

                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].cell_access_mode = 
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].cell_access_mode;
                }
                /*csg endt*/
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_X2_STATUS_PRESENT)
                {
                    /* coverity : CID 31030 */
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].x2_status =
                        (rrmcm_rmif_cell_x2_status_et)p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].x2_status;
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].bitmask |= RRMCM_RMIF_INTRA_FREQ_X2_STATUS_PRESENT;

                }
                /* BUG_897_fix_start */
                else
                {
                    /* x2 status should be set to allowed if not provided by OAM */
                    /* Coverity_ID : 55808 */
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].x2_status = X2_ALLOWED;
                }
                /* BUG_897_fix_end */

                /** eICIC feature changes start */
                if(p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].bitmask &
                        RRM_OAM_INTRA_FREQ_INTERFERENCE_SCHEME_PRESENT)

                {
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].bitmask |=
                        RRMCM_RMIF_INTRA_FREQ_INTERFERENCE_SCHEME_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].interference_scheme =
                        p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].interference_scheme;

                }    

                /** eICIC feature changes end */
                /* broadcast status */
                /* coverity : CID 31031 */
                p_ncl_info_to_cellm->lte_ncl.intra_freq_cells[intra_ncl_count].broadcast_status = 
                    (rrm_bool_et)p_ncl_info_from_oam->lte_ncl.intra_freq_cells[intra_freq_cell_count].broadcast_status;
                /* broadcast status */
                intra_ncl_count++;
            } 
        }  
        p_ncl_info_to_cellm->lte_ncl.num_valid_intra_freq_cell=intra_ncl_count;
        /*daho clean up end*/  

        /* SPR 10498 Fix Start */

        for(inter_freq_cell_count=0;
                ((inter_freq_cell_count < 
                  p_ncl_info_from_oam->lte_ncl.num_valid_inter_freq_cell)&&
                 (inter_freq_cell_count < RRM_OAM_MAX_NUM_INTER_FREQ_CELLS)); inter_freq_cell_count++)
        {
            /*if multiple cells are indicated as daho only first occurence will
              be considerd as daho and rest will be considered as ncl*/
            if((p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_CELL_DAHO_IND_PRESENT) && 
                    (RRM_TRUE == p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].daho_indication) &&
                    (RRM_PNULL == rrm_search_daho_cell_for_inter_freq(&p_operator_info_to_cellm->daho_cell_config_info,
                                                                      p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn)))
            {
                /*This is the daho cell*/
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "DAHO cell for inter-freq = %d received",
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn);

                p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_DAHO_CELL_LIST ;
                p_operator_info_to_cellm->daho_cell_config_info.bitmask |=
                    EUTRA_INTER_FREQ_DAHO_CELL_PRESENT;
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT");
                    /*populate plmn info*/  
                    rrm_memcpy_rrm_oam_eutran_global_cell_id(&p_operator_info_to_cellm->daho_cell_config_info.
                            eutran_inter_freq_daho_cells_config_info_list.rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].cell_id,
                            &p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].cell_id);
                }

                p_operator_info_to_cellm->daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                    rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].earfcn =
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn;  

                /*populate pci*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    eutran_inter_freq_daho_cells_config_info_list.rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].phy_cell_id =
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].phy_cell_id;

                /*populate q_offset*/
                p_operator_info_to_cellm->daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                    rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].q_offset = (rrm_q_offset_range_et)
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].q_offset;

                /*populate cell_individual_offset*/
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
                {
                    p_operator_info_to_cellm->daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.
                        rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].cell_individual_offset = (rrm_q_offset_range_et)
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].cell_individual_offset;
                }

                /*populate r_stx_power*/
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_RSTX_POWER_PRESENT)
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_inter_freq_daho_cells_config_info_list.rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].r_stx_power =
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].r_stx_power;
                }

                /*populate tac*/
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        eutran_inter_freq_daho_cells_config_info_list.rrm_eutran_inter_freq_daho_cell_config_info[eutran_inter_freq_daho_count].tac,
                        p_ncl_info_from_oam->lte_ncl.
                        inter_freq_cells[inter_freq_cell_count].tac,
                        RRM_OAM_MAX_NUM_TAC_OCTETS);
                eutran_inter_freq_daho_count++;
                p_operator_info_to_cellm->daho_cell_config_info.eutran_inter_freq_daho_cells_config_info_list.count =
                    eutran_inter_freq_daho_count;

            }
            else /*ncl param*/
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "Adding in NCL: inter freq nbr. freq = %d, pci = %d",
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn,
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].phy_cell_id );

                /* SPR 10498 Fix End */
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask = 0x00;
                if (p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask & 
                        RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTER_FREQ_GLOBAL_CELL_ID_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                        RRMCM_RMIF_INTER_FREQ_GLOBAL_CELL_ID_PRESENT;
                    /* PLMN Info*/
                    rrm_memcpy_rrm_oam_eutran_global_cell_id(
                            &p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].cell_id,
                            &p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].cell_id);

                    /* BUG_371 FIX START */
                }

                RRM_MEMCPY(p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].tac,
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].tac,
                        MAX_TAC_SIZE);
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                    RRMCM_RMIF_INTER_FREQ_TAC_PRESENT;

                /* BUG_371 FIX END */
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].eutra_carrier_arfcn=
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].eutra_carrier_arfcn;  
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].phy_cell_id=
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].phy_cell_id;  

                if ( p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_HO_STATUS_PRESENT )
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].
                        bitmask |= RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].ho_status =
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].ho_status;
                }
                /* Bug 896: Start */
                else
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].
                        bitmask |= RRMCM_RMIF_INTER_FREQ_HO_STATUS_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].ho_status = HO_ALLOWED;
                }
                /* Bug 896: End */
                /* Coverity 88477-80 Fix Start */
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].q_offset=
                    rrm_map_q_offset_from_oam_to_cellm( p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].q_offset);
                /* Coverity 88477-80 Fix End */

                if (p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                        RRMCM_RMIF_INTER_FREQ_CELL_INDIVIDUAL_OFFSET_PRESENT;
                    /* Coverity 88477-80 Fix Start */
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].cio  =
                        rrm_map_q_offset_from_oam_to_cellm(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].cell_individual_offset);
                    /* Coverity 88477-80 Fix End */
                }
                if (p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_RSTX_POWER_PRESENT)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_INTER_FREQ_RSTX_POWER_PRESENT");
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                        RRMCM_RMIF_INTER_FREQ_R_STX_POWER_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].r_stx_power=
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].r_stx_power;  
                }
                /*Coverity 23126, typecasted to rrm_bool_et in rel 1.3: Aditya*/
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].blacklisted=
                    (rrm_bool_et)p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].blacklisted;  


                /*csg start*/
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_CELL_ACCESS_MODE_PRESENT)
                {
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                        RRMCM_RMIF_CELL_ACCESS_MODE_PRESENT;
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].cell_access_mode = 
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].cell_access_mode;
                }
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_CSG_ID_PRESENT)
                {
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].bitmask |=
                        RRMCM_RMIF_CSG_ID_PRESENT;

                    RRM_MEMCPY(p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].csg_identity,
                            p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].csg_identity,
                            RRM_OAM_MAX_NUM_CSG_OCTETS);
                }
                /*csg end*/
                if(p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].bitmask &
                        RRM_OAM_INTER_FREQ_X2_STATUS_PRESENT)
                {
                    /*coverity 30244, aditya, typecasted to rrmcm_rmif_cell_x2_status_et, rel2.0.1*/
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].x2_status =(rrmcm_rmif_cell_x2_status_et)
                        p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].x2_status;
                }
                /* BUG_897_fix_start */
                else
                {
                    /* x2 status should be set to allowed if not provided by OAM */
                    /* Coverity_ID : 55809 */ 
                    p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].x2_status = X2_ALLOWED;
                }
                /* BUG_897_fix_end */


                /* broadcast status start */

                /* coverity : CID 29718*/
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].broadcast_status = (rrm_bool_et)
                    p_ncl_info_from_oam->lte_ncl.inter_freq_cells[inter_freq_cell_count].broadcast_status;

                /* broadcase status end */
                /*SPR 10329:start*/
                p_ncl_info_to_cellm->lte_ncl.inter_freq_cells[inter_ncl_count].p_enb_gu_group_id = RRM_PNULL; 
                /*SPR 10329:end*/
                /* SPR 10498 Fix Start */
                inter_ncl_count++;
                /* SPR 10498 Fix End */
            }
        }
        /* SPR 10498 Fix Start */
        p_ncl_info_to_cellm->lte_ncl.num_valid_inter_freq_cell = inter_ncl_count;
        if(intra_ncl_count || inter_ncl_count)
        {
            p_ncl_info_to_cellm->bitmask |= RRMCM_RMIF_LTE_NCL_PRESENT;
        }
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "intra_ncl_count = %d, inter_ncl_count = %d", intra_ncl_count, inter_ncl_count);
        /* SPR 10498 Fix End */
    }
    if(p_ncl_info_from_oam->bitmask & RRM_OAM_INTER_RAT_NCL_PRESENT)
    {
        rrm_oam_utran_freq_cells_t	  *p_oam_utra_freq_cells = RRM_PNULL;
        // p_ncl_info_from_oam->inter_rat_ncl.utran_freq_cells;
        utran_freq_cells_t    *p_cellm_utra_freq_cells = RRM_PNULL;
        // p_ncl_info_to_cellm->inter_rat_ncl.utran_freq_cells;

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_IRAT_UTRAN_NCL_PRESENT");

        for(utran_cell_count= RRM_ZERO; utran_cell_count < \
                p_ncl_info_from_oam->inter_rat_ncl.num_valid_utran_freq_cell; \
                utran_cell_count++)
        {
            p_oam_utra_freq_cells = &(p_ncl_info_from_oam->inter_rat_ncl.\
                    utran_freq_cells[utran_cell_count]);
            p_cellm_utra_freq_cells = &(p_ncl_info_to_cellm->inter_rat_ncl.\
                    utran_freq_cells[utra_freq_ncl_count]);
            /*spr_19395_changes_start*/
            /* As per 3GPP spec 36.413, LAC values as 0000 and FFFE are
             ** not allowed. If any such configuration is provided, skipping
             ** respective entry in NCL
             */
            if(!rrm_is_lac_valid(&(p_oam_utra_freq_cells->rai.lai)))
            {
                continue;
            }
            /*spr_19395_changes_end*/

            /*daho clean up start*/
            /*if multiple cells are indicated as daho only first occurence will
              be considerd as daho and rest will be considered as ncl*/
            if((p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_DAHO_IND_PRESENT) &&
                    (RRM_TRUE == p_oam_utra_freq_cells->daho_indication) &&
                    (RRM_FALSE == utra_daho_count))
            {
                /*this is the daho cell*/
                p_operator_info_to_cellm->daho_cell_config_info.bitmask |=
                    UTRAN_DAHO_CELL_PRESENT; 

                /*populate rai*/   
                /*populate plmn id*/ 
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.rai.lai.plmn_identity.mcc,
                        p_oam_utra_freq_cells->rai.lai.plmn_id.mcc,
                        MCC_OCTET_SIZE);

                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.rai.lai.plmn_identity.presence_bitmask |=
                    PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.rai.lai.plmn_identity.mnc.count =
                    p_oam_utra_freq_cells->rai.lai.plmn_id.num_mnc_digit;

                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.rai.lai.plmn_identity.mnc.mnc,
                        p_oam_utra_freq_cells->rai.lai.plmn_id.mnc,MAX_MNC_DIGITS );

                /*popuate lac*/
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.rai.lai.location_area_code,
                        p_oam_utra_freq_cells->rai.lai.lac,
                        RRM_OAM_MAX_NUM_LAC_OCTETS);

                /*populate rac*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.rai.rac =    
                    p_oam_utra_freq_cells->rai.rac;

                /*populate uc_id*/   
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.uc_id.cell_id,
                        p_oam_utra_freq_cells->uc_id.cell_id,
                        RRM_UTRAN_CELL_IDENTITY_OCTETS);

                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.uc_id.rnc_id =
                    p_oam_utra_freq_cells->uc_id.rnc_id;

                if(p_oam_utra_freq_cells->uc_id.bitmask &
                        RRM_OAM_UTRAN_EXTN_RNC_ID_PRESENT) 
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.uc_id.bitmask |= RRM_OAM_EXTENDED_RNC_ID;   
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.uc_id.extended_rnc_id = 
                        p_oam_utra_freq_cells->uc_id.extended_rnc_id;  
                }

                /*populate pci*/   
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.pci = 
                    p_oam_utra_freq_cells->pcpich_scrambling_code;

                /*populate ura*/   
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.ura =
                    p_oam_utra_freq_cells->ura;            

                /*populate uarfcnul*/
                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_FREQ_UARFCNUL_PRESENT)
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.uarfcnul =
                        p_oam_utra_freq_cells->uarfcnul;        
                }

                /*populate uarfcndl*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.uarfcndl =
                    p_oam_utra_freq_cells->uarfcndl;

                /*populate pcpich_scrambling_code*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.pcpich_scrambling_code =
                    p_oam_utra_freq_cells->pcpich_scrambling_code;

                /*populate pcpich_tx_power*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    utran_daho_cell_config_info.pcpich_tx_power =
                    p_oam_utra_freq_cells->pcpich_tx_power;

                /* SRVCC SUPPORT START */
                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT)
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.ps_ho_supported =
                        p_oam_utra_freq_cells->ps_ho_supported;
                }
                else
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.ps_ho_supported = RRM_TRUE;
                }

                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_VOIP_CAPABLE_PRESENT)
                {
                    if((RRM_FALSE == p_operator_info_to_cellm->daho_cell_config_info.
                                utran_daho_cell_config_info.ps_ho_supported) &&
                            (RRM_TRUE == p_oam_utra_freq_cells->voip_capable))
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "UTRAN DAHO cell can't be voip capable if it does not support PS HO."
                                "Setting UTRAN DAHO cell as voip-incapable");
                        p_operator_info_to_cellm->daho_cell_config_info.
                            utran_daho_cell_config_info.voip_capable = RRM_FALSE;
                    }
                    else
                    {
                        p_operator_info_to_cellm->daho_cell_config_info.
                            utran_daho_cell_config_info.voip_capable =
                            p_oam_utra_freq_cells->voip_capable;
                    }
                }
                else
                {
                    p_operator_info_to_cellm->daho_cell_config_info.
                        utran_daho_cell_config_info.voip_capable = RRM_TRUE;
                }
                /* SRVCC SUPPORT END */

                utra_daho_count = RRM_TRUE;
            }
            else /*utra ncl*/
            {
                rrm_memcpy_mcc(
                        (p_cellm_utra_freq_cells->rai.lai.plmn_identity.mcc),
                        (p_oam_utra_freq_cells->rai.lai.plmn_id.mcc));

                p_cellm_utra_freq_cells->rai.lai.plmn_identity.presence_bitmask |= \
                                                                                   PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                if(p_oam_utra_freq_cells->rai.lai.plmn_id.num_mnc_digit)
                {
                    rrm_memcpy_mnc(
                            (p_cellm_utra_freq_cells->rai.lai.plmn_identity.mnc.mnc),
                            (p_oam_utra_freq_cells->rai.lai.plmn_id.mnc),
                            MAX_MNC_DIGITS);

                    p_cellm_utra_freq_cells->rai.lai.plmn_identity.mnc.count = \
                                                                               p_oam_utra_freq_cells->rai.lai.plmn_id.num_mnc_digit;
                }
                rrm_memcpy_lac(
                        p_cellm_utra_freq_cells->rai.lai.lac,
                        p_oam_utra_freq_cells->rai.lai.lac,
                        RRM_OAM_MAX_NUM_LAC_OCTETS);

                p_cellm_utra_freq_cells->rai.rac = \
                                                   p_oam_utra_freq_cells->rai.rac;

                /*CP: Fix UTRAN CELL ID START */
                p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ZERO] = p_oam_utra_freq_cells->uc_id.cell_id[RRM_ZERO];
                p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ONE] = p_oam_utra_freq_cells->uc_id.cell_id[RRM_ONE];
                /* SPR-9815-fix start */

                p_cellm_utra_freq_cells->uc_id.bitmask = RRM_ZERO;
                if(p_oam_utra_freq_cells->uc_id.bitmask & RRM_OAM_EXTENDED_RNC_ID)
                {
                    p_cellm_utra_freq_cells->uc_id.bitmask |= RRM_UTRAN_EXTN_RNC_ID_PRESENT;
                    p_cellm_utra_freq_cells->uc_id.extended_rnc_id = p_oam_utra_freq_cells->uc_id.extended_rnc_id;
                    rrm_encode_rncid_to_cell_identity (p_cellm_utra_freq_cells->uc_id.cell_id_merge,p_cellm_utra_freq_cells->uc_id.extended_rnc_id);
                }
                else
                {
                    p_cellm_utra_freq_cells->uc_id.rnc_id = p_oam_utra_freq_cells->uc_id.rnc_id;
                    rrm_encode_rncid_to_cell_identity (p_cellm_utra_freq_cells->uc_id.cell_id_merge,p_cellm_utra_freq_cells->uc_id.rnc_id);

                }
                /* Fetch the CID and convert into the U16 data type */
                utran_cell_id = p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ZERO];
                utran_cell_id |= p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ONE] << RRM_EIGHT;

                rrm_encode_cid_to_cell_identity (p_cellm_utra_freq_cells->uc_id.cell_id_merge,utran_cell_id);
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF, "CELL_ID %d %d, RNC_ID %d, extended RNC ID %d, cell_id_merge %d %d %d %d\n",
                        p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ONE],
                        p_cellm_utra_freq_cells->uc_id.cell_id[RRM_ZERO],
                        p_cellm_utra_freq_cells->uc_id.rnc_id,
                        p_cellm_utra_freq_cells->uc_id.extended_rnc_id,
                        p_cellm_utra_freq_cells->uc_id.cell_id_merge[RRM_ZERO],
                        p_cellm_utra_freq_cells->uc_id.cell_id_merge[RRM_ONE],
                        p_cellm_utra_freq_cells->uc_id.cell_id_merge[RRM_TWO],
                        p_cellm_utra_freq_cells->uc_id.cell_id_merge[RRM_THREE]);

                /* SPR-9815-fix end */

                /*CP: Fix UTRAN CELL ID STOP */
                p_cellm_utra_freq_cells->ura = p_oam_utra_freq_cells->ura;

                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_FREQ_UARFCNUL_PRESENT)
                {
                    p_cellm_utra_freq_cells->uarfcnul = p_oam_utra_freq_cells->uarfcnul;
                    p_cellm_utra_freq_cells->bitmask |= RRM_UTRAN_FREQ_UARFCNUL_PRESENT;
                }
                p_cellm_utra_freq_cells->uarfcndl = p_oam_utra_freq_cells->uarfcndl;
                p_cellm_utra_freq_cells->pcpich_scrambling_code = \
                                                                  p_oam_utra_freq_cells->pcpich_scrambling_code;

                p_cellm_utra_freq_cells->pcpich_tx_power = \
                                                           p_oam_utra_freq_cells->pcpich_tx_power;
                p_cellm_utra_freq_cells->offset_freq = p_oam_utra_freq_cells->offset_freq;

                p_cellm_utra_freq_cells->blacklisted = p_oam_utra_freq_cells->blacklisted;

                /*csg start*/
                if (p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT)
                {
                    p_cellm_utra_freq_cells->bitmask |= RRM_UTRAN_FREQ_CELL_ACCESS_MODE_PRESENT;
                    p_cellm_utra_freq_cells->cell_access_mode = p_oam_utra_freq_cells->cell_access_mode;
                }

                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_FREQ_CSG_ID_PRESENT)
                {
                    p_cellm_utra_freq_cells->bitmask |= RRM_UTRAN_FREQ_CSG_ID_PRESENT;
                    RRM_MEMCPY(p_cellm_utra_freq_cells->csg_identity,p_oam_utra_freq_cells->csg_identity,RRM_OAM_MAX_NUM_CSG_OCTETS);
                }
                /*csg end*/
                /*SRVCC SUPPORT START */
                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_PS_HO_SUPPORTED_PRESENT)
                {
                    p_cellm_utra_freq_cells->ps_ho_supported = p_oam_utra_freq_cells->ps_ho_supported;
                }
                else
                {
                    p_cellm_utra_freq_cells->ps_ho_supported = RRM_TRUE;
                }

                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_VOIP_CAPABLE_PRESENT)
                {
                    if((RRM_FALSE == p_cellm_utra_freq_cells->ps_ho_supported) &&
                            (RRM_TRUE == p_oam_utra_freq_cells->voip_capable))
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                                "UTRAN cell can't be voip capable if it does not support PS HO."
                                "Setting UTRAN cell as voip-incapable");
                        p_cellm_utra_freq_cells->voip_capable = RRM_FALSE;
                    }
                    else
                    {
                        p_cellm_utra_freq_cells->voip_capable = p_oam_utra_freq_cells->voip_capable;
                    }
                }
                else
                {
                    p_cellm_utra_freq_cells->voip_capable = RRM_TRUE;
                }
                /*SRVCC SUPPORT END*/

                /*Spr 10305: Start */
                if(p_oam_utra_freq_cells->bitmask & RRM_OAM_UTRAN_HO_STATUS_PRESENT)
                {
                    p_cellm_utra_freq_cells->bitmask |= RRM_UTRAN_HO_STATUS_PRESENT;
                    p_cellm_utra_freq_cells->ho_status = p_oam_utra_freq_cells->ho_status;
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,\
                            " ho status utran ho status %d ", p_cellm_utra_freq_cells->ho_status);
                }else 
                {
                    p_cellm_utra_freq_cells->bitmask |= RRM_UTRAN_HO_STATUS_PRESENT;
                    p_cellm_utra_freq_cells->ho_status =  HO_ALLOWED;
                }
                /*Spr bug 10305: End */
                utra_freq_ncl_count++;
            }

        }
        p_ncl_info_to_cellm->bitmask |= RRMCM_RMIF_INTER_RAT_NCL_PRESENT;
        p_ncl_info_to_cellm->inter_rat_ncl.num_valid_utran_freq_cell = 
            utra_freq_ncl_count;
        /*daho clean up end*/

        geran_freq_ncl_t *p_geran_ncl = p_ncl_info_to_cellm->\
                                        inter_rat_ncl.geran_freq_cells;

        rrm_oam_geran_freq_cells_t *p_oam_geran_cell = p_ncl_info_from_oam->\
                                                       inter_rat_ncl.geran_freq_cells;

        for(utran_cell_count= RRM_ZERO; utran_cell_count < \
                p_ncl_info_from_oam->inter_rat_ncl.num_valid_geran_freq_cell; \
                utran_cell_count++)
        {
            /*spr_19395_changes_start*/
            /* As per 3GPP spec 36.413, LAC values as 0000 and FFFE are
             ** not allowed. If any such configuration is provided, skipping
             ** respective entry in NCL
             */
            if(!rrm_is_lac_valid(&(p_oam_geran_cell[utran_cell_count].lai)))
            {
                continue;
            }
            /*spr_19395_changes_end*/
            /*daho clean up start*/
            /*if multiple cells are indicated as daho only first occurence will
              be considerd as daho and rest will be considered as ncl*/
            if((p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_DAHO_IND_PRESENT) &&
                    (RRM_TRUE == p_oam_geran_cell[utran_cell_count].daho_indication) &&
                    (RRM_FALSE == geran_daho_count))
            {
                p_operator_info_to_cellm->daho_cell_config_info.bitmask |=      
                    GERAN_DAHO_CELL_PRESENT;

                /*populate plmn id*/
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        geran_daho_cell_config_info.lai.plmn_identity.mcc,
                        p_oam_geran_cell[utran_cell_count].lai.plmn_id.mcc,
                        MCC_OCTET_SIZE);

                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.lai.plmn_identity.presence_bitmask |=
                    PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.lai.plmn_identity.mnc.count =
                    p_oam_geran_cell[utran_cell_count].lai.plmn_id.num_mnc_digit;

                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        geran_daho_cell_config_info.lai.plmn_identity.mnc.mnc,
                        p_oam_geran_cell[utran_cell_count].lai.plmn_id.mnc,MAX_MNC_DIGITS );

                /*populate lac*/
                RRM_MEMCPY(p_operator_info_to_cellm->daho_cell_config_info.
                        geran_daho_cell_config_info.lai.lac,
                        p_oam_geran_cell[utran_cell_count].lai.lac,
                        RRM_OAM_MAX_NUM_LAC_OCTETS);

                /*populate cell_id*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.cell_id =
                    p_oam_geran_cell[utran_cell_count].cell_id;

                /*populate band_indicator*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.band_indicator =
                    p_oam_geran_cell[utran_cell_count].bandindicator;

                /*populate bcch_arfcn*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.bcch_arfcn =
                    p_oam_geran_cell[utran_cell_count].bccharfcn;

                /*populate pci*/
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.pci =
                    p_oam_geran_cell[utran_cell_count].pci;

                /* BugId - 20068 Start */
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.dtm_supported = \
                    p_oam_geran_cell[utran_cell_count].dtm_supported;
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.dtm_ho_supported = \
                    p_oam_geran_cell[utran_cell_count].dtm_ho_supported;
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.voip_capable = \
                    p_oam_geran_cell[utran_cell_count].voip_capable;
                /* BugId - 20068 End */

                /* SPR_13721_fix : start */
                if (p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_supported = \
                                                                      p_oam_geran_cell[utran_cell_count].dtm_supported;
                }
                else   /* If dtm_supported not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_supported = RRM_ZERO;
                }
                if(p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_DTM_HO_SUPPORTED_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_ho_supported = \
                                                                         p_oam_geran_cell[utran_cell_count].dtm_ho_supported;
                }
                else  /* If dtm_ho_supported not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_ho_supported = RRM_ZERO;
                }

                if(p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_VOIP_CAPABLE_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].voip_capable = \
                                                                     p_oam_geran_cell[utran_cell_count].voip_capable;
                }
                else  /* If voip_capable not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].voip_capable = RRM_ZERO;
                }
                /* SPR_13721_fix : end */
                /* SPR 19327 Fix Start */
                p_operator_info_to_cellm->daho_cell_config_info.
                    geran_daho_cell_config_info.rac = p_oam_geran_cell[utran_cell_count].rac;
                /* SPR 19327 Fix Stop */

                geran_daho_count = RRM_TRUE;
            }
            else /*This is normal neighbor cell*/
            {
                rrm_memcpy_mcc(
                        p_geran_ncl[geran_freq_ncl_count].lai.plmn_identity.mcc,
                        p_oam_geran_cell[utran_cell_count].lai.plmn_id.mcc);
                p_geran_ncl[geran_freq_ncl_count].lai.plmn_identity.presence_bitmask |= \
                                                                                        PLMN_IDENTITY_MCC_PRESENCE_FLAG;

                if(p_oam_geran_cell[utran_cell_count].lai.plmn_id.num_mnc_digit)
                {
                    rrm_memcpy_mnc(
                            p_geran_ncl[geran_freq_ncl_count].lai.plmn_identity.mnc.mnc,
                            p_oam_geran_cell[utran_cell_count].lai.plmn_id.mnc,
                            MAX_MNC_OCTET_SIZE);
                }
                p_geran_ncl[geran_freq_ncl_count].lai.plmn_identity.mnc.count = \
                                                                                p_oam_geran_cell[utran_cell_count].lai.plmn_id.num_mnc_digit;
                rrm_memcpy_lac(
                        p_geran_ncl[geran_freq_ncl_count].lai.lac,
                        p_oam_geran_cell[utran_cell_count].lai.lac,
                        RRM_OAM_MAX_NUM_LAC_OCTETS);

                /* 18031_CHANGES_START */
                p_geran_ncl[geran_freq_ncl_count].cell_id = \
                                                            p_oam_geran_cell[utran_cell_count].cell_id;
                /* 18031_CHANGES_END */

                p_geran_ncl[geran_freq_ncl_count].band_indicator = \
                                                                   p_oam_geran_cell[utran_cell_count].bandindicator;

                p_geran_ncl[geran_freq_ncl_count].bcch_arfcn = \
                                                               p_oam_geran_cell[utran_cell_count].bccharfcn;

                p_geran_ncl[geran_freq_ncl_count].pci = \
                                                        p_oam_geran_cell[utran_cell_count].pci;
                /* SPR-10489-fix start */
                if (p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_supported = \
                                                                      p_oam_geran_cell[utran_cell_count].dtm_supported;
                    p_geran_ncl[geran_freq_ncl_count].bitmask |=
                        RRM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT;

                }
                /* SPR_14067_Fix_Start */
                else   /* If dtm_supported not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_supported = RRM_ZERO;

                    p_geran_ncl[geran_freq_ncl_count].bitmask |=
                        RRM_GERAN_FREQ_CELL_DTM_SUPPORTED_PRESENT;
                }

                if(p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_DTM_HO_SUPPORTED_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_ho_supported = \
                                                                         p_oam_geran_cell[utran_cell_count].dtm_ho_supported;

                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_CELL_DTM_HO_SUPPORTED_PRESENT;
                }
                else  /* If dtm_ho_supported not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].dtm_ho_supported = RRM_ZERO;

                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_CELL_DTM_HO_SUPPORTED_PRESENT;
                }

                if(p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_CELL_VOIP_CAPABLE_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].voip_capable = \
                                                                     p_oam_geran_cell[utran_cell_count].voip_capable;

                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_CELL_VOIP_CAPABLE_PRESENT;
                }
                else  /* If voip_capable not received from OAM for Geran cell then RRM will consider as not supported */
                {
                    p_geran_ncl[geran_freq_ncl_count].voip_capable = RRM_ZERO;

                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_CELL_VOIP_CAPABLE_PRESENT;
                }
                /* SPR_14067_Fix_End */


                if(p_oam_geran_cell[utran_cell_count].bitmask &
                        RRM_OAM_GERAN_FREQ_CELL_NW_CTRL_ORDER_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].nw_ctrl_order = p_oam_geran_cell[utran_cell_count].
                        network_control_order;
                    p_geran_ncl[geran_freq_ncl_count].bitmask |=
                        RRM_GERAN_FREQ_CELL_NW_CONTROL_ORDER_PRESENT;
                }

                /*Spr 10305: Start */
                /* bug 1013: Start */
                if(p_oam_geran_cell[utran_cell_count].bitmask & RRM_OAM_GERAN_FREQ_HO_STATUS_PRESENT)
                {
                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_HO_STATUS_PRESENT;
                    p_geran_ncl[geran_freq_ncl_count].ho_status = p_oam_geran_cell[utran_cell_count].ho_status;
                }
                /* bug 1013: End */
                /*Spr 10305: End */  
                /* Bug 896: Start */
                else
                {
                    p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_HO_STATUS_PRESENT;
                    /* SPR-10489-fix end */
                    p_geran_ncl[geran_freq_ncl_count].ho_status = HO_ALLOWED;
                }
                /* SPR 19327 Fix Start */
                p_geran_ncl[geran_freq_ncl_count].bitmask |= RRM_GERAN_FREQ_CELL_RAC_PRESENT;
                p_geran_ncl[geran_freq_ncl_count].rac = p_oam_geran_cell[utran_cell_count].rac;
                /* SPR 19327 Fix Stop */
                /* Bug 896: End */
                geran_freq_ncl_count++;
            }

        }	     
        p_ncl_info_to_cellm->inter_rat_ncl.num_valid_geran_cell = geran_freq_ncl_count;

        /*daho clean up end*/

        fill_ncl_info_cdma2000(p_ncl_info_to_cellm,
                p_ncl_info_from_oam);
    }
    /*daho clean up start*/
    if((EUTRA_DAHO_CELL_PRESENT & p_operator_info_to_cellm->daho_cell_config_info.bitmask) ||
            /* SPR 10498 Fix Start */
            (EUTRA_INTER_FREQ_DAHO_CELL_PRESENT & p_operator_info_to_cellm->daho_cell_config_info.bitmask) ||
            /* SPR 10498 Fix End */
            (UTRAN_DAHO_CELL_PRESENT & p_operator_info_to_cellm->daho_cell_config_info.bitmask) ||
            (GERAN_DAHO_CELL_PRESENT & p_operator_info_to_cellm->daho_cell_config_info.bitmask))
    {
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_DAHO_CELL_LIST;
    }
    /*daho clean up end*/
    RRM_UT_TRACE_EXIT();
    /*CID 64293:end*/
}

/****************************************************************************
 * Function Name  : rrm_oam_fill_common_params_for_eutra_info
 * Inputs         : *p_common_params_to_cellm, *p_common_params_from_oam
 * Outputs        : none
 * Returns        : void
 * Description    : This function fill the common params for Eutra Info 
 *                  for CellM module
 ****************************************************************************/
void rrm_oam_fill_common_params_for_eutra_info(
        rrm_common_params_for_eutra_t      *p_common_params_to_cellm,
        rrm_oam_common_params_for_eutra_t  *p_common_params_from_oam)
{
    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_common_params_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_common_params_from_oam);

    p_common_params_to_cellm->filter_coefficient_rsrp =
        p_common_params_from_oam->filter_coefficient_rsrp;
    p_common_params_to_cellm->filter_coefficient_rsrq =
        p_common_params_from_oam->filter_coefficient_rsrq;
    p_common_params_to_cellm->a1_threshold_rsrp =
        p_common_params_from_oam->a1_threshold_rsrp;
    p_common_params_to_cellm->a1_threshold_rsrq =
        p_common_params_from_oam->a1_threshold_rsrq;
    p_common_params_to_cellm->a2_threshold_rsrp =
        p_common_params_from_oam->a2_threshold_rsrp;
    p_common_params_to_cellm->a2_threshold_rsrq =
        p_common_params_from_oam->a2_threshold_rsrq;
    p_common_params_to_cellm->a3_offset = 
        p_common_params_from_oam->a3_offset;
    p_common_params_to_cellm->report_on_leave =
        p_common_params_from_oam->report_on_leave;
    p_common_params_to_cellm->a4_threshold_rsrp =
        p_common_params_from_oam->a4_threshold_rsrp;
    p_common_params_to_cellm->a4_threshold_rsrq =
        p_common_params_from_oam->a4_threshold_rsrq;
    p_common_params_to_cellm->a5_threshold_1rsrp =
        p_common_params_from_oam->a5_threshold_1rsrp;
    p_common_params_to_cellm->a5_threshold_1rsrq =
        p_common_params_from_oam->a5_threshold_1rsrq;
    p_common_params_to_cellm->a5_threshold_2rsrp =
        p_common_params_from_oam->a5_threshold_2rsrp;
    p_common_params_to_cellm->a5_threshold_2rsrq =
        p_common_params_from_oam->a5_threshold_2rsrq;
    p_common_params_to_cellm->hysteresis = 
        p_common_params_from_oam->hysteresis;
    p_common_params_to_cellm->time_to_trigger =
        p_common_params_from_oam->time_to_trigger;
    p_common_params_to_cellm->trigger_quantity =
        p_common_params_from_oam->trigger_quantity;
    p_common_params_to_cellm->report_quantity =
        p_common_params_from_oam->report_quantity;
    p_common_params_to_cellm->report_interval =
        p_common_params_from_oam->report_interval;
    p_common_params_to_cellm->report_amount =
        p_common_params_from_oam->report_amount;
    p_common_params_to_cellm->ps_ho_enabled =
        (rrm_bool_et)p_common_params_from_oam->ps_ho_enabled;
    /*bug fix 985 start*/
    p_common_params_to_cellm->max_report_cells=
        p_common_params_from_oam->max_report_cells;
    /*bug fix 985 end*/

    /* SPR 17529 Fix Start */
    if(RRM_OAM_MIN_THRESHOLD_RSRQ_PRESENT & p_common_params_from_oam->bitmask)
    {
        p_common_params_to_cellm->min_threshold_rsrq = 
            p_common_params_from_oam->min_threshold_rsrq;
        p_common_params_to_cellm->bitmask |= RRMCM_RMIF_MIN_THRESHOLD_RSRQ_PRESENT;
    }
    /* SPR 17529 Fix End */
    RRM_UT_TRACE_EXIT();
}


/**********************************************************************************
 * Function Name  : rrm_oam_fill_ue_gen_cdma2000_params
 * Inputs         : 
 * Outputs        : none
 * Returns        : void
 * Description    : This function fill connected mode mobility info
 *                  for CellM module
 **********************************************************************************/
    rrm_void_t 
rrm_oam_fill_ue_gen_cdma2000_params(
        rrmc_ue_generic_cdma2000_params_t     *p_ue_gen_cdma2000_info_to_cellm,
        rrm_oam_ue_generic_cdma2000_params_t  *p_ue_gen_cdma2000_info_from_oam)
{
    RRM_ASSERT (RRM_PNULL != p_ue_gen_cdma2000_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ue_gen_cdma2000_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_ue_gen_cdma2000_info_to_cellm->bitmask = 0x00;

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_AUTH_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->auth = \
                                                p_ue_gen_cdma2000_info_from_oam->auth;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_AUTH_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_MAX_NUM_ALT_SO_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->max_num_alt_so = \
                                                          p_ue_gen_cdma2000_info_from_oam->max_num_alt_so;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_MAX_NUM_ALT_SO_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_USE_SYNC_ID_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->use_sync_id = \
                                                       p_ue_gen_cdma2000_info_from_oam->use_sync_id;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_USE_SYNC_ID_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_MOB_QOS_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->mob_qos = \
                                                   p_ue_gen_cdma2000_info_from_oam->mob_qos;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_MOB_QOS_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_BYPASS_REG_IND_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->bypass_reg_ind = \
                                                          p_ue_gen_cdma2000_info_from_oam->bypass_reg_ind;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_BYPASS_REG_IND_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->max_add_serv_instance = \
                                                                 p_ue_gen_cdma2000_info_from_oam->max_add_serv_instance;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_PARAMETER_REG_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->parameter_reg = \
                                                         p_ue_gen_cdma2000_info_from_oam->parameter_reg;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_PARAMETER_REG_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_REG_DIST_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->reg_dist = \
                                                    p_ue_gen_cdma2000_info_from_oam->reg_dist;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_REG_DIST_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_PREF_MSID_TYPE_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->pref_msid_type = \
                                                          p_ue_gen_cdma2000_info_from_oam->pref_msid_type;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_PREF_MSID_TYPE_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_EXT_PREF_MSID_TYPE_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->ext_pref_msid_type = \
                                                              p_ue_gen_cdma2000_info_from_oam->ext_pref_msid_type;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_EXT_PREF_MSID_TYPE_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_MEID_REQD_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->meid_reqd = \
                                                     p_ue_gen_cdma2000_info_from_oam->meid_reqd;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_MEID_REQD_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_MCC_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->mcc = \
                                               p_ue_gen_cdma2000_info_from_oam->mcc;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_MCC_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_IMSI_11_12_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->imsi_11_12 = \
                                                      p_ue_gen_cdma2000_info_from_oam->imsi_11_12;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_IMSI_11_12_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_IMSI_T_SUPPORTED_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->imsi_t_supported = \
                                                            p_ue_gen_cdma2000_info_from_oam->imsi_t_supported;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_IMSI_T_SUPPORTED_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_RECONNECT_MSG_IND_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->reconnect_msg_ind = \
                                                             p_ue_gen_cdma2000_info_from_oam->reconnect_msg_ind;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_RECONNECT_MSG_IND_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_RER_MODE_SUPPORTED_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->rer_mode_supported = \
                                                              p_ue_gen_cdma2000_info_from_oam->rer_mode_supported;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_RER_MODE_SUPPORTED_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_PILOT_REPORT_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->pilot_report = \
                                                        p_ue_gen_cdma2000_info_from_oam->pilot_report;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_PILOT_REPORT_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_SDB_SUPPORTED_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->sdb_supported = \
                                                         p_ue_gen_cdma2000_info_from_oam->sdb_supported;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_SDB_SUPPORTED_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_AUTO_FCSO_ALLOWED_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->auto_fcso_allowed = \
                                                             p_ue_gen_cdma2000_info_from_oam->auto_fcso_allowed;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_AUTO_FCSO_ALLOWED_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_SDB_IN_RCNM_IND_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->sdb_in_rcnm_ind = \
                                                           p_ue_gen_cdma2000_info_from_oam->sdb_in_rcnm_ind;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_SDB_IN_RCNM_IND_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_DAYLT_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->daylt = \
                                                 p_ue_gen_cdma2000_info_from_oam->daylt;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_DAYLT_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->gcsna_l2_ack_timer = \
                                                              p_ue_gen_cdma2000_info_from_oam->gcsna_l2_ack_timer;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT;
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask &
            RRM_OAM_GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->gcsna_sequence_context_timer = \
                                                                        p_ue_gen_cdma2000_info_from_oam->gcsna_sequence_context_timer;

        p_ue_gen_cdma2000_info_to_cellm->bitmask |= \
                                                    RRMCM_RMIF_GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT;
    }
    /* Bug 12675 Fix Start */
    if(p_ue_gen_cdma2000_info_from_oam->bitmask & RRM_OAM_RAND_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->bitmask |= RRMCM_RMIF_RAND_INCLUDED_PRESENT; 
    }

    if(p_ue_gen_cdma2000_info_from_oam->bitmask & RRM_OAM_LTM_OFF_INCLUDED_PRESENT)
    {
        p_ue_gen_cdma2000_info_to_cellm->bitmask |= RRMCM_RMIF_LTM_OFF_INCLUDED_PRESENT;  
    }
    /* Bug 12675 Fix Stop */
    RRM_UT_TRACE_EXIT();
}


/**********************************************************************************
 * Function Name  : rrm_oam_fill_connected_mode_mobility_info
 * Inputs         : *p_cntd_mode_mob_info_to_cellm, *p_cntd_mode_mob_info_from_oam
 * Outputs        : none
 * Returns        : void
 * Description    : This function fill connected mode mobility info
 *                  for CellM module
 **********************************************************************************/
void rrm_oam_fill_connected_mode_mobility_info(
        rrm_connected_mode_mobility_params_t      *p_cntd_mode_mob_info_to_cellm, 
        rrm_oam_connected_mode_mobility_params_t  *p_cntd_mode_mob_info_from_oam)
{
    RRM_UT_TRACE_ENTER();

    /*Populating common_params_for_eutra_info*/
    if( p_cntd_mode_mob_info_from_oam->bitmask &
            RRM_OAM_COMMON_PARAMS_FOR_EUTRA_PRESENT)
    {
        rrm_oam_fill_common_params_for_eutra_info(
                &p_cntd_mode_mob_info_to_cellm->common_params_for_eutra,  
                &p_cntd_mode_mob_info_from_oam->common_params_for_eutra);
        p_cntd_mode_mob_info_to_cellm->bitmask |= RRMCM_RMIF_COMMON_PARAMS_FOR_EUTRA_PRESENT ;
    }
    /* Populating Irat Info*/
    if( p_cntd_mode_mob_info_from_oam->bitmask &
            RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT )
    {
        p_cntd_mode_mob_info_to_cellm->irat.bitmask =
            p_cntd_mode_mob_info_from_oam->irat.bitmask;
        p_cntd_mode_mob_info_to_cellm->irat.qoffset_tutra = \
                                                            p_cntd_mode_mob_info_from_oam->irat.qoffset_tutra;
        p_cntd_mode_mob_info_to_cellm->irat.filter_coefficient_utra = \
                                                                      p_cntd_mode_mob_info_from_oam->irat.filter_coefficient_utra;
        p_cntd_mode_mob_info_to_cellm->irat.meas_quantity_utra_fdd = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.meas_quantity_utra_fdd;
        p_cntd_mode_mob_info_to_cellm->irat.b1_threshold_utra_rscp = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b1_threshold_utra_rscp;
        p_cntd_mode_mob_info_to_cellm->irat.b1_threshold_utra_ecn0 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b1_threshold_utra_ecn0;
        p_cntd_mode_mob_info_to_cellm->irat.q_offset_geran = \
                                                             p_cntd_mode_mob_info_from_oam->irat.q_offset_geran;
        p_cntd_mode_mob_info_to_cellm->irat.filter_coefficient_geran = \
                                                                       p_cntd_mode_mob_info_from_oam->irat.filter_coefficient_geran;
        p_cntd_mode_mob_info_to_cellm->irat.b1_threshold_geran = \
                                                                 p_cntd_mode_mob_info_from_oam->irat.b1_threshold_geran;
        p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_2utra_rscp = \
                                                                      p_cntd_mode_mob_info_from_oam->irat.b2_threshold_2utra_rscp;
        p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_2utra_ecn0 = \
                                                                      p_cntd_mode_mob_info_from_oam->irat.b2_threshold_2utra_ecn0;
        p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_2geran = \
                                                                  p_cntd_mode_mob_info_from_oam->irat.b2_threshold_2geran;
        p_cntd_mode_mob_info_to_cellm->irat.hysteresis = \
                                                         p_cntd_mode_mob_info_from_oam->irat.hysteresis;
        p_cntd_mode_mob_info_to_cellm->irat.time_to_trigger = \
                                                              p_cntd_mode_mob_info_from_oam->irat.time_to_trigger;
        p_cntd_mode_mob_info_to_cellm->irat.max_report_cells = \
                                                               p_cntd_mode_mob_info_from_oam->irat.max_report_cells;
        p_cntd_mode_mob_info_to_cellm->irat.report_interval = \
                                                              p_cntd_mode_mob_info_from_oam->irat.report_interval;
        p_cntd_mode_mob_info_to_cellm->irat.report_amount = \
                                                            p_cntd_mode_mob_info_from_oam->irat.report_amount;

        p_cntd_mode_mob_info_to_cellm->bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT ;
        if(p_cntd_mode_mob_info_from_oam->irat.bitmask &
                RRM_OAM_UE_GENERIC_PARAMS_PRESENT)
        {
            rrm_oam_fill_ue_gen_cdma2000_params(
                    &p_cntd_mode_mob_info_to_cellm->irat.ue_generic_cdma2000_params,
                    &p_cntd_mode_mob_info_from_oam->irat.ue_generic_cdma2000_params);

            p_cntd_mode_mob_info_to_cellm->irat.bitmask |= \
                                                           RRMCM_RMIF_UE_GENERIC_PARAMS_PRESENT;
        }
        /* Bug 13021 fix start */
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_THRESHOLD_1RSRP_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_1rsrp = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_threshold_1rsrp;
        }
        else
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_1rsrp = \
                                                                     RRM_DEFAULT_VALUE_FOR_B2_THRESHOLD1_RSRP;
        }

        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_THRESHOLD_1RSRQ_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_1rsrq = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_threshold_1rsrq;
        }
        else
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_threshold_1rsrq = \
                                                                     RRM_DEFAULT_VALUE_FOR_B2_THRESHOLD1_RSRQ;
        }
        /* Bug 13021 fix end */
#ifdef ENDC_ENABLED
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B1_NR_THRESHOLD_RSRP_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b1_nr_threshold_rsrp = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b1_nr_threshold_rsrp;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B1_NR_THRESHOLD_RSRQ_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b1_nr_threshold_rsrq = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b1_nr_threshold_rsrq;
        }

        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B1_NR_THRESHOLD_SINR_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b1_nr_threshold_sinr = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b1_nr_threshold_sinr;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_NR_THRESHOLD2_RSRP_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_nr_threshold2_rsrp = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_nr_threshold2_rsrp;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_NR_THRESHOLD2_RSRQ_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_nr_threshold2_rsrq= \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_nr_threshold2_rsrq;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_NR_THRESHOLD2_SINR_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_nr_threshold2_sinr = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_nr_threshold2_sinr;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_NR_THRESHOLD1_RSRP_EUTRA_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_nr_threshold1_rsrp_eutra = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_nr_threshold1_rsrp_eutra;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_B2_NR_THRESHOLD1_RSRQ_EUTRA_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.b2_nr_threshold1_rsrq_eutra = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.b2_nr_threshold1_rsrq_eutra;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_OFFSET_FREQ_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.offset_freq_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.offset_freq_r15;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_QUANTITY_CONFIG_SET_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.quantity_config_set_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.quantity_config_set_r15;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_REPORT_QUANTITY_NR_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.report_quantity_nr = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.report_quantity_nr;
        }
/* NR_REP_CONFIG_FIX_START */
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_TRIGGER_QUANTITY_NR_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.trigger_quantity_nr = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.trigger_quantity_nr;
        }
/* NR_REP_CONFIG_FIX_END */
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_FILTER_COEFF_RSRP_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.filter_coeff_rsrp_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.filter_coeff_rsrp_r15;
        }
        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_FILTER_COEFF_RSRQ_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.filter_coeff_rsrq_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.filter_coeff_rsrq_r15;
        }

        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_FILTER_COEFF_SINR_PRESENT)
        {
            p_cntd_mode_mob_info_to_cellm->irat.filter_coeff_sinr_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.filter_coeff_sinr_r15;
        }

        if ( p_cntd_mode_mob_info_from_oam->irat.bitmask & RRM_OAM_NR_REPORT_ON_LEAVE_PRESENT )
        {
            p_cntd_mode_mob_info_to_cellm->irat.report_on_leave_r15 = \
                                                                     p_cntd_mode_mob_info_from_oam->irat.report_on_leave_r15;
        }
#endif
    }

    RRM_UT_TRACE_EXIT();
}

/* Coverity_ID : 41563 start*/
/****************************************************************************
 * Function Name  : rrm_map_antenna_ports_count_number_from_oam_to_cellm
 * Inputs         : antenna_ports_count_number
 * Outputs        : None
 * Returns        : antenna_ports_count_et
 * Description    : This function map antenna port number from OAM to cellm
 ****************************************************************************/
    antenna_ports_count_et
rrm_map_antenna_ports_count_number_from_oam_to_cellm(
        U8 antenna_ports_count_number_from_oam)
{
    antenna_ports_count_et antenna_ports_count_number_to_cellm = 
        ANTENNA_PORTS_COUNT_AN1;

    RRM_UT_TRACE_ENTER();
    switch (antenna_ports_count_number_from_oam)
    {
        case RRM_ONE:
            antenna_ports_count_number_to_cellm = ANTENNA_PORTS_COUNT_AN1;
            break;
        case RRM_TWO:
            antenna_ports_count_number_to_cellm = ANTENNA_PORTS_COUNT_AN2;
            break;
        case RRM_FOUR:
            antenna_ports_count_number_to_cellm = ANTENNA_PORTS_COUNT_AN4;
            break;
        case RRM_FIVE:
            antenna_ports_count_number_to_cellm = ANTENNA_PORTS_COUNT_SPARE1;
            break;
        default :
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,\
                    RRM_BRIEF,"Invalid antenna ports count number recieved:%d \
                    So assigning ANTENNA_PORTS_COUNT_AN1 by default",\
                    antenna_ports_count_number_from_oam);
            break;
    }
    RRM_UT_TRACE_EXIT();

    return antenna_ports_count_number_to_cellm;
}
/* Coverity_ID : 41563 end*/
/****************************************************************************
 * Function Name  : fill_ran_info_for_cell_reconfig
 * Inputs         : - p_ran_info_to_cellm
 *                  - p_ran_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the RAN info for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_ran_info_for_cell_reconfig(
        ran_t                       *p_ran_info_to_cellm, 
        operator_info_t              *p_operator_info_to_cellm,
        rrm_oam_ran_t               *p_ran_info_from_oam,
        rrm_oam_eutran_global_cell_id_t    *p_cell_id_from_oam)
    /* SPR 20653 Fix End */
    /*SPR 17777 +-*/
    /*BUG_866_CHANGES_START*/
    //rrm_oam_epc_t                *p_epc_info_from_oam,
    /*BUG_866_CHANGES_END*/
    /*SPR 17777 +-*/
{
    U8 cell_idx = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_ran_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_cell_id_from_oam);

    RRM_UT_TRACE_ENTER();

    /* Initialize bitmask */
    p_ran_info_to_cellm->bitmask = 0x00;
    p_operator_info_to_cellm->bitmask = 0x00;

    /* SPR 12603_12618 Fix start */
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /* SPR 12603_12618 Fix end   */


    /* Populating Physical Layer Info */
    if(p_ran_info_from_oam->bitmask & RRM_OAM_PHY_LAYER_PARAMS_PRESENT)
    {
        /* SPR 20653 Fix Start */
        fill_phy_layer_info_for_cell_reconfig( 
                &p_ran_info_to_cellm->physical_layer_params, 
                &p_ran_info_from_oam->physical_layer_params);
        /* SPR 20653 Fix End */
        /*SPR 17777 +-*/
        p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT;
    }
    /* Populating MAC Layer Info */
    if(p_ran_info_from_oam->bitmask & RRM_OAM_MAC_LAYER_PARAMS_PRESENT)
    {
        /* SPR 20653 Fix Start */
        fill_mac_layer_info_for_cell_reconfig(&p_ran_info_to_cellm->mac_layer_params, 
                &p_ran_info_from_oam->mac_layer_params);
        /* SPR 20653 Fix End */
        p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT;
    }
    /* Populating RLC Layer Info */   
    if(p_ran_info_from_oam->bitmask & RRM_OAM_RLC_LAYER_PARAMS_PRESENT )
    {
        fill_rlc_layer_info(/*SPR 17777 +-*/
                &p_ran_info_to_cellm->rlc_layer_params, 
                &p_ran_info_from_oam->rlc_layer_params);

        p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_RLC_LAYER_PARAMS_PRESENT;
    }
    /* Populating Mobility Info Info */   
    if( p_ran_info_from_oam->bitmask & RRM_OAM_MOBILITY_LAYER_PARAMS_PRESENT)
    {
        fill_mobility_info_for_cell_reconfig(&p_ran_info_to_cellm->mobility_params, 
                /* CSR_00057814_CHANGES_START */
                &p_ran_info_from_oam->mobility_params,
                p_ran_info_from_oam);
        /* CSR_00057814_CHANGES_END */

        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT;
    }
    /* Populating RRC Timers_Constant Info */   
    if( p_ran_info_from_oam->bitmask & RRM_OAM_RRC_TIMERS_CONST_PARAMS_PRESENT)
    {
        fill_rrc_timer_constant_info_cell_reconfig(&p_ran_info_to_cellm->rrc_timers_and_constants, 
                &p_ran_info_from_oam->rrc_timers_and_constants);
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT;
    }

    /* Populating RF Info */   
    if( p_ran_info_from_oam->bitmask & RRM_OAM_RF_PARAMS_PRESENT)
    {
        /* SPR 20653 Fix Start */
        fill_rf_info(&p_ran_info_to_cellm->rf_params, 
                &p_ran_info_from_oam->rf_params);
        /* SPR 20653 Fix End */
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_RF_PARAMS_PRESENT;
    }
    /* SPR 20653 Fix Start */
    if (p_ran_info_from_oam->rf_params.rf_configurations.bitmask & RRM_OAM_ANTENNA_PORTS_COUNT_NO_PRESENT)
    {
        /* SPR 21417 FIXED START */
         p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_ANTENNA_PORTS_COUNT_NO_PRESENT;
        /* SPR 21417 FIXED END*/
        p_ran_info_to_cellm->antenna_info.antenna_ports_count_number = 
            rrm_map_antenna_ports_count_number_from_oam_to_cellm(
                    p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number);
        if (RRM_THREE == p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Antenna port number(%d) range invalid", 
                    p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number);
        }
    }
    /* SPR 20653 Fix End */

    /* Populating Common EUTRAN Info */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Common EUTRAN Info");
    for (cell_idx = 0; cell_idx < MAX_CELL_IDENTITY_OCTETS; cell_idx++)
    {
        p_ran_info_to_cellm->common_eutran_params.cell_identity[cell_idx] = 
            p_cell_id_from_oam->cell_identity[cell_idx];
    }
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT;

    /* Populating S1-AP Info */   
    if(p_ran_info_from_oam->bitmask & RRM_OAM_S1AP_PARAMS_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating S1AP Info");
        p_ran_info_to_cellm->s1ap_params.t_reloc_prep=
            p_ran_info_from_oam->s1ap_params.t_reloc_prep;
        p_ran_info_to_cellm->s1ap_params.t_reloc_overall = 
            p_ran_info_from_oam->s1ap_params.t_reloc_overall;
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_S1AP_PARAMS_PRESENT;
    }
    /* Populating NCL Info */   
    if (p_ran_info_from_oam->bitmask & RRM_OAM_NCL_PARAMS_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_NCL_PARAMS_PRESENT");

        /* SPR 5193 */
        fill_ncl_info(/*SPR 17777 +-*/
                &p_ran_info_to_cellm->ncl_params, 
                p_operator_info_to_cellm,
                &p_ran_info_from_oam->ncl_params);
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT;
    }

    /* Populating connected mode mobility*/
    if (RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT == 
            (p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT");
        rrm_oam_fill_connected_mode_mobility_info(
                &p_ran_info_to_cellm->connected_mode_mobility_params, 
                &p_ran_info_from_oam->connected_mode_mobility_params);
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT;
    }
    if(p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT)
    {
        if(p_ran_info_from_oam->connected_mode_mobility_params.bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)
        {
            /* SPR 16880: start */
            /* SPR 20653 Fix Start */
            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_MEAS_QUANTITY_CDMA2000_PRESENT)
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.meas_quantity_cdma2000 = 
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.meas_quantity_cdma2000;

            }
            else
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.meas_quantity_cdma2000 = RRM_RRC_PILOT_STRENGTH;
            }
            /* SPR 16880: end */
            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_B1_THRESHOLD_CDMA2000_PRESENT)
            {
                /* SPR 16880: start */
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b1_threshold_cdma2000 = 
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.b1_threshold_cdma2000;
                /* SPR 16880: end */

            }
            else
            {
                /* SPR 16880: start */
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b1_threshold_cdma2000 =
                    RRM_DEFINED_DEFAULT_VALUE_FOR_B1_THRESHOLD_CDMA2000;
                /* SPR 16880: end */
            }

            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_B2_THRESHOLD_2CDMA_PRESENT)
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b2_threshold_cdma2000 =
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.b2_threshold_2cdma;

            }
            else
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b2_threshold_cdma2000 =
                    RRM_DEFINED_DEFAULT_VALUE_FOR_B2_THRESHOLD_CDMA2000;
            }
            /* SPR 20653 Fix End */
            /* SPR 16880: start */
            /* Code removed */
            /* SPR 16880: end */
            p_ran_info_to_cellm->connected_mode_mobility_params.bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;
        }
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}



/****************************************************************************
 * Function Name  : fill_epc_info_fro_cell_reconfig
 * Inputs         : - p_epc_info_to_cellm
 *                  - p_epc_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the EPC info for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_epc_info_for_cell_reconfig(
        epc_t                        *p_epc_info_to_cellm, 
        rrm_oam_epc_t                *p_epc_info_from_oam,
        /* SPR 18641_18843 fix start */
        rrm_oam_ran_t                *p_ran_info_from_oam,
        U8                           *p_tti_bundling_info_present) 
/* SPR 20653 Fix End */
/* SPR 18641_18843 fix end */
{
    U16 plmn_count= RRM_ZERO;
    U16 tac_count = RRM_ZERO;
    U16 eaid_count= RRM_ZERO;
    U16 qos_count = RRM_ZERO;
    /* + SPS_TDD_Changes */
    /* Code removed as this is for FDD and TDD both*/
    /* - SPS_TDD_Changes */
    /* SPS related changes start */

    /* SPS related changes start */
    U8 qci_val = RRM_ZERO;
    /* SPS related changes end */

    RRM_ASSERT (RRM_PNULL != p_epc_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_epc_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating EPC Info");

    /* Initialize the bitmask */
    p_epc_info_to_cellm->epc_params.bitmask = 0x00;

    /* epc general params - start */
    if( p_epc_info_from_oam->epc_params.bitmask & RRM_OAM_GENERAL_EPC_PARAMS_PRESENT)
    {
        p_epc_info_to_cellm->epc_params.general_epc_params.bitmask = 0x00;

        p_epc_info_to_cellm->epc_params.general_epc_params.num_valid_plmn= 
            p_epc_info_from_oam->epc_params.general_epc_params.num_valid_plmn;  

        p_epc_info_to_cellm->epc_params.general_epc_params.num_valid_plmn= 
            p_epc_info_from_oam->epc_params.general_epc_params.num_valid_plmn;  

        /* PLMN INFO*/
        for (plmn_count=0; 
                ((plmn_count < p_epc_info_to_cellm->epc_params.general_epc_params.
                  num_valid_plmn)&& (plmn_count < MAX_PLMN_LIST)); 
                plmn_count++)
        {
            /* SPR 10730 Fix Start */
            fill_cell_plmn_info(
                    &p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].plmn_id, 
                    &p_epc_info_from_oam->epc_params.general_epc_params.plmn_list[plmn_count].plmn_info);
            p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
                cell_reserved_for_operator_use = p_epc_info_from_oam->epc_params.
                general_epc_params.plmn_list[plmn_count].reserve_operator_use;

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "Reserved Cell for Operator[%d]",
                    p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
                    cell_reserved_for_operator_use);

            p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask =
                0x00;
            p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask |=
                RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT;

            /* SPR 10730 Fix End */
            /* SPR 23209 FIXED START*/
            if( p_epc_info_from_oam->epc_params.general_epc_params.plmn_list[plmn_count].bitmask
                    & RRM_OAM_MOCN_OPERATOR_IDENTITY_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask |=
                    RRMCM_RMIF_MOCN_OPERATOR_INDENTITY_PRESENT;

                p_epc_info_to_cellm->epc_params.general_epc_params.
                    plmn_list[plmn_count].mocn_operator_identity =
                    p_epc_info_from_oam->epc_params.general_epc_params.
                    plmn_list[plmn_count].mocn_operator_identity;

                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "MOCN Operator ID for Operator[%d]",
                        p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
                        mocn_operator_identity);
            }

            /* SPR 23209 FIXED END*/

        }

        /*tac*/
        for (tac_count=0; tac_count< MAX_TAC_SIZE; tac_count++)
        {
            p_epc_info_to_cellm->epc_params.general_epc_params.tac[tac_count]=
                p_epc_info_from_oam->epc_params.general_epc_params.tac[tac_count];   
        }

        /*eaid*/
        if (p_epc_info_from_oam->epc_params.general_epc_params.bitmask & 
                RRM_OAM_EMERGENCY_AREA_ID_PRESENT)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_EMERGENCY_AREA_ID_PRESENT");
            for (eaid_count=0; eaid_count< MAX_EAID; eaid_count++)
            {
                p_epc_info_to_cellm->epc_params.general_epc_params.eaid[eaid_count]=
                    p_epc_info_from_oam->epc_params.general_epc_params.eaid[eaid_count];
            }
            p_epc_info_to_cellm->epc_params.general_epc_params.bitmask |=
                RRMCM_RMIF_EA_ID_PRESENT;

        }/* general epc params - end */

        p_epc_info_to_cellm->epc_params.bitmask |= RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT;
    }
    /*qos info - start*/
    p_epc_info_to_cellm->epc_params.num_valid_qos_profiles = 
        p_epc_info_from_oam->epc_params.num_valid_qos_profiles;  
    for (qos_count=0; 
            ((qos_count<p_epc_info_to_cellm->epc_params.num_valid_qos_profiles)&&
             (qos_count<RRM_MAX_QCI) ); qos_count++)
    {
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].qci;

        if (  p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_DSCP_PRESENT )
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_DSCP_PRESENT");
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].dscp=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].dscp;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask|= 
                RRMCM_RMIF_DSCP_PRESENT;
        }
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_LOSSLESS_HO_REQ_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].lossless_ho_required=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].lossless_ho_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_LOSSLESS_HO_REQ_PRESNET;

        }
        /*BUG_11564_CHANGES_START*/
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_DL_FWDING_APPLICABLE)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].dl_forwarding_applicability =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].dl_forwarding_applicability;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_DL_FWDING_PRESENT;

        }
        /*BUG_11564_CHANGES_END*/
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_UE_INACTIVE_TIMER_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].ue_inactivity_timer_config=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].ue_inactivity_timer_config;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_UE_INACTIVE_TIMER_PRESENT;
        }
        /*For limiting UE measurement start*/
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SUPPORTED_RAT_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].supported_rat=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].supported_rat;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SUPPORTED_RAT_PRESENT;
        }
        /*For limiting UE measurement end*/

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].type =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].type;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].priority=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].priority;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].packet_delay_budget=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].packet_delay_budget;

        /* Loss-less data transfer changes start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].lossless_ho_required = 
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].lossless_ho_required;
        /* Loss-less data transfer changes end */

        /*For limiting UE measurement*/
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].supported_rat =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].supported_rat;

        /*Added for RCC*/
        if (RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT == (p_epc_info_from_oam->epc_params.
                    qos_config_params[qos_count].bitmask & RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT");
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].packet_error_loss_rate = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].packet_error_loss_rate;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_PACKET_ERROR_LOSS_PRESENT;
        }

        /* erb service profile - start*/ 
        /* pdcp_config - start */
        /*It is mandatory for RRM if not available from OAM side value will be taken from Macro*/
        /* SPR 20653 Fix Start */
        if ( p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_RLC_MODE_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                data_transfer_mode = p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_mode;
        }
        /* Code Removed */

        if((p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                    RRM_OAM_PDCP_ROHC_PARAMS_PRESENT) &&
                (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.bitmask & 
                 RRM_OAM_ROHC_ENABLE_PRESENT))
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                enable_rohc = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.enable_rohc;
        }
        /* Code Removed */

        /* CHANGES_FRM_XML_TO_CFG START */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
            pdcp_config.bitmask = 0x00;
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_DISCARD_TIMER_ERB_SERVICE_PROFILE_PRESENT;
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_AM_STATUS_REPORT_REQ_ERB_SERVICE_PROFILE_PRESENT;
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_AM_ENB_STATUS_REPORT_REQ_ERB_SERVICE_PROFILE_PRESENT;

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_PDCP_DISCARD_TIMER_PRESENT ) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                pdcp_config.discard_timer=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].pdcp_discard_timer;
        }
        /* Code Removed */

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_RLC_AM_STATUS_REPORT_PRESENT) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                rlc_am_status_report_required = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_am_status_report_required;
        }
        /* Code Removed */


        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_RLC_AM_ENB_STATUS_REPORT_PRESENT) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                rlc_am_enb_status_report_required =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_am_enb_status_report_required;
        }
        /* Code Removed */
        /* CHANGES_FRM_XML_TO_CFG END */


        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
            header_compression.bitmask = 0x00;


        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.enable_rohc == RRM_TRUE)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_1_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0001 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0001;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_2_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0002 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0002;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_3_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0003 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0003;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_4_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0004 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0004;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_6_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0006 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0006;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_101_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0101 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0101;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_102_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0102 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0102;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_103_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0103 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0103;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_104_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0104 =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0104;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.bitmask & RRM_OAM_ROHC_MAX_CID_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.max_cid = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.max_cid;
            }
            /* Code Removed */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                header_compression.bitmask |= RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_ERB_SERVICE_PROFILE_PRESENT;
        }
        else
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                header_compression.bitmask = 0x00;
        }

        /* pdcp_config - end */

        /* rlc_config - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask = 0x00;

        /*data_transfer_mode-1 for AM
          data_transfer_mode-2 for UM*/


        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_ADDL_RLC_PARAM_PRESENT)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_RETRSMIT_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.t_poll_retransmit = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_poll_retransmit;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_POLL_PDU_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.poll_pdu = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_poll_pdu;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_REORDER_FOR_AM_MODE_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.dl_am_rlc.t_reordering =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_reordering_am;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_STATUS_PROHIBIT_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.dl_am_rlc.t_status_prohibit =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_status_prohibit;
            }
            /* Code Removed */
            /* CHANGES_FRM_XML_TO_CFG START*/
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_UL_AM_POLL_BYTE_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.poll_byte = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.ul_am_poll_byte;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_MAX_RTX_THRESHOLD_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.max_retx_threshold = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.ul_am_rrc_max_retx_threshold;
            }
            /* Code Removed */
            /* CHANGES_FRM_XML_TO_CFG END */
        }
        /* SPR 20653 Fix End */

        /* Filling params of RLC Config ERB Service Profile */
        /* SPR 20653 Fix Start */
        if( RRM_OAM_GBR == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].type)
        {
            if( QCI_VAL_4 == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].qci)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_gbr/ RRM_TWO;
            }
            else
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_gbr;
            }
        }
        else
        {
            if(QCI_VAL_9 == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].type)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_ngbr / RRM_TWO;
            }
            else
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_ngbr;

            }
        }
        /* SPR 20653 Fix End */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_AM_CONFIG_ERB_SERVICE_PROFILE_PRESENT;
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_UM_PDCP_SN_SIZE_ERB_SERVICE_PROFILE_PRESENT;

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_SN_FIELD_LEN_PRESENT) 
        {
            /*Cov_fix_start_64291*/
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT)
            {
                /* SPR_10949_CHANGES_START */
                /* SPR 20653 Fix Start */
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.ul_rlc)
                {
                    case RRM_OAM_SN_FIELD_LEN_UL_RLC_5_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ZERO;
                        break;
                    case RRM_OAM_SN_FIELD_LEN_UL_RLC_10_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ONE;
                        break;
                    default :
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ZERO;
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.ul_rlc);
                }
                /* SPR_10949_CHANGES_END */
            }
            /* Code Removed */
            /* Coverity 64921 fix start */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    um_uni_directional_dl_config.dl_um_rlc.sn_field_length =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.dl_rlc;
                /* SPR_10949_CHANGES_START */
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.dl_rlc)
                {
                    case RRM_OAM_SN_FIELD_LEN_DL_RLC_5_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ZERO;
                        break;
                    case RRM_OAM_SN_FIELD_LEN_DL_RLC_10_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ONE;
                        break;
                    default :
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.dl_rlc);
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ZERO;
                }
                /* SPR_10949_CHANGES_END */
            }
            /* Coverity 64921 fix end */
            /* Code Removed */
            /* SPR_10949_CHANGES_START */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT)
            {
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.rlc_um_pdcp_sn_size)
                {
                    case RRM_OAM_RLC_UM_PDCP_SN_SIZE_7_BITS:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ZERO; 
                        break;
                    case RRM_OAM_RLC_UM_PDCP_SN_SIZE_12_BITS:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ONE;
                        break;
                    default:
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.rlc_um_pdcp_sn_size);
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ZERO;
                }
            }
            /* Code Removed */
            /* SPR_10949_CHANGES_END */
            /*Cov_fix_end_64291*/
        }
        /* Code removed */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_ERB_SERVICE_PROFILE_PRESENT;


        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_ERB_SERVICE_PROFILE_PRESENT;

        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                RRM_OAM_TMR_REORDER_FOR_UM_MODE_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                um_uni_directional_dl_config.dl_um_rlc.t_reordering = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_reordering_um;
        }
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* CHANGES_FRM_XML_TO_CFG END */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_ERB_SERVICE_PROFILE_PRESENT;
        rrm_memcpy_rrc_uplink_um_rlc_erb_service_profile(
                &p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_bi_directional_config.ul_um_rlc,
                &p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_uni_directional_ul_config.ul_um_rlc);
        rrm_memcpy_rrc_uplink_um_rlc_erb_service_profile(
                (rrc_uplink_um_rlc_erb_service_profile_t *)&p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_bi_directional_config.dl_um_rlc,
                (rrc_uplink_um_rlc_erb_service_profile_t *)&p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_uni_directional_dl_config.dl_um_rlc);

        /* rlc_config - end */

        /*mac config - start*/
        /*SPR 5169 start*/
        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SR_CONFIGURATION_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.mac_config.
                sr_prohibit_timer_r9 = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.sr_prohibit_timer_r9;

            /* SPR 20653 Fix Start */
            /* Code removed */
            /* SPR 20653 Fix End */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.mac_config.
                sr_max_transmissions = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.dsr_trans_max;

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sr_mask_flag =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.sr_mask_flag;
        }
        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* CHANGES_FRM_XML_TO_CFG END */

        /*SPR 5169 end*/
        /*mac config - end*/

        /* ul_specific_parameters - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            bitmask = 0x00;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            priority =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].priority;

        /* CHANGES_FRM_XML_TO_CFG START */
        /* SPR 20653 Fix Start */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_PRIORITIZED_BIT_RATE_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
                prioritized_bit_rate =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].prioritized_bit_rate;
        }
        /* CHANGES_FRM_XML_TO_CFG END */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_BUCKET_SIZE_DURATION_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
                bucket_size_duration =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bucket_size_duration;
        }
        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_LOGICAL_CHANNEL_GROUP_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
                logical_channel_group =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].logical_channel_group;
        }
        /* Code Removed */
        /* CHANGES_FRM_XML_TO_CFG END */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            bitmask |= RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_ERB_SERVICE_PROFILE_PRESENT;

        /* ul_specific_parameters - end */

        /* rrc_ul_sch_config_profile - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            bitmask = 0x00;

        if( RRM_OAM_MAX_HARQ_TX_PRESENT & p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                max_harq_tx =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].max_harq_tx;
        }
        /* Code Removed */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;

        if( RRM_OAM_ADDL_MAC_PARAM_PRESENT & p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.bitmask &
                    RRM_OAM_PERIODIC_TMR_BSR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                    periodic_bsr_timer =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.t_periodic_bsr;
            }
            /* Code Removed */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT;

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.bitmask &
                    RRM_OAM_PERIODIC_PHR_TMR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                    erb_service_profile.phr_config.phr_config_param.periodic_phr_timer = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_periodic_phr;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.bitmask &
                    RRM_OAM_PROHIBIT_PHR_TMR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                    erb_service_profile.phr_config.phr_config_param.prohibit_phr_timer = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_prohibit_phr;
            }
            /* Code Removed */

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.bitmask &
                    RRM_OAM_DL_PATHLOSS_TMR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                    erb_service_profile.phr_config.phr_config_param.dl_pathloss_change = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_pathloss_chng;
            }
            /* Code Removed */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.phr_config.bitmask = 0x00;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                erb_service_profile.phr_config.bitmask |= RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT;

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.bitmask & 
                    RRM_OAM_RETX_TMR_BSR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                    retx_bsr_timer =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.t_retx_bsr;
            }
            /* Code Removed */
        }
        /* Code Removed */
        /* SPR 20653 Fix End */
        /*Start changes for TTI bundling feature*/
#ifndef TDD_MODE_FLAG    
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_TTI_BUNDLING_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                tti_bundling =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].tti_bundling;
            /* SPR 18641_18843 fix start */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].tti_bundling)
            {
                *p_tti_bundling_info_present = RRM_TRUE;
            }
            /* SPR 18641_18843 fix end */
        }
        else
        {
            /*Disable tti bundling feature if it is not provided by OAM */
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                tti_bundling = 0;
        }
#else 
        /*TTI bundling feature is not supported in TDD mode by L2 in this release */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            tti_bundling = 0;
#endif

        /*End changes for TTI bundling feature*/

        /* rrc_ul_sch_config_profile - end */

        /* rrm_s1u_config_erb_service_profile_t - start */

        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* rrm_s1u_config_erb_service_profile_t - ends */

        /* erb_service_profile - end */
        /* + SPS_TDD_Changes */
        /* Code removed as this is for FDD and TDD both*/
        /* - SPS_TDD_Changes */
        /* SPS related changes start */
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SPS_CONFIG_ENABLED_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_config_enabled = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_config_enabled;

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SPS_CONFIG_ENABLED_PRESENT;
        }

        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SPS_CONFIG_DATA_PRESENT)
        {
            qci_val = p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci;
            populate_sps_config_data(&(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_data),
                    &(p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_data),
                    qci_val, p_ran_info_from_oam->physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch);
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT;
        }

        else
        {
            if(1 == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_config_enabled)
            {
                qci_val = p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci;
                populate_sps_config_data(&(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_data),
                        &(p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_data),
                        qci_val, p_ran_info_from_oam->physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch);
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |= 
                    RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT;
            }
        }
        /* SPS related changes end */
        /* + SPS_TDD_Changes */
        /* Code removed as this is for FDD and TDD both*/
        /* - SPS_TDD_Changes */
        /* SPS - sr_mask_flag CR start */
        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* SPS - sr_mask_flag CR end */

        /* SPR_13815_fix: start */
        /* Lines deleted */
        /* SPR_13815_fix: end */

        /*SRVCC SUPPORT START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SRVCC_OP_REQUIRED_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].srvcc_op_required =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].srvcc_op_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SRVCC_OP_REQUIRED_PRESENT;
        }
        /*SRVCC SUPPORT END */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating EPC Info2 \n");
#ifdef ENDC_ENABLED   
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SGNB_BEARER_REQUIRED)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sgnb_bearer_required=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sgnb_bearer_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SGNB_BEARER_REQUIRED;
        }

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SGNB_BEARER_TYPE)
        {
       /*coverity_<280097>_fix_start*/ 
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sgnb_bearer_type =
               (rrm_drb_type_et)p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sgnb_bearer_type;
       /*coverity_<280097>_fix_end*/
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SGNB_BEARER_TYPE_PRESENT;
        }
#endif    

    } 
    /*qos info - start*/


    p_epc_info_to_cellm->epc_params.emergency_erab_arp = p_epc_info_from_oam->epc_params.emergency_erab_arp;

    RRM_UT_TRACE_EXIT();
} 

/* SPS related changes start */
/****************************************************************************
 * Function Name  : populate_sps_config_data
 * Inputs         : - sps_config_data_from_oam
 *                  - sps_config_data_to_cellm
 *                  - qci_val
 * Outputs        : None
 * Returns        : void
 * Description    : This function populates the SPS config data for the CellM module
 ****************************************************************************/
void populate_sps_config_data(
        rrm_oam_sps_config_data_t     *sps_config_data_from_oam,
        rrm_sps_config_data_t         *sps_config_data_to_cellm,
        U8                             qci_val,
        S8                             p_0_nominal_pusch
        )
{

    RRM_ASSERT (RRM_PNULL != sps_config_data_from_oam);
    RRM_ASSERT (RRM_PNULL != sps_config_data_to_cellm);

    RRM_UT_TRACE_ENTER();
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating SPS config Data");

    sps_config_data_to_cellm->bitmask |= 0x00;

    if (sps_config_data_from_oam->bitmask & RRM_OAM_SPS_CONFIG_DL_PRESENT)
    {
        sps_config_data_to_cellm->sps_config_dl.semi_persist_sched_interval_dl =
            sps_config_data_from_oam->sps_config_dl.semi_persist_sched_interval_dl;
        sps_config_data_to_cellm->sps_config_dl.number_of_conf_sps_processes =
            sps_config_data_from_oam->sps_config_dl.number_of_conf_sps_processes;

        /* + SPR 16930 */
        if ((sps_config_data_from_oam->sps_config_dl.semi_persist_sched_interval_dl == RRM_OAM_SEMI_PERSIST_INT_SF_40) &&
                (sps_config_data_from_oam->sps_config_dl.max_sps_harq_retx  > RRM_OAM_SPS_PROFILE_40_MAX_HARQ_RETX)) 
        {     
            sps_config_data_to_cellm->sps_config_dl.max_sps_harq_retx = 
                RRM_OAM_SPS_PROFILE_40_MAX_HARQ_RETX;
        }     
        else if ((sps_config_data_from_oam->sps_config_dl.semi_persist_sched_interval_dl == RRM_OAM_SEMI_PERSIST_INT_SF_20) &&
                (sps_config_data_from_oam->sps_config_dl.max_sps_harq_retx  > RRM_OAM_SPS_PROFILE_20_MAX_HARQ_RETX)) 
        {     
            sps_config_data_to_cellm->sps_config_dl.max_sps_harq_retx = 
                RRM_OAM_SPS_PROFILE_20_MAX_HARQ_RETX;
        }     
        else  
        {     
            sps_config_data_to_cellm->sps_config_dl.max_sps_harq_retx = 
                sps_config_data_from_oam->sps_config_dl.max_sps_harq_retx;
        }     
        /* - SPR 16930 */

        sps_config_data_to_cellm->sps_config_dl.explicit_release_after =
            sps_config_data_from_oam->sps_config_dl.explicit_release_after;

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_DL_PRESENT;
    }

    else if ( (qci_val == 1) || (qci_val == 3) || (qci_val == 5) || (qci_val == 7) )
    {
        sps_config_data_to_cellm->sps_config_dl.semi_persist_sched_interval_dl =
            RRM_OAM_SPS_PROFILE_20_INTERVAL;

        sps_config_data_to_cellm->sps_config_dl.number_of_conf_sps_processes =
            RRM_OAM_SPS_PROFILE_20_CONF_PROCESSES;

        sps_config_data_to_cellm->sps_config_dl.max_sps_harq_retx =
            RRM_OAM_SPS_PROFILE_20_MAX_HARQ_RETX;

        sps_config_data_to_cellm->sps_config_dl.explicit_release_after =
            RRM_OAM_SPS_PROFILE_20_EXPLICIT_RELEASE_AFTER;

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_DL_PRESENT;
    }

    else
    {
        sps_config_data_to_cellm->sps_config_dl.semi_persist_sched_interval_dl =
            RRM_OAM_SPS_PROFILE_40_INTERVAL;

        sps_config_data_to_cellm->sps_config_dl.number_of_conf_sps_processes =
            RRM_OAM_SPS_PROFILE_40_CONF_PROCESSES;

        sps_config_data_to_cellm->sps_config_dl.max_sps_harq_retx =
            RRM_OAM_SPS_PROFILE_40_MAX_HARQ_RETX;

        sps_config_data_to_cellm->sps_config_dl.explicit_release_after =
            RRM_OAM_SPS_PROFILE_40_EXPLICIT_RELEASE_AFTER;

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_DL_PRESENT;
    }

    if(sps_config_data_from_oam->bitmask & RRM_OAM_SPS_CONFIG_UL_PRESENT)
    {
        sps_config_data_to_cellm->sps_config_ul.semi_persist_sched_interval_ul =
            sps_config_data_from_oam->sps_config_ul.semi_persist_sched_interval_ul;

        sps_config_data_to_cellm->sps_config_ul.implicit_release_after =
            sps_config_data_from_oam->sps_config_ul.implicit_release_after;

        if(sps_config_data_from_oam->sps_config_ul.bitmask & RRM_OAM_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT)
        {
            sps_config_data_to_cellm->sps_config_ul.p_zero_nominal_pusch_persistent =
                sps_config_data_from_oam->sps_config_ul.p_zero_nominal_pusch_persistent;

            sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;
        }
        else
        {
            sps_config_data_to_cellm->sps_config_ul.p_zero_nominal_pusch_persistent = 
                p_0_nominal_pusch;

            sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;
        }
        /* + SPS_TDD_Changes */
#ifdef TDD_MODE_FLAG
        if (sps_config_data_from_oam->sps_config_ul.bitmask & RRM_OAM_SPS_TWO_INTERVAL_CONFIG_SUPPORTED)
        {
            sps_config_data_to_cellm->sps_config_ul.two_intervals_config = 
                sps_config_data_from_oam->sps_config_ul.two_interval_supported;
            /*If two_interval_supported is true from OAM. Then only set the bitmask for message of CELLM.
             *As RRC expects only a true value*/
            if (RRM_OAM_TWO_INTERVAL_PRESENT == sps_config_data_from_oam->sps_config_ul.two_interval_supported)
            {
                sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_TWO_INTERVAL_CONFIG;
            }
        }
#endif
        /* - SPS_TDD_Changes */

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_UL_PRESENT;
    }

    else if ((qci_val == 1) || (qci_val == 3) || (qci_val == 5) || (qci_val == 7))
    {
        sps_config_data_to_cellm->sps_config_ul.semi_persist_sched_interval_ul =
            RRM_OAM_SPS_PROFILE_20_INTERVAL;

        sps_config_data_to_cellm->sps_config_ul.implicit_release_after =
            RRM_OAM_SPS_PROFILE_20_IMPLICIT_RELEASE_AFTER;

        sps_config_data_to_cellm->sps_config_ul.p_zero_nominal_pusch_persistent = 
            p_0_nominal_pusch;

        sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;
        /* + SPS_TDD_Changes */
#ifdef TDD_MODE_FLAG
        sps_config_data_to_cellm->sps_config_ul.two_intervals_config = RRM_OAM_TWO_INTERVAL_PRESENT;
        sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_TWO_INTERVAL_CONFIG;
#endif
        /* - SPS_TDD_Changes */

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_UL_PRESENT;
    }

    else
    {
        sps_config_data_to_cellm->sps_config_ul.semi_persist_sched_interval_ul =
            RRM_OAM_SPS_PROFILE_40_INTERVAL;

        sps_config_data_to_cellm->sps_config_ul.implicit_release_after =
            RRM_OAM_SPS_PROFILE_40_IMPLICIT_RELEASE_AFTER;

        sps_config_data_to_cellm->sps_config_ul.p_zero_nominal_pusch_persistent =
            p_0_nominal_pusch;

        sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_P_ZERO_NOMINAL_PUSCH_PERSISTENT_PRESENT;
        /* + SPS_TDD_Changes */
#ifdef TDD_MODE_FLAG
        sps_config_data_to_cellm->sps_config_ul.two_intervals_config = RRM_OAM_TWO_INTERVAL_PRESENT;
        sps_config_data_to_cellm->sps_config_ul.bitmask |= RRMCM_RMIF_TWO_INTERVAL_CONFIG;
#endif
        /* - SPS_TDD_Changes */

        sps_config_data_to_cellm->bitmask |= RRMCM_RMIF_SPS_CONFIG_UL_PRESENT;
    }

    RRM_UT_TRACE_EXIT();
}
/* SPS related changes end */

/*****************************************************************************
 * Function Name  : fill_access_mangt_info
 * Inputs         : p_access_mgmt_info_from_oam 
 * Outputs        : p_access_mgmt_Info_to_cellm
 * Returns        : None
 * Description    : This function fills the access management information in the 
 *                  config/reconfig structure going to be sent to cell manager.
 ****************************************************************************/
void fill_access_mangt_info(access_mgmt_params_t		 *p_access_mgmt_Info_to_cellm, 
        rrm_oam_access_mgmt_params_t *p_access_mgmt_info_from_oam)
{
    U16  csg_octate_count = RRM_ZERO;
    U16  hnb_count = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_access_mgmt_Info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_access_mgmt_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populationg Access Management Information");

    /* Populationg Access Management Information Parameters */
    p_access_mgmt_Info_to_cellm->access_mode = 
        p_access_mgmt_info_from_oam->access_mode;
    p_access_mgmt_Info_to_cellm->max_csg_members = 
        p_access_mgmt_info_from_oam->max_csg_members;
    p_access_mgmt_Info_to_cellm->max_non_csg_members = 
        p_access_mgmt_info_from_oam->max_non_csg_members;
    /* p_access_mgmt_Info_to_cellm->max_resource_non_csg_members 
       is not used */

    p_access_mgmt_Info_to_cellm->bitmask = 0x00;
    if (p_access_mgmt_info_from_oam->bitmask & RRM_OAM_CSG_ID_PRESENT)
    {
        p_access_mgmt_Info_to_cellm->bitmask |= 
            RRMCM_RMIF_ACCESS_MGM_CSG_ID_PRESENT;
        for (csg_octate_count=0; csg_octate_count<NUM_CSG_OCTETS; csg_octate_count++)
        {
            p_access_mgmt_Info_to_cellm->csg_id[csg_octate_count] = 
                p_access_mgmt_info_from_oam->csg_id[csg_octate_count];
        }
    }

    p_access_mgmt_Info_to_cellm->hnb_name_size = 
        p_access_mgmt_info_from_oam->hnb_name_size;
    for (hnb_count=0; hnb_count<RRMCM_MAX_HNB_ID; hnb_count++)
    {
        p_access_mgmt_Info_to_cellm->hnb_name[hnb_count] = 
            p_access_mgmt_info_from_oam->hnb_name[hnb_count];
    }

    RRM_UT_TRACE_EXIT(); 
}


/*****************************************************************************
 * Function Name  : populate_tm_mode_table 
 * Inputs         : p_tm_mode_table_from_oam 
 * Outputs        : p_tm_mode_table_to_cellm 
 * Returns        : None
 * Description    : This function fills the transmission mode table 
 ****************************************************************************/
rrm_void_t populate_tm_mode_table( rrm_oam_transmission_mode_table_t 
        *p_tm_mode_table_from_oam,
        rrm_transmission_mode_table_t
        *p_tm_mode_table_to_cellm )
{
    RRM_UT_TRACE_ENTER();
    U8 index = 0;

    if(p_tm_mode_table_from_oam->bitmask & RRM_OAM_TM_MODE_FOR_STRNGNT_QCI_PRESENT)
    {
        /* coverity  : CID 41566 */
        p_tm_mode_table_to_cellm->tm_mode_for_strngnt_qci =
            (transmission_mode_ue_service_profile_et)  p_tm_mode_table_from_oam->tm_mode_for_strngnt_qci;
        p_tm_mode_table_to_cellm->bitmask |= RRM_TM_MODE_FOR_STRNGNT_QCI_PRESENT;   
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "Transmission mode Stringent QCI is not present "); 
    } 
    p_tm_mode_table_to_cellm->count =
        p_tm_mode_table_from_oam->count;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Transmission mode row count [%d]",p_tm_mode_table_to_cellm->count); 

    for(index = RRM_ZERO; index < p_tm_mode_table_from_oam->count ; index ++)
    {
        /* coverity : CID 41564 */
        p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].tm_mode = 
            (transmission_mode_ue_service_profile_et) p_tm_mode_table_from_oam->rrm_tm_mode_table_row[index].tm_mode;
        switch(p_tm_mode_table_from_oam->rrm_tm_mode_table_row[index].sinr_level)
        {
            case 0:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].sinr = RRM_LOW_LEVEL;
                break;
            case 1:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].sinr = RRM_HIGH_LEVEL;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "valure recvd"
                        " for sinr level is not 0/1 setting low be default");
                break;
        }

        switch(p_tm_mode_table_from_oam->rrm_tm_mode_table_row[index].pathloss_level)
        {
            case 0:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].pathloss = RRM_LOW_LEVEL;
                break;
            case 1:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].pathloss = RRM_HIGH_LEVEL;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "valure recvd"
                        " for pathloss level is not 0/1 setting low be default");
                break;
        }

        switch(p_tm_mode_table_from_oam->rrm_tm_mode_table_row[index].mobility_level)
        {
            case 0:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].mobility = RRM_LOW_LEVEL;
                break;
            case 1:
                p_tm_mode_table_to_cellm->rrm_tm_mode_table_row[index].mobility = RRM_HIGH_LEVEL;
                break;
            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "valure recvd"
                        " for pathloss mobility is not 0/1 setting low be default");
                break;
        }
    }

    RRM_UT_TRACE_EXIT();
}
/* BUG_371 FIX START */ 
/* SPR 20653 Fix Start */
void
    populate_operator_sib2_ul_power_ctrl_info
(
 operator_info_t           *p_operator_info_to_cellm,
 rrm_oam_operator_info_t   *p_operator_info_from_oam
 )
    /* SPR 20653 Fix End */
{
    RRM_UT_TRACE_ENTER();
    /* SPR 20653 Fix Start */
    if (p_operator_info_from_oam->bitmask & RRM_OAM_POWER_CONTROL_INFO_PRESENT)
    {
        fill_sib_2_ul_power_control_data(&p_operator_info_from_oam->rrm_power_control_params,
                &(p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl));
    }
    else
    {
        /* Coverity_ID : 53624 */
        /* CID 112398, 112399, 112400,112403, 112404, 112406 Start */ 
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1 = (rrmc_delta_f_pucch_format_one_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF2_CFG;

        /* Coverity_ID : 53625 */
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b = (rrmc_delta_f_pucch_format_one_b_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_DELTAF5_CFG;

        /* Coverity_ID : 53626 */
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2 = (rrmc_delta_f_pucch_format_two_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_2_CFG_DELTAF0_CFG;

        /* Coverity_ID : 53628 */
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2a = (rrmc_delta_f_pucch_format_two_ab_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF0_CFG;

        /* Coverity_ID : 53630 */
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_2b = (rrmc_delta_f_pucch_format_two_ab_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_CFG_DELTAF0_CFG;

        /* CA_Stage3_PUCCH_Format_Enh: Start */
        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.bitmask |=
            RRMCM_RMIF_PUCCH_FORMAT_R10_PRESENT;

        p_operator_info_to_cellm->rrm_operator_ul_pwr_ctrl.delta_f_pucch_format_1b_cs_r10 = (rrmc_delta_f_pucch_format_one_b_cs_r10_et)RRM_RRC_DELTA_F_PUCCH_FORMAT_1B_CS_R10_DELTAF1_CFG;
        /* CA_Stage3_PUCCH_Format_Enh: End */
        /* CID 112398, 112399, 112400,112403, 112404, 112406 End */ 

    }
    /* SPR 20653 Fix End */
    p_operator_info_to_cellm->bitmask |= RRM_RRM_OPERATOR_UL_PWR_CTRL;

    RRM_UT_TRACE_EXIT();
}
/* BUG_371 FIX END */ 


/* Carrier_Aggregation_Start */
/****************************************************************************
 * Function Name  : rrm_fill_ca_reconfig_params
 * Inputs         : - ca_config_to_cellm
 *                  - ca_config_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the CA params info for CellM Module
 ****************************************************************************/
    rrm_void_t
rrm_fill_ca_reconfig_params (rrm_ca_config_t *p_ca_reconfig_to_cellm,
        rrm_oam_ca_config_t *p_ca_reconfig_from_oam
        )
{
    RRM_ASSERT (RRM_PNULL != p_ca_reconfig_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ca_reconfig_from_oam);

    RRM_UT_TRACE_ENTER();
    p_ca_reconfig_to_cellm->bitmask = 0x00;
    if (RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        p_ca_reconfig_to_cellm->is_ca_eligible = p_ca_reconfig_from_oam->is_ca_eligible;
        p_ca_reconfig_to_cellm->bitmask |= RRM_IS_CA_ELIGIBLE_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA param is_ca_eligible is not present in cell reconfig req"); 
    } 
    if (RRM_OAM_NUM_OF_REPORT_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        p_ca_reconfig_to_cellm->num_of_report = p_ca_reconfig_from_oam->num_of_report;
        p_ca_reconfig_to_cellm->bitmask |= RRM_NUM_OF_REPORT_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA param num_of_report is not present in cell reconfig req"); 
    } 
    if (RRM_OAM_CA_APPLICABLE_BITRATE_DL_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        p_ca_reconfig_to_cellm->ca_applicable_bitrate_dl = p_ca_reconfig_from_oam->ca_applicable_bitrate_dl;
        p_ca_reconfig_to_cellm->bitmask |= RRM_CA_APPLICABLE_BITRATE_DL_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA param ca_applicable_bitrate_dl is not present in cell reconfig req"); 
    } 
    if (RRM_OAM_IS_MASA_INFO_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        p_ca_reconfig_to_cellm->is_masa = p_ca_reconfig_from_oam->is_masa;
        p_ca_reconfig_to_cellm->bitmask |= RRM_IS_MASA_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA param is_masa is not present in cell reconfig req"); 
    } 
    if (RRM_OAM_SCELL_DEACTIVATION_TIMER_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        p_ca_reconfig_to_cellm->scell_deactivation_timer = 
            (rrm_scell_deactivation_timer_et)p_ca_reconfig_from_oam->scell_deactivation_timer;
        p_ca_reconfig_to_cellm->bitmask |= RRM_SCELL_DEACTIVATION_TIMER_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA param scell_deactivation_timer is not present in cell reconfig req"); 
    } 
    if (RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & p_ca_reconfig_from_oam->bitmask)
    {
        if (RRM_OAM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.load_calcualtion_window_size = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.load_calcualtion_window_size;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |= 
                RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT;
        }
        if (RRM_OAM_LOAD_DISPARITY_THRESHOLD_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.load_disparity_threshold = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.load_disparity_threshold;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_LOAD_DISPARITY_THRESHOLD_PRESENT;
        }
        if (RRM_OAM_MCS_DIFF_THRESHOLD_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.mcs_diff_threshold = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.mcs_diff_threshold;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_MCS_DIFF_THRESHOLD_PRESENT;
        }
        if (RRM_OAM_PRB_USAGE_WATER_MARK_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.prb_usage_water_mark = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.prb_usage_water_mark;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_PRB_USAGE_WATER_MARK_PRESENT;
        }
        if (RRM_OAM_DL_DEACT_COMMAND_THRESH_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.dl_deact_command_thresh = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.dl_deact_command_thresh;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_DEACT_COMMAND_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_DEACT_MCS_LOW_THRESH_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.dl_deact_mcs_low_thresh = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.dl_deact_mcs_low_thresh;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_Q_LOAD_UP_THRESH_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.dl_qload_up_threshold = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.dl_qload_up_threshold;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_Q_LOAD_UP_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_Q_LOAD_LOW_THRESH_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.dl_qload_low_threshold = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.dl_qload_low_threshold;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_Q_LOAD_LOW_THRESH_PRESENT;
        }
        if (RRM_OAM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.act_deact_trigger_count_threshold = 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.act_deact_trigger_count_threshold;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT;
        }
        /* SPR 16422 START */
        if (RRM_OAM_CQI_VALIDITY_TIMER_PRESENT &
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.cqi_validity_timer= 
                p_ca_reconfig_from_oam->ca_mac_scheduler_params.cqi_validity_timer;
            p_ca_reconfig_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_CQI_VALIDITY_TIMER_PRESENT;
        } 
        /* SPR 16422 END */
        p_ca_reconfig_to_cellm->bitmask |= RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA MAC Sheduler params is not present in cell reconfig req"); 
    } 

    RRM_UT_TRACE_EXIT();
}
/* Carrier_Aggregation_End */

/** eICIC feature changes start */
/****************************************************************************
 * Function Name  : rrm_fill_abs_pattern_info
 * Inputs         : - p_abs_pattern_info_to_cellm
 *                  - p_abs_pattern_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill ABS information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_abs_pattern_info
(
 rrm_abs_pattern_info_t      *p_abs_pattern_info_to_cellm,
 rrm_oam_abs_pattern_info_t  *p_abs_pattern_info_from_oam
 )
{
    U8                  low_load_abs_pattern_index = RRM_ZERO;
    U8                  victim_abs_pattern_index = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_abs_pattern_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_abs_pattern_info_from_oam);

    RRM_UT_TRACE_ENTER();

    p_abs_pattern_info_to_cellm->bitmask = 0x00;
    /* bug_13935_start */ 
    RRM_MEMSET(p_abs_pattern_info_to_cellm->low_load_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(p_abs_pattern_info_to_cellm->victim_abs_pattern,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    RRM_MEMSET(p_abs_pattern_info_to_cellm->victim_meas_subset,RRM_ZERO,RRM_MAX_PATTERN_BYTE);
    /* bug_13935_end */

    /** Filling low load ABS pattern configured from OAM */
    if (RRM_OAM_LOW_LOAD_ABS_PATTERN_PRESENT & p_abs_pattern_info_from_oam->bitmask)
    {
        for (low_load_abs_pattern_index = RRM_ZERO; 
                low_load_abs_pattern_index < RRM_MAX_PATTERN_BYTE;
                low_load_abs_pattern_index++)
        {
            p_abs_pattern_info_to_cellm->low_load_abs_pattern[low_load_abs_pattern_index] =
                p_abs_pattern_info_from_oam->low_load_abs_pattern[low_load_abs_pattern_index];
        }
        p_abs_pattern_info_to_cellm->bitmask |= RRMCM_RMIF_LOW_LOAD_ABS_PATTERN_PRESENT;
    }
    /** Filling high load ABS pattern configured from OAM */
    /*eicic ut fix 23Sept2014 start*/
    if (RRM_OAM_VICTIM_ABS_PATTERN_PRESENT & p_abs_pattern_info_from_oam->bitmask)
    {
        for(victim_abs_pattern_index = RRM_ZERO;
                victim_abs_pattern_index < RRM_MAX_PATTERN_BYTE;
                victim_abs_pattern_index++)
        {
            p_abs_pattern_info_to_cellm->victim_abs_pattern[victim_abs_pattern_index] =
                p_abs_pattern_info_from_oam->victim_abs_pattern[victim_abs_pattern_index];
        }
        p_abs_pattern_info_to_cellm->bitmask |= RRMCM_RMIF_VICTIM_ABS_PATTERN_PRESENT;
    }
    /*eicic ut fix 23Sept2014 end*/
    /*eicic_subset_pattern_fix_start*/
    if (RRM_OAM_VICTIM_MEAS_SUBSET_PRESENT & p_abs_pattern_info_from_oam->bitmask)
    {
        for(victim_abs_pattern_index = RRM_ZERO;
                victim_abs_pattern_index < RRM_MAX_PATTERN_BYTE;
                victim_abs_pattern_index++)
        {
            p_abs_pattern_info_to_cellm->victim_meas_subset[victim_abs_pattern_index] =
                p_abs_pattern_info_from_oam->victim_meas_subset[victim_abs_pattern_index];
        }
        p_abs_pattern_info_to_cellm->bitmask |= RRMCM_RMIF_VICTIM_MEAS_SUBSET_PRESENT;
    }
    /*eicic_subset_pattern_fix_end*/
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Furction Name  : rrm_fill_default_eicic_timer_info
 * Inputs         : - p_abs_info_to_cellm
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill default timer information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_default_eicic_timer_info
(
 rrm_eicic_timer_info_t  *p_eicic_timer_info_to_cellm
 )
{
    RRM_UT_TRACE_ENTER();
    /*SPR 14134 start*/
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "bitmask is not set, assigning default value aggressor_sel_timer = [%d]",RRM_AGGRESSOR_SEL_TIMER_DEFAULT_VALUE);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "bitmask is not set, assigning default value load_information_guard_timer = [%d]", RRM_LOAD_INFORMATION_GUARD_TIMER_DEFAULT_VALUE);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "assigning default value load_information_collation_timer  = [%d]",RRM_LOAD_INFORMATION_COLLATION_TIMER_DEFAULT_VALUE);

    /*SPR 14134 end*/
    p_eicic_timer_info_to_cellm->aggressor_sel_timer = RRM_AGGRESSOR_SEL_TIMER_DEFAULT_VALUE;
    /*SPR 14399 start*/
    p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_AGGRESSOR_SEL_TIMER_PRESENT;
    /*SPR 14399 end*/
    p_eicic_timer_info_to_cellm->load_information_guard_timer = RRM_LOAD_INFORMATION_GUARD_TIMER_DEFAULT_VALUE;
    /*SPR 14399 start*/
    p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;
    /*SPR 14399 end*/
    p_eicic_timer_info_to_cellm->load_information_collation_timer = RRM_LOAD_INFORMATION_COLLATION_TIMER_DEFAULT_VALUE;
    /*SPR 14399 start*/
    p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER;
    /*SPR 14399 end*/
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Furction Name  : rrm_fill_abs_info_default_values
 * Inputs         : - p_abs_info_to_cellm
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill default ABS information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_abs_info_default_values
(
 rrm_abs_info_t      *p_abs_info_to_cellm
 )
{
    RRM_ASSERT ( RRM_PNULL != p_abs_info_to_cellm);
    RRM_UT_TRACE_ENTER();
    /*SPR 14134 start*/
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "abs_info bitmask is not set, assigning default value num_abs_report [%d]",RRM_NUM_ABS_REPORT_DEFAULT_VALUE );
    /*SPR 14134 end*/
    p_abs_info_to_cellm->num_abs_report = RRM_NUM_ABS_REPORT_DEFAULT_VALUE;
    /*SPR 14134 start*/
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "abs_info bitmask is not set, assigning default value abs_usage_low_threshold [%d]",
            RRM_ABS_USAGE_LOW_THRESHOLD_DEFAULT_VALUE );
    /*SPR 14134 end*/
    p_abs_info_to_cellm->abs_usage_low_threshold = RRM_ABS_USAGE_LOW_THRESHOLD_DEFAULT_VALUE;
    /*SPR 14134 start*/
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "abs_info bitmask is not set, assigning default value abs_usage_high_threshold [%d]",
            RRM_ABS_USAGE_HIGH_THRESHOLD_DEFAULT_VALUE );
    /*SPR 14134 end*/
    p_abs_info_to_cellm->abs_usage_high_threshold = RRM_ABS_USAGE_HIGH_THRESHOLD_DEFAULT_VALUE;
    /*SPR 14399 start*/
    p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_NUM_ABS_REPORT_PRESENT;
    p_abs_info_to_cellm->bitmask |=RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT;
    p_abs_info_to_cellm->bitmask |=RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT;
    /*SPR 14399 end*/

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_fill_abs_info
 * Inputs         : - p_abs_info_to_cellm
 *                  - p_abs_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill ABS information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_abs_info
(
 rrm_abs_info_t      *p_abs_info_to_cellm,
 rrm_oam_abs_info_t  *p_abs_info_from_oam
 )
{
    RRM_ASSERT ( RRM_PNULL != p_abs_info_to_cellm);
    RRM_ASSERT ( RRM_PNULL != p_abs_info_from_oam);
    RRM_UT_TRACE_ENTER();
    p_abs_info_to_cellm->bitmask = 0x00;
    /** Filling Num ABS report value configured from OAM to cellm
      default value is 12 */
    if (RRM_OAM_NUM_ABS_REPORT_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->num_abs_report = 
            p_abs_info_from_oam->num_abs_report;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_NUM_ABS_REPORT_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_g_rrm_mif_facility_name, RRM_DETAILED,
                "Num ABS report not present filling default value");
        p_abs_info_to_cellm->num_abs_report = RRM_NUM_ABS_REPORT_DEFAULT_VALUE;
    }
    /** Filling ABS usage low threshold value configured from OAM to cellm
      default value is 50 */
    if (RRM_OAM_ABS_USAGE_LOW_THRESHOLD_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->abs_usage_low_threshold =
            p_abs_info_from_oam->abs_usage_low_threshold;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_g_rrm_mif_facility_name, RRM_DETAILED,
                "ABS useage low threshold not present filling default value");
        p_abs_info_to_cellm->abs_usage_low_threshold = RRM_ABS_USAGE_LOW_THRESHOLD_DEFAULT_VALUE;
    }
    /** Filling ABS usage high threshold value configured from OAM to cellm
      default value is 90 */
    if (RRM_OAM_ABS_USAGE_HIGH_THRESHOLD_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->abs_usage_high_threshold = 
            p_abs_info_from_oam->abs_usage_high_threshold;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_g_rrm_mif_facility_name, RRM_DETAILED,
                "ABS usage high threshold not present filling default value");
        p_abs_info_to_cellm->abs_usage_high_threshold = RRM_ABS_USAGE_HIGH_THRESHOLD_DEFAULT_VALUE;
    }
    /** Filling ABS pattern configured from OAM to cellm */
    /*eicic ut fix 23Sept2014 start*/
    if (RRM_OAM_ABS_PATTERN_INFO_PRESENT & p_abs_info_from_oam->bitmask)
    {
        rrm_fill_abs_pattern_info(&p_abs_info_to_cellm->abs_pattern,
                &p_abs_info_from_oam->abs_pattern);
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
    }
    /*eicic ut fix 23Sept2014 end*/
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_fill_eicic_timer_info 
 * Inputs         : - p_eicic_timer_info_to_cellm
 *                  - p_eicic_timer_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill eICIC timer info configured OAM to 
 *                  CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_eicic_timer_info
(
 rrm_eicic_timer_info_t      *p_eicic_timer_info_to_cellm,
 rrm_oam_eicic_timer_info_t  *p_eicic_timer_info_from_oam
 )
{
    RRM_ASSERT (RRM_PNULL != p_eicic_timer_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_eicic_timer_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_eicic_timer_info_to_cellm->bitmask = 0x00;
    /** Filling mac_eicic_meas_report_periodicity configured from OAM to cellm */
    if(RRM_OAM_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->mac_eicic_meas_report_periodicity = 
            p_eicic_timer_info_from_oam->mac_eicic_meas_report_periodicity;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT;
    }
    /** Filling aggressor sel timer configured from OAM to cellm
      default value is 60 */
    if(RRM_OAM_AGGRESSOR_SEL_TIMER_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->aggressor_sel_timer =
            p_eicic_timer_info_from_oam->aggressor_sel_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_AGGRESSOR_SEL_TIMER_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_g_rrm_mif_facility_name, RRM_DETAILED,
                "Aggressor sel timer is not present filling default value");
        p_eicic_timer_info_to_cellm->aggressor_sel_timer = RRM_AGGRESSOR_SEL_TIMER_DEFAULT_VALUE;
    }
    /** Filling load information guard timer configured from OAM to cellm
      default value is 10 */
    if(RRM_OAM_LOAD_INFORMATION_GUAURD_TIMER_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->load_information_guard_timer = 
            p_eicic_timer_info_from_oam->load_information_guard_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_g_rrm_mif_facility_name, RRM_DETAILED,
                "load info guard timer value not present filling default value");
        p_eicic_timer_info_to_cellm->load_information_guard_timer = RRM_LOAD_INFORMATION_GUARD_TIMER_DEFAULT_VALUE;
    }

    /** Filling load_information_collation_timer configured from OAM to cellm
      default value is 10 */
    if(RRM_OAM_LOAD_INFORMATION_COLLATION_TIMER & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->load_information_collation_timer = 
            p_eicic_timer_info_from_oam->load_information_collation_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off,p_g_rrm_mif_facility_name,RRM_DETAILED,
                "load information collation timer not present filling default value");
        p_eicic_timer_info_to_cellm->load_information_collation_timer = RRM_LOAD_INFORMATION_COLLATION_TIMER_DEFAULT_VALUE;
    }

    RRM_UT_TRACE_EXIT();
}
/*eicic ut fix 23Sept2014 start*/
/****************************************************************************
 * Function Name  : rrm_fill_abs_info_for_cell_reconfig
 * Inputs         : - p_abs_info_to_cellm
 *                  - p_abs_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill ABS information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_abs_info_for_cell_reconfig
(
 rrm_abs_info_t      *p_abs_info_to_cellm,
 rrm_oam_abs_info_t  *p_abs_info_from_oam
 )
{
    RRM_ASSERT ( RRM_PNULL != p_abs_info_to_cellm);
    RRM_ASSERT ( RRM_PNULL != p_abs_info_from_oam);
    RRM_UT_TRACE_ENTER();
    p_abs_info_to_cellm->bitmask = 0x00;
    /** Filling Num ABS report value configured from OAM to cellm
      default value is 12 */
    if (RRM_OAM_NUM_ABS_REPORT_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->num_abs_report = 
            p_abs_info_from_oam->num_abs_report;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_NUM_ABS_REPORT_PRESENT;
    }
    /** Filling ABS usage low threshold value configured from OAM to cellm
      default value is 50 */
    if (RRM_OAM_ABS_USAGE_LOW_THRESHOLD_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->abs_usage_low_threshold =
            p_abs_info_from_oam->abs_usage_low_threshold;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_USAGE_LOW_THRESHOLD_PRESENT;
    }
    if (RRM_OAM_ABS_USAGE_HIGH_THRESHOLD_PRESENT & p_abs_info_from_oam->bitmask)
    {
        p_abs_info_to_cellm->abs_usage_high_threshold = 
            p_abs_info_from_oam->abs_usage_high_threshold;
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_USAGE_HIGH_THRESHOLD_PRESENT;
    }
    /** Filling ABS pattern configured from OAM to cellm */
    /*eicic ut fix 23Sept2014 start*/
    if (RRM_OAM_ABS_PATTERN_INFO_PRESENT & p_abs_info_from_oam->bitmask)
    {
        rrm_fill_abs_pattern_info(&p_abs_info_to_cellm->abs_pattern,
                &p_abs_info_from_oam->abs_pattern);
        p_abs_info_to_cellm->bitmask |= RRMCM_RMIF_ABS_PATTERN_INFO_PRESENT;
    }
    /*eicic ut fix 23Sept2014 end*/
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : rrm_fill_eicic_timer_info_for_cell_reconfig
 * Inputs         : - p_abs_info_to_cellm
 *                  - p_abs_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill eicic timer information in eICIC info from OAM
 *                  to CELLM
 ****************************************************************************/
rrm_void_t
    rrm_fill_eicic_timer_info_for_cell_reconfig
(
 rrm_eicic_timer_info_t      *p_eicic_timer_info_to_cellm,
 rrm_oam_eicic_timer_info_t  *p_eicic_timer_info_from_oam
 )
{
    RRM_ASSERT (RRM_PNULL != p_eicic_timer_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_eicic_timer_info_from_oam);

    RRM_UT_TRACE_ENTER();
    p_eicic_timer_info_to_cellm->bitmask = 0x00;
    /** Filling mac_eicic_meas_report_periodicity configured from OAM to cellm */
    if(RRM_OAM_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->mac_eicic_meas_report_periodicity = 
            p_eicic_timer_info_from_oam->mac_eicic_meas_report_periodicity;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_EICIC_MEAS_REPORT_PERIODICITY_PRESENT;
    }
    /** Filling aggressor sel timer configured from OAM to cellm
      default value is 60 */
    if(RRM_OAM_AGGRESSOR_SEL_TIMER_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->aggressor_sel_timer =
            p_eicic_timer_info_from_oam->aggressor_sel_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_AGGRESSOR_SEL_TIMER_PRESENT;
    }
    if(RRM_OAM_LOAD_INFORMATION_GUAURD_TIMER_PRESENT & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->load_information_guard_timer = 
            p_eicic_timer_info_from_oam->load_information_guard_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_GUAURD_TIMER_PRESENT;
    }
    /** Filling load_information_collation_timer configured from OAM to cellm
      default value is 10 */
    if(RRM_OAM_LOAD_INFORMATION_COLLATION_TIMER & p_eicic_timer_info_from_oam->bitmask)
    {
        p_eicic_timer_info_to_cellm->load_information_collation_timer = 
            p_eicic_timer_info_from_oam->load_information_collation_timer;
        p_eicic_timer_info_to_cellm->bitmask |= RRMCM_RMIF_LOAD_INFORMATION_COLLATION_TIMER;
    }
    RRM_UT_TRACE_EXIT();
}
/*eicic ut fix 23Sept2014 end*/
/****************************************************************************
 * Function Name  : rrm_fill_eicic_info_reconfig_params
 * Inputs         : - eicic_info_config_to_cellm
 *                  - eicic_info_config_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the eICIC params from for cell config
 *                  from OAM.
 ****************************************************************************/
rrm_void_t
    rrm_fill_eicic_info_reconfig_params 
(
 rrm_eicic_info_t        *p_eicic_info_reconfig_to_cellm,
 rrm_oam_eicic_info_t    *p_eicic_info_reconfig_from_oam
 )
{

    RRM_ASSERT ( RRM_PNULL != p_eicic_info_reconfig_to_cellm );
    RRM_ASSERT ( RRM_PNULL != p_eicic_info_reconfig_from_oam );
    /* BCOM Compiltaion Fix */
    RRM_UT_TRACE_ENTER();

    /** Filling is_eicic_provisioned parameter value which configured
      from OAM. Default value is 0 stands for deactivated eICIC */
    p_eicic_info_reconfig_to_cellm->bitmask = 0x00;
    if (RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        p_eicic_info_reconfig_to_cellm->eicic_provisioned_type = p_eicic_info_reconfig_from_oam->eicic_provisioned_type;
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT;
    }
    /*SPR 14165 start*/
    //code deleted
    /*SPR 14165 end*/
    /** Filling ABS information */
    /*SPR 14456 start*/
    if(RRM_OAM_EICIC_ELIGIBLE_UE_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        p_eicic_info_reconfig_to_cellm->eligible_ue = p_eicic_info_reconfig_from_oam->eligible_ue;
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_EICIC_ELIGIBLE_UE_PRESENT;
    }
    /*SPR 14456 end*/
    if(RRM_OAM_ABS_INFO_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        rrm_fill_abs_info_for_cell_reconfig(&p_eicic_info_reconfig_to_cellm->abs_info,
                &p_eicic_info_reconfig_from_oam->abs_info);
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
    }
    if(RRM_OAM_EICIC_TIMER_INFO_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        rrm_fill_eicic_timer_info_for_cell_reconfig(&p_eicic_info_reconfig_to_cellm->eicic_timer_info,
                &p_eicic_info_reconfig_from_oam->eicic_timer_info);
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT;
    }
    if(RRM_OAM_DL_SINR_THRESHOLD_LOW_MARK_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        p_eicic_info_reconfig_to_cellm->dl_sinr_threshold_low_mark =
            p_eicic_info_reconfig_from_oam->dl_sinr_threshold_low_mark;
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
    }
    if(RRM_OAM_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT & p_eicic_info_reconfig_from_oam->bitmask)
    {
        p_eicic_info_reconfig_to_cellm->dl_sinr_threshold_high_mark =
            p_eicic_info_reconfig_from_oam->dl_sinr_threshold_high_mark;
        p_eicic_info_reconfig_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
    }
    RRM_UT_TRACE_EXIT();
}
/** eICIC feature changes end */
/****************************************************************************
 * Function Name  : fill_operator_info_for_cell_reconfig
 * Inputs         : - p_operator_cfg_params
 *                  - p_operator_info_to_cellm
 *                  - p_operator_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Operator info for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_operator_info_for_cell_reconfig(
        operator_info_t            *p_operator_info_to_cellm,
        rrm_oam_operator_info_t    *p_operator_info_from_oam,
        /*SPR 17777 +-*/
        rrm_oam_rf_params_t        *p_rf_params_from_oam,
        rrm_oam_physical_layer_params_t *p_plp_params_from_oam,
        /* SPR 18641_18843 fix start */
        rrm_oam_mac_layer_params_t      *p_mac_layer_params_from_oam,
        U8 tti_bundling_info_present)
/* SPR 20653 Fix End */
/* SPR 18641_18843 fix end */
{

    RRM_ASSERT (RRM_PNULL != p_operator_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_operator_info_from_oam);
    /* SPR fix 17928 Start */
    /* Code Deleted */
    /* SPR fix 17928 end */
    RRM_ASSERT (RRM_PNULL != p_rf_params_from_oam);
    RRM_ASSERT (RRM_PNULL != p_plp_params_from_oam);


    RRM_UT_TRACE_ENTER();

    /* Populationg Operator Info */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populationg Operator Info");

    /*Populating Cell Params */
    if (p_operator_info_from_oam->bitmask & RRM_OAM_ADD_CELL_PARAMS_PRESENT)
    {
        p_operator_info_to_cellm->cell_params.sub_carrier_spacing = 
            p_operator_info_from_oam->additional_cell_params.sub_carrier_spacing;
        p_operator_info_to_cellm->cell_params.dl_cyclic_prefix = 
            p_operator_info_from_oam->additional_cell_params.dl_cyclic_prefix;

        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT;
        /* SPR 21429 Fix End */
    }
    /* SPR 20653 Fix Start */
    /* Additional parameters for Cell Config Added STARTS*/
    if(p_rf_params_from_oam->rf_configurations.bitmask & RRM_OAM_MAX_RS_EPRE_PRESENT)
    {
        p_operator_info_to_cellm->cell_params.max_rs_epre = 
            p_rf_params_from_oam->rf_configurations.max_rs_epre;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->cell_params.bitmask |= RRMCM_MAX_RS_EPRE_PRESENT;
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT;
        /* SPR 21429 Fix End */
    }
    /* SPR 20653 Fix End */


    /* Populating Mac Config Params*/
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_MAC_CONFIG_PRESENT)
    {
        /* BUG_371 FIX START */ 
        /* SPR 7283 Fix Start */
        /* SPR 20653 Fix Start */
        populate_operator_mac_param_for_cell_reconfig(p_operator_info_to_cellm ,p_operator_info_from_oam, p_mac_layer_params_from_oam);
        /* BUG_371 FIX END */ 
        /*spr_19151_changes_start*/
        p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
            pcfichPowerOffset = p_rf_params_from_oam->rf_configurations.pcfichPowerOffset;

        p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
            phichPowerOffset = p_rf_params_from_oam->rf_configurations.phichPowerOffset;

        p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
            pdcchPowerOffset = p_rf_params_from_oam->rf_configurations.pdcchPowerOffset; 

        p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
            pbchTransmissionPower = p_rf_params_from_oam->rf_configurations.pbchTransmissionPower;

        p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
            pchTransmissionpower = p_rf_params_from_oam->rf_configurations.pchTransmissionpower;
        /* SPR 20653 Fix End */
        /*spr_19151_changes_end*/
        /* CHANGES_FRM_XML_TO_CFG END */

        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_CONFIG_PRESENT ;
        /* SPR 7283 Fix End */
    }
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

    /* Populating phich_config Params*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_PHICH_CONFIG_PRESENT)
    {
        p_operator_info_to_cellm->phich_config.phich_resource= 
            p_operator_info_from_oam->phich_config.phich_resource;

        p_operator_info_to_cellm->phich_config.phich_duration= 
            p_operator_info_from_oam->phich_config.phich_duration;

        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_PHICH_CONFIG_PRESENT;
    }


    /* Populating sib_1_info */
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB1_INFO_PRESENT)
    {
        /* BUG_371 FIX START */ 
        /* SPR 20653 Fix Start */
        populate_operator_sib1_info(p_operator_info_from_oam ,p_operator_info_to_cellm );
        /* SPR 20653 Fix End */
        /* BUG_371 FIX END */ 
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_1_INFO_PRESENT;
    }
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

    /* Populating SIB2 Info */  
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB2_INFO_PRESENT)
    {
        /* SPR 20653 Fix Start */
        populate_operator_sib2_info(p_operator_info_to_cellm,
                p_operator_info_from_oam, 
                p_rf_params_from_oam->rf_configurations.ul_bandwidth);
        /* SPR 20653 Fix End */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_2_INFO_PRESENT;
    }
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
    /* changes End by  by gur30308 */
    /* BUG_371 FIX START */ 
    if(p_operator_info_from_oam->bitmask & RRM_OAM_POWER_CONTROL_INFO_PRESENT)
    {
        /* SPR 20653 Fix Start */
        populate_operator_sib2_ul_power_ctrl_info(p_operator_info_to_cellm ,p_operator_info_from_oam);
        /* SPR 20653 Fix End */
    }
    /* BUG_371 FIX END */ 

    /* Populating SIB3*/ 
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB3_INFO_PRESENT)
    {
        /* SPR 20653 Fix Start */
        populate_operator_sib3_info(p_operator_info_to_cellm , p_operator_info_from_oam);
        /* SPR 20653 Fix End */
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_3_INFO_PRESENT;
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
        /* SPR 16442 START */
        /* Code Removed */
        /* SPR 16442 END */
    }
    /*Rel 10 CR changes-36331.553*/   
    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB4_INFO_PRESENT)
    {
        /* BUG_11575_CHANGES_START */
        /* Populating SIB4*/
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_4_INFO_PRESENT;
        p_operator_info_to_cellm->sib_4_info.csg_id_range.bitmask = 0x00;
        p_operator_info_to_cellm->sib_4_info.csg_id_range.start=
            p_operator_info_from_oam->sib_4_info.csg_id_range.start;

        if (p_operator_info_from_oam->sib_4_info.csg_id_range.bitmask&
                RRM_OAM_CELL_ID_RANGE_PRESENT)
        {
            p_operator_info_to_cellm->sib_4_info.csg_id_range.bitmask |=
                RRMCM_RMIF_CELL_ID_RANGE_PRESENT;
            p_operator_info_to_cellm->sib_4_info.csg_id_range.range=
                p_operator_info_from_oam->sib_4_info.csg_id_range.range;
        }
        /* BUG_11575_CHANGES_END */
    }
    /* SPR 20653 Fix Start */
    if (p_rf_params_from_oam->rf_configurations.bitmask & RRM_OAM_RB_SIZE_PRESENT)
    {
        p_operator_info_to_cellm->cell_params.rb_size = 
            p_rf_params_from_oam->rf_configurations.rb_size;
        /* SPR 21429 Fix Start */
        p_operator_info_to_cellm->cell_params.bitmask |= RRMCM_RB_SIZE_PRESENT;
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT;
        /* SPR 21429 Fix End */
    }
    /* SPR 20653 Fix End */

    /* Populating admission Control Info */
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/

    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDMISION_CONTROL_INFO_PRESENT)
    {
        populate_operator_admsn_control_info_for_cell_reconfig(p_operator_info_to_cellm , p_operator_info_from_oam , 
                /*SPR 17777 +-*/
                /* SPR 20653 Fix Start */ 
                p_plp_params_from_oam ,
                /* SPR 20653 Fix End */ 
                /*SPR 17777 +-*/
                p_rf_params_from_oam->rf_configurations.dl_bandwidth);
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
    }
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

    /* HO config params start*/
    if(p_operator_info_from_oam->bitmask & RRM_OAM_HO_CONFIGURATION_PRESENT)
    {
        populate_ho_config_params_info(p_operator_info_to_cellm, p_operator_info_from_oam);
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT; 
    }
    /* HO config params end */
    /* Inter RAT changes start */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_MEASUREMENT_CONFIG_PRESENT)
    {
        populate_meas_config_info(p_operator_info_to_cellm, p_operator_info_from_oam);
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MEASUREMENT_CONFIG_PRESENT;
    }
    /* Inter RAT changes end */
    /* GERAN cell configurations */


#ifndef TDD_MODE_FLAG
    if (p_operator_info_from_oam->bitmask & RRM_OAM_SPS_CRNTI_RANGE_PRESENT)
    {
        p_operator_info_to_cellm->sps_crnti_range_info.start_sps_crnti_range =
            p_operator_info_from_oam->rrm_sps_crnti_range.start_sps_crnti_range;

        p_operator_info_to_cellm->sps_crnti_range_info.end_sps_crnti_range =
            p_operator_info_from_oam->rrm_sps_crnti_range.end_sps_crnti_range;

        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT;
    }
#endif
    /* DYNAMIC ICIC START */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT)
    {
        /* SPR 20653 Fix Start */ 
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT; 
        populate_dynamic_icic_info(&p_operator_info_to_cellm->dynamic_icic_info , 
                &p_operator_info_from_oam->dynamic_icic_info, 
                (p_plp_params_from_oam->physical_layer_param_ul_power_control.alpha)); 

        if(p_operator_info_from_oam->dynamic_icic_info.report_config_info.bitmask & RRM_OAM_REPORT_CONFIG_INFO_PRESENT)
        {
            populate_dynamic_icic_periodicity_info(p_operator_info_to_cellm, 
                    &p_operator_info_from_oam->dynamic_icic_info.report_config_info );
        }
        /* SPR 20653 Fix End */ 
    }
    /* DYNAMIC ICIC END */
    /* SPS related changes end */
    /* UE positioning start */
    if (p_operator_info_from_oam->bitmask & RRM_OAM_EUTRAN_ACCESS_POINT_POS_PRESENT)
    {
        populate_eutran_access_point_pos_params(&p_operator_info_from_oam->rrm_eutran_access_point_pos, 
                &p_operator_info_to_cellm->eutran_access_point_pos);

        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_EUTRAN_ACCESS_POINT_POS_PRESENT;
    }
    /* UE positioning end */
    /*TM mode 7-8 start*/
    if(p_operator_info_from_oam->mimo_mode_params.bitmask  
            & RRM_OAM_TRANSMISSION_MODE_TABLE_PRESENT )
    {
        populate_tm_mode_table(&p_operator_info_from_oam->mimo_mode_params.tm_mode_table,
                &p_operator_info_to_cellm->rrm_tm_mode_table);
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT;
    }

    if( RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT & p_operator_info_from_oam->bitmask )
    {
        rrm_fill_dynamic_ue_scheduling( &(p_operator_info_from_oam->rrm_ue_scheduling_info),
                &(p_operator_info_to_cellm->rrm_ue_scheduling_info ));
        p_operator_info_to_cellm->bitmask |= RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT; 
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "Dynamic UE scheduling info is not coming from OAM in cell reconfig");
    }
    /*TM mode 7-8 end*/
    /*spr 7984 start*/
    if(RRM_OAM_ENABLE_CQI_MASK_R9_PRESENT & p_operator_info_from_oam->bitmask)
    {
        switch(p_operator_info_from_oam->rrm_enable_cqi_mask_r9)
        {
            case RRM_ZERO:
                p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
                break;
            case RRM_ONE:
                p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_TRUE;
                break;
            default:
                p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "Invalid value[%d] received for rrm_enable_cqi_mask_r9, setting it to false",
                        p_operator_info_from_oam->rrm_enable_cqi_mask_r9);
        }
    }
    else
    {
        p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "rrm_enable_cqi_mask_r9 is not coming from OAM in cell reconfig"
                " setting it to false");
    }
    /*spr 7984 end*/
    /* Carrier_Aggregation_Start */
    if (RRM_OAM_CA_CONFIG_INFO_PRESENT & p_operator_info_from_oam->bitmask)
    {
        rrm_fill_ca_reconfig_params (&(p_operator_info_to_cellm->ca_config),
                &(p_operator_info_from_oam->ca_config));
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;    
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "CA info is not present in cell reconfig req from OAM");
    }
    /* Carrier_Aggregation_End */
    if (p_operator_info_from_oam->bitmask & RRM_OAM_SUBBAND_CQI_PARAM_PRESENT)
    {
        p_operator_info_to_cellm->k = p_operator_info_from_oam->k;
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PRESENT;
    }
    if (p_operator_info_from_oam->bitmask & RRM_OAM_SUBBAND_CQI_PERIODICTY_FACTOR_R10_PRESENT)
    {
        switch(p_operator_info_from_oam->periodicity_factor)
        {
            case RRM_OAM_PERIODCITY_FACTOR_N2: 
                p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N2;
                break;
            case RRM_OAM_PERIODCITY_FACTOR_N4:
                p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N4;
                break;
            default:
                p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N2;
                break;

        }
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PERIODCITY_FACTOR_PRESENT;
    }
    /** eICIC feature changes start */
    if (RRM_OAM_EICIC_INFO_PRESENT & p_operator_info_from_oam->bitmask)
    {
        rrm_fill_eicic_info_reconfig_params(&(p_operator_info_to_cellm->eicic_info),
                &(p_operator_info_from_oam->eicic_info));
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "eICIC is not present in cell reconfig req from OAM");
    }
    /** eICIC feature changes end */
#ifdef LTE_EMBMS_SUPPORTED
/* SPR 22248 MBMS Changes Start */ 
mbms_notif_rep_coeff_et p_notif_rep_coeff = MBMS_NOTIF_REP_COEFF_N4;
/* SPR 18334 : START */
    rrm_fill_sib_13_info_config_params(&(p_operator_info_to_cellm->sib_13_info),
                                       p_notif_rep_coeff);
/* SPR 22248 MBMS Changes Stop */
/* SPR 18334 : END */
  if (RRM_OAM_EMBMS_POWER_INFO_PRESENT & p_operator_info_from_oam->bitmask )
  {
      RRM_MEMCPY(&(p_operator_info_to_cellm->mbms_power_info),
                 &(p_operator_info_from_oam->mbms_power_info),
                 sizeof(rrm_oam_mbms_power_info_t));
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MBMS_POWER_INFO_PRESENT;

      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
              "EMBMS Power Info is present "
              "cell_pwer_offset[%d], transmission_power[%d]",
              p_operator_info_to_cellm->mbms_power_info.cell_pwer_offset,
              p_operator_info_to_cellm->mbms_power_info.transmission_power);

  }  
  else
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                " EMBMS Power Info is not present in cell reconfig from OAM");
  }

#endif
    /* SPR 18641_18843 fix start */
    if(tti_bundling_info_present)
    {
        if(RRM_OAM_TTI_BUNDLING_INFO_PRESENT & p_operator_info_from_oam->bitmask) 
        {
            p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_actv_tti = 
                p_operator_info_from_oam->tti_bundling_info.ul_sinr_threshold_to_actv_tti; 

            p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_deactv_tti = 
                p_operator_info_from_oam->tti_bundling_info.ul_sinr_threshold_to_deactv_tti; 

            p_operator_info_to_cellm->tti_bundling_info.rrm_ue_used_rb_threshold = 
                p_operator_info_from_oam->tti_bundling_info.rrm_ue_used_rb_threshold;

            p_operator_info_to_cellm->bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT;

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "ul_sinr_threshold_to_actv_tti [%d]",
                    p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_actv_tti);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "ul_sinr_threshold_to_deactv_tti[%d]",
                    p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_deactv_tti);
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "rrm_ue_used_rb_threshold[%d]",
                    p_operator_info_to_cellm->tti_bundling_info.rrm_ue_used_rb_threshold);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "TTI bundling is enabled but bitmask RRM_OAM_TTI_BUNDLING_INFO_PRESENT is not set, Invalid Params received");
        }    
    }    
    else
    {
        p_operator_info_to_cellm->bitmask &= ~(RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT);
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,"TTI bundling is disabled");
    }    
    /* SPR 18641_18843 fix end */

}

/****************************************************************************
 * Function Name  : fill_ho_params 
 * Inputs         : - p_operator_cfg_params
 *                  - p_operator_info_to_cellm
 *                  - p_ho_params_info_from_oam
 *                  - p_cmm_params_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Operator info for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_ho_params(
        ho_params_t                *p_ho_params_info_to_cellm,
        rrm_oam_ho_config_params_t *p_ho_params_info_from_oam,
        rrm_oam_connected_mode_mobility_params_t *p_cmm_params_from_oam
        )
    /* SPR 20653 Fix End */
{ 
    /* SPR 17784 Start */
    /* SPR 20653 Fix Start */ 
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_BLIND_HO_TIMER_PRESENT)
    {
        p_ho_params_info_to_cellm->ho_blind_timer_duration = 
            p_ho_params_info_from_oam->blind_ho_timer;
    }
    else
    {
        p_ho_params_info_to_cellm->ho_blind_timer_duration = RRM_DEFINED_DEFAULT_VALUE_FOR_BLIND_HO_TIMER_DURATION;
    }

    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_BLIND_HO_TIMER_PRESENT)
    {
        p_ho_params_info_to_cellm->cgi_timer_duration = 
            p_ho_params_info_from_oam->blind_ho_timer;
    }
    else
    {
        p_ho_params_info_to_cellm->cgi_timer_duration = RRM_DEFINED_DEFAULT_VALUE_FOR_CGI_TIMER_DURATION;
    }
    /* SPR 21556 Fix Start */
    p_ho_params_info_to_cellm->a3_a4_event_trigger_quantity = 
	    (U8)p_cmm_params_from_oam->common_params_for_eutra.trigger_quantity; 
    /* SPR 21556 Fix End */
    /* SPR 20653 Fix End */ 
    /* SPR 17784 End */
    /* SPR 20653 Fix Start */
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_S1_DIRECT_FWD_PATH_AVAILABLE_PRESENT)
    {
        p_ho_params_info_to_cellm->s1_direct_fwd_path_available = 
            p_ho_params_info_from_oam->s1_direct_fwd_path_available;
    }
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_UTRA_RNC_DIRECT_FWD_PATH_AVAILABLE_PRESENT)
    {
        p_ho_params_info_to_cellm->utra_rnc_direct_fwd_path_available = 
            p_ho_params_info_from_oam->utra_rnc_direct_fwd_path_available;
    }
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_B1_EVENT_UTRAN_TRIGGER_QUANTITY_PRESENT)
    {
        p_ho_params_info_to_cellm->b1_event_trigger_quantity = 
            p_ho_params_info_from_oam->b1_event_utran_trigger_quantity;
    }
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_B2_EVENT_UTRAN_TRIGGER_QUANTITY_PRESENT)
    {
        p_ho_params_info_to_cellm->b2_event_utran_trigger_quantity = 
            p_ho_params_info_from_oam->b2_event_utran_trigger_quantity;
    }
    /* SPR 21365 Fix Start */
    /* Lines Deleted */
    /* SPR 21365 Fix Stop */
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_CSFB_BLIND_TIMER_DURATION_PRESENT)
    {
        p_ho_params_info_to_cellm->csfb_blind_timer_duration = 
            p_ho_params_info_from_oam->csfb_blind_timer_duration;
    }
    if(p_ho_params_info_from_oam->bitmask & RRM_OAM_IRAT_OFFSET_PRESENT)
    {
        p_ho_params_info_to_cellm->irat_offset = 
            p_ho_params_info_from_oam->irat_offset;
    }
    if(p_cmm_params_from_oam->common_params_for_eutra.bitmask & RRM_OAM_DELAYED_A3_ENABLED_PRESENT)
    {
        p_ho_params_info_to_cellm->delayed_a3_enabled = 
            p_cmm_params_from_oam->common_params_for_eutra.delayed_a3_enabled;
    }			   
    if(p_cmm_params_from_oam->common_params_for_eutra.bitmask & RRM_OAM_A4_MEAS_CONFIG_ENABLED_PRESENT)
    {
        p_ho_params_info_to_cellm->a4_meas_cfg_enabled = 
            p_cmm_params_from_oam->common_params_for_eutra.a4_meas_cfg_enabled;
    }
    /* SPR 20653 Fix End */
    if(RRMC_RSRP == p_cmm_params_from_oam->common_params_for_eutra.trigger_quantity)
    {
        p_ho_params_info_to_cellm->b2_event_eutran_thresh_rsrx = 
            /* Bug 13021 fix start */
            p_cmm_params_from_oam->irat.b2_threshold_1rsrp;
        /* Bug 13021 fix end */
    }
    else if(RRMC_RSRQ == p_cmm_params_from_oam->common_params_for_eutra.trigger_quantity)
    {
        p_ho_params_info_to_cellm->b2_event_eutran_thresh_rsrx =
            /*SPR 21755 Fix Start*/
            /* Bug 13021 fix start */
            p_cmm_params_from_oam->irat.b2_threshold_1rsrq;
        /* Bug 13021 fix end */
            /*SPR 21755 Fix Stop*/
    }

    /* SPR 20653 Fix Start */ 
    /* Code Removed */ 
    /* SPR 20653 Fix End */ 

    if(p_ho_params_info_from_oam->target_cell_selection_params.bitmask &
            RRM_OAM_UE_MEAS_BASED_HO_ENABLE_PRESENT)
    {
        switch(p_ho_params_info_from_oam->target_cell_selection_params.ue_measurement_based_ho_enable)
        {
            case RRM_ZERO:
                p_ho_params_info_to_cellm->rrm_enable_ue_measurement =
                    RRM_UE_MEASURMENT_DISABLE;
                break;

            case RRM_ONE:
                p_ho_params_info_to_cellm->rrm_enable_ue_measurement =
                    RRM_UE_MEASURMENT_ENABLE;
                break;

            default:
                RRM_TRACE (g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "Incorrect value entered for enable_ue_measurement  %d",
                        p_ho_params_info_from_oam->target_cell_selection_params.ue_measurement_based_ho_enable);
                p_ho_params_info_to_cellm->rrm_enable_ue_measurement = RRM_UE_MEASURMENT_DISABLE;
        }
    }
    /*SPR 21365 fix start*/
    /*Lines Deleted*/
    /*SPR 21365 fix stop*/

    /* SPR 20653 Fix Start */
    p_ho_params_info_to_cellm->s_measure = p_cmm_params_from_oam->common_params_for_eutra.s_measure;
    /* SPR 20653 Fix End */
}

/****************************************************************************
 * Function Name  : fill_block_cell_params_for_ho
 * Inputs         : - p_operator_cfg_params
 *                  - p_block_cell_params_ho
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Block Cell Params for HO 
 *                  for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_block_cell_params_for_ho(
        rrm_block_cell_params_ho_t  *p_block_cell_params_ho,
        rrm_oam_block_cell_params_ho_t *p_block_cell_params_from_oam)
    /* SPR 20653 Fix End */
{
    /* SPR 20653 Fix Start */
    /* CID 112402 Start */
    p_block_cell_params_ho->trigger_quantity_for_block = 
        (rrm_trigger_quantity_et)p_block_cell_params_from_oam->trigger_quantity_for_block;
    /* CID 112402 End */
    p_block_cell_params_ho->a4_threshold_rsrp_for_block = 
        p_block_cell_params_from_oam->a4_threshold_rsrp_for_block;
    p_block_cell_params_ho->a4_threshold_rsrq_for_block = 
        p_block_cell_params_from_oam->a4_threshold_rsrq_for_block;
    /* SPR 20653 Fix End */
}

/* Uplink power starts */
/****************************************************************************
 * Function Name  : fill_olpc_params
 * Inputs         : p_operator_cfg_params
 * Outputs        : p_rrm_olpc_config_params 
 * Returns        : void
 * Description    : This function fill the olpc params
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_olpc_params(
        rrm_olpc_config_params_t     *p_rrm_olpc_config_params,
        rrm_oam_olpc_config_params_t *p_rrm_olpc_params_from_oam
        )
    /* SPR 20653 Fix End */
{
    /* SPR 20653 Fix Start */
    U8    count = RRM_ZERO;
    for( count = RRM_ZERO; count < RRM_OLPC_CATEGORY_TABLE_SIZE; count++)
    {
        if ((RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[OLPC_TABLE_CATEGORY_1 - RRM_ONE] = 
            p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[OLPC_TABLE_CATEGORY_3 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[OLPC_TABLE_CATEGORY_2 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[OLPC_TABLE_CATEGORY_4 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_supported_table[count].rrm_olpc_tupple.action;
        }
    }
    p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_center_ue =
        p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_center_ue;

    p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_edge_ue =
        p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_pusch_snr_threshold_for_cell_edge_ue;

    p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_start =
        p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_start;

    p_rrm_olpc_config_params->rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_end =
        p_rrm_olpc_params_from_oam->rrm_olpc_pusch_config_params.olpc_p0_ue_pusch_range_end;

    for( count = RRM_ZERO; count < RRM_OLPC_CATEGORY_TABLE_SIZE; count++)
    {
        if ((RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[OLPC_TABLE_CATEGORY_1 - RRM_ONE] = 
            p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[OLPC_TABLE_CATEGORY_3 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_FALSE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[OLPC_TABLE_CATEGORY_2 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.action;
        }

        if ((RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_pathloss_high) &&
            (RRM_TRUE == p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.is_sinr_high))
        {
            p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[OLPC_TABLE_CATEGORY_4 - RRM_ONE] = 
                p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_supported_table[count].rrm_olpc_tupple.action;
        }
    }
    p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_pucch_snr_threshold =
        p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_pucch_snr_threshold;

    p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_start =
        p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_start;

    p_rrm_olpc_config_params->rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_end =
        p_rrm_olpc_params_from_oam->rrm_olpc_pucch_config_params.olpc_p0_ue_pucch_range_end;

    p_rrm_olpc_config_params->ul_pathloss_threshold = 
        p_rrm_olpc_params_from_oam->ul_pathloss_threshold;

    p_rrm_olpc_config_params->ue_handover_count_threshold = 
        p_rrm_olpc_params_from_oam->ue_handover_count_threshold;

    p_rrm_olpc_config_params->min_ue_power = 
        p_rrm_olpc_params_from_oam->min_ue_power;
    /* SPR 20653 Fix End */
}
/* Uplink power end */

/*DYNAMIC ICIC START*/
/****************************************************************************
 * Function Name  : fill_pdsch_params
 * Inputs         : p_operator_cfg_params
 * Outputs        : p_rrm_olpc_config_params 
 * Returns        : void
 * Description    : This function fill the olpc params
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_pdsch_config_params(
        rrm_oam_dynamic_icic_info_t  *p_rrm_oam_dynamic_icic_info,
        rrm_pdsch_config_params_t    *p_rrm_pdsch_cfg_params)
    /* SPR 20653 Fix End */
{
    /* SPR 20653 Fix Start */ 
    p_rrm_pdsch_cfg_params->pdsch_dedicated_config.pa_for_ce_ue = 
        p_rrm_oam_dynamic_icic_info->pa_for_ce_ue;
    if(p_rrm_oam_dynamic_icic_info->bitmask & RRM_OAM_PA_RAMPING_STEP_PRESENT)
    {
        p_rrm_pdsch_cfg_params->pdsch_dedicated_config.p_a_ramping_step = 
            p_rrm_oam_dynamic_icic_info->p_a_ramping_step;
    }

    if(p_rrm_oam_dynamic_icic_info->bitmask & RRM_OAM_REF_SIG_POWER_RAMPING_STEP_PRESENT)
    {
        p_rrm_pdsch_cfg_params->pdsch_common_config.ref_sig_powr_ramping_step =
            p_rrm_oam_dynamic_icic_info->ref_sig_powr_ramping_step;                                
    }
    /* SPR 20653 Fix End */  
}
/*DYNAMIC ICIC END*/ 
/****************************************************************************
 * Function Name  : fill_cell_config_request_for_cellm
 * Inputs         : - OutCellConfigReqToCellM_p
 *                  - InCellConfigReqFromOam_p
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill Cell Config req for CellM Module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_cell_config_request_for_cellm(
        rrmcm_rmif_cell_config_req_t   *OutCellConfigReqToCellM_p,
        rrm_oam_cell_config_req_t      *InCellConfigReqFromOam_p)
    /* SPR 20653 Fix End */
{
    RRM_ASSERT (RRM_PNULL !=InCellConfigReqFromOam_p);
    RRM_ASSERT (RRM_PNULL !=OutCellConfigReqToCellM_p);

    /* CHANGES_FRM_XML_TO_CFG START */
    U8 max_harq_retrans_per_qci_list[9] = {RRM_ZERO};
    U8 qci_count = RRM_ZERO;
    U8 min_val_for_harq_retrans = RRM_ZERO;
    /* CHANGES_FRM_XML_TO_CFG END */

    /* SPR 18641_18843 fix start */
    U8 tti_bundling_info_present = RRM_FALSE;
    /* SPR 18641_18843 fix end */

    RRM_UT_TRACE_ENTER();

    /* Filling  RAN Information*/
    /* SPR 20653 Fix Start */
    fill_ran_info_for_cell_config(
            &OutCellConfigReqToCellM_p->ran_info, 
            &OutCellConfigReqToCellM_p->operator_info,
            &InCellConfigReqFromOam_p->ran_info,
            &InCellConfigReqFromOam_p->global_cell_info.cell_access_restriction_params,
            &InCellConfigReqFromOam_p->global_cell_info.eutran_global_cell_id,
            /*SPR 17777 +-*/
            &InCellConfigReqFromOam_p->operator_info);
    /* SPR 20653 Fix End */

    /* Filling  EPC Information*/
    /* SPR 20653 Fix Start */
    fill_epc_info_for_cell_config(
            &OutCellConfigReqToCellM_p->epc_info, 
            &InCellConfigReqFromOam_p->epc_info,
            /* SPR 18641_18843 fix start */
            &InCellConfigReqFromOam_p->ran_info,
            &tti_bundling_info_present); 
    /* SPR 18641_18843 fix end */
    /* SPR 20653 Fix End */

    /* Filling  Operator Information*/
    /* SPR 20653 Fix Start */
    fill_operator_info_for_cell_config(
            &OutCellConfigReqToCellM_p->operator_info,
            &InCellConfigReqFromOam_p->operator_info,
            /*SPR 17777 +-*/
            &InCellConfigReqFromOam_p->ran_info.rf_params,
            &InCellConfigReqFromOam_p->ran_info.physical_layer_params,
            /* SPR 18641_18843 fix start */
            &InCellConfigReqFromOam_p->ran_info.mac_layer_params,
            tti_bundling_info_present);
    /* SPR 18641_18843 fix end */
    /* SPR 20653 Fix End */

    /* SPR 20653 Fix Start */
    /* CHANGES_FRM_XML_TO_CFG START */
    for(qci_count = RRM_ZERO ; qci_count < InCellConfigReqFromOam_p->epc_info.epc_params.num_valid_qos_profiles ; qci_count++)
    {
      /*  if(InCellConfigReqFromOam_p->epc_info.epc_params.qos_config_params[qci_count].bitmask &
                RRM_OAM_ARQ_TX_RETRANS_PRESENT)*/
        {
            max_harq_retrans_per_qci_list[qci_count] = 
                InCellConfigReqFromOam_p->epc_info.epc_params.qos_config_params[qci_count].max_harq_retrans;
        }
    }
    /* SPR 20653 Fix End */

    min_val_for_harq_retrans = max_harq_retrans_per_qci_list[RRM_ZERO];
    for(qci_count = RRM_ONE ; qci_count < InCellConfigReqFromOam_p->epc_info.epc_params.num_valid_qos_profiles ; qci_count++)
    {
        if(max_harq_retrans_per_qci_list[qci_count] < min_val_for_harq_retrans)
        {
            min_val_for_harq_retrans = max_harq_retrans_per_qci_list[qci_count];
        }
    }
    OutCellConfigReqToCellM_p->operator_info.rrm_mac_config.max_harq_retrans = min_val_for_harq_retrans;
    /* CHANGES_FRM_XML_TO_CFG END */

    /* Filling  Access Mgnt Information*/
    /* Start: CSR 00082391 */
    if (RRM_OAM_ACCESS_MGMT_PARAMS_PRESENT & InCellConfigReqFromOam_p->bitmask)
        /* End: CSR 00082391 */
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT: %u", InCellConfigReqFromOam_p->bitmask);
        OutCellConfigReqToCellM_p->bitmask |= RRMCM_RMIF_ACCESS_MGMT_PARAMS_PRESENT;
        fill_access_mangt_info(&OutCellConfigReqToCellM_p->access_mgmt_params, 
                &InCellConfigReqFromOam_p->access_mgmt_params);
    }

    /* Filling immediate start Needed */
    OutCellConfigReqToCellM_p->immediate_start_needed = 
        InCellConfigReqFromOam_p->immediate_start_needed;
    /* Filling ho parameters */
    /* SPR 20653 Fix Start */
    fill_ho_params(
            &OutCellConfigReqToCellM_p->ho_parameters,
            &InCellConfigReqFromOam_p->operator_info.ho_configuration,
            &InCellConfigReqFromOam_p->ran_info.connected_mode_mobility_params);
    /* SPR 20653 Fix End */

    /* SPR 20653 Fix Start */
    /* Filling Block Cell Params for HO */
    fill_block_cell_params_for_ho(
            &OutCellConfigReqToCellM_p->block_cell_params_ho,
            &InCellConfigReqFromOam_p->operator_info.ho_configuration.block_cell_params_ho);

    if(InCellConfigReqFromOam_p->operator_info.mimo_mode_params.bitmask  
            & RRM_OAM_UL_MIMO_MODE_PARAMS_PRESENT )
    {
        OutCellConfigReqToCellM_p->uplink_sinr_threshold =
            InCellConfigReqFromOam_p->operator_info.mimo_mode_params.ul_mimo_mode_params.uplink_sinr_threshold; 
        OutCellConfigReqToCellM_p->uplink_prb_budget_threshold =
            InCellConfigReqFromOam_p->operator_info.mimo_mode_params.ul_mimo_mode_params.uplink_prb_budget_threshold; 
        OutCellConfigReqToCellM_p->uplink_prb_budget_down_threshold =
            InCellConfigReqFromOam_p->operator_info.mimo_mode_params.ul_mimo_mode_params.uplink_prb_budget_down_threshold; 
    }
    OutCellConfigReqToCellM_p->active_ue_reports_timer =
        InCellConfigReqFromOam_p->operator_info.rrm_ue_scheduling_info.active_ue_reports_timer;
    /* SPR 20653 Fix End */

    /* Fix for CSR: 00059124 */ 
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /* Fix for CSR: 00059124 */

    /* Uplink power starts */
    /* SPR 20653 Fix Start */
    fill_olpc_params(&OutCellConfigReqToCellM_p->rrm_olpc_config_params,
            &InCellConfigReqFromOam_p->ran_info.olpc_config_params);
    /* Uplink power end */

    /*DYNAMIC ICIC START*/
    fill_pdsch_config_params(&InCellConfigReqFromOam_p->operator_info.dynamic_icic_info,
            &OutCellConfigReqToCellM_p->rrm_pdsch_config_params);
    /* SPR 20653 Fix End */
    /*DYNAMIC ICIC END*/

    /*Filling capacity class param*/
    if(RRM_OAM_CELL_CAPACITY_CLASS_PRESENT & InCellConfigReqFromOam_p->operator_info.bitmask)
    {
        OutCellConfigReqToCellM_p->bitmask |= RRMCM_RMIF_CELL_CAPACITY_CLASS_PRESENT;
        OutCellConfigReqToCellM_p->cell_cap_class = InCellConfigReqFromOam_p->operator_info.cell_capacity_class;
    }

    /*Rel10 CR 393 changes start*/
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /*Rel10 CR 393 changes end*/

    /* dynamic pdcch start */
    OutCellConfigReqToCellM_p->dynamic_pdcch = InCellConfigReqFromOam_p->ran_info.mac_layer_params.dynamic_pdcch; 
    /* dynamic pdcch end */
    /* SPR 20653 Fix Start */
    OutCellConfigReqToCellM_p->mac_ecid_meas_start_sfn =  InCellConfigReqFromOam_p->ran_info.mac_layer_params.mac_ecid_meas_start_sfn;

    OutCellConfigReqToCellM_p->pusch_bler_threshold = 
        InCellConfigReqFromOam_p->ran_info.physical_layer_params.physical_layer_param_pusch.pusch_bler_threshold;
    /* SPR 20653 Fix End */
    /* SPR 20908 Start */
    RRM_MEMCPY((&OutCellConfigReqToCellM_p->l2_comm_info_params),&(InCellConfigReqFromOam_p->l2_comm_info_params),sizeof(rrm_oam_lower_layer_comm_info_t));
    /* SPR 20908 End */

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_cell_reconfig_request_for_cellm
 * Inputs         : - p_cell_reconf_req_to_cellm
 *                  - p_cell_reconf_req_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill Cell Reconfig Info for CellM module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_cell_reconfig_request_for_cellm(rrmcm_rmif_cell_reconfig_req_t   *p_cell_reconf_req_to_cellm, 
        rrm_oam_cell_reconfig_req_t      *p_cell_reconf_req_from_oam)
    /* SPR 20653 Fix End */
{

    /* SPR 11906 Fix start */
    U8 index = RRM_ZERO;
    /* SPR 11906 Fix end */
    /*BUG_866_CHANGES_START*/
    /*SPR 17777 +-*/
    /*BUG_866_CHANGES_END*/
    RRM_ASSERT (RRM_PNULL != p_cell_reconf_req_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_cell_reconf_req_from_oam);

    /* CHANGES_FRM_XML_TO_CFG START */
    U8 max_harq_retrans_per_qci_list[9] = {RRM_ZERO};
    U8 qci_count = RRM_ZERO;
    U8 temp_qci_count = RRM_ZERO;
    U8 min_val_for_harq_retrans = RRM_ZERO;
    /* CHANGES_FRM_XML_TO_CFG END */
    /* SPR 18641_18843 fix start */
    U8 tti_bundling_info_present = RRM_FALSE;
    /* SPR 18641_18843 fix end */

    RRM_UT_TRACE_ENTER();

    p_cell_reconf_req_to_cellm->bitmask = 0;

    /* Ran Info*/
    if (p_cell_reconf_req_from_oam->bitmask & RRM_OAM_RAN_INFO_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"RRMCM_RMIF_RAN_INFO_PRESENT");
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_RAN_INFO_PRESENT;  
        /* SPR 20653 Fix Start */
        fill_ran_info_for_cell_reconfig(&p_cell_reconf_req_to_cellm->ran_info, 
                &p_cell_reconf_req_to_cellm->operator_info,
                &p_cell_reconf_req_from_oam->ran_info,
                &p_cell_reconf_req_from_oam->global_cell_id);
        /* SPR 20653 Fix End */
        /*SPR 17777 +-*/
        /*BUG_866_CHANGES_START*/
        /*SPR 17777 +-*/

        if((p_cell_reconf_req_to_cellm->operator_info.bitmask & RRMCM_RMIF_DAHO_CELL_LIST) &&
                (((EUTRA_DAHO_CELL_PRESENT & p_cell_reconf_req_to_cellm->operator_info.daho_cell_config_info.bitmask) ||
                  (UTRAN_DAHO_CELL_PRESENT & p_cell_reconf_req_to_cellm->operator_info.daho_cell_config_info.bitmask) ||
                  (GERAN_DAHO_CELL_PRESENT & p_cell_reconf_req_to_cellm->operator_info.daho_cell_config_info.bitmask))))
        {
            p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_OPERATOR_INFO_PRESENT;
        }

    }
    /* Coverity 60125 fix start */
    /*BUG_866_CHANGES_START*/
    /*cov_fix_start_60125*/
    /*SPR 17777 +-*/

    /*spr 6807  start*/
    if(p_cell_reconf_req_from_oam->bitmask & RRM_OAM_CELL_ACCESS_PARAMS_PRESENT)
        /*spr 6807  end*/
    {
        fill_cell_restriction_info_for_cell_reconfig(&(p_cell_reconf_req_to_cellm->ran_info.cell_restriction_params),
                &(p_cell_reconf_req_from_oam->cell_access_restriction_params));
        /*SPR 17777 +-*/

        /*SPR 8181 FIX START*/
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_RAN_INFO_PRESENT;
        /*SPR 8181 FIX END*/
        /* SPR 12603_12618 Fix start */
        /* SPR 20653 Fix Start */
        /* Code removed */
        /* SPR 20653 Fix End */
        /* SPR 12603_12618 Fix end   */

        p_cell_reconf_req_to_cellm->ran_info.bitmask |= RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT;
    }
    /*cov_fix_end_60125*/

    if(p_cell_reconf_req_from_oam->bitmask & RRM_OAM_EPC_INFO_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"RRMCM_RMIF_EPC_INFO_PRESENT");
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_EPC_INFO_PRESENT;
        /* SPR 20653 Fix Start */
        fill_epc_info_for_cell_reconfig(
                &p_cell_reconf_req_to_cellm->epc_info, 
                &p_cell_reconf_req_from_oam->epc_info,
                /* SPR 18641_18843 fix start */
                &p_cell_reconf_req_from_oam->ran_info,
                &tti_bundling_info_present); 
        /* SPR 18641_18843 fix end */
        /* SPR 20653 Fix End */
    }


    if (p_cell_reconf_req_from_oam->bitmask & RRM_OAM_OPERATOR_INFO_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"RRMCM_RMIF_OPERATOR_INFO_PRESENT");
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_OPERATOR_INFO_PRESENT;
        /* SPR 20653 Fix Start */
        fill_operator_info_for_cell_reconfig(&p_cell_reconf_req_to_cellm->operator_info, 
                &p_cell_reconf_req_from_oam->operator_info,
                /*SPR 17777 +-*/
                &p_cell_reconf_req_from_oam->ran_info.rf_params,
                &p_cell_reconf_req_from_oam->ran_info.physical_layer_params,
                /* SPR 18641_18843 fix start */
                &p_cell_reconf_req_from_oam->ran_info.mac_layer_params,
                tti_bundling_info_present); 
        /* SPR 18641_18843 fix end */
        /* SPR 20653 Fix End */

        /*  DYNAMIC ICIC CHANGES START */
        if(p_cell_reconf_req_from_oam->operator_info.bitmask & RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT)
        {
            p_cell_reconf_req_to_cellm->ran_info.physical_layer_params.physical_layer_param_pdsch.p_a_for_cell_edge_ue =
                p_cell_reconf_req_from_oam->operator_info.dynamic_icic_info.pa_for_ce_ue;
        }
        /*  DYNAMIC ICIC CHANGES END */
        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_cell_reconf_req_from_oam->operator_info.bitmask & RRM_OAM_MAC_CONFIG_PRESENT)
        {
            if(p_cell_reconf_req_from_oam->bitmask & RRM_OAM_EPC_INFO_PRESENT)
            {
                for(qci_count = RRM_ZERO ; qci_count < p_cell_reconf_req_from_oam->epc_info.epc_params.num_valid_qos_profiles ; qci_count++)
                {
                    if(p_cell_reconf_req_from_oam->epc_info.epc_params.qos_config_params[qci_count].bitmask &
                            RRM_OAM_ARQ_TX_RETRANS_PRESENT)
                        /* SPR 20653 Fix Start */
                    {
                        max_harq_retrans_per_qci_list[qci_count] = 
                            p_cell_reconf_req_from_oam->epc_info.epc_params.qos_config_params[qci_count].max_harq_retrans;
                    }
                }
            }
            /* Code Removed */
            /* SPR 20653 Fix End */
        }
        min_val_for_harq_retrans = max_harq_retrans_per_qci_list[RRM_ZERO];
        for(temp_qci_count = RRM_ONE ; temp_qci_count < qci_count; temp_qci_count++)
        {
            if(max_harq_retrans_per_qci_list[temp_qci_count] < min_val_for_harq_retrans)
            {
                min_val_for_harq_retrans = max_harq_retrans_per_qci_list[temp_qci_count];
            }
        }
        p_cell_reconf_req_to_cellm->operator_info.rrm_mac_config.max_harq_retrans = min_val_for_harq_retrans;


        /* SPR 11906 Fix start */
        if (p_cell_reconf_req_from_oam->operator_info.bitmask & RRM_OAM_MIMO_MODE_PARAMS_PRESENT)
        {
            p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_RAN_INFO_PRESENT; 
            /* SPR 12603_12618 Fix start */
            /* SPR 20653 Fix Start */
            /* Code removed */
            /* SPR 20653 Fix End */
            /* SPR 12603_12618 Fix end   */

            if (p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.bitmask & RRM_OAM_CODEBOOK_SUBSET_RESTRICTION_PRESENT)
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                        "CBSR count received = %d",
                        p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.num_of_cbsr);

                p_cell_reconf_req_to_cellm->ran_info.antenna_info.num_cbsr = p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.num_of_cbsr;

                for(index = RRM_ZERO;((index < RRM_OAM_MAX_CODEBOOK_SUBSET ));index++)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED ,
                            "CBSR type received = %d",
                            p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.mimo_cbsr[index].type);

                    p_cell_reconf_req_to_cellm->ran_info.antenna_info.cbsr[index].type = 
                        p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.mimo_cbsr[index].type;

                    RRM_MEMCPY(p_cell_reconf_req_to_cellm->ran_info.antenna_info.cbsr[index].value,
                            p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.mimo_cbsr[index].value,
                            RRM_EIGHT);
                }
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "CBSR info is not coming from OAM"); 
            }

            if(p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.bitmask & RRM_OAM_SINR_THRESHOLD_PRESENT)
            {
                p_cell_reconf_req_to_cellm->ran_info.antenna_info.sinr_threshold = p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.sinr_threshold;
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "SINR THRSHOLD is not coming from OAM"); 
            }
            if(p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.bitmask & RRM_OAM_PATHLOSS_THRESHOLD_PRESENT)
            {
                p_cell_reconf_req_to_cellm->ran_info.antenna_info.pathloss_threshold = p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.pathloss_threshold;
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "PATHLOSS THRSHOLD is not coming from OAM, value received at the time of cell config or default value will be used"); 
            }
            if(p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.bitmask & RRM_OAM_MOBILITY_SINR_THRESHOLD_PRESENT)  
            {
                p_cell_reconf_req_to_cellm->ran_info.antenna_info.ue_speed_catagory_data.ue_speed_category1_deltaSINR_thresold =
                    p_cell_reconf_req_from_oam->operator_info.mimo_mode_params.mobility_sinr_threshold;
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                        "MOBILITY THRSHOLD is not coming from OAM"); 
            }
        }
        /* SPR 11906 Fix end */
    }
    /* SPR 23041 fix start */
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"RRMCM_RMIF_OPERATOR_INFO_PRESENT is not receieved");
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_OPERATOR_INFO_PRESENT;
    }
    /* SPR 23041 fix stop */
    /* CHANGES_FRM_XML_TO_CFG START */

    if (p_cell_reconf_req_from_oam->bitmask & RRM_OAM_RRM_ACCESS_MGMT_PARAMS_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"RRMCM_RMIF_RRM_ACCESS_MGMT_PARAMS_PRESENT");
        p_cell_reconf_req_to_cellm->bitmask |= 
            RRMCM_RMIF_RRM_ACCESS_MGMT_PARAMS_PRESENT;
        fill_access_mangt_info(&p_cell_reconf_req_to_cellm->access_mgmt_params, 
                &p_cell_reconf_req_from_oam->access_mgmt_params); 
    }

    if(p_cell_reconf_req_from_oam->operator_info.bitmask & RRM_OAM_CELL_CAPACITY_CLASS_PRESENT)
    {
        p_cell_reconf_req_to_cellm->bitmask |= RRMCM_RMIF_RECONFIG_CELL_CAPACITY_CLASS_PRESENT;
        p_cell_reconf_req_to_cellm->cell_cap_class = p_cell_reconf_req_from_oam->operator_info.cell_capacity_class;
    }
    /*Rel10 CR 393 changes start*/
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /*Rel10 CR 393 changes end*/
    /* SPR 21251 +- */
    RRM_UT_TRACE_EXIT();
    /* Coverity 60125 fix end */
}


/*****************************************************************************
 * Function Name  : rrm_mif_log_enable_disable_cmd
 * Inputs         : Log Enable/Disable
 *                  Log Level to be set
 * Outputs        : None
 * Returns        : None
 * Description    : This function processes RRM_OAM_LOG_ENABLE_DISABLE_REQ msg
 *                  to set the logging parameters for RRM MgmtIfH
 ****************************************************************************/
void rrm_mif_log_enable_disable_cmd (
        rrm_mif_gb_context_t      *p_gl_ctxt,
        rrm_oam_log_on_off_et log_on_off,
        rrm_oam_log_level_et log_level)
{
    RRM_UT_TRACE_ENTER();

    p_gl_ctxt->log_level = log_level;
    if(RRM_OAM_LOG_OFF == log_on_off)
    {
        log_level = RRM_OAM_NONE;
    }
    SET_MODULE_LOG_LEVEL(log_level);
    g_mif_log_on_off = p_gl_ctxt->log_enabled = log_on_off;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
            "Log enable/disable = %d",
            log_on_off);

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  :build_and_send_set_log_level_req 
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_in_cell_del_req_from_oam - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Log Enable/Disable Request to CellM/UeM
 ****************************************************************************/
void build_and_send_set_log_level_req(/*SPR 17777 +-*/
        rrm_oam_set_log_level_req_t 
        *p_in_log_en_dis_req_from_oam,
        U16                        trans_id)
{
    rrmcm_rmif_set_log_level_req_t       OutSetLogLeveReqToCellM = {0};
    rrmuem_rmif_set_log_level_req_t      OutSetLogLeveReqToUeM= {0};

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_in_log_en_dis_req_from_oam);

    if ((p_in_log_en_dis_req_from_oam->module_id == RRM_OAM_CM_MODULE_ID) ||
            (p_in_log_en_dis_req_from_oam->module_id == RRM_ALL_MODULE_ID))
    {
        OutSetLogLeveReqToCellM.transaction_id = trans_id;
        switch(p_in_log_en_dis_req_from_oam->log_level)
        {  
            case RRM_OAM_INFO:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_INFO;
                break;

            case RRM_OAM_BRIEF:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_BRIEF;
                break;

            case RRM_OAM_DETAILED:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_DETAILED;
                break;

            case RRM_OAM_DETAILEDALL:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_DETAILEDALL;
                break;

            case RRM_OAM_WARNING:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_WARNING;
                break;

            case RRM_OAM_ERROR:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_ERROR;
                break;

            case RRM_OAM_CRITICAL:
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_CRITICAL;
                break;

            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                        RRM_WARNING, "Invalid Log Level[%d] received. Using BRIEF as default",
                        p_in_log_en_dis_req_from_oam->log_level);
                OutSetLogLeveReqToCellM.log_level = RRM_OAM_BRIEF;
                break;

        }

        /* Sending Log Enable Disable Request to CellM */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Sending rrmcm_rmif_set_log_level_req_t to CellM");
        rrm_mif_send_internal_msg(RRM_OAM_CM_MODULE_ID,
                RRMCM_RMIF_SET_LOG_LEVEL_REQ,
                sizeof(rrmcm_rmif_set_log_level_req_t),
                &OutSetLogLeveReqToCellM);
    }
    if ((p_in_log_en_dis_req_from_oam->module_id == RRM_OAM_UEM_MODULE_ID) ||
            (p_in_log_en_dis_req_from_oam->module_id == RRM_ALL_MODULE_ID))
    {
        OutSetLogLeveReqToUeM.transaction_id = trans_id;
        switch(p_in_log_en_dis_req_from_oam->log_level)
        {
            case RRM_OAM_INFO:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_INFO;
                break;

            case RRM_OAM_BRIEF:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_BRIEF;
                break;

            case RRM_OAM_DETAILED:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_DETAILED;
                break;

            case RRM_OAM_DETAILEDALL:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_DETAILEDALL;
                break;

            case RRM_OAM_WARNING:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_WARNING;
                break;

            case RRM_OAM_ERROR:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_ERROR;
                break;

            case RRM_OAM_CRITICAL:
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_CRITICAL;
                break;

            default:
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, 
                        RRM_ERROR, "Invalid Log Level[%d] received. Using BRIEF as default",
                        p_in_log_en_dis_req_from_oam->log_level);
                OutSetLogLeveReqToUeM.log_level = RRM_UEM_LOG_LEVEL_BRIEF;
                break;

        }
        /* Sending Log Enable Disable Request to UEM */
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Sending rrmuem_rmif_set_log_level_req_t to UEM");
        rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
                RRMUEM_RMIF_SET_LOG_LEVEL_REQ,
                sizeof(rrmuem_rmif_set_log_level_req_t),
                &OutSetLogLeveReqToUeM);
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_rac_enable_disable_req_to_cellm 
 * Inputs         : 
 *                  1. p_gl_ctxt                         : not null
 *                  2. p_mif_context
 *                  3. p_rac_enable_disable_req_from_oam      : not null
 *                  4. p_rac_enable_disable_req_to_cellm   : not null
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares Land sends RAC Enable/Disable 
 *                  Request to UEM
 ****************************************************************************/
void build_and_send_rac_enable_disable_req_to_cellm
(
 /*SPR 17777 +-*/
 rrm_mif_context                      *p_mif_context,
 rrm_oam_rac_enable_disable_req_t     *p_rac_enable_disable_req_from_oam,
 rrmcm_rmif_rac_enable_disable_req_t  *p_rac_enable_disable_req_to_cellm
 )
{
    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_rac_enable_disable_req_from_oam);
    RRM_ASSERT (RRM_PNULL != p_rac_enable_disable_req_to_cellm);

    p_rac_enable_disable_req_to_cellm->transaction_id = p_mif_context->currently_processed_api_trans_d;
    p_rac_enable_disable_req_to_cellm->cell_index = p_mif_context->cell_index;
    p_rac_enable_disable_req_to_cellm->bitmask = p_rac_enable_disable_req_from_oam->bitmask;

    p_rac_enable_disable_req_to_cellm->enable_rac = 
        (p_rac_enable_disable_req_from_oam->request_type == RRM_OAM_RAC_ENABLE ? RRM_TRUE : RRM_FALSE);

    /* Sending stop admission request to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_RAC_ENABLE_DISABLE_REQ,
            sizeof(rrmcm_rmif_rac_enable_disable_req_t),
            (void *)p_rac_enable_disable_req_to_cellm);

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_rac_enable_disable_resp_to_oam 
 * Inputs         : 
 *                  1. p_gl_ctxt                              : not null
 *                  2. p_mif_context
 *                  3. p_in_rac_enable_disable_resp_from_cellm  : not null
 *                  4. p_out_rac_enable_disable_resp_to_oam   : not null
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares and sends RAC Enable/Disable
 *                  Response to OAMH
 ****************************************************************************/
    void build_and_send_rac_enable_disable_resp_to_oam
(
 rrm_mif_gb_context_t                 *p_gl_ctxt,
 rrm_mif_context                      *p_mif_context,
 rrmcm_rmif_rac_enable_disable_res_t  *p_in_rac_enable_disable_resp_from_cellm,
 rrm_oam_rac_enable_disable_resp_t    *p_out_rac_enable_disable_resp_to_oam
 )
{
    /* SPR 10811 start */
    /*SPR 15993 Fix Start*/
    /* Code Deleted */
    /*SPR 15993 Fix End*/
    U8             mif_ctxt_cnt   = RRM_ZERO;
    rrm_cell_index_t    cell_index  = RRM_ZERO;
    /* SPR 10811 end */


    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_gl_ctxt);
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_rac_enable_disable_resp_from_cellm);
    RRM_ASSERT (RRM_PNULL != p_out_rac_enable_disable_resp_to_oam);

    /* Fill in the global cell id from cellindex received from uem */
    /* SPR 10811 start */
    if (RRM_TRUE == (RMIF_GLOBAL_CELL_ID_PRESENT(p_in_rac_enable_disable_resp_from_cellm)))
    {
        /* SPR 10811 end */
        for (mif_ctxt_cnt = 0; mif_ctxt_cnt < MAX_NUM_MIF_CTXT; mif_ctxt_cnt++)
        {
            if ( RRM_TRUE == p_gl_ctxt->map_info[mif_ctxt_cnt].is_info_valid)
            {
                if (p_gl_ctxt->map_info[mif_ctxt_cnt].cell_index == p_in_rac_enable_disable_resp_from_cellm->cell_index)
                {
                    /* Copy the cell id */
                    rrm_memcpy_rrm_oam_eutran_global_cell_id(
                            &(p_out_rac_enable_disable_resp_to_oam->global_cell_id),
                            &(p_gl_ctxt->map_info[mif_ctxt_cnt].global_cell_id));

                    /* SPR 10811 start */
                    cell_index = p_in_rac_enable_disable_resp_from_cellm->cell_index;
                    /* SPR 10811 end */
                    break;
                }
            }
        }
    }
    /*SPR 15993 Fix Start*/
    /* Code Deleted */
    /*SPR 15993 Fix End*/
    p_out_rac_enable_disable_resp_to_oam->bitmask = p_in_rac_enable_disable_resp_from_cellm->bitmask;

    if (RRM_SUCCESS == p_in_rac_enable_disable_resp_from_cellm->response)
    {
        p_out_rac_enable_disable_resp_to_oam->response = RRM_SUCCESS;
        /* SPR 10811 start */
        p_out_rac_enable_disable_resp_to_oam->fail_cause = RRM_NO_ERROR;
        /* SPR 10811 end */
#ifdef RRM_UT_FLAG        
        RRM_INCR_MSG_LOG_COUNTER(gp_rrmStats->rrmOamDebugStats.rac_enbl_disbl_resp_S);
#endif        
    }
    else
    {
        p_out_rac_enable_disable_resp_to_oam->response = RRM_FAILURE;
        /* coverity : CID 16481*/
        p_out_rac_enable_disable_resp_to_oam->fail_cause = (rrm_error_et)p_in_rac_enable_disable_resp_from_cellm->fail_cause;
    }


    rrm_oam_send_rrm_oam_rac_enable_disable_resp(
            p_out_rac_enable_disable_resp_to_oam,
            RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID,
            /*SPR 15993 Fix Start*/
            p_mif_context->currently_processed_api_trans_d,
            /*SPR 15993 Fix End*/
            /* SPR 10811 start */
            cell_index);
    /* SPR 10811 end */

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : build_and_send_init_ind_to_oam 
 * Inputs         : None
 * Outputs        : None
 * Returns        : None
 * Description    : This function prepares and sends an INIT_IND to OAM
 ****************************************************************************/
void build_and_send_init_ind_to_oam(void)
{
    void  *p_msg          = RRM_PNULL;
    U8     msg_api_length = 0;

    RRM_UT_TRACE_ENTER();

    /* Allocate buffer */
    msg_api_length = RRM_API_HEADER_SIZE + RRM_INTERFACE_API_HEADER_SIZE;
    p_msg = rrm_msg_mem_get(msg_api_length);
    RRM_ASSERT(p_msg != RRM_PNULL);
    /* Coverity 61369 Fix Start */
    if (RRM_PNULL == p_msg)
    {
        RRM_UT_TRACE_EXIT();
        return;
    }
    /* Coverity 61369 Fix End */
    RRM_MEMSET(p_msg, 0, msg_api_length);

    /* Fill CSPL header */
    rrm_construct_api_header(p_msg, RRM_VERSION_ID, RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID, RRM_OAM_INIT_IND, msg_api_length);

    /* Fill interface header */
    rrm_construct_interface_api_header(((U8*)p_msg + RRM_API_HEADER_SIZE),
            RRM_ZERO, RRM_MIF_MODULE_ID,
            RRM_OAM_MODULE_ID, RRM_OAM_INIT_IND, RRM_ZERO, RRM_ZERO);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Sending OAM INIT");

    /* Send message to oam*/
    rrm_send_message(p_msg, RRM_OAM_MODULE_ID);

    RRM_UT_TRACE_EXIT();
}

/***************************************************************************
 * Function Name  :     build_and_send_context_print_req
 * Inputs         :
 *
 * Outputs        :
 * Returns        :
 * Description    :
 ***************************************************************************/
void build_and_send_context_print_req(U8 cell_index)
{
    rrmcm_rmif_cell_context_print_req_t  OutCellContextPrintReq = {0};

    RRM_UT_TRACE_ENTER();

    OutCellContextPrintReq.cell_index = cell_index ;

    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CELL_CONTEXT_PRINT_REQ,
            sizeof(rrmcm_rmif_cell_context_print_req_t),
            &OutCellContextPrintReq);
    RRM_UT_TRACE_EXIT();
}

/*UE RELEASE REQ*/
/***************************************************************************
 * Function Name  :    build_and_send_ue_release_req
 * Inputs         :
 *
 * Outputs        :
 * Returns        :
 * Description    :
 ***************************************************************************/


void  build_and_send_ue_release_req
( 
 U16 ue_index, 
 /*SPR 17777 +-*/
 /*SPR_1366_FIX_START*/
 U8  cell_index
 /*SPR_1366_FIX_END*/
 )
{

    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_ue_release_req_t  *rrmuem_rmif_ue_release_req = RRM_PNULL;
    rrmuem_rmif_ue_release_req =(rrmuem_rmif_ue_release_req_t *)
        rrm_mem_get(sizeof(rrmuem_rmif_ue_release_req_t));

    if ( rrmuem_rmif_ue_release_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to rrmuem_rmif_ue_release_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /*SPR_1366_FIX_START*/
    rrmuem_rmif_ue_release_req->cell_index=cell_index;
    /*SPR_1366_FIX_END*/
    rrmuem_rmif_ue_release_req->ue_index=ue_index;

    rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
            RRMUEM_RMIF_UE_REL_REQ,
            sizeof(rrmuem_rmif_ue_release_req_t),
            (void *)rrmuem_rmif_ue_release_req);
    RRM_MEM_FREE(rrmuem_rmif_ue_release_req);
    RRM_UT_TRACE_EXIT();
}


/*CID 66683:start*/
/****************************************************************************
 * Function Name  : rrm_fill_cdma_neighbor_list_xrtt 
 * Inputs         : p_in_cdma_neighbor_list_xrtt
 *                  p_out_cdma_neighbor_list_xrtt
 * Outputs        : None
 * Returns        : void
 * Description    : This function fills cdma_neighbor_list_xrtt 
 *                  received from SON
 ****************************************************************************/
rrm_void_t
    rrm_fill_cdma_neighbor_list_xrtt
(
 rrmcm_rmif_cdma_neighbor_list_xrtt_t *p_out_cdma_neighbor_list_xrtt,
 son_rrm_cdma_neighbor_list_xrtt_t  *p_in_cdma_neighbor_list_xrtt
 )
{
    U8 count = RRM_ZERO;
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_out_cdma_neighbor_list_xrtt->band_class = p_in_cdma_neighbor_list_xrtt->band_class;

    for (count = RRM_ZERO; count < p_in_cdma_neighbor_list_xrtt->cell_list_size; count ++)
    {
        p_out_cdma_neighbor_list_xrtt->cell_list_size++; 
        p_out_cdma_neighbor_list_xrtt->cell_list[count].pci = p_in_cdma_neighbor_list_xrtt->\
                                                              cell_list[count].pci;

        if (SON_RRM_CGI_1X_RTT_PRESENT & p_in_cdma_neighbor_list_xrtt->cell_list[count].cgi.bitmask)
        {
            p_out_cdma_neighbor_list_xrtt->cell_list[count].cgi.bitmask |= RRM_SON_CDMA_CGI_1X_RTT_PRESENT;
            for (index = RRM_ZERO; index < RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE; index++)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cgi.cell_global_id_1X_RTT[index] = 
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cgi.cell_global_id_1X_RTT[index];
            }
        }
        if (SON_RRM_CGI_HRPD_PRESENT & p_in_cdma_neighbor_list_xrtt->cell_list[count].cgi.bitmask)
        {
            p_out_cdma_neighbor_list_xrtt->cell_list[count].cgi.bitmask |= RRM_SON_CDMA_CGI_HRPD_PRESENT;
            for (index = RRM_ZERO; index < RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE; index++)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cgi.cell_global_id_HRPD[index] = 
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cgi.cell_global_id_HRPD[index];
            }
        }

        p_out_cdma_neighbor_list_xrtt->cell_list[count].arfcn = p_in_cdma_neighbor_list_xrtt->\
                                                                cell_list[count].arfcn;
        if (p_in_cdma_neighbor_list_xrtt->cell_list[count].bitmask & 
                SON_RRM_CDMA_XRTT_CELL_SPECIFIC_OFFSET_PRESENT)
        {
            p_out_cdma_neighbor_list_xrtt->cell_list[count].bitmask |= RRM_SON_CDMA_NBR_CELL_XRTT_CSO;
            p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_offset = 
                p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_offset;
        }
        if (p_in_cdma_neighbor_list_xrtt->cell_list[count].bitmask &
                SON_RRM_CDMA_XRTT_CELL_SPECIFIC_PARAMS_PRESENT)
        {
            p_out_cdma_neighbor_list_xrtt->cell_list[count].bitmask |= 
                RRM_SON_CDMA_XRTT_CELL_SPECIFIC_PARAMS_PRESENT;
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_PZ_HYST_PARAMS_INCLUDED_PRESENT)
            {

                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask |=
                    RRMCM_RMIF_PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT;
                if ( SON_RRM_CDMA_PZ_HYST_ENABLED_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_ENABLD_PRESENT;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_enabled =
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_enabled ;
                }
                if ( SON_RRM_CDMA_PZ_HYST_INFO_INCL_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_INFO_INCL_PRESENT;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_info_incl =
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_info_incl ;
                }
                if (SON_RRM_CDMA_PZ_HYST_TIMER_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_LIST_LEN_PRESENT  ;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_list_len=
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_list_len;
                }
                if ( SON_RRM_CDMA_PZ_HYST_TIMER_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_ACT_TIMER_PRESENT;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_act_timer =
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_act_timer ;
                }
                if ( SON_RRM_CDMA_PZ_HYST_TIMER_MUL_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_TIMER_MUL_PRESENT;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_timer_mul=
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_timer_mul;
                }
                if (SON_RRM_CDMA_PZ_HYST_TIMER_EXP_PRESENT & p_in_cdma_neighbor_list_xrtt->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_TIMER_EXP_PRESENT;

                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_timer_exp=
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_timer_exp;
                }

            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_P_REV_PRESENT )
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_P_REV_INCLUDED_PRESENT ;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.p_rev =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.p_rev;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MIN_P_REV_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MIN_P_REV_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.min_p_rev =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.min_p_rev;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_NEG_SLOT_CYCLE_INDEX_PRESENT )
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    neg_slot_cycle_index_sup = p_in_cdma_neighbor_list_xrtt->cell_list[count].\
                    cell_specific_params.neg_slot_cycle_index_sup;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ENCRYPT_MODE_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ENCRYPT_MODE_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.encrypt_mode =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.encrypt_mode;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ENCRYPT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ENC_SUPPORTED_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.enc_supported =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.encrypt_suported;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SYG_ENCRYPT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_ENCRYPT_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.sig_encrypt_sup =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.syg_encrypt_suported;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MSG_INT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MSG_INTEGRITY_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.msg_integrity_sup =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.msg_integrity_sup;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SIG_INT_SUPPORTED_INCL_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    sig_integrity_sup_incl = p_in_cdma_neighbor_list_xrtt->cell_list[count].\
                    cell_specific_params.sig_integrity_sup_incl;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SIG_INT_SUPPORTED_PRESENT )
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_INTEGRITY_SUP_INCLUDED_PRESENT ;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.sig_integrity_sup =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.sig_integrity_sup;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MS_INIT_POS_LOC_SUP_IND_PRESENT )
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.ms_init_pos_loc_sup_ind =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.ms_init_pos_loc_sup_ind;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_BAND_CLASS_INFO_REQ_PRESENT )
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_BAND_CLASS_INFO_REQ_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.band_class_info_req =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.band_class_info_req;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_BAND_CLASS_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_BAND_CLASS_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.band_class =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.band_class;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ALT_BAND_CLASS_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ALT_BAND_CLASS_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.alt_band_class =
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.alt_band_class;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_TKZ_MODE_SUP_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_TKZ_MODE_SUPPORTED_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.tkz_mode_supported=
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.tkz_mode_supported;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_TKZ_ID_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_TKZ_ID_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.tkz_id=
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.tkz_id;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_FPC_FCH_INCLUDED)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_FPC_FCH_INCLUDED_PRESENT;

                if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC3_PRESENT)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC3_PRESENT;
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc3 = 
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc3;
                }
                if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC4_PRESENT)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC4_PRESENT;
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc4 = 
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc4;
                }
                if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC5_PRESENT)
                {
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC5_PRESENT ;
                    p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc5 = 
                        p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc5;
                }
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_T_ADD)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_T_ADD_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.t_add=
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.t_add;
            }
            if (p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_PILOT_INC_PRESENT)
            {
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_PILOT_INC_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.pilot_inc=
                    p_in_cdma_neighbor_list_xrtt->cell_list[count].cell_specific_params.pilot_inc;
            }

        }

    }

    RRM_UT_TRACE_EXIT();
}
/*CID 66683:end*/

/*CID 66682:start*/
/****************************************************************************
 * Function Name  : rrm_fill_cdma_neighbor_list_hrpd 
 * Inputs         : p_in_cdma_neighbor_list_hrpd
 *                  p_out_cdma_neighbor_list_hrpd
 * Outputs        : None
 * Returns        : void
 * Description    : This function fills cdma_neighbor_list_hrpd structure
 ****************************************************************************/
rrm_void_t
    rrm_fill_cdma_neighbor_list_hrpd
(
 rrmcm_rmif_cdma_neighbor_list_hrpd_t *p_out_cdma_neighbor_list_hrpd,
 son_rrm_cdma_neighbor_list_hrpd_t  *p_in_cdma_neighbor_list_hrpd
 )
{
    U8 count = RRM_ZERO; 
    U8 index = RRM_ZERO;
    RRM_UT_TRACE_ENTER();

    p_out_cdma_neighbor_list_hrpd->band_class = p_in_cdma_neighbor_list_hrpd->band_class;

    for (count = RRM_ZERO; count < p_out_cdma_neighbor_list_hrpd->cell_list_size; count ++)
    {
        p_out_cdma_neighbor_list_hrpd->cell_list_size ++;
        p_out_cdma_neighbor_list_hrpd->cell_list[count].pci = p_in_cdma_neighbor_list_hrpd->cell_list[count].pci;
        if (SON_RRM_CGI_1X_RTT_PRESENT & p_in_cdma_neighbor_list_hrpd->cell_list[count].cgi.bitmask)
        {
            p_out_cdma_neighbor_list_hrpd->cell_list[count].cgi.bitmask |= RRM_SON_CDMA_CGI_1X_RTT_PRESENT;
            for (index = RRM_ZERO; index < RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE; index++)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cgi.cell_global_id_1X_RTT[index] = 
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cgi.cell_global_id_1X_RTT[index];
            }
        }
        if (SON_RRM_CGI_HRPD_PRESENT & p_in_cdma_neighbor_list_hrpd->cell_list[count].cgi.bitmask)
        {
            p_out_cdma_neighbor_list_hrpd->cell_list[count].cgi.bitmask |= RRM_SON_CDMA_CGI_HRPD_PRESENT;
            for (index = RRM_ZERO; index < RRM_SON_CDMA_CELL_GLOBAL_ID_1X_RTT_SIZE; index++)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cgi.cell_global_id_HRPD[index] = 
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cgi.cell_global_id_HRPD[index];
            }
        }

        p_out_cdma_neighbor_list_hrpd->cell_list[count].arfcn = 
            p_in_cdma_neighbor_list_hrpd->cell_list[count].arfcn;
        if (p_in_cdma_neighbor_list_hrpd->cell_list[count].bitmask & 
                SON_RRM_CDMA_HRPD_CELL_SPECIFIC_OFFSET_PRESENT)
        {
            p_out_cdma_neighbor_list_hrpd->cell_list[count].bitmask |= RRM_SON_CDMA_NBR_CELL_HRPD_CSO;
            p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_offset = 
                p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_offset;
        }
        if (p_in_cdma_neighbor_list_hrpd->cell_list[count].bitmask &
                SON_RRM_CDMA_HRPD_CELL_SPECIFIC_PARAMS_PRESENT)
        {
            p_out_cdma_neighbor_list_hrpd->cell_list[count].bitmask |= 
                RRM_SON_CDMA_HRPD_CELL_SPECIFIC_PARAMS_PRESENT;
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_PZ_HYST_PARAMS_INCLUDED_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask |=
                    RRMCM_RMIF_PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT;
                if ( SON_RRM_CDMA_PZ_HYST_ENABLED_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_ENABLD_PRESENT;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_enabled =
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_enabled ;
                }
                if ( SON_RRM_CDMA_PZ_HYST_INFO_INCL_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_INFO_INCL_PRESENT;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_info_incl =
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_info_incl ;
                }
                if (SON_RRM_CDMA_PZ_HYST_TIMER_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_LIST_LEN_PRESENT  ;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_list_len=
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_list_len;
                }
                if ( SON_RRM_CDMA_PZ_HYST_TIMER_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_ACT_TIMER_PRESENT;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_act_timer =
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_act_timer ;
                }
                if ( SON_RRM_CDMA_PZ_HYST_TIMER_MUL_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_TIMER_MUL_PRESENT;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_timer_mul=
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_timer_mul;
                }
                if (SON_RRM_CDMA_PZ_HYST_TIMER_EXP_PRESENT & p_in_cdma_neighbor_list_hrpd->\
                        cell_list[count].cell_specific_params.pz_hyst_params_included.bitmask)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.bitmask |= RRMCM_RMIF_PZ_HYST_TIMER_EXP_PRESENT;

                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_parameters_included.pz_hyst_timer_exp=
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        pz_hyst_params_included.pz_hyst_timer_exp;
                }

            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_P_REV_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_P_REV_INCLUDED_PRESENT ;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.p_rev =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.p_rev;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MIN_P_REV_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MIN_P_REV_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.min_p_rev =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.min_p_rev;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_NEG_SLOT_CYCLE_INDEX_PRESENT )
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    neg_slot_cycle_index_sup =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    neg_slot_cycle_index_sup;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ENCRYPT_MODE_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ENCRYPT_MODE_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.encrypt_mode =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.encrypt_mode;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ENCRYPT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ENC_SUPPORTED_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.enc_supported =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.encrypt_suported;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SYG_ENCRYPT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_ENCRYPT_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.sig_encrypt_sup =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.syg_encrypt_suported;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MSG_INT_SUPPORTED_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MSG_INTEGRITY_SUP_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.msg_integrity_sup =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.msg_integrity_sup;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SIG_INT_SUPPORTED_INCL_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    sig_integrity_sup_incl = p_in_cdma_neighbor_list_hrpd->cell_list[count].\
                    cell_specific_params.sig_integrity_sup_incl;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_SIG_INT_SUPPORTED_PRESENT )
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_SIG_INTEGRITY_SUP_INCLUDED_PRESENT ;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.sig_integrity_sup =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.sig_integrity_sup;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_MS_INIT_POS_LOC_SUP_IND_PRESENT )
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    ms_init_pos_loc_sup_ind = p_in_cdma_neighbor_list_hrpd->cell_list[count].\
                    cell_specific_params.ms_init_pos_loc_sup_ind;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_BAND_CLASS_INFO_REQ_PRESENT )
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_BAND_CLASS_INFO_REQ_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.band_class_info_req =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.band_class_info_req;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_BAND_CLASS_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_BAND_CLASS_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.band_class =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.band_class;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_ALT_BAND_CLASS_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_ALT_BAND_CLASS_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.alt_band_class =
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.alt_band_class;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_TKZ_MODE_SUP_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_TKZ_MODE_SUPPORTED_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.tkz_mode_supported=
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.tkz_mode_supported;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_TKZ_ID_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_TKZ_ID_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.tkz_id=
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.tkz_id;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_FPC_FCH_INCLUDED)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_FPC_FCH_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    fpc_fch_included.bitmask = p_in_cdma_neighbor_list_hrpd->cell_list[count].\
                    cell_specific_params.fpc_fch_included.bitmask;

                if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC3_PRESENT)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC3_PRESENT;
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc3 = 
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc3;
                }
                if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC4_PRESENT)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC4_PRESENT;
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc4 = 
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc4;
                }
                if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask & SON_RRM_CDMA_FPC_FCH_INCL_RC5_PRESENT)
                {
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.bitmask |= RRMCM_RMIF_FPC_FCH_INIT_SETPT_RC5_PRESENT ;
                    p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc5 = 
                        p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                        fpc_fch_included.fpc_fch_init_setpt_rc5;
                }
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_T_ADD)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_T_ADD_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.t_add=
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.t_add;
            }
            if (p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.bitmask
                    & SON_RRM_CDMA_CSP_PILOT_INC_PRESENT)
            {
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.\
                    bitmask |= RRMCM_RMIF_PILOT_INC_INCLUDED_PRESENT;
                p_out_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.pilot_inc=
                    p_in_cdma_neighbor_list_hrpd->cell_list[count].cell_specific_params.pilot_inc;
            }

        }

    }

    RRM_UT_TRACE_EXIT();
}

/*CID 66682:end*/

/* UPDATED NRT INFO CHANGES START */ 
/****************************************************************************
 * Function Name  : build_and_send_son_updated_nrt_info_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_updated_nrt_info_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares Updated NRT Info Request to CellM
 ****************************************************************************/
void build_and_send_son_updated_nrt_info_to_cellm(/*SPR 17777 +-*/
        rrm_mif_context                  *p_mif_context, 
        son_anr_rrm_updated_nrt_info_t   *p_in_updated_nrt_info_msg,
        U16                              src)
{
    rrmcm_rmif_updated_nrt_info_t *p_out_updated_nrt_info_msg = RRM_PNULL;
    /*CID 66683:start*/
    U8 count    = RRM_ZERO;
    /*CID 66683:end*/
    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT (RRM_PNULL != p_mif_context);
    RRM_ASSERT (RRM_PNULL != p_in_updated_nrt_info_msg);

    p_out_updated_nrt_info_msg = (rrmcm_rmif_updated_nrt_info_t*)
        rrm_mem_get(sizeof(rrmcm_rmif_updated_nrt_info_t));

    if ( p_out_updated_nrt_info_msg == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to p_out_updated_nrt_info_msg failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /*+ Valgrind Fix 29 Nov 2013 +*/
    RRM_MEMSET(p_out_updated_nrt_info_msg,RRM_ZERO,sizeof(rrmcm_rmif_updated_nrt_info_t));
    /*- Valgrind Fix 29 Nov 2013 -*/

    p_out_updated_nrt_info_msg->cellindex = p_mif_context->cell_index;
    p_out_updated_nrt_info_msg->transaction_id = p_mif_context->currently_processed_api_trans_d;

    rrm_memcpy_rrm_oam_eutran_global_cell_id(
            &(p_out_updated_nrt_info_msg->src_cgi),
            (rrm_oam_eutran_global_cell_id_t *)&(p_in_updated_nrt_info_msg->src_cgi)); 
    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "filling intra_rat_ncl_params_for_cellm from received updated_nrt" );
    rrm_fill_intra_rat_ncl_params_for_cellm(
            &(p_out_updated_nrt_info_msg->intra_rat_ncl),
            &p_in_updated_nrt_info_msg->intra_rat_ncl);

    p_out_updated_nrt_info_msg->inter_rat_ncl.bitmask = 
        p_in_updated_nrt_info_msg->inter_rat_ncl.bitmask;

    if(SON_RRM_UTRAN_NR_LIST_PRESENT & p_in_updated_nrt_info_msg->inter_rat_ncl.bitmask)
    {
        RRM_MEMCPY(&(p_out_updated_nrt_info_msg->inter_rat_ncl.utran_neighbor_list),
                &(p_in_updated_nrt_info_msg->inter_rat_ncl.utran_neighbor_list),
                sizeof(rrmcm_rmif_utran_neighbor_cell_list_t));
    }
    if(SON_RRM_GERAN_NR_LIST_PRESENT & p_in_updated_nrt_info_msg->inter_rat_ncl.bitmask)
    {
        /* SPR 15393 Fix Start */
        /*memcpy is replaced by populate function*/
        rrm_populate_geran_neighbour_list(p_out_updated_nrt_info_msg,p_in_updated_nrt_info_msg);
        /* SPR 15393 Fix Stop */
    }
    /* Start Bug Fix 786 */
    if(SON_RRM_CDMA_NR_LIST_XRTT_PRESENT & p_in_updated_nrt_info_msg->inter_rat_ncl.bitmask)
    {
        /*CID 66683:start*/
        p_out_updated_nrt_info_msg->inter_rat_ncl.bitmask |= RRMCM_RMIF_CDMA_NR_LIST_XRTT_PRESENT;
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                 cells_to_add_mod_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.cells_to_add_mod_list_size++;
            rrm_fill_cdma_neighbor_list_xrtt(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_xrtt.cells_to_add_mod_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                        cells_to_add_mod_list[count]) );
        }
        /*cells_to_remove_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                 cells_to_remove_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.cells_to_remove_list_size++;
            rrm_fill_cdma_neighbor_list_xrtt(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_xrtt.cells_to_remove_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                        cells_to_remove_list[count]) );

        }
        /*black_list_cells_to_add_mod_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                 black_list_cells_to_add_mod_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                black_list_cells_to_add_mod_list_size++ ;
            rrm_fill_cdma_neighbor_list_xrtt(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_xrtt.black_list_cells_to_add_mod_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                        black_list_cells_to_add_mod_list[count]) );

        }
        /*black_list_cells_to_remove_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                 black_list_cells_to_remove_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                black_list_cells_to_remove_list_size++;
            rrm_fill_cdma_neighbor_list_xrtt(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_xrtt.black_list_cells_to_remove_list[count]),
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_xrtt.\
                        black_list_cells_to_remove_list[count]) );

        }
        /*CID 66683:end*/
    }
    if(SON_RRM_CDMA_NR_LIST_HRPD_PRESENT & p_in_updated_nrt_info_msg->inter_rat_ncl.bitmask)
    {
        /*CID 66682:start*/
        p_out_updated_nrt_info_msg->inter_rat_ncl.bitmask |= RRMCM_RMIF_CDMA_NR_LIST_HRPD_PRESENT;
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                 cells_to_add_mod_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.cells_to_add_mod_list_size++ ;
            rrm_fill_cdma_neighbor_list_hrpd(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_hrpd.cells_to_add_mod_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                        cells_to_add_mod_list[count]) );
        }
        /*cells_to_remove_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                 cells_to_remove_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.\
                cdma_neighbor_list_hrpd.cells_to_remove_list_size++ ;
            rrm_fill_cdma_neighbor_list_hrpd(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_hrpd.cells_to_remove_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                        cells_to_remove_list[count]) );

        }
        /*black_list_cells_to_add_mod_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                 black_list_cells_to_add_mod_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.\
                cdma_neighbor_list_hrpd.black_list_cells_to_add_mod_list_size++ ;
            rrm_fill_cdma_neighbor_list_hrpd(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_hrpd.black_list_cells_to_add_mod_list[count]), 
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                        black_list_cells_to_add_mod_list[count]) );

        }
        /*black_list_cells_to_remove_list_size*/
        for (count = RRM_ZERO; 
                (count < p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                 black_list_cells_to_remove_list_size) && (count < RRM_SON_CDMA_MAX_NO_ARFCN ); 
                count ++)
        {
            p_out_updated_nrt_info_msg->inter_rat_ncl.\
                cdma_neighbor_list_hrpd.black_list_cells_to_remove_list_size++;
            rrm_fill_cdma_neighbor_list_hrpd(&(p_out_updated_nrt_info_msg->inter_rat_ncl.\
                        cdma_neighbor_list_hrpd.black_list_cells_to_remove_list[count]),
                    &(p_in_updated_nrt_info_msg->inter_rat_ncl.cdma_neighbor_list_hrpd.\
                        black_list_cells_to_remove_list[count]) );

        }
        /*CID 66682:end*/
    }
    /* SPR_17763_FIX_START */
    RRM_GETTIMEOFDAY(&(p_out_updated_nrt_info_msg->incoming_time_stamp),RRM_PNULL);
    /* SPR_17763_FIX_END */
    /* End Bug Fix 786 */
    if (RRM_SON_ANR_MODULE_ID == src)
    {
        /* Sending updated NRT Info to RRMCM */
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_UPDATED_NRT_INFO_FROM_ANR_REQ,
                (U16)(sizeof(rrmcm_rmif_updated_nrt_info_t)),
                (void *)p_out_updated_nrt_info_msg);
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Message received from Invalid Source(%d)", src);
    }
    RRM_MEM_FREE(p_out_updated_nrt_info_msg);

    RRM_UT_TRACE_EXIT();
}

/***************************************************************************
 * Function Name  : build_and_send_release_all_existing_ue_forcefully_req
 * Inputs         : Cell Index, Transaction Id
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This API build and send all ue active release ind to UEM.
 ***************************************************************************/


    void build_and_send_release_all_existing_ue_forcefully_req
(   rrm_cell_index_t cell_index, 
    U16  trans_id
    )
{

    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_release_all_existing_ue_forcefully_req_t *rrmuem_rmif_release_all_existing_ue_forcefully_req = RRM_PNULL;
    rrmuem_rmif_release_all_existing_ue_forcefully_req =(rrmuem_rmif_release_all_existing_ue_forcefully_req_t *)
        rrm_mem_get(sizeof(rrmuem_rmif_release_all_existing_ue_forcefully_req_t));

    if ( rrmuem_rmif_release_all_existing_ue_forcefully_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to rrmuem_rmif_release_all_existing_ue_forcefully_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    rrmuem_rmif_release_all_existing_ue_forcefully_req->cell_index = cell_index;
    rrmuem_rmif_release_all_existing_ue_forcefully_req->transaction_id = trans_id;

    rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
            RRMUEM_RMIF_RELEASE_ALL_EXISTING_UE_FORCEFULLY_REQ,
            sizeof(rrmuem_rmif_release_all_existing_ue_forcefully_req_t),
            (void *)rrmuem_rmif_release_all_existing_ue_forcefully_req);
    RRM_MEM_FREE(rrmuem_rmif_release_all_existing_ue_forcefully_req);
    RRM_UT_TRACE_EXIT();
}

/***************************************************************************
 * Function Name  : build_and_send_non_emrgncy_active_calls_ho_req
 * Inputs         : Cell Index, Transaction Id
 *
 * Outputs        : None
 * Returns        : Void
 * Description    : This API builds and sends HO_REQ to UEM for all non-emergncy active calls.
 ***************************************************************************/


    void build_and_send_non_emrgncy_active_calls_ho_req
(   rrm_cell_index_t cell_index,
    U16  trans_id
    )
{
    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_non_emrgncy_active_calls_ho_req_t *rrmuem_rmif_non_emrgncy_active_calls_ho_req = RRM_PNULL;
    rrmuem_rmif_non_emrgncy_active_calls_ho_req =(rrmuem_rmif_non_emrgncy_active_calls_ho_req_t *)
        rrm_mem_get(sizeof(rrmuem_rmif_non_emrgncy_active_calls_ho_req_t));

    if ( rrmuem_rmif_non_emrgncy_active_calls_ho_req == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_ERROR,
                "Memory allocation to rrmuem_rmif_non_emrgncy_active_calls_ho_req failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }

    rrmuem_rmif_non_emrgncy_active_calls_ho_req->cell_index = cell_index;
    rrmuem_rmif_non_emrgncy_active_calls_ho_req->transaction_id = trans_id;

    rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
            RRMUEM_RMIF_NON_EMRGNCY_ACTIVE_CALLS_HO_REQ,
            sizeof(rrmuem_rmif_release_all_existing_ue_forcefully_req_t),
            (void *)rrmuem_rmif_non_emrgncy_active_calls_ho_req);
    RRM_MEM_FREE(rrmuem_rmif_non_emrgncy_active_calls_ho_req);
    RRM_UT_TRACE_EXIT();
}

/* SPR 20653 Fix Start */
/* Code Removed */
/* SPR 20653 Fix End */
/* UPDATED NRT INFO CHANGES END */

rrm_return_et
    rrm_mif_fill_ld_ac_barring_info
(
 rrm_oam_access_class_barring_information_t *p_ld_ssac_bar_info_in,
 rrm_access_class_barring_info_t *p_ld_ssac_bar_info_out,
 rrm_error_et *p_fail_cause
 )
{
    rrm_return_et ret_val = RRM_SUCCESS;
    RRM_UT_TRACE_ENTER();
    RRM_ASSERT(RRM_PNULL != p_ld_ssac_bar_info_in);
    RRM_ASSERT(RRM_PNULL != p_ld_ssac_bar_info_out);
    if (((RRM_NULL != p_ld_ssac_bar_info_in->ac_barring_for_special_ac) && 
                ((p_ld_ssac_bar_info_in->ac_barring_for_special_ac & RRM_SEVEN) ||
                 (RRM_NULL != p_ld_ssac_bar_info_in->ac_barring_factor))))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,    
                "LTE RRM shall expect to have non zero value for ac-BarringFactor\
                incase ac-BarringForSpecialAC is zero OR Invalid Value (%d) of ac-BarringForSpecialAC\
                received in cell load config req: Only left most 5 bit should be set/unset",\
                p_ld_ssac_bar_info_in->ac_barring_for_special_ac);
        *p_fail_cause = RRM_ERR_INVALID_PARAMS;
        ret_val = RRM_FAILURE;
    }
    else
    {

        /* coverity : CID 29713 */
        p_ld_ssac_bar_info_out->ac_barring_factor = (rrm_mif_ac_barring_factor_et) p_ld_ssac_bar_info_in->ac_barring_factor;
        /* coverity : CID 29714 */
        p_ld_ssac_bar_info_out->ac_barring_time = (rrm_mif_ac_barring_time_et) p_ld_ssac_bar_info_in->ac_barring_time;
        p_ld_ssac_bar_info_out->ac_barring_for_special_ac = p_ld_ssac_bar_info_in->ac_barring_for_special_ac;
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

    rrm_return_et
fill_load_action_params(
        rrmcm_rmif_action_t *out_load_level_action, 
        rrm_oam_load_def_t in_load_level_action,
        rrm_error_et *p_fail_cause)
{
    U8            abs_pattern_index = RRM_ZERO;
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    out_load_level_action->bitmask = RRM_ZERO;

    if(RRM_OAM_PERCNTG_PRESENT & in_load_level_action.bitmask)
    {
        out_load_level_action->bitmask |= RRMCM_RMIF_PERCNTG_PRESENT;
        out_load_level_action->load_perctg = in_load_level_action.load_perctg;
    }

    /* Bug_8718_start */
    if((RRM_OAM_STOP_ADM_INFO_PRESENT & in_load_level_action.bitmask) && 
            (RRM_OAM_SOFT_LIMIT_PRESENT & in_load_level_action.stop_adm_info.bitmask))
    {
        out_load_level_action->bitmask |= RRMCM_RMIF_STOP_ADM_INFO_PRESENT;
        out_load_level_action->stop_adm_info.bitmask |= RRMCM_RMIF_SOFT_LIMIT_PRESENT;
        out_load_level_action->stop_adm_info.soft_limit = in_load_level_action.stop_adm_info.soft_limit;
    }
    /* Bug_8718_end */

    if(RRM_OAM_ACTION_PRESENT & in_load_level_action.bitmask)
    {
        out_load_level_action->bitmask |= RRMCM_RMIF_ACTION_PRESENT;
        out_load_level_action->action = in_load_level_action.action;
        if (RRMCM_ACTN_AQM & in_load_level_action.action) 
        {
            if (RRM_OAM_Q_WATERMARK_PRESENT !=
                    (RRM_OAM_Q_WATERMARK_PRESENT & in_load_level_action.bitmask))
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                        "Action AQM: Watermark is not Present!!");
                *p_fail_cause =  RRM_ERR_MANDATORY_PARAMS_ABSENT;
                ret_val = RRM_FAILURE; 
                RRM_UT_TRACE_EXIT();
                return ret_val;
            }
            else
            {
                /* Fixed by renuka*/
                if (in_load_level_action.q_watermark.low_watermark > in_load_level_action.q_watermark.high_watermark)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                            "With Action  AQM Low Watermark (%u) is greater than (%u) High watermark",
                            in_load_level_action.q_watermark.low_watermark, in_load_level_action.q_watermark.high_watermark);
                    *p_fail_cause = RRM_ERR_INVALID_PARAMS;
                    ret_val = RRM_FAILURE;
                    RRM_UT_TRACE_EXIT();
                    return ret_val;
                }
                else
                {
                    out_load_level_action->bitmask |= RRMCM_RMIF_Q_WATERMARK_PRESENT;
                    out_load_level_action->q_watermark.high_watermark = in_load_level_action.q_watermark.high_watermark;
                    out_load_level_action->q_watermark.low_watermark = in_load_level_action.q_watermark.low_watermark;
                }
            }
        }
        if (in_load_level_action.action & RRMCM_ACTN_AC_BARRING)
        {
            if (in_load_level_action.bitmask & RRM_OAM_LD_AC_BARRING_PRESENT)
            {
                out_load_level_action->bitmask |= RRMCM_RMIF_LD_AC_BARRING_PRESENT;
                if (RRM_ZERO == in_load_level_action.ld_ac_bar.bitmask)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "No AC Barring Info present while AC Barring action is applied");
                    *p_fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                    ret_val = RRM_FAILURE;
                }
                else
                {
                    if (in_load_level_action.ld_ac_bar.bitmask & RRM_OAM_AC_BARRING_MO_SIGNALLING_PRESENT)
                    {
                        out_load_level_action->ld_ac_bar.bitmask |= RRMCM_RMIF_AC_BARRING_MO_SIGNALLING_PRESENT;
                        ret_val = rrm_mif_fill_ld_ac_barring_info (&in_load_level_action.ld_ac_bar.ac_barring_for_mo_signalling,
                                &out_load_level_action->ld_ac_bar.ac_barring_for_mo_signalling, p_fail_cause);
                    }
                    if ((RRM_SUCCESS == ret_val) && (in_load_level_action.ld_ac_bar.bitmask & RRM_OAM_AC_BARRING_MO_DATA_PRESENT))
                    {
                        out_load_level_action->ld_ac_bar.bitmask |= RRMCM_RMIF_AC_BARRING_MO_DATA_PRESENT; 
                        ret_val = rrm_mif_fill_ld_ac_barring_info (&in_load_level_action.ld_ac_bar.ac_barring_for_mo_data,
                                &out_load_level_action->ld_ac_bar.ac_barring_for_mo_data, p_fail_cause);
                    }
                    if ((RRM_SUCCESS == ret_val) && (in_load_level_action.ld_ac_bar.bitmask & RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT))
                    {
                        out_load_level_action->ld_ac_bar.bitmask |= RRM_OAM_SSAC_BARRING_FOR_MMTEL_PRESENT;
                        if (!((RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT & in_load_level_action.ld_ac_bar.ssac_barring_r9.bitmask) || 
                                    (RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT & in_load_level_action.ld_ac_bar.ssac_barring_r9.bitmask)))
                        {
                            *p_fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                            ret_val = RRM_FAILURE;
                            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                                    "MLB: MMTEL Voice/Video Must be present when MMTEL flag is true");
                        }
                        else
                        {
                            if (RRM_OAM_SSAC_BARRING_MMTEL_VOICE_R9_PRESENT & in_load_level_action.ld_ac_bar.ssac_barring_r9.bitmask)
                            {
                                out_load_level_action->ld_ac_bar.ssac_barring_r9.bitmask |= RRMCM_RMIF_SSAC_BARRING_MMTEL_VOICE_PRESENT;
                                ret_val = rrm_mif_fill_ld_ac_barring_info (&in_load_level_action.ld_ac_bar.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9,
                                        &out_load_level_action->ld_ac_bar.ssac_barring_r9.ssac_barring_for_mmtel_voice_r9, p_fail_cause);
                            }
                            if ((RRM_SUCCESS == ret_val) && (RRM_OAM_SSAC_BARRING_MMTEL_VIDEO_R9_PRESENT & in_load_level_action.ld_ac_bar.ssac_barring_r9.bitmask))
                            {
                                out_load_level_action->ld_ac_bar.ssac_barring_r9.bitmask |= RRMCM_RMIF_SSAC_BARRING_MMTEL_VIDEO_PRESENT;
                                ret_val = rrm_mif_fill_ld_ac_barring_info (&in_load_level_action.ld_ac_bar.ssac_barring_r9.ssac_barring_for_mmtel_video_r9,
                                        &out_load_level_action->ld_ac_bar.ssac_barring_r9.ssac_barring_for_mmtel_video_r9, p_fail_cause);
                            }
                        }
                    }
                }
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "AC Barring Info is not present while AC Barring action is applied");
                *p_fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                ret_val = RRM_FAILURE;
            }
            if (RRM_FAILURE == ret_val)
            {
                RRM_UT_TRACE_EXIT();
                return ret_val; 
            }
        }
        switch (in_load_level_action.action)
        {
            case RRMCM_ACTN_NONE:
            case RRMCM_ACTN_STOP_ADM:
            case RRMCM_ACTN_AQM:
            case RRMCM_ACTN_AC_BARRING:
                {
                    ret_val = RRM_SUCCESS;
                    break;
                }
            default:
                {
                    if (RRMCM_RMIF_NUM_USR_PRESENT !=
                            (RRMCM_RMIF_NUM_USR_PRESENT & in_load_level_action.bitmask))
                    {
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "With Action HO,Rel UE,ECN, and scell deact Num of User is Mandatory");
                        *p_fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT;
                        ret_val = RRM_FAILURE;
                    }
                    else
                    {
                        out_load_level_action->bitmask |= RRMCM_RMIF_NUM_USR_PRESENT;
                        out_load_level_action->num_usr = in_load_level_action.num_usr;
                    }
                    break;
                }
        }
    }
    /* Bug_944_start */
    if ((RRM_FAILURE != ret_val) && (RRM_OAM_REDIRECT_INFO_PRESENT & in_load_level_action.bitmask))
    {
        out_load_level_action->bitmask |= RRMCM_RMIF_REDIRECT_INFO_PRESENT;
        if (RRM_OAM_MEAS_BASED_RWR_PRESENT & in_load_level_action.redirect_info.bitmask)
        {
            out_load_level_action->mard_info.bitmask |= RRMCM_RMIF_MARD_PRESENT;
            out_load_level_action->mard_info.mard_present = 
                in_load_level_action.redirect_info.is_meas_based_rwr;
        }
        if (RRM_OAM_RWR_TIMER_PRESENT & in_load_level_action.redirect_info.bitmask)
        {
            out_load_level_action->mard_info.bitmask |= RRMCM_RMIF_MEAS_BASED_RWR_TIMER_PRESENT;
            out_load_level_action->mard_info.rwr_timer = 
                in_load_level_action.redirect_info.rwr_timer;
        }
        /* Checking if timer is present then meas based  redirect should be present */
        if ((RRMCM_RMIF_MEAS_BASED_RWR_TIMER_PRESENT & out_load_level_action->mard_info.bitmask) &&
                (RRM_ZERO == out_load_level_action->mard_info.mard_present))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "if rwr timer is present then  meas based redirect should be present");
            *p_fail_cause = RRM_ERR_MANDATORY_PARAMS_ABSENT;
            ret_val = RRM_FAILURE;

        }

    }
    /** eICIC feature changes start */
    if(RRM_OAM_EICIC_LOAD_CONFIG_PRESENT & in_load_level_action.bitmask)
    {
        out_load_level_action->bitmask |= RRMCM_RMIF_EICIC_LOAD_CONFIG_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "eICIC load config params are present");

        if(RRM_OAM_ELIGIBLE_UE_PRESENT & in_load_level_action.eicic_load_config.bitmask)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "eICIC load config ue eligibility is present");
            out_load_level_action->eicic_load_config.eligible_ue = 
                in_load_level_action.eicic_load_config.eligible_ue; 
            out_load_level_action->eicic_load_config.bitmask |= 
                RRMCM_RMIF_ELIGIBLE_UE_PRESENT; 
        }    
        if( RRM_OAM_ABS_PATTERN_PRESENT & in_load_level_action.eicic_load_config.bitmask)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "eICIC load config abs pattern is present");
            for (abs_pattern_index = RRM_ZERO;
                    abs_pattern_index <RRM_MAX_PATTERN_BYTE;
                    abs_pattern_index++)
            {
                out_load_level_action->eicic_load_config.abs_pattern[abs_pattern_index] 
                    = in_load_level_action.eicic_load_config.abs_pattern[abs_pattern_index];     
            }
            out_load_level_action->eicic_load_config.bitmask |= RRMCM_RMIF_ABS_PATTERN_PRESENT;
        }    
    }
    /** eICIC feature changes end */
    /* Bug_944_end */
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_admitted_csg_user
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_admitted_csg_user param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_admitted_csg_user(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_admitted_csg_user = p_stored_kpi->num_of_admitted_csg_user;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_admitted_csg_user[%u]",p_stored_kpi->num_of_admitted_csg_user);   
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_admitted_non_csg_user
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_admitted_non_csg_user param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_admitted_non_csg_user(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_admitted_non_csg_user= p_stored_kpi->num_of_admitted_non_csg_user;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_admitted_non_csg_user[%u]",p_stored_kpi->num_of_admitted_non_csg_user);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_ue_admission_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_ue_admission_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_ue_admission_success(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_ue_admission_success= p_stored_kpi->num_of_ue_admission_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_ue_admission_success [%u]",p_stored_kpi->num_of_ue_admission_success);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_ue_admission_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_ue_admission_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_ue_admission_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_ue_admission_fail = p_stored_kpi->num_of_ue_admission_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_ue_admission_fail[%u]",p_stored_kpi->num_of_ue_admission_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_setup_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_setup_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_setup_success(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_setup_success = p_stored_kpi->num_of_erb_setup_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_setup_success[%u]",p_stored_kpi->num_of_erb_setup_success);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_setup_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_setup_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_setup_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_setup_fail = p_stored_kpi->num_of_erb_setup_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_setup_fail[%u]",p_stored_kpi->num_of_erb_setup_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_modify_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_modify_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_modify_success(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_modify_success = p_stored_kpi->num_of_erb_modify_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_modify_success[%u]",p_stored_kpi->num_of_erb_modify_success);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_modify_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_modify_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_modify_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_modify_fail = p_stored_kpi->num_of_erb_modify_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_modify_fail[%u]",p_stored_kpi->num_of_erb_modify_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_release_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_release_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_release_success(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_release_success = p_stored_kpi->num_of_erb_release_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_release_success[%u]",p_stored_kpi->num_of_erb_release_success);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_erb_release_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_erb_release_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_erb_release_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_erb_release_fail = p_stored_kpi->num_of_erb_release_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_erb_release_fail[%u]",p_stored_kpi->num_of_erb_release_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_avg_dl_allocated_gbr_prb
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store avg_dl_allocated_gbr_prb param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_avg_dl_allocated_gbr_prb(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->avg_dl_allocated_gbr_prb = p_stored_kpi->avg_dl_allocated_gbr_prb;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "avg_dl_allocated_gbr_prb[%u]",p_stored_kpi->avg_dl_allocated_gbr_prb);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_avg_ul_allocated_gbr_prb
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store avg_ul_allocated_gbr_prb param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_avg_ul_allocated_gbr_prb(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->avg_ul_allocated_gbr_prb = p_stored_kpi->avg_ul_allocated_gbr_prb;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "avg_ul_allocated_gbr_prb[%u]",p_stored_kpi->avg_ul_allocated_gbr_prb);
    RRM_UT_TRACE_EXIT();

}

/****************************************************************************
 * Function Name : rrm_oam_updt_dl_allocated_ngbr_prb
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store avg_dl_allocated_ngbr_prb param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_dl_allocated_ngbr_prb(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->dl_allocated_ngbr_prb = p_stored_kpi->avg_dl_allocated_ngbr_prb;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "avg_dl_allocated_ngbr_prb[%u]",p_stored_kpi->avg_dl_allocated_ngbr_prb);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_ul_allocated_ngbr_prb
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store avg_ul_allocated_ngbr_prb param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_ul_allocated_ngbr_prb(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->ul_allocated_ngbr_prb= p_stored_kpi->avg_ul_allocated_ngbr_prb;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "avg_ul_allocated_ngbr_prb[%u]",p_stored_kpi->avg_ul_allocated_ngbr_prb);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_geran_ho_attempt
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_geran_ho_attempt param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_geran_ho_attempt(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_geran_ho_attempt = p_stored_kpi->num_of_geran_ho_attempt;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_geran_ho_attempt[%u]",p_stored_kpi->num_of_geran_ho_attempt);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_geran_ho_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_geran_ho_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_geran_ho_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_geran_ho_fail = p_stored_kpi->num_of_geran_ho_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_geran_ho_fail[%u]",p_stored_kpi->num_of_geran_ho_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_utran_ho_attempt
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_utran_ho_attempt param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_utran_ho_attempt(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_utran_ho_attempt = p_stored_kpi->num_of_utran_ho_attempt;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_utran_ho_attempt[%u]",p_stored_kpi->num_of_utran_ho_attempt);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_utran_ho_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_utran_ho_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_utran_ho_fail(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_utran_ho_fail = p_stored_kpi->num_of_utran_ho_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_utran_ho_fail[%u]",p_stored_kpi->num_of_utran_ho_fail);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_eutran_ho_attempt
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_eutran_ho_attempt param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_eutran_ho_attempt(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_eutran_ho_attempt= p_stored_kpi->num_of_eutran_ho_attempt;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_eutran_ho_attempt[%u]",p_stored_kpi->num_of_eutran_ho_attempt);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_eutran_ho_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_eutran_ho_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_eutran_ho_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_eutran_ho_fail = p_stored_kpi->num_of_eutran_ho_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_eutran_ho_fail[%u]",p_stored_kpi->num_of_eutran_ho_fail);
    RRM_UT_TRACE_EXIT();

}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_geran_hi_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_geran_hi_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_geran_hi_success(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_geran_hi_success = p_stored_kpi->num_of_geran_hi_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_geran_hi_success[%u]",p_stored_kpi->num_of_geran_hi_success);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_geran_hi_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_geran_hi_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_geran_hi_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_geran_hi_fail = p_stored_kpi->num_of_geran_hi_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_utran_hi_success[%u]",p_stored_kpi->num_of_utran_hi_success);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_utran_hi_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_utran_hi_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_utran_hi_success(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_utran_hi_success = p_stored_kpi->num_of_utran_hi_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_utran_hi_success[%u]",p_stored_kpi->num_of_utran_hi_success);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_utran_hi_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_utran_hi_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_utran_hi_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_utran_hi_fail = p_stored_kpi->num_of_utran_hi_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_utran_hi_fail[%u]",p_stored_kpi->num_of_utran_hi_fail);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_eutran_hi_success
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_eutran_hi_success param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_eutran_hi_success(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_eutran_hi_success = p_stored_kpi->num_of_eutran_hi_success;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_eutran_hi_success[%u]",p_stored_kpi->num_of_eutran_hi_success);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_eutran_hi_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_eutran_hi_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_eutran_hi_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_eutran_hi_fail = p_stored_kpi->num_of_eutran_hi_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_eutran_hi_fail[%u]",p_stored_kpi->num_of_eutran_hi_fail);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_enb_init_ho_csg_usr
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_enb_init_ho_csg_usr param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_enb_init_ho_csg_usr(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_enb_init_ho_csg_usr = p_stored_kpi->num_of_enb_init_ho_csg_usr;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_enb_init_ho_csg_usr[%u]",p_stored_kpi->num_of_enb_init_ho_csg_usr);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_enb_init_ho_non_csg_usr
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_enb_init_ho_non_csg_usr param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_enb_init_ho_non_csg_usr(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_enb_init_ho_non_csg_usr = p_stored_kpi->num_of_enb_init_ho_non_csg_usr;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_enb_init_ho_non_csg_usr[%u]",p_stored_kpi->num_of_enb_init_ho_non_csg_usr);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_enb_init_ue_release
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_enb_init_ue_release param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_enb_init_ue_release(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_enb_init_ue_release = p_stored_kpi->num_of_enb_init_ue_release;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_enb_init_ue_release[%u]",p_stored_kpi->num_of_enb_init_ue_release);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_pucch_res_alloc_attempts
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_pucch_res_alloc_attempts param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_pucch_res_alloc_attempts(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_pucch_res_alloc_attempts = p_stored_kpi->num_pucch_res_alloc_attempts;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_pucch_res_alloc_attempts[%u]",p_stored_kpi->num_pucch_res_alloc_attempts);
    RRM_UT_TRACE_EXIT();
}
/*CA STAGE 2*/
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_ca_ue
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_ca_ue param received
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_ca_ue(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_ca_ue = p_stored_kpi->num_of_ca_ue;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_ca_ue[%u]",p_stored_kpi->num_of_ca_ue);
    RRM_UT_TRACE_EXIT();
}
/*CA STAGE 2*/
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_sr_res_alloc_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_sr_res_alloc_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_sr_res_alloc_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_sr_res_alloc_fail = p_stored_kpi->num_of_sr_res_alloc_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_sr_res_alloc_fail[%u]",p_stored_kpi->num_of_sr_res_alloc_fail);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name : rrm_oam_updt_num_of_sr_cqi_alloc_fail
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store num_of_sr_cqi_alloc_fail param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_num_of_sr_cqi_alloc_fail(rrmcm_kpi_data_t *p_stored_kpi, 
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->num_of_sr_cqi_alloc_fail = p_stored_kpi->num_of_sr_cqi_alloc_fail;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "num_of_sr_res_alloc_fail[%u]",p_stored_kpi->num_of_sr_res_alloc_fail);
    RRM_UT_TRACE_EXIT();
}
/* BUG_857 start*/
/****************************************************************************
 * Function Name : rrm_oam_updt_cell_unavailable_time
 * Inputs        : p_stored_kpi -Its Not NULL pointer
 *                 p_out_kpi_data - Its Null Pointer      
 * Outputs       : None
 * Return        : Void
 * Description   : This function store cell_unavailable_time param received 
 *                 from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_updt_cell_unavailable_time(rrmcm_kpi_data_t *p_stored_kpi,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    RRM_UT_TRACE_ENTER();
    p_out_kpi_data->total_cell_unavailable_time = p_stored_kpi->cell_unavailable_time;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "cell_unavailable_time[%u]",p_stored_kpi->cell_unavailable_time);
    RRM_UT_TRACE_EXIT();
}
/* BUG_857 end*/
/****************************************************************************
 * Function Name : rrm_oam_map_bit
 * Inputs        : - p_kpi_from_cellm - Its not Null pointer
 *                 - p_kpi_stat   - Its not Null Pointer
 *                 - reset      
 * Outputs       : None
 * Return        : Void
 * Description   : This function map the kpi param received from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_oam_bitmap_func_ptr rrm_oam_map_bit[RRM_MAX_KPI][RRM_EIGHT] = 
{
    {
        rrm_oam_updt_num_of_admitted_csg_user,
        rrm_oam_updt_num_of_admitted_non_csg_user,
        rrm_oam_updt_num_of_ue_admission_success,
        rrm_oam_updt_num_of_ue_admission_fail,
        rrm_oam_updt_num_of_erb_setup_success,
        rrm_oam_updt_num_of_erb_setup_fail,
        rrm_oam_updt_num_of_erb_modify_success,
        rrm_oam_updt_num_of_erb_modify_fail
    },
    {
        rrm_oam_updt_num_of_erb_release_success,
        rrm_oam_updt_num_of_erb_release_fail,
        rrm_oam_updt_avg_dl_allocated_gbr_prb,
        rrm_oam_updt_avg_ul_allocated_gbr_prb,
        rrm_oam_updt_dl_allocated_ngbr_prb,
        rrm_oam_updt_ul_allocated_ngbr_prb,
        rrm_oam_updt_num_of_geran_ho_attempt,
        rrm_oam_updt_num_of_geran_ho_fail
    },
    {
        rrm_oam_updt_num_of_utran_ho_attempt,
        rrm_oam_updt_num_of_utran_ho_fail,
        rrm_oam_updt_num_of_eutran_ho_attempt,
        rrm_oam_updt_num_of_eutran_ho_fail,
        rrm_oam_updt_num_of_geran_hi_success,
        rrm_oam_updt_num_of_geran_hi_fail,
        rrm_oam_updt_num_of_utran_hi_success,
        rrm_oam_updt_num_of_utran_hi_fail
    },
    {
        rrm_oam_updt_num_of_eutran_hi_success,
        rrm_oam_updt_num_of_eutran_hi_fail,
        rrm_oam_updt_num_of_enb_init_ho_csg_usr,
        rrm_oam_updt_num_of_enb_init_ho_non_csg_usr,
        rrm_oam_updt_num_of_enb_init_ue_release,
        rrm_oam_updt_num_pucch_res_alloc_attempts,
        rrm_oam_updt_num_of_sr_res_alloc_fail,
        rrm_oam_updt_num_of_sr_cqi_alloc_fail
    }, 
    /* BUG_857 start*/
    {
        rrm_oam_updt_cell_unavailable_time,
        rrm_oam_updt_num_of_ca_ue,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL,
        RRM_PNULL
    }
    /* BUG_857 end*/
};
/****************************************************************************
 * Function Name : rrm_oam_mapping_kpi_bit
 * Inputs        : - p_kpi_from_cellm - Its not Null pointer
 *                 - p_kpi_stat   - Its not Null Pointer
 *                 - reset      
 * Outputs       : None
 * Return        : Void
 * Description   : This function map the kpi param received from cellm to oam
 *                 depending upon the value of bitmask
 ****************************************************************************/
rrm_void_t rrm_oam_mapping_kpi_bit(
        rrmcm_kpi_data_t *p_kpi_from_cellm,
        rrm_oam_kpi_data_t *p_out_kpi_data)
{
    U8 index = RRM_ZERO;
    U8 kpi_val = RRM_ZERO;
    U8 kpi_bit = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    for(index = RRM_ZERO; index<RRM_MAX_KPI;index++)
    {
        if(RRM_ZERO != p_kpi_from_cellm->kpi_bit.bitmap[index])
        {
            kpi_val = p_kpi_from_cellm->kpi_bit.bitmap[index];
            kpi_bit = RRM_ZERO;
            while(RRM_ZERO != kpi_val)
            {
                if(kpi_val & RRM_ONE)
                {
                    rrm_oam_map_bit[index][kpi_bit](p_kpi_from_cellm,p_out_kpi_data);
                }

                kpi_val = kpi_val>>RRM_ONE;
                ++kpi_bit;
            }
        }	
    }     

    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  : map_p_kpi_from_cellm
 * Inputs         : -p_kpi_from_cellm - It's not null pointer.
 *                  -p_kpi_stat  - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function map kpi param received from cellm for OAM
 ****************************************************************************/
rrm_void_t map_kpi_from_cellm( rrmcm_kpi_data_t *p_kpi_from_cellm,
        rrm_oam_kpi_data_t *p_kpi_stat)
{
    RRM_UT_TRACE_ENTER();
    p_kpi_stat->kpi_to_report = p_kpi_from_cellm->kpi_bit;
    rrm_oam_mapping_kpi_bit(p_kpi_from_cellm,p_kpi_stat);
    RRM_UT_TRACE_EXIT();
}

/* RACH_OPTIMIZATION_CHANGES_START */
/****************************************************************************
 * Function Name  : build_and_send_rach_report_to_son
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_kpi_ind  - transaction id.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares and send KPI Indication to OAM
 ****************************************************************************/
    void 
build_and_send_rach_report_to_son(
        rrm_mif_gb_context_t        *p_gl_ctxt,
        rrm_mif_context             *p_mif_context,
        rrmcm_rmif_rach_l2_report_t *p_rach_l2_report
        )
{
    rrm_son_l2_rach_perf_report_t     out_rach_l2_report_to_son;
    rrm_return_et                     ret_val = RRM_SUCCESS;
    U8                                index = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    out_rach_l2_report_to_son.num_of_l2_perf_accumulated_reports =
        p_rach_l2_report->num_of_l2_perf_accumulated_reports;
    out_rach_l2_report_to_son.total_rcvd_msg3_random_access_preambles_cbra =
        p_rach_l2_report->total_rcvd_msg3_random_access_preambles_cbra;
    out_rach_l2_report_to_son.total_rcvd_msg3_random_access_preambles_cfra = 
        p_rach_l2_report->total_rcvd_msg3_random_access_preambles_cfra;
    out_rach_l2_report_to_son.total_failed_random_access_preambles_msg2_cbra =
        p_rach_l2_report->total_failed_random_access_preambles_msg2_cbra;
    out_rach_l2_report_to_son.total_failed_random_access_preambles_msg2_cfra =
        p_rach_l2_report->total_failed_random_access_preambles_msg2_cfra;
    out_rach_l2_report_to_son.total_allocated_random_access_preambles =
        p_rach_l2_report->total_allocated_random_access_preambles;
    out_rach_l2_report_to_son.total_unassigned_false_cfra =
        p_rach_l2_report->total_unassigned_false_cfra;
    out_rach_l2_report_to_son.total_unassigned_sum_cfra =
        p_rach_l2_report->total_unassigned_sum_cfra;
    /* SPR-18438 START */
    out_rach_l2_report_to_son.num_random_access_preambles_group_a = 
        p_rach_l2_report->num_random_access_preambles_group_a;
    out_rach_l2_report_to_son.num_random_access_preambles_group_b = 
        p_rach_l2_report->num_random_access_preambles_group_b;
    /* SPR-18438 END */

    for(index = RRM_ZERO; index < MAX_TA_RANGE; index++)
    {
        out_rach_l2_report_to_son.total_succ_random_access_ta[index] =
            p_rach_l2_report->total_succ_random_access_ta[index];
    }

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(out_rach_l2_report_to_son.cell_id),
            p_mif_context->cell_index);
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "L2 rach report recvd from cell id[%d]",p_mif_context->cell_index); 
    }
    else
    {
        rrm_son_send_rrm_son_l2_rach_perf_report( 
                &out_rach_l2_report_to_son,
                RRM_MIF_MODULE_ID,
                RRM_SON_RACH_OPT_MODULE_ID,
                RRM_ZERO,
                p_mif_context->cell_index);
    }
    RRM_UT_TRACE_EXIT();
}
/* RACH_OPTIMIZATION_CHANGES_END */
/****************************************************************************
 * Function Name  : build_and_send_kpi_ind_to_oam
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_kpi_ind  - transaction id.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares and send KPI Indication to OAM
 ****************************************************************************/
void build_and_send_kpi_ind_to_oam (
        rrm_mif_gb_context_t        *p_gl_ctxt,
        rrm_mif_context *p_mif_context,
        rrmcm_kpi_ind_t *p_kpi_ind
        )
{
    rrm_oam_kpi_ind_t     out_kpi_ind_to_oam;
    rrm_return_et         ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    map_kpi_from_cellm(&(p_kpi_ind->kpi_data),&(out_kpi_ind_to_oam.kpi_data));   

    ret_val = copy_global_cell_id_from_ctxt(p_gl_ctxt,
            &(out_kpi_ind_to_oam.cell_id),
            p_mif_context->cell_index);
    if(RRM_FAILURE == ret_val)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                "Kpi Indication recvd from cell id[%d]",p_mif_context->cell_index); 
    }
    else
    {
        rrm_oam_send_rrm_oam_kpi_ind(
                &out_kpi_ind_to_oam,
                RRM_MIF_MODULE_ID,
                RRM_OAM_MODULE_ID,
                RRM_ZERO/*trans_id*/,
                p_mif_context->cell_index);
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :build_and_send_get_kpi_request_to_cellm 
 * Inputs         : -p_rrm_oam_get_kpi_req - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -trans_id - transaction id.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares and send Get KPI Request to CellM
 ****************************************************************************/
rrm_void_t build_and_send_get_kpi_request_to_cellm(
        rrm_oam_get_kpi_req_t *p_rrm_oam_get_kpi_req,
        rrm_mif_context *p_mif_context)
{
    rrmcm_rmif_get_kpi_req_t out_get_kpi_ind = {RRM_ZERO};
    rrm_return_et            ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    out_get_kpi_ind.cell_index= p_mif_context->cell_index;
    out_get_kpi_ind.trans_id= p_mif_context->currently_processed_api_trans_d;
    /* coverity : CID 31032 */
    out_get_kpi_ind.reset= (rrm_bool_et)p_rrm_oam_get_kpi_req->reset;
    out_get_kpi_ind.kpi_to_report= p_rrm_oam_get_kpi_req->kpi_to_report;

    /*Sending message to cellm*/
    ret_val = rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_GET_KPI_REQ,
            sizeof(rrmcm_rmif_get_kpi_req_t),
            (void *)&out_get_kpi_ind);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
            "MIF %s in sending get kpi req for cell id[%d]",
            (ret_val==RRM_SUCCESS? "successful":"unsuccessful"), p_mif_context->cell_index);
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :build_and_send_kpi_config_req_to_cellm
 * Inputs         : -p_in_oam_config_kpi_req - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -trans_id - transaction id.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares and send KPI Config Request to CellM
 ****************************************************************************/
rrm_void_t build_and_send_kpi_config_req_to_cellm(
        rrm_oam_config_kpi_req_t *p_in_oam_config_kpi_req,
        rrm_mif_context          *p_mif_context)
{
    rrmcm_rmif_kpi_config_req_t  out_config_kpi_req ={RRM_ZERO};  
    rrm_return_et                ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();
    /*Fill message to be send to Cellm*/
    if (p_in_oam_config_kpi_req->bitmask & RRM_OAM_CONFIG_KPI_DURATION_PRESENT)
    {
        out_config_kpi_req.duration = p_in_oam_config_kpi_req->duration;
        out_config_kpi_req.bitmask |= RRMCM_KPI_CONFIG_DURATION_PRESENT; 
    }
    out_config_kpi_req.cell_index = p_mif_context->cell_index;
    out_config_kpi_req.trans_id = p_mif_context->currently_processed_api_trans_d;
    out_config_kpi_req.periodic_reporting = p_in_oam_config_kpi_req->periodic_reporting;
    out_config_kpi_req.kpi_to_report = p_in_oam_config_kpi_req->kpi_to_report;

    /*Sending message to cellm*/
    ret_val = rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_CONFIG_KPI_REQ,
            sizeof(rrmcm_rmif_kpi_config_req_t),
            (void *)&out_config_kpi_req);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
            "MIF %s in sending config kpi req for cell id[%d]",
            (ret_val==RRM_SUCCESS? "successful":"unsuccessful"),p_mif_context->cell_index);

    RRM_UT_TRACE_EXIT();
}

/* Coverity_ID : 54439 start */
/****************************************************************************
 * Function Name  : rrm_map_resrc_type
 * Inputs         : U32 rrm_resrc_type.
 * Outputs        : None
 * Returns        : rrm_cellm_resrc_type_et
 * Description    : This function map resource type.
 ****************************************************************************/
    rrm_cellm_resrc_type_et
rrm_map_resrc_type (U32 rrm_resrc_type)
{
    rrm_cellm_resrc_type_et resrc_type = RRM_CELLM_MAX_RESRC;

    RRM_UT_TRACE_ENTER();

    switch (rrm_resrc_type)
    {
        case RRM_ZERO:
            resrc_type = RRM_CELLM_HW_RESRC;
            break;
        case RRM_ONE:
            resrc_type = RRM_CELLM_TNL_RESRC;
            break;
        case RRM_TWO:
            resrc_type = RRM_CELLM_NONGRB_RESRC;
            break;
        case RRM_THREE:
            resrc_type = RRM_CELLM_GBR_RESRC;
            break;
        case RRM_FOUR:
            resrc_type = RRM_CELLM_MAX_RESRC;
            break;
        default:
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    " By default assigning RRM_CELLM_MAX_RESRC ");
            break;
    }
    RRM_UT_TRACE_EXIT();
    return resrc_type;
}

/* Bug_8718_start */

/****************************************************************************
 * Function Name  : check_soft_limit_range_for_resrc_sp
 * Inputs         : -serv_enb_cell_info
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function checks if soft limit value
 *                  provided from OAM is correct or not
 ****************************************************************************/
    rrm_return_et
check_soft_limit_range_for_resrc_sp(
        rrm_oam_serving_enb_cell_info_t  *p_serv_enb_cell_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;
    U8            index   = RRM_ZERO;

    RRM_UT_TRACE_ENTER();
    if(p_serv_enb_cell_info->bitmask & RRM_OAM_RESRC_SPEC_PRESENT)
    {
        for(index = RRM_ZERO; index < p_serv_enb_cell_info->resrc_spec.count; index++)
        {
            if((p_serv_enb_cell_info->resrc_spec.resrc_info[index].bitmask & RRM_OAM_ACTION_OVERLD_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT)  &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.action & RRMCM_ACTN_STOP_ADM) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.bitmask & RRM_OAM_PERCNTG_PRESENT))
            {
                if(p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.stop_adm_info.soft_limit +
                        p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.load_perctg >= 100)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "Range for soft limit value[%d] for overload (resource specific) fails",
                            p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.stop_adm_info.soft_limit);
                    ret_val = RRM_FAILURE;
                    break;
                }
            }

            if((p_serv_enb_cell_info->resrc_spec.resrc_info[index].bitmask & RRM_OAM_ACTION_HIGHLD_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].bitmask & RRM_OAM_ACTION_OVERLD_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.bitmask & RRM_OAM_PERCNTG_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.action & RRMCM_ACTN_STOP_ADM) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.bitmask & RRM_OAM_PERCNTG_PRESENT))
            {
                if((p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.stop_adm_info.soft_limit +
                            p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.load_perctg) >
                        (p_serv_enb_cell_info->resrc_spec.resrc_info[index].overload.load_perctg))
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "Range for soft limit value[%d] for highload (resource specific) fails",
                            p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.stop_adm_info.soft_limit);
                    ret_val = RRM_FAILURE;
                    break;
                }
            }

            if((p_serv_enb_cell_info->resrc_spec.resrc_info[index].bitmask & RRM_OAM_ACTION_MIDLD_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].bitmask & RRM_OAM_ACTION_HIGHLD_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.bitmask & RRM_OAM_PERCNTG_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.action & RRMCM_ACTN_STOP_ADM) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) &&
                    (p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.bitmask & RRM_OAM_PERCNTG_PRESENT))
            {
                if((p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.stop_adm_info.soft_limit +
                            p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.load_perctg) >
                        (p_serv_enb_cell_info->resrc_spec.resrc_info[index].highload.load_perctg))
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "Range for soft limit value[%d] for midload (resource specific) fails",
                            p_serv_enb_cell_info->resrc_spec.resrc_info[index].midload.stop_adm_info.soft_limit);
                    ret_val = RRM_FAILURE;
                    break;
                }
            }
        }
        if(RRM_FAILURE == ret_val)
        {
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
    }
    RRM_UT_TRACE_EXIT();
    return ret_val;
}

/****************************************************************************
 * Function Name  : check_soft_limit_range
 * Inputs         : -serv_enb_cell_info 
 * Outputs        : None
 * Returns        : RRM_SUCCESS/RRM_FAILURE
 * Description    : This function checks if soft limit value 
 *                  provided from OAM is correct or not
 ****************************************************************************/
    rrm_return_et
check_soft_limit_range(
        rrm_oam_serving_enb_cell_info_t  *p_serv_enb_cell_info)
{
    rrm_return_et ret_val = RRM_SUCCESS;

    RRM_UT_TRACE_ENTER();

    if((p_serv_enb_cell_info->bitmask & RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT) && 
            (p_serv_enb_cell_info->over_load_lvl_act.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT) &&
            (p_serv_enb_cell_info->over_load_lvl_act.action & RRMCM_ACTN_STOP_ADM) &&
            (p_serv_enb_cell_info->over_load_lvl_act.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) && 
            (p_serv_enb_cell_info->over_load_lvl_act.bitmask & RRM_OAM_PERCNTG_PRESENT))
    {
        if((p_serv_enb_cell_info->over_load_lvl_act.stop_adm_info.soft_limit + 
                    p_serv_enb_cell_info->over_load_lvl_act.load_perctg) > 100)
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Range for soft limit value[%d] for overload fails",
                    p_serv_enb_cell_info->over_load_lvl_act.stop_adm_info.soft_limit);
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
    }

    if((p_serv_enb_cell_info->bitmask & RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT) && 
            (p_serv_enb_cell_info->bitmask & RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT) && 
            (p_serv_enb_cell_info->over_load_lvl_act.bitmask & RRM_OAM_PERCNTG_PRESENT) && 
            (p_serv_enb_cell_info->high_load_lvl_act.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT) && 
            (p_serv_enb_cell_info->high_load_lvl_act.action & RRMCM_ACTN_STOP_ADM) &&
            (p_serv_enb_cell_info->high_load_lvl_act.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) && 
            (p_serv_enb_cell_info->high_load_lvl_act.bitmask & RRM_OAM_PERCNTG_PRESENT))
    {
        if((p_serv_enb_cell_info->high_load_lvl_act.stop_adm_info.soft_limit + 
                    p_serv_enb_cell_info->high_load_lvl_act.load_perctg) >= 
                (p_serv_enb_cell_info->over_load_lvl_act.load_perctg))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Range for soft limit value[%d] for highload fails",
                    p_serv_enb_cell_info->high_load_lvl_act.stop_adm_info.soft_limit);
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
    }

    if((p_serv_enb_cell_info->bitmask & RRM_OAM_MID_LOAD_LVL_ACT_PRESENT) && 
            (p_serv_enb_cell_info->bitmask & RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT) && 
            (p_serv_enb_cell_info->high_load_lvl_act.bitmask & RRM_OAM_PERCNTG_PRESENT) && 
            (p_serv_enb_cell_info->mid_load_lvl_act.bitmask & RRM_OAM_STOP_ADM_INFO_PRESENT) && 
            (p_serv_enb_cell_info->mid_load_lvl_act.action & RRMCM_ACTN_STOP_ADM) &&
            (p_serv_enb_cell_info->mid_load_lvl_act.stop_adm_info.bitmask & RRM_OAM_SOFT_LIMIT_PRESENT) && 
            (p_serv_enb_cell_info->mid_load_lvl_act.bitmask & RRM_OAM_PERCNTG_PRESENT))
    {
        if((p_serv_enb_cell_info->mid_load_lvl_act.stop_adm_info.soft_limit + 
                    p_serv_enb_cell_info->mid_load_lvl_act.load_perctg) >= 
                (p_serv_enb_cell_info->high_load_lvl_act.load_perctg))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "Range for soft limit value[%d] for midload fails",
                    p_serv_enb_cell_info->mid_load_lvl_act.stop_adm_info.soft_limit);
            ret_val = RRM_FAILURE;
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
    }

    ret_val = check_soft_limit_range_for_resrc_sp(p_serv_enb_cell_info);

    RRM_UT_TRACE_EXIT();

    return ret_val;
}
/* Bug_8718_end */

/* Coverity_ID : 54439 end */
/****************************************************************************
 * Function Name  : build_and_send_load_config_req_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_message - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares and send Load Config Request to CellM
 ****************************************************************************/
rrm_return_et 
build_and_send_load_config_req_to_cellm(
        /*SPR 17777 +-*/
        rrm_mif_context             **p_mif_context,
        U16                         mif_count,
        rrm_oam_load_config_req_t   *p_in_message,
        U32                         trans_id,
        rrm_error_et                *p_fail_cause)
{
    rrm_return_et                 ret_val = RRM_SUCCESS;
    rrmcm_rmif_load_config_req_t  *out_load_config_req_to_cellm = RRM_PNULL;
    U16                           i = RRM_NULL;
    U16                           j = RRM_NULL;
    U32                           dup_elem = RRM_NULL;

    RRM_UT_TRACE_ENTER();

    /*SPR 17777 +-*/
    RRM_ASSERT(RRM_PNULL != p_mif_context);
    RRM_ASSERT(RRM_PNULL != p_in_message);

    out_load_config_req_to_cellm = (rrmcm_rmif_load_config_req_t *) rrm_mem_get(sizeof(rrmcm_rmif_load_config_req_t));

    if(RRM_PNULL == out_load_config_req_to_cellm)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Memory allocation failed");
        return RRM_FAILURE;

    }
    RRM_MEMSET (out_load_config_req_to_cellm, RRM_ZERO, sizeof(rrmcm_rmif_load_config_req_t));
    out_load_config_req_to_cellm->transaction_id = trans_id;
    out_load_config_req_to_cellm->bitmask = RRM_ZERO;
    if (RRM_OAM_LOAD_RPT_INTRVL_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_LOAD_RPT_INTRVL;
        out_load_config_req_to_cellm->load_rpt_intrvl = p_in_message->load_rpt_intrvl;
    }

    if (RRM_OAM_NCL_LOAD_IND_INTRVL_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_NCL_LOAD_IND_INTRVL;
        out_load_config_req_to_cellm->ncl_load_ind_intrvl = p_in_message->ncl_load_ind_intrvl;
    }

    /* Bug_8718_start */
    if(RRM_OAM_LOAD_CHK_PRDCTY_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_LOAD_CHK_PRDCTY_PRESENT;
        out_load_config_req_to_cellm->load_chk_periodicity = p_in_message->load_chk_periodicity;
    }

    if(RRM_OAM_HIGH_ACT_RPT_LMT_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_HIGH_ACT_RPT_LMT_PRESENT;
        out_load_config_req_to_cellm->high_actn_repeat_lmt = p_in_message->high_actn_repeat_lmt;
    }
    /* Bug_8718_end */

    /* SPR 20653 Fix Start */
    if(RRM_OAM_TNL_LOAD_SUPPORT_FLAG_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_TNL_LOAD_SUPPORT_FLAG_PRESENT;
        out_load_config_req_to_cellm->tnl_load_support_flag = p_in_message->tnl_load_support_flag;
    }
    if(RRM_OAM_HW_LOAD_SUPPORT_FLAG_PRESENT & p_in_message->bitmask)
    {
        out_load_config_req_to_cellm->bitmask |= RRMCM_RMIF_HW_LOAD_SUPPORT_FLAG_PRESENT;
        out_load_config_req_to_cellm->hw_load_support_flag = p_in_message->hw_load_support_flag;
    }
    /* SPR 20653 Fix End */
    out_load_config_req_to_cellm->num_of_cell = p_in_message->num_enb_cells;

    for(i = RRM_NULL; i < mif_count; i++)
    {

        /* Bug_8718_start */
        /*Check soft limit range provided from OAM for each load action*/
        ret_val = check_soft_limit_range(&(p_in_message->serv_enb_cell_info[i]));

        if(RRM_FAILURE == ret_val)
        {
            *p_fail_cause = RRM_ERR_INVALID_PARAMS;
            /* COVERITY : RESOURCE LEAK : CID : 63264 fix start */
            if( RRM_NULL != out_load_config_req_to_cellm )
                RRM_MEM_FREE( out_load_config_req_to_cellm );
            /* COVERITY : RESOURCE LEAK : CID : 63264 fix end*/
            RRM_UT_TRACE_EXIT();
            return ret_val;
        }
        /* Bug_8718_end */
        out_load_config_req_to_cellm->srv_cell_info[i].bitmask = RRM_NULL;
        out_load_config_req_to_cellm->srv_cell_info[i].cellindex = 
            p_mif_context[i]->cell_index;
        /* Bug_8718_start */
        if((ret_val == RRM_SUCCESS)&& (RRM_OAM_OVER_LOAD_LVL_ACT_PRESENT & p_in_message->serv_enb_cell_info[i].bitmask))
            /* Bug_8718_end */
        {
            out_load_config_req_to_cellm->srv_cell_info[i].bitmask |= 
                RRMCM_RMIF_OVER_LOAD_LVL_ACT_PRESENT;
            ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                    over_load_lvl_act, p_in_message->serv_enb_cell_info[i].over_load_lvl_act, p_fail_cause);
        }
        if((ret_val == RRM_SUCCESS)&& (RRM_OAM_HIGH_LOAD_LVL_ACT_PRESENT & p_in_message->serv_enb_cell_info[i].bitmask))
        {
            out_load_config_req_to_cellm->srv_cell_info[i].bitmask |= 
                RRMCM_RMIF_HIGH_LOAD_LVL_ACT_PRESENT;
            ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                    high_load_lvl_act, p_in_message->serv_enb_cell_info[i].high_load_lvl_act, p_fail_cause);
        }
        if((ret_val == RRM_SUCCESS)&&(RRM_OAM_MID_LOAD_LVL_ACT_PRESENT & p_in_message->serv_enb_cell_info[i].bitmask))
        {
            out_load_config_req_to_cellm->srv_cell_info[i].bitmask |= 
                RRMCM_RMIF_MID_LOAD_LVL_ACT_PRESENT;
            ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                    mid_load_lvl_act, p_in_message->serv_enb_cell_info[i].mid_load_lvl_act, p_fail_cause);
        }
        if((ret_val == RRM_SUCCESS)&&(RRM_OAM_RESRC_SPEC_PRESENT & p_in_message->serv_enb_cell_info[i].bitmask))
        {
            out_load_config_req_to_cellm->srv_cell_info[i].bitmask |= 
                RRMCM_RMIF_RESRC_SPEC_PRESENT;

            out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.bitmask = RRM_ZERO;
            out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.count = RRM_ZERO;
            /*+ Coverity : CID 25364 +*/
            for(j = RRM_ZERO; ((j < p_in_message->serv_enb_cell_info[i].resrc_spec.count) && (j < RRM_OAM_MAX_RESOURCE)); 
                    j++)
                /*- Coverity : CID 25364 -*/
            {
                if (dup_elem & (RRM_ONE << (p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type)))
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                            "RRM LD Config Req: Duplicate Resource type recved from OAM");
                    *p_fail_cause = RRM_ERR_INVALID_PARAMS;
                    ret_val = RRM_FAILURE;
                    break;
                }
                else
                {
                    dup_elem = (dup_elem | (RRM_ONE << (p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type)));
                }
                if(RRM_THREE <  p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type)
                {
                    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                            "Wrong Resource type :%d", p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type);
                    ret_val = RRM_FAILURE;
                }
                if (RRM_FAILURE == ret_val)
                {
                    *p_fail_cause = RRM_ERR_INVALID_PARAMS;
                    break;
                }
                else
                {
                    /* Coverity_ID : 54439 start */
                    if (p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type <= RRM_CELLM_MAX_RESRC )
                    {
                        out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.resrc_info[j].
                            resrc_type = rrm_map_resrc_type(
                                    p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].resrc_type);
                    }
                    else
                    {
                        *p_fail_cause = RRM_ERR_INVALID_PARAMS;
                        ret_val = RRM_FAILURE;
                        break;
                    }
                    /* Coverity_ID : 54439 end */
                    out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.resrc_info[j].bitmask = RRM_ZERO;

                    if(p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].bitmask & 
                            RRM_OAM_ACTION_OVERLD_PRESENT)
                    {
                        out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.resrc_info[j].
                            bitmask |= RRMCM_RMIF_ACTION_OVERLD_PRESENT;
                        ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                                resrc_spec.resrc_info[j].overload, p_in_message->serv_enb_cell_info[i].
                                resrc_spec.resrc_info[j].overload, p_fail_cause);

                    }

                    if((ret_val == RRM_SUCCESS)&&(p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].bitmask & 
                                RRM_OAM_ACTION_HIGHLD_PRESENT))
                    {
                        out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.resrc_info[j].
                            bitmask |= RRMCM_RMIF_ACTION_HIGHLD_PRESENT;
                        ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                                resrc_spec.resrc_info[j].highload, p_in_message->
                                serv_enb_cell_info[i].resrc_spec.resrc_info[j].highload, p_fail_cause);
                    }

                    if((ret_val == RRM_SUCCESS)&&(p_in_message->serv_enb_cell_info[i].resrc_spec.resrc_info[j].bitmask & 
                                RRM_OAM_ACTION_MIDLD_PRESENT))
                    {
                        out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.resrc_info[j].
                            bitmask |= RRMCM_RMIF_ACTION_MIDLD_PRESENT;
                        ret_val = fill_load_action_params(&out_load_config_req_to_cellm->srv_cell_info[i].
                                resrc_spec.resrc_info[j].midload, p_in_message->
                                serv_enb_cell_info[i].resrc_spec.resrc_info[j].midload, p_fail_cause);
                    }
                    out_load_config_req_to_cellm->srv_cell_info[i].resrc_spec.count++; 
                }
            }
        }
        if (RRM_FAILURE == ret_val)
        {
            break;
        }
    }

    /* Sending load config request to RRMCM*/
    if (ret_val == RRM_SUCCESS)
    {
        rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                RRMCM_RMIF_LOAD_CONFIG_REQ,
                sizeof(rrmcm_rmif_load_config_req_t),
                (void *)out_load_config_req_to_cellm);
    }
    RRM_MEM_FREE (out_load_config_req_to_cellm);
    RRM_UT_TRACE_EXIT();
    return ret_val;
}


/****************************************************************************
 * Function Name  : get_num_of_rb_frm_chanl_bw
 * Inputs         : channel_bandwith
 * Outputs        : num_of_avail_rb
 * Returns        : void
 * Description    : This function calculates the available RB's as per
 *                  the channel BW.
 ****************************************************************************/
rrm_void_t
get_num_of_rb_frm_chanl_bw
( 
 rrm_oam_band_width_et channel_bandwith , 
 U8 *num_of_avail_rb
 )
{
    RRM_UT_TRACE_ENTER();

    switch(channel_bandwith)
    {

        case RRM_OAM_BW_N_6:
            *num_of_avail_rb = RB_COUNT_6;
            break;

        case RRM_OAM_BW_N_15:
            *num_of_avail_rb = RB_COUNT_15;
            break;

        case RRM_OAM_BW_N_25:
            *num_of_avail_rb = RB_COUNT_25;
            break;

        case RRM_OAM_BW_N_50:
            *num_of_avail_rb = RB_COUNT_50;
            break;

        case RRM_OAM_BW_N_75:
            *num_of_avail_rb = RB_COUNT_75;
            break;

        case RRM_OAM_BW_N_100:
            *num_of_avail_rb = RB_COUNT_100;
            break;
    }

    RRM_UT_TRACE_EXIT();
}
#ifdef TDD_MODE_FLAG

/****************************************************************************
 * Function Name  : get_dl_prb_bdgt_frm_total_bw_in_tdd 
 * Inputs         : channel_bandwith, plp_tdd_frame_str_from_oam ,
 * Outputs        : dl_prb_budget
 * Returns        : void
 * Description    : This function calculates the DL prb budget as for TDD
 ****************************************************************************/
rrm_void_t
    get_dl_prb_bdgt_frm_total_bw_in_tdd
(
 rrm_oam_band_width_et channel_bandwith,
 rrm_oam_tdd_frame_structure_t *plp_tdd_frame_str_from_oam,
 U8 *dl_prb_budget 
 )
{
    RRM_UT_TRACE_ENTER();

    U64 total_dl_length     = RRM_NULL;
    U16 spcl_dwpts_length   = RRM_NULL;  
    U8  num_of_avail_dl_rb     = RRM_ZERO; 

    get_spcl_dwpts_length_from_spcl_sf_pattern(plp_tdd_frame_str_from_oam->special_sub_frame_patterns ,
            &spcl_dwpts_length);

    get_num_of_rb_frm_chanl_bw( channel_bandwith , &num_of_avail_dl_rb);                                              

    switch(plp_tdd_frame_str_from_oam->sub_frame_assignment)
    {
        case RRM_OAM_SA0:
            total_dl_length = (DL_SUBFRMS_COUNT_2 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_dwpts_length); 
            break;
        case RRM_OAM_SA1:
            total_dl_length = (DL_SUBFRMS_COUNT_4 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_dwpts_length); 
            break;

        case RRM_OAM_SA2:
            total_dl_length = (DL_SUBFRMS_COUNT_6 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_dwpts_length); 
            break;
        case RRM_OAM_SA3:
            total_dl_length = (DL_SUBFRMS_COUNT_6 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_dwpts_length); 
            break;
        case RRM_OAM_SA4:
            total_dl_length = (DL_SUBFRMS_COUNT_7 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_dwpts_length); 
            break;
        case RRM_OAM_SA5:
            total_dl_length = (DL_SUBFRMS_COUNT_8 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_dwpts_length); 
            break;
        case RRM_OAM_SA6:
            total_dl_length = (DL_SUBFRMS_COUNT_3 * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_dwpts_length); 
            break;

    }

    *dl_prb_budget = RRM_FLOOR((total_dl_length * num_of_avail_dl_rb)/ONE_RF_LENGTH);

    RRM_UT_TRACE_EXIT();  
}

/****************************************************************************
 * Function Name  : get_spcl_dwpts_length_from_spcl_sf_pattern 
 * Inputs         : spcl_sf_pattrn
 * Outputs        : spcl_dwpts_length
 * Returns        : void
 * Description    : This function calculates the length of DWPTS part of the
 *                  Special subframe as per the tdd spcl sf pattern
 ****************************************************************************/
rrm_void_t
    get_spcl_dwpts_length_from_spcl_sf_pattern
(
 rrm_oam_special_sub_frame_patterns_et spcl_sf_pattrn,
 U16 *spcl_dwpts_length
 )
{
    RRM_UT_TRACE_ENTER();

    if((spcl_sf_pattrn == RRM_OAM_SSP0) ||
            (spcl_sf_pattrn == RRM_OAM_SSP5))
    {
        *spcl_dwpts_length = SPCL_DWPTS_LENGTH_0;
    }
    else if((spcl_sf_pattrn == RRM_OAM_SSP1) ||
            (spcl_sf_pattrn == RRM_OAM_SSP6))
    {
        *spcl_dwpts_length = SPCL_DWPTS_LENGTH_1;
    }
    else if((spcl_sf_pattrn == RRM_OAM_SSP2) ||
            (spcl_sf_pattrn == RRM_OAM_SSP7))
    {
        *spcl_dwpts_length = SPCL_DWPTS_LENGTH_2;
    }
    else if((spcl_sf_pattrn == RRM_OAM_SSP3) ||
            (spcl_sf_pattrn == RRM_OAM_SSP8))
    {
        *spcl_dwpts_length = SPCL_DWPTS_LENGTH_3;
    }
    else if((spcl_sf_pattrn == RRM_OAM_SSP4))
    {
        *spcl_dwpts_length = SPCL_DWPTS_LENGTH_4;
    }
    else
    {
        /*do nothong*/
    }

    RRM_UT_TRACE_EXIT();
}


/****************************************************************************
 * Function Name  : get_spcl_uppts_length_from_spcl_sf_pattern 
 * Inputs         : spcl_sf_pattrn
 * Outputs        : spcl_uppts_length
 * Returns        : void
 * Description    : This function calculates the length of UPPTS part of the
 *                  Special subframe as per the tdd spcl sf pattern
 ****************************************************************************/
rrm_void_t
    get_spcl_uppts_length_from_spcl_sf_pattern
(
 rrm_oam_special_sub_frame_patterns_et spcl_sf_pattrn,
 U16 *spcl_uppts_length
 )
{
    RRM_UT_TRACE_ENTER();
    /*SPR 16236 TDD Merge start*/
    /*commented to remove warning to error conversion,as this enum is intialised to 0 and hence
      comparasion to 0 does not make sense*/
    if(/*(spcl_sf_pattrn >= RRM_OAM_SSP0) &&*/
            /*SPR 16236 end*/
            (spcl_sf_pattrn <= RRM_OAM_SSP4))
    {
        *spcl_uppts_length = SPCL_ONE_SYMBOL_UPPTS_LENGTH;
    }
    /* Covetity Fix 63939 Start */
    else if((spcl_sf_pattrn >= RRM_OAM_SSP5) &&
            (spcl_sf_pattrn <= RRM_OAM_SSP8))
        /* Covetity Fix 63939 End */
    {
        *spcl_uppts_length = SPCL_TWO_SYMBOL_UPPTS_LENGTH;
    }
    else
    {
        *spcl_uppts_length = SPCL_ONE_SYMBOL_UPPTS_LENGTH;
    }
    /* Coverity 47645 fix end */

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : get_ul_prb_bdgt_frm_total_bw_in_tdd 
 * Inputs         : channel_bandwith, plp_tdd_frame_str_from_oam ,
 * Outputs        : ul_prb_budget
 * Returns        : void
 * Description    : This function calculates the UL prb budget as for TDD
 ****************************************************************************/
rrm_void_t
    get_ul_prb_bdgt_frm_total_bw_in_tdd
(
 rrm_oam_band_width_et channel_bandwith,
 rrm_oam_tdd_frame_structure_t *plp_tdd_frame_str_from_oam,
 U8 *ul_prb_budget 
 )
{
    RRM_UT_TRACE_ENTER();

    U64 total_ul_length     = RRM_NULL;
    U16 spcl_uppts_length   = RRM_NULL;  
    U8  num_of_avail_ul_rb  = RRM_ZERO; 
    U8  ul_sf_count         = RRM_ZERO;   

    get_spcl_uppts_length_from_spcl_sf_pattern(plp_tdd_frame_str_from_oam->special_sub_frame_patterns ,
            &spcl_uppts_length);

    get_num_of_rb_frm_chanl_bw( channel_bandwith , &num_of_avail_ul_rb);                                              

    switch(plp_tdd_frame_str_from_oam->sub_frame_assignment)
    {
        case RRM_OAM_SA0:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_2 - SPCL_SUBFRMS_COUNT_2; 
            total_ul_length = (ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_uppts_length); 
            break;
        case RRM_OAM_SA1:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_4 - SPCL_SUBFRMS_COUNT_2; 
            total_ul_length = (ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_uppts_length); 
            break;

        case RRM_OAM_SA2:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_6 - SPCL_SUBFRMS_COUNT_2; 
            total_ul_length = (ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_uppts_length); 
            break;
        case RRM_OAM_SA3:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_6 - SPCL_SUBFRMS_COUNT_1; 
            total_ul_length = ( ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_uppts_length); 
            break;
        case RRM_OAM_SA4:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_7 - SPCL_SUBFRMS_COUNT_1; 
            total_ul_length = ( ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_uppts_length); 
            break;
        case RRM_OAM_SA5:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_8 - SPCL_SUBFRMS_COUNT_1; 
            total_ul_length = (ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_1 + spcl_uppts_length); 
            break;
        case RRM_OAM_SA6:
            ul_sf_count = TOTAL_SF_IN_ONE_RF - DL_SUBFRMS_COUNT_8 - SPCL_SUBFRMS_COUNT_2; 
            total_ul_length = ( ul_sf_count * ONE_SF_LENFTH) + 
                (SPCL_SUBFRMS_COUNT_2 + spcl_uppts_length); 
            break;

    }

    *ul_prb_budget = RRM_FLOOR((total_ul_length * num_of_avail_ul_rb)/ONE_RF_LENGTH);

    RRM_UT_TRACE_EXIT();  
}

#endif

/************* Changes starts for Cell Configuration functions. Bitmask checking
 * from OAM for Cell Configuration Message removed
 */



/****************************************************************************
 * Function Name  : rrm_fill_beamforming_info 
 * Inputs         : p_operator_cfg_params , 
 * Outputs        : p_operator_info_to_cellm 
 * Returns        : void
 * Description    : This function fill the beamforming info 
 ****************************************************************************/
/* SPR 20653 Fix Start */
rrm_void_t rrm_fill_beamforming_info( rrm_oam_operator_info_t *p_operator_info_from_oam,
        operator_info_t           *p_operator_info_to_cellm )
{

    U16 index = RRM_ZERO;

    if( p_operator_info_from_oam->mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.bitmask & 
            RRM_OAM_AOA_BEAM_FORMING_ALGO_PRESENT )
    {
        p_operator_info_to_cellm->mac_beam_forming_info.bitmask |=
            RRM_AOA_TO_BEAM_FRMNG_VECTOR_MPPNG_PRESENT; 

        for( index = RRM_ZERO; index < RRM_MAX_BF_VECTORS_TO_AOA_VAL ; index++ )
        {
            p_operator_info_to_cellm->mac_beam_forming_info.
                rrm_aoa_to_beam_frmng_vctr_mppng[index] = 
                p_operator_info_from_oam->mimo_mode_params.rrm_tm_mode_additional_info.
                beam_forming_algo_info.aoa_beamforming_vector[index];

        }
    }

    if( p_operator_info_from_oam->mimo_mode_params.rrm_tm_mode_additional_info.beam_forming_algo_info.bitmask & 
            RRM_OAM_SINR_BEAM_FORMING_ALGO_PRESENT )
    {
        p_operator_info_to_cellm->mac_beam_forming_info.bitmask |=
            RRM_SINR_TO_BEAM_FRMNG_CONFIG_PRESENT; 

        for( index = RRM_ZERO; index < RRM_MAX_BF_VECTORS_TO_SINR_VAL; index++ )
        {
            p_operator_info_to_cellm->mac_beam_forming_info.sinr_to_beam_forming_config_t[index].
                beam_frmng_vector_for_A1 = 
                p_operator_info_from_oam->mimo_mode_params.rrm_tm_mode_additional_info.
                    beam_forming_algo_info.sinr_beamforming_vector[index];
        }
    }
}

 /* SPR 20653 Fix End */


/****************************************************************************
 * Function Name  : rrm_fill_tm_mode_additional_info 
 * Inputs         : p_operator_cfg_params ,
 * Outputs        : p_operator_info_to_cellm
 * Returns        : void
 * Description    : This function fill the transmission mode additional info
 ****************************************************************************/
/* SPR 20653 Fix Start */
rrm_void_t
rrm_fill_tm_mode_additional_info( rrm_oam_tm_mode_additional_info_t *p_tm_mode_add_info_from_oam,
                                  operator_info_t *p_operator_info_to_cellm)
    /* SPR 20653 Fix End */
{
    RRM_UT_TRACE_ENTER();
    /* SPR 20653 Fix Start */
    if(p_tm_mode_add_info_from_oam->bitmask & RRM_OAM_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT)
    {
        p_operator_info_to_cellm->rrm_tm_mode_additional_info.pdsch_epre_to_ue_rs_ratio = 
            p_tm_mode_add_info_from_oam->pdsch_epre_to_ue_rs_ratio;
    }
    if(p_tm_mode_add_info_from_oam->bitmask & RRM_OAM_ENABLE_PMI_RI_REPORT_R9_PRESENT)
    {
        switch(p_tm_mode_add_info_from_oam->enable_pmi_ri_report_r9)
        {
            case 0:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.enable_pmi_ri_report_r9 = RRM_FALSE;
                break;
            case 1:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.enable_pmi_ri_report_r9 = RRM_TRUE;
                break;
            default:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.enable_pmi_ri_report_r9 = RRM_FALSE;
                break;
        }
    }

    if(p_tm_mode_add_info_from_oam->bitmask & RRM_OAM_BEAM_FORMING_ALGO_INFO_PRESENT)
    {
        switch(p_tm_mode_add_info_from_oam->beam_forming_algo_info.beam_forming_algo)
        {
            /* coverity : CID 41562 */
            /* CID 112405, 112397 Start */
            case BEAM_FORMING_SINR:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.beam_forming_algo = (rrm_beam_forming_algo_et)BEAM_FORMING_SINR ;
                break;
            case BEAM_FORMING_AOA:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.beam_forming_algo = (rrm_beam_forming_algo_et)BEAM_FORMING_AOA;
                break;
            default:
                p_operator_info_to_cellm->rrm_tm_mode_additional_info.beam_forming_algo = (rrm_beam_forming_algo_et)BEAM_FORMING_SINR; /* coverity : CID 41561*/
                break;
                /* CID 112405, 112397 End */
        }
    }
    /* SPR 20653 Fix End */
    RRM_UT_TRACE_ENTER();
}


/****************************************************************************
 * Function Name  : rrm_fill_dynamic_ue_scheduling
 * Inputs         : p_operator_info_from_oam ,
 * Outputs        : p_operator_info_cellm 
 * Returns        : void
 * Description    : This function fill the dynamic ue scheduling info
 ******************************************************************************/
    rrm_void_t
rrm_fill_dynamic_ue_scheduling( rrm_oam_max_ue_schedule_dl_ul_t *p_ue_schedule_info_oam,
        rrm_max_ue_schedule_dl_ul_t     *p_ue_schedule_info_cellm )
{
    /* no need to check the null pointer of 
       p_ue_schedule_info_oam , p_ue_schedule_info_cellm  
       ,as it is already checked in its callee function */

    RRM_UT_TRACE_ENTER();

    p_ue_schedule_info_cellm->bitmask = 0x00;


    p_ue_schedule_info_cellm->max_ue_scheduled_dl = p_ue_schedule_info_oam->max_ue_scheduled_dl;
    p_ue_schedule_info_cellm->max_ue_scheduled_ul = p_ue_schedule_info_oam->max_ue_scheduled_ul;


    if( RRM_OAM_UE_SCHEDULING_HYSTERESIS_PRESENT & p_ue_schedule_info_oam->bitmask )
    {
        p_ue_schedule_info_cellm->bitmask |= RRM_UE_SCHEDULING_HYSTERESIS_PRESENT;

        p_ue_schedule_info_cellm->ue_scheduling_hysteresis =
            p_ue_schedule_info_oam->ue_scheduling_hysteresis;

    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "UE scheduling hysteresis info is not coming in Dynamic UE scheduling"
                "info from OAM");
    } 

    RRM_UT_TRACE_EXIT();

}

/* Carrier_Aggregation_Start */
/****************************************************************************
 * Function Name  : rrm_fill_ca_config_params
 * Inputs         : - ca_config_to_cellm
 *                  - ca_config_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the CA params info for CellM Module
 ****************************************************************************/
    rrm_void_t
rrm_fill_ca_config_params (rrm_ca_config_t *p_ca_config_to_cellm,
        rrm_oam_ca_config_t *p_ca_config_from_oam
        )
{
    RRM_ASSERT (RRM_PNULL != p_ca_config_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ca_config_from_oam);

    RRM_UT_TRACE_ENTER();
    p_ca_config_to_cellm->bitmask = 0x00;
    p_ca_config_to_cellm->bitmask |= RRM_IS_CA_ELIGIBLE_INFO_PRESENT;
    if (RRM_OAM_IS_CA_ELIGIBLE_INFO_PRESENT & p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->is_ca_eligible = p_ca_config_from_oam->is_ca_eligible;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA config param is_ca_eligible is not present assigning default value"); 
        p_ca_config_to_cellm->is_ca_eligible = RRM_IS_CA_ELIGIBLE_DEFAULT_VALUE;
    } 
    p_ca_config_to_cellm->bitmask |= RRM_NUM_OF_REPORT_PRESENT;
    if (RRM_OAM_NUM_OF_REPORT_PRESENT & p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->num_of_report = p_ca_config_from_oam->num_of_report;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA config param num_of_report is not present assigning default value"); 
        p_ca_config_to_cellm->num_of_report = RRM_NUM_OF_REPORT_DEFAULT_VALUE;
    } 
    p_ca_config_to_cellm->bitmask |= RRM_CA_APPLICABLE_BITRATE_DL_PRESENT;
    if (RRM_OAM_CA_APPLICABLE_BITRATE_DL_PRESENT & p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->ca_applicable_bitrate_dl = p_ca_config_from_oam->ca_applicable_bitrate_dl;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA config param ca_applicable_bitrate_dl is not present assigning default value"); 
        p_ca_config_to_cellm->ca_applicable_bitrate_dl = RRM_CA_APPL_BITRATE_UL_DL_DEFAULT_VALUE;
    } 
    p_ca_config_to_cellm->bitmask |= RRM_IS_MASA_INFO_PRESENT;
    if (RRM_OAM_IS_MASA_INFO_PRESENT & p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->is_masa = p_ca_config_from_oam->is_masa;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA config param is_masa is not present assigning default value"); 
        p_ca_config_to_cellm->is_masa = RRM_IS_MASA_DEFAULT_VALUE;
    } 
    p_ca_config_to_cellm->bitmask |= RRM_SCELL_DEACTIVATION_TIMER_PRESENT;
    if (RRM_OAM_SCELL_DEACTIVATION_TIMER_PRESENT & p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->scell_deactivation_timer = 
            (rrm_scell_deactivation_timer_et)p_ca_config_from_oam->scell_deactivation_timer;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA config param scell_deactivation_timer is not present assigning default value"); 
        p_ca_config_to_cellm->scell_deactivation_timer = RRM_SCELL_RF32;
    } 
    if (RRM_OAM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT & p_ca_config_from_oam->bitmask)
    {
        if (RRM_OAM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.load_calcualtion_window_size = 
                p_ca_config_from_oam->ca_mac_scheduler_params.load_calcualtion_window_size;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |= 
                RRM_LOAD_CALCULATION_WINDOW_SIZE_PRESENT;
        }
        if (RRM_OAM_LOAD_DISPARITY_THRESHOLD_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.load_disparity_threshold = 
                p_ca_config_from_oam->ca_mac_scheduler_params.load_disparity_threshold;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_LOAD_DISPARITY_THRESHOLD_PRESENT;
        }
        if (RRM_OAM_MCS_DIFF_THRESHOLD_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.mcs_diff_threshold = 
                p_ca_config_from_oam->ca_mac_scheduler_params.mcs_diff_threshold;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_MCS_DIFF_THRESHOLD_PRESENT;
        }
        if (RRM_OAM_PRB_USAGE_WATER_MARK_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.prb_usage_water_mark = 
                p_ca_config_from_oam->ca_mac_scheduler_params.prb_usage_water_mark;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_PRB_USAGE_WATER_MARK_PRESENT;
        }
        if (RRM_OAM_DL_DEACT_COMMAND_THRESH_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.dl_deact_command_thresh = 
                p_ca_config_from_oam->ca_mac_scheduler_params.dl_deact_command_thresh;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_DEACT_COMMAND_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_DEACT_MCS_LOW_THRESH_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.dl_deact_mcs_low_thresh = 
                p_ca_config_from_oam->ca_mac_scheduler_params.dl_deact_mcs_low_thresh;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_DEACT_MCS_LOW_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_Q_LOAD_UP_THRESH_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.dl_qload_up_threshold = 
                p_ca_config_from_oam->ca_mac_scheduler_params.dl_qload_up_threshold;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_Q_LOAD_UP_THRESH_PRESENT;
        }
        if (RRM_OAM_DL_Q_LOAD_LOW_THRESH_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.dl_qload_low_threshold = 
                p_ca_config_from_oam->ca_mac_scheduler_params.dl_qload_low_threshold;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_DL_Q_LOAD_LOW_THRESH_PRESENT;
        }
        if (RRM_OAM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.act_deact_trigger_count_threshold = 
                p_ca_config_from_oam->ca_mac_scheduler_params.act_deact_trigger_count_threshold;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_ACT_DEACT_TRIG_COUNT_THRESH_PRESENT;
        }
        /* SPR 16422 START */
        if (RRM_OAM_CQI_VALIDITY_TIMER_PRESENT &
                p_ca_config_from_oam->ca_mac_scheduler_params.bitmask)
        {
            p_ca_config_to_cellm->ca_mac_scheduler_params.cqi_validity_timer= 
                p_ca_config_from_oam->ca_mac_scheduler_params.cqi_validity_timer;
            p_ca_config_to_cellm->ca_mac_scheduler_params.bitmask |=
                RRM_CQI_VALIDITY_TIMER_PRESENT;
        }  
        /* SPR 16422 END */
        p_ca_config_to_cellm->bitmask |= RRM_CA_MAC_SCHEDULER_PARAMS_INFO_PRESENT;
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA MAC Sheduler params is not present "); 
    }
    /*CA STAGE 2*/
    /*SPR 21206 +-*/
    if (RRM_OAM_MEAS_CYCLE_SCELL_PRESENT &
            p_ca_config_from_oam->bitmask)
    {
        p_ca_config_to_cellm->meas_cycle_scell =
            p_ca_config_from_oam->meas_cycle_scell;
        p_ca_config_to_cellm->bitmask |=
            RRM_CA_MEAS_CYCLE_SCELL_PRESENT;
    }
    else
    {
        p_ca_config_to_cellm->meas_cycle_scell =
            RRM_OAM_MEAS_CYCL_SCELL_SF512;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "CA meas_cycle_scell is not present setting default value to this parameter");
    }
    /*CA STAGE 2*/
    RRM_UT_TRACE_EXIT();
}
/* Carrier_Aggregation_End */
/*SPR 14227 start*/

/****************************************************************************
 * Function Name  : rrm_set_default_values_for_eicic_params
 * Inputs         : - eicic_info_config_to_cellm
 *                  - eicic_info_config_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill default values of eICIC params from for cell config
 *                  from OAM.
 ****************************************************************************/
rrm_void_t
rrm_set_default_values_for_eicic_params 
(
 rrm_eicic_info_t        *p_eicic_info_config_to_cellm
 /*SPR 17777 +-*/
 )
{
    RRM_ASSERT ( RRM_PNULL != p_eicic_info_config_to_cellm );
    /*SPR 17777 +-*/

    RRM_UT_TRACE_ENTER();

    p_eicic_info_config_to_cellm->bitmask = RRM_ZERO;

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "eICIC not provisioned assigning default value [%d]",RRM_OAM_EICIC_DEACTIVATED);
    p_eicic_info_config_to_cellm->eicic_provisioned_type = RRM_OAM_EICIC_DEACTIVATED;

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_ELIGIBLE_UE_PRESENT;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "ELIGIBLE_UE bitmask is not set, assigning default value [%d]", RRM_EICIC_ELIGIBLE_UE_DEFAULT_VALUE);
    p_eicic_info_config_to_cellm->eligible_ue = RRM_EICIC_ELIGIBLE_UE_DEFAULT_VALUE;

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
    rrm_fill_abs_info_default_values(&p_eicic_info_config_to_cellm->abs_info);

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT;
    rrm_fill_default_eicic_timer_info(&p_eicic_info_config_to_cellm->eicic_timer_info);

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "DL Sinr threshold low mark is not set, assigning default value [%d]",RRM_DL_SINR_THERSHOLD_DEFAULT_LOW_VALUE);
    p_eicic_info_config_to_cellm->dl_sinr_threshold_low_mark = RRM_DL_SINR_THERSHOLD_DEFAULT_LOW_VALUE;

    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "DL Sinr threshold high mark is not set, assigning default value [%d]",RRM_DL_SINR_THERSHOLD_DEFAULT_HIGH_VALUE);
    p_eicic_info_config_to_cellm->dl_sinr_threshold_high_mark = RRM_DL_SINR_THERSHOLD_DEFAULT_HIGH_VALUE;

    RRM_UT_TRACE_EXIT();
}
/*SPR 14227 end*/

/** eICIC feature changes start */
/****************************************************************************
 * Function Name  : rrm_fill_eicic_info_config_params
 * Inputs         : - eicic_info_config_to_cellm
 *                  - eicic_info_config_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the eICIC params from for cell config
 *                  from OAM.
 ****************************************************************************/
rrm_void_t
    rrm_fill_eicic_info_config_params 
(
 rrm_eicic_info_t        *p_eicic_info_config_to_cellm,
 rrm_oam_eicic_info_t    *p_eicic_info_config_from_oam
 )
{
    RRM_ASSERT ( RRM_PNULL != p_eicic_info_config_to_cellm );
    RRM_ASSERT ( RRM_PNULL != p_eicic_info_config_from_oam );

    RRM_UT_TRACE_ENTER();

    /** Filling is_eicic_provisioned parameter value which configured
      from OAM. Default value is 0 stands for deactivated eICIC */
    p_eicic_info_config_to_cellm->bitmask = RRM_ZERO;
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_PROVISIONED_TYPE_PRESENT;
    if (RRM_OAM_EICIC_PROVISIONED_TYPE_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        p_eicic_info_config_to_cellm->eicic_provisioned_type = p_eicic_info_config_from_oam->eicic_provisioned_type;
    }
    else
    {  /*SPR 14134 start*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "eICIC not provisioned assigning default value [%d]",RRM_OAM_EICIC_DEACTIVATED);
        /*SPR 14134 end*/ 
        p_eicic_info_config_to_cellm->eicic_provisioned_type = RRM_OAM_EICIC_DEACTIVATED;
    }
    /*SPR 14165 start*/
    //code deleted
    /*SPR 14165 end*/
    /*eICIC_changes_start*/
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_ELIGIBLE_UE_PRESENT;
    if( RRM_OAM_EICIC_ELIGIBLE_UE_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        p_eicic_info_config_to_cellm->eligible_ue = p_eicic_info_config_from_oam->eligible_ue;
    }   
    else
    {   /*SPR 14134 start*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "ELIGIBLE_UE bitmask is not set, assigning default value [%d]", RRM_EICIC_ELIGIBLE_UE_DEFAULT_VALUE);
        /*SPR 14134 end*/
        p_eicic_info_config_to_cellm->eligible_ue = RRM_EICIC_ELIGIBLE_UE_DEFAULT_VALUE;
    }    
    /*eICIC_changes_end*/
    /** Filling ABS information */
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_ABS_INFO_PRESENT;
    if(RRM_OAM_ABS_INFO_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        rrm_fill_abs_info(&p_eicic_info_config_to_cellm->abs_info,
                &p_eicic_info_config_from_oam->abs_info);
    }
    else
        /** Filling default values for ABS information */
        /*eicic ut fix 23Sept2014 start*/
    {
        rrm_fill_abs_info_default_values(&p_eicic_info_config_to_cellm->abs_info);
    }
    /*eicic ut fix 23Sept2014 end*/
    /** Filling eICIC timer information */
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_EICIC_TIMER_INFO_PRESENT;
    if(RRM_OAM_EICIC_TIMER_INFO_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        rrm_fill_eicic_timer_info(&p_eicic_info_config_to_cellm->eicic_timer_info,
                &p_eicic_info_config_from_oam->eicic_timer_info);
    }
    /*eicic ut fix 23Sept2014 start*/
    else
    {
        rrm_fill_default_eicic_timer_info(&p_eicic_info_config_to_cellm->eicic_timer_info);
    } 
    /*eicic ut fix 23Sept2014 end*/

    /** Filling dl_sinr_threshold_low_mark value configured from OAM,
      Default value is 50 */
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_LOW_MARK_PRESENT;
    if(RRM_OAM_DL_SINR_THRESHOLD_LOW_MARK_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        p_eicic_info_config_to_cellm->dl_sinr_threshold_low_mark =
            p_eicic_info_config_from_oam->dl_sinr_threshold_low_mark;
    }
    else
    {   /*SPR 14134 start*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "DL Sinr threshold low mark is not set, assigning default value [%d]",RRM_DL_SINR_THERSHOLD_DEFAULT_LOW_VALUE);
        /*SPR 14134 end*/
        p_eicic_info_config_to_cellm->dl_sinr_threshold_low_mark = RRM_DL_SINR_THERSHOLD_DEFAULT_LOW_VALUE;
    }
    /** Filling dl_sinr_threshold_low_mark value configured from OAM,
      Default value is 90 */
    p_eicic_info_config_to_cellm->bitmask |= RRMCM_RMIF_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT;
    if(RRM_OAM_DL_SINR_THRESHOLD_HIGH_MARK_PRESENT & p_eicic_info_config_from_oam->bitmask)
    {
        p_eicic_info_config_to_cellm->dl_sinr_threshold_high_mark =
            p_eicic_info_config_from_oam->dl_sinr_threshold_high_mark;
    }
    else
    {   /*SPR 14134 start*/
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "DL Sinr threshold high mark is not set, assigning default value [%d]",RRM_DL_SINR_THERSHOLD_DEFAULT_HIGH_VALUE);
        /*SPR 14134 end*/
        p_eicic_info_config_to_cellm->dl_sinr_threshold_high_mark = RRM_DL_SINR_THERSHOLD_DEFAULT_HIGH_VALUE;
    }
    RRM_UT_TRACE_EXIT();
}
/** eICIC feature changes end */

/****************************************************************************
 * Function Name  : fill_operator_info_for_cell_config
 * Inputs         : - p_operator_cfg_params
 *                  - p_operator_info_to_cellm
 *                  - p_operator_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Operator info for CellM Module
 ****************************************************************************/
 /* SPR 20653 Fix Start */
void fill_operator_info_for_cell_config(operator_info_t            *p_operator_info_to_cellm,
        rrm_oam_operator_info_t    *p_operator_info_from_oam,
        /*SPR 17777 +-*/
        rrm_oam_rf_params_t        *p_rf_params_from_oam,
        rrm_oam_physical_layer_params_t *p_plp_params_from_oam,
        /* SPR 18641_18843 fix start */
        rrm_oam_mac_layer_params_t      *p_mac_layer_params_from_oam,
        U8 tti_bundling_info_present)
 /* SPR 20653 Fix End */
/* SPR 18641_18843 fix end */
{
  
/* NR_REP_CONFIG_FIX_START */
  U8       pci_count = RRM_ZERO;
/* NR_REP_CONFIG_FIX_END */
  RRM_ASSERT (RRM_PNULL != p_operator_info_to_cellm);
  RRM_ASSERT (RRM_PNULL != p_operator_info_from_oam);
  /* SPR Fix 17928 Start */
  /* Code Deleted */
  /* SPR Fix 17928 Snd */
  RRM_ASSERT (RRM_PNULL != p_rf_params_from_oam);
  RRM_ASSERT (RRM_PNULL != p_plp_params_from_oam);

  RRM_UT_TRACE_ENTER();

  /* Populationg Operator Info */
  RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populationg Operator Info");


  /*Populating Cell Params */
  p_operator_info_to_cellm->cell_params.sub_carrier_spacing = 
      p_operator_info_from_oam->additional_cell_params.sub_carrier_spacing;
  p_operator_info_to_cellm->cell_params.dl_cyclic_prefix = 
      p_operator_info_from_oam->additional_cell_params.dl_cyclic_prefix;
  /* SPR 20653 Fix Start */
  /* Additional parameters for Cell Config Added STARTS*/
  if(p_rf_params_from_oam->rf_configurations.bitmask & RRM_OAM_MAX_RS_EPRE_PRESENT)
  {
      p_operator_info_to_cellm->cell_params.max_rs_epre = 
          p_rf_params_from_oam->rf_configurations.max_rs_epre;
  }
  else
  {
      p_operator_info_to_cellm->cell_params.max_rs_epre = RRM_DEFINED_DEFAULT_VALUE_FOR_MAX_RS_EPRE;
  }
  /* SPR 20653 Fix End */
  /*SPR 21206 Start*/
  if(p_operator_info_from_oam->bitmask & RRM_OAM_ASSOCIATED_LAYER2_INST_FIELD_PRESENT)
  {

      p_operator_info_to_cellm->l2_instance = 
          p_operator_info_from_oam->associated_layer2_inst;
  }
  /*SPR 21206 End*/

  /* Additional parameters for Cell Config Added ENDS*/
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADD_CELL_PARAMS_PRESENT;

  /*Populating load congestion params*/
  p_operator_info_to_cellm->load_congestion_cfg.overload.bitmask |= RRMCM_RMIF_PERCNTG_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.overload.bitmask |= RRMCM_RMIF_ACTION_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.overload.bitmask |= RRMCM_RMIF_NUM_USR_PRESENT;

  p_operator_info_to_cellm->load_congestion_cfg.highload.bitmask |= RRMCM_RMIF_PERCNTG_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.highload.bitmask |= RRMCM_RMIF_ACTION_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.highload.bitmask |= RRMCM_RMIF_NUM_USR_PRESENT;

  p_operator_info_to_cellm->load_congestion_cfg.midload.bitmask |= RRMCM_RMIF_PERCNTG_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.midload.bitmask |= RRMCM_RMIF_ACTION_PRESENT;
  p_operator_info_to_cellm->load_congestion_cfg.midload.bitmask |= RRMCM_RMIF_NUM_USR_PRESENT;

  p_operator_info_to_cellm->load_congestion_cfg.soft_lmt =
      RRM_DEFINED_DEFAULT_VALUE_FOR_SOFT_LMT;
  p_operator_info_to_cellm->load_congestion_cfg.high_actn_applied_lmt =
      RRM_DEFINED_DEFAULT_VALUE_FOR_HIGH_ACTN_APPLIED_LMT;
  p_operator_info_to_cellm->load_congestion_cfg.ld_process_timer =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LD_PROCESS_TIMER;

  p_operator_info_to_cellm->load_congestion_cfg.overload.load_perctg =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_PERCENTAGE_OVER;
  p_operator_info_to_cellm->load_congestion_cfg.overload.action =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_ACTION_OVER;
  p_operator_info_to_cellm->load_congestion_cfg.overload.num_usr =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_NUM_USER;

  p_operator_info_to_cellm->load_congestion_cfg.highload.load_perctg =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_PERCENTAGE_HIGH;
  p_operator_info_to_cellm->load_congestion_cfg.highload.action =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_ACTION_HIGH;
  p_operator_info_to_cellm->load_congestion_cfg.highload.num_usr =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_NUM_USER;

  p_operator_info_to_cellm->load_congestion_cfg.midload.load_perctg =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_PERCENTAGE_MID;
  p_operator_info_to_cellm->load_congestion_cfg.midload.action =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_ACTION_MID;
  p_operator_info_to_cellm->load_congestion_cfg.midload.num_usr =
      RRM_DEFINED_DEFAULT_VALUE_FOR_LOAD_NUM_USER;

  /* Populating Mac Config Params*/
  /* CHANGES_FRM_XML_TO_CFG START */
    /* BUG_371 FIX START */ 
    /* SPR 7283 Fix Start */
    /* SPR 20653 Fix Start */
    populate_operator_mac_param_for_cell_config(p_operator_info_to_cellm , p_operator_info_from_oam, p_mac_layer_params_from_oam);
    /* SPR 20653 Fix End */

    /* BUG_371 FIX END */ 
  
    /* SPR 20653 Fix Start */
    p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
        pcfichPowerOffset = p_rf_params_from_oam->rf_configurations.pcfichPowerOffset; 

    p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
        phichPowerOffset = p_rf_params_from_oam->rf_configurations.phichPowerOffset; 

    p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
        pdcchPowerOffset = p_rf_params_from_oam->rf_configurations.pdcchPowerOffset;

    p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
        pbchTransmissionPower = p_rf_params_from_oam->rf_configurations.pbchTransmissionPower;

    p_operator_info_to_cellm->rrm_mac_config.mac_downlink_power_control_common.
        pchTransmissionpower = p_rf_params_from_oam->rf_configurations.pchTransmissionpower;
    /* SPR 20653 Fix End */
    /* CHANGES_FRM_XML_TO_CFG END */
    p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_CONFIG_PRESENT ;


  /* Populating phich_config Params*/
  p_operator_info_to_cellm->phich_config.phich_resource= 
          p_operator_info_from_oam->phich_config.phich_resource;

  p_operator_info_to_cellm->phich_config.phich_duration= 
      p_operator_info_from_oam->phich_config.phich_duration;
  
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_PHICH_CONFIG_PRESENT;
  /* SPR 20653 Fix Start */
  p_operator_info_to_cellm->contention_free_rach_timer =
      p_mac_layer_params_from_oam->mac_layer_param_rach.contention_free_rach_timer;
  /* Populating sib_1_info */
    /* BUG_371 FIX START */ 
    populate_operator_sib1_info(p_operator_info_from_oam ,
            p_operator_info_to_cellm); 
    /* BUG_371 FIX END */ 
    p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_1_INFO_PRESENT;

    /* Populating SIB2 Info */  
    populate_operator_sib2_info(p_operator_info_to_cellm ,
            p_operator_info_from_oam , 
            p_rf_params_from_oam->rf_configurations.ul_bandwidth);
    /* BUG_371 FIX START */ 
    populate_operator_sib2_ul_power_ctrl_info(p_operator_info_to_cellm ,p_operator_info_from_oam);
    /* BUG_371 FIX END */
    p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_2_INFO_PRESENT;


    /* Populating SIB3*/ 
    populate_operator_sib3_info(p_operator_info_to_cellm , p_operator_info_from_oam);
    p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_3_INFO_PRESENT;
    /*Rel 10 CR changes-36331.553*/
    if((p_operator_info_to_cellm->sib_3_info.bitmask & RRMCM_RMIF_THRESHOLD_SERVING_LOW_PRESENT) &&
            !(p_operator_info_to_cellm->sib_1_info.bitmask & RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT))
    {
        p_operator_info_to_cellm->sib_1_info.bitmask |= RRMCM_RMIF_CELL_SELECTION_INFO_R9_PRESENT;
        p_operator_info_to_cellm->sib_1_info.cell_selection_info.q_qual_min_r9 =
            p_operator_info_from_oam->sib_1_info.cell_selection_info.q_qual_min_r9;
        if(p_operator_info_from_oam->sib_1_info.cell_selection_info.bitmask & RRM_OAM_Q_QUAL_MIN_OFFSET_R9_PRESENT)
        {
            p_operator_info_to_cellm->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present =
                p_operator_info_from_oam->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present;
            p_operator_info_to_cellm->sib_1_info.cell_selection_info.bitmask |= RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT;
        }
        else
        {
            p_operator_info_to_cellm->sib_1_info.cell_selection_info.q_qual_min_offset_r9_present =
               RRM_DEFINED_DEFAULT_VALUE_FOR_Q_QUAL_MIN_OFFSET_R9_PRESENT;
            p_operator_info_to_cellm->sib_1_info.cell_selection_info.bitmask |= RRMCM_RMIF_Q_QUAL_MIN_OFFSET_R9_PRESENT;
        }
        /* SPR 20653 Fix End */

    }
    /*Rel 10 CR changes-36331.553*/


    if(p_operator_info_from_oam->bitmask & RRM_OAM_ADDL_SIB4_INFO_PRESENT)
    {
        /* BUG_11575_CHANGES_START */
        /* Populating SIB4*/
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SIB_4_INFO_PRESENT;
        p_operator_info_to_cellm->sib_4_info.csg_id_range.bitmask = 0x00;
        p_operator_info_to_cellm->sib_4_info.csg_id_range.start=
            p_operator_info_from_oam->sib_4_info.csg_id_range.start;

        if (p_operator_info_from_oam->sib_4_info.csg_id_range.bitmask&
                RRM_OAM_CELL_ID_RANGE_PRESENT)
        {
            p_operator_info_to_cellm->sib_4_info.csg_id_range.bitmask |=
                RRMCM_RMIF_CELL_ID_RANGE_PRESENT;
            p_operator_info_to_cellm->sib_4_info.csg_id_range.range=
                p_operator_info_from_oam->sib_4_info.csg_id_range.range;
        }
        /* BUG_11575_CHANGES_END */
    }
  /* SPR 20653 Fix Start */
  p_operator_info_to_cellm->cell_params.rb_size = 
      p_rf_params_from_oam->rf_configurations.rb_size;
  /* SPR 20653 Fix End */

    /* Populating admission Control Info */

    populate_operator_admsn_control_info_for_cell_config(p_operator_info_to_cellm , p_operator_info_from_oam , 
            /*SPR 17777 +-*/
            /* SPR 20653 Fix Start */
            p_plp_params_from_oam ,
            /* SPR 20653 Fix End */
     /*SPR 17777 +-*/
          p_rf_params_from_oam->rf_configurations.dl_bandwidth);
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ADDMISION_CONTROL_INFO_PRESENT;
  /* SPR 20653 Fix Start */
  /* Code Removed */
  /* SPR 20653 Fix End */
  /* HO config params start*/
  if(p_operator_info_from_oam->bitmask & RRM_OAM_HO_CONFIGURATION_PRESENT)
  {
      populate_ho_config_params_info(p_operator_info_to_cellm, p_operator_info_from_oam);
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT; 
  }
  /* Bug 4618 start */
  else
  {
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_HO_CONFIG_PARAMS_PRESENT;
      p_operator_info_to_cellm->ho_config_params.bitmask |= RRMCM_RMIF_HO_RETRY_PARAMS_PRESENT;
      /* SPR 22311 Changes - Starts */
      /* Code Deleted */
      /* SPR 22311 Changes - Ends */
      p_operator_info_to_cellm->ho_config_params.ho_retry_params.ho_retry_count= RRM_ONE;
  }
  /* Bug 4618 end */
  /* HO config params end */

  /* Inter RAT changes start */
  if(p_operator_info_from_oam->bitmask & RRM_OAM_MEASUREMENT_CONFIG_PRESENT)
  {
    populate_meas_config_info(p_operator_info_to_cellm, p_operator_info_from_oam);
    p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MEASUREMENT_CONFIG_PRESENT;
  }
  /* Inter RAT changes end */
  /* GERAN cell configurations */
  populate_operator_geran_cell_info(p_operator_info_to_cellm);
  populate_operator_cdma_cell_info(p_operator_info_to_cellm);
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_FREQ_PRIORITY_LIST;


/* HO Oscillation Start*/
  /* SPR 20653 Fix Start */
  populate_ho_oscillation_cfg_info_for_cell_config(p_operator_info_to_cellm,
                                            &p_operator_info_from_oam->ho_configuration.ho_oscillation_cfg);
  /* SPR 20653 Fix End */
/* HO Oscillation End*/


  /* HO Enh start */
            /* SPR 20653 Fix Start */
  populate_rat_priority_info(p_operator_info_to_cellm, p_operator_info_from_oam);
            /* SPR 20653 Fix End */
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_RAT_PRIORITY_INFO_CFG_PRESENT;
  /* HO Enh end */
/* HO Oscillation Start*/
  /* SPR 20653 Fix Start */
  /* Code Removed */
  /* SPR 20653 Fix End */
  p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_RAT_PRIORITY_INFO_CFG_PRESENT;
  /* HO Enh end */
  /* Not populating from Static Config file.. reading from rrm_oam.cfg
  RRM_MEMCPY(
		&(p_operator_info_to_cellm->priority_cfg),
		&(p_operator_info_from_oam->priority_cfg),
		sizeof(rrm_priority_cfg_t));*/

  /* SPR 20653 Fix Start */
  /* Code Removed */
  /* SPR 20653 Fix End */

  /* SPS related changes start */
  /* + SPS_TDD_Changes */
  /* Code removed as this is for FDD and TDD both*/
  /* - SPS_TDD_Changes */
  if (p_operator_info_from_oam->bitmask & RRM_OAM_SPS_CRNTI_RANGE_PRESENT)
  {
      p_operator_info_to_cellm->sps_crnti_range_info.start_sps_crnti_range =
          p_operator_info_from_oam->rrm_sps_crnti_range.start_sps_crnti_range;

      p_operator_info_to_cellm->sps_crnti_range_info.end_sps_crnti_range =
          p_operator_info_from_oam->rrm_sps_crnti_range.end_sps_crnti_range;

      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SPS_CRNTI_RANGE_PRESENT;
  }
  /* SPS related changes end */

/* DYNAMIC ICIC START */
    if(p_operator_info_from_oam->bitmask & RRM_OAM_DYNAMIC_ICIC_INFO_PRESENT)
    {
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_DYNAMIC_ICIC_INFO_PRESENT; 
 /* SPR 20653 Fix Start */ 
        populate_dynamic_icic_periodicity_info(p_operator_info_to_cellm,
                                &p_operator_info_from_oam->dynamic_icic_info.report_config_info);
        populate_dynamic_icic_info(&p_operator_info_to_cellm->dynamic_icic_info , 
                &p_operator_info_from_oam->dynamic_icic_info,
                p_plp_params_from_oam->physical_layer_param_ul_power_control.alpha); 
 /* SPR 20653 Fix End */ 
    }                               
    /* DYNAMIC ICIC END   */

  /* UE positioning start */
  if (p_operator_info_from_oam->bitmask & RRM_OAM_EUTRAN_ACCESS_POINT_POS_PRESENT)
  {
      populate_eutran_access_point_pos_params(&p_operator_info_from_oam->rrm_eutran_access_point_pos, 
                                              &p_operator_info_to_cellm->eutran_access_point_pos);
      
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_EUTRAN_ACCESS_POINT_POS_PRESENT;
  }
  /* UE positioning end */

  /* SPR 20653 Fix Start */
  rrm_fill_beamforming_info(p_operator_info_from_oam,
                             p_operator_info_to_cellm );

  rrm_fill_tm_mode_additional_info( &p_operator_info_from_oam->mimo_mode_params.rrm_tm_mode_additional_info,
                                    p_operator_info_to_cellm);
  /* SPR 20653 Fix End */

  if( p_operator_info_from_oam->mimo_mode_params.bitmask
             & RRM_OAM_TRANSMISSION_MODE_TABLE_PRESENT )
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
      " transmission mode table bitmask is present");

      populate_tm_mode_table( &p_operator_info_from_oam->mimo_mode_params.tm_mode_table,
                              &p_operator_info_to_cellm->rrm_tm_mode_table );
 
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_TRANSMISSION_MODE_TABLE_PRESENT;
  }

  if( RRM_OAM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT & p_operator_info_from_oam->bitmask )
  {
      rrm_fill_dynamic_ue_scheduling( &(p_operator_info_from_oam->rrm_ue_scheduling_info),
                                      &(p_operator_info_to_cellm->rrm_ue_scheduling_info) );
      p_operator_info_to_cellm->bitmask |= RRM_DYNAMIC_UE_SCHEDULING_INFO_PRESENT;
  }
  else
  {
     RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
     "Dynamic UE scheduling info is not coming from OAM in cell config");
  }
  /*spr 7984 start*/
  if(RRM_OAM_ENABLE_CQI_MASK_R9_PRESENT & p_operator_info_from_oam->bitmask)
  {
      switch(p_operator_info_from_oam->rrm_enable_cqi_mask_r9)
      {
          case RRM_ZERO:
              p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
              break;
          case RRM_ONE:
              p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_TRUE;
              break;
          default:
              p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
              RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                      "Invalid value[%d] received for rrm_enable_cqi_mask_r9, setting it to false",
                      p_operator_info_from_oam->rrm_enable_cqi_mask_r9);
      }
  }
  else
  {
      p_operator_info_to_cellm->rrm_enable_cqi_mask_r9=RRM_FALSE;
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
              "rrm_enable_cqi_mask_r9 is not coming from OAM in cell config"
              " setting it as false");
  }
  /*spr 7984 end*/
  /* Carrier_Aggregation_Start */
  /* CID 86724 Start */
  if (RRM_OAM_CA_CONFIG_INFO_PRESENT & p_operator_info_from_oam->bitmask)
  {
      rrm_fill_ca_config_params (&(p_operator_info_to_cellm->ca_config),
              &(p_operator_info_from_oam->ca_config));
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_CA_CONFIG_INFO_PRESENT;    
  }
  else
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
              "CA info is not present in cell config req from OAM");
  }
  /* Carrier_Aggregation_End */

  if (p_operator_info_from_oam->bitmask & RRM_OAM_SUBBAND_CQI_PARAM_PRESENT)
  {
      p_operator_info_to_cellm->k = p_operator_info_from_oam->k;
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PRESENT;
  }
  if (p_operator_info_from_oam->bitmask & RRM_OAM_SUBBAND_CQI_PERIODICTY_FACTOR_R10_PRESENT)
  {
      switch(p_operator_info_from_oam->periodicity_factor)
      {
          case RRM_OAM_PERIODCITY_FACTOR_N2: 
              p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N2;
              break;
          case RRM_OAM_PERIODCITY_FACTOR_N4:
              p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N4;
              break;
          default:
              p_operator_info_to_cellm->periodicity_factor = RRMCM_PERIODICTY_FACTOR_N2;
              break;

      }
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_SUBBAND_CQI_PERIODCITY_FACTOR_PRESENT;
  }
  /** eICIC feature changes start */
  if (p_operator_info_from_oam->bitmask & RRM_OAM_EICIC_INFO_PRESENT)
  {
      rrm_fill_eicic_info_config_params(&(p_operator_info_to_cellm->eicic_info),
              &(p_operator_info_from_oam->eicic_info));
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
  }
  else
  {    
      /*SPR 14227 start*/
      rrm_set_default_values_for_eicic_params(&(p_operator_info_to_cellm->eicic_info));
      /*SPR 17777 +-*/
      /*SPR 14399 start*/
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_EICIC_INFO_PRESENT;
      /*SPR 14399 end*/
      /*SPR 14227 end*/
  }
  /** eICIC feature changes end */
#ifdef LTE_EMBMS_SUPPORTED
/* SPR 22248 MBMS Changes Start */ 
mbms_notif_rep_coeff_et p_notif_rep_coeff = MBMS_NOTIF_REP_COEFF_N4;
/* SPR 18334 : START */
    rrm_fill_sib_13_info_config_params(&(p_operator_info_to_cellm->sib_13_info),
                                       p_notif_rep_coeff);
/* SPR 22248 MBMS Changes Stop */
    /* SPR 18334 : END */
    if (RRM_OAM_EMBMS_POWER_INFO_PRESENT & p_operator_info_from_oam->bitmask )
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "EMBMS Power Info is present in cell config from OAM");
        RRM_MEMCPY(&(p_operator_info_to_cellm->mbms_power_info),
                &(p_operator_info_from_oam->mbms_power_info),
                sizeof(rrm_oam_mbms_power_info_t));
        p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_MBMS_POWER_INFO_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "cell_pwer_offset[%d], transmission_power[%d]",
                p_operator_info_to_cellm->mbms_power_info.cell_pwer_offset,
                p_operator_info_to_cellm->mbms_power_info.transmission_power);
    } 
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "EMBMS Power Info is not present in cell config from OAM",
                "eMBMS is enabled");
    }


#endif
  /* SPR 18641_18843 fix start */
  if(tti_bundling_info_present)
  {
      if(RRM_OAM_TTI_BUNDLING_INFO_PRESENT & p_operator_info_from_oam->bitmask) 
      {
          p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_actv_tti = 
              p_operator_info_from_oam->tti_bundling_info.ul_sinr_threshold_to_actv_tti; 

          p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_deactv_tti = 
              p_operator_info_from_oam->tti_bundling_info.ul_sinr_threshold_to_deactv_tti; 

          p_operator_info_to_cellm->tti_bundling_info.rrm_ue_used_rb_threshold = 
              p_operator_info_from_oam->tti_bundling_info.rrm_ue_used_rb_threshold;

          p_operator_info_to_cellm->bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_TTI_BUNDLING_INFO_PRESENT;

          RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "ul_sinr_threshold_to_actv_tti [%d]",
                  p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_actv_tti);
          RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "ul_sinr_threshold_to_deactv_tti[%d]",
                  p_operator_info_to_cellm->tti_bundling_info.ul_sinr_threshold_to_deactv_tti);
          RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "rrm_ue_used_rb_threshold[%d]",
                  p_operator_info_to_cellm->tti_bundling_info.rrm_ue_used_rb_threshold);
      }
      else
      {
          RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                  "TTI bundling is enabled but bitmask RRM_OAM_TTI_BUNDLING_INFO_PRESENT is not set, Invalid Params received\n");
      }    
  }    
  else
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,"TTI bundling is disabled\n");
  }    
  /* SPR 18641_18843 fix end */
#ifdef ENDC_ENABLED
  if( RRM_OAM_ENDC_INFO_PRESENT & p_operator_info_from_oam->bitmask)
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_INFO,
              "SGNB AMBR Share  received from OAM ");
      /*Set bitmask for cellM interface */
      p_operator_info_to_cellm->bitmask |= RRMCM_RMIF_ENDC_INFO_PRESENT;

      p_operator_info_to_cellm->endc_info.sgnb_ambr_share = p_operator_info_from_oam->endc_info.sgnb_ambr_share;
      p_operator_info_to_cellm->endc_info.min_num_ue_thp_report = p_operator_info_from_oam->endc_info.min_num_ue_thp_report;
      p_operator_info_to_cellm->endc_info.is_ma_sgnb_addition = p_operator_info_from_oam->endc_info.is_ma_sgnb_addition;
      p_operator_info_to_cellm->endc_info.bearer_throughput_threshold_ul = p_operator_info_from_oam->endc_info.bearer_throughput_threshold_ul;
      p_operator_info_to_cellm->endc_info.bearer_throughput_threshold_dl = p_operator_info_from_oam->endc_info.bearer_throughput_threshold_dl;
      p_operator_info_to_cellm->endc_info.endc_sinr_thershold_ul = p_operator_info_from_oam->endc_info.endc_sinr_thershold_ul;
      p_operator_info_to_cellm->endc_info.endc_sinr_thershold_dl = p_operator_info_from_oam->endc_info.endc_sinr_thershold_dl;
      p_operator_info_to_cellm->endc_info.endc_bler_thershold_ul = p_operator_info_from_oam->endc_info.endc_bler_thershold_ul;
      p_operator_info_to_cellm->endc_info.endc_bler_thershold_dl = p_operator_info_from_oam->endc_info.endc_bler_thershold_dl;
      p_operator_info_to_cellm->endc_info.max_meas_freq_scg_nr =
          p_operator_info_from_oam->endc_info.max_meas_freq_scg_nr;

      p_operator_info_to_cellm->endc_info.max_meas_id_scg_nr =
          p_operator_info_from_oam->endc_info.max_meas_id_scg_nr;
  /* NR_REP_CONFIG_FIX_START */
       p_operator_info_to_cellm->endc_info.peer_gnb_pci_list.count =
               p_operator_info_from_oam->endc_info.peer_gnb_pci_list.count;
       for(pci_count = RRM_ZERO ; 
              pci_count < p_operator_info_to_cellm->endc_info.peer_gnb_pci_list.count;
              pci_count++)
       {
          p_operator_info_to_cellm->endc_info.peer_gnb_pci_list.\
                  peer_gnb_pci[pci_count].nr_pci = 
          p_operator_info_from_oam->endc_info.peer_gnb_pci_list. \
                  nr_pci[pci_count];
  
          p_operator_info_to_cellm->endc_info.peer_gnb_pci_list.\
                  peer_gnb_pci[pci_count].is_valid = RRM_ZERO; 
       }
/* NR_REP_CONFIG_FIX_END */
}
#endif
}

/*Cov_fix_64292_start*/
/****************************************************************************
 * Function Name  : fill_epc_info_for_cell_config
 * Inputs         : - p_epc_info_to_cellm
 *                  - p_epc_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the EPC info for CellM Module
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_epc_info_for_cell_config(
        epc_t                        *p_epc_info_to_cellm, 
        rrm_oam_epc_t                *p_epc_info_from_oam,
        /* SPR 18641_18843 fix start */
        rrm_oam_ran_t                *p_ran_info_from_oam,
        U8                           *p_tti_bundling_info_present)
/* SPR 20653 Fix End */
/* SPR 18641_18843 fix end */
{
    U16 plmn_count= RRM_ZERO;
    U16 tac_count = RRM_ZERO;
    U16 eaid_count= RRM_ZERO;
    U16 qos_count = RRM_ZERO;
    /* SPS related changes start */
    /* + SPS_TDD_Changes */
    /*Code removed as this is for both FDD and TDD*/
    /* - SPS_TDD_Changes */
    U8 qci_val = RRM_ZERO;
    /* SPS related changes end */

    RRM_ASSERT (RRM_PNULL != p_epc_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_epc_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating EPC Info");

    /* Initialize the bitmask */
    p_epc_info_to_cellm->epc_params.bitmask = 0x00;

    /* epc general params - start */
    p_epc_info_to_cellm->epc_params.general_epc_params.bitmask = 0x00;

    p_epc_info_to_cellm->epc_params.general_epc_params.num_valid_plmn= 
        p_epc_info_from_oam->epc_params.general_epc_params.num_valid_plmn;  

    p_epc_info_to_cellm->epc_params.general_epc_params.num_valid_plmn= 
        p_epc_info_from_oam->epc_params.general_epc_params.num_valid_plmn;  

    /* PLMN INFO*/
    for (plmn_count=0; 
            ((plmn_count < p_epc_info_to_cellm->epc_params.general_epc_params.
              num_valid_plmn)&& (plmn_count < MAX_PLMN_LIST)); 
            plmn_count++)
    {
        /* SPR 10730 Fix Start */
        fill_cell_plmn_info(
                &p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].plmn_id, 
                &p_epc_info_from_oam->epc_params.general_epc_params.plmn_list[plmn_count].plmn_info);
        p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
            cell_reserved_for_operator_use = p_epc_info_from_oam->epc_params.
            general_epc_params.plmn_list[plmn_count].reserve_operator_use;

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "Reserved Cell for Operator[%d]",
                p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
                cell_reserved_for_operator_use);

        p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask =
            0x00;
        p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask |=
            RRMCM_RMIF_CELL_RESERVED_FOR_OPERATOR_USE_PRESENT;
        /* SPR 10730 Fix End */
        /* SPR 23209 FIXED START*/
        if( p_epc_info_from_oam->epc_params.general_epc_params.plmn_list[plmn_count].bitmask
                & RRM_OAM_MOCN_OPERATOR_IDENTITY_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].bitmask |=
                RRMCM_RMIF_MOCN_OPERATOR_INDENTITY_PRESENT;

            p_epc_info_to_cellm->epc_params.general_epc_params.
                plmn_list[plmn_count].mocn_operator_identity =
                p_epc_info_from_oam->epc_params.general_epc_params.
                plmn_list[plmn_count].mocn_operator_identity;

            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "MOCN Operator ID for Operator[%d]",
                    p_epc_info_to_cellm->epc_params.general_epc_params.plmn_list[plmn_count].
                    mocn_operator_identity);
        }
        /* SPR 23209 FIXED END*/
    }

    /*tac*/
    for (tac_count=0; tac_count< MAX_TAC_SIZE; tac_count++)
    {
        p_epc_info_to_cellm->epc_params.general_epc_params.tac[tac_count]=
            p_epc_info_from_oam->epc_params.general_epc_params.tac[tac_count];   
    }

    /*eaid*/
    if (p_epc_info_from_oam->epc_params.general_epc_params.bitmask & 
            RRM_OAM_EMERGENCY_AREA_ID_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_EMERGENCY_AREA_ID_PRESENT");
        for (eaid_count=0; eaid_count< MAX_EAID; eaid_count++)
        {
            p_epc_info_to_cellm->epc_params.general_epc_params.eaid[eaid_count]=
                p_epc_info_from_oam->epc_params.general_epc_params.eaid[eaid_count];
        }
        p_epc_info_to_cellm->epc_params.general_epc_params.bitmask |=
            RRMCM_RMIF_EA_ID_PRESENT;

    }/* general epc params - end */

    p_epc_info_to_cellm->epc_params.bitmask |= RRMCM_RMIF_GENERAL_EPC_PARAMS_PRESENT;


    /*qos info - start*/
    p_epc_info_to_cellm->epc_params.num_valid_qos_profiles = 
        p_epc_info_from_oam->epc_params.num_valid_qos_profiles;  
    for (qos_count=0; 
            ((qos_count<p_epc_info_to_cellm->epc_params.num_valid_qos_profiles)&&
             (qos_count<RRM_MAX_QCI) ); qos_count++)
    {
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].qci;

        if (  p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_DSCP_PRESENT )
        { 
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_DSCP_PRESENT");
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].dscp=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].dscp;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask|= 
                RRMCM_RMIF_DSCP_PRESENT;
        }
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_LOSSLESS_HO_REQ_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].lossless_ho_required=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].lossless_ho_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_LOSSLESS_HO_REQ_PRESNET;

        }
        /*BUG_11564_CHANGES_START*/
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_DL_FWDING_APPLICABLE)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].dl_forwarding_applicability =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].dl_forwarding_applicability;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_DL_FWDING_PRESENT;

        }
        /*BUG_11564_CHANGES_END*/
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_UE_INACTIVE_TIMER_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].ue_inactivity_timer_config=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].ue_inactivity_timer_config;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_UE_INACTIVE_TIMER_PRESENT;
        }
        /*For limiting UE measurement start*/
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SUPPORTED_RAT_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].supported_rat=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].supported_rat;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SUPPORTED_RAT_PRESENT;
        }
        /*For limiting UE measurement end*/

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].type =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].type;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].priority=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].priority;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].packet_delay_budget=
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].packet_delay_budget;

        /* Loss-less data transfer changes start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].lossless_ho_required = 
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].lossless_ho_required;
        /* Loss-less data transfer changes end */

        /*For limiting UE measurement*/
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].supported_rat =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].supported_rat;

        /*Added for RCC*/
        if (RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT == (p_epc_info_from_oam->epc_params.
                    qos_config_params[qos_count].bitmask & RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT))
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "RRM_OAM_PACKET_ERROR_LOSS_RATE_PRESENT");
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].packet_error_loss_rate = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].packet_error_loss_rate;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |= 
                RRMCM_RMIF_PACKET_ERROR_LOSS_PRESENT;
        }

        /* erb service profile - start*/ 
        /* pdcp_config - start */
        /* SPR 20653 Fix Start */ 
        if ( p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_RLC_MODE_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                data_transfer_mode = p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_mode;
        }
        if((p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                    RRM_OAM_PDCP_ROHC_PARAMS_PRESENT) &&
                (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.bitmask & 
                 RRM_OAM_ROHC_ENABLE_PRESENT))
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                enable_rohc = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.enable_rohc;
        }
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
            pdcp_config.bitmask = 0x00;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_DISCARD_TIMER_ERB_SERVICE_PROFILE_PRESENT;

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_PDCP_DISCARD_TIMER_PRESENT ) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                pdcp_config.discard_timer=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].pdcp_discard_timer;
        }
        /* Code Removed */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_AM_STATUS_REPORT_REQ_ERB_SERVICE_PROFILE_PRESENT;
        /* Code Removed */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_RLC_AM_STATUS_REPORT_PRESENT) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                rlc_am_status_report_required = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_am_status_report_required;
        }
        /* Code Removed */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_AM_ENB_STATUS_REPORT_REQ_ERB_SERVICE_PROFILE_PRESENT;
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_RLC_AM_ENB_STATUS_REPORT_PRESENT) 
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                rlc_am_enb_status_report_required =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rlc_am_enb_status_report_required;
        }
        /* Code Removed */

        /* CHANGES_FRM_XML_TO_CFG END*/


        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
            header_compression.bitmask = 0x00;


        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.enable_rohc == RRM_TRUE)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_1_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0001 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0001;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_2_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0002 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0002;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_3_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0003 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0003;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_4_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0004 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0004;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_6_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0006 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0006;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_101_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0101 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0101;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_102_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0102 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0102;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask &
                    RRM_OAM_ROHC_PROFILE_103_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0103 = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0103;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.bitmask & 
                    RRM_OAM_ROHC_PROFILE_104_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.rohc_profile.profile0x0104 =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.rohc_profiles.rohc_profile0x0104;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.bitmask & RRM_OAM_ROHC_MAX_CID_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                    header_compression.rohc_config.max_cid = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].rohc_params.max_cid;
            }
            /* Code Removed */
            /* SPR 20653 Fix End */ 
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                header_compression.bitmask |= RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_ERB_SERVICE_PROFILE_PRESENT;
        }
        else
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.
                header_compression.bitmask = 0x00;
        }

        /* pdcp_config - end */

        /* rlc_config - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask = 0x00;

        /*data_transfer_mode-1 for AM
          data_transfer_mode-2 for UM*/

        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & 
                RRM_OAM_ADDL_RLC_PARAM_PRESENT)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_RETRSMIT_PRESENT)
            {
                /* SPR 20653 Fix Start */ 
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.t_poll_retransmit = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_poll_retransmit;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_POLL_PDU_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.poll_pdu = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_poll_pdu;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_REORDER_FOR_AM_MODE_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.dl_am_rlc.t_reordering =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_reordering_am;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_TMR_STATUS_PROHIBIT_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.dl_am_rlc.t_status_prohibit =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_status_prohibit;
            }
            /* Code Removed */
            /* CHANGES_FRM_XML_TO_CFG START*/
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_UL_AM_POLL_BYTE_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.poll_byte = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.ul_am_poll_byte;
            }
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                    RRM_OAM_MAX_RTX_THRESHOLD_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    am_config.ul_am_rlc.max_retx_threshold = 
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.ul_am_rrc_max_retx_threshold;
            }
            /* Code Removed */
            /* CHANGES_FRM_XML_TO_CFG END */
        }
        /* Code Removed */
        /* SPR 20653 Fix End */

        /* SPR 20653 Fix Start */
        if( RRM_OAM_GBR == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].type)
        {
            if( QCI_VAL_4 == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].qci)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_gbr / RRM_TWO;
            }
            else
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                    buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_gbr ;

            }
        }
        else
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                buffer_factor = p_ran_info_from_oam->rlc_layer_params.rlc_tx_buffer_size_factor_ngbr;
        }
        /* SPR 20653 Fix End */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_AM_CONFIG_ERB_SERVICE_PROFILE_PRESENT;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.pdcp_config.bitmask |=
            RRC_PDCP_CONFIG_RLC_UM_PDCP_SN_SIZE_ERB_SERVICE_PROFILE_PRESENT;

        /* SPR 20653 Fix Start */ 
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_SN_FIELD_LEN_PRESENT) 
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_SN_FIELD_LEN_UL_RLC_PRESENT)
            {
                /* SPR_10949_CHANGES_START */
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.ul_rlc)
                {
                    case RRM_OAM_SN_FIELD_LEN_UL_RLC_5_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ZERO;
                        break;
                    case RRM_OAM_SN_FIELD_LEN_UL_RLC_10_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ONE;
                        break;
                    default :
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_ul_config.ul_um_rlc.sn_field_length = RRM_ZERO;
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.ul_rlc);
                }
                /* SPR_10949_CHANGES_END */
            }
            /* Code Removed */
            /*cov_fix_start_64292*/
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_SN_FIELD_LEN_DL_RLC_PRESENT)
            {
                /* SPR_10949_CHANGES_START */
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.dl_rlc)
                {
                    case RRM_OAM_SN_FIELD_LEN_DL_RLC_5_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ZERO;
                        break;
                    case RRM_OAM_SN_FIELD_LEN_DL_RLC_10_BIT:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ONE;
                        break;
                    default :
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.dl_rlc);
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                            um_uni_directional_dl_config.dl_um_rlc.sn_field_length = RRM_ZERO;
                }
                /* SPR_10949_CHANGES_END */
            }
            /*cov_fix_end_64292*/
            /* Code Removed */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.bitmask &
                    RRM_OAM_RLC_UM_PDCP_SN_SIZE_PRESENT)
            {
                /* SPR_10949_CHANGES_START */
                switch(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.rlc_um_pdcp_sn_size)
                {
                    case RRM_OAM_RLC_UM_PDCP_SN_SIZE_7_BITS:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ZERO;
                        break;
                    case RRM_OAM_RLC_UM_PDCP_SN_SIZE_12_BITS:
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ONE;
                        break;
                    default:
                        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                                "Incorrect Value[%d] Received from OAM",
                                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sn_field_len.rlc_um_pdcp_sn_size);
                        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                            pdcp_config.rlc_um_pdcp_sn_size = RRM_ZERO;
                }
                /* SPR_10949_CHANGES_END */
            }
            /* Code Removed */
        }
        /* Code Removed */
        /* SPR 20653 Fix End */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_ERB_SERVICE_PROFILE_PRESENT;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_ERB_SERVICE_PROFILE_PRESENT;

        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.bitmask & 
                RRM_OAM_TMR_REORDER_FOR_UM_MODE_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
                um_uni_directional_dl_config.dl_um_rlc.t_reordering = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_rlc_param.t_reordering_um;
        }
        /* Code Removed */
        /* CHANGES_FRM_XML_TO_CFG END */


        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rlc_config.
            bitmask |= RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_ERB_SERVICE_PROFILE_PRESENT;
        RRM_MEMCPY(&p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_bi_directional_config.ul_um_rlc,
                &p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_uni_directional_ul_config.ul_um_rlc,
                sizeof(rrc_uplink_um_rlc_erb_service_profile_t));
        RRM_MEMCPY(&p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_bi_directional_config.dl_um_rlc,
                &p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.
                rlc_config.um_uni_directional_dl_config.dl_um_rlc,
                sizeof(rrc_downlink_um_rlc_erb_service_profile_t));


        /* rlc_config - end */

        /*mac config - start*/
        /*SPR 5169 start*/
        /* CHANGES_FRM_XML_TO_CFG START */
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SR_CONFIGURATION_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.mac_config.
                sr_prohibit_timer_r9 = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.sr_prohibit_timer_r9;

            /* SPR 20653 Fix Start */
            /* Code Removed */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.mac_config.
                sr_max_transmissions = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.dsr_trans_max;

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sr_mask_flag =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sr_configuration.sr_mask_flag;
        }
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* CHANGES_FRM_XML_TO_CFG END */
        /*SPR 5169 end*/
        /*mac config - end*/

        /* ul_specific_parameters - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            bitmask = 0x00;

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            priority =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].priority;

        /* CHANGES_FRM_XML_TO_CFG START */
        /* SPR 20653 Fix Start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            prioritized_bit_rate =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].prioritized_bit_rate;
        /* CHANGES_FRM_XML_TO_CFG END */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            bucket_size_duration =
            p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bucket_size_duration;
        /* CHANGES_FRM_XML_TO_CFG START*/
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask & RRM_OAM_LOGICAL_CHANNEL_GROUP_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
                logical_channel_group =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].logical_channel_group;
        }
        /* Code Removed */
        /* CHANGES_FRM_XML_TO_CFG END */

        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.ul_specific_parameters.
            bitmask |= RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_ERB_SERVICE_PROFILE_PRESENT;

        /* ul_specific_parameters - end */

        /* rrc_ul_sch_config_profile - start */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            bitmask = 0x00;

        if( RRM_OAM_MAX_HARQ_TX_PRESENT & p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                max_harq_tx =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].max_harq_tx;
        }
        /* Code Removed */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT;

        if( RRM_OAM_ADDL_MAC_PARAM_PRESENT & p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask)
        {
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.bitmask &
                    RRM_OAM_PERIODIC_TMR_BSR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                    periodic_bsr_timer =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.t_periodic_bsr;
            }
            /* Code Removed */
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                bitmask |= RRC_SERVICE_PROFILE_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT;

            /*spr_22058_changes_start*/
            /* Code Removed */
            /*spr_22058_changes_end*/
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                erb_service_profile.phr_config.phr_config_param.periodic_phr_timer = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_periodic_phr;
            /* Code Removed */
            /*spr_22058_changes_start*/
            /* Code Removed */
            /*spr_22058_changes_end*/
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                erb_service_profile.phr_config.phr_config_param.prohibit_phr_timer = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_prohibit_phr;
            /* Code Removed */
            /*spr_22058_changes_start*/
            /* Code Removed */
            /*spr_22058_changes_end*/
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                erb_service_profile.phr_config.phr_config_param.dl_pathloss_change = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.phr_config.t_pathloss_chng;
            /* Code Removed */

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.phr_config.bitmask = 0x00;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].
                erb_service_profile.phr_config.bitmask |= RRC_SERVICE_PROFILE_PHR_CONFIG_PARAM_PRESENT;

            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.bitmask &
                    RRM_OAM_RETX_TMR_BSR_PRESENT)
            {
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                    retx_bsr_timer =
                    p_epc_info_from_oam->epc_params.qos_config_params[qos_count].addl_mac_param.bsr_config.t_retx_bsr;
            }
            /* Code Removed */
        }
        /* Code Removed */
        /* SPR 20653 Fix End */


        /*Start changes for TTI bundling feature*/
#ifndef TDD_MODE_FLAG
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_TTI_BUNDLING_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                tti_bundling =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].tti_bundling;
            /* SPR 18641_18843 fix start */
            if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].tti_bundling)
            {
                *p_tti_bundling_info_present = RRM_TRUE;
            }    
            /* SPR 18641_18843 fix end */
        }
        else
        {
            /*Disable tti bundling feature if it is not provided by OAM */
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
                tti_bundling = 0;
        }
#else 
        /*TTI bundling feature is not supported in TDD mode by L2 in this release */
        p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].erb_service_profile.rrc_ul_sch_config_profile.
            tti_bundling = 0;
#endif
        /*End changes for TTI bundling feature*/

        /* rrc_ul_sch_config_profile - end */

        /* rrm_s1u_config_erb_service_profile_t - start */

        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
        /* rrm_s1u_config_erb_service_profile_t - ends */

        /* erb_service_profile - end */
        /* SPS related changes start */
        /* + SPS_TDD_Changes */
        /* Code removed as this is for FDD and TDD both*/
        /* - SPS_TDD_Changes */
        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SPS_CONFIG_ENABLED_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_config_enabled = 
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_config_enabled;

            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SPS_CONFIG_ENABLED_PRESENT;
        }

        if (p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SPS_CONFIG_DATA_PRESENT)
        {
            qci_val = p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci;
            populate_sps_config_data(&(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_data),
                    &(p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_data),
                    qci_val, p_ran_info_from_oam->physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch);
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT;
        }

        else
        {
            if(RRM_ONE == p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_config_enabled)
            {
                qci_val = p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].qci;
                populate_sps_config_data(&(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sps_data),
                        &(p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sps_data),
                        qci_val, p_ran_info_from_oam->physical_layer_params.physical_layer_param_ul_power_control.p_0_nominal_pusch);
                p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |= 
                    RRMCM_RMIF_SPS_CONFIG_DATA_PRESENT;
            }
        }
        /* SPS related changes end */

        /* SPR_13815_fix: start */
        /* Lines deleted */
        /* SPR_13815_fix: end */

        /*SRVCC SUPPORT START*/
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SRVCC_OP_REQUIRED_PRESENT)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].srvcc_op_required =
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].srvcc_op_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SRVCC_OP_REQUIRED_PRESENT;
        }
        /*SRVCC SUPPORT END*/

#ifdef ENDC_ENABLED   
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SGNB_BEARER_REQUIRED)
        {
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sgnb_bearer_required=
                p_epc_info_from_oam->epc_params.qos_config_params[qos_count].sgnb_bearer_required;
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SGNB_BEARER_REQUIRED;
        }
        if(p_epc_info_from_oam->epc_params.qos_config_params[qos_count].bitmask &
                RRM_OAM_SGNB_BEARER_TYPE)
        {
            /* coverity_<280097>_fix_start */
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].sgnb_bearer_type =
                (rrm_drb_type_et)p_epc_info_from_oam->epc_params.qos_config_params[qos_count].\
                      sgnb_bearer_type;
               /* coverity_<280097>_fix_end */
            p_epc_info_to_cellm->epc_params.qos_config_params[qos_count].bitmask |=
                RRMCM_RMIF_SGNB_BEARER_TYPE_PRESENT;
        }
#endif    
    } 

    /*qos info - start*/
    p_epc_info_to_cellm->epc_params.emergency_erab_arp = p_epc_info_from_oam->epc_params.emergency_erab_arp;

    RRM_UT_TRACE_EXIT();
} 
/*Cov_fix_64292_end*/
/****************************************************************************
 * Function Name  : fill_mobility_info_for_cell_config
 * Inputs         : - p_mob_info_to_cellm
 *                  - p_mob_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Mobility Info for CellM module.
 ****************************************************************************/
/* CSR_00057814_CHANGES_START */
void fill_mobility_info_for_cell_config(
        mobility_params_t          *p_mob_info_to_cellm, 
        rrm_oam_mobility_params_t  *p_mob_info_from_oam,
        rrm_oam_ran_t               *p_ran_info_from_oam)
    /* CSR_00057814_CHANGES_END */
{
    U16                                    inter_freq_param_count = RRM_ZERO;
    common_params_t                       *comPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_common_params_t               *comPramsp_mob_info_from_oam = RRM_NULL;
    intra_freq_params_t                   *intraFreqPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_intra_freq_params_t           *intraFreqPramsp_mob_info_from_oam = RRM_NULL; 
    inter_freq_params_t                   *interFreqPramsp_mob_info_to_cellm = RRM_NULL;
    rrm_oam_inter_freq_params_t           *interFreqPramsp_mob_info_from_oam = RRM_NULL;
    RRM_ASSERT (RRM_PNULL != p_mob_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_mob_info_from_oam);
    /* CSR_00057814_CHANGES_START */
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    /* CSR_00057814_CHANGES_END */

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Mobility Information");

    /* idle mode mobility common params - start */
    comPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
        idle_mode_mobility_common_params;
    comPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.
        idle_mode_mobility_common_params;

    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    fill_cellm_comPramsp_mob_info(comPramsp_mob_info_from_oam , comPramsp_mob_info_to_cellm);
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/
    p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_RMIF_IDLE_MODE_MOBILITY_COMMON_PARAMS_PRESENT;
    /* common params - end */

    /*idle mode mobility intra freq params - start*/
    intraFreqPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params;
    intraFreqPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.
        idle_mode_mobility_intra_freq_params;

    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
    fill_cellm_intraFreqPramsp_mob_info(intraFreqPramsp_mob_info_from_oam , intraFreqPramsp_mob_info_to_cellm);
    /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

    p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_MIF_IDLE_MODE_MOBILITY_INTRA_FREQ_PARAMS;
    /*idle mode mobility intra freq params - end*/

    /*inter freq params - start*/
    p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list=
        p_mob_info_from_oam->idle_mode_mobility_params.
        idle_mode_inter_freq_params_list.num_valid_inter_freq_list;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "No of Inter Freq [%d]",
            p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list);

    for (inter_freq_param_count = 0;
            ((inter_freq_param_count<p_mob_info_to_cellm->idle_mode_mobility_params.num_valid_inter_freq_list)&&
             (inter_freq_param_count < MAX_NO_INTER_FREQ)); inter_freq_param_count++)
    {
        interFreqPramsp_mob_info_to_cellm = &p_mob_info_to_cellm->idle_mode_mobility_params.
            idle_mode_mobility_inter_freq_params[inter_freq_param_count];
        interFreqPramsp_mob_info_from_oam = &p_mob_info_from_oam->idle_mode_mobility_params.idle_mode_inter_freq_params_list.
            idle_mode_mobility_inter_freq_params[inter_freq_param_count];
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_START*/
        fill_cellm_interFreqPramsp_mob_info(interFreqPramsp_mob_info_from_oam , interFreqPramsp_mob_info_to_cellm);
        /*LTE_RRM_KLOCWORK_WARN_<24_JUL_12>_END*/

    }/*for loop ends here*/
    p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= RRMCM_MIF_IDLE_MODE_MOBILITY_INTER_FREQ_PARAMS;
    /*inter freq params - end*/

    /*populating irat utra params */
    if (p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
            RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT");
        fill_idle_mode_mobility_irat_utra_info(
                &p_mob_info_to_cellm->idle_mode_mobility_params.
                idle_mode_mobility_irat_utra_params,
                &p_mob_info_from_oam->idle_mode_mobility_params.
                /* CSR_00057814_CHANGES_START */
                idle_mode_mobility_inter_rat_utra_params,
                p_ran_info_from_oam);
        /* CSR_00057814_CHANGES_END */

        p_mob_info_to_cellm->idle_mode_mobility_params.bitmask|= 
            RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_UTRA_PRESENT; 
    }

    /*populating irat geran params */
    if (p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
            RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT)
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT");
        fill_idle_mode_mobility_irat_geran_info(
                &p_mob_info_to_cellm->idle_mode_mobility_params.
                idle_mode_mobility_irat_geran_params,
                &p_mob_info_from_oam->idle_mode_mobility_params.
                idle_mode_mobility_inter_rat_geran_params,
                p_ran_info_from_oam);

        p_mob_info_to_cellm->idle_mode_mobility_params.bitmask|= 
            RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_GERAN_PRESENT; 
    }

    /*populating irat cdma2000 params */
    if(p_mob_info_from_oam->idle_mode_mobility_params.bitmask &
            RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_IDLE_MODE_MOBILITY_IRAT_CDMA2000_PRESENT");
        fill_idle_mode_mobility_irat_cdma2000_info(
                &p_mob_info_to_cellm->idle_mode_mobility_params. \
                idle_mode_mobility_irat_cdma_params, 
                &p_mob_info_from_oam->idle_mode_mobility_params. \
                idle_mode_mobility_inter_rat_cdma2000_params);

        p_mob_info_to_cellm->idle_mode_mobility_params.bitmask |= \
                                                                  RRMCM_RMIF_IDLE_MODE_MOBILITY_IRAT_CDMA_PRESENT;
    }

    p_mob_info_to_cellm->bitmask |= RRMCM_RMIF_IDLE_MODE_MOBILITY_PARAMS_PRESENT;

    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_mac_layer_info_for_cell_config
 * Inputs         : - p_mac_info_to_cellm
 *                  - p_mac_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the MAC layer Info for CellM module.
 ****************************************************************************/
 /* SPR 20653 Fix Start */
void fill_mac_layer_info_for_cell_config(mac_layer_params_t          *p_mac_info_to_cellm,
        /* BUG_371 FIX START */ 
        rrm_oam_mac_layer_params_t  *p_mac_info_from_oam)
        /*SPR 17777 +-*/
 /* SPR 20653 Fix End */
/* BUG_371 FIX END */ 
/*SPR 17777 +-*/
{
    U16 drx_profile_count = RRM_ZERO;
    U16 qci_count         = RRM_ZERO;
    RRM_ASSERT (RRM_PNULL != p_mac_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_mac_info_from_oam);

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating MAC Information");

    /* Inititalize bitmask */
    p_mac_info_to_cellm->bitmask = 0x00;

    /* rach - start */
    /* preamble_info - start */
    p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.bitmask |= 0x00;

    /* preamble_info - start */
    p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.bitmask |= 0x00;

    p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.number_of_ra_preambles= 
        p_mac_info_from_oam->mac_layer_param_rach.preamble_info.number_of_ra_preambles;

    if (p_mac_info_from_oam->mac_layer_param_rach.preamble_info.bitmask & 
            RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRM_OAM_RA_PREABLE_GROUPA_INFO_PRESENT");

        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.bitmask |=
            RRMCM_RMIF_RA_PREABLE_GROUPA_INFO_PRESENT;
        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a= 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.size_of_ra_group_a;
        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_size_group_a= 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_size_group_a;
        p_mac_info_to_cellm->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b = 
            p_mac_info_from_oam->mac_layer_param_rach.preamble_info.ra_preamble_groupA_info.message_power_offset_group_b;
    }
    /* preamble_info - end */

    p_mac_info_to_cellm->mac_layer_param_rach.power_ramping_step = 
        p_mac_info_from_oam->mac_layer_param_rach.power_ramping_step;

    p_mac_info_to_cellm->mac_layer_param_rach.preamble_initial_received_target_power = 
        p_mac_info_from_oam->mac_layer_param_rach.preamble_initial_received_target_power;

    p_mac_info_to_cellm->mac_layer_param_rach.preamble_trans_max = 
        p_mac_info_from_oam->mac_layer_param_rach.preamble_trans_max;

    p_mac_info_to_cellm->mac_layer_param_rach.response_window_size = 
        p_mac_info_from_oam->mac_layer_param_rach.response_window_size;

    p_mac_info_to_cellm->mac_layer_param_rach.contention_resolution_timer = 
        p_mac_info_from_oam->mac_layer_param_rach.contention_resolution_timer;


    p_mac_info_to_cellm->mac_layer_param_rach.max_harq_msg_3tx =
        p_mac_info_from_oam->mac_layer_param_rach.max_harq_msg_3tx;

    /* SPR 19309 + */
    p_mac_info_to_cellm->cfi_value =
        p_mac_info_from_oam->cfi_value;
    /* SPR 19309 - */
    /* SPR 19310 + */
    p_mac_info_to_cellm->num_of_eul =
        p_mac_info_from_oam->num_of_eul;
    p_mac_info_to_cellm->size_of_eul =
        p_mac_info_from_oam->size_of_eul;
    /* SPR 19310 - */

    p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_RACH_PRESENT;
    /* rach - end */

    /* drx - start */
    p_mac_info_to_cellm->mac_layer_param_drx.drx_enabled =
        p_mac_info_from_oam->mac_layer_param_drx.drx_enabled;
    p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles= 
        p_mac_info_from_oam->mac_layer_param_drx.num_valid_drx_profiles;
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
            "DRX Enable [%d]  Number of Valid DRX profiles[%d]",
            p_mac_info_to_cellm->mac_layer_param_drx.drx_enabled,
            p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles);

    for (drx_profile_count=0;
            ((drx_profile_count < p_mac_info_to_cellm->mac_layer_param_drx.num_valid_drx_profiles)&&
             (drx_profile_count < MAX_NO_DRX_PROFILE));
            drx_profile_count++)
    {
        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask = 0x00;

        /*qci info*/ 
        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci =  
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].num_applicable_qci;

        for (qci_count = 0;
                ((qci_count < p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci)&&
                 (qci_count < RRM_MAX_QCI )); qci_count++ )
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].qci[qci_count]=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].applicable_qci_list[qci_count]; 
        }/*for loop ends*/

        /*qci info*/ 
        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci =  
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].num_applicable_qci;

        for (qci_count = 0;
                ((qci_count < p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].num_qci)&&
                 (qci_count < RRM_MAX_QCI )); qci_count++ )
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].qci[qci_count]=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].applicable_qci_list[qci_count]; 
        }/*for loop ends*/


        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].on_duration_timer=
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].on_duration_timer;

        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_inactivity_timer=
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_inactivity_timer;

        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_retransmission_timer=
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_retransmission_timer;

        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle=
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle;

        #ifdef ENDC_ENABLED
        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle_r15 =
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].long_drx_cycle_r15;
        #endif

        p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_start_offset=
            p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].drx_start_offset;

        if (p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].bitmask & 
                RRM_OAM_SHORT_DRX_CYCLE_PRESENT)
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask |= 
                RRMCM_RMIF_SHORT_DRX_CYCLE_PRESENT;

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].bitmask |= 
                RRMCM_RMIF_SHORT_DRX_CYCLE_TIMER_PRESENT;

            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle =
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle.short_drx_cycle;
            p_mac_info_to_cellm->mac_layer_param_drx.drx_config[drx_profile_count].drx_short_cycle_timer=
                p_mac_info_from_oam->mac_layer_param_drx.drx_config[drx_profile_count].short_drx_cycle.
                drx_short_cycle_timer;
        }
    }/*outer for loop ends*/

    /* CSR_00053551_CHANGES_START */
    /*Coverity_fix_start_62525*/
    if(RRM_TRUE == p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_command_enable)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "DRX_MAC_CE_CMD is Enabled by operator");
        if(p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT)
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_timer_percentage =
                p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_timer_percentage;
        }
        else
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_FALSE;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "DRX_MAC_CE_CMD is Disabled as drx_mac_ce_timer_percentage is not configured");
        }

        if(p_mac_info_from_oam->mac_layer_param_drx.bitmask &  RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT)
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_cmd_threshold =
                p_mac_info_from_oam->mac_layer_param_drx.drx_mac_ce_cmd_threshold;
        }
        else
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_FALSE;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "DRX_MAC_CE_CMD is Disabled as drx_mac_ce_cmd_threshold is not configured");
        }
        if((p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_TIMER_PERCENT_INFO_PRESENT) &&
                (p_mac_info_from_oam->mac_layer_param_drx.bitmask & RRM_OAM_DRX_MAC_CE_CMD_THRESHOLD_PRESENT))
        {
            p_mac_info_to_cellm->mac_layer_param_drx.drx_mac_ce_cmd_trigger_info.drx_mac_ce_command_enable = RRM_TRUE;
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                    "DRX_MAC_CE_CMD is Enabled for further decisions at Cell Manager");
        }
    }
    /* Coverity 62525 fix end */
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_BRIEF,
                "DRX_MAC_CE_CMD is disabled by operator");
    }
    /* CSR_00053551_CHANGES_END */
    /*Coverity_fix_end_62525*/
    p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_DRX_PRESENT; 
    /* drx - end */

    /* Fix for CSR: 00059124 */
    if(p_mac_info_from_oam->bitmask & RRM_OAM_MAC_LAYER_PARAM_CDRX_PRESENT)
    {
        p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_CDRX_PRESENT;

        p_mac_info_to_cellm->rrm_cdrx_config.on_duration_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.on_duration_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_inactivity_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_inactivity_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_retransmission_timer=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_retransmission_timer;

        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle=
            p_mac_info_from_oam->rrm_oam_cdrx_config.long_drx_cycle;

        #ifdef ENDC_ENABLED
        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle_r15 =
            p_mac_info_from_oam->rrm_oam_cdrx_config.long_drx_cycle_r15;
        p_mac_info_to_cellm->rrm_cdrx_config.bitmask |=
            RRMCM_RMIF_CDRX_LONG_DRX_CYCLE_R15_PRESENT;
        #endif

        p_mac_info_to_cellm->rrm_cdrx_config.drx_start_offset=
            p_mac_info_from_oam->rrm_oam_cdrx_config.drx_start_offset;
        /*SPR 20533 Fix Start*/
        /*Code Removed*/
        /*SPR 20533 Fix Stop*/
    }
    else
    {
        p_mac_info_to_cellm->bitmask |= RRMCM_RMIF_MAC_LAYER_PARAM_CDRX_PRESENT;

        p_mac_info_to_cellm->rrm_cdrx_config.on_duration_timer =
            RRM_CFG_CDRX_ON_DURATION_TIMER;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_inactivity_timer =
            RRM_CFG_CDRX_DRX_INACTIVITY_TIMER;

        p_mac_info_to_cellm->rrm_cdrx_config.drx_retransmission_timer =
            RRM_CFG_CDRX_DRX_RETRANSMISSION_TIMER;

        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle =
            RRM_CFG_CDRX_LONG_DRX_CYCLE;

        #ifdef ENDC_ENABLED
        p_mac_info_to_cellm->rrm_cdrx_config.long_drx_cycle_r15 =
            RRM_CFG_CDRX_LONG_DRX_CYCLE_R15;
        p_mac_info_to_cellm->rrm_cdrx_config.bitmask |=
            RRMCM_RMIF_CDRX_LONG_DRX_CYCLE_R15_PRESENT;
        #endif

        p_mac_info_to_cellm->rrm_cdrx_config.drx_start_offset =
            RRM_CFG_CDRX_DRX_START_OFFSET;

        /*SPR 20533 Fix Start*/
        /*Code Removed*/
        /*SPR 20533 Fix Stop*/
    }
    /* Fix for CSR: 00059124 */
    /* BUG_371 FIX START */ 

    if(p_mac_info_from_oam->bitmask & RRM_OAM_UL_SYNC_LOSS_TIMER_PRESENT)
    {
        switch(p_mac_info_from_oam->ul_sync_loss_timer)
        {
            case RRM_ZERO:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_INFINITY;
                    break;
                }
            case RRM_ONE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_100;
                    break;
                }
            case RRM_TWO:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_150;
                    break;
                }
            case RRM_THREE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_200;
                    break;
                }
            case RRM_FOUR:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_300;
                    break;
                }
            case RRM_FIVE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_400;
                    break;
                }
            case RRM_SIX:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_500;
                    break;
                }
            case RRM_SEVEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_750;
                    break;
                }
            case RRM_EIGHT:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_1280;
                    break;
                }
            case RRM_NINE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_1920;
                    break;
                }
            case RRM_TEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_2560;
                    break;
                }
            case RRM_ELEVEN:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_5120;
                    break;
                }
            case RRM_TWELVE:
                {
                    p_mac_info_to_cellm->ul_sync_loss_timer =
                        RRM_UL_SYNC_LOSS_TIMER_10240;
                    break;
                }
            default:
                p_mac_info_to_cellm->ul_sync_loss_timer =
                    RRM_UL_SYNC_LOSS_TIMER_INFINITY;
        }
        /* SPR 20653 Fix Start */
        /* Code Removed */
    }
    else
    {
        p_mac_info_to_cellm->ul_sync_loss_timer = RRM_DEFINED_DEFAULT_VALUE_FOR_UL_SYNC_LOSS_TIMER;
        /* Coverity_ID : 53623 */
        /* Code Removed */
        /* SPR 20653 Fix End */
    }
    if(p_mac_info_from_oam->bitmask & RRM_OAM_N_GAP_PRESENT)
    {
        switch(p_mac_info_from_oam->n_gap)
        {
            case RRM_ZERO:
                {
                    p_mac_info_to_cellm->n_gap =
                        RRM_NGAP_1;
                    break;
                }
            case RRM_ONE:
                {
                    p_mac_info_to_cellm->n_gap =
                        RRM_NGAP_2;
                    break;
                }
            default:
                p_mac_info_to_cellm->n_gap =
                    RRM_NGAP_1;
        }
    }
    /* SPR 20653 Fix Start */
    /* Code Removed */
    /* SPR 20653 Fix End */
    /* BUG_371 FIX END */ 
    /* SPR 21958 PUSCH RAT1 Support Start */
    if (p_mac_info_from_oam->bitmask & 
            RRM_OAM_UPLINK_RAT1_SUPPORT_INFO_PRESENT)
    {
        p_mac_info_to_cellm->is_uplink_rat1_supported = 
            p_mac_info_from_oam->is_uplink_rat_1_supported;

        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                RRM_DETAILED, "RRM_OAM_UPLINK_RAT1_SUPPORT_INFO_PRESENT" 
                " and value for is_uplink_rat1_supported = %d",
                p_mac_info_from_oam->is_uplink_rat_1_supported);
    }
    else
    {
       p_mac_info_to_cellm->is_uplink_rat1_supported = RRM_ZERO;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                RRM_DETAILED, "Bitmask not set for uplink rat1" 
                " and value for is_uplink_rat1_supported = %d",
                p_mac_info_from_oam->is_uplink_rat_1_supported);
    }
    /* SPR 21958 PUSCH RAT1 Support End */
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : fill_phy_layer_info_for_cell_config
 * Inputs         : - p_phy_info_to_cellm
 *                  - p_phy_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the Physical Layer info for CellM module.
 ****************************************************************************/
/* SPR 20653 Fix Start */
void fill_phy_layer_info_for_cell_config(
        rrm_physical_layer_params_t       *p_phy_info_to_cellm,
        rrm_oam_physical_layer_params_t   *p_phy_info_from_oam)
    /* SPR 20653 Fix End */
    /*SPR 17777 +-*/
{
    RRM_ASSERT (RRM_PNULL != p_phy_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_phy_info_from_oam); 

    RRM_UT_TRACE_ENTER();

    /* Inititalize bitmask */
    p_phy_info_to_cellm->bitmask = 0x00;

    /* Physiacal Layer Parameters */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating PHY Information");

    /*pdsch - start*/
    p_phy_info_to_cellm->physical_layer_param_pdsch.p_b =
        p_phy_info_from_oam->physical_layer_param_pdsch.p_b;
    p_phy_info_to_cellm->physical_layer_param_pdsch.p_a =
        p_phy_info_from_oam->physical_layer_param_pdsch.p_a;
    p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PDSCH_CONFIG_PRESENT;
    /*pdsch - end*/

    /*srs - start*/
    p_phy_info_to_cellm->physical_layer_param_srs.bitmask = 0x00;
    switch (p_phy_info_from_oam->physical_layer_param_srs.srsEnabled)
    {
        case RRM_OAM_SRS_DISABLED:
            {
                p_phy_info_to_cellm->physical_layer_param_srs.srsEnabled = RRM_FALSE;
                break;
            }
        case RRM_OAM_SRS_ENABLED:
            {
                p_phy_info_to_cellm->physical_layer_param_srs.srsEnabled = RRM_TRUE;
                break;
            }
        default:
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR, 
                        "fill_phy_layer_info_for_cell_config: Incorrect p_phy_info_from_oam->"
                        "physical_layer_param_srs.srsEnabled");
                break; 
            }
    }

    p_phy_info_to_cellm->physical_layer_param_srs.srs_bandwidth_config =
        p_phy_info_from_oam->physical_layer_param_srs.srs_bandwidth_config;

    p_phy_info_to_cellm->physical_layer_param_srs.srs_subframe_config =
        p_phy_info_from_oam->physical_layer_param_srs.srs_subframe_config;

    /*BUG_931_CHANGES_START*/
#ifdef TDD_MODE_FLAG
    if ((p_phy_info_from_oam->physical_layer_param_srs.bitmask &
                RRM_OAM_SRS_MAX_UP_PTS_PRESENT) && 
            (RRM_OAM_SRS_MAX_UP_PTS_TRUE == p_phy_info_from_oam->physical_layer_param_srs.srs_max_up_pts))
    { 
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT");
        p_phy_info_to_cellm->physical_layer_param_srs.srs_max_up_pts =
            p_phy_info_from_oam->physical_layer_param_srs.srs_max_up_pts;
        p_phy_info_to_cellm->physical_layer_param_srs.bitmask |= 
            RRMCM_RMIF_SRS_MAX_UP_PTS_PRESENT;    
    }
#endif
/*BUG_931_CHANGES_END*/
   p_phy_info_to_cellm->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission=
       p_phy_info_from_oam->physical_layer_param_srs.ack_nack_srs_simultaneous_transmission;
   /* SPR 20653 Fix Start */
   p_phy_info_to_cellm->physical_layer_param_srs.srs_hopping_enable= 
       p_phy_info_from_oam->physical_layer_param_srs.srs_hopping_enable;   

   p_phy_info_to_cellm->physical_layer_param_srs.srs_duration= 
       p_phy_info_from_oam->physical_layer_param_srs.srs_duration;    
   /* SPR 20653 Fix End */

   p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_SRS_CONFIG_PRESENT;
  /*srs - end*/

  /*prach - start*/
   p_phy_info_to_cellm->physical_layer_param_prach.root_sequence_index =
       p_phy_info_from_oam->physical_layer_param_prach.root_sequence_index;

   p_phy_info_to_cellm->physical_layer_param_prach.configuration_index =
       p_phy_info_from_oam->physical_layer_param_prach.configuration_index;

   p_phy_info_to_cellm->physical_layer_param_prach.high_speed_flag =
       p_phy_info_from_oam->physical_layer_param_prach.high_speed_flag;

   p_phy_info_to_cellm->physical_layer_param_prach.zero_correlation_zone_config =
       p_phy_info_from_oam->physical_layer_param_prach.zero_correlation_zone_config;

   p_phy_info_to_cellm->physical_layer_param_prach.frequency_offset =
       p_phy_info_from_oam->physical_layer_param_prach.frequency_offset;

   p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRACH_CONFIG_PRESENT;
  /*prach - end*/

  /*pucch - start*/
   p_phy_info_to_cellm->physical_layer_param_pucch.delta_pucch_shift =
       p_phy_info_from_oam->physical_layer_param_pucch.delta_pucch_shift;

   p_phy_info_to_cellm->physical_layer_param_pucch.n_rb_cqi =
         p_phy_info_from_oam->physical_layer_param_pucch.n_rb_cqi;

   /* SPR 20653 Fix Start */
   if(p_phy_info_from_oam->addl_physical_layer_params.addl_pucch_parameters.bitmask & RRM_OAM_N1_CS_PRESENT)
   {
       p_phy_info_to_cellm->physical_layer_param_pucch.n_cs_an =
           p_phy_info_from_oam->addl_physical_layer_params.addl_pucch_parameters.n1_cs;
   }
   else
   {
       p_phy_info_to_cellm->physical_layer_param_pucch.n_cs_an = RRM_DEFINED_DEFAULT_VALUE_FOR_PUCCH_N_CS_AN;
   }

  /* for TDD mode only*/
   p_phy_info_to_cellm->physical_layer_param_pucch.bitmask = 0x00;
   if(p_phy_info_from_oam->physical_layer_param_pucch.bitmask & RRM_OAM_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT)
   {
     p_phy_info_to_cellm->physical_layer_param_pucch.tdd_ack_nack_feedback_mode =
        p_phy_info_from_oam->physical_layer_param_pucch.tdd_ack_nack_feedback_mode;
     p_phy_info_to_cellm->physical_layer_param_pucch.bitmask |= PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;
   }
  else
  {
      p_phy_info_to_cellm->physical_layer_param_pucch.tdd_ack_nack_feedback_mode = 
           RRM_DEFINED_DEFAULT_VALUE_FOR_TDD_ACK_NACK_FEEDBACK_MODE;
      p_phy_info_to_cellm->physical_layer_param_pucch.bitmask |= PUCCH_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT;
  }
   /* SPR 20653 Fix End */

   p_phy_info_to_cellm->physical_layer_param_pucch.n1_pucch_an =
         p_phy_info_from_oam->physical_layer_param_pucch.n1_pucch_an;

   p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUCCH_CONFIG_PRESENT;
  /*pucch - end*/

  /*pusch - start*/
   p_phy_info_to_cellm->physical_layer_param_pusch.n_sb =
       p_phy_info_from_oam->physical_layer_param_pusch.n_sb;

   p_phy_info_to_cellm->physical_layer_param_pusch.pusch_hopping_mode =
        p_phy_info_from_oam->physical_layer_param_pusch.pusch_hopping_mode;

    p_phy_info_to_cellm->physical_layer_param_pusch.hopping_offset =
        p_phy_info_from_oam->physical_layer_param_pusch.hopping_offset;

    /* SPR 20653 Fix Start */
    if(p_phy_info_from_oam->addl_physical_layer_params.additional_pusch_parameters.bitmask & 
            RRM_OAM_PUSCH_ENABLE_64_QAM_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_pusch.enable_64_qam = 
            p_phy_info_from_oam->addl_physical_layer_params.additional_pusch_parameters.pusch_enable_64_qam;
    }
    else
    {
        p_phy_info_to_cellm->physical_layer_param_pusch.enable_64_qam = RRM_DEFINED_DEFAULT_VALUE_FOR_ENABLE_64_QAM;
    }
    p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PUSCH_CONFIG_PRESENT;
    /*pusch - end*/

    /*ul refernce signal - start*/
    p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_hopping_enabled =
        p_phy_info_from_oam->physical_layer_param_ul_reference_signal.group_hopping_enabled;

    p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.sequence_hopping_enabled =
        p_phy_info_from_oam->physical_layer_param_ul_reference_signal.sequence_hopping_enabled;

    if(p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask & RRM_OAM_GROUP_ASSIGMENT_PUSCH_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_assignment_pusch =
            p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.group_assignment_pusch;
    }
    else
    {
        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.group_assignment_pusch = 
            RRM_DEFINED_DEFAULT_VALUE_FOR_GROUP_ASGMNT_PUSCH;
    }

    if(p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.bitmask & RRM_OAM_UL_REFER_SIGNAL_PUSCH_CYCLIC_SHIFT_PRESENT)
    {
        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.cyclic_shift =
            p_phy_info_from_oam->addl_physical_layer_params.addtl_ul_reference_signal_params.ul_reference_signal_pusch_cyclicshift;
    }
    else
    {
        p_phy_info_to_cellm->physical_layer_param_ul_reference_signal.cyclic_shift = 
            RRM_DEFINED_DEFAULT_VALUE_FOR_UL_REF_SIG_PUSCH_CYCLIC_SHIFT;
    }
    /* SPR 20653 Fix End */

    p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_REF_SIG_PRESENT;
    /*ul refernce signal - end*/

    /*ul power control - start*/
    p_phy_info_to_cellm->physical_layer_param_ul_power_control.p_0_nominal_pusch =
        p_phy_info_from_oam->physical_layer_param_ul_power_control.p_0_nominal_pusch;

    p_phy_info_to_cellm->physical_layer_param_ul_power_control.alpha =
        p_phy_info_from_oam->physical_layer_param_ul_power_control.alpha;

    p_phy_info_to_cellm->physical_layer_param_ul_power_control.p_0_nominal_pucch =
        p_phy_info_from_oam->physical_layer_param_ul_power_control.p_0_nominal_pucch;

    /* BUG_371 FIX START */
    /* BUG_371 FIX END */
    p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_UL_POWER_CTRL_PRESENT;
    /*ul_power_control - end*/

    /*prs - start*/
    if (p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT");

        p_phy_info_to_cellm->physical_layer_param_prs.bitmask =
            p_phy_info_from_oam->physical_layer_param_prs.bitmask;

        p_phy_info_to_cellm->physical_layer_param_prs.prs_enable =
            p_phy_info_from_oam->physical_layer_param_prs.prs_enable;

        p_phy_info_to_cellm->physical_layer_param_prs.num_prs_resource_blocks =
            p_phy_info_from_oam->physical_layer_param_prs.num_prs_resource_blocks;

        p_phy_info_to_cellm->physical_layer_param_prs.prs_configuration_index =
            p_phy_info_from_oam->physical_layer_param_prs.prs_configuration_index;

        p_phy_info_to_cellm->physical_layer_param_prs.num_consecutive_prs_subfames =
            p_phy_info_from_oam->physical_layer_param_prs.num_consecutive_prs_subfames;

        if (p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_TWO_PRESENT)
        { 
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_two =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_two;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_TWO_PRESENT;
        }

        if ( p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_FOUR_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_four =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_four;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_FOUR_PRESENT;
        }

        if(p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask &  RRM_OAM_PRS_MUTING_EIGHT_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_eight =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_eight;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_EIGHT_PRESENT;
        }

        if (p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.bitmask & RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT)
        {
            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.muting_config_sixteen =
                p_phy_info_from_oam->physical_layer_param_prs.prs_muting_configration.muting_config_sixteen;

            p_phy_info_to_cellm->physical_layer_param_prs.prs_muting_configration.bitmask |= RRM_OAM_PRS_MUTING_SIXTEEN_PRESENT;
        }

        p_phy_info_to_cellm->physical_layer_param_prs.prs_transmission_power =
            (p_phy_info_from_oam->physical_layer_param_prs.prs_transmission_power + STARTING_POWER_SIGNAL) * (POWER_SIGNAL_IN_ONE_DB) ;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_PRS_CONFIG_PRESENT;
    }
    /*prs - end*/

    if (p_phy_info_from_oam->bitmask & RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_FRAME_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "fill_phy_layer_info_for_cell_config: RRM_OAM_PHYSICAL_LAYER_PARAM_TDD_PRESENT");

        p_phy_info_to_cellm->physical_layer_param_tdd_frame_structure.sub_frame_assignment =
            p_phy_info_from_oam->physical_layer_param_tdd_frame_structure.sub_frame_assignment;

        p_phy_info_to_cellm->physical_layer_param_tdd_frame_structure.special_sub_frame_patterns=
            p_phy_info_from_oam->physical_layer_param_tdd_frame_structure.special_sub_frame_patterns;

        p_phy_info_to_cellm->bitmask |= RRMCM_RMIF_PHYSICAL_LAYER_PARAM_TDD_PRESENT;
    }
    /*SPR:11977 start*/
    if(p_phy_info_from_oam->physical_layer_param_pucch.bitmask & RRM_OAM_PUCCH_CQI_SINR_VAL_PRESENT)
    {
        /* SPR 16077 fix start */
     /* p_phy_cfg_params->mac_config.pucch_cqi_sinr_value =
          p_phy_info_from_oam->physical_layer_param_pucch.pucch_cqi_sinr_value;*/
        /* SPR 16077 fix end */     

        p_phy_info_to_cellm->physical_layer_param_pucch.pucch_cqi_sinr_value =
            p_phy_info_from_oam->physical_layer_param_pucch.pucch_cqi_sinr_value;
    }
    /* SPR 20653 Fix Start */
    else
    {
        p_phy_info_to_cellm->physical_layer_param_pucch.pucch_cqi_sinr_value = RRM_DEFINED_DEFAULT_VALUE_FOR_PUCCH_CQI_SNR_VALUE;
    }
   /* SPR 20653 Fix End */
    /*SPR:11977 end*/

  #ifdef LTE_EMBMS_SUPPORTED
  if (p_phy_info_from_oam->bitmask & RRM_OAM_MBSFN_CONFIGURATION_INFO_PRESENT)
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "MBSFN IE for SIB2 is present in cell config from OAM");
      rrm_fill_mbsfn_config_params(&(p_phy_info_to_cellm->
              physical_layer_param_mbsfn_config_info),
              &((p_phy_info_from_oam->mbsfn_subframe_config_list)));
      p_phy_info_to_cellm->bitmask |= 
              RRMCM_RMIF_MBSFN_CONFIGURATION_INFO_PRESENT;
  }
  else
  {
      RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                "MBSFN IE for SIB2 is not present in cell config from OAM");
  }
  #endif
    RRM_UT_TRACE_EXIT();
}
/* SPR 20653 Fix Start */
/* Code Removed */
/* SPR 20653 Fix End */
/****************************************************************************
 * Function Name  : fill_ran_info_for_cell_config
 * Inputs         : - p_ran_info_to_cellm
 *                  - p_ran_info_from_oam
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the RAN info for CellM Module
 ****************************************************************************/
 /* SPR 20653 Fix Start */
void fill_ran_info_for_cell_config(ran_t                       *p_ran_info_to_cellm, 
        operator_info_t             *p_operator_info_to_cellm,
        rrm_oam_ran_t               *p_ran_info_from_oam,
        rrm_oam_cell_access_restriction_params_t *p_car_params_from_oam,
        rrm_oam_eutran_global_cell_id_t    *p_cell_id_from_oam,
        /*SPR 17777 +-*/
        rrm_oam_operator_info_t      *p_operator_info_from_oam)
 /* SPR 20653 Fix End */
{
    U8 cell_idx = RRM_ZERO;
    U8 index = RRM_ZERO;

    RRM_ASSERT (RRM_PNULL != p_ran_info_to_cellm);
    RRM_ASSERT (RRM_PNULL != p_ran_info_from_oam);
    RRM_ASSERT (RRM_PNULL != p_car_params_from_oam);
    RRM_ASSERT (RRM_PNULL != p_cell_id_from_oam);
    RRM_ASSERT (RRM_PNULL != p_operator_info_from_oam);

    rrm_bool_et HRPD_DAHO_FOUND = RRM_FALSE;
    rrm_bool_et XRTT_DAHO_FOUND = RRM_FALSE;

    RRM_UT_TRACE_ENTER();

    /* Initialize bitmask */
    p_ran_info_to_cellm->bitmask = 0x00;
    p_operator_info_to_cellm->bitmask = 0x00;
    /* Populating Physical Layer Info */
    /* SPR 20653 Fix Start */
    fill_phy_layer_info_for_cell_config( 
            /* SPR 20653 Fix End */
            &p_ran_info_to_cellm->physical_layer_params, 
            &p_ran_info_from_oam->physical_layer_params);
    /*SPR 17777 +-*/
    p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_PHY_LAYER_PARAMS_PRESENT;


    /* Populating MAC Layer Info */
    /* SPR 20653 Fix Start */
    fill_mac_layer_info_for_cell_config(&p_ran_info_to_cellm->mac_layer_params, 
            &p_ran_info_from_oam->mac_layer_params);
    /* SPR 20653 Fix End */
    /*SPR 17777 +-*/
    p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_MAC_LAYER_PARAMS_PRESENT;


    /* Populating RLC Layer Info */   
    fill_rlc_layer_info(
            &p_ran_info_to_cellm->rlc_layer_params, 
            &p_ran_info_from_oam->rlc_layer_params);
    p_ran_info_to_cellm->bitmask |=  RRMCM_RMIF_RLC_LAYER_PARAMS_PRESENT;


    /*BUG_866_CHANGES_START*/
    /* Populating Cell Restriction Info */
    fill_cell_restriction_info_for_cell_config(&p_ran_info_to_cellm->cell_restriction_params,
            p_car_params_from_oam);
    /*SPR 17777 +-*/
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_CELL_RESTRICTION_PARAMS_PRESENT; 
    /*BUG_866_CHANGES_END*/

    /* Populating Mobility Info Info */   
    fill_mobility_info_for_cell_config(&p_ran_info_to_cellm->mobility_params, 
            /* CSR_00057814_CHANGES_START */
            &p_ran_info_from_oam->mobility_params,
            p_ran_info_from_oam);
    /* CSR_00057814_CHANGES_END */
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_MOBILITY_LAYER_PARAMS_PRESENT;


    U8 count = RRM_ZERO;
    U8 cdma2000_cell_count = RRM_ZERO;

    for(cdma2000_cell_count = RRM_ZERO; cdma2000_cell_count < p_ran_info_from_oam->ncl_params.
            inter_rat_ncl.num_valid_cdma2000_freq_cells; cdma2000_cell_count++)
    {
        if(RRM_TRUE == p_ran_info_from_oam->ncl_params.inter_rat_ncl.cdma2000_freq_cells[cdma2000_cell_count].daho_indication)
        {
            if(RRM_OAM_NCL_TYPE_1XRTT == p_ran_info_from_oam->ncl_params.inter_rat_ncl.cdma2000_freq_cells[cdma2000_cell_count].type)
            {
                for(count = RRM_ZERO; count < p_ran_info_to_cellm->ncl_params.
                        inter_rat_ncl.cdma2000_freq_cells[cdma2000_cell_count].num_valid_count_cid; count++)
                {
                    p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_cdma_params.cdma2000_cell_param.cell_id_1xrtt.
                        cdma2000_1xrtt_cell_id[count] = p_ran_info_from_oam->mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.cdma2000_cell_param.
                        cell_id_1xrtt.cdma2000_1xrtt_cell_id[count];
                }

                p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.cdma2000_cell_param.bitmask |= 
                    RRMCM_RMIF_CDMA2000_PARAM_1XRTT_CELL_ID_PRESENCE_FLAG;

                p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.presence_bitmask |=
                    RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG;
                XRTT_DAHO_FOUND = RRM_TRUE;
            }
            if(RRM_OAM_NCL_TYPE_HRPD == p_ran_info_from_oam->ncl_params.inter_rat_ncl.cdma2000_freq_cells[cdma2000_cell_count].type)
            {
                p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.cdma2000_cell_param.cell_id_hrpd.
                    cdma2000_hrpd_cell_id_length = 16;

                for(count = RRM_ZERO; count < p_ran_info_to_cellm->ncl_params.inter_rat_ncl.
                        cdma2000_freq_cells[cdma2000_cell_count].num_valid_count_cid; count++)
                {
                    p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                        idle_mode_mobility_irat_cdma_params.cdma2000_cell_param.cell_id_hrpd.
                        cdma2000_hrpd_cell_id[count] = p_ran_info_from_oam->mobility_params.
                        idle_mode_mobility_params.idle_mode_mobility_inter_rat_cdma2000_params.cdma2000_cell_param.
                        cell_id_hrpd.cdma2000_hrpd_cell_id[count];
                }

                p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.cdma2000_cell_param.bitmask |= 
                    RRMCM_RMIF_CDMA2000_PARAM_HRPD_CELL_ID_PRESENCE_FLAG;

                p_ran_info_to_cellm->mobility_params.idle_mode_mobility_params.
                    idle_mode_mobility_irat_cdma_params.presence_bitmask |=
                    RRMCM_RMIF_CDMA2000_CELL_PARAMS_PRESENCE_FLAG;
                HRPD_DAHO_FOUND = RRM_TRUE;
            }
        }
        if((RRM_TRUE == XRTT_DAHO_FOUND) && (RRM_TRUE == HRPD_DAHO_FOUND))
        {
            break;
        }
    }


    /* Populating RRC Timers_Constant Info */   
    fill_rrc_timer_constant_info_cell_config(&p_ran_info_to_cellm->rrc_timers_and_constants, 
            &p_ran_info_from_oam->rrc_timers_and_constants);
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_RRC_TIMERS_CONST_PARAMS_PRESENT;


    /* Populating RF Info */   
    /* SPR 20653 Fix Start */
    fill_rf_info(&p_ran_info_to_cellm->rf_params, 
            &p_ran_info_from_oam->rf_params);
    /* SPR 20653 Fix End */
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_RF_PARAMS_PRESENT;
/* SPR 21417 FIXED START */
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_ANTENNA_PORTS_COUNT_NO_PRESENT; 
/* SPR 21417 FIXED END */

    /* SPR 20653 Fix Start */
    p_ran_info_to_cellm->antenna_info.antenna_ports_count_number = 
        rrm_map_antenna_ports_count_number_from_oam_to_cellm(
                p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number);
    if (RRM_THREE == p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "Antenna port number(%d) range invalid", 
                p_ran_info_from_oam->rf_params.rf_configurations.antenna_ports_count_number);
    }
    /* SPR 20653 Fix End */


    /* Populating Common EUTRAN Info */
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating Common EUTRAN Info");
    for (cell_idx = 0; cell_idx < MAX_CELL_IDENTITY_OCTETS; cell_idx++)
    {
        p_ran_info_to_cellm->common_eutran_params.cell_identity[cell_idx] = 
            p_cell_id_from_oam->cell_identity[cell_idx];
    }
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_COMMON_EUTRAN_PARAMS_PRESENT;

    /* Populating S1-AP Info */   
    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating S1AP Info");
    p_ran_info_to_cellm->s1ap_params.t_reloc_prep=
        p_ran_info_from_oam->s1ap_params.t_reloc_prep;
    p_ran_info_to_cellm->s1ap_params.t_reloc_overall = 
        p_ran_info_from_oam->s1ap_params.t_reloc_overall;
    p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_S1AP_PARAMS_PRESENT;


    /* Populating NCL Info */   
    if (p_ran_info_from_oam->bitmask & RRM_OAM_NCL_PARAMS_PRESENT)
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "RRMCM_RMIF_NCL_PARAMS_PRESENT");

        /* SPR 5193 */
        fill_ncl_info(/*SPR 17777 +-*/
                &p_ran_info_to_cellm->ncl_params, 
                p_operator_info_to_cellm,
                &p_ran_info_from_oam->ncl_params);
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_NCL_PARAMS_PRESENT;
    }

    /* Populating connected mode mobility*/
    if (RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT == 
            (p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT))
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
                "RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT");
        rrm_oam_fill_connected_mode_mobility_info(
                &p_ran_info_to_cellm->connected_mode_mobility_params, 
                &p_ran_info_from_oam->connected_mode_mobility_params);
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT;
    }

    if(p_ran_info_from_oam->bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_PRESENT)
    {
        if(p_ran_info_from_oam->connected_mode_mobility_params.bitmask & RRM_OAM_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT)
        {
            /* SPR 16880: start */
            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_MEAS_QUANTITY_CDMA2000_PRESENT)
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.meas_quantity_cdma2000 = 
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.meas_quantity_cdma2000;
                /* SPR 20653 Fix Start */
            }
            else
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.meas_quantity_cdma2000 = RRM_RRC_PILOT_STRENGTH;
            }
            /* SPR 16880: end */
            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_B1_THRESHOLD_CDMA2000_PRESENT)
            {
                /* SPR 16880: start */
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b1_threshold_cdma2000 = 
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.b1_threshold_cdma2000;
                /* SPR 16880: end */

            }
            else
            {
                /* SPR 16880: start */
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b1_threshold_cdma2000 =
                    RRM_DEFINED_DEFAULT_VALUE_FOR_B1_THRESHOLD_CDMA2000;
                /* SPR 16880: end */
            }

            if(p_ran_info_from_oam->connected_mode_mobility_params.irat.bitmask & RRM_OAM_B2_THRESHOLD_2CDMA_PRESENT)
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b2_threshold_cdma2000 =
                    p_ran_info_from_oam->connected_mode_mobility_params.irat.b2_threshold_2cdma;

            }
            else
            {
                p_ran_info_to_cellm->connected_mode_mobility_params.irat.b2_threshold_cdma2000 =
                    RRM_DEFINED_DEFAULT_VALUE_FOR_B2_THRESHOLD_CDMA2000;
            }
            /* SPR 20653 Fix End */
            /* SPR 16880: start */
            /* Code removed */
            /* SPR 16880: end */
            p_ran_info_to_cellm->connected_mode_mobility_params.bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_INTER_RAT_PRESENT;
        }
        p_ran_info_to_cellm->bitmask |= RRMCM_RMIF_CONNECTED_MODE_MOBILITY_PARAMS_PRESENT;
    }

    if (p_operator_info_from_oam->bitmask & RRM_OAM_MIMO_MODE_PARAMS_PRESENT)
    {
        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
            /* coverity  : CID  41563 */
        /* SPR 20653 Fix Start */
        /* SPR 20653 Fix End */

         /* SPR 21417 FIXED START */
        /* Code Remove */
         /* SPR 21417 FIXED END */
            /* SPR 12603_12618 Fix start */
            /*cov_fix_65854_start*/
        /* SPR 20653 Fix Start */
        /* Code Removed */
        /* SPR 20653 Fix End */
            /*cov_fix_65854_end*/
            /* SPR 12603_12618 Fix end */

       
                 /* SPR 21417 FIXED START */
                /* Code Remove */
                 /* SPR 21417 FIXED END */


        if (p_operator_info_from_oam->mimo_mode_params.bitmask & RRM_OAM_CODEBOOK_SUBSET_RESTRICTION_PRESENT)
        {
            p_ran_info_to_cellm->antenna_info.num_cbsr = p_operator_info_from_oam->mimo_mode_params.num_of_cbsr;

            for(index = RRM_ZERO;
                    (( index<p_operator_info_from_oam->mimo_mode_params.num_of_cbsr) && 
                     ( index < RRM_OAM_MAX_CODEBOOK_SUBSET )); index++)
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED ,
                        "CBSR type received = %d",
                        p_operator_info_from_oam->mimo_mode_params.mimo_cbsr[index].type);

                p_ran_info_to_cellm->antenna_info.cbsr[index].type =
                    p_operator_info_from_oam->mimo_mode_params.mimo_cbsr[index].type;

                RRM_MEMCPY(p_ran_info_to_cellm->antenna_info.cbsr[index].value,
                        p_operator_info_from_oam->mimo_mode_params.mimo_cbsr[index].value,
                        RRM_EIGHT);
            }
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "CBSR info is not coming from OAM"); 
        }

        /*TM mode 7-8 start*/
        if(p_operator_info_from_oam->mimo_mode_params.bitmask & RRM_OAM_SINR_THRESHOLD_PRESENT)
        {
            p_ran_info_to_cellm->antenna_info.sinr_threshold = p_operator_info_from_oam->mimo_mode_params.sinr_threshold;
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "SINR THRSHOLD is not coming from OAM"); 
        }
        if(p_operator_info_from_oam->mimo_mode_params.bitmask & RRM_OAM_PATHLOSS_THRESHOLD_PRESENT)
        {
            p_ran_info_to_cellm->antenna_info.pathloss_threshold = p_operator_info_from_oam->mimo_mode_params.pathloss_threshold;
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
                    "PATHLOSS THRSHOLD is not coming from OAM so taking default value as 70"); 
            p_ran_info_to_cellm->antenna_info.pathloss_threshold = RRM_DEFINED_DEFAULT_VALUE_FOR_PL_THRESHOLD; 
        }
        if(p_operator_info_from_oam->mimo_mode_params.bitmask & RRM_OAM_MOBILITY_SINR_THRESHOLD_PRESENT)  
        {
            p_ran_info_to_cellm->antenna_info.ue_speed_catagory_data.ue_speed_category1_deltaSINR_thresold =
                p_operator_info_from_oam->mimo_mode_params.mobility_sinr_threshold;
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                    "MOBILITY THRSHOLD is not coming from OAM"); 
        }
        /*TM mode 7-8 end*/
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_WARNING,
                "Mimo mode parmas is not coming from OAM ");
    }

    RRM_UT_TRACE_EXIT();
}

/* TTT_UPDATE_IND CHANGES START */ 
/****************************************************************************
 * Function Name  : build_and_send_son_ttt_update_ind_to_cellm
 * Inputs         : -p_gl_ctxt - It's not null pointer.
 *                  -p_mif_context - It's not null pointer.
 *                  -p_in_updated_nrt_info_req_msg - It's not null pointer.
 * Outputs        : None
 * Returns        : void
 * Description    : This function prepares TTT Update Ind Request to CellM
 ****************************************************************************/
    rrm_return_et 
build_and_send_son_ttt_update_ind_to_cellm(
        rrm_mif_gb_context_t	 *p_gl_ctxt,
        rrm_mif_context          *p_mif_context, 
        son_rrm_ttt_update_ind_t *p_in_ttt_update_ind,
        U16                       src
        )
{
    rrmcm_rmif_ttt_update_ind_t *p_out_ttt_update_ind = RRM_PNULL;
    rrm_return_et                ret_val= RRM_FAILURE;

    RRM_UT_TRACE_ENTER();

    if((RRM_PNULL != p_gl_ctxt) &&
            (RRM_PNULL != p_mif_context) &&
            (RRM_PNULL != p_in_ttt_update_ind))
    {
        p_out_ttt_update_ind = (rrmcm_rmif_ttt_update_ind_t*)
            rrm_mem_get(sizeof(rrmcm_rmif_ttt_update_ind_t));
        if(RRM_PNULL != p_out_ttt_update_ind)
        {
            p_out_ttt_update_ind->cell_index = p_mif_context->cell_index;
            /* coverity : CID 29708*/
            p_out_ttt_update_ind->updated_ttt = (rrm_time_to_trigger_et) p_in_ttt_update_ind->updated_ttt;

            if (RRM_SON_MRO_MODULE_ID == src)
            {
                /* Sending updated NRT Info to RRMCM */
                rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
                        RRMCM_RMIF_TTT_UPDATE_IND_REQ,
                        (U16)(sizeof(rrmcm_rmif_ttt_update_ind_t)),
                        (void *)p_out_ttt_update_ind);
                ret_val=RRM_SUCCESS;
            }
            else
            {
                RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                        "Message received from Invalid Source(%d)", src);
            }
            RRM_MEM_FREE(p_out_ttt_update_ind);
        }
        else
        {
            RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                    "p_out_ttt_update_ind memory allocation failure occured");
            return RRM_FAILURE;
        }
    }
    else
    {
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_ERROR,
                "cell_context =%p /mif_context =%p /ttt_update_ind =%p is(are) null", 
                p_gl_ctxt,p_mif_context, p_in_ttt_update_ind);
    }

    RRM_UT_TRACE_EXIT();
    return ret_val;
}
/* TTT_UPDATE_IND CHANGES ENDS */

/* UE positioning start */
/****************************************************************************
 * Function Name  : populate_eutran_access_point_pos_params
 * Inputs         : - eutran_access_point_pos_from_oam
 *                  - eutran_access_point_pos_to_cellm
 * Outputs        : None
 * Returns        : void
 * Description    : This function populates the EUTRAN Access Point Position
 *                  data for the CellM module
 ****************************************************************************/
    rrm_void_t
populate_eutran_access_point_pos_params(
        rrm_oam_eutran_access_point_pos_t *eutran_access_point_pos_from_oam,
        rrm_eutran_access_point_pos_t     *eutran_access_point_pos_to_cellm
        )
{
    RRM_ASSERT (RRM_PNULL != eutran_access_point_pos_from_oam);
    RRM_ASSERT (RRM_PNULL != eutran_access_point_pos_to_cellm);

    U32 temp;
    S32 var;
    float float_var;
    U16 value;

    RRM_UT_TRACE_ENTER();

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating EUTRAN Access Point Position params start");

    eutran_access_point_pos_to_cellm->bitmask |= 0x00;

    eutran_access_point_pos_to_cellm->latitude_sign = 
        eutran_access_point_pos_from_oam->latitude_sign;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, 
            "Latitude sign to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->latitude_sign);

    if (90 == eutran_access_point_pos_from_oam->deg_of_latitude)
    {
        eutran_access_point_pos_to_cellm->deg_of_latitude = RRM_POW(2,23) - 1;
    }
    else
    {
        temp = (RRM_POW(2,23) * eutran_access_point_pos_from_oam->deg_of_latitude)/90;
        eutran_access_point_pos_to_cellm->deg_of_latitude = temp;
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Degree of Latitude to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->deg_of_latitude);

    if (180 == eutran_access_point_pos_from_oam->deg_of_longitude)
    {
        eutran_access_point_pos_to_cellm->deg_of_longitude = RRM_POW(2,23) - 1;
    }
    else
    {
        var = (RRM_POW(2,24) * eutran_access_point_pos_from_oam->deg_of_longitude)/360;
        eutran_access_point_pos_to_cellm->deg_of_longitude = var;
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Degree of Longitude to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->deg_of_longitude);

    eutran_access_point_pos_to_cellm->dir_of_altitude = 
        eutran_access_point_pos_from_oam->dir_of_altitude;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Direction of altitude to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->dir_of_altitude);

    eutran_access_point_pos_to_cellm->altitude = 
        eutran_access_point_pos_from_oam->altitude;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Altitude to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->altitude);

    /* r = 10[(1.1)^k - 1], r is the configured value from OAM and k is the value sent to RRC
     * So we can write k = RRM_LOG10[(r/10) + 1] / RRM_LOG10(1.1)*/
    /* SPR 8085 Fix */
    float_var = RRM_LOG10(((float)eutran_access_point_pos_from_oam->uncertainty_semi_major/10) + 1)/RRM_LOG10(1.1);
    temp = float_var;
    if (127 < temp)
    {
        eutran_access_point_pos_to_cellm->uncertainty_semi_major = 127;
    }
    else
    {
        eutran_access_point_pos_to_cellm->uncertainty_semi_major = temp;
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Uncertainty Semi Major to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->uncertainty_semi_major);

    /* r = 10[(1.1)^k - 1], r is the configured value from OAM and k is the value sent to RRC
     * So we can write k = RRM_LOG10[(r/10) + 1] / RRM_LOG10(1.1) */
    /* SPR 8085 Fix */
    float_var = RRM_LOG10(((float)eutran_access_point_pos_from_oam->uncertainty_semi_minor/10) + 1)/RRM_LOG10(1.1);
    temp = float_var;
    if (127 < temp)
    {
        eutran_access_point_pos_to_cellm->uncertainty_semi_minor = 127;
    }
    else
    {
        eutran_access_point_pos_to_cellm->uncertainty_semi_minor = temp;
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Uncertainty Semi Minor to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->uncertainty_semi_minor);

    eutran_access_point_pos_to_cellm->orientation_of_major_axis = 
        eutran_access_point_pos_from_oam->orientation_of_major_axis;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Orientation of Major Axis to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->orientation_of_major_axis);

    /* h = 45[(1.025)^k - 1], h is the configured value from OAM and k is the value sent to RRC
     * So we can write k = RRM_LOG10[(h/45) + 1] / RRM_LOG10(1.025) */
    /* SPR 8085 Fix */
    float_var = RRM_LOG10(((float)eutran_access_point_pos_from_oam->uncertainty_altitude/45) + 1)/RRM_LOG10(1.025);
    value = float_var;
    if (127 < value)
    {
        eutran_access_point_pos_to_cellm->uncertainty_altitude = 127;
    }
    else
    {
        eutran_access_point_pos_to_cellm->uncertainty_altitude = value;
    }

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Uncertainty Altitude to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->uncertainty_altitude);

    eutran_access_point_pos_to_cellm->confidence = 
        eutran_access_point_pos_from_oam->confidence;

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED,
            "Confidence to be sent to RRC is: %d", eutran_access_point_pos_to_cellm->confidence);

    RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name, RRM_DETAILED, "Populating EUTRAN Access Point Position params end");
    RRM_UT_TRACE_EXIT();
}
/* UE positioning end */
/* SPR 12603_12618 Fix start */
/* SPR 20653 Fix Start */
/* Code Removed */
/* SPR 20653 Fix End */
/*SPR 12603_12618 Fix end*/

/* SPR_13117_FIX_START */
/****************************************************************************
 * Function Name  :rrm_build_and_get_log_level_resp
 * Inputs         :p_out_message
 *                :module_id
 * Outputs        : None
 * Returns        : void
 * Description    : This function get module_id and fill the log_level after mapping
 *                : for CellM/UeM
 ****************************************************************************/
rrm_void_t rrm_build_and_get_log_level_resp(rrm_oam_get_log_level_resp_t *p_out_message,
        rrmuem_rmif_get_log_level_resp_t *p_log_level_of_cellm_uem,
        rrm_mif_gb_context_t *p_gl_ctxt
        )
{
    rrm_internal_module_id_et module_id;
    rrm_oam_log_on_off_et  log_flag;

    RRM_UT_TRACE_ENTER();
    if ((RRM_PNULL != p_out_message) && (p_gl_ctxt != RRM_PNULL) && (RRM_PNULL != p_log_level_of_cellm_uem))
    {
        module_id = (rrm_internal_module_id_et)p_log_level_of_cellm_uem->module_id;
        switch(module_id)
        {
            case RRM_ALL_MODULE_ID:

                p_out_message->fail_cause = RRM_NO_ERROR;
                p_out_message->num_of_modules = RRM_THREE;

                p_out_message->module_id[RRM_ZERO].module_id =  RRM_OAM_CM_MODULE_ID;
                log_flag = (rrm_oam_log_on_off_et)p_log_level_of_cellm_uem->log_level_on_off_on_cell;
                if (RRM_OAM_LOG_OFF == log_flag)
                {
                    p_out_message->response = RRM_PARTIAL_SUCCESS;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_ERR_LOGGING_DISABLED;
                    p_out_message->module_id[RRM_ZERO].bitmask = RRM_ZERO;
                }
                else
                {
                    p_out_message->response = RRM_SUCCESS;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_NO_ERROR;
                    p_out_message->module_id[RRM_ZERO].bitmask |= RRM_OAM_MODULE_LOG_LEVEL_PRESENT;
                    /* cov_67021_start */
                    p_out_message->module_id[RRM_ZERO].log_level = (rrm_oam_log_level_et)p_log_level_of_cellm_uem->log_level_for_cellm;
                    /* cov_67021_end */
                }

                p_out_message->module_id[RRM_ONE].module_id =  RRM_OAM_UEM_MODULE_ID;
                log_flag = (rrm_oam_log_on_off_et)p_log_level_of_cellm_uem->log_level_on_off_on_ue;
                if (RRM_OAM_LOG_OFF == log_flag)
                {
                    p_out_message->response = RRM_PARTIAL_SUCCESS;
                    p_out_message->module_id[RRM_ONE].error_code = RRM_ERR_LOGGING_DISABLED;
                    p_out_message->module_id[RRM_ONE].bitmask = RRM_ZERO;
                }
                else
                {
                    p_out_message->response = RRM_SUCCESS;
                    p_out_message->module_id[RRM_ONE].error_code = RRM_NO_ERROR;
                    p_out_message->module_id[RRM_ONE].bitmask |= RRM_OAM_MODULE_LOG_LEVEL_PRESENT;
                    p_out_message->module_id[RRM_ONE].log_level = (rrm_oam_log_level_et)p_log_level_of_cellm_uem->log_level_for_uem;
                }

                p_out_message->module_id[RRM_TWO].module_id =  RRM_OAM_MIF_MODULE_ID;
                if (RRM_OAM_LOG_OFF == p_gl_ctxt->log_enabled)
                {
                    p_out_message->response = RRM_PARTIAL_SUCCESS;
                    p_out_message->module_id[RRM_TWO].error_code = RRM_ERR_LOGGING_DISABLED;
                    p_out_message->module_id[RRM_TWO].bitmask = RRM_ZERO;
                }
                else
                {
                    p_out_message->response = RRM_SUCCESS;
                    p_out_message->module_id[RRM_TWO].error_code = RRM_NO_ERROR;
                    p_out_message->module_id[RRM_TWO].bitmask |= RRM_OAM_MODULE_LOG_LEVEL_PRESENT;
                    p_out_message->module_id[RRM_TWO].log_level = p_gl_ctxt->log_level;
                }

                break;

            case RRM_OAM_UEM_MODULE_ID:

                p_out_message->fail_cause = RRM_NO_ERROR;
                p_out_message->num_of_modules = RRM_ONE;

                p_out_message->module_id[RRM_ZERO].module_id =  RRM_OAM_UEM_MODULE_ID;
                log_flag = (rrm_oam_log_on_off_et)p_log_level_of_cellm_uem->log_level_on_off_on_ue;
                if (RRM_OAM_LOG_OFF == log_flag)
                {
                    p_out_message->response = RRM_FAILURE;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_ERR_LOGGING_DISABLED;
                    p_out_message->module_id[RRM_ZERO].bitmask = RRM_ZERO;
                }
                else
                {
                    p_out_message->response = RRM_SUCCESS;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_NO_ERROR;
                    p_out_message->module_id[RRM_ZERO].bitmask |= RRM_OAM_MODULE_LOG_LEVEL_PRESENT;
                    p_out_message->module_id[RRM_ZERO].log_level = (rrm_oam_log_level_et)p_log_level_of_cellm_uem->log_level_for_uem;
                }
                break;

            default:
                p_out_message->fail_cause = RRM_NO_ERROR;
                p_out_message->num_of_modules = RRM_ONE;

                p_out_message->module_id[RRM_ZERO].module_id =  RRM_OAM_CM_MODULE_ID;
                log_flag = (rrm_oam_log_on_off_et)p_log_level_of_cellm_uem->log_level_on_off_on_cell;
                if (RRM_OAM_LOG_OFF == log_flag)
                {
                    p_out_message->response = RRM_FAILURE;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_ERR_LOGGING_DISABLED;
                    p_out_message->module_id[RRM_ZERO].bitmask = RRM_ZERO;
                }
                else
                {
                    p_out_message->response = RRM_SUCCESS;
                    p_out_message->module_id[RRM_ZERO].error_code = RRM_NO_ERROR;
                    p_out_message->module_id[RRM_ZERO].bitmask |= RRM_OAM_MODULE_LOG_LEVEL_PRESENT;
                    p_out_message->module_id[RRM_ZERO].log_level = (rrm_oam_log_level_et)p_log_level_of_cellm_uem->log_level_for_cellm;
                }
                break;
        }
    }
    RRM_UT_TRACE_EXIT();
}
/****************************************************************************
 * Function Name  :build_and_send_get_log_level_req_to_cellm_uem
 * Inputs         :module_id
 *                :
 * Outputs        : None
 * Returns        : void
 * Description    : This function get module_id and send request for get log_level
 *                : to UEM and Uem get log_level for CellM also
 ****************************************************************************/

rrm_void_t rrm_build_and_send_get_log_level_req_to_cellm_uem(rrm_internal_module_id_et mode_id,U16 trans_id)
{
    rrmuem_rmif_get_log_level_req_t rrmuem_rmif_get_log_level_req;

    RRM_UT_TRACE_ENTER();
    rrmuem_rmif_get_log_level_req.module_id = mode_id;
    rrmuem_rmif_get_log_level_req.transaction_id = trans_id;
    rrm_mif_send_internal_msg(RRM_OAM_UEM_MODULE_ID,
            RRMUEM_RMIF_GET_LOG_LEVEL_REQ,
            /*SPR 20953 Fix Start*/
             sizeof(rrmuem_rmif_get_log_level_req_t),
            /*SPR 20953 Fix End*/
            &rrmuem_rmif_get_log_level_req);

    RRM_UT_TRACE_EXIT();
}

/* SPR_13117_FIX_END */

/* Spr 16142 Fix Start */
/****************************************************************************
 * Function Name  : build_and_send_son_stop_tnl_discovery_to_cellm
 * Inputs         : p_in_stop_tnl_discovery_ind
 *                :
 * Outputs        : None
 * Returns        : void
 * Description    : This function send request for stop tnl discovery ind to
 *                : CellM
 ****************************************************************************/
    void build_and_send_son_stop_tnl_discovery_to_cellm
(
 son_rrm_stop_tnl_discovery_ind_t *p_in_stop_tnl_discovery_ind
 )
{
    rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t  *p_out_stop_tnl_discovery_ind = RRM_PNULL;
    U16                        count = RRM_ZERO;

    RRM_UT_TRACE_ENTER();

    RRM_ASSERT (RRM_PNULL != p_in_stop_tnl_discovery_ind);

    p_out_stop_tnl_discovery_ind = (rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t *)
        rrm_mem_get(sizeof(rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t));
    if ( p_out_stop_tnl_discovery_ind == RRM_PNULL)
    {
        RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_BRIEF,
                "Memory allocation to p_out_stop_tnl_discovery_ind failed" );
        RRM_UT_TRACE_EXIT();
        return ;
    }
    /* Spr 16142 Fix Start */
    RRM_MEMSET((void *)p_out_stop_tnl_discovery_ind,0,
            sizeof(rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t));
    /* Spr 16142 Fix End */

    p_out_stop_tnl_discovery_ind->target_enb_id.enb_type =
        (rrm_enb_type_et)p_in_stop_tnl_discovery_ind->target_enb_id.enb_type;/*cov 93970+-*/

    rrm_memcpy_rrm_oam_cell_plmn_info(&p_out_stop_tnl_discovery_ind->
            target_enb_id.plmn_id,
            (rrm_oam_cell_plmn_info_t *)&p_in_stop_tnl_discovery_ind->
            target_enb_id.plmn_id);

    for(count=RRM_ZERO; count<HOME_ENB_ID_OCTET_SIZE; count++)
    {
        p_out_stop_tnl_discovery_ind->target_enb_id.eNb_id[count] =
            p_in_stop_tnl_discovery_ind->target_enb_id.enb_id[count];
    }

    /* Sending Stop TNL discovery indication to RRMCM*/
    rrm_mif_send_internal_msg(RRM_CM_MODULE_ID,
            RRMCM_RMIF_STOP_TNL_DISCOVERY_FROM_ANR_REQ,
            sizeof(rrmcm_rmif_cell_son_stop_tnl_discovery_ind_t),
            (void *)p_out_stop_tnl_discovery_ind);

    RRM_MEM_FREE(p_out_stop_tnl_discovery_ind);

    RRM_UT_TRACE_EXIT();
}
/* Spr 16142 Fix End */

/* Coverity 88477-80 Fix Start */
rrm_q_offsetrange_et
    rrm_map_q_offset_from_oam_to_cellm
(
 rrm_oam_q_offset_range_et oam_q_offset
 )
{
    rrm_q_offsetrange_et cellm_q_offset = RRM_Q_OFFSET_RANGE_DB0;
    RRM_UT_TRACE_ENTER();

    switch( oam_q_offset )
    {
        case RRM_OAM_Q_OFFESET_RANGE_DB_24:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_24;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_22:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_22;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_20:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_20;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_18:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_18;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_16:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_16;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_14:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_14;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_12:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_12;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_10:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_10;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_8:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_8;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_6:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_6;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_5:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_5;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_4:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_4;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_3:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_3;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_2:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_3;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB_1:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB_3;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB0:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB0;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB1:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB1;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB2:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB2;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB3:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB3;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB4:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB4;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB5:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB5;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB6:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB6;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB8:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB8;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB10:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB10;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB12:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB12;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB14:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB14;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB16:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB16;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB18:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB18;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB20:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB20;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB22:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB22;
                break;
            }
        case RRM_OAM_Q_OFFESET_RANGE_DB24:
            {
                cellm_q_offset =  RRM_Q_OFFSET_RANGE_DB24;
                break;
            }
    }
    RRM_UT_TRACE_EXIT();
    return cellm_q_offset;
}
/* Coverity 88477-80 Fix End */

/* SPR 15393 Fix Start */
/****************************************************************************
 * Function Name  : rrm_convert_son_geran_nbr_data_to_rrm_geran_nbr_data
 * Inputs         : p_out_geran_nbr_data,p_in_geran_nbr_data
 *                :
 * Outputs        : None
 * Returns        : void
 * Description    : This Function updates the geran nbr data from SON to 
 * 		  : CellM
 ****************************************************************************/
static rrm_void_t rrm_convert_son_geran_nbr_data_to_rrm_geran_nbr_data(rrmcm_rmif_geran_neighbor_cell_t *p_out_geran_nbr_data,son_rrm_geran_neighbor_cell_t *p_in_geran_nbr_data)
{
    RRM_UT_TRACE_ENTER();
    RRM_MEMCPY(&p_out_geran_nbr_data->cgi, &p_in_geran_nbr_data->cgi, sizeof(rrm_son_utran_geran_global_cell_id_t));
    RRM_MEMCPY(&p_out_geran_nbr_data->pci, &p_in_geran_nbr_data->pci, sizeof(rrmcm_rmif_geran_physical_cell_id_t));
    if(p_in_geran_nbr_data->bitmask & SON_RRM_GERAN_NR_INFO_OFFSET_PRESENT)
    {
        p_out_geran_nbr_data->cell_specific_offset = p_in_geran_nbr_data->cell_specific_offset;
        p_out_geran_nbr_data->bitmask |= RRMCM_RMIF_GERAN_NR_INFO_OFFSET_PRESENT;
    }
    if(p_in_geran_nbr_data->bitmask & SON_RRM_GERAN_RAC_PRESENT)
    {
        p_out_geran_nbr_data->rac = p_in_geran_nbr_data->rac;
        p_out_geran_nbr_data->bitmask |= RRMCM_RMIF_GERAN_RAC_PRESENT;
        RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
                RRM_DETAILED, " geran rac is present");
    }

    RRM_UT_TRACE_EXIT();
} 

/****************************************************************************
 * Function Name  : rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs
 * Inputs         : p_out_geran_nbr_info,p_in_geran_nbr_info
 *                :
 * Outputs        : None
 * Returns        : void
 * Description    : This function updates the SON geran nbrs to CellM
 ****************************************************************************/
static rrm_void_t rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs(rrmcm_rmif_geran_neighbor_list_t *p_out_geran_nbr_info, son_rrm_geran_neighbor_list_t *p_in_geran_nbr_info)
{
    U32 index 				= RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_out_geran_nbr_info->arfcn 		= p_in_geran_nbr_info->arfcn;
    /*CID 86333 Start*/
    p_out_geran_nbr_info->band_ind		= (rrmcm_rmif_geran_band_indicator_et)p_in_geran_nbr_info->band_ind;
    /*CID 86333 End*/
    p_out_geran_nbr_info->cell_list_size	= p_in_geran_nbr_info->cell_list_size;

    for(index = RRM_ZERO; (index < p_out_geran_nbr_info->cell_list_size) && (index < RRM_MAX_NUM_EARFCN); index ++)
    {
        /*SPR 17838 FIX START */
        rrm_convert_son_geran_nbr_data_to_rrm_geran_nbr_data(&(p_out_geran_nbr_info->cell_list[index]),&(p_in_geran_nbr_info->cell_list[index]));
        /*SPR 17838 FIX END */
    }
    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_populate_geran_neighbour_list
 * Inputs         : p_out_updated_nrt_info_msg,p_in_updated_nrt_info_msg
 *                :
 * Outputs        : None
 * Returns        : void
 * Description    : This function populates the geran nbr list to CellM 
 ****************************************************************************/
rrm_void_t rrm_populate_geran_neighbour_list(rrmcm_rmif_updated_nrt_info_t *p_out_updated_nrt_info_msg,son_anr_rrm_updated_nrt_info_t *p_in_updated_nrt_info_msg)
{

    U32 index 				= RRM_ZERO;
    RRM_UT_TRACE_ENTER();
    p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_add_mod_list_size = 
        p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_add_mod_list_size;
    for(index = RRM_ZERO; 
            (index < p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_add_mod_list_size) 
            && (index < MAX_NO_GERAN_FREQ_GROUUP);
            index ++)
    {
        /*SPR 17838 FIX START */
        rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs(&(p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_add_mod_list[index]), &(p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_add_mod_list[index]));
        /*SPR 17838 FIX END */
    }



    p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_remove_list_size= 
        p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_remove_list_size;
    for(index = RRM_ZERO; 
            (index < p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_remove_list_size) 
            && (index < MAX_NO_GERAN_FREQ_GROUUP);
            index ++)
    {
        /*SPR 17838 FIX START */
        rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs( &(p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_remove_list[index]), &(p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.cells_to_remove_list[index]));
        /*SPR 17838 FIX END */
    }



    p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_add_mod_list_size= 
        p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_add_mod_list_size;
    for(index = RRM_ZERO; 
            (index < p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_add_mod_list_size) 
            && (index < MAX_NO_GERAN_FREQ_GROUUP );
            index ++)
    {
        /*SPR 17838 FIX START */
        rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs( &(p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_add_mod_list[index]), &(p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_add_mod_list[index]));
        /*SPR 17838 FIX END */
    }



    p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_remove_list_size= 
        p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_remove_list_size;
    /* Coverity_fix 98967 ++ */
    for(index = RRM_ZERO; 
            (index < p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_remove_list_size) 
            && (index < RRM_MAX_NO_EARFCN );
            index ++)
        /* Coverity_fix 98967 -- */
    {
        /*SPR 17838 FIX START */
        rrm_convert_son_geran_nbrs_to_rrm_geran_nbrs( &(p_out_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_remove_list[index]), &(p_in_updated_nrt_info_msg->inter_rat_ncl.geran_neighbor_list.black_list_cells_to_remove_list[index]));
        /*SPR 17838 FIX END */
    }

    RRM_UT_TRACE_EXIT();
}
/* SPR 15393 Fix Stop */
/* SPR22359 MBMS changes start */
/****************************************************************************
 * Function Name  : rrm_fill_intra_rat_ncl_params_for_cellm 
 * Inputs         : - p_out_intra_cell
 *                  - p_in_intra_cell
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill the intra_rat_ncl_params_for_cellm
 ****************************************************************************/

rrm_void_t
    rrm_fill_intra_rat_ncl_params_for_cellm
(
 rrmcm_rmif_intra_rat_neighbor_cell_list_t *p_out_intra_cell,
 son_rrm_intra_rat_neighbor_cell_list_t *p_in_intra_cell
 )
{
    RRM_UT_TRACE_ENTER();

    /*Filling cells_to_add_mod_list */
    p_out_intra_cell->intra_rat_cells_to_add_mod_list_size = 
        p_in_intra_cell->intra_rat_cells_to_add_mod_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Filling intra_rat_cells_to_add_mod_list" );

    rrm_fill_intra_rat_neighbor_list(
            p_out_intra_cell->intra_rat_cells_to_add_mod_list_size,
            p_out_intra_cell->intra_rat_cells_to_add_mod_list,
            p_in_intra_cell->intra_rat_cells_to_add_mod_list);
    /*Filling cells_to_remove_list */

    p_out_intra_cell->intra_rat_cells_to_remove_list_size = 
        p_in_intra_cell->intra_rat_cells_to_remove_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Filling intra_rat_cells_to_remove_list" );
    rrm_fill_intra_rat_neighbor_list(
            p_out_intra_cell->intra_rat_cells_to_remove_list_size,
            p_out_intra_cell->intra_rat_cells_to_remove_list,
            p_in_intra_cell->intra_rat_cells_to_remove_list);

    /*Filling black_list_cells_to_add_mod_ */
    p_out_intra_cell->intra_rat_black_list_cells_to_add_mod_list_size = 
        p_in_intra_cell->intra_rat_black_list_cells_to_add_mod_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Filling intra_rat_black_list_cells_to_add_mod_list" );
    rrm_fill_intra_rat_neighbor_list(
            p_out_intra_cell->intra_rat_black_list_cells_to_add_mod_list_size,
            p_out_intra_cell->intra_rat_black_list_cells_to_add_mod_list,
            p_in_intra_cell->intra_rat_black_list_cells_to_add_mod_list);

    /*Filling black_list_cells_to_remove_list */
    p_out_intra_cell->intra_rat_black_list_cells_to_remove_list_size = 
        p_in_intra_cell->intra_rat_black_list_cells_to_remove_list_size;

    RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, RRM_DETAILED,
                "Filling intra_rat_black_list_cells_to_remove_list" );
    rrm_fill_intra_rat_neighbor_list(
            p_out_intra_cell->intra_rat_black_list_cells_to_remove_list_size,
            p_out_intra_cell->intra_rat_black_list_cells_to_remove_list,
            p_in_intra_cell->intra_rat_black_list_cells_to_remove_list);


    RRM_UT_TRACE_EXIT();
}

/****************************************************************************
 * Function Name  : rrm_fill_intra_rat_neighbor_list 
 * Inputs         : - list_size 
 *                  - p_out_ncl_list
 *                  - p_in_ncl_list
 * Outputs        : None
 * Returns        : void
 * Description    : This function fill intra_rat_neighbor_list from SON
 ****************************************************************************/
rrm_void_t
rrm_fill_intra_rat_neighbor_list
(
 U8 list_size,
 rrmcm_rmif_intra_rat_neighbor_list_t *p_out_ncl_list,
 son_rrm_intra_rat_neighbor_list_t    *p_in_ncl_list
 )
{
    U8 index                                                   = RRM_ZERO;
    U8 cell_count                                              = RRM_ZERO;
    U8 sf_alloc                                                = RRM_ZERO;
    rrmcm_rmif_intra_rat_neighbor_cell_t *p_out_cell_list      = RRM_PNULL;
    son_rrm_intra_rat_neighbor_cell_t    *p_in_cell_list       = RRM_PNULL;
    RRM_UT_TRACE_ENTER();

    for (index = RRM_ZERO; (index < list_size) &&
            (index < RRM_MAX_NO_EARFCN); index++ )
    {
        p_out_ncl_list[index].earfcn = p_in_ncl_list[index].earfcn;
        p_out_ncl_list[index].cell_list_size = p_in_ncl_list[index].
            cell_list_size;
        for (cell_count = RRM_ZERO; 
                (cell_count < p_out_ncl_list[index].cell_list_size) &&
                (cell_count < RRM_MAX_NO_CELLS_PER_EARFCN); cell_count++)
        {
            p_out_cell_list = &(p_out_ncl_list[index].cell_list[cell_count]);
            p_in_cell_list = &(p_in_ncl_list[index].cell_list[cell_count]);

            p_out_cell_list->bitmask = RRM_ZERO ;

            RRM_MEMCPY(&p_out_cell_list->cgi, &p_in_cell_list->cgi,
                    sizeof(rrm_oam_eutran_global_cell_id_t));
            p_out_cell_list->pci = p_in_cell_list->pci;
            if (SON_RRM_INTRA_RAT_NR_INFO_OFFSET_PRESENT & 
                    p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_OFFSET_PRESENT;
                p_out_cell_list->cell_specific_offset = 
                    p_in_cell_list->cell_specific_offset;
            }
            if (SON_RRM_ENABLE_X2_STATUS_PRESENT & p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_X2_STATUS_PRESENT;
                p_out_cell_list->x2_status = rrm_son_x2_status_enum_mapping(p_in_cell_list->x2_status); 

            }
            if (SON_RRM_TAC_PRESENT & p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_TAC_PRESENT;
                for(sf_alloc= RRM_ZERO; sf_alloc < MAX_TAC_SIZE; sf_alloc++)
                {
                    p_out_cell_list->tac[sf_alloc] = 
                        p_in_cell_list->tac[sf_alloc];
                }

            }
            if (SON_RRM_INTRA_RAT_NR_INFO_CM_OFFSET_PRESENT & 
                    p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_CM_OFFSET_PRESENT;
                p_out_cell_list->cm_cell_specific_offset = 
                    p_in_cell_list->cm_cell_specific_offset;

            }
            if (SON_RRM_ACCESS_MODE_PRESENT & p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_ACCESS_MODE_PRESENT;
                p_out_cell_list->access_mode = 
                    (rrm_oam_access_mode_et)p_in_cell_list->access_mode;

            }
            if (SON_RRM_BROADCAST_STATUS_PRESENT & p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_BROADCAST_STATUS;
                p_out_cell_list->broadcast_status = 
                    (rrm_bool_et)p_in_cell_list->broadcast_status;

            }
            if (SON_RRM_INTRA_CSG_IDENTITY_PRESENT & p_in_cell_list->bitmask)
            {
                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_NR_INFO_CSG_IDENTITY;
                for(sf_alloc= RRM_ZERO; 
                        sf_alloc <RRM_OAM_MAX_NUM_CSG_OCTETS ; sf_alloc++)
                {
                    p_out_cell_list->csg_identity[sf_alloc] = 
                        p_in_cell_list->csg_identity[sf_alloc];
                }

            }
            if (SON_RRM_CELL_INTF_SCHEME_TYPE_PRESENT & 
                    p_in_cell_list->bitmask)
            {
                p_out_cell_list->interference_scheme = 
                    (rrm_oam_intf_scheme_type_et)p_in_cell_list->
                    interference_scheme;
            }
#ifdef LTE_EMBMS_SUPPORTED
            if (SON_RRM_MBSFN_CONFIG_LIST_PRESENT & p_in_cell_list->bitmask)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                        RRM_DETAILED, 
                        "MBSFN info is present for NCL[%d] and "
                        "list count index[%d]", cell_count, index);

                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_RAT_MBSFN_INFO_PRESENT;
                p_out_cell_list->mbsfn_config_info.count = 
                    p_in_cell_list->mbms_config.num_mbsfn;

                 rrm_fills_mbsfn_info_from_son(
                   p_out_cell_list->mbsfn_config_info.count,
                   p_out_cell_list->mbsfn_config_info.
                   mbsfn_subframe_config_info,
                   p_in_cell_list->mbms_config.mbsfn_info);
            }
            if (SON_RRM_TDD_SF_ASSN_PRESENT & p_in_cell_list->bitmask)
            {
                RRM_TRACE(g_cellm_log_on_off, p_rrm_cellm_facility_name, 
                        RRM_DETAILED, 
                        "SF assignment is present for NCL[%d] and "
                        "list count index[%d]", cell_count, index);

                p_out_cell_list->bitmask |= 
                    RRMCM_RMIF_INTRA_TDD_SF_ASSN_INFO_PRESENT;
                p_out_cell_list->subframe_assn = 
                    p_in_cell_list->subframe_assn;
            }
#endif
        }

    }
    RRM_UT_TRACE_EXIT();
}

/* SPR22359 MBMS changes stop */

/***********************************************************************
 * Function Name  : rrm_son_x2_status_enum_mapping
 * Inputs         : -son_status - x2 status from SON
 * Outputs        : x2 status for RRM 
 * Returns        : rrmcm_rmif_cell_x2_status_et
 * Description    : This function maps son x2 status  to rrm x2 status
 **********************************************************************/

static rrmcm_rmif_cell_x2_status_et 
	rrm_son_x2_status_enum_mapping
(
 son_x2_status_et son_x2_status
 )
{
	RRM_UT_TRACE_ENTER();

	rrmcm_rmif_cell_x2_status_et rrm_x2_status;
	switch(son_x2_status)
	{
		case SON_X2_ALLOWED :
			rrm_x2_status =  X2_ALLOWED;
			break;	
		case SON_X2_PROHIBITED:
			rrm_x2_status = X2_PROHIBITED;
			break;
		case SON_X2_ALLOWED_CONNECTED :
			rrm_x2_status = X2_ALLOWED_CONNECTED;
			break;
		case SON_X2_ALLOWED_DISCONNECTED :
			rrm_x2_status = X2_ALLOWED_DISCONNECTED;
			break;
		case SON_X2_PROHIBITED_CONNECTED :
			rrm_x2_status = X2_PROHIBITED_CONNECTED;
			break;
		case SON_X2_PROHIBITED_DISCONNECTED :
			rrm_x2_status = X2_PROHIBITED_DISCONNECTED;
			break;
		case SON_LOCALLY_CONNECTED_CELL :
			rrm_x2_status = X2_LOCALLY_CONNECTED_CELL;
			break;
		default:
			rrm_x2_status = X2_PROHIBITED_DISCONNECTED;
			break;
	}
	RRM_TRACE(g_mif_log_on_off, p_rrm_mif_facility_name,
			RRM_DETAILED,"son_x2_status:%d mapped with rrm_x2_status:%d",son_x2_status,rrm_x2_status);
	return rrm_x2_status;
	RRM_UT_TRACE_EXIT();	

}


