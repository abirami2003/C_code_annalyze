/***************************************************************************
 *
 *  ARICENT -
 *
 *  Copyright (c) 2014 Aricent.
 *
 ****************************************************************************
 * File Details
 * ------------
 *  $Id: $
 ****************************************************************************
 *
 *  File Description : The file rrc_rrm_il_parser.c contains the definitions 
 *                     of rrc-rrm interface message parsing functions.
 *
 ****************************************************************************
 *
 * Revision Details
 * ----------------
 * $Log: $
 *
 ****************************************************************************/
#include "rrc_cp_common.h"
#include "rrc_rrm_il_parser.h"
#include "rrc_rrm_intf.h"
#include "rrc_ext_api.h"
#include "rrc_common_utils.h"

#define ARRSIZE(array_name) (sizeof(array_name) / sizeof(array_name[0]))
#define PUP_TL_LENGTH       (sizeof(U16) + sizeof(U16))


/*****************************************************************************/
/*                      Functions forward declarations                       */
/*****************************************************************************/

static
rrc_return_et
rrc_il_parse_rrm_cause
(
    rrm_cause_t *p_rrm_cause,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_dl_earfcn
(
    rrc_dl_earfcn_t *p_rrc_dl_earfcn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phich_config
(
    phich_config_t *p_phich_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mib_info
(
    mib_info_t *p_mib_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mnc
(
    mnc_t *p_mnc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_plmn_identity
(
    plmn_identity_t *p_plmn_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_plmn_identity_info
(
    plmn_identity_info_t *p_plmn_identity_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_plmn_id_info_list
(
    plmn_id_info_list_t *p_plmn_id_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_access_related_info
(
    cell_access_related_info_t *p_cell_access_related_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_selection_Info
(
    cell_selection_Info_t *p_cell_selection_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_mapping_info
(
    sib_mapping_info_t *p_sib_mapping_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_scheduling_info
(
    scheduling_info_t *p_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_scheduling_info_list
(
    scheduling_info_list_t *p_scheduling_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_tdd_config
(
    tdd_config_t *p_tdd_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_multi_band_info_list
(
    multi_band_info_list_t *p_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_1_v8h0_ies
(
    sib_type_1_v8h0_ies_t *p_sib_type_1_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_selection_info_v920
(
    cell_selection_info_v920_t *p_cell_selection_info_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_CellSelectionInfoCeR13
(
    CellSelectionInfoCeR13_t *p_CellSelectionInfoCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_BrSibMappingInfo
(
    BrSibMappingInfo_t *p_BrSibMappingInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_BrSchedulingInfo
(
    BrSchedulingInfo_t *p_BrSchedulingInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_SchedulingInfoListBrR13
(
    SchedulingInfoListBrR13_t *p_SchedulingInfoListBrR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_FddDownlinkOrTddSubframeBitmapBrR13
(
    FddDownlinkOrTddSubframeBitmapBrR13_t *p_FddDownlinkOrTddSubframeBitmapBrR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_SystemInfoValueTagListR13
(
    SystemInfoValueTagListR13_t *p_SystemInfoValueTagListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_BandwidthReducedAccessRelatedInfoR13
(
    BandwidthReducedAccessRelatedInfoR13_t *p_BandwidthReducedAccessRelatedInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_SibType1V1310Ies
(
    SibType1V1310Ies_t *p_SibType1V1310Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_SibType1V1250Ies
(
    SibType1V1250Ies_t *p_SibType1V1250Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_SibType1V1130Ies
(
    SibType1V1130Ies_t *p_SibType1V1130Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_1_v920_ies
(
    sib_type_1_v920_ies_t *p_sib_type_1_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_1_v890_ies
(
    sib_type_1_v890_ies_t *p_sib_type_1_v890_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_1_Info
(
    sib_type_1_Info_t *p_sib_type_1_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_access_class_barring_Info
(
    access_class_barring_Info_t *p_access_class_barring_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_access_barring_info
(
    access_barring_info_t *p_access_barring_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_preambles_group_a_config
(
    preambles_group_a_config_t *p_preambles_group_a_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_preamble_info
(
    preamble_info_t *p_preamble_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_power_ramping_params
(
    power_ramping_params_t *p_power_ramping_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ra_supervision_info
(
    ra_supervision_info_t *p_ra_supervision_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PreambleMappingInfoR13
(
    PreambleMappingInfoR13_t *p_PreambleMappingInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RachCeLevelInfoR13
(
    RachCeLevelInfoR13_t *p_RachCeLevelInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RachCeLevelInfoListR13
(
    RachCeLevelInfoListR13_t *p_RachCeLevelInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rach_config_common
(
    rach_config_common_t *p_rach_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_bcch_config
(
    bcch_config_t *p_bcch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pcch_config
(
    pcch_config_t *p_pcch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_prach_config_info
(
    prach_config_info_t *p_prach_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_prach_config_sib
(
    prach_config_sib_t *p_prach_config_sib,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pdsch_config_common
(
    pdsch_config_common_t *p_pdsch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pusch_config_basic
(
    pusch_config_basic_t *p_pusch_config_basic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ul_ref_signals_pusch
(
    ul_ref_signals_pusch_t *p_ul_ref_signals_pusch,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pusch_config_common
(
    pusch_config_common_t *p_pusch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pucch_config_common
(
    pucch_config_common_t *p_pucch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sounding_rs_ul_config_common_setup
(
    sounding_rs_ul_config_common_setup_t *p_sounding_rs_ul_config_common_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sounding_rs_ul_config_common
(
    sounding_rs_ul_config_common_t *p_sounding_rs_ul_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_delta_f_list_pucch
(
    delta_f_list_pucch_t *p_delta_f_list_pucch,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_delta_f_pucch_format_two
(
    delta_f_pucch_format_two_t *p_delta_f_pucch_format_two,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_uplink_power_control_common
(
    uplink_power_control_common_t *p_uplink_power_control_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_uplink_power_control_common_v1020
(
    uplink_power_control_common_v1020_t *p_uplink_power_control_common_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PcchConfigV1310
(
    PcchConfigV1310_t *p_PcchConfigV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PdschConfigCommonV1310
(
    PdschConfigCommonV1310_t *p_PdschConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PuschConfigCommonV1310
(
    PuschConfigCommonV1310_t *p_PuschConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_MpdcchNarrowbandsToMonitorR13
(
    MpdcchNarrowbandsToMonitorR13_t *p_MpdcchNarrowbandsToMonitorR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PrachParametersCeR13
(
    PrachParametersCeR13_t *p_PrachParametersCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PrachParametersListCeR13
(
    PrachParametersListCeR13_t *p_PrachParametersListCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RsrpThresholdsPrachInfoListR13
(
    RsrpThresholdsPrachInfoListR13_t *p_RsrpThresholdsPrachInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PrachConfigV1310
(
    PrachConfigV1310_t *p_PrachConfigV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcN1PucchAnInfoListR13
(
    RrcN1PucchAnInfoListR13_t *p_RrcN1PucchAnInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_PucchConfigCommonV1310
(
    PucchConfigCommonV1310_t *p_PucchConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_radio_resource_config_common_sib
(
    radio_resource_config_common_sib_t *p_radio_resource_config_common_sib,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_timers_and_constants
(
    ue_timers_and_constants_t *p_ue_timers_and_constants,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_freq_info
(
    freq_info_t *p_freq_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_subframe_allocation
(
    subframe_allocation_t *p_subframe_allocation,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mbsfn_subframe_config
(
    mbsfn_subframe_config_t *p_mbsfn_subframe_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mbsfn_subframe_config_list
(
    mbsfn_subframe_config_list_t *p_mbsfn_subframe_config_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_2_multi_band_info_list
(
    sib_2_multi_band_info_list_t *p_sib_2_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_2_v8h0_ies
(
    sib_type_2_v8h0_ies_t *p_sib_type_2_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_2_Info
(
    sib_type_2_Info_t *p_sib_type_2_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mobility_state_params
(
    mobility_state_params_t *p_mobility_state_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_speed_depend_scaling_param_hyst
(
    speed_depend_scaling_param_hyst_t *p_speed_depend_scaling_param_hyst,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_speed_depend_reselect
(
    speed_depend_reselect_t *p_speed_depend_reselect,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_reselect_info_comm
(
    cell_reselect_info_comm_t *p_cell_reselect_info_comm,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_reselect_serv_freq_info
(
    cell_reselect_serv_freq_info_t *p_cell_reselect_serv_freq_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_speed_state_scale_factors
(
    speed_state_scale_factors_t *p_speed_state_scale_factors,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_intra_freq_cell_reselect_info
(
    intra_freq_cell_reselect_info_t *p_intra_freq_cell_reselect_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib3_intra_search_v920
(
    sib3_intra_search_v920_t *p_sib3_intra_search_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib3_non_intra_search_v920
(
    sib3_non_intra_search_v920_t *p_sib3_non_intra_search_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_3_Info
(
    sib_type_3_Info_t *p_sib_type_3_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell
(
    neigh_cell_t *p_neigh_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_list
(
    neigh_cell_list_t *p_neigh_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phy_cell_id_range
(
    phy_cell_id_range_t *p_phy_cell_id_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_black_listed_cell_list
(
    black_listed_cell_list_t *p_black_listed_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_4_Info
(
    sib_type_4_Info_t *p_sib_type_4_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_thresh_x_q_r9
(
    thresh_x_q_r9_t *p_thresh_x_q_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq
(
    inter_freq_carrier_freq_t *p_inter_freq_carrier_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_list_list
(
    inter_freq_carrier_freq_list_list_t *p_inter_freq_carrier_freq_list_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_info_v8h0
(
    inter_freq_carrier_freq_info_v8h0_t *p_inter_freq_carrier_freq_info_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_list_v8h0
(
    inter_freq_carrier_freq_list_v8h0_t *p_inter_freq_carrier_freq_list_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_5_v8h0_ies
(
    sib_5_v8h0_ies_t *p_sib_5_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_5_Info
(
    sib_type_5_Info_t *p_sib_type_5_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_utra_fdd
(
    carrier_freq_utra_fdd_t *p_carrier_freq_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_fdd
(
    carrier_freq_list_utra_fdd_t *p_carrier_freq_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_utra_tdd
(
    carrier_freq_utra_tdd_t *p_carrier_freq_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_tdd
(
    carrier_freq_list_utra_tdd_t *p_carrier_freq_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_fdd_v8h0_multi_band_info_list
(
    utra_fdd_v8h0_multi_band_info_list_t *p_utra_fdd_v8h0_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_info_utra_fdd_v8h0
(
    carrier_freq_info_utra_fdd_v8h0_t *p_carrier_freq_info_utra_fdd_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_fdd_v8h0
(
    carrier_freq_list_utra_fdd_v8h0_t *p_carrier_freq_list_utra_fdd_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_6_v8h0_ies
(
    sib_6_v8h0_ies_t *p_sib_6_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_6_Info
(
    sib_type_6_Info_t *p_sib_type_6_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_explicit_list_arfcns
(
    explicit_list_arfcns_t *p_explicit_list_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_equally_spaced_arfcns
(
    equally_spaced_arfcns_t *p_equally_spaced_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_var_bitmap_of_arfcns
(
    var_bitmap_of_arfcns_t *p_var_bitmap_of_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_geran_following_arfcns
(
    geran_following_arfcns_t *p_geran_following_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freqs_geran
(
    carrier_freqs_geran_t *p_carrier_freqs_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_crfi_geran_common_info
(
    crfi_geran_common_info_t *p_crfi_geran_common_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freqs_info_geran
(
    carrier_freqs_info_geran_t *p_carrier_freqs_info_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freqs_info_list_geran
(
    carrier_freqs_info_list_geran_t *p_carrier_freqs_info_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_7_Info
(
    sib_type_7_Info_t *p_sib_type_7_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sys_time_info_cdma2000
(
    sys_time_info_cdma2000_t *p_sys_time_info_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_secondary_pre_reg_zone_id_list_hrpd
(
    secondary_pre_reg_zone_id_list_hrpd_t *p_secondary_pre_reg_zone_id_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pre_reg_info_hrpd
(
    pre_reg_info_hrpd_t *p_pre_reg_info_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_class_info_cdma2000
(
    band_class_info_cdma2000_t *p_band_class_info_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_class_list_cdma2000
(
    band_class_list_cdma2000_t *p_band_class_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phys_cell_id_list_cdma2000
(
    phys_cell_id_list_cdma2000_t *p_phys_cell_id_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_cdma2000
(
    neigh_cells_per_bandclass_cdma2000_t *p_neigh_cells_per_bandclass_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000
(
    neigh_cells_per_bandclass_list_cdma2000_t *p_neigh_cells_per_bandclass_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_cdma2000
(
    neigh_cell_cdma2000_t *p_neigh_cell_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_list_cdma2000
(
    neigh_cell_list_cdma2000_t *p_neigh_cell_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_reselection_params_cdma2000
(
    cell_reselection_params_cdma2000_t *p_cell_reselection_params_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_params_hrpd
(
    params_hrpd_t *p_params_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_csfb_reg_param_1_xrtt
(
    csfb_reg_param_1_xrtt_t *p_csfb_reg_param_1_xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_params_1_xrtt
(
    params_1_xrtt_t *p_params_1_xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phys_cell_id_list_cdma2000_v920
(
    phys_cell_id_list_cdma2000_v920_t *p_phys_cell_id_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_cdma2000_v920
(
    neigh_cells_per_bandclass_cdma2000_v920_t *p_neigh_cells_per_bandclass_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000_v920
(
    neigh_cells_per_bandclass_list_cdma2000_v920_t *p_neigh_cells_per_bandclass_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_cdma2000_v920
(
    neigh_cell_cdma2000_v920_t *p_neigh_cell_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_list_cdma2000_v920
(
    neigh_cell_list_cdma2000_v920_t *p_neigh_cell_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_reselection_params_cdma2000_v920
(
    cell_reselection_params_cdma2000_v920_t *p_cell_reselection_params_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ac_barring_config_1_xrtt_r9
(
    ac_barring_config_1_xrtt_r9_t *p_ac_barring_config_1_xrtt_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_8_Info
(
    sib_type_8_Info_t *p_sib_type_8_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_9_Info
(
    sib_type_9_Info_t *p_sib_type_9_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_m2ap_mcch_related_bcch_info
(
    m2ap_mcch_related_bcch_info_t *p_m2ap_mcch_related_bcch_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_m2ap_notification_config
(
    m2ap_notification_config_t *p_m2ap_notification_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib_type_13_info
(
    sib_type_13_info_t *p_sib_type_13_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mbms_updated_area_info
(
    mbms_updated_area_info_t *p_mbms_updated_area_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mbms_updated_area_info_list
(
    mbms_updated_area_info_list_t *p_mbms_updated_area_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_m2ap_reserved_mcch_related_bcch_info_list
(
    m2ap_reserved_mcch_related_bcch_info_list_t *p_m2ap_reserved_mcch_related_bcch_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_broadcast_config_info
(
    broadcast_config_info_t *p_broadcast_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_recfg_phy_cell_parameters
(
    rrc_recfg_phy_cell_parameters_t *p_rrc_recfg_phy_cell_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_sync_signals
(
    rrc_phy_sync_signals_t *p_rrc_phy_sync_signals,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_si_start_offset
(
    rrc_si_start_offset_t *p_rrc_si_start_offset,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_si_start_offset_info
(
    rrc_si_start_offset_info_t *p_rrc_si_start_offset_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_si_transmission_info
(
    rrc_si_transmission_info_t *p_rrc_si_transmission_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_si_transmission_info_list
(
    rrc_si_transmission_info_list_t *p_rrc_si_transmission_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_sps_crnti_range
(
    rrc_rrm_sps_crnti_range_t *p_rrc_rrm_sps_crnti_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_bandwidth_info
(
    rrc_rrm_prs_bandwidth_info_t *p_rrc_rrm_prs_bandwidth_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_subframes_info
(
    rrc_rrm_prs_subframes_info_t *p_rrc_rrm_prs_subframes_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config_index_info
(
    rrc_rrm_prs_config_index_info_t *p_rrc_rrm_prs_config_index_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_transmission_power_info
(
    rrc_rrm_prs_transmission_power_info_t *p_rrc_rrm_prs_transmission_power_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_muting_config_info
(
    rrc_rrm_prs_muting_config_info_t *p_rrc_rrm_prs_muting_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_reconfig
(
    rrc_rrm_prs_reconfig_t *p_rrc_rrm_prs_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_reconfig_info
(
    rrc_rrm_prs_reconfig_info_t *p_rrc_rrm_prs_reconfig_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_reconfig
(
    rrc_mac_reconfig_t *p_rrc_mac_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_non_broadcast_config_info
(
    non_broadcast_config_info_t *p_non_broadcast_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_downlink_power_control_common
(
    rrc_mac_downlink_power_control_common_t *p_rrc_mac_downlink_power_control_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_rand
(
    cdma2000_rand_t *p_cdma2000_rand,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_1xrtt_cell_identifier
(
    cdma2000_1xrtt_cell_identifier_t *p_cdma2000_1xrtt_cell_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd_sector_identifier
(
    cdma2000_hrpd_sector_identifier_t *p_cdma2000_hrpd_sector_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_1xrtt_ref_cell_identifier
(
    cdma2000_1xrtt_ref_cell_identifier_t *p_cdma2000_1xrtt_ref_cell_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd_ref_sector_identifier
(
    cdma2000_hrpd_ref_sector_identifier_t *p_cdma2000_hrpd_ref_sector_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_cell_param
(
    cdma2000_cell_param_t *p_cdma2000_cell_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cell_parameters
(
    rrc_phy_cell_parameters_t *p_rrc_phy_cell_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_enable_frequency_selective_scheduling
(
    rrc_mac_enable_frequency_selective_scheduling_t *p_rrc_mac_enable_frequency_selective_scheduling,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_tpc_rnti_range
(
    rrc_mac_tpc_rnti_range_t *p_rrc_mac_tpc_rnti_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_power_control_enable
(
    rrc_mac_power_control_enable_t *p_rrc_mac_power_control_enable,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config
(
    rrc_rrm_prs_config_t *p_rrc_rrm_prs_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config_info
(
    rrc_rrm_prs_config_info_t *p_rrc_rrm_prs_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_mocn_operator_info
(
    rrc_rrm_mocn_operator_info_t *p_rrc_rrm_mocn_operator_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sib13_scheduling_info
(
    sib13_scheduling_info_t *p_sib13_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_laa_scell_config
(
    rrc_radio_res_dedicated_laa_scell_config_t *p_rrc_radio_res_dedicated_laa_scell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_dmtc_configuration_r13
(
    rrc_dmtc_configuration_r13_t *p_rrc_dmtc_configuration_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_config
(
    rrc_mac_config_t *p_rrc_mac_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_l2_comm_info
(
    rrc_l2_comm_info_t *p_rrc_l2_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pdcp_comm_info
(
    rrc_pdcp_comm_info_t *p_rrc_pdcp_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_lower_layer_comm_info
(
    rrc_lower_layer_comm_info_t *p_rrc_lower_layer_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_cell_config
(
    rrc_rrm_cell_config_t *p_rrc_rrm_cell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcUeSpecificNarrowbands
(
    RrcUeSpecificNarrowbands *p_RrcUeSpecificNarrowbands,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_EmtcCellParam
(
    EmtcCellParam *p_EmtcCellParam,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_s_tmsi
(
    rrc_s_tmsi_t *p_rrc_s_tmsi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_initial_ue_identity
(
    rrc_initial_ue_identity_t *p_rrc_initial_ue_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_uplink_am_rlc
(
    rrc_uplink_am_rlc_t *p_rrc_uplink_am_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_downlink_am_rlc
(
    rrc_downlink_am_rlc_t *p_rrc_downlink_am_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_am_config
(
    rrc_am_config_t *p_rrc_am_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_srb_am_config
(
    rrm_srb_am_config_t *p_rrm_srb_am_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_ul_specific_parameters
(
    rrc_ul_specific_parameters_t *p_rrc_ul_specific_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_logical_channel_config
(
    rrm_logical_channel_config_t *p_rrm_logical_channel_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_ca_lc_bandwidth_dist_info
(
    rrc_mac_ca_lc_bandwidth_dist_info_t *p_rrc_mac_ca_lc_bandwidth_dist_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_mac_lc_config
(
    rrm_mac_lc_config_t *p_rrm_mac_lc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_srb_config
(
    rrm_srb_config_t *p_rrm_srb_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_srb_info
(
    rrm_srb_info_t *p_rrm_srb_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_ul_sch_config
(
    rrc_ul_sch_config_t *p_rrc_ul_sch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_long_drx_cycle_start_offset
(
    rrc_long_drx_cycle_start_offset_t *p_rrc_long_drx_cycle_start_offset,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_short_drx
(
    rrc_short_drx_t *p_rrc_short_drx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_drx_mac_ce_cmd_trigger_info
(
    rrc_drx_mac_ce_cmd_trigger_info_t *p_rrc_drx_mac_ce_cmd_trigger_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_long_drx_cycle_start_offset_r15
(
    rrc_long_drx_cycle_start_offset_r15_t *p_rrc_long_drx_cycle_start_offset_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_drx_config_param
(
    rrc_drx_config_param_t *p_rrc_drx_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_drx_config
(
    rrc_drx_config_t *p_rrc_drx_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phr_config_param
(
    rrc_phr_config_param_t *p_rrc_phr_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phr_config
(
    rrc_phr_config_t *p_rrc_phr_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_main_config_v1020
(
    rrc_mac_main_config_v1020_t *p_rrc_mac_main_config_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_mac_main_config
(
    rrc_mac_main_config_t *p_rrc_mac_main_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_mac_main_config_extensions
(
    rrm_mac_main_config_extensions_t *p_rrm_mac_main_config_extensions,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_mac_config
(
    rrm_mac_config_t *p_rrm_mac_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_n1_pucch_an_persist_list
(
    rrc_n1_pucch_an_persist_list_t *p_rrc_n1_pucch_an_persist_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_sps_config_dl_param
(
    rrc_sps_config_dl_param_t *p_rrc_sps_config_dl_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_sps_config_dl
(
    rrc_sps_config_dl_t *p_rrc_sps_config_dl,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_p_zero_persistent
(
    rrc_p_zero_persistent_t *p_rrc_p_zero_persistent,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_sps_config_ul_param
(
    rrc_sps_config_ul_param_t *p_rrc_sps_config_ul_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_sps_config_ul
(
    rrc_sps_config_ul_t *p_rrc_sps_config_ul,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_sps_config
(
    rrc_sps_config_t *p_rrc_sps_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_pdsch_configuration_dedicated
(
    rrc_phy_pdsch_configuration_dedicated_t *p_rrc_phy_pdsch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_ack_nack_repetition_param
(
    rrc_phy_ack_nack_repetition_param_t *p_rrc_phy_ack_nack_repetition_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_pucch_configuration_dedicated
(
    rrc_phy_pucch_configuration_dedicated_t *p_rrc_phy_pucch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_pusch_configuration_dedicated
(
    rrc_phy_pusch_configuration_dedicated_t *p_rrc_phy_pusch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_uplink_power_control_dedicated
(
    rrc_phy_uplink_power_control_dedicated_t *p_rrc_phy_uplink_power_control_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_index
(
    rrc_phy_tpc_index_t *p_rrc_phy_tpc_index,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_pdcch_config_param
(
    rrc_phy_tpc_pdcch_config_param_t *p_rrc_phy_tpc_pdcch_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_pdcch_configuration
(
    rrc_phy_tpc_pdcch_configuration_t *p_rrc_phy_tpc_pdcch_configuration,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_subband_cqi_param_param
(
    rrc_phy_subband_cqi_param_param_t *p_rrc_phy_subband_cqi_param_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_indicator_periodic
(
    rrc_phy_cqi_format_indicator_periodic_t *p_rrc_phy_cqi_format_indicator_periodic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting_periodic_param
(
    rrc_phy_cqi_reporting_periodic_param_t *p_rrc_phy_cqi_reporting_periodic_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting_periodic
(
    rrc_phy_cqi_reporting_periodic_t *p_rrc_phy_cqi_reporting_periodic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting
(
    rrc_phy_cqi_reporting_t *p_rrc_phy_cqi_reporting,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated_param
(
    rrc_phy_sounding_rs_ul_config_dedicated_param_t *p_rrc_phy_sounding_rs_ul_config_dedicated_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated
(
    rrc_phy_sounding_rs_ul_config_dedicated_t *p_rrc_phy_sounding_rs_ul_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_codebook_subset_restriction
(
    rrc_phy_codebook_subset_restriction_t *p_rrc_phy_codebook_subset_restriction,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_ue_transmit_antenna_selection
(
    rrc_phy_ue_transmit_antenna_selection_t *p_rrc_phy_ue_transmit_antenna_selection,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_information_dedicated
(
    rrc_phy_antenna_information_dedicated_t *p_rrc_phy_antenna_information_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_information
(
    rrc_phy_antenna_information_t *p_rrc_phy_antenna_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_scheduling_request_config_param
(
    rrc_phy_scheduling_request_config_param_t *p_rrc_phy_scheduling_request_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_scheduling_request_config
(
    rrc_phy_scheduling_request_config_t *p_rrc_phy_scheduling_request_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_config_v920
(
    rrc_phy_cqi_report_config_v920_t *p_rrc_phy_cqi_report_config_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_codebook_subset_restriction_v920
(
    rrc_phy_codebook_subset_restriction_v920_t *p_rrc_phy_codebook_subset_restriction_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_info_v920
(
    rrc_phy_antenna_info_v920_t *p_rrc_phy_antenna_info_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_codebook_subset_restriction_r10
(
    rrc_codebook_subset_restriction_r10_t *p_rrc_codebook_subset_restriction_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_dedicated_r10
(
    rrc_antenna_info_dedicated_r10_t *p_rrc_antenna_info_dedicated_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_r10
(
    rrc_antenna_info_r10_t *p_rrc_antenna_info_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_ul_r10
(
    rrc_antenna_info_ul_r10_t *p_rrc_antenna_info_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger
(
    rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger_t *p_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup
(
    rrc_phy_cqi_report_aperiodic_r10_setup_t *p_rrc_phy_cqi_report_aperiodic_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10
(
    rrc_phy_cqi_report_aperiodic_r10_t *p_rrc_phy_cqi_report_aperiodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_wideband_r10
(
    rrc_phy_cqi_format_ind_wideband_r10_t *p_rrc_phy_cqi_format_ind_wideband_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_subband_r10
(
    rrc_phy_cqi_format_ind_subband_r10_t *p_rrc_phy_cqi_format_ind_subband_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_periodic_r10
(
    rrc_phy_cqi_format_ind_periodic_r10_t *p_rrc_phy_cqi_format_ind_periodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup
(
    rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup_t *p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index
(
    rrc_phy_cqi_report_periodic_r10_setup_csi_config_index *p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup
(
    rrc_phy_cqi_report_periodic_r10_setup_t *p_rrc_phy_cqi_report_periodic_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10
(
    rrc_phy_cqi_report_periodic_r10_t *p_rrc_phy_cqi_report_periodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_fdd_r10
(
    rrc_phy_meas_subframe_pattern_fdd_r10_t *p_rrc_phy_meas_subframe_pattern_fdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_tdd_r10
(
    rrc_phy_meas_subframe_pattern_tdd_r10_t *p_rrc_phy_meas_subframe_pattern_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_r10
(
    rrc_phy_meas_subframe_pattern_r10_t *p_rrc_phy_meas_subframe_pattern_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup
(
    rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup_t *p_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_csi_subframePattern_r10
(
    rrc_phy_cqi_report_csi_subframePattern_r10_t *p_rrc_phy_cqi_report_csi_subframePattern_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_cqi_report_config_r10
(
    rrc_cqi_report_config_r10_t *p_rrc_cqi_report_config_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_additional_spectrum_emission_ca_r10
(
    rrc_additional_spectrum_emission_ca_r10_t *p_rrc_additional_spectrum_emission_ca_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_n1pucch_an_cs_r10
(
    n1pucch_an_cs_r10_t *p_n1pucch_an_cs_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_n1pucch_an_cs_list_r10
(
    n1pucch_an_cs_list_r10_t *p_n1pucch_an_cs_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_channel_selection_n1_pucch_an_cs_r10
(
    rrc_channel_selection_n1_pucch_an_cs_r10_t *p_rrc_channel_selection_n1_pucch_an_cs_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pucch_channel_selection_config_v1020
(
    rrc_pucch_channel_selection_config_v1020_t *p_rrc_pucch_channel_selection_config_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_physical_config_dedicated_extended
(
    rrc_phy_physical_config_dedicated_extended_t *p_rrc_phy_physical_config_dedicated_extended,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_phy_physical_config_dedicated
(
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_to_remove_list
(
    meas_object_to_remove_list_t *p_meas_object_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_index_list
(
    cell_index_list_t *p_cell_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod
(
    cells_to_add_mod_t *p_cells_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list
(
    cells_to_add_mod_list_t *p_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod
(
    black_cells_to_add_mod_t *p_black_cells_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_list
(
    black_cells_to_add_mod_list_t *p_black_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_subframe_cell_list_r10
(
    meas_subframe_cell_list_r10_t *p_meas_subframe_cell_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_subframe_pattern_config_neigh_r10_setup
(
    meas_subframe_pattern_config_neigh_r10_setup_t *p_meas_subframe_pattern_config_neigh_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_subframe_pattern_config_neigh_r10
(
    meas_subframe_pattern_config_neigh_r10_t *p_meas_subframe_pattern_config_neigh_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_eutra
(
    meas_object_eutra_t *p_meas_object_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_utra_fdd
(
    cells_to_add_mod_utra_fdd_t *p_cells_to_add_mod_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_utra_fdd
(
    cells_to_add_mod_list_utra_fdd_t *p_cells_to_add_mod_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_utra_tdd
(
    cells_to_add_mod_utra_tdd_t *p_cells_to_add_mod_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_utra_tdd
(
    cells_to_add_mod_list_utra_tdd_t *p_cells_to_add_mod_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_utra_cells_to_add_mod_list
(
    meas_object_utra_cells_to_add_mod_list_t *p_meas_object_utra_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_utra_cell_for_which_to_report_cgi
(
    meas_object_utra_cell_for_which_to_report_cgi_t *p_meas_object_utra_cell_for_which_to_report_cgi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_utra
(
    meas_object_utra_t *p_meas_object_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phys_cell_id_geran
(
    phys_cell_id_geran_t *p_phys_cell_id_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_geran
(
    meas_object_geran_t *p_meas_object_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_cdma2000
(
    carrier_freq_cdma2000_t *p_carrier_freq_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_cdma2000
(
    cells_to_add_mod_cdma2000_t *p_cells_to_add_mod_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_cdma2000_list
(
    cells_to_add_mod_list_cdma2000_list_t *p_cells_to_add_mod_list_cdma2000_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_cdma2000
(
    meas_object_cdma2000_t *p_meas_object_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_band
(
    wlan_band_t *p_wlan_band,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_channel
(
    wlan_channel_t *p_wlan_channel,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_carrier_info
(
    wlan_carrier_info_t *p_wlan_carrier_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_carrier_info_list
(
    wlan_carrier_info_list_t *p_wlan_carrier_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_wlan_carrier_freq
(
    meas_object_wlan_carrier_freq_t *p_meas_object_wlan_carrier_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_identifier_ssid
(
    wlan_identifier_ssid_t *p_wlan_identifier_ssid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_identifier
(
    wlan_identifier_t *p_wlan_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_wlan_to_add_mod_list
(
    meas_object_wlan_to_add_mod_list_t *p_meas_object_wlan_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_index_list
(
    wlan_index_list_t *p_wlan_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_wlan
(
    meas_object_wlan_t *p_meas_object_wlan,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_periodicity_and_offfset_r15
(
    periodicity_and_offfset_r15_t *p_periodicity_and_offfset_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mtc_ssb_nr_r15
(
    mtc_ssb_nr_r15_t *p_mtc_ssb_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rs_config_ssb_nr_r15
(
    rs_config_ssb_nr_r15_t *p_rs_config_ssb_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_threshold_list_nr_r15
(
    threshold_list_nr_r15_t *p_threshold_list_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_r15
(
    black_cells_to_add_mod_r15_t *p_black_cells_to_add_mod_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_list_r15
(
    black_cells_to_add_mod_list_r15_t *p_black_cells_to_add_mod_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cells_to_report_SFTD_r15_list
(
    cells_to_report_SFTD_r15_list_t *p_cells_to_report_SFTD_r15_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_nr
(
    meas_object_nr_t *p_meas_object_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod_meas_object
(
    meas_object_to_add_mod_meas_object_t *p_meas_object_to_add_mod_meas_object,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod
(
    meas_object_to_add_mod_t *p_meas_object_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod_list
(
    meas_object_to_add_mod_list_t *p_meas_object_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_to_remove_list
(
    report_config_to_remove_list_t *p_report_config_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_threshold_eutra
(
    threshold_eutra_t *p_threshold_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a1
(
    report_config_eutra_trigger_type_event_eventid_event_a1_t *p_report_config_eutra_trigger_type_event_eventid_event_a1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a2
(
    report_config_eutra_trigger_type_event_eventid_event_a2_t *p_report_config_eutra_trigger_type_event_eventid_event_a2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a3
(
    report_config_eutra_trigger_type_event_eventid_event_a3_t *p_report_config_eutra_trigger_type_event_eventid_event_a3,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a4
(
    report_config_eutra_trigger_type_event_eventid_event_a4_t *p_report_config_eutra_trigger_type_event_eventid_event_a4,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a5
(
    report_config_eutra_trigger_type_event_eventid_event_a5_t *p_report_config_eutra_trigger_type_event_eventid_event_a5,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid
(
    report_config_eutra_trigger_type_event_eventid_t *p_report_config_eutra_trigger_type_event_eventid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event
(
    report_config_eutra_trigger_type_event_t *p_report_config_eutra_trigger_type_event,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_periodical
(
    report_config_eutra_trigger_type_periodical_t *p_report_config_eutra_trigger_type_periodical,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type
(
    report_config_eutra_trigger_type_t *p_report_config_eutra_trigger_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra
(
    report_config_eutra_t *p_report_config_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_threshold_utra
(
    threshold_utra_t *p_threshold_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1
(
    report_config_interrat_trigger_type_event_eventid_event_b1_t *p_report_config_interrat_trigger_type_event_eventid_event_b1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2
(
    report_config_interrat_trigger_type_event_eventid_event_b2_t *p_report_config_interrat_trigger_type_event_eventid_event_b2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w1
(
    report_config_interrat_trigger_type_event_eventid_event_w1_t *p_report_config_interrat_trigger_type_event_eventid_event_w1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w2
(
    report_config_interrat_trigger_type_event_eventid_event_w2_t *p_report_config_interrat_trigger_type_event_eventid_event_w2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w3
(
    report_config_interrat_trigger_type_event_eventid_event_w3_t *p_report_config_interrat_trigger_type_event_eventid_event_w3,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_threshold_nr_r15
(
    threshold_nr_r15_t *p_threshold_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1_nr
(
    report_config_interrat_trigger_type_event_eventid_event_b1_nr_t *p_report_config_interrat_trigger_type_event_eventid_event_b1_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2_nr
(
    report_config_interrat_trigger_type_event_eventid_event_b2_nr_t *p_report_config_interrat_trigger_type_event_eventid_event_b2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid
(
    report_config_interrat_trigger_type_event_eventid_t *p_report_config_interrat_trigger_type_event_eventid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event
(
    report_config_interrat_trigger_type_event_t *p_report_config_interrat_trigger_type_event,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_periodical
(
    report_config_interrat_trigger_type_periodical_t *p_report_config_interrat_trigger_type_periodical,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type
(
    report_config_interrat_trigger_type_t *p_report_config_interrat_trigger_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_reportQuantityWLAN_r13
(
    reportQuantityWLAN_r13_t *p_reportQuantityWLAN_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_quantity_cell_nr_r15
(
    report_quantity_cell_nr_r15_t *p_report_quantity_cell_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_interrat
(
    report_config_interrat_t *p_report_config_interrat,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_eutra_ext
(
    report_config_eutra_ext_t *p_report_config_eutra_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod_report_config
(
    report_config_to_add_mod_report_config_t *p_report_config_to_add_mod_report_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod
(
    report_config_to_add_mod_t *p_report_config_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod_list
(
    report_config_to_add_mod_list_t *p_report_config_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_id_to_remove_list
(
    meas_id_to_remove_list_t *p_meas_id_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_id_to_add_mod
(
    meas_id_to_add_mod_t *p_meas_id_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_id_to_add_mod_list
(
    meas_id_to_add_mod_list_t *p_meas_id_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_eutra
(
    quantity_config_eutra_t *p_quantity_config_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_utra
(
    quantity_config_utra_t *p_quantity_config_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_geran
(
    quantity_config_geran_t *p_quantity_config_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_cdma2000
(
    quantity_config_cdma2000_t *p_quantity_config_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_UTRA_v1020
(
    quantity_config_UTRA_v1020_t *p_quantity_config_UTRA_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantityConfigWLAN_r13
(
    quantityConfigWLAN_r13_t *p_quantityConfigWLAN_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_rs_nr_r15
(
    quantity_config_rs_nr_r15_t *p_quantity_config_rs_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_nr_r15
(
    quantity_config_nr_r15_t *p_quantity_config_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config_nr_list_r15
(
    quantity_config_nr_list_r15_t *p_quantity_config_nr_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_quantity_config
(
    quantity_config_t *p_quantity_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_gap_setup_config_info
(
    meas_gap_setup_config_info_t *p_meas_gap_setup_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_gap_config
(
    meas_gap_config_t *p_meas_gap_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_secondary_pre_registration_zone_id_list_hrpd
(
    secondary_pre_registration_zone_id_list_hrpd_t *p_secondary_pre_registration_zone_id_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pre_registration_info_hrpd
(
    pre_registration_info_hrpd_t *p_pre_registration_info_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mobility_state_parameters
(
    mobility_state_parameters_t *p_mobility_state_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_config_speed_state_pars_setup
(
    meas_config_speed_state_pars_setup_t *p_meas_config_speed_state_pars_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_config_speed_state_pars
(
    meas_config_speed_state_pars_t *p_meas_config_speed_state_pars,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_meas_config
(
    rrm_meas_config_t *p_rrm_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_setup
(
    setup_t *p_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rlf_timers_and_constants_r9
(
    rlf_timers_and_constants_r9_t *p_rlf_timers_and_constants_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_ue_adm_radio_res_config
(
    rrm_ue_adm_radio_res_config_t *p_rrm_ue_adm_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcMpdcchConfigSetupR13
(
    RrcMpdcchConfigSetupR13_t *p_RrcMpdcchConfigSetupR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcMpdcchConfigR13
(
    RrcMpdcchConfigR13_t *p_RrcMpdcchConfigR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcEpdcchSetConfigR11
(
    RrcEpdcchSetConfigR11_t *p_RrcEpdcchSetConfigR11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_EpdcchConfigSetup
(
    EpdcchConfigSetup_t *p_EpdcchConfigSetup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_EpdcchConfig
(
    EpdcchConfig_t *p_EpdcchConfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcAckNackRepetitionSetupR13
(
    RrcAckNackRepetitionSetupR13_t *p_RrcAckNackRepetitionSetupR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcPucchConfigDedicatedR13
(
    RrcPucchConfigDedicatedR13_t *p_RrcPucchConfigDedicatedR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcRrmAdmissionEmtcConfigInfo
(
    RrcRrmAdmissionEmtcConfigInfo_t *p_RrcRrmAdmissionEmtcConfigInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_subframe_pattern_pcell_r10
(
    rrc_meas_subframe_pattern_pcell_r10_t *p_rrc_meas_subframe_pattern_pcell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_radio_resource_reconfig
(
    radio_resource_reconfig_t *p_radio_resource_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_to_release
(
    rrc_scell_to_release_t *p_rrc_scell_to_release,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_to_release_list
(
    rrc_scell_to_release_list_t *p_rrc_scell_to_release_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_Identification
(
    rrc_scell_Identification_t *p_rrc_scell_Identification,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_common_scell_non_ul_config
(
    rrc_radio_res_common_scell_non_ul_config_t *p_rrc_radio_res_common_scell_non_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_config_common_scell
(
    rrc_radio_res_config_common_scell_t *p_rrc_radio_res_config_common_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_scell_non_ul_config
(
    rrc_radio_res_dedicated_scell_non_ul_config_t *p_rrc_radio_res_dedicated_scell_non_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_cqi_report_config_scell_r10
(
    rrc_cqi_report_config_scell_r10_t *p_rrc_cqi_report_config_scell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_scell_ul_config
(
    rrc_radio_res_dedicated_scell_ul_config_t *p_rrc_radio_res_dedicated_scell_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_physical_config_dedicated_scell
(
    rrc_physical_config_dedicated_scell_t *p_rrc_physical_config_dedicated_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_res_config_dedicated_scell
(
    rrc_radio_res_config_dedicated_scell_t *p_rrc_radio_res_config_dedicated_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_mac_main_config_extensions
(
    rrc_scell_mac_main_config_extensions_t *p_rrc_scell_mac_main_config_extensions,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_to_add_mod
(
    rrc_scell_to_add_mod_t *p_rrc_scell_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_scell_to_add_mod_list
(
    rrc_scell_to_add_mod_list_t *p_rrc_scell_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_scell_config
(
    rrm_scell_config_t *p_rrm_scell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_ue_agg_max_bit_rate_ext
(
    rrm_ue_agg_max_bit_rate_ext_t *p_rrm_ue_agg_max_bit_rate_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_ue_agg_max_bit_rate
(
    rrm_ue_agg_max_bit_rate_t *p_rrm_ue_agg_max_bit_rate,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_allocation_and_retention_priority
(
    rrm_allocation_and_retention_priority_t *p_rrm_allocation_and_retention_priority,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_gbr_qos_info
(
    rrm_gbr_qos_info_t *p_rrm_gbr_qos_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_level_qos_params
(
    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_setup_item
(
    rrm_erab_to_be_setup_item_t *p_rrm_erab_to_be_setup_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_setup_item_list
(
    rrm_erab_to_be_setup_item_list_t *p_rrm_erab_to_be_setup_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_equiv_plmn
(
    equiv_plmn_t *p_equiv_plmn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_equiv_plmn_list
(
    equiv_plmn_list_t *p_equiv_plmn_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_tac
(
    forbidden_tac_t *p_forbidden_tac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_tac_list
(
    forbidden_tac_list_t *p_forbidden_tac_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_ta
(
    forbidden_ta_t *p_forbidden_ta,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_ta_list
(
    forbidden_ta_list_t *p_forbidden_ta_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_lac
(
    forbidden_lac_t *p_forbidden_lac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_lac_list
(
    forbidden_lac_list_t *p_forbidden_lac_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_la
(
    forbidden_la_t *p_forbidden_la,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_forbidden_la_list
(
    forbidden_la_list_t *p_forbidden_la_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ho_restriction_list
(
    ho_restriction_list_t *p_ho_restriction_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_plmn_identity_lai
(
    plmn_identity_lai_t *p_plmn_identity_lai,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_lac
(
    lac_t *p_lac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_registered_lai
(
    registered_lai_t *p_registered_lai,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pdcp_rohc_profile
(
    rrc_pdcp_rohc_profile_t *p_rrc_pdcp_rohc_profile,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pdcp_rohc_config
(
    rrc_pdcp_rohc_config_t *p_rrc_pdcp_rohc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pdcp_header_compression_config
(
    rrc_pdcp_header_compression_config_t *p_rrc_pdcp_header_compression_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_pdcp_config
(
    rrc_pdcp_config_t *p_rrc_pdcp_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_uplink_um_rlc
(
    rrc_uplink_um_rlc_t *p_rrc_uplink_um_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_downlink_um_rlc
(
    rrc_downlink_um_rlc_t *p_rrc_downlink_um_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_um_bi_directional_config
(
    rrc_um_bi_directional_config_t *p_rrc_um_bi_directional_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_um_uni_directional_ul_config
(
    rrc_um_uni_directional_ul_config_t *p_rrc_um_uni_directional_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_um_uni_directional_dl_config
(
    rrc_um_uni_directional_dl_config_t *p_rrc_um_uni_directional_dl_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlc_config
(
    rrc_rlc_config_t *p_rrc_rlc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlc_config_enb
(
    rrc_rlc_config_enb_t *p_rrc_rlc_config_enb,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_s1u_qos_profile
(
    rrm_s1u_qos_profile_t *p_rrm_s1u_qos_profile,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_s1u_config
(
    rrm_s1u_config_t *p_rrm_s1u_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rrc_drb_lwa_config
(
    rrm_rrc_drb_lwa_config_t *p_rrm_rrc_drb_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_config
(
    rrm_drb_config_t *p_rrm_drb_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_to_add_info_list
(
    rrm_drb_to_add_info_list_t *p_rrm_drb_to_add_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_failed_to_add_item
(
    rrm_drb_failed_to_add_item_t *p_rrm_drb_failed_to_add_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_failed_to_add_info_list
(
    rrm_drb_failed_to_add_info_list_t *p_rrm_drb_failed_to_add_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_report_proximity_config_r9
(
    rrm_report_proximity_config_r9_t *p_rrm_report_proximity_config_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_setup_radio_res_config
(
    rrm_erab_setup_radio_res_config_t *p_rrm_erab_setup_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_item
(
    rrm_erab_failed_item_t *p_rrm_erab_failed_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_released_item_list
(
    rrm_erab_to_be_released_item_list_t *p_rrm_erab_to_be_released_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RrcRrmErabMpdcchConfigInfo
(
    RrcRrmErabMpdcchConfigInfo_t *p_RrcRrmErabMpdcchConfigInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_quantity_res
(
    rrc_rrm_meas_quantity_res_t *p_rrc_rrm_meas_quantity_res,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_cell_results
(
    rrc_rrm_meas_cell_results_t *p_rrc_rrm_meas_cell_results,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_ssb_idx
(
    rrc_rrm_results_per_ssb_idx_t *p_rrc_rrm_results_per_ssb_idx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_ssb_idx_list
(
    rrc_rrm_results_per_ssb_idx_list_t *p_rrc_rrm_results_per_ssb_idx_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_csi_rs_idx
(
    rrc_rrm_results_per_csi_rs_idx_t *p_rrc_rrm_results_per_csi_rs_idx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_csi_rs_idx_list
(
    rrc_rrm_results_per_csi_rs_idx_list_t *p_rrc_rrm_results_per_csi_rs_idx_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_rs_idx_results
(
    rrc_rrm_meas_rs_idx_results_t *p_rrc_rrm_meas_rs_idx_results,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result
(
    rrc_rrm_meas_result_t *p_rrc_rrm_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_nr
(
    meas_result_nr_t *p_meas_result_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list_nr
(
    meas_result_list_nr_t *p_meas_result_list_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result2_nr
(
    rrc_rrm_meas_result2_nr_t *p_rrc_rrm_meas_result2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result_list2_nr
(
    rrc_rrm_meas_result_list2_nr_t *p_rrc_rrm_meas_result_list2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_index_list
(
    band_combination_index_list_t *p_band_combination_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_scg_serv_cell_index_range
(
    scg_serv_cell_index_range_t *p_scg_serv_cell_index_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_power_coordination_fr1
(
    power_coordination_fr1_t *p_power_coordination_fr1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_config_restrict_info
(
    config_restrict_info_t *p_config_restrict_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_cn_association
(
    rrc_rrm_cn_association_t *p_rrc_rrm_cn_association,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_to_add_mod
(
    drb_to_add_mod_t *p_drb_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_to_add_mod_list
(
    drb_to_add_mod_list_t *p_drb_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_radio_bearer_config
(
    radio_bearer_config_t *p_radio_bearer_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cg_config_info
(
    cg_config_info_t *p_cg_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_x2ap_plmn_identity
(
    x2ap_plmn_identity_t *p_x2ap_plmn_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_x2_gnb_id
(
    x2_gnb_id_t *p_x2_gnb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_x2_gb_gnb_id
(
    x2_gb_gnb_id_t *p_x2_gb_gnb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_sgnb_add_param
(
    rrc_rrm_sgnb_add_param_t *p_rrc_rrm_sgnb_add_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_item
(
    rrm_erab_item_t *p_rrm_erab_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_cnf_list
(
    rrm_erab_cnf_list_t *p_rrm_erab_cnf_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_error_info
(
    rrm_erab_error_info_t *p_rrm_erab_error_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_error_list
(
    rrm_erab_error_list_t *p_rrm_erab_error_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_release_cnf_list
(
    rrm_erab_release_cnf_list_t *p_rrm_erab_release_cnf_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mme_sel_gummei_info
(
    mme_sel_gummei_info_t *p_mme_sel_gummei_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_reconfig_lwa_config
(
    rrm_erab_reconfig_lwa_config_t *p_rrm_erab_reconfig_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_reconfigured_item
(
    rrm_erab_to_be_reconfigured_item_t *p_rrm_erab_to_be_reconfigured_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_reconfigured_item_list
(
    rrm_erab_to_be_reconfigured_item_list_t *p_rrm_erab_to_be_reconfigured_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_identifier_list
(
    wlan_identifier_list_t *p_wlan_identifier_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_mobility_config
(
    wlan_mobility_config_t *p_wlan_mobility_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_lwa_config
(
    rrc_lwa_config_t *p_rrc_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_lwa_r13_config
(
    rrc_rrm_lwa_r13_config_t *p_rrc_rrm_lwa_r13_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_modify_radio_res_config
(
    rrm_erab_modify_radio_res_config_t *p_rrm_erab_modify_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_redirected_carrier_info_utra_tdd_r10
(
    redirected_carrier_info_utra_tdd_r10_t *p_redirected_carrier_info_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_redirected_carrier_info
(
    rrm_redirected_carrier_info_t *p_rrm_redirected_carrier_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_eutra
(
    rrm_freq_priority_eutra_t *p_rrm_freq_priority_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_eutra
(
    rrm_freq_priority_list_eutra_t *p_rrm_freq_priority_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freqs_priority_geran
(
    rrm_freqs_priority_geran_t *p_rrm_freqs_priority_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freqs_priority_list_geran
(
    rrm_freqs_priority_list_geran_t *p_rrm_freqs_priority_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_utra_fdd
(
    rrm_freq_priority_utra_fdd_t *p_rrm_freq_priority_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_utra_fdd
(
    rrm_freq_priority_list_utra_fdd_t *p_rrm_freq_priority_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_utra_tdd
(
    rrm_freq_priority_utra_tdd_t *p_rrm_freq_priority_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_utra_tdd
(
    rrm_freq_priority_list_utra_tdd_t *p_rrm_freq_priority_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_hrpd
(
    rrm_band_class_priority_hrpd_t *p_rrm_band_class_priority_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_list_hrpd
(
    rrm_band_class_priority_list_hrpd_t *p_rrm_band_class_priority_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_1xrtt
(
    rrm_band_class_priority_1xrtt_t *p_rrm_band_class_priority_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_list_1xrtt
(
    rrm_band_class_priority_list_1xrtt_t *p_rrm_band_class_priority_list_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_idle_mode_mobility_control_info
(
    rrm_idle_mode_mobility_control_info_t *p_rrm_idle_mode_mobility_control_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_carrier_freq_geran
(
    carrier_freq_geran_t *p_carrier_freq_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sys_info_container_encoded_si_info
(
    sys_info_container_encoded_si_info_t *p_sys_info_container_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_sys_info_container_expanded_si_info
(
    sys_info_container_expanded_si_info_t *p_sys_info_container_expanded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_system_info_list_geran_element
(
    system_info_list_geran_element_t *p_system_info_list_geran_element,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_system_info_list_geran
(
    system_info_list_geran_t *p_system_info_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_geran_r9
(
    cell_info_geran_r9_t *p_cell_info_geran_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_list_geran_r9
(
    cell_info_list_geran_r9_t *p_cell_info_list_geran_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r9_encoded_si_info
(
    utra_bcch_container_r9_encoded_si_info_t *p_utra_bcch_container_r9_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r9_expanded_si_info
(
    utra_bcch_container_r9_expanded_si_info_t *p_utra_bcch_container_r9_expanded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_utra_fdd_r9
(
    cell_info_utra_fdd_r9_t *p_cell_info_utra_fdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_fdd_r9
(
    cell_info_list_utra_fdd_r9_t *p_cell_info_list_utra_fdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_utra_tdd_r9
(
    cell_info_utra_tdd_r9_t *p_cell_info_utra_tdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_tdd_r9
(
    cell_info_list_utra_tdd_r9_t *p_cell_info_list_utra_tdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r10_encoded_si_info
(
    utra_bcch_container_r10_encoded_si_info_t *p_utra_bcch_container_r10_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_utra_tdd_r10
(
    cell_info_utra_tdd_r10_t *p_cell_info_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_tdd_r10
(
    cell_info_list_utra_tdd_r10_t *p_cell_info_list_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_info_list_r9
(
    cell_info_list_r9_t *p_cell_info_list_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v1020_ies
(
    rrm_rrc_connection_release_v1020_ies_t *p_rrm_rrc_connection_release_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v920_ies
(
    rrm_rrc_connection_release_v920_ies_t *p_rrm_rrc_connection_release_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v890_ies
(
    rrm_rrc_connection_release_v890_ies_t *p_rrm_rrc_connection_release_v890_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_cell
(
    rrc_meas_result_serv_cell_t *p_rrc_meas_result_serv_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_global_id_eutra
(
    cell_global_id_eutra_t *p_cell_global_id_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_plmn_identity_list2
(
    plmn_identity_list2_t *p_plmn_identity_list2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_eutra_cgi_info
(
    meas_result_eutra_cgi_info_t *p_meas_result_eutra_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_eutra_meas_result
(
    meas_result_eutra_meas_result_t *p_meas_result_eutra_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_csg_info
(
    meas_result_csg_info_t *p_meas_result_csg_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_eutra
(
    meas_result_eutra_t *p_meas_result_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list_eutra
(
    meas_result_list_eutra_t *p_meas_result_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_utra_phys_cell_id
(
    meas_result_utra_phys_cell_id_t *p_meas_result_utra_phys_cell_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_global_id_utra
(
    cell_global_id_utra_t *p_cell_global_id_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_utra_cgi_info
(
    meas_result_utra_cgi_info_t *p_meas_result_utra_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_utra_meas_result
(
    meas_result_utra_meas_result_t *p_meas_result_utra_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_utra
(
    meas_result_utra_t *p_meas_result_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list_utra
(
    meas_result_list_utra_t *p_meas_result_list_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_global_id_geran
(
    cell_global_id_geran_t *p_cell_global_id_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_geran_cgi_info
(
    meas_result_geran_cgi_info_t *p_meas_result_geran_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_geran_meas_result
(
    meas_result_geran_meas_result_t *p_meas_result_geran_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_geran
(
    meas_result_geran_t *p_meas_result_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list_geran
(
    meas_result_list_geran_t *p_meas_result_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cell_global_id_cdma2000
(
    cell_global_id_cdma2000_t *p_cell_global_id_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_cdma2000_meas_result
(
    meas_result_cdma2000_meas_result_t *p_meas_result_cdma2000_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_cdma2000
(
    meas_result_cdma2000_t *p_meas_result_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list_cdma2000
(
    meas_result_list_cdma2000_t *p_meas_result_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_results_cdma2000
(
    meas_results_cdma2000_t *p_meas_results_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_ssb_index_r15
(
    meas_result_ssb_index_r15_t *p_meas_result_ssb_index_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_ssb_index_list_r15
(
    meas_result_ssb_index_list_r15_t *p_meas_result_ssb_index_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_ind_nr
(
    meas_result_ind_nr_t *p_meas_result_ind_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_results_list_nr_r15
(
    meas_results_list_nr_r15_t *p_meas_results_list_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_neigh_cells
(
    rrc_meas_result_neigh_cells_t *p_rrc_meas_result_neigh_cells,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_ecid_r9
(
    rrc_meas_result_ecid_r9_t *p_rrc_meas_result_ecid_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_attr
(
    meas_result_attr_t *p_meas_result_attr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_best_neigh_cell_r10
(
    meas_result_best_neigh_cell_r10_t *p_meas_result_best_neigh_cell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_freq_r10
(
    rrc_meas_result_serv_freq_r10_t *p_rrc_meas_result_serv_freq_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_freq_list_r10
(
    rrc_meas_result_serv_freq_list_r10_t *p_rrc_meas_result_serv_freq_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_wlan_r13
(
    rrc_meas_result_wlan_r13_t *p_rrc_meas_result_wlan_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_wlan_list_r13
(
    rrc_meas_result_wlan_list_r13_t *p_rrc_meas_result_wlan_list_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ProximityIndication_r9_IEs_carrierFreq_r9
(
    ProximityIndication_r9_IEs_carrierFreq_r9_t *p_ProximityIndication_r9_IEs_carrierFreq_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rat_type_info
(
    rat_type_info_t *p_rat_type_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_release_item_list
(
    rrm_erab_release_item_list_t *p_rrm_erab_release_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_to_release_item
(
    rrm_erab_failed_to_release_item_t *p_rrm_erab_failed_to_release_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_to_release_item_list
(
    rrm_erab_failed_to_release_item_list_t *p_rrm_erab_failed_to_release_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pdcp_parameters
(
    pdcp_parameters_t *p_pdcp_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_physical_layer_params
(
    physical_layer_params_t *p_physical_layer_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_eutra
(
    supported_band_eutra_t *p_supported_band_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_list_eutra
(
    supported_band_list_eutra_t *p_supported_band_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters
(
    rf_parameters_t *p_rf_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_band_info
(
    inter_freq_band_info_t *p_inter_freq_band_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_freq_band_list
(
    inter_freq_band_list_t *p_inter_freq_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_rat_band_info
(
    inter_rat_band_info_t *p_inter_rat_band_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_rat_band_list
(
    inter_rat_band_list_t *p_inter_rat_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_info_eutra
(
    band_info_eutra_t *p_band_info_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_list_eutra
(
    band_list_eutra_t *p_band_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_pameters
(
    meas_pameters_t *p_meas_pameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_fdd
(
    utra_fdd_t *p_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_tdd128
(
    utra_tdd128_t *p_utra_tdd128,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_tdd384
(
    utra_tdd384_t *p_utra_tdd384,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_tdd768
(
    utra_tdd768_t *p_utra_tdd768,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_list_geran
(
    supported_band_list_geran_t *p_supported_band_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_geran
(
    geran_t *p_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_list_hrpd
(
    supported_band_list_hrpd_t *p_supported_band_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd
(
    cdma2000_hrpd_t *p_cdma2000_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_list_1xrtt
(
    supported_band_list_1xrtt_t *p_supported_band_list_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_1x_rtt
(
    cdma2000_1x_rtt_t *p_cdma2000_1x_rtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_inter_rat_Parameters
(
    inter_rat_Parameters_t *p_inter_rat_Parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_radio_capability_info_def
(
    eutra_radio_capability_info_def_t *p_eutra_radio_capability_info_def,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phy_layer_parameters_v920
(
    phy_layer_parameters_v920_t *p_phy_layer_parameters_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_geran_v920
(
    irat_parameters_geran_v920_t *p_irat_parameters_geran_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_v920
(
    irat_parameters_utra_v920_t *p_irat_parameters_utra_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_cdma2000_v920
(
    irat_parameters_cdma2000_v920_t *p_irat_parameters_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_csg_proximity_indication_parameters_r9
(
    csg_proximity_indication_parameters_r9_t *p_csg_proximity_indication_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_neigh_cell_si_acquisition_parameters_r9
(
    neigh_cell_si_acquisition_parameters_r9_t *p_neigh_cell_si_acquisition_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_son_parameters_r9
(
    son_parameters_r9_t *p_son_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_addxdd_mode_r9
(
    ue_eutra_capability_addxdd_mode_r9_t *p_ue_eutra_capability_addxdd_mode_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_v9c0
(
    irat_parameters_utra_v9c0_t *p_irat_parameters_utra_v9c0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v9c0_ies
(
    ue_eutra_capability_v9c0_ies_t *p_ue_eutra_capability_v9c0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v9a0_ies
(
    ue_eutra_capability_v9a0_ies_t *p_ue_eutra_capability_v9a0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_noncontiguousul_ra_withincc_r10_ies
(
    noncontiguousul_ra_withincc_r10_ies_t *p_noncontiguousul_ra_withincc_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_noncontiguousul_ra_withincc_list_r10_ies
(
    noncontiguousul_ra_withincc_list_r10_ies_t *p_noncontiguousul_ra_withincc_list_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_phylayer_parameters_v1020_ies
(
    phylayer_parameters_v1020_ies_t *p_phylayer_parameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_ul_r10
(
    ca_mimo_parameters_ul_r10_t *p_ca_mimo_parameters_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_ul_r10
(
    band_parameters_ul_r10_t *p_band_parameters_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_dl_r10
(
    ca_mimo_parameters_dl_r10_t *p_ca_mimo_parameters_dl_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_dl_r10
(
    band_parameters_dl_r10_t *p_band_parameters_dl_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_r10
(
    band_parameters_r10_t *p_band_parameters_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r10
(
    band_combination_parameters_r10_t *p_band_combination_parameters_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_combination_r10_ies
(
    supported_band_combination_r10_ies_t *p_supported_band_combination_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_v1020_ies
(
    rf_parameters_v1020_ies_t *p_rf_parameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_list_eutra_r10_ies
(
    band_combination_list_eutra_r10_ies_t *p_band_combination_list_eutra_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_measparameters_v1020_ies
(
    measparameters_v1020_ies_t *p_measparameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_cdma2000_v1020
(
    irat_parameters_cdma2000_v1020_t *p_irat_parameters_cdma2000_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_tdd_v1020
(
    irat_parameters_utra_tdd_v1020_t *p_irat_parameters_utra_tdd_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_addxdd_mode_v1060
(
    ue_eutra_capability_addxdd_mode_v1060_t *p_ue_eutra_capability_addxdd_mode_v1060,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_width_combination_set_r10
(
    supported_band_width_combination_set_r10_t *p_supported_band_width_combination_set_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_ext_r10
(
    band_combination_parameters_ext_r10_t *p_band_combination_parameters_ext_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_combination_ext_r10_ies
(
    supported_band_combination_ext_r10_ies_t *p_supported_band_combination_ext_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_v1060_ies
(
    rf_parameters_v1060_ies_t *p_rf_parameters_v1060_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_v1090
(
    band_parameters_v1090_t *p_band_parameters_v1090,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_v1090
(
    band_combination_parameters_v1090_t *p_band_combination_parameters_v1090,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_combination_v1090_ies
(
    supported_band_combination_v1090_ies_t *p_supported_band_combination_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_v1090_ies
(
    rf_parameters_v1090_ies_t *p_rf_parameters_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_r11
(
    band_parameters_r11_t *p_band_parameters_r11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r11
(
    band_combination_parameters_r11_t *p_band_combination_parameters_r11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_combination_add_r11_ies
(
    supported_band_combination_add_r11_ies_t *p_supported_band_combination_add_r11_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_v1180_ies
(
    rf_parameters_v1180_ies_t *p_rf_parameters_v1180_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pdcp_parameters_v1310
(
    pdcp_parameters_v1310_t *p_pdcp_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rlc_parameters_v1310
(
    rlc_parameters_v1310_t *p_rlc_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_ul_r13
(
    band_parameters_ul_r13_t *p_band_parameters_ul_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_intra_band_contiguous_cc_info_r12
(
    intra_band_contiguous_cc_info_r12_t *p_intra_band_contiguous_cc_info_r12,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_intra_band_contiguous_cc_info_list_r13
(
    intra_band_contiguous_cc_info_list_r13_t *p_intra_band_contiguous_cc_info_list_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_dl_r13
(
    ca_mimo_parameters_dl_r13_t *p_ca_mimo_parameters_dl_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_dl_r13
(
    band_parameters_dl_r13_t *p_band_parameters_dl_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_r13
(
    band_parameters_r13_t *p_band_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r13_bandParameterList_r13
(
    band_combination_parameters_r13_bandParameterList_r13_t *p_band_combination_parameters_r13_bandParameterList_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r13
(
    band_combination_parameters_r13_t *p_band_combination_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_combination_reduced_r13_ies
(
    supported_band_combination_reduced_r13_ies_t *p_supported_band_combination_reduced_r13_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_v1310_ies
(
    rf_parameters_v1310_ies_t *p_rf_parameters_v1310_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_parameters_wlan_r13
(
    irat_parameters_wlan_r13_t *p_irat_parameters_wlan_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_laa_parameters_r13
(
    laa_parameters_r13_t *p_laa_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_wlan_iw_parameters_v1310
(
    wlan_iw_parameters_v1310_t *p_wlan_iw_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_lwip_parameters_r13
(
    lwip_parameters_r13_t *p_lwip_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_lwa_parameters
(
    ue_eutra_capability_lwa_parameters_t *p_ue_eutra_capability_lwa_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityEmtcParamaters
(
    UeEutraCapabilityEmtcParamaters_t *p_UeEutraCapabilityEmtcParamaters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityIratParametersNrR15
(
    UeEutraCapabilityIratParametersNrR15_t *p_UeEutraCapabilityIratParametersNrR15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityEndcParamaters
(
    UeEutraCapabilityEndcParamaters_t *p_UeEutraCapabilityEndcParamaters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1510_ies
(
    ue_eutra_capability_v1510_ies_t *p_ue_eutra_capability_v1510_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1460_ies
(
    ue_eutra_capability_v1460_ies_t *p_ue_eutra_capability_v1460_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1450_ies
(
    ue_eutra_capability_v1450_ies_t *p_ue_eutra_capability_v1450_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1440_ies
(
    ue_eutra_capability_v1440_ies_t *p_ue_eutra_capability_v1440_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1430_ies
(
    ue_eutra_capability_v1430_ies_t *p_ue_eutra_capability_v1430_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1360_ies
(
    ue_eutra_capability_v1360_ies_t *p_ue_eutra_capability_v1360_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1350_ies
(
    ue_eutra_capability_v1350_ies_t *p_ue_eutra_capability_v1350_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1340_ies
(
    ue_eutra_capability_v1340_ies_t *p_ue_eutra_capability_v1340_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1330_ies
(
    ue_eutra_capability_v1330_ies_t *p_ue_eutra_capability_v1330_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1320_ies
(
    ue_eutra_capability_v1320_ies_t *p_ue_eutra_capability_v1320_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1310_ies
(
    ue_eutra_capability_v1310_ies_t *p_ue_eutra_capability_v1310_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1280_ies
(
    ue_eutra_capability_v1280_ies_t *p_ue_eutra_capability_v1280_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1270_ies
(
    ue_eutra_capability_v1270_ies_t *p_ue_eutra_capability_v1270_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1260_ies
(
    ue_eutra_capability_v1260_ies_t *p_ue_eutra_capability_v1260_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1250_ies
(
    ue_eutra_capability_v1250_ies_t *p_ue_eutra_capability_v1250_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v11a0_ies
(
    ue_eutra_capability_v11a0_ies_t *p_ue_eutra_capability_v11a0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1180_ies
(
    ue_eutra_capability_v1180_ies_t *p_ue_eutra_capability_v1180_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1090_ies
(
    ue_eutra_capability_v1090_ies_t *p_ue_eutra_capability_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1060_ies
(
    ue_eutra_capability_v1060_ies_t *p_ue_eutra_capability_v1060_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_based_nw_perf_meas_params
(
    ue_based_nw_perf_meas_params_t *p_ue_based_nw_perf_meas_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1020_ies
(
    ue_eutra_capability_v1020_ies_t *p_ue_eutra_capability_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v940_ies
(
    ue_eutra_capability_v940_ies_t *p_ue_eutra_capability_v940_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v920_ies
(
    ue_eutra_capability_v920_ies_t *p_ue_eutra_capability_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_radio_capability_info
(
    eutra_radio_capability_info_t *p_eutra_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_utra_radio_capability_info
(
    utra_radio_capability_info_t *p_utra_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cdma2000_radio_capability_info
(
    cdma2000_radio_capability_info_t *p_cdma2000_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_geran_cs_radio_capability_info
(
    geran_cs_radio_capability_info_t *p_geran_cs_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_geran_ps_radio_capability_info
(
    geran_ps_radio_capability_info_t *p_geran_ps_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_eutra
(
    band_parameters_eutra_t *p_band_parameters_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters_nr
(
    band_parameters_nr_t *p_band_parameters_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_parameters
(
    band_parameters_t *p_band_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination_band_list
(
    band_combination_band_list_t *p_band_combination_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_band_combination
(
    band_combination_t *p_band_combination,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_supported_band_comb_list
(
    supported_band_comb_list_t *p_supported_band_comb_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rf_parameters_mrdc
(
    rf_parameters_mrdc_t *p_rf_parameters_mrdc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_nr_radio_capability_info
(
    eutra_nr_radio_capability_info_t *p_eutra_nr_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_nr_radio_capability_info
(
    nr_radio_capability_info_t *p_nr_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_radio_capability_info
(
    rrc_radio_capability_info_t *p_rrc_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_globalEnb_ecgi
(
    eutra_globalEnb_ecgi_t *p_eutra_globalEnb_ecgi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_tai_info
(
    rrm_tai_info_t *p_rrm_tai_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_enb_id
(
    rrm_enb_id_t *p_rrm_enb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_lai_info
(
    rrm_lai_info_t *p_rrm_lai_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rnc_id
(
    rrm_rnc_id_t *p_rrm_rnc_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_cgi_info
(
    rrm_cgi_info_t *p_rrm_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_target_id
(
    rrm_target_id_t *p_rrm_target_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_target_cell_identity
(
    target_cell_identity_t *p_target_cell_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_target_cell_identity_list
(
    target_cell_identity_list_t *p_target_cell_identity_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_candidate_cell_info
(
    candidate_cell_info_t *p_candidate_cell_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_candidate_cell_info_list
(
    candidate_cell_info_list_t *p_candidate_cell_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_config
(
    rrm_config_t *p_rrm_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_rrc_container
(
    rrm_rrc_container_t *p_rrm_rrc_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_erab_list
(
    rrc_erab_list_t *p_rrc_erab_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_eutran_type
(
    rrc_eutran_type_t *p_rrc_eutran_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_last_visited_e_utran_cell_information
(
    last_visited_e_utran_cell_information_t *p_last_visited_e_utran_cell_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_utran_type
(
    rrc_utran_type_t *p_rrc_utran_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_last_visited_utran_cell_information
(
    last_visited_utran_cell_information_t *p_last_visited_utran_cell_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_last_visited_cell_info
(
    last_visited_cell_info_t *p_last_visited_cell_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_last_visited_cell_list
(
    last_visited_cell_list_t *p_last_visited_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ue_history
(
    ue_history_t *p_ue_history,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_sourceenb_to_targetenb_transparent_cotainer
(
    rrm_sourceenb_to_targetenb_transparent_cotainer_t *p_rrm_sourceenb_to_targetenb_transparent_cotainer,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_security_info
(
    security_info_t *p_security_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_transport_channel_id
(
    transport_channel_id_t *p_transport_channel_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rab_transport_channel_mapping
(
    rab_transport_channel_mapping_t *p_rab_transport_channel_mapping,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_srb_transport_channel_mapping
(
    srb_transport_channel_mapping_t *p_srb_transport_channel_mapping,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_trace_recording_session_info
(
    trace_recording_session_info_t *p_trace_recording_session_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_srvcc_information
(
    srvcc_information_t *p_srvcc_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_freq
(
    eutra_freq_t *p_eutra_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_eutra_freq_list
(
    eutra_freq_list_t *p_eutra_freq_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_meas_param
(
    irat_meas_param_t *p_irat_meas_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_irat_meas_config
(
    irat_meas_config_t *p_irat_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_source_rnc_to_target_rnc_transparent_container
(
    rrm_source_rnc_to_target_rnc_transparent_container_t *p_rrm_source_rnc_to_target_rnc_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_irat_meas_config
(
    rrm_old_bss_to_new_bss_irat_meas_config_t *p_rrm_old_bss_to_new_bss_irat_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_source_bss_to_target_bss_transparent_container
(
    rrm_source_bss_to_target_bss_transparent_container_t *p_rrm_source_bss_to_target_bss_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_extra_information
(
    rrm_old_bss_to_new_bss_extra_information_t *p_rrm_old_bss_to_new_bss_extra_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_information
(
    rrm_old_bss_to_new_bss_information_t *p_rrm_old_bss_to_new_bss_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_soruce_to_target_transparent_container
(
    rrm_soruce_to_target_transparent_container_t *p_rrm_soruce_to_target_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mobility_control_info
(
    mobility_control_info_t *p_mobility_control_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pz_hyst_parameters_included
(
    pz_hyst_parameters_included_t *p_pz_hyst_parameters_included,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_mobility_parameters
(
    mobility_parameters_t *p_mobility_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_fpc_fch_included
(
    fpc_fch_included_t *p_fpc_fch_included,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_additional_mobility_parameters
(
    additional_mobility_parameters_t *p_additional_mobility_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_channel_record
(
    channel_record_t *p_channel_record,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pilot_entry
(
    pilot_entry_t *p_pilot_entry,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_pilot_list
(
    pilot_list_t *p_pilot_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ho_from_eutra_preperation_req_r10_ies
(
    ho_from_eutra_preperation_req_r10_ies_t *p_ho_from_eutra_preperation_req_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_cdma2000_information
(
    rrm_cdma2000_information_t *p_rrm_cdma2000_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_system_info_list_geran_si_psi
(
    system_info_list_geran_si_psi_t *p_system_info_list_geran_si_psi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_target_rat_type_geran
(
    rrc_target_rat_type_geran_t *p_rrc_target_rat_type_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_target_rat_type
(
    rrc_target_rat_type_t *p_rrc_target_rat_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cco_parameters
(
    cco_parameters_t *p_cco_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_radio_resource_config_dedicated
(
    radio_resource_config_dedicated_t *p_radio_resource_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_security_algorithm_config
(
    security_algorithm_config_t *p_security_algorithm_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_as_config
(
    as_config_t *p_as_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_additional_reestab_info
(
    additional_reestab_info_t *p_additional_reestab_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_additional_reestab_info_list
(
    additional_reestab_info_list_t *p_additional_reestab_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_as_context
(
    as_context_t *p_as_context,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_as_config_ext
(
    as_config_ext_t *p_as_config_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_src_to_trg_container
(
    src_to_trg_container_t *p_src_to_trg_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_request_type
(
    request_type_t *p_request_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_response
(
    rrm_response_t *p_rrm_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd
(
    rrm_drb_sub_to_fwd_t *p_rrm_drb_sub_to_fwd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd_list
(
    rrm_drb_sub_to_fwd_list_t *p_rrm_drb_sub_to_fwd_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_radio_resource_config
(
    radio_resource_config_t *p_radio_resource_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_erab_item_list
(
    erab_item_list_t *p_erab_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_item_list
(
    rrm_erab_failed_item_list_t *p_rrm_erab_failed_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_nas_security_param
(
    nas_security_param_t *p_nas_security_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_tansport_layer_address
(
    rrc_rrm_tansport_layer_address_t *p_rrc_rrm_tansport_layer_address,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd_info
(
    rrm_drb_sub_to_fwd_info_t *p_rrm_drb_sub_to_fwd_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_erab_info_list
(
    rrc_erab_info_list_t *p_rrc_erab_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_erab_to_release
(
    erab_to_release_t *p_erab_to_release,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_erab_to_release_list
(
    erab_to_release_list_t *p_erab_to_release_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_ho_response
(
    ho_response_t *p_ho_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_warning_info
(
    rrc_warning_info_t *p_rrc_warning_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_warning_info_list
(
    rrc_warning_info_list_t *p_rrc_warning_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_etws_scheduling_info
(
    etws_scheduling_info_t *p_etws_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cmas_scheduling_info
(
    cmas_scheduling_info_t *p_cmas_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_cmas_scheduling_info_list
(
    cmas_scheduling_info_list_t *p_cmas_scheduling_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_inactive_ue_info
(
    rrc_rrm_inactive_ue_info_t *p_rrc_rrm_inactive_ue_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_list
(
    drb_list_t *p_drb_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_count_info
(
    drb_count_info_t *p_drb_count_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_count_info_list
(
    drb_count_info_list_t *p_drb_count_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_countMSB_info
(
    drb_countMSB_info_t *p_drb_countMSB_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_drb_countMSB_info_list
(
    drb_countMSB_info_list_t *p_drb_countMSB_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rach_report
(
    rrc_rach_report_t *p_rrc_rach_report,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_meas_result_serv_cell
(
    rrc_rlf_report_meas_result_serv_cell_t *p_rrc_rlf_report_meas_result_serv_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_eutra
(
    rrc_meas_result2_eutra_t *p_rrc_meas_result2_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_list2_eutra
(
    rrc_meas_result_list2_eutra_t *p_rrc_meas_result_list2_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_utra
(
    rrc_meas_result2_utra_t *p_rrc_meas_result2_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result_list2_utra
(
    rrc_meas_result_list2_utra_t *p_rrc_meas_result_list2_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_cdma2000
(
    rrc_meas_result2_cdma2000_t *p_rrc_meas_result2_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_meas_result_list2_cdma2000
(
    meas_result_list2_cdma2000_t *p_meas_result_list2_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_meas_result_neigh_cell
(
    rrc_rlf_report_meas_result_neigh_cell_t *p_rrc_rlf_report_meas_result_neigh_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrm_cell_global_id_eutra
(
    rrm_cell_global_id_eutra_t *p_rrm_cell_global_id_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_dynamic_string
(
    rrc_rlf_dynamic_string_t *p_rrc_rlf_dynamic_string,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_location_coordinates
(
    rrc_rlf_report_location_coordinates_t *p_rrc_rlf_report_location_coordinates,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_location_info
(
    rrc_rlf_report_location_info_t *p_rrc_rlf_report_location_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_failed_pci_arfcn
(
    rrc_rlf_failed_pci_arfcn_t *p_rrc_rlf_failed_pci_arfcn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_failed_pcellid
(
    rrc_rlf_failed_pcellid_t *p_rrc_rlf_failed_pcellid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rlf_report
(
    rrc_rlf_report_t *p_rrc_rlf_report,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RstdInterFreqInfoList_r10
(
    RstdInterFreqInfoList_r10_t *p_RstdInterFreqInfoList_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_RstdInterFreqInfoList
(
    RstdInterFreqInfoList_t *p_RstdInterFreqInfoList,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_impacted_items_list
(
    rrc_impacted_items_list_t *p_rrc_impacted_items_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_impacted_items
(
    rrc_impacted_items_t *p_rrc_impacted_items,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);

static
rrc_return_et
rrc_il_parse_rrc_rrm_endc_meas_config
(
    rrc_rrm_endc_meas_config_t *p_rrc_rrm_endc_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
);


/*****************************************************************************/
/*                      Functions implementations                            */
/*****************************************************************************/

rrc_return_et
rrc_il_parse_rrc_rrm_ue_sync_status
(
    rrc_rrm_ue_sync_status_t *p_rrc_rrm_ue_sync_status,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_sync_status, 0, sizeof(rrc_rrm_ue_sync_status_t));

    /* This function parses rrc_rrm_ue_sync_status */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_sync_status->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_sync_status->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ue_sync_status->rrc_rrm_ue_sync_status, p_src + *p_length_read, "rrc_rrm_ue_sync_status");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_sync_status->rrc_rrm_ue_sync_status > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_sync_status->rrc_rrm_ue_sync_status] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_sync_status->rrc_rrm_ue_sync_status);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_reestab_complete_ind
(
    rrc_rrm_ue_reestab_complete_ind_t *p_rrc_rrm_ue_reestab_complete_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_reestab_complete_ind, 0, sizeof(rrc_rrm_ue_reestab_complete_ind_t));

    /* This function parses rrc_rrm_ue_reestab_complete_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_complete_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_reestab_complete_ind->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_reestab_complete_ind->cell_index > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_reestab_complete_ind->cell_index] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_rrm_ue_reestab_complete_ind->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_complete_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_reestab_complete_ind->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_reestab_complete_ind->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_reestab_complete_ind->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_reestab_complete_ind->response);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_release_req
(
    rrc_rrm_ue_release_req_t *p_rrc_rrm_ue_release_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_release_req, 0, sizeof(rrc_rrm_ue_release_req_t));

    /* This function parses rrc_rrm_ue_release_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_release_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_release_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_release_req->bitmask & RRC_RRM_UE_RELEASE_CAUSE_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ue_release_req->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_cause
(
    rrm_cause_t *p_rrm_cause,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_cause, 0, sizeof(rrm_cause_t));

    /* This function parses rrm_cause */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_cause->type, p_src + *p_length_read, "type");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_cause->value, p_src + *p_length_read, "value");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_release_resp
(
    rrc_rrm_ue_release_resp_t *p_rrc_rrm_ue_release_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_release_resp, 0, sizeof(rrc_rrm_ue_release_resp_t));

    /* This function parses rrc_rrm_ue_release_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_release_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_release_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_release_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_release_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_release_resp->response);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_setup_resp
(
    rrc_rrm_cell_setup_resp_t *p_rrc_rrm_cell_setup_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_setup_resp, 0, sizeof(rrc_rrm_cell_setup_resp_t));

    /* This function parses rrc_rrm_cell_setup_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_setup_resp->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_setup_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_setup_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_setup_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_cell_setup_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_cell_setup_resp->presence_bitmask & CELL_SETUP_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_setup_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_resp->fail_cause > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_resp->fail_cause] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_rrm_cell_setup_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_cell_setup_resp->presence_bitmask & CELL_SETUP_RESP_API_EARFCN_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_dl_earfcn(
        &p_rrc_rrm_cell_setup_resp->dl_earfcn_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_dl_earfcn
(
    rrc_dl_earfcn_t *p_rrc_dl_earfcn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_dl_earfcn, 0, sizeof(rrc_dl_earfcn_t));

    /* This function parses rrc_dl_earfcn */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_dl_earfcn->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_dl_earfcn->count > RRC_PHY_CELL_PARAMS_DL_EARFCN_MAX_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_dl_earfcn->count] should be less than"
            " or equal to RRC_PHY_CELL_PARAMS_DL_EARFCN_MAX_COUNT. Incorrect value %u received.", p_rrc_dl_earfcn->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_dl_earfcn->count * sizeof(p_rrc_dl_earfcn->earfcnDl[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_dl_earfcn->count; loop++)
        {
            rrc_cp_unpack_U32((void*)&p_rrc_dl_earfcn->earfcnDl[loop], (void*)(p_src + *p_length_read), "earfcnDl[]");
            *p_length_read += sizeof(U32);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_reconfig_req
(
    rrc_rrm_cell_reconfig_req_t *p_rrc_rrm_cell_reconfig_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_reconfig_req, 0, sizeof(rrc_rrm_cell_reconfig_req_t));

    /* This function parses rrc_rrm_cell_reconfig_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_reconfig_req->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_reconfig_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_reconfig_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_reconfig_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_reconfig_req->cell_index);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_broadcast_config_info(
        &p_rrc_rrm_cell_reconfig_req->broadcast_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_non_broadcast_config_info(
        &p_rrc_rrm_cell_reconfig_req->non_broadcast_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & 8)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_rrm_cell_reconfig_req->emergency_area_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_rrm_cell_reconfig_req->emergency_area_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_cell_reconfig_req->emergency_area_id[loop], (void*)(p_src + *p_length_read), "emergency_area_id[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & CELL_RECONFIG_REQ_API_CONTENTION_FREE_RACH_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_reconfig_req->contention_free_rach_timer, p_src + *p_length_read, "contention_free_rach_timer");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & CELL_RECONFIG_DOWNLINK_POWER_CONTROL_COMMON_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_downlink_power_control_common(
        &p_rrc_rrm_cell_reconfig_req->downlink_power_control_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & CELL_RECONFIG_REQ_API_CDMA2000_CELL_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_cell_param(
        &p_rrc_rrm_cell_reconfig_req->cdma2000_cell_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_reconfig_req->presence_bitmask & 256)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_reconfig_req->mbms_transmission_power, p_src + *p_length_read, "mbms_transmission_power");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_reconfig_req->mbms_transmission_power > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_reconfig_req->mbms_transmission_power] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_rrm_cell_reconfig_req->mbms_transmission_power);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phich_config
(
    phich_config_t *p_phich_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phich_config, 0, sizeof(phich_config_t));

    /* This function parses phich_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phich_config->phich_resource, p_src + *p_length_read, "phich_resource");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phich_config->phich_resource > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phich_config->phich_resource] should be less than"
            " or equal to 3. Incorrect value %u received.", p_phich_config->phich_resource);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phich_config->phich_duration, p_src + *p_length_read, "phich_duration");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phich_config->phich_duration > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phich_config->phich_duration] should be less than"
            " or equal to 1. Incorrect value %u received.", p_phich_config->phich_duration);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mib_info
(
    mib_info_t *p_mib_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mib_info, 0, sizeof(mib_info_t));

    /* This function parses mib_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mib_info->dl_band_width, p_src + *p_length_read, "dl_band_width");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mib_info->dl_band_width > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mib_info->dl_band_width] should be less than"
            " or equal to 5. Incorrect value %u received.", p_mib_info->dl_band_width);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_phich_config(
        &p_mib_info->phich_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mnc
(
    mnc_t *p_mnc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_mnc, 0, sizeof(mnc_t));

    /* This function parses mnc */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mnc->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_mnc->count < 2) || (p_mnc->count > MAX_MNC_OCTET_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mnc->count] should be in range "
            "2 to MAX_MNC_OCTET_SIZE. Incorrect value %u received.", p_mnc->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_mnc->count * sizeof(p_mnc->mnc[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_mnc->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_mnc->mnc[loop], (void*)(p_src + *p_length_read), "mnc[]");
            if (p_mnc->mnc[loop] > 9)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_mnc->mnc[%u] should be less"
                    " than or equal to 9. "
                    "Incorrect value %d received.", loop, p_mnc->mnc[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_plmn_identity
(
    plmn_identity_t *p_plmn_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_plmn_identity, 0, sizeof(plmn_identity_t));

    /* This function parses plmn_identity */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_plmn_identity->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_plmn_identity->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(p_plmn_identity->mcc) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_plmn_identity->mcc); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_plmn_identity->mcc[loop], (void*)(p_src + *p_length_read), "mcc[]");
            if (p_plmn_identity->mcc[loop] > 9)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_plmn_identity->mcc[%u] should be less"
                    " than or equal to 9. "
                    "Incorrect value %d received.", loop, p_plmn_identity->mcc[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (RRC_FAILURE == rrc_il_parse_mnc(
        &p_plmn_identity->mnc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_plmn_identity_info
(
    plmn_identity_info_t *p_plmn_identity_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_plmn_identity_info, 0, sizeof(plmn_identity_info_t));

    /* This function parses plmn_identity_info */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_plmn_identity_info->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_plmn_identity_info->cell_res_for_operator_use, p_src + *p_length_read, "cell_res_for_operator_use");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_plmn_identity_info->cell_res_for_operator_use > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_plmn_identity_info->cell_res_for_operator_use] should be less than"
            " or equal to 1. Incorrect value %u received.", p_plmn_identity_info->cell_res_for_operator_use);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_plmn_id_info_list
(
    plmn_id_info_list_t *p_plmn_id_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_plmn_id_info_list, 0, sizeof(plmn_id_info_list_t));

    /* This function parses plmn_id_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_plmn_id_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_plmn_id_info_list->count < 1) || (p_plmn_id_info_list->count > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_plmn_id_info_list->count] should be in range "
            "1 to 6. Incorrect value %u received.", p_plmn_id_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_plmn_id_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_plmn_identity_info(
                &p_plmn_id_info_list->plmn_identity_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_access_related_info
(
    cell_access_related_info_t *p_cell_access_related_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_access_related_info, 0, sizeof(cell_access_related_info_t));

    /* This function parses cell_access_related_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_access_related_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(p_cell_access_related_info->tac) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_access_related_info->tac); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_access_related_info->tac[loop], (void*)(p_src + *p_length_read), "tac[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_cell_access_related_info->cell_Id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_access_related_info->cell_Id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_access_related_info->cell_Id[loop], (void*)(p_src + *p_length_read), "cell_Id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_access_related_info->cell_barred, p_src + *p_length_read, "cell_barred");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_access_related_info->cell_barred > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_access_related_info->cell_barred] should be less than"
            " or equal to 1. Incorrect value %u received.", p_cell_access_related_info->cell_barred);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_access_related_info->intra_freq_reselection, p_src + *p_length_read, "intra_freq_reselection");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_access_related_info->intra_freq_reselection > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_access_related_info->intra_freq_reselection] should be less than"
            " or equal to 1. Incorrect value %u received.", p_cell_access_related_info->intra_freq_reselection);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_access_related_info->csg_indication, p_src + *p_length_read, "csg_indication");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_access_related_info->csg_indication > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_access_related_info->csg_indication] should be less than"
            " or equal to 1. Incorrect value %u received.", p_cell_access_related_info->csg_indication);
        return RRC_FAILURE;
    }

    if (p_cell_access_related_info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(p_cell_access_related_info->csg_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_access_related_info->csg_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_access_related_info->csg_identity[loop], (void*)(p_src + *p_length_read), "csg_identity[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (RRC_FAILURE == rrc_il_parse_plmn_id_info_list(
        &p_cell_access_related_info->plmn_Id_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_selection_Info
(
    cell_selection_Info_t *p_cell_selection_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cell_selection_Info, 0, sizeof(cell_selection_Info_t));

    /* This function parses cell_selection_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_selection_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_cell_selection_Info->q_rx_lev_min, p_src + *p_length_read, "q_rx_lev_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_selection_Info->q_rx_lev_min < -70) || (p_cell_selection_Info->q_rx_lev_min > -22))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_selection_Info->q_rx_lev_min] should be in range "
            "-70 to -22. Incorrect value %d received.", p_cell_selection_Info->q_rx_lev_min);
        return RRC_FAILURE;
    }

    if (p_cell_selection_Info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_selection_Info->q_rx_lev_min_offset, p_src + *p_length_read, "q_rx_lev_min_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_selection_Info->q_rx_lev_min_offset < 1) || (p_cell_selection_Info->q_rx_lev_min_offset > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_selection_Info->q_rx_lev_min_offset] should be in range "
            "1 to 8. Incorrect value %u received.", p_cell_selection_Info->q_rx_lev_min_offset);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_mapping_info
(
    sib_mapping_info_t *p_sib_mapping_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib_mapping_info, 0, sizeof(sib_mapping_info_t));

    /* This function parses sib_mapping_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_mapping_info->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)(p_sib_mapping_info->count * sizeof(p_sib_mapping_info->sib_type[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_sib_mapping_info->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sib_mapping_info->sib_type[loop], (void*)(p_src + *p_length_read), "sib_type[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_scheduling_info
(
    scheduling_info_t *p_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_scheduling_info, 0, sizeof(scheduling_info_t));

    /* This function parses scheduling_info */

    if (RRC_FAILURE == rrc_il_parse_sib_mapping_info(
        &p_scheduling_info->sib_mapping_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_scheduling_info->si_periodicity, p_src + *p_length_read, "si_periodicity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_scheduling_info->si_periodicity > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_scheduling_info->si_periodicity] should be less than"
            " or equal to 6. Incorrect value %u received.", p_scheduling_info->si_periodicity);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_scheduling_info_list
(
    scheduling_info_list_t *p_scheduling_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_scheduling_info_list, 0, sizeof(scheduling_info_list_t));

    /* This function parses scheduling_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_scheduling_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_scheduling_info_list->count < 1) || (p_scheduling_info_list->count > MAX_SI_MESSAGE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_scheduling_info_list->count] should be in range "
            "1 to MAX_SI_MESSAGE. Incorrect value %u received.", p_scheduling_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_scheduling_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_scheduling_info(
                &p_scheduling_info_list->scheduling_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_tdd_config
(
    tdd_config_t *p_tdd_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_tdd_config, 0, sizeof(tdd_config_t));

    /* This function parses tdd_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_tdd_config->sub_frame_assignment, p_src + *p_length_read, "sub_frame_assignment");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_tdd_config->sub_frame_assignment > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_tdd_config->sub_frame_assignment] should be less than"
            " or equal to 6. Incorrect value %u received.", p_tdd_config->sub_frame_assignment);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_tdd_config->special_sub_frame_pattern, p_src + *p_length_read, "special_sub_frame_pattern");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_tdd_config->special_sub_frame_pattern > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_tdd_config->special_sub_frame_pattern] should be less than"
            " or equal to 8. Incorrect value %u received.", p_tdd_config->special_sub_frame_pattern);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_multi_band_info_list
(
    multi_band_info_list_t *p_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_multi_band_info_list, 0, sizeof(multi_band_info_list_t));

    /* This function parses multi_band_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_multi_band_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_multi_band_info_list->count < 1) || (p_multi_band_info_list->count > MAX_MULTI_BANDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_multi_band_info_list->count] should be in range "
            "1 to MAX_MULTI_BANDS. Incorrect value %u received.", p_multi_band_info_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_multi_band_info_list->count * sizeof(p_multi_band_info_list->freq_band_indicator[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_multi_band_info_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_multi_band_info_list->freq_band_indicator[loop], (void*)(p_src + *p_length_read), "freq_band_indicator[]");
            if ((p_multi_band_info_list->freq_band_indicator[loop] < 1) || (p_multi_band_info_list->freq_band_indicator[loop] > MAX_FREQ_BAND_INDICATOR))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_multi_band_info_list->freq_band_indicator[%u] should be in "
                    "range 1 to MAX_FREQ_BAND_INDICATOR. "
                    "Incorrect value %d received.", loop, p_multi_band_info_list->freq_band_indicator[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_1_v8h0_ies
(
    sib_type_1_v8h0_ies_t *p_sib_type_1_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_1_v8h0_ies, 0, sizeof(sib_type_1_v8h0_ies_t));

    /* This function parses sib_type_1_v8h0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_1_v8h0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_1_v8h0_ies->bitmask & SIB_TYPE_1_v8h0_IES_MULTI_BAND_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_multi_band_info_list(
        &p_sib_type_1_v8h0_ies->multi_band_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_selection_info_v920
(
    cell_selection_info_v920_t *p_cell_selection_info_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cell_selection_info_v920, 0, sizeof(cell_selection_info_v920_t));

    /* This function parses cell_selection_info_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_selection_info_v920->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_cell_selection_info_v920->q_qual_min_r9, p_src + *p_length_read, "q_qual_min_r9");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_selection_info_v920->q_qual_min_r9 < -34) || (p_cell_selection_info_v920->q_qual_min_r9 > -3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_selection_info_v920->q_qual_min_r9] should be in range "
            "-34 to -3. Incorrect value %d received.", p_cell_selection_info_v920->q_qual_min_r9);
        return RRC_FAILURE;
    }

    if (p_cell_selection_info_v920->presence_bitmask & CELL_SELECTION_INFO_Q_QUAL_MIN_OFFSET_R9_PRESENT_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_selection_info_v920->q_qual_min_offset_r9, p_src + *p_length_read, "q_qual_min_offset_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_selection_info_v920->q_qual_min_offset_r9 < 1) || (p_cell_selection_info_v920->q_qual_min_offset_r9 > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_selection_info_v920->q_qual_min_offset_r9] should be in range "
            "1 to 8. Incorrect value %u received.", p_cell_selection_info_v920->q_qual_min_offset_r9);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_CellSelectionInfoCeR13
(
    CellSelectionInfoCeR13_t *p_CellSelectionInfoCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_CellSelectionInfoCeR13, 0, sizeof(CellSelectionInfoCeR13_t));

    /* This function parses CellSelectionInfoCeR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_CellSelectionInfoCeR13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_CellSelectionInfoCeR13->qRxLevMinCeR13, p_src + *p_length_read, "qRxLevMinCeR13");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_CellSelectionInfoCeR13->qRxLevMinCeR13 < -70) || (p_CellSelectionInfoCeR13->qRxLevMinCeR13 > EMTC_MAX_RXLEVMIN))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_CellSelectionInfoCeR13->qRxLevMinCeR13] should be in range "
            "-70 to EMTC_MAX_RXLEVMIN. Incorrect value %d received.", p_CellSelectionInfoCeR13->qRxLevMinCeR13);
        return RRC_FAILURE;
    }

    if (p_CellSelectionInfoCeR13->bitmask & SIB_1_Q_QUAL_MIN_RSRQ_CE_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_CellSelectionInfoCeR13->qQualMinRrsqCeR13, p_src + *p_length_read, "qQualMinRrsqCeR13");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_CellSelectionInfoCeR13->qQualMinRrsqCeR13 < -34) || (p_CellSelectionInfoCeR13->qQualMinRrsqCeR13 > EMTC_MAX_Q_QUALMINRSRQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_CellSelectionInfoCeR13->qQualMinRrsqCeR13] should be in range "
            "-34 to EMTC_MAX_Q_QUALMINRSRQ. Incorrect value %d received.", p_CellSelectionInfoCeR13->qQualMinRrsqCeR13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_BrSibMappingInfo
(
    BrSibMappingInfo_t *p_BrSibMappingInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_BrSibMappingInfo, 0, sizeof(BrSibMappingInfo_t));

    /* This function parses BrSibMappingInfo */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BrSibMappingInfo->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)(p_BrSibMappingInfo->count * sizeof(p_BrSibMappingInfo->brSibType[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_BrSibMappingInfo->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_BrSibMappingInfo->brSibType[loop], (void*)(p_src + *p_length_read), "brSibType[]");
            if (p_BrSibMappingInfo->brSibType[loop] > EMTC_MAX_SIB_COUNT)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_BrSibMappingInfo->brSibType[%u] should be less"
                    " than or equal to EMTC_MAX_SIB_COUNT. "
                    "Incorrect value %d received.", loop, p_BrSibMappingInfo->brSibType[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_BrSchedulingInfo
(
    BrSchedulingInfo_t *p_BrSchedulingInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_BrSchedulingInfo, 0, sizeof(BrSchedulingInfo_t));

    /* This function parses BrSchedulingInfo */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BrSchedulingInfo->siNarrowbandR13, p_src + *p_length_read, "siNarrowbandR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_BrSchedulingInfo->siNarrowbandR13 < 1) || (p_BrSchedulingInfo->siNarrowbandR13 > EMTC_MAX_AVAILABLE_NARROWBAND))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BrSchedulingInfo->siNarrowbandR13] should be in range "
            "1 to EMTC_MAX_AVAILABLE_NARROWBAND. Incorrect value %u received.", p_BrSchedulingInfo->siNarrowbandR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BrSchedulingInfo->siPeriodicity, p_src + *p_length_read, "siPeriodicity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_BrSchedulingInfo->siPeriodicity > EMTC_SI_PERIODICITY_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BrSchedulingInfo->siPeriodicity] should be less than"
            " or equal to EMTC_SI_PERIODICITY_MAX. Incorrect value %u received.", p_BrSchedulingInfo->siPeriodicity);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_BrSibMappingInfo(
        &p_BrSchedulingInfo->sibMappingInfo,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_SchedulingInfoListBrR13
(
    SchedulingInfoListBrR13_t *p_SchedulingInfoListBrR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_SchedulingInfoListBrR13, 0, sizeof(SchedulingInfoListBrR13_t));

    /* This function parses SchedulingInfoListBrR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SchedulingInfoListBrR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_SchedulingInfoListBrR13->count < 1) || (p_SchedulingInfoListBrR13->count > EMTC_MAX_SI_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_SchedulingInfoListBrR13->count] should be in range "
            "1 to EMTC_MAX_SI_COUNT. Incorrect value %u received.", p_SchedulingInfoListBrR13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_SchedulingInfoListBrR13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_BrSchedulingInfo(
                &p_SchedulingInfoListBrR13->brSchedulingInfo[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_FddDownlinkOrTddSubframeBitmapBrR13
(
    FddDownlinkOrTddSubframeBitmapBrR13_t *p_FddDownlinkOrTddSubframeBitmapBrR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_FddDownlinkOrTddSubframeBitmapBrR13, 0, sizeof(FddDownlinkOrTddSubframeBitmapBrR13_t));

    /* This function parses FddDownlinkOrTddSubframeBitmapBrR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_FddDownlinkOrTddSubframeBitmapBrR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_FddDownlinkOrTddSubframeBitmapBrR13->count < 2) || (p_FddDownlinkOrTddSubframeBitmapBrR13->count > EMTC_MAX_DL_SF_PATTERN_BYTES))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_FddDownlinkOrTddSubframeBitmapBrR13->count] should be in range "
            "2 to EMTC_MAX_DL_SF_PATTERN_BYTES. Incorrect value %u received.", p_FddDownlinkOrTddSubframeBitmapBrR13->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_FddDownlinkOrTddSubframeBitmapBrR13->count * sizeof(p_FddDownlinkOrTddSubframeBitmapBrR13->subframePatternR13[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_FddDownlinkOrTddSubframeBitmapBrR13->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_FddDownlinkOrTddSubframeBitmapBrR13->subframePatternR13[loop], (void*)(p_src + *p_length_read), "subframePatternR13[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_SystemInfoValueTagListR13
(
    SystemInfoValueTagListR13_t *p_SystemInfoValueTagListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_SystemInfoValueTagListR13, 0, sizeof(SystemInfoValueTagListR13_t));

    /* This function parses SystemInfoValueTagListR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SystemInfoValueTagListR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_SystemInfoValueTagListR13->count < 1) || (p_SystemInfoValueTagListR13->count > EMTC_MAX_SI_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_SystemInfoValueTagListR13->count] should be in range "
            "1 to EMTC_MAX_SI_COUNT. Incorrect value %u received.", p_SystemInfoValueTagListR13->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_SystemInfoValueTagListR13->count * sizeof(p_SystemInfoValueTagListR13->systemInfoValueTagR13[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_SystemInfoValueTagListR13->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_SystemInfoValueTagListR13->systemInfoValueTagR13[loop], (void*)(p_src + *p_length_read), "systemInfoValueTagR13[]");
            if (p_SystemInfoValueTagListR13->systemInfoValueTagR13[loop] > EMTC_MAX_SYSTEM_INFO_VALUE_TAG)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_SystemInfoValueTagListR13->systemInfoValueTagR13[%u] should be less"
                    " than or equal to EMTC_MAX_SYSTEM_INFO_VALUE_TAG. "
                    "Incorrect value %d received.", loop, p_SystemInfoValueTagListR13->systemInfoValueTagR13[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_BandwidthReducedAccessRelatedInfoR13
(
    BandwidthReducedAccessRelatedInfoR13_t *p_BandwidthReducedAccessRelatedInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_BandwidthReducedAccessRelatedInfoR13, 0, sizeof(BandwidthReducedAccessRelatedInfoR13_t));

    /* This function parses BandwidthReducedAccessRelatedInfoR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BandwidthReducedAccessRelatedInfoR13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BandwidthReducedAccessRelatedInfoR13->siWindowLengthBrR13, p_src + *p_length_read, "siWindowLengthBrR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_BandwidthReducedAccessRelatedInfoR13->siWindowLengthBrR13 > EMTC_SI_WINDOW_LEN_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BandwidthReducedAccessRelatedInfoR13->siWindowLengthBrR13] should be less than"
            " or equal to EMTC_SI_WINDOW_LEN_MAX. Incorrect value %u received.", p_BandwidthReducedAccessRelatedInfoR13->siWindowLengthBrR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BandwidthReducedAccessRelatedInfoR13->siRepetitionPatternR13, p_src + *p_length_read, "siRepetitionPatternR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_BandwidthReducedAccessRelatedInfoR13->siRepetitionPatternR13 > EMTC_SI_REPETITION_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BandwidthReducedAccessRelatedInfoR13->siRepetitionPatternR13] should be less than"
            " or equal to EMTC_SI_REPETITION_MAX. Incorrect value %u received.", p_BandwidthReducedAccessRelatedInfoR13->siRepetitionPatternR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BandwidthReducedAccessRelatedInfoR13->startSymbolBrR13, p_src + *p_length_read, "startSymbolBrR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_BandwidthReducedAccessRelatedInfoR13->startSymbolBrR13 < 1) || (p_BandwidthReducedAccessRelatedInfoR13->startSymbolBrR13 > EMTC_MAX_START_SYMBOL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BandwidthReducedAccessRelatedInfoR13->startSymbolBrR13] should be in range "
            "1 to EMTC_MAX_START_SYMBOL. Incorrect value %u received.", p_BandwidthReducedAccessRelatedInfoR13->startSymbolBrR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_BandwidthReducedAccessRelatedInfoR13->siHoppingConfigCommonR13, p_src + *p_length_read, "siHoppingConfigCommonR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_BandwidthReducedAccessRelatedInfoR13->siHoppingConfigCommonR13 > EMTC_SI_HOPPING_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BandwidthReducedAccessRelatedInfoR13->siHoppingConfigCommonR13] should be less than"
            " or equal to EMTC_SI_HOPPING_MAX. Incorrect value %u received.", p_BandwidthReducedAccessRelatedInfoR13->siHoppingConfigCommonR13);
        return RRC_FAILURE;
    }

    if (p_BandwidthReducedAccessRelatedInfoR13->bitmask & RRC_RRM_SCHEDULING_INFO_LIST_BR_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_SchedulingInfoListBrR13(
        &p_BandwidthReducedAccessRelatedInfoR13->schedulingInfoListBrR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_BandwidthReducedAccessRelatedInfoR13->bitmask & RRC_RRM_FDD_DOWNLINK_TDD_SF_BITMAP_BR_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_FddDownlinkOrTddSubframeBitmapBrR13(
        &p_BandwidthReducedAccessRelatedInfoR13->fddDownlinkOrTddSubframeBitmapBr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_BandwidthReducedAccessRelatedInfoR13->bitmask & RRC_RRM_FDD_UPLINK_SF_BITMAP_BR_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_BandwidthReducedAccessRelatedInfoR13->fddUplinkSubframeBitmapBr, p_src + *p_length_read, "fddUplinkSubframeBitmapBr");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_BandwidthReducedAccessRelatedInfoR13->fddUplinkSubframeBitmapBr > EMTC_MAX_FDD_UPLINK_SF_BITMAP))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_BandwidthReducedAccessRelatedInfoR13->fddUplinkSubframeBitmapBr] should be less than"
            " or equal to EMTC_MAX_FDD_UPLINK_SF_BITMAP. Incorrect value %u received.", p_BandwidthReducedAccessRelatedInfoR13->fddUplinkSubframeBitmapBr);
        return RRC_FAILURE;
    }
    }

    if (p_BandwidthReducedAccessRelatedInfoR13->bitmask & RRC_RRM_SI_VALUE_TAG_LIST_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_SystemInfoValueTagListR13(
        &p_BandwidthReducedAccessRelatedInfoR13->systemInfoValueTagList,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_SibType1V1310Ies
(
    SibType1V1310Ies_t *p_SibType1V1310Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_SibType1V1310Ies, 0, sizeof(SibType1V1310Ies_t));

    /* This function parses SibType1V1310Ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SibType1V1310Ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SibType1V1310Ies->sib1BrRepetition, p_src + *p_length_read, "sib1BrRepetition");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_SibType1V1310Ies->sib1BrRepetition > EMTC_SIB1_BR_REPETITION_NMAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_SibType1V1310Ies->sib1BrRepetition] should be less than"
            " or equal to EMTC_SIB1_BR_REPETITION_NMAX. Incorrect value %u received.", p_SibType1V1310Ies->sib1BrRepetition);
        return RRC_FAILURE;
    }

    if (p_SibType1V1310Ies->bitmask & RRC_RRM_CELL_SELECTION_INFO_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_CellSelectionInfoCeR13(
        &p_SibType1V1310Ies->cellSelectionInfoCeR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_SibType1V1310Ies->bitmask & RRC_RRM_BW_REDUCED_ACESS_RELATED_INFO_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_BandwidthReducedAccessRelatedInfoR13(
        &p_SibType1V1310Ies->bandwidthReducedAccessRelatedInfoR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_SibType1V1250Ies
(
    SibType1V1250Ies_t *p_SibType1V1250Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_SibType1V1250Ies, 0, sizeof(SibType1V1250Ies_t));

    /* This function parses SibType1V1250Ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SibType1V1250Ies->presenceBitmask, p_src + *p_length_read, "presenceBitmask");
    *p_length_read += sizeof(U8);

    if (p_SibType1V1250Ies->presenceBitmask & SIB_TYPE_1_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_SibType1V1310Ies(
        &p_SibType1V1250Ies->nonCriticalExtension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_SibType1V1130Ies
(
    SibType1V1130Ies_t *p_SibType1V1130Ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_SibType1V1130Ies, 0, sizeof(SibType1V1130Ies_t));

    /* This function parses SibType1V1130Ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_SibType1V1130Ies->presenceBitmask, p_src + *p_length_read, "presenceBitmask");
    *p_length_read += sizeof(U8);

    if (p_SibType1V1130Ies->presenceBitmask & SIB_TYPE_1_V1250_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_SibType1V1250Ies(
        &p_SibType1V1130Ies->nonCriticalExtension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_1_v920_ies
(
    sib_type_1_v920_ies_t *p_sib_type_1_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_1_v920_ies, 0, sizeof(sib_type_1_v920_ies_t));

    /* This function parses sib_type_1_v920_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_1_v920_ies->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_1_v920_ies->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_1_v920_ies->ims_emergency_support, p_src + *p_length_read, "ims_emergency_support");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_1_v920_ies->ims_emergency_support > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_1_v920_ies->ims_emergency_support] should be less than"
            " or equal to 0. Incorrect value %u received.", p_sib_type_1_v920_ies->ims_emergency_support);
        return RRC_FAILURE;
    }
    }

    if (p_sib_type_1_v920_ies->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_selection_info_v920(
        &p_sib_type_1_v920_ies->cell_selection_info_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_1_v920_ies->presence_bitmask & SIB_TYPE_1_V920_IES_NON_CRITICAL_EXTENSION_PRESENT_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_SibType1V1130Ies(
        &p_sib_type_1_v920_ies->nonCriticalExtension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_1_v890_ies
(
    sib_type_1_v890_ies_t *p_sib_type_1_v890_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_1_v890_ies, 0, sizeof(sib_type_1_v890_ies_t));

    /* This function parses sib_type_1_v890_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_1_v890_ies->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_1_v890_ies->presence_bitmask & SIB_TYPE_1_V890_IES_LATE_NON_CRITICAL_EXTENSION_PRESENT_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_v8h0_ies(
        &p_sib_type_1_v890_ies->late_non_critical_extension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_1_v890_ies->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_v920_ies(
        &p_sib_type_1_v890_ies->non_critical_extension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_1_Info
(
    sib_type_1_Info_t *p_sib_type_1_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_1_Info, 0, sizeof(sib_type_1_Info_t));

    /* This function parses sib_type_1_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_1_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cell_access_related_info(
        &p_sib_type_1_Info->cell_access_related_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_cell_selection_Info(
        &p_sib_type_1_Info->cell_selection_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_sib_type_1_Info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_sib_type_1_Info->p_max, p_src + *p_length_read, "p_max");
    *p_length_read += sizeof(S8);
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_1_Info->freq_band_indicator, p_src + *p_length_read, "freq_band_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_sib_type_1_Info->freq_band_indicator < 1) || (p_sib_type_1_Info->freq_band_indicator > MAX_FREQ_BAND_INDICATOR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_1_Info->freq_band_indicator] should be in range "
            "1 to MAX_FREQ_BAND_INDICATOR. Incorrect value %u received.", p_sib_type_1_Info->freq_band_indicator);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_1_Info->si_window_length, p_src + *p_length_read, "si_window_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_1_Info->si_window_length > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_1_Info->si_window_length] should be less than"
            " or equal to 6. Incorrect value %u received.", p_sib_type_1_Info->si_window_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_1_Info->si_value_tag, p_src + *p_length_read, "si_value_tag");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_1_Info->si_value_tag > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_1_Info->si_value_tag] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib_type_1_Info->si_value_tag);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_scheduling_info_list(
        &p_sib_type_1_Info->scheduling_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_sib_type_1_Info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_tdd_config(
        &p_sib_type_1_Info->tdd_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_1_Info->presence_bitmask & 4)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_v890_ies(
        &p_sib_type_1_Info->non_critical_extension,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_access_class_barring_Info
(
    access_class_barring_Info_t *p_access_class_barring_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_access_class_barring_Info, 0, sizeof(access_class_barring_Info_t));

    /* This function parses access_class_barring_Info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_access_class_barring_Info->ac_barring_factor, p_src + *p_length_read, "ac_barring_factor");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_access_class_barring_Info->ac_barring_factor > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_access_class_barring_Info->ac_barring_factor] should be less than"
            " or equal to 15. Incorrect value %u received.", p_access_class_barring_Info->ac_barring_factor);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_access_class_barring_Info->ac_barring_time, p_src + *p_length_read, "ac_barring_time");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_access_class_barring_Info->ac_barring_time > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_access_class_barring_Info->ac_barring_time] should be less than"
            " or equal to 7. Incorrect value %u received.", p_access_class_barring_Info->ac_barring_time);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_access_class_barring_Info->ac_barring_for_special_ac, p_src + *p_length_read, "ac_barring_for_special_ac");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_access_barring_info
(
    access_barring_info_t *p_access_barring_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_access_barring_info, 0, sizeof(access_barring_info_t));

    /* This function parses access_barring_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_access_barring_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_access_barring_info->acBarringForEmergency, p_src + *p_length_read, "acBarringForEmergency");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_access_barring_info->acBarringForEmergency > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_access_barring_info->acBarringForEmergency] should be less than"
            " or equal to 1. Incorrect value %u received.", p_access_barring_info->acBarringForEmergency);
        return RRC_FAILURE;
    }

    if (p_access_barring_info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_access_class_barring_Info(
        &p_access_barring_info->ac_barring_for_mo_signalling,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_access_barring_info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_access_class_barring_Info(
        &p_access_barring_info->ac_barring_for_mo_data,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_preambles_group_a_config
(
    preambles_group_a_config_t *p_preambles_group_a_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_preambles_group_a_config, 0, sizeof(preambles_group_a_config_t));

    /* This function parses preambles_group_a_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_preambles_group_a_config->ra_preambles_group_a_size, p_src + *p_length_read, "ra_preambles_group_a_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_preambles_group_a_config->ra_preambles_group_a_size > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_preambles_group_a_config->ra_preambles_group_a_size] should be less than"
            " or equal to 14. Incorrect value %u received.", p_preambles_group_a_config->ra_preambles_group_a_size);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_preambles_group_a_config->group_a_msg_size, p_src + *p_length_read, "group_a_msg_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_preambles_group_a_config->group_a_msg_size > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_preambles_group_a_config->group_a_msg_size] should be less than"
            " or equal to 3. Incorrect value %u received.", p_preambles_group_a_config->group_a_msg_size);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_preambles_group_a_config->group_b_msg_power_offset, p_src + *p_length_read, "group_b_msg_power_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_preambles_group_a_config->group_b_msg_power_offset > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_preambles_group_a_config->group_b_msg_power_offset] should be less than"
            " or equal to 7. Incorrect value %u received.", p_preambles_group_a_config->group_b_msg_power_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_preamble_info
(
    preamble_info_t *p_preamble_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_preamble_info, 0, sizeof(preamble_info_t));

    /* This function parses preamble_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_preamble_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_preamble_info->ra_preamble_count, p_src + *p_length_read, "ra_preamble_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_preamble_info->ra_preamble_count > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_preamble_info->ra_preamble_count] should be less than"
            " or equal to 15. Incorrect value %u received.", p_preamble_info->ra_preamble_count);
        return RRC_FAILURE;
    }

    if (p_preamble_info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_preambles_group_a_config(
        &p_preamble_info->preambles_group_a_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_power_ramping_params
(
    power_ramping_params_t *p_power_ramping_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_power_ramping_params, 0, sizeof(power_ramping_params_t));

    /* This function parses power_ramping_params */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_power_ramping_params->power_ramping_step, p_src + *p_length_read, "power_ramping_step");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_power_ramping_params->power_ramping_step > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_power_ramping_params->power_ramping_step] should be less than"
            " or equal to 3. Incorrect value %u received.", p_power_ramping_params->power_ramping_step);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_power_ramping_params->preamble_init_rec_target_pow, p_src + *p_length_read, "preamble_init_rec_target_pow");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_power_ramping_params->preamble_init_rec_target_pow > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_power_ramping_params->preamble_init_rec_target_pow] should be less than"
            " or equal to 15. Incorrect value %u received.", p_power_ramping_params->preamble_init_rec_target_pow);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ra_supervision_info
(
    ra_supervision_info_t *p_ra_supervision_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ra_supervision_info, 0, sizeof(ra_supervision_info_t));

    /* This function parses ra_supervision_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ra_supervision_info->preamble_trans_max, p_src + *p_length_read, "preamble_trans_max");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ra_supervision_info->preamble_trans_max > 10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ra_supervision_info->preamble_trans_max] should be less than"
            " or equal to 10. Incorrect value %u received.", p_ra_supervision_info->preamble_trans_max);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ra_supervision_info->ra_resp_win_size, p_src + *p_length_read, "ra_resp_win_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ra_supervision_info->ra_resp_win_size > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ra_supervision_info->ra_resp_win_size] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ra_supervision_info->ra_resp_win_size);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ra_supervision_info->mac_cont_resol_timer, p_src + *p_length_read, "mac_cont_resol_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ra_supervision_info->mac_cont_resol_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ra_supervision_info->mac_cont_resol_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ra_supervision_info->mac_cont_resol_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PreambleMappingInfoR13
(
    PreambleMappingInfoR13_t *p_PreambleMappingInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_PreambleMappingInfoR13, 0, sizeof(PreambleMappingInfoR13_t));

    /* This function parses PreambleMappingInfoR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PreambleMappingInfoR13->firstPreambleR13, p_src + *p_length_read, "firstPreambleR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PreambleMappingInfoR13->firstPreambleR13 > EMTC_MAX_PREAMBLE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PreambleMappingInfoR13->firstPreambleR13] should be less than"
            " or equal to EMTC_MAX_PREAMBLE. Incorrect value %u received.", p_PreambleMappingInfoR13->firstPreambleR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PreambleMappingInfoR13->lastPreambleR13, p_src + *p_length_read, "lastPreambleR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PreambleMappingInfoR13->lastPreambleR13 > EMTC_MAX_PREAMBLE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PreambleMappingInfoR13->lastPreambleR13] should be less than"
            " or equal to EMTC_MAX_PREAMBLE. Incorrect value %u received.", p_PreambleMappingInfoR13->lastPreambleR13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RachCeLevelInfoR13
(
    RachCeLevelInfoR13_t *p_RachCeLevelInfoR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RachCeLevelInfoR13, 0, sizeof(RachCeLevelInfoR13_t));

    /* This function parses RachCeLevelInfoR13 */

    if (RRC_FAILURE == rrc_il_parse_PreambleMappingInfoR13(
        &p_RachCeLevelInfoR13->preambleMappingInfoR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RachCeLevelInfoR13->raResponseWindowSizeR13, p_src + *p_length_read, "raResponseWindowSizeR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RachCeLevelInfoR13->raResponseWindowSizeR13 > EMTC_RA_RESPONSE_WINDOW_SIZE_SF_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RachCeLevelInfoR13->raResponseWindowSizeR13] should be less than"
            " or equal to EMTC_RA_RESPONSE_WINDOW_SIZE_SF_MAX. Incorrect value %u received.", p_RachCeLevelInfoR13->raResponseWindowSizeR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RachCeLevelInfoR13->macContentionResolutionTimerR13, p_src + *p_length_read, "macContentionResolutionTimerR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RachCeLevelInfoR13->macContentionResolutionTimerR13 > EMTC_MAC_CONTENTION_RESOLUTION_TIMER_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RachCeLevelInfoR13->macContentionResolutionTimerR13] should be less than"
            " or equal to EMTC_MAC_CONTENTION_RESOLUTION_TIMER_MAX. Incorrect value %u received.", p_RachCeLevelInfoR13->macContentionResolutionTimerR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RachCeLevelInfoR13->rarHoppingConfigR13, p_src + *p_length_read, "rarHoppingConfigR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RachCeLevelInfoR13->rarHoppingConfigR13 > EMTC_RAR_HOPPPING_CONFIG_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RachCeLevelInfoR13->rarHoppingConfigR13] should be less than"
            " or equal to EMTC_RAR_HOPPPING_CONFIG_MAX. Incorrect value %u received.", p_RachCeLevelInfoR13->rarHoppingConfigR13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RachCeLevelInfoListR13
(
    RachCeLevelInfoListR13_t *p_RachCeLevelInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RachCeLevelInfoListR13, 0, sizeof(RachCeLevelInfoListR13_t));

    /* This function parses RachCeLevelInfoListR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RachCeLevelInfoListR13->numCeLevels, p_src + *p_length_read, "numCeLevels");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RachCeLevelInfoListR13->numCeLevels > EMTC_MAX_CE_LEVEL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RachCeLevelInfoListR13->numCeLevels] should be less than"
            " or equal to EMTC_MAX_CE_LEVEL. Incorrect value %u received.", p_RachCeLevelInfoListR13->numCeLevels);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_RachCeLevelInfoListR13->numCeLevels; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_RachCeLevelInfoR13(
                &p_RachCeLevelInfoListR13->rachCeLevelInfo[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rach_config_common
(
    rach_config_common_t *p_rach_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rach_config_common, 0, sizeof(rach_config_common_t));

    /* This function parses rach_config_common */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rach_config_common->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_preamble_info(
        &p_rach_config_common->preamble_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_power_ramping_params(
        &p_rach_config_common->power_ramping_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_ra_supervision_info(
        &p_rach_config_common->ra_supervision_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rach_config_common->max_harq_msg_3_tx, p_src + *p_length_read, "max_harq_msg_3_tx");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rach_config_common->max_harq_msg_3_tx < 1) || (p_rach_config_common->max_harq_msg_3_tx > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rach_config_common->max_harq_msg_3_tx] should be in range "
            "1 to 8. Incorrect value %u received.", p_rach_config_common->max_harq_msg_3_tx);
        return RRC_FAILURE;
    }

    if (p_rach_config_common->bitmask & RRC_RRM_PREAMBLE_TRANS_MAX_CE_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rach_config_common->preambleTransMaxCeR13, p_src + *p_length_read, "preambleTransMaxCeR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rach_config_common->preambleTransMaxCeR13 > EMTC_PREAMBLE_TRANS_MAX_CE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rach_config_common->preambleTransMaxCeR13] should be less than"
            " or equal to EMTC_PREAMBLE_TRANS_MAX_CE_MAX. Incorrect value %u received.", p_rach_config_common->preambleTransMaxCeR13);
        return RRC_FAILURE;
    }
    }

    if (p_rach_config_common->bitmask & RRC_RRM_RACH_CE_LEVEL_INFO_LIST_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RachCeLevelInfoListR13(
        &p_rach_config_common->rachCeLevelInfoList,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_bcch_config
(
    bcch_config_t *p_bcch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_bcch_config, 0, sizeof(bcch_config_t));

    /* This function parses bcch_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_bcch_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_bcch_config->mod_period_coeff, p_src + *p_length_read, "mod_period_coeff");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_bcch_config->mod_period_coeff > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_bcch_config->mod_period_coeff] should be less than"
            " or equal to 3. Incorrect value %u received.", p_bcch_config->mod_period_coeff);
        return RRC_FAILURE;
    }

    if (p_bcch_config->bitmask & RRC_RRM_MODIFICATION_PERIOD_COEFF_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_bcch_config->modificationPeriodCoeffR13, p_src + *p_length_read, "modificationPeriodCoeffR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_bcch_config->modificationPeriodCoeffR13 > EMTC_MOD_PERIOD_COEFF_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_bcch_config->modificationPeriodCoeffR13] should be less than"
            " or equal to EMTC_MOD_PERIOD_COEFF_MAX. Incorrect value %u received.", p_bcch_config->modificationPeriodCoeffR13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pcch_config
(
    pcch_config_t *p_pcch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pcch_config, 0, sizeof(pcch_config_t));

    /* This function parses pcch_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pcch_config->default_paging_cycle, p_src + *p_length_read, "default_paging_cycle");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pcch_config->default_paging_cycle > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pcch_config->default_paging_cycle] should be less than"
            " or equal to 3. Incorrect value %u received.", p_pcch_config->default_paging_cycle);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pcch_config->nb, p_src + *p_length_read, "nb");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pcch_config->nb > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pcch_config->nb] should be less than"
            " or equal to 7. Incorrect value %u received.", p_pcch_config->nb);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_prach_config_info
(
    prach_config_info_t *p_prach_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_prach_config_info, 0, sizeof(prach_config_info_t));

    /* This function parses prach_config_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_prach_config_info->prach_config_index, p_src + *p_length_read, "prach_config_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_prach_config_info->prach_config_index > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_prach_config_info->prach_config_index] should be less than"
            " or equal to 63. Incorrect value %u received.", p_prach_config_info->prach_config_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_prach_config_info->high_speed_flag, p_src + *p_length_read, "high_speed_flag");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_prach_config_info->high_speed_flag > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_prach_config_info->high_speed_flag] should be less than"
            " or equal to 1. Incorrect value %u received.", p_prach_config_info->high_speed_flag);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_prach_config_info->zero_cor_zone_config, p_src + *p_length_read, "zero_cor_zone_config");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_prach_config_info->zero_cor_zone_config > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_prach_config_info->zero_cor_zone_config] should be less than"
            " or equal to 15. Incorrect value %u received.", p_prach_config_info->zero_cor_zone_config);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_prach_config_info->prach_freq_offset, p_src + *p_length_read, "prach_freq_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_prach_config_info->prach_freq_offset > 94))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_prach_config_info->prach_freq_offset] should be less than"
            " or equal to 94. Incorrect value %u received.", p_prach_config_info->prach_freq_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_prach_config_sib
(
    prach_config_sib_t *p_prach_config_sib,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_prach_config_sib, 0, sizeof(prach_config_sib_t));

    /* This function parses prach_config_sib */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_prach_config_sib->root_seq_index, p_src + *p_length_read, "root_seq_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_prach_config_sib->root_seq_index > 837))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_prach_config_sib->root_seq_index] should be less than"
            " or equal to 837. Incorrect value %u received.", p_prach_config_sib->root_seq_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_prach_config_info(
        &p_prach_config_sib->prach_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pdsch_config_common
(
    pdsch_config_common_t *p_pdsch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pdsch_config_common, 0, sizeof(pdsch_config_common_t));

    /* This function parses pdsch_config_common */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_pdsch_config_common->ref_signal_power, p_src + *p_length_read, "ref_signal_power");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_pdsch_config_common->ref_signal_power < -60) || (p_pdsch_config_common->ref_signal_power > 50))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pdsch_config_common->ref_signal_power] should be in range "
            "-60 to 50. Incorrect value %d received.", p_pdsch_config_common->ref_signal_power);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pdsch_config_common->pb, p_src + *p_length_read, "pb");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pdsch_config_common->pb > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pdsch_config_common->pb] should be less than"
            " or equal to 3. Incorrect value %u received.", p_pdsch_config_common->pb);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pusch_config_basic
(
    pusch_config_basic_t *p_pusch_config_basic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pusch_config_basic, 0, sizeof(pusch_config_basic_t));

    /* This function parses pusch_config_basic */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pusch_config_basic->nsb, p_src + *p_length_read, "nsb");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_pusch_config_basic->nsb < 1) || (p_pusch_config_basic->nsb > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pusch_config_basic->nsb] should be in range "
            "1 to 4. Incorrect value %u received.", p_pusch_config_basic->nsb);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pusch_config_basic->hopping_mode, p_src + *p_length_read, "hopping_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pusch_config_basic->hopping_mode > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pusch_config_basic->hopping_mode] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pusch_config_basic->hopping_mode);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pusch_config_basic->pusch_hopping_offset, p_src + *p_length_read, "pusch_hopping_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pusch_config_basic->pusch_hopping_offset > 98))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pusch_config_basic->pusch_hopping_offset] should be less than"
            " or equal to 98. Incorrect value %u received.", p_pusch_config_basic->pusch_hopping_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pusch_config_basic->enable_64_qam, p_src + *p_length_read, "enable_64_qam");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pusch_config_basic->enable_64_qam > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pusch_config_basic->enable_64_qam] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pusch_config_basic->enable_64_qam);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ul_ref_signals_pusch
(
    ul_ref_signals_pusch_t *p_ul_ref_signals_pusch,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ul_ref_signals_pusch, 0, sizeof(ul_ref_signals_pusch_t));

    /* This function parses ul_ref_signals_pusch */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ul_ref_signals_pusch->group_hopping_enabled, p_src + *p_length_read, "group_hopping_enabled");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ul_ref_signals_pusch->group_hopping_enabled > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ul_ref_signals_pusch->group_hopping_enabled] should be less than"
            " or equal to 1. Incorrect value %u received.", p_ul_ref_signals_pusch->group_hopping_enabled);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ul_ref_signals_pusch->group_assign_pusch, p_src + *p_length_read, "group_assign_pusch");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ul_ref_signals_pusch->group_assign_pusch > 29))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ul_ref_signals_pusch->group_assign_pusch] should be less than"
            " or equal to 29. Incorrect value %u received.", p_ul_ref_signals_pusch->group_assign_pusch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ul_ref_signals_pusch->seq_hopping_enabled, p_src + *p_length_read, "seq_hopping_enabled");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ul_ref_signals_pusch->seq_hopping_enabled > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ul_ref_signals_pusch->seq_hopping_enabled] should be less than"
            " or equal to 1. Incorrect value %u received.", p_ul_ref_signals_pusch->seq_hopping_enabled);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ul_ref_signals_pusch->cyclic_shift, p_src + *p_length_read, "cyclic_shift");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ul_ref_signals_pusch->cyclic_shift > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ul_ref_signals_pusch->cyclic_shift] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ul_ref_signals_pusch->cyclic_shift);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pusch_config_common
(
    pusch_config_common_t *p_pusch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pusch_config_common, 0, sizeof(pusch_config_common_t));

    /* This function parses pusch_config_common */

    if (RRC_FAILURE == rrc_il_parse_pusch_config_basic(
        &p_pusch_config_common->pusch_config_basic,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_ul_ref_signals_pusch(
        &p_pusch_config_common->ul_ref_signals_pusch,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pucch_config_common
(
    pucch_config_common_t *p_pucch_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pucch_config_common, 0, sizeof(pucch_config_common_t));

    /* This function parses pucch_config_common */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pucch_config_common->delta_pucch_shift, p_src + *p_length_read, "delta_pucch_shift");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pucch_config_common->delta_pucch_shift > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pucch_config_common->delta_pucch_shift] should be less than"
            " or equal to 2. Incorrect value %u received.", p_pucch_config_common->delta_pucch_shift);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pucch_config_common->n_rb_cqi, p_src + *p_length_read, "n_rb_cqi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pucch_config_common->n_rb_cqi > 98))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pucch_config_common->n_rb_cqi] should be less than"
            " or equal to 98. Incorrect value %u received.", p_pucch_config_common->n_rb_cqi);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pucch_config_common->n_cs_an, p_src + *p_length_read, "n_cs_an");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pucch_config_common->n_cs_an > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pucch_config_common->n_cs_an] should be less than"
            " or equal to 7. Incorrect value %u received.", p_pucch_config_common->n_cs_an);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pucch_config_common->n_one_pucch_an, p_src + *p_length_read, "n_one_pucch_an");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_pucch_config_common->n_one_pucch_an > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pucch_config_common->n_one_pucch_an] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_pucch_config_common->n_one_pucch_an);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sounding_rs_ul_config_common_setup
(
    sounding_rs_ul_config_common_setup_t *p_sounding_rs_ul_config_common_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sounding_rs_ul_config_common_setup, 0, sizeof(sounding_rs_ul_config_common_setup_t));

    /* This function parses sounding_rs_ul_config_common_setup */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sounding_rs_ul_config_common_setup->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sounding_rs_ul_config_common_setup->srs_bw_config, p_src + *p_length_read, "srs_bw_config");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sounding_rs_ul_config_common_setup->srs_bw_config > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sounding_rs_ul_config_common_setup->srs_bw_config] should be less than"
            " or equal to 7. Incorrect value %u received.", p_sounding_rs_ul_config_common_setup->srs_bw_config);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sounding_rs_ul_config_common_setup->srs_subframe_config, p_src + *p_length_read, "srs_subframe_config");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sounding_rs_ul_config_common_setup->srs_subframe_config > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sounding_rs_ul_config_common_setup->srs_subframe_config] should be less than"
            " or equal to 15. Incorrect value %u received.", p_sounding_rs_ul_config_common_setup->srs_subframe_config);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sounding_rs_ul_config_common_setup->ack_nack_srs_simul_trans, p_src + *p_length_read, "ack_nack_srs_simul_trans");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sounding_rs_ul_config_common_setup->ack_nack_srs_simul_trans > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sounding_rs_ul_config_common_setup->ack_nack_srs_simul_trans] should be less than"
            " or equal to 1. Incorrect value %u received.", p_sounding_rs_ul_config_common_setup->ack_nack_srs_simul_trans);
        return RRC_FAILURE;
    }

    if (p_sounding_rs_ul_config_common_setup->presence_bitmask & SOUNDING_RS_UL_CONFIG_COMMON_SETUP_SRS_MAX_UP_PTS_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sounding_rs_ul_config_common_setup->srs_max_up_pts, p_src + *p_length_read, "srs_max_up_pts");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sounding_rs_ul_config_common_setup->srs_max_up_pts > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sounding_rs_ul_config_common_setup->srs_max_up_pts] should be less than"
            " or equal to 0. Incorrect value %u received.", p_sounding_rs_ul_config_common_setup->srs_max_up_pts);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sounding_rs_ul_config_common
(
    sounding_rs_ul_config_common_t *p_sounding_rs_ul_config_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sounding_rs_ul_config_common, 0, sizeof(sounding_rs_ul_config_common_t));

    /* This function parses sounding_rs_ul_config_common */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sounding_rs_ul_config_common->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sounding_rs_ul_config_common->presence_bitmask & SOUNDING_RS_UL_CONFIG_COMMON_SETUP_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sounding_rs_ul_config_common_setup(
        &p_sounding_rs_ul_config_common->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_delta_f_list_pucch
(
    delta_f_list_pucch_t *p_delta_f_list_pucch,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_delta_f_list_pucch, 0, sizeof(delta_f_list_pucch_t));

    /* This function parses delta_f_list_pucch */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_delta_f_list_pucch->delta_f_pucch_format_one, p_src + *p_length_read, "delta_f_pucch_format_one");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_delta_f_list_pucch->delta_f_pucch_format_one > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_delta_f_list_pucch->delta_f_pucch_format_one] should be less than"
            " or equal to 2. Incorrect value %u received.", p_delta_f_list_pucch->delta_f_pucch_format_one);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_delta_f_list_pucch->delta_f_pucch_format_one_b, p_src + *p_length_read, "delta_f_pucch_format_one_b");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_delta_f_list_pucch->delta_f_pucch_format_one_b > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_delta_f_list_pucch->delta_f_pucch_format_one_b] should be less than"
            " or equal to 2. Incorrect value %u received.", p_delta_f_list_pucch->delta_f_pucch_format_one_b);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_delta_f_pucch_format_two
(
    delta_f_pucch_format_two_t *p_delta_f_pucch_format_two,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_delta_f_pucch_format_two, 0, sizeof(delta_f_pucch_format_two_t));

    /* This function parses delta_f_pucch_format_two */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_delta_f_pucch_format_two->delta_f_pucch_format_two, p_src + *p_length_read, "delta_f_pucch_format_two");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_delta_f_pucch_format_two->delta_f_pucch_format_two > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_delta_f_pucch_format_two->delta_f_pucch_format_two] should be less than"
            " or equal to 3. Incorrect value %u received.", p_delta_f_pucch_format_two->delta_f_pucch_format_two);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_delta_f_pucch_format_two->delta_f_pucch_format_two_a, p_src + *p_length_read, "delta_f_pucch_format_two_a");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_delta_f_pucch_format_two->delta_f_pucch_format_two_a > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_delta_f_pucch_format_two->delta_f_pucch_format_two_a] should be less than"
            " or equal to 2. Incorrect value %u received.", p_delta_f_pucch_format_two->delta_f_pucch_format_two_a);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_delta_f_pucch_format_two->delta_f_pucch_format_two_b, p_src + *p_length_read, "delta_f_pucch_format_two_b");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_delta_f_pucch_format_two->delta_f_pucch_format_two_b > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_delta_f_pucch_format_two->delta_f_pucch_format_two_b] should be less than"
            " or equal to 2. Incorrect value %u received.", p_delta_f_pucch_format_two->delta_f_pucch_format_two_b);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_uplink_power_control_common
(
    uplink_power_control_common_t *p_uplink_power_control_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_uplink_power_control_common, 0, sizeof(uplink_power_control_common_t));

    /* This function parses uplink_power_control_common */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_uplink_power_control_common->p_zero_nominal_Pusch, p_src + *p_length_read, "p_zero_nominal_Pusch");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_uplink_power_control_common->p_zero_nominal_Pusch < -126) || (p_uplink_power_control_common->p_zero_nominal_Pusch > 24))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common->p_zero_nominal_Pusch] should be in range "
            "-126 to 24. Incorrect value %d received.", p_uplink_power_control_common->p_zero_nominal_Pusch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_uplink_power_control_common->alpha, p_src + *p_length_read, "alpha");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_uplink_power_control_common->alpha > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common->alpha] should be less than"
            " or equal to 7. Incorrect value %u received.", p_uplink_power_control_common->alpha);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_uplink_power_control_common->p_zero_nominal_pucch, p_src + *p_length_read, "p_zero_nominal_pucch");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_uplink_power_control_common->p_zero_nominal_pucch < -127) || (p_uplink_power_control_common->p_zero_nominal_pucch > -96))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common->p_zero_nominal_pucch] should be in range "
            "-127 to -96. Incorrect value %d received.", p_uplink_power_control_common->p_zero_nominal_pucch);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_delta_f_list_pucch(
        &p_uplink_power_control_common->delta_f_list_pucch,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_delta_f_pucch_format_two(
        &p_uplink_power_control_common->delta_f_pucch_format_two,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_uplink_power_control_common->delta_preamble_msg_three, p_src + *p_length_read, "delta_preamble_msg_three");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_uplink_power_control_common->delta_preamble_msg_three < -1) || (p_uplink_power_control_common->delta_preamble_msg_three > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common->delta_preamble_msg_three] should be in range "
            "-1 to 6. Incorrect value %d received.", p_uplink_power_control_common->delta_preamble_msg_three);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_uplink_power_control_common_v1020
(
    uplink_power_control_common_v1020_t *p_uplink_power_control_common_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_uplink_power_control_common_v1020, 0, sizeof(uplink_power_control_common_v1020_t));

    /* This function parses uplink_power_control_common_v1020 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_uplink_power_control_common_v1020->pucch_format3_r10, p_src + *p_length_read, "pucch_format3_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_uplink_power_control_common_v1020->pucch_format3_r10 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common_v1020->pucch_format3_r10] should be less than"
            " or equal to 7. Incorrect value %u received.", p_uplink_power_control_common_v1020->pucch_format3_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_uplink_power_control_common_v1020->pucch_format1_bcs_r10, p_src + *p_length_read, "pucch_format1_bcs_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_uplink_power_control_common_v1020->pucch_format1_bcs_r10 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_uplink_power_control_common_v1020->pucch_format1_bcs_r10] should be less than"
            " or equal to 1. Incorrect value %u received.", p_uplink_power_control_common_v1020->pucch_format1_bcs_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PcchConfigV1310
(
    PcchConfigV1310_t *p_PcchConfigV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_PcchConfigV1310, 0, sizeof(PcchConfigV1310_t));

    /* This function parses PcchConfigV1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->pagingNarrowBandsR13, p_src + *p_length_read, "pagingNarrowBandsR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_PcchConfigV1310->pagingNarrowBandsR13 < 1) || (p_PcchConfigV1310->pagingNarrowBandsR13 > EMTC_MAX_AVAILABLE_NARROWBAND))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PcchConfigV1310->pagingNarrowBandsR13] should be in range "
            "1 to EMTC_MAX_AVAILABLE_NARROWBAND. Incorrect value %u received.", p_PcchConfigV1310->pagingNarrowBandsR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->mpdcchMaxNumRepetitionPaging, p_src + *p_length_read, "mpdcchMaxNumRepetitionPaging");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PcchConfigV1310->mpdcchMaxNumRepetitionPaging > EMTC_MPDCCH_MAX_NUM_REPETITION_PAGING_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PcchConfigV1310->mpdcchMaxNumRepetitionPaging] should be less than"
            " or equal to EMTC_MPDCCH_MAX_NUM_REPETITION_PAGING_MAX. Incorrect value %u received.", p_PcchConfigV1310->mpdcchMaxNumRepetitionPaging);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->mpdcchNumRepetitionPaging, p_src + *p_length_read, "mpdcchNumRepetitionPaging");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_PcchConfigV1310->mpdcchNumRepetitionPaging < 1) || (p_PcchConfigV1310->mpdcchNumRepetitionPaging > EMTC_MPDCCH_NUM_REPETITION_PAGING_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PcchConfigV1310->mpdcchNumRepetitionPaging] should be in range "
            "1 to EMTC_MPDCCH_NUM_REPETITION_PAGING_MAX. Incorrect value %u received.", p_PcchConfigV1310->mpdcchNumRepetitionPaging);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->pdschNumRepetitionPaging, p_src + *p_length_read, "pdschNumRepetitionPaging");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_PcchConfigV1310->pdschNumRepetitionPaging < 1) || (p_PcchConfigV1310->pdschNumRepetitionPaging > EMTC_PDSCH_PAGING_REP_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PcchConfigV1310->pdschNumRepetitionPaging] should be in range "
            "1 to EMTC_PDSCH_PAGING_REP_MAX. Incorrect value %u received.", p_PcchConfigV1310->pdschNumRepetitionPaging);
        return RRC_FAILURE;
    }

    if (p_PcchConfigV1310->bitmask & RRC_PCCH_CONFIG_V1310_NB_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PcchConfigV1310->nBv1310, p_src + *p_length_read, "nBv1310");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PcchConfigV1310->nBv1310 > EMTC_NB_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PcchConfigV1310->nBv1310] should be less than"
            " or equal to EMTC_NB_MAX. Incorrect value %u received.", p_PcchConfigV1310->nBv1310);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PdschConfigCommonV1310
(
    PdschConfigCommonV1310_t *p_PdschConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_PdschConfigCommonV1310, 0, sizeof(PdschConfigCommonV1310_t));

    /* This function parses PdschConfigCommonV1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PdschConfigCommonV1310->pdschMaxNumRepetitionCeModeA, p_src + *p_length_read, "pdschMaxNumRepetitionCeModeA");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PdschConfigCommonV1310->pdschMaxNumRepetitionCeModeA > EMTC_PDSCH_MAX_NUM_REPETITION_CE_MODE_A_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PdschConfigCommonV1310->pdschMaxNumRepetitionCeModeA] should be less than"
            " or equal to EMTC_PDSCH_MAX_NUM_REPETITION_CE_MODE_A_MAX. Incorrect value %u received.", p_PdschConfigCommonV1310->pdschMaxNumRepetitionCeModeA);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PuschConfigCommonV1310
(
    PuschConfigCommonV1310_t *p_PuschConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_PuschConfigCommonV1310, 0, sizeof(PuschConfigCommonV1310_t));

    /* This function parses PuschConfigCommonV1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PuschConfigCommonV1310->puschMaxNumRepetitionCeModeA, p_src + *p_length_read, "puschMaxNumRepetitionCeModeA");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PuschConfigCommonV1310->puschMaxNumRepetitionCeModeA > EMTC_PUSCH_MAX_NUM_REPTITION_CE_MODE_A_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PuschConfigCommonV1310->puschMaxNumRepetitionCeModeA] should be less than"
            " or equal to EMTC_PUSCH_MAX_NUM_REPTITION_CE_MODE_A_MAX. Incorrect value %u received.", p_PuschConfigCommonV1310->puschMaxNumRepetitionCeModeA);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_MpdcchNarrowbandsToMonitorR13
(
    MpdcchNarrowbandsToMonitorR13_t *p_MpdcchNarrowbandsToMonitorR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_MpdcchNarrowbandsToMonitorR13, 0, sizeof(MpdcchNarrowbandsToMonitorR13_t));

    /* This function parses MpdcchNarrowbandsToMonitorR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_MpdcchNarrowbandsToMonitorR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_MpdcchNarrowbandsToMonitorR13->count < 1) || (p_MpdcchNarrowbandsToMonitorR13->count > EMTC_MAX_NARROWBAND_TO_MONITOR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_MpdcchNarrowbandsToMonitorR13->count] should be in range "
            "1 to EMTC_MAX_NARROWBAND_TO_MONITOR. Incorrect value %u received.", p_MpdcchNarrowbandsToMonitorR13->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_MpdcchNarrowbandsToMonitorR13->count * sizeof(p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_MpdcchNarrowbandsToMonitorR13->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[loop], (void*)(p_src + *p_length_read), "mpdcchNarrowbandsToMonitor[]");
            if ((p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[loop] < 1) || (p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[loop] > EMTC_MAX_AVAILABLE_NARROWBAND))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[%u] should be in "
                    "range 1 to EMTC_MAX_AVAILABLE_NARROWBAND. "
                    "Incorrect value %d received.", loop, p_MpdcchNarrowbandsToMonitorR13->mpdcchNarrowbandsToMonitor[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PrachParametersCeR13
(
    PrachParametersCeR13_t *p_PrachParametersCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_PrachParametersCeR13, 0, sizeof(PrachParametersCeR13_t));

    /* This function parses PrachParametersCeR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->prachConfigIndexR13, p_src + *p_length_read, "prachConfigIndexR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->prachConfigIndexR13 > EMTC_MAX_PRACH_CONFIG_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->prachConfigIndexR13] should be less than"
            " or equal to EMTC_MAX_PRACH_CONFIG_INDEX. Incorrect value %u received.", p_PrachParametersCeR13->prachConfigIndexR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->prachFreqOffsetR13, p_src + *p_length_read, "prachFreqOffsetR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->prachFreqOffsetR13 > EMTC_MAX_PRACH_FREQ_OFFSET))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->prachFreqOffsetR13] should be less than"
            " or equal to EMTC_MAX_PRACH_FREQ_OFFSET. Incorrect value %u received.", p_PrachParametersCeR13->prachFreqOffsetR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->numRepetitionPerPreambleAttemptR13, p_src + *p_length_read, "numRepetitionPerPreambleAttemptR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->numRepetitionPerPreambleAttemptR13 > EMTC_NUM_REPETITION_PER_PREAMBLE_ATTEMPT_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->numRepetitionPerPreambleAttemptR13] should be less than"
            " or equal to EMTC_NUM_REPETITION_PER_PREAMBLE_ATTEMPT_MAX. Incorrect value %u received.", p_PrachParametersCeR13->numRepetitionPerPreambleAttemptR13);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_MpdcchNarrowbandsToMonitorR13(
        &p_PrachParametersCeR13->mpdcchNarrowbandsToMonitor,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->mpdcchNumRepetitionRaR13, p_src + *p_length_read, "mpdcchNumRepetitionRaR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->mpdcchNumRepetitionRaR13 > EMTC_MPDCCH_NUM_REPETITION_RA_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->mpdcchNumRepetitionRaR13] should be less than"
            " or equal to EMTC_MPDCCH_NUM_REPETITION_RA_MAX. Incorrect value %u received.", p_PrachParametersCeR13->mpdcchNumRepetitionRaR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->prachHoppingConfigR13, p_src + *p_length_read, "prachHoppingConfigR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->prachHoppingConfigR13 > EMTC_PRACH_HOPPING_CONFIG_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->prachHoppingConfigR13] should be less than"
            " or equal to EMTC_PRACH_HOPPING_CONFIG_MAX. Incorrect value %u received.", p_PrachParametersCeR13->prachHoppingConfigR13);
        return RRC_FAILURE;
    }

    if (p_PrachParametersCeR13->bitmask & RRC_PRACH_STARTING_SF_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->prachStartingSubframeR13, p_src + *p_length_read, "prachStartingSubframeR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->prachStartingSubframeR13 > EMTC_PRACH_STARTING_SF_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->prachStartingSubframeR13] should be less than"
            " or equal to EMTC_PRACH_STARTING_SF_MAX. Incorrect value %u received.", p_PrachParametersCeR13->prachStartingSubframeR13);
        return RRC_FAILURE;
    }
    }

    if (p_PrachParametersCeR13->bitmask & RRC_MAX_NUM_PREAMBLE_ATTEMPT_CE_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersCeR13->maxNumPreambleAttemptCeR13, p_src + *p_length_read, "maxNumPreambleAttemptCeR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachParametersCeR13->maxNumPreambleAttemptCeR13 > EMTC_MAX_NUM_PREAMBLE_ATTEMPT_CE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersCeR13->maxNumPreambleAttemptCeR13] should be less than"
            " or equal to EMTC_MAX_NUM_PREAMBLE_ATTEMPT_CE_MAX. Incorrect value %u received.", p_PrachParametersCeR13->maxNumPreambleAttemptCeR13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PrachParametersListCeR13
(
    PrachParametersListCeR13_t *p_PrachParametersListCeR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_PrachParametersListCeR13, 0, sizeof(PrachParametersListCeR13_t));

    /* This function parses PrachParametersListCeR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachParametersListCeR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_PrachParametersListCeR13->count < 1) || (p_PrachParametersListCeR13->count > EMTC_MAX_CE_LEVEL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachParametersListCeR13->count] should be in range "
            "1 to EMTC_MAX_CE_LEVEL. Incorrect value %u received.", p_PrachParametersListCeR13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_PrachParametersListCeR13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_PrachParametersCeR13(
                &p_PrachParametersListCeR13->prachParametersCeR13[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RsrpThresholdsPrachInfoListR13
(
    RsrpThresholdsPrachInfoListR13_t *p_RsrpThresholdsPrachInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RsrpThresholdsPrachInfoListR13, 0, sizeof(RsrpThresholdsPrachInfoListR13_t));

    /* This function parses RsrpThresholdsPrachInfoListR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RsrpThresholdsPrachInfoListR13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_RsrpThresholdsPrachInfoListR13->count < 1) || (p_RsrpThresholdsPrachInfoListR13->count > EMTC_MAX_RSRP_LIST_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RsrpThresholdsPrachInfoListR13->count] should be in range "
            "1 to EMTC_MAX_RSRP_LIST_SIZE. Incorrect value %u received.", p_RsrpThresholdsPrachInfoListR13->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_RsrpThresholdsPrachInfoListR13->count * sizeof(p_RsrpThresholdsPrachInfoListR13->rsrpRange[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_RsrpThresholdsPrachInfoListR13->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_RsrpThresholdsPrachInfoListR13->rsrpRange[loop], (void*)(p_src + *p_length_read), "rsrpRange[]");
            if (p_RsrpThresholdsPrachInfoListR13->rsrpRange[loop] > EMTC_MAX_RSRP_RANGE)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_RsrpThresholdsPrachInfoListR13->rsrpRange[%u] should be less"
                    " than or equal to EMTC_MAX_RSRP_RANGE. "
                    "Incorrect value %d received.", loop, p_RsrpThresholdsPrachInfoListR13->rsrpRange[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PrachConfigV1310
(
    PrachConfigV1310_t *p_PrachConfigV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_PrachConfigV1310, 0, sizeof(PrachConfigV1310_t));

    /* This function parses PrachConfigV1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachConfigV1310->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_PrachParametersListCeR13(
        &p_PrachConfigV1310->prachParametersListCe,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_PrachConfigV1310->bitmask & RRC_RSRP_THRESHOLD_PRACH_INFO_LIST_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RsrpThresholdsPrachInfoListR13(
        &p_PrachConfigV1310->rsrpThresholdsPrachInfoList,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_PrachConfigV1310->bitmask & RRC_MPDCCH_START_SF_CSS_RA_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PrachConfigV1310->mpdcchStartSfCssRaFdd, p_src + *p_length_read, "mpdcchStartSfCssRaFdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PrachConfigV1310->mpdcchStartSfCssRaFdd > EMTC_MPDCCH_START_SF_CSS_RA_FDD_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PrachConfigV1310->mpdcchStartSfCssRaFdd] should be less than"
            " or equal to EMTC_MPDCCH_START_SF_CSS_RA_FDD_MAX. Incorrect value %u received.", p_PrachConfigV1310->mpdcchStartSfCssRaFdd);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcN1PucchAnInfoListR13
(
    RrcN1PucchAnInfoListR13_t *p_RrcN1PucchAnInfoListR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RrcN1PucchAnInfoListR13, 0, sizeof(RrcN1PucchAnInfoListR13_t));

    /* This function parses RrcN1PucchAnInfoListR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcN1PucchAnInfoListR13->numCeLevels, p_src + *p_length_read, "numCeLevels");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcN1PucchAnInfoListR13->numCeLevels > EMTC_MAX_CE_LEVEL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcN1PucchAnInfoListR13->numCeLevels] should be less than"
            " or equal to EMTC_MAX_CE_LEVEL. Incorrect value %u received.", p_RrcN1PucchAnInfoListR13->numCeLevels);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_RrcN1PucchAnInfoListR13->numCeLevels * sizeof(p_RrcN1PucchAnInfoListR13->n1PucchAnInfo[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_RrcN1PucchAnInfoListR13->numCeLevels; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_RrcN1PucchAnInfoListR13->n1PucchAnInfo[loop], (void*)(p_src + *p_length_read), "n1PucchAnInfo[]");
            if (p_RrcN1PucchAnInfoListR13->n1PucchAnInfo[loop] > EMTC_MAX_N1_PUCCH_AN)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_RrcN1PucchAnInfoListR13->n1PucchAnInfo[%u] should be less"
                    " than or equal to EMTC_MAX_N1_PUCCH_AN. "
                    "Incorrect value %d received.", loop, p_RrcN1PucchAnInfoListR13->n1PucchAnInfo[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_PucchConfigCommonV1310
(
    PucchConfigCommonV1310_t *p_PucchConfigCommonV1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_PucchConfigCommonV1310, 0, sizeof(PucchConfigCommonV1310_t));

    /* This function parses PucchConfigCommonV1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PucchConfigCommonV1310->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (p_PucchConfigCommonV1310->bitmask & RRC_N1_PUUCH_AN_INFO_LIST_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcN1PucchAnInfoListR13(
        &p_PucchConfigCommonV1310->n1PucchAnInfoList,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_PucchConfigCommonV1310->bitmask & RRC_PUCCH_NUM_REPETITION_CE_MSG4_LEVEL0_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level0, p_src + *p_length_read, "pucchNumRepetitionCeMsg4Level0");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level0 > EMTC_PUCCH_NUM_REPETITION_CE_MSG4_L0_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level0] should be less than"
            " or equal to EMTC_PUCCH_NUM_REPETITION_CE_MSG4_L0_MAX. Incorrect value %u received.", p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level0);
        return RRC_FAILURE;
    }
    }

    if (p_PucchConfigCommonV1310->bitmask & RRC_PUCCH_NUM_REPETITION_CE_MSG4_LEVEL1_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level1, p_src + *p_length_read, "pucchNumRepetitionCeMsg4Level1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level1 > EMTC_PUCCH_NUM_REPETITION_CE_MSG4_L1_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level1] should be less than"
            " or equal to EMTC_PUCCH_NUM_REPETITION_CE_MSG4_L1_MAX. Incorrect value %u received.", p_PucchConfigCommonV1310->pucchNumRepetitionCeMsg4Level1);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_radio_resource_config_common_sib
(
    radio_resource_config_common_sib_t *p_radio_resource_config_common_sib,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_radio_resource_config_common_sib, 0, sizeof(radio_resource_config_common_sib_t));

    /* This function parses radio_resource_config_common_sib */

    if (RRC_FAILURE == rrc_il_parse_rach_config_common(
        &p_radio_resource_config_common_sib->rach_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_bcch_config(
        &p_radio_resource_config_common_sib->bcch_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_pcch_config(
        &p_radio_resource_config_common_sib->pcch_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_prach_config_sib(
        &p_radio_resource_config_common_sib->prach_config_sib,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_radio_resource_config_common_sib->ul_cyc_prefix_len, p_src + *p_length_read, "ul_cyc_prefix_len");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_radio_resource_config_common_sib->ul_cyc_prefix_len > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_radio_resource_config_common_sib->ul_cyc_prefix_len] should be less than"
            " or equal to 1. Incorrect value %u received.", p_radio_resource_config_common_sib->ul_cyc_prefix_len);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_pdsch_config_common(
        &p_radio_resource_config_common_sib->pdsch_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_pusch_config_common(
        &p_radio_resource_config_common_sib->pusch_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_pucch_config_common(
        &p_radio_resource_config_common_sib->pucch_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_sounding_rs_ul_config_common(
        &p_radio_resource_config_common_sib->sounding_rs_ul_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_uplink_power_control_common(
        &p_radio_resource_config_common_sib->uplink_power_control_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_radio_resource_config_common_sib->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_CONFIG_COMMON_SIB_POWER_CONTROL_CMN_V1020)
    {

    if (RRC_FAILURE == rrc_il_parse_uplink_power_control_common_v1020(
        &p_radio_resource_config_common_sib->uplink_power_control_common_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_PCCH_CONFIG_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_PcchConfigV1310(
        &p_radio_resource_config_common_sib->pcchConfigV1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_PDSCH_CONFIG_COMMON_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_PdschConfigCommonV1310(
        &p_radio_resource_config_common_sib->pdschConfigV1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_PUSCH_CONFIG_COMMON_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_PuschConfigCommonV1310(
        &p_radio_resource_config_common_sib->puschConfigCommonV1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_PRACH_CONFIG_SIB_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_PrachConfigV1310(
        &p_radio_resource_config_common_sib->prachConfigV1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_common_sib->presence_bitmask & RRC_PUCCH_CONFIG_COMMON_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_PucchConfigCommonV1310(
        &p_radio_resource_config_common_sib->pucchConfigCommonV1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_timers_and_constants
(
    ue_timers_and_constants_t *p_ue_timers_and_constants,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ue_timers_and_constants, 0, sizeof(ue_timers_and_constants_t));

    /* This function parses ue_timers_and_constants */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_300, p_src + *p_length_read, "timer_300");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_300 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_300] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ue_timers_and_constants->timer_300);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_301, p_src + *p_length_read, "timer_301");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_301 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_301] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ue_timers_and_constants->timer_301);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_310, p_src + *p_length_read, "timer_310");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_310 > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_310] should be less than"
            " or equal to 6. Incorrect value %u received.", p_ue_timers_and_constants->timer_310);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_n310, p_src + *p_length_read, "timer_n310");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_n310 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_n310] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ue_timers_and_constants->timer_n310);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_311, p_src + *p_length_read, "timer_311");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_311 > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_311] should be less than"
            " or equal to 6. Incorrect value %u received.", p_ue_timers_and_constants->timer_311);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_timers_and_constants->timer_n311, p_src + *p_length_read, "timer_n311");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_timers_and_constants->timer_n311 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_timers_and_constants->timer_n311] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ue_timers_and_constants->timer_n311);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_freq_info
(
    freq_info_t *p_freq_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_freq_info, 0, sizeof(freq_info_t));

    /* This function parses freq_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_freq_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_freq_info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_freq_info->ul_carrier_freq, p_src + *p_length_read, "ul_carrier_freq");
    *p_length_read += sizeof(U16);
    }

    if (p_freq_info->presence_bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_freq_info->ul_bandwidth, p_src + *p_length_read, "ul_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_freq_info->ul_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_freq_info->ul_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_freq_info->ul_bandwidth);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_freq_info->add_spectrum_emission, p_src + *p_length_read, "add_spectrum_emission");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_freq_info->add_spectrum_emission < 1) || (p_freq_info->add_spectrum_emission > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_freq_info->add_spectrum_emission] should be in range "
            "1 to 32. Incorrect value %u received.", p_freq_info->add_spectrum_emission);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_subframe_allocation
(
    subframe_allocation_t *p_subframe_allocation,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_subframe_allocation, 0, sizeof(subframe_allocation_t));

    /* This function parses subframe_allocation */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_subframe_allocation->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_subframe_allocation->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(p_subframe_allocation->one_frame) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_subframe_allocation->one_frame); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_subframe_allocation->one_frame[loop], (void*)(p_src + *p_length_read), "one_frame[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_subframe_allocation->presence_bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(p_subframe_allocation->four_frames) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_subframe_allocation->four_frames); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_subframe_allocation->four_frames[loop], (void*)(p_src + *p_length_read), "four_frames[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mbsfn_subframe_config
(
    mbsfn_subframe_config_t *p_mbsfn_subframe_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mbsfn_subframe_config, 0, sizeof(mbsfn_subframe_config_t));

    /* This function parses mbsfn_subframe_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mbsfn_subframe_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbsfn_subframe_config->radio_frame_alloc_period, p_src + *p_length_read, "radio_frame_alloc_period");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbsfn_subframe_config->radio_frame_alloc_period > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbsfn_subframe_config->radio_frame_alloc_period] should be less than"
            " or equal to 5. Incorrect value %u received.", p_mbsfn_subframe_config->radio_frame_alloc_period);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbsfn_subframe_config->radio_frame_alloc_offset, p_src + *p_length_read, "radio_frame_alloc_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbsfn_subframe_config->radio_frame_alloc_offset > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbsfn_subframe_config->radio_frame_alloc_offset] should be less than"
            " or equal to 7. Incorrect value %u received.", p_mbsfn_subframe_config->radio_frame_alloc_offset);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_subframe_allocation(
        &p_mbsfn_subframe_config->subframe_allocation,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_mbsfn_subframe_config->bitmask & SYNC_STRATUM_ID_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbsfn_subframe_config->sync_stratum_id, p_src + *p_length_read, "sync_stratum_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbsfn_subframe_config->sync_stratum_id > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbsfn_subframe_config->sync_stratum_id] should be less than"
            " or equal to 8. Incorrect value %u received.", p_mbsfn_subframe_config->sync_stratum_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mbsfn_subframe_config_list
(
    mbsfn_subframe_config_list_t *p_mbsfn_subframe_config_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mbsfn_subframe_config_list, 0, sizeof(mbsfn_subframe_config_list_t));

    /* This function parses mbsfn_subframe_config_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbsfn_subframe_config_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbsfn_subframe_config_list->count > MAX_MBSFN_SUBFRAME_CONFIG))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbsfn_subframe_config_list->count] should be less than"
            " or equal to MAX_MBSFN_SUBFRAME_CONFIG. Incorrect value %u received.", p_mbsfn_subframe_config_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_mbsfn_subframe_config_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_mbsfn_subframe_config(
                &p_mbsfn_subframe_config_list->mbsfn_subframe_config[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_2_multi_band_info_list
(
    sib_2_multi_band_info_list_t *p_sib_2_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib_2_multi_band_info_list, 0, sizeof(sib_2_multi_band_info_list_t));

    /* This function parses sib_2_multi_band_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_2_multi_band_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_sib_2_multi_band_info_list->count < 1) || (p_sib_2_multi_band_info_list->count > MAX_MULTI_BANDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_2_multi_band_info_list->count] should be in range "
            "1 to MAX_MULTI_BANDS. Incorrect value %u received.", p_sib_2_multi_band_info_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_sib_2_multi_band_info_list->count * sizeof(p_sib_2_multi_band_info_list->add_spectrum_emission[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_sib_2_multi_band_info_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sib_2_multi_band_info_list->add_spectrum_emission[loop], (void*)(p_src + *p_length_read), "add_spectrum_emission[]");
            if ((p_sib_2_multi_band_info_list->add_spectrum_emission[loop] < 1) || (p_sib_2_multi_band_info_list->add_spectrum_emission[loop] > 32))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_sib_2_multi_band_info_list->add_spectrum_emission[%u] should be in "
                    "range 1 to 32. "
                    "Incorrect value %d received.", loop, p_sib_2_multi_band_info_list->add_spectrum_emission[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_2_v8h0_ies
(
    sib_type_2_v8h0_ies_t *p_sib_type_2_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_2_v8h0_ies, 0, sizeof(sib_type_2_v8h0_ies_t));

    /* This function parses sib_type_2_v8h0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_2_v8h0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_2_v8h0_ies->bitmask & SIB_2_MULTI_BAND_INFO_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_2_multi_band_info_list(
        &p_sib_type_2_v8h0_ies->multi_band_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_2_Info
(
    sib_type_2_Info_t *p_sib_type_2_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_2_Info, 0, sizeof(sib_type_2_Info_t));

    /* This function parses sib_type_2_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_2_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_2_Info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_access_barring_info(
        &p_sib_type_2_Info->access_barring_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_radio_resource_config_common_sib(
        &p_sib_type_2_Info->radio_resource_config_common_sib,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_ue_timers_and_constants(
        &p_sib_type_2_Info->ue_timers_and_constants,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_freq_info(
        &p_sib_type_2_Info->freq_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_sib_type_2_Info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_mbsfn_subframe_config_list(
        &p_sib_type_2_Info->mbsfn_subframe_config_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_2_Info->time_align_timer, p_src + *p_length_read, "time_align_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_2_Info->time_align_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_2_Info->time_align_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_sib_type_2_Info->time_align_timer);
        return RRC_FAILURE;
    }

    if (p_sib_type_2_Info->presence_bitmask & 4)
    {

    if (RRC_FAILURE == rrc_il_parse_access_class_barring_Info(
        &p_sib_type_2_Info->ssac_barring_for_mmtel_voice_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_2_Info->presence_bitmask & 8)
    {

    if (RRC_FAILURE == rrc_il_parse_access_class_barring_Info(
        &p_sib_type_2_Info->ssac_barring_for_mmtel_video_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_2_Info->presence_bitmask & 16)
    {

    if (RRC_FAILURE == rrc_il_parse_access_class_barring_Info(
        &p_sib_type_2_Info->ac_barring_for_csfb_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_2_Info->presence_bitmask & 32)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_2_v8h0_ies(
        &p_sib_type_2_Info->sib_type_2_v8h0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mobility_state_params
(
    mobility_state_params_t *p_mobility_state_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_mobility_state_params, 0, sizeof(mobility_state_params_t));

    /* This function parses mobility_state_params */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_params->t_evaluation, p_src + *p_length_read, "t_evaluation");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_state_params->t_evaluation > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_params->t_evaluation] should be less than"
            " or equal to 4. Incorrect value %u received.", p_mobility_state_params->t_evaluation);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_params->t_hyst_normal, p_src + *p_length_read, "t_hyst_normal");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_state_params->t_hyst_normal > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_params->t_hyst_normal] should be less than"
            " or equal to 4. Incorrect value %u received.", p_mobility_state_params->t_hyst_normal);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_params->n_cell_change_medium, p_src + *p_length_read, "n_cell_change_medium");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_mobility_state_params->n_cell_change_medium < 1) || (p_mobility_state_params->n_cell_change_medium > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_params->n_cell_change_medium] should be in range "
            "1 to 16. Incorrect value %u received.", p_mobility_state_params->n_cell_change_medium);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_params->n_cell_change_high, p_src + *p_length_read, "n_cell_change_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_mobility_state_params->n_cell_change_high < 1) || (p_mobility_state_params->n_cell_change_high > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_params->n_cell_change_high] should be in range "
            "1 to 16. Incorrect value %u received.", p_mobility_state_params->n_cell_change_high);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_speed_depend_scaling_param_hyst
(
    speed_depend_scaling_param_hyst_t *p_speed_depend_scaling_param_hyst,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_speed_depend_scaling_param_hyst, 0, sizeof(speed_depend_scaling_param_hyst_t));

    /* This function parses speed_depend_scaling_param_hyst */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_speed_depend_scaling_param_hyst->q_hyst_sf_medium, p_src + *p_length_read, "q_hyst_sf_medium");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_speed_depend_scaling_param_hyst->q_hyst_sf_medium > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_speed_depend_scaling_param_hyst->q_hyst_sf_medium] should be less than"
            " or equal to 6. Incorrect value %u received.", p_speed_depend_scaling_param_hyst->q_hyst_sf_medium);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_speed_depend_scaling_param_hyst->q_hyst_sf_high, p_src + *p_length_read, "q_hyst_sf_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_speed_depend_scaling_param_hyst->q_hyst_sf_high > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_speed_depend_scaling_param_hyst->q_hyst_sf_high] should be less than"
            " or equal to 6. Incorrect value %u received.", p_speed_depend_scaling_param_hyst->q_hyst_sf_high);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_speed_depend_reselect
(
    speed_depend_reselect_t *p_speed_depend_reselect,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_speed_depend_reselect, 0, sizeof(speed_depend_reselect_t));

    /* This function parses speed_depend_reselect */

    if (RRC_FAILURE == rrc_il_parse_mobility_state_params(
        &p_speed_depend_reselect->mobility_state_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_speed_depend_scaling_param_hyst(
        &p_speed_depend_reselect->speed_depend_scaling_param_hyst,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_reselect_info_comm
(
    cell_reselect_info_comm_t *p_cell_reselect_info_comm,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_reselect_info_comm, 0, sizeof(cell_reselect_info_comm_t));

    /* This function parses cell_reselect_info_comm */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_reselect_info_comm->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_reselect_info_comm->q_hyst, p_src + *p_length_read, "q_hyst");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_reselect_info_comm->q_hyst > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_reselect_info_comm->q_hyst] should be less than"
            " or equal to 15. Incorrect value %u received.", p_cell_reselect_info_comm->q_hyst);
        return RRC_FAILURE;
    }

    if (p_cell_reselect_info_comm->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_depend_reselect(
        &p_cell_reselect_info_comm->speed_depend_reselect,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_reselect_serv_freq_info
(
    cell_reselect_serv_freq_info_t *p_cell_reselect_serv_freq_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cell_reselect_serv_freq_info, 0, sizeof(cell_reselect_serv_freq_info_t));

    /* This function parses cell_reselect_serv_freq_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_reselect_serv_freq_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_cell_reselect_serv_freq_info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_reselect_serv_freq_info->s_non_intra_search, p_src + *p_length_read, "s_non_intra_search");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_reselect_serv_freq_info->s_non_intra_search > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_reselect_serv_freq_info->s_non_intra_search] should be less than"
            " or equal to 31. Incorrect value %u received.", p_cell_reselect_serv_freq_info->s_non_intra_search);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_reselect_serv_freq_info->thresh_serving_low, p_src + *p_length_read, "thresh_serving_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_reselect_serv_freq_info->thresh_serving_low > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_reselect_serv_freq_info->thresh_serving_low] should be less than"
            " or equal to 31. Incorrect value %u received.", p_cell_reselect_serv_freq_info->thresh_serving_low);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_reselect_serv_freq_info->cell_reselect_priority, p_src + *p_length_read, "cell_reselect_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_reselect_serv_freq_info->cell_reselect_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_reselect_serv_freq_info->cell_reselect_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_cell_reselect_serv_freq_info->cell_reselect_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_speed_state_scale_factors
(
    speed_state_scale_factors_t *p_speed_state_scale_factors,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_speed_state_scale_factors, 0, sizeof(speed_state_scale_factors_t));

    /* This function parses speed_state_scale_factors */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_speed_state_scale_factors->sf_medium, p_src + *p_length_read, "sf_medium");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_speed_state_scale_factors->sf_medium > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_speed_state_scale_factors->sf_medium] should be less than"
            " or equal to 3. Incorrect value %u received.", p_speed_state_scale_factors->sf_medium);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_speed_state_scale_factors->sf_high, p_src + *p_length_read, "sf_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_speed_state_scale_factors->sf_high > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_speed_state_scale_factors->sf_high] should be less than"
            " or equal to 3. Incorrect value %u received.", p_speed_state_scale_factors->sf_high);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_intra_freq_cell_reselect_info
(
    intra_freq_cell_reselect_info_t *p_intra_freq_cell_reselect_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_intra_freq_cell_reselect_info, 0, sizeof(intra_freq_cell_reselect_info_t));

    /* This function parses intra_freq_cell_reselect_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_intra_freq_cell_reselect_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_intra_freq_cell_reselect_info->q_rx_lev_min, p_src + *p_length_read, "q_rx_lev_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_intra_freq_cell_reselect_info->q_rx_lev_min < -70) || (p_intra_freq_cell_reselect_info->q_rx_lev_min > -22))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->q_rx_lev_min] should be in range "
            "-70 to -22. Incorrect value %d received.", p_intra_freq_cell_reselect_info->q_rx_lev_min);
        return RRC_FAILURE;
    }

    if (p_intra_freq_cell_reselect_info->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_intra_freq_cell_reselect_info->p_max, p_src + *p_length_read, "p_max");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_intra_freq_cell_reselect_info->p_max < -30) || (p_intra_freq_cell_reselect_info->p_max > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->p_max] should be in range "
            "-30 to 33. Incorrect value %d received.", p_intra_freq_cell_reselect_info->p_max);
        return RRC_FAILURE;
    }
    }

    if (p_intra_freq_cell_reselect_info->presence_bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_freq_cell_reselect_info->s_intra_search, p_src + *p_length_read, "s_intra_search");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_freq_cell_reselect_info->s_intra_search > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->s_intra_search] should be less than"
            " or equal to 31. Incorrect value %u received.", p_intra_freq_cell_reselect_info->s_intra_search);
        return RRC_FAILURE;
    }
    }

    if (p_intra_freq_cell_reselect_info->presence_bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_freq_cell_reselect_info->measure_bw, p_src + *p_length_read, "measure_bw");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_freq_cell_reselect_info->measure_bw > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->measure_bw] should be less than"
            " or equal to 5. Incorrect value %u received.", p_intra_freq_cell_reselect_info->measure_bw);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_freq_cell_reselect_info->presence_antenna_port_1, p_src + *p_length_read, "presence_antenna_port_1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_freq_cell_reselect_info->presence_antenna_port_1 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->presence_antenna_port_1] should be less than"
            " or equal to 1. Incorrect value %u received.", p_intra_freq_cell_reselect_info->presence_antenna_port_1);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_freq_cell_reselect_info->neigh_cell_config, p_src + *p_length_read, "neigh_cell_config");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_freq_cell_reselect_info->t_reselec_eutra, p_src + *p_length_read, "t_reselec_eutra");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_freq_cell_reselect_info->t_reselec_eutra > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_freq_cell_reselect_info->t_reselec_eutra] should be less than"
            " or equal to 7. Incorrect value %u received.", p_intra_freq_cell_reselect_info->t_reselec_eutra);
        return RRC_FAILURE;
    }

    if (p_intra_freq_cell_reselect_info->presence_bitmask & 8)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_intra_freq_cell_reselect_info->t_reselect_eutra_sf,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib3_intra_search_v920
(
    sib3_intra_search_v920_t *p_sib3_intra_search_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib3_intra_search_v920, 0, sizeof(sib3_intra_search_v920_t));

    /* This function parses sib3_intra_search_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib3_intra_search_v920->s_intra_search_p_r9, p_src + *p_length_read, "s_intra_search_p_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib3_intra_search_v920->s_intra_search_p_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib3_intra_search_v920->s_intra_search_p_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib3_intra_search_v920->s_intra_search_p_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib3_intra_search_v920->s_intra_search_q_r9, p_src + *p_length_read, "s_intra_search_q_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib3_intra_search_v920->s_intra_search_q_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib3_intra_search_v920->s_intra_search_q_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib3_intra_search_v920->s_intra_search_q_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib3_non_intra_search_v920
(
    sib3_non_intra_search_v920_t *p_sib3_non_intra_search_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib3_non_intra_search_v920, 0, sizeof(sib3_non_intra_search_v920_t));

    /* This function parses sib3_non_intra_search_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib3_non_intra_search_v920->s_non_intra_search_p_r9, p_src + *p_length_read, "s_non_intra_search_p_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib3_non_intra_search_v920->s_non_intra_search_p_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib3_non_intra_search_v920->s_non_intra_search_p_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib3_non_intra_search_v920->s_non_intra_search_p_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib3_non_intra_search_v920->s_non_intra_search_q_r9, p_src + *p_length_read, "s_non_intra_search_q_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib3_non_intra_search_v920->s_non_intra_search_q_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib3_non_intra_search_v920->s_non_intra_search_q_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib3_non_intra_search_v920->s_non_intra_search_q_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_3_Info
(
    sib_type_3_Info_t *p_sib_type_3_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_3_Info, 0, sizeof(sib_type_3_Info_t));

    /* This function parses sib_type_3_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_3_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cell_reselect_info_comm(
        &p_sib_type_3_Info->timecell_reselect_info_comm,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_cell_reselect_serv_freq_info(
        &p_sib_type_3_Info->cell_reselect_serv_freq_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_intra_freq_cell_reselect_info(
        &p_sib_type_3_Info->intra_freq_cell_reselect_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_sib_type_3_Info->presence_bitmask & SIB_3_INTRA_SEARCH_V920_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib3_intra_search_v920(
        &p_sib_type_3_Info->sib3_intra_search_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_3_Info->presence_bitmask & SIB_3_NON_INTRA_SEARCH_V920_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib3_non_intra_search_v920(
        &p_sib_type_3_Info->sib3_non_intra_search_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_3_Info->presence_bitmask & SIB_3_Q_QUAL_MIN_R9_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_sib_type_3_Info->q_qual_min_r9, p_src + *p_length_read, "q_qual_min_r9");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_sib_type_3_Info->q_qual_min_r9 < -34) || (p_sib_type_3_Info->q_qual_min_r9 > -3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_3_Info->q_qual_min_r9] should be in range "
            "-34 to -3. Incorrect value %d received.", p_sib_type_3_Info->q_qual_min_r9);
        return RRC_FAILURE;
    }
    }

    if (p_sib_type_3_Info->presence_bitmask & SIB_3_THRESH_SERVING_LOW_Q_R9_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_3_Info->thresh_serving_low_q_r9, p_src + *p_length_read, "thresh_serving_low_q_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_3_Info->thresh_serving_low_q_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_3_Info->thresh_serving_low_q_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_sib_type_3_Info->thresh_serving_low_q_r9);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell
(
    neigh_cell_t *p_neigh_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_neigh_cell, 0, sizeof(neigh_cell_t));

    /* This function parses neigh_cell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_neigh_cell->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell->phys_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell->phys_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_neigh_cell->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell->q_offset_cell, p_src + *p_length_read, "q_offset_cell");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell->q_offset_cell > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell->q_offset_cell] should be less than"
            " or equal to 30. Incorrect value %u received.", p_neigh_cell->q_offset_cell);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_list
(
    neigh_cell_list_t *p_neigh_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_list, 0, sizeof(neigh_cell_list_t));

    /* This function parses neigh_cell_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell_list->count > MAX_CELL_INTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_list->count] should be less than"
            " or equal to MAX_CELL_INTRA. Incorrect value %u received.", p_neigh_cell_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_neigh_cell_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_neigh_cell(
                &p_neigh_cell_list->neigh_cell[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phy_cell_id_range
(
    phy_cell_id_range_t *p_phy_cell_id_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phy_cell_id_range, 0, sizeof(phy_cell_id_range_t));

    /* This function parses phy_cell_id_range */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_phy_cell_id_range->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_phy_cell_id_range->start, p_src + *p_length_read, "start");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_phy_cell_id_range->start > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phy_cell_id_range->start] should be less than"
            " or equal to 503. Incorrect value %u received.", p_phy_cell_id_range->start);
        return RRC_FAILURE;
    }

    if (p_phy_cell_id_range->presence_bitmask & PHY_CELL_ID_RANGE)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phy_cell_id_range->range, p_src + *p_length_read, "range");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phy_cell_id_range->range > 13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phy_cell_id_range->range] should be less than"
            " or equal to 13. Incorrect value %u received.", p_phy_cell_id_range->range);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_black_listed_cell_list
(
    black_listed_cell_list_t *p_black_listed_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_black_listed_cell_list, 0, sizeof(black_listed_cell_list_t));

    /* This function parses black_listed_cell_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_black_listed_cell_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_black_listed_cell_list->count > MAX_CELL_BLACK_LIST))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_listed_cell_list->count] should be less than"
            " or equal to MAX_CELL_BLACK_LIST. Incorrect value %u received.", p_black_listed_cell_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_black_listed_cell_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_phy_cell_id_range(
                &p_black_listed_cell_list->black_listed_cell[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_4_Info
(
    sib_type_4_Info_t *p_sib_type_4_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_4_Info, 0, sizeof(sib_type_4_Info_t));

    /* This function parses sib_type_4_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_4_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_4_Info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_list(
        &p_sib_type_4_Info->intra_freq_neigh_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_4_Info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_black_listed_cell_list(
        &p_sib_type_4_Info->intra_freq_black_listed_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_4_Info->presence_bitmask & 4)
    {

    if (RRC_FAILURE == rrc_il_parse_phy_cell_id_range(
        &p_sib_type_4_Info->csg_phy_cell_id_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_thresh_x_q_r9
(
    thresh_x_q_r9_t *p_thresh_x_q_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_thresh_x_q_r9, 0, sizeof(thresh_x_q_r9_t));

    /* This function parses thresh_x_q_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_thresh_x_q_r9->thresh_x_high_q_r9, p_src + *p_length_read, "thresh_x_high_q_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_thresh_x_q_r9->thresh_x_high_q_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_thresh_x_q_r9->thresh_x_high_q_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_thresh_x_q_r9->thresh_x_high_q_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_thresh_x_q_r9->thresh_x_low_q_r9, p_src + *p_length_read, "thresh_x_low_q_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_thresh_x_q_r9->thresh_x_low_q_r9 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_thresh_x_q_r9->thresh_x_low_q_r9] should be less than"
            " or equal to 31. Incorrect value %u received.", p_thresh_x_q_r9->thresh_x_low_q_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq
(
    inter_freq_carrier_freq_t *p_inter_freq_carrier_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_freq_carrier_freq, 0, sizeof(inter_freq_carrier_freq_t));

    /* This function parses inter_freq_carrier_freq */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_inter_freq_carrier_freq->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_inter_freq_carrier_freq->eutra_dl_carrier_freq, p_src + *p_length_read, "eutra_dl_carrier_freq");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_inter_freq_carrier_freq->qrx_lev_min, p_src + *p_length_read, "qrx_lev_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_freq_carrier_freq->qrx_lev_min < -70) || (p_inter_freq_carrier_freq->qrx_lev_min > -22))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->qrx_lev_min] should be in range "
            "-70 to -22. Incorrect value %d received.", p_inter_freq_carrier_freq->qrx_lev_min);
        return RRC_FAILURE;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_inter_freq_carrier_freq->p_max, p_src + *p_length_read, "p_max");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_freq_carrier_freq->p_max < -30) || (p_inter_freq_carrier_freq->p_max > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->p_max] should be in range "
            "-30 to 33. Incorrect value %d received.", p_inter_freq_carrier_freq->p_max);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->t_reselection_eutran, p_src + *p_length_read, "t_reselection_eutran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->t_reselection_eutran > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->t_reselection_eutran] should be less than"
            " or equal to 7. Incorrect value %u received.", p_inter_freq_carrier_freq->t_reselection_eutran);
        return RRC_FAILURE;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_inter_freq_carrier_freq->speed_depend_scal_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->thresh_x_high, p_src + *p_length_read, "thresh_x_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->thresh_x_high > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->thresh_x_high] should be less than"
            " or equal to 31. Incorrect value %u received.", p_inter_freq_carrier_freq->thresh_x_high);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->thresh_x_low, p_src + *p_length_read, "thresh_x_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->thresh_x_low > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->thresh_x_low] should be less than"
            " or equal to 31. Incorrect value %u received.", p_inter_freq_carrier_freq->thresh_x_low);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->measurement_bandwidth, p_src + *p_length_read, "measurement_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->measurement_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->measurement_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_inter_freq_carrier_freq->measurement_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->presence_antenna_port_1, p_src + *p_length_read, "presence_antenna_port_1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->presence_antenna_port_1 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->presence_antenna_port_1] should be less than"
            " or equal to 1. Incorrect value %u received.", p_inter_freq_carrier_freq->presence_antenna_port_1);
        return RRC_FAILURE;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->cell_reselect_priority, p_src + *p_length_read, "cell_reselect_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->cell_reselect_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->cell_reselect_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_inter_freq_carrier_freq->cell_reselect_priority);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->neigh_cell_config, p_src + *p_length_read, "neigh_cell_config");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq->q_offset_freq, p_src + *p_length_read, "q_offset_freq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq->q_offset_freq > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->q_offset_freq] should be less than"
            " or equal to 30. Incorrect value %u received.", p_inter_freq_carrier_freq->q_offset_freq);
        return RRC_FAILURE;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 8)
    {

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_list(
        &p_inter_freq_carrier_freq->inter_freq_neigh_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 16)
    {

    if (RRC_FAILURE == rrc_il_parse_black_listed_cell_list(
        &p_inter_freq_carrier_freq->inter_freq_black_listed_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 32)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_inter_freq_carrier_freq->q_qual_min_r9, p_src + *p_length_read, "q_qual_min_r9");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_freq_carrier_freq->q_qual_min_r9 < -34) || (p_inter_freq_carrier_freq->q_qual_min_r9 > -3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq->q_qual_min_r9] should be in range "
            "-34 to -3. Incorrect value %d received.", p_inter_freq_carrier_freq->q_qual_min_r9);
        return RRC_FAILURE;
    }
    }

    if (p_inter_freq_carrier_freq->presence_bitmask & 64)
    {

    if (RRC_FAILURE == rrc_il_parse_thresh_x_q_r9(
        &p_inter_freq_carrier_freq->thresh_x_q_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_list_list
(
    inter_freq_carrier_freq_list_list_t *p_inter_freq_carrier_freq_list_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_freq_carrier_freq_list_list, 0, sizeof(inter_freq_carrier_freq_list_list_t));

    /* This function parses inter_freq_carrier_freq_list_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq_list_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_carrier_freq_list_list->count > MAX_EUTRA_CARRIER_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq_list_list->count] should be less than"
            " or equal to MAX_EUTRA_CARRIER_FREQ. Incorrect value %u received.", p_inter_freq_carrier_freq_list_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_inter_freq_carrier_freq_list_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_inter_freq_carrier_freq(
                &p_inter_freq_carrier_freq_list_list->inter_freq_carrier_freq_list[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_info_v8h0
(
    inter_freq_carrier_freq_info_v8h0_t *p_inter_freq_carrier_freq_info_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_freq_carrier_freq_info_v8h0, 0, sizeof(inter_freq_carrier_freq_info_v8h0_t));

    /* This function parses inter_freq_carrier_freq_info_v8h0 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_inter_freq_carrier_freq_info_v8h0->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_inter_freq_carrier_freq_info_v8h0->bitmask & INTER_FREQ_CARRIER_FREQ_v8h0_MULTI_BAND_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_multi_band_info_list(
        &p_inter_freq_carrier_freq_info_v8h0->multi_band_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_carrier_freq_list_v8h0
(
    inter_freq_carrier_freq_list_v8h0_t *p_inter_freq_carrier_freq_list_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_freq_carrier_freq_list_v8h0, 0, sizeof(inter_freq_carrier_freq_list_v8h0_t));

    /* This function parses inter_freq_carrier_freq_list_v8h0 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_carrier_freq_list_v8h0->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_freq_carrier_freq_list_v8h0->count < 1) || (p_inter_freq_carrier_freq_list_v8h0->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_carrier_freq_list_v8h0->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_inter_freq_carrier_freq_list_v8h0->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_inter_freq_carrier_freq_list_v8h0->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_inter_freq_carrier_freq_info_v8h0(
                &p_inter_freq_carrier_freq_list_v8h0->inter_freq_carrier_freq_info_v8h0[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_5_v8h0_ies
(
    sib_5_v8h0_ies_t *p_sib_5_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_5_v8h0_ies, 0, sizeof(sib_5_v8h0_ies_t));

    /* This function parses sib_5_v8h0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_5_v8h0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_5_v8h0_ies->bitmask & SIB_5_v8h0_INTER_FREQ_CARRIER_FREQ_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_inter_freq_carrier_freq_list_v8h0(
        &p_sib_5_v8h0_ies->inter_freq_carrier_freq_list_v8h0,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_5_Info
(
    sib_type_5_Info_t *p_sib_type_5_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_5_Info, 0, sizeof(sib_type_5_Info_t));

    /* This function parses sib_type_5_Info */

    if (RRC_FAILURE == rrc_il_parse_inter_freq_carrier_freq_list_list(
        &p_sib_type_5_Info->inter_freq_carrier_freq_list_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_5_Info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_5_Info->bitmask & SIB_TYPE_5_v8h0_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_5_v8h0_ies(
        &p_sib_type_5_Info->sib_5_v8h0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_utra_fdd
(
    carrier_freq_utra_fdd_t *p_carrier_freq_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_utra_fdd, 0, sizeof(carrier_freq_utra_fdd_t));

    /* This function parses carrier_freq_utra_fdd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_utra_fdd->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_utra_fdd->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_fdd->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_carrier_freq_utra_fdd->carrier_freq);
        return RRC_FAILURE;
    }

    if (p_carrier_freq_utra_fdd->presence_bitmask & CR_FREQ_UTRA_FDD_CELL_RESEL_PRI_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_fdd->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_fdd->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_carrier_freq_utra_fdd->cell_reselection_priority);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_fdd->thresh_x_high, p_src + *p_length_read, "thresh_x_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_fdd->thresh_x_high > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->thresh_x_high] should be less than"
            " or equal to 31. Incorrect value %u received.", p_carrier_freq_utra_fdd->thresh_x_high);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_fdd->thresh_x_low, p_src + *p_length_read, "thresh_x_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_fdd->thresh_x_low > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->thresh_x_low] should be less than"
            " or equal to 31. Incorrect value %u received.", p_carrier_freq_utra_fdd->thresh_x_low);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_carrier_freq_utra_fdd->q_rx_lev_min, p_src + *p_length_read, "q_rx_lev_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_utra_fdd->q_rx_lev_min < -60) || (p_carrier_freq_utra_fdd->q_rx_lev_min > -13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->q_rx_lev_min] should be in range "
            "-60 to -13. Incorrect value %d received.", p_carrier_freq_utra_fdd->q_rx_lev_min);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_carrier_freq_utra_fdd->p_max_utra, p_src + *p_length_read, "p_max_utra");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_utra_fdd->p_max_utra < -50) || (p_carrier_freq_utra_fdd->p_max_utra > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->p_max_utra] should be in range "
            "-50 to 33. Incorrect value %d received.", p_carrier_freq_utra_fdd->p_max_utra);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_carrier_freq_utra_fdd->q_qual_min, p_src + *p_length_read, "q_qual_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_utra_fdd->q_qual_min < -24) || (p_carrier_freq_utra_fdd->q_qual_min > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_fdd->q_qual_min] should be in range "
            "-24 to 0. Incorrect value %d received.", p_carrier_freq_utra_fdd->q_qual_min);
        return RRC_FAILURE;
    }

    if (p_carrier_freq_utra_fdd->presence_bitmask & CR_FREQ_UTRA_FDD_THRESH_X_Q_R9_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_thresh_x_q_r9(
        &p_carrier_freq_utra_fdd->thresh_x_q_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_fdd
(
    carrier_freq_list_utra_fdd_t *p_carrier_freq_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_list_utra_fdd, 0, sizeof(carrier_freq_list_utra_fdd_t));

    /* This function parses carrier_freq_list_utra_fdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_list_utra_fdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_list_utra_fdd->count < 1) || (p_carrier_freq_list_utra_fdd->count > MAX_UTRA_FDD_CARRIER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_list_utra_fdd->count] should be in range "
            "1 to MAX_UTRA_FDD_CARRIER. Incorrect value %u received.", p_carrier_freq_list_utra_fdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_carrier_freq_list_utra_fdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_carrier_freq_utra_fdd(
                &p_carrier_freq_list_utra_fdd->data[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_utra_tdd
(
    carrier_freq_utra_tdd_t *p_carrier_freq_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_utra_tdd, 0, sizeof(carrier_freq_utra_tdd_t));

    /* This function parses carrier_freq_utra_tdd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_utra_tdd->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_utra_tdd->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_tdd->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_carrier_freq_utra_tdd->carrier_freq);
        return RRC_FAILURE;
    }

    if (p_carrier_freq_utra_tdd->presence_bitmask & CR_FREQ_UTRA_TDD_CELL_RESEL_PRI_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_tdd->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_tdd->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_carrier_freq_utra_tdd->cell_reselection_priority);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_tdd->thresh_x_high, p_src + *p_length_read, "thresh_x_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_tdd->thresh_x_high > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->thresh_x_high] should be less than"
            " or equal to 31. Incorrect value %u received.", p_carrier_freq_utra_tdd->thresh_x_high);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_utra_tdd->thresh_x_low, p_src + *p_length_read, "thresh_x_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_utra_tdd->thresh_x_low > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->thresh_x_low] should be less than"
            " or equal to 31. Incorrect value %u received.", p_carrier_freq_utra_tdd->thresh_x_low);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_carrier_freq_utra_tdd->q_rx_lev_min, p_src + *p_length_read, "q_rx_lev_min");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_utra_tdd->q_rx_lev_min < -60) || (p_carrier_freq_utra_tdd->q_rx_lev_min > -13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->q_rx_lev_min] should be in range "
            "-60 to -13. Incorrect value %d received.", p_carrier_freq_utra_tdd->q_rx_lev_min);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_carrier_freq_utra_tdd->p_max_utra, p_src + *p_length_read, "p_max_utra");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_utra_tdd->p_max_utra < -50) || (p_carrier_freq_utra_tdd->p_max_utra > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_utra_tdd->p_max_utra] should be in range "
            "-50 to 33. Incorrect value %d received.", p_carrier_freq_utra_tdd->p_max_utra);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_tdd
(
    carrier_freq_list_utra_tdd_t *p_carrier_freq_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_list_utra_tdd, 0, sizeof(carrier_freq_list_utra_tdd_t));

    /* This function parses carrier_freq_list_utra_tdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_list_utra_tdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_list_utra_tdd->count < 1) || (p_carrier_freq_list_utra_tdd->count > MAX_UTRA_TDD_CARRIER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_list_utra_tdd->count] should be in range "
            "1 to MAX_UTRA_TDD_CARRIER. Incorrect value %u received.", p_carrier_freq_list_utra_tdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_carrier_freq_list_utra_tdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_carrier_freq_utra_tdd(
                &p_carrier_freq_list_utra_tdd->data[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_fdd_v8h0_multi_band_info_list
(
    utra_fdd_v8h0_multi_band_info_list_t *p_utra_fdd_v8h0_multi_band_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_fdd_v8h0_multi_band_info_list, 0, sizeof(utra_fdd_v8h0_multi_band_info_list_t));

    /* This function parses utra_fdd_v8h0_multi_band_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_fdd_v8h0_multi_band_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_utra_fdd_v8h0_multi_band_info_list->count < 1) || (p_utra_fdd_v8h0_multi_band_info_list->count > MAX_MULTI_BANDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_fdd_v8h0_multi_band_info_list->count] should be in range "
            "1 to MAX_MULTI_BANDS. Incorrect value %u received.", p_utra_fdd_v8h0_multi_band_info_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_fdd_v8h0_multi_band_info_list->count * sizeof(p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_fdd_v8h0_multi_band_info_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[loop], (void*)(p_src + *p_length_read), "freq_band_indicator_utra_fdd[]");
            if ((p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[loop] < 1) || (p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[loop] > 86))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[%u] should be in "
                    "range 1 to 86. "
                    "Incorrect value %d received.", loop, p_utra_fdd_v8h0_multi_band_info_list->freq_band_indicator_utra_fdd[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_info_utra_fdd_v8h0
(
    carrier_freq_info_utra_fdd_v8h0_t *p_carrier_freq_info_utra_fdd_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_info_utra_fdd_v8h0, 0, sizeof(carrier_freq_info_utra_fdd_v8h0_t));

    /* This function parses carrier_freq_info_utra_fdd_v8h0 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_info_utra_fdd_v8h0->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_carrier_freq_info_utra_fdd_v8h0->bitmask & CARRIER_FREQ_INFO_UTRA_FDD_v8h0_MULTI_BAND_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_fdd_v8h0_multi_band_info_list(
        &p_carrier_freq_info_utra_fdd_v8h0->multi_band_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_list_utra_fdd_v8h0
(
    carrier_freq_list_utra_fdd_v8h0_t *p_carrier_freq_list_utra_fdd_v8h0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_list_utra_fdd_v8h0, 0, sizeof(carrier_freq_list_utra_fdd_v8h0_t));

    /* This function parses carrier_freq_list_utra_fdd_v8h0 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_list_utra_fdd_v8h0->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_carrier_freq_list_utra_fdd_v8h0->count < 1) || (p_carrier_freq_list_utra_fdd_v8h0->count > MAX_UTRA_FDD_CARRIER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_list_utra_fdd_v8h0->count] should be in range "
            "1 to MAX_UTRA_FDD_CARRIER. Incorrect value %u received.", p_carrier_freq_list_utra_fdd_v8h0->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_carrier_freq_list_utra_fdd_v8h0->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_carrier_freq_info_utra_fdd_v8h0(
                &p_carrier_freq_list_utra_fdd_v8h0->carrier_freq_info_utra_fdd_v8h0[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_6_v8h0_ies
(
    sib_6_v8h0_ies_t *p_sib_6_v8h0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_6_v8h0_ies, 0, sizeof(sib_6_v8h0_ies_t));

    /* This function parses sib_6_v8h0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_6_v8h0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_6_v8h0_ies->bitmask & SIB_6_v8h0_CARRIER_FREQ_LIST_UTRA_FDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_list_utra_fdd_v8h0(
        &p_sib_6_v8h0_ies->carrier_freq_list_utra_fdd_v8h0,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_6_Info
(
    sib_type_6_Info_t *p_sib_type_6_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_6_Info, 0, sizeof(sib_type_6_Info_t));

    /* This function parses sib_type_6_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_6_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_6_Info->presence_bitmask & SIB_6_CARRIER_FREQ_LIST_UTRA_FDD_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_list_utra_fdd(
        &p_sib_type_6_Info->carrier_freq_list_utra_fdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_6_Info->presence_bitmask & SIB_6_CARRIER_FREQ_LIST_UTRA_TDD_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_list_utra_tdd(
        &p_sib_type_6_Info->carrier_freq_list_utra_tdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_6_Info->t_resel_utra, p_src + *p_length_read, "t_resel_utra");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_6_Info->t_resel_utra > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_6_Info->t_resel_utra] should be less than"
            " or equal to 7. Incorrect value %u received.", p_sib_type_6_Info->t_resel_utra);
        return RRC_FAILURE;
    }

    if (p_sib_type_6_Info->presence_bitmask & SIB_6_T_RESELECTION_UTRA_SF_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_sib_type_6_Info->t_resel_utra_sf,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_6_Info->presence_bitmask & SIB_6_LATE_NON_CRITICAL_EXTENSION_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_6_v8h0_ies(
        &p_sib_type_6_Info->sib_6_v8h0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_explicit_list_arfcns
(
    explicit_list_arfcns_t *p_explicit_list_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_explicit_list_arfcns, 0, sizeof(explicit_list_arfcns_t));

    /* This function parses explicit_list_arfcns */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_explicit_list_arfcns->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_explicit_list_arfcns->count > MAX_EXPL_ARFCNS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_explicit_list_arfcns->count] should be less than"
            " or equal to MAX_EXPL_ARFCNS. Incorrect value %u received.", p_explicit_list_arfcns->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_explicit_list_arfcns->count * sizeof(p_explicit_list_arfcns->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_explicit_list_arfcns->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_explicit_list_arfcns->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_equally_spaced_arfcns
(
    equally_spaced_arfcns_t *p_equally_spaced_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_equally_spaced_arfcns, 0, sizeof(equally_spaced_arfcns_t));

    /* This function parses equally_spaced_arfcns */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_equally_spaced_arfcns->arfcn_spacing, p_src + *p_length_read, "arfcn_spacing");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_equally_spaced_arfcns->arfcn_spacing < 1) || (p_equally_spaced_arfcns->arfcn_spacing > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_equally_spaced_arfcns->arfcn_spacing] should be in range "
            "1 to 8. Incorrect value %u received.", p_equally_spaced_arfcns->arfcn_spacing);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_equally_spaced_arfcns->num_of_following_arfcns, p_src + *p_length_read, "num_of_following_arfcns");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_equally_spaced_arfcns->num_of_following_arfcns > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_equally_spaced_arfcns->num_of_following_arfcns] should be less than"
            " or equal to 31. Incorrect value %u received.", p_equally_spaced_arfcns->num_of_following_arfcns);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_var_bitmap_of_arfcns
(
    var_bitmap_of_arfcns_t *p_var_bitmap_of_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_var_bitmap_of_arfcns, 0, sizeof(var_bitmap_of_arfcns_t));

    /* This function parses var_bitmap_of_arfcns */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_var_bitmap_of_arfcns->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_var_bitmap_of_arfcns->count < 1) || (p_var_bitmap_of_arfcns->count > MAX_VAR_BITMAP_OF_ARFCNS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_var_bitmap_of_arfcns->count] should be in range "
            "1 to MAX_VAR_BITMAP_OF_ARFCNS. Incorrect value %u received.", p_var_bitmap_of_arfcns->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_var_bitmap_of_arfcns->count * sizeof(p_var_bitmap_of_arfcns->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_var_bitmap_of_arfcns->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_var_bitmap_of_arfcns->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_geran_following_arfcns
(
    geran_following_arfcns_t *p_geran_following_arfcns,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_geran_following_arfcns, 0, sizeof(geran_following_arfcns_t));

    /* This function parses geran_following_arfcns */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_geran_following_arfcns->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_geran_following_arfcns->presence_bitmask & GERAN_EXPL_LIST_OF_ARFCNS_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_explicit_list_arfcns(
        &p_geran_following_arfcns->explicit_list_of_arfcns,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_geran_following_arfcns->presence_bitmask & GERAN_EQ_SPACED_ARFCNS_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_equally_spaced_arfcns(
        &p_geran_following_arfcns->equally_spaced_arfcns,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_geran_following_arfcns->presence_bitmask & GERAN_VAR_BITMAP_ARFCNS_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_var_bitmap_of_arfcns(
        &p_geran_following_arfcns->var_bitmap_of_arfcns,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freqs_geran
(
    carrier_freqs_geran_t *p_carrier_freqs_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freqs_geran, 0, sizeof(carrier_freqs_geran_t));

    /* This function parses carrier_freqs_geran */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freqs_geran->starting_arfcn, p_src + *p_length_read, "starting_arfcn");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freqs_geran->starting_arfcn > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freqs_geran->starting_arfcn] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_carrier_freqs_geran->starting_arfcn);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freqs_geran->band_indicator, p_src + *p_length_read, "band_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freqs_geran->band_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freqs_geran->band_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_carrier_freqs_geran->band_indicator);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_geran_following_arfcns(
        &p_carrier_freqs_geran->following_arfcns,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_crfi_geran_common_info
(
    crfi_geran_common_info_t *p_crfi_geran_common_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_crfi_geran_common_info, 0, sizeof(crfi_geran_common_info_t));

    /* This function parses crfi_geran_common_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_crfi_geran_common_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_crfi_geran_common_info->presence_bitmask & CRFI_GERAN_CELL_RESEL_PRI_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_crfi_geran_common_info->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_crfi_geran_common_info->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_crfi_geran_common_info->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_crfi_geran_common_info->cell_reselection_priority);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(p_crfi_geran_common_info->ncc_permitted) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_crfi_geran_common_info->ncc_permitted); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_crfi_geran_common_info->ncc_permitted[loop], (void*)(p_src + *p_length_read), "ncc_permitted[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_crfi_geran_common_info->q_rx_lev_min, p_src + *p_length_read, "q_rx_lev_min");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_crfi_geran_common_info->q_rx_lev_min > 45))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_crfi_geran_common_info->q_rx_lev_min] should be less than"
            " or equal to 45. Incorrect value %u received.", p_crfi_geran_common_info->q_rx_lev_min);
        return RRC_FAILURE;
    }

    if (p_crfi_geran_common_info->presence_bitmask & CRFI_GERAN_P_MAX_GERAN_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_crfi_geran_common_info->p_max_geran, p_src + *p_length_read, "p_max_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_crfi_geran_common_info->p_max_geran > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_crfi_geran_common_info->p_max_geran] should be less than"
            " or equal to 39. Incorrect value %u received.", p_crfi_geran_common_info->p_max_geran);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_crfi_geran_common_info->thresh_x_high, p_src + *p_length_read, "thresh_x_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_crfi_geran_common_info->thresh_x_high > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_crfi_geran_common_info->thresh_x_high] should be less than"
            " or equal to 31. Incorrect value %u received.", p_crfi_geran_common_info->thresh_x_high);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_crfi_geran_common_info->thresh_x_low, p_src + *p_length_read, "thresh_x_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_crfi_geran_common_info->thresh_x_low > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_crfi_geran_common_info->thresh_x_low] should be less than"
            " or equal to 31. Incorrect value %u received.", p_crfi_geran_common_info->thresh_x_low);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freqs_info_geran
(
    carrier_freqs_info_geran_t *p_carrier_freqs_info_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freqs_info_geran, 0, sizeof(carrier_freqs_info_geran_t));

    /* This function parses carrier_freqs_info_geran */

    if (RRC_FAILURE == rrc_il_parse_carrier_freqs_geran(
        &p_carrier_freqs_info_geran->carrier_freqs,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_crfi_geran_common_info(
        &p_carrier_freqs_info_geran->common_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freqs_info_list_geran
(
    carrier_freqs_info_list_geran_t *p_carrier_freqs_info_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_carrier_freqs_info_list_geran, 0, sizeof(carrier_freqs_info_list_geran_t));

    /* This function parses carrier_freqs_info_list_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freqs_info_list_geran->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freqs_info_list_geran->count > MAX_GNFG))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freqs_info_list_geran->count] should be less than"
            " or equal to MAX_GNFG. Incorrect value %u received.", p_carrier_freqs_info_list_geran->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_carrier_freqs_info_list_geran->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_carrier_freqs_info_geran(
                &p_carrier_freqs_info_list_geran->cr_freq_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_7_Info
(
    sib_type_7_Info_t *p_sib_type_7_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_7_Info, 0, sizeof(sib_type_7_Info_t));

    /* This function parses sib_type_7_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_7_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_7_Info->t_reselection_geran, p_src + *p_length_read, "t_reselection_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_7_Info->t_reselection_geran > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_7_Info->t_reselection_geran] should be less than"
            " or equal to 7. Incorrect value %u received.", p_sib_type_7_Info->t_reselection_geran);
        return RRC_FAILURE;
    }

    if (p_sib_type_7_Info->presence_bitmask & SIB_7_T_RESEL_GERAN_SF_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_sib_type_7_Info->t_reselect_geran_sf,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_7_Info->presence_bitmask & SIB_7_CR_FREQS_INFO_LST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freqs_info_list_geran(
        &p_sib_type_7_Info->carrier_freqs_info_lst,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sys_time_info_cdma2000
(
    sys_time_info_cdma2000_t *p_sys_time_info_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sys_time_info_cdma2000, 0, sizeof(sys_time_info_cdma2000_t));

    /* This function parses sys_time_info_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sys_time_info_cdma2000->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sys_time_info_cdma2000->cdma_eutra_sync, p_src + *p_length_read, "cdma_eutra_sync");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sys_time_info_cdma2000->cdma_eutra_sync > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sys_time_info_cdma2000->cdma_eutra_sync] should be less than"
            " or equal to 1. Incorrect value %u received.", p_sys_time_info_cdma2000->cdma_eutra_sync);
        return RRC_FAILURE;
    }

    if (p_sys_time_info_cdma2000->presence_bitmask & SYS_TIME_INFO_CDMA2000_SYNC_SYS_TIME_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(p_sys_time_info_cdma2000->sync_sys_time) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_sys_time_info_cdma2000->sync_sys_time); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sys_time_info_cdma2000->sync_sys_time[loop], (void*)(p_src + *p_length_read), "sync_sys_time[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_sys_time_info_cdma2000->presence_bitmask & SYS_TIME_INFO_CDMA2000_ASYNC_SYS_TIME_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(p_sys_time_info_cdma2000->async_sys_time) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_sys_time_info_cdma2000->async_sys_time); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sys_time_info_cdma2000->async_sys_time[loop], (void*)(p_src + *p_length_read), "async_sys_time[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_secondary_pre_reg_zone_id_list_hrpd
(
    secondary_pre_reg_zone_id_list_hrpd_t *p_secondary_pre_reg_zone_id_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_secondary_pre_reg_zone_id_list_hrpd, 0, sizeof(secondary_pre_reg_zone_id_list_hrpd_t));

    /* This function parses secondary_pre_reg_zone_id_list_hrpd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_secondary_pre_reg_zone_id_list_hrpd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_secondary_pre_reg_zone_id_list_hrpd->count < 1) || (p_secondary_pre_reg_zone_id_list_hrpd->count > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_secondary_pre_reg_zone_id_list_hrpd->count] should be in range "
            "1 to 2. Incorrect value %u received.", p_secondary_pre_reg_zone_id_list_hrpd->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_secondary_pre_reg_zone_id_list_hrpd->count * sizeof(p_secondary_pre_reg_zone_id_list_hrpd->pre_reg_zone_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_secondary_pre_reg_zone_id_list_hrpd->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_secondary_pre_reg_zone_id_list_hrpd->pre_reg_zone_id[loop], (void*)(p_src + *p_length_read), "pre_reg_zone_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pre_reg_info_hrpd
(
    pre_reg_info_hrpd_t *p_pre_reg_info_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pre_reg_info_hrpd, 0, sizeof(pre_reg_info_hrpd_t));

    /* This function parses pre_reg_info_hrpd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pre_reg_info_hrpd->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pre_reg_info_hrpd->pre_reg_allowed, p_src + *p_length_read, "pre_reg_allowed");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pre_reg_info_hrpd->pre_reg_allowed > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pre_reg_info_hrpd->pre_reg_allowed] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pre_reg_info_hrpd->pre_reg_allowed);
        return RRC_FAILURE;
    }

    if (p_pre_reg_info_hrpd->presence_bitmask & PRE_REG_INFO_HRPD_ZONE_ID_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pre_reg_info_hrpd->pre_reg_zone_id, p_src + *p_length_read, "pre_reg_zone_id");
    *p_length_read += sizeof(U8);
    }

    if (p_pre_reg_info_hrpd->presence_bitmask & PRE_REG_INFO_HRPD_SECONDARY_LST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_secondary_pre_reg_zone_id_list_hrpd(
        &p_pre_reg_info_hrpd->secondary_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_class_info_cdma2000
(
    band_class_info_cdma2000_t *p_band_class_info_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_band_class_info_cdma2000, 0, sizeof(band_class_info_cdma2000_t));

    /* This function parses band_class_info_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_class_info_cdma2000->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_class_info_cdma2000->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_class_info_cdma2000->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_class_info_cdma2000->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_band_class_info_cdma2000->band_class);
        return RRC_FAILURE;
    }

    if (p_band_class_info_cdma2000->presence_bitmask & BAND_CLASS_INFO_CDMA2000_CELL_RESELECT_PRI_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_class_info_cdma2000->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_class_info_cdma2000->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_class_info_cdma2000->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_band_class_info_cdma2000->cell_reselection_priority);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_class_info_cdma2000->thresh_x_high, p_src + *p_length_read, "thresh_x_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_class_info_cdma2000->thresh_x_high > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_class_info_cdma2000->thresh_x_high] should be less than"
            " or equal to 63. Incorrect value %u received.", p_band_class_info_cdma2000->thresh_x_high);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_class_info_cdma2000->thresh_x_low, p_src + *p_length_read, "thresh_x_low");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_class_info_cdma2000->thresh_x_low > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_class_info_cdma2000->thresh_x_low] should be less than"
            " or equal to 63. Incorrect value %u received.", p_band_class_info_cdma2000->thresh_x_low);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_class_list_cdma2000
(
    band_class_list_cdma2000_t *p_band_class_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_class_list_cdma2000, 0, sizeof(band_class_list_cdma2000_t));

    /* This function parses band_class_list_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_class_list_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_class_list_cdma2000->count > MAX_CDMA_BAND_CLASS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_class_list_cdma2000->count] should be less than"
            " or equal to MAX_CDMA_BAND_CLASS. Incorrect value %u received.", p_band_class_list_cdma2000->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_class_list_cdma2000->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_class_info_cdma2000(
                &p_band_class_list_cdma2000->band_class_info_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phys_cell_id_list_cdma2000
(
    phys_cell_id_list_cdma2000_t *p_phys_cell_id_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phys_cell_id_list_cdma2000, 0, sizeof(phys_cell_id_list_cdma2000_t));

    /* This function parses phys_cell_id_list_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phys_cell_id_list_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_phys_cell_id_list_cdma2000->count < 1) || (p_phys_cell_id_list_cdma2000->count > MAX_PHYS_CELL_ID_LIST_CDMA2000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phys_cell_id_list_cdma2000->count] should be in range "
            "1 to MAX_PHYS_CELL_ID_LIST_CDMA2000. Incorrect value %u received.", p_phys_cell_id_list_cdma2000->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_phys_cell_id_list_cdma2000->count * sizeof(p_phys_cell_id_list_cdma2000->phys_cell_id_cdma2000[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_phys_cell_id_list_cdma2000->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_phys_cell_id_list_cdma2000->phys_cell_id_cdma2000[loop], (void*)(p_src + *p_length_read), "phys_cell_id_cdma2000[]");
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_cdma2000
(
    neigh_cells_per_bandclass_cdma2000_t *p_neigh_cells_per_bandclass_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cells_per_bandclass_cdma2000, 0, sizeof(neigh_cells_per_bandclass_cdma2000_t));

    /* This function parses neigh_cells_per_bandclass_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_neigh_cells_per_bandclass_cdma2000->arfcn, p_src + *p_length_read, "arfcn");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cells_per_bandclass_cdma2000->arfcn > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cells_per_bandclass_cdma2000->arfcn] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_neigh_cells_per_bandclass_cdma2000->arfcn);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_list_cdma2000(
        &p_neigh_cells_per_bandclass_cdma2000->phys_cell_id_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000
(
    neigh_cells_per_bandclass_list_cdma2000_t *p_neigh_cells_per_bandclass_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cells_per_bandclass_list_cdma2000, 0, sizeof(neigh_cells_per_bandclass_list_cdma2000_t));

    /* This function parses neigh_cells_per_bandclass_list_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cells_per_bandclass_list_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_neigh_cells_per_bandclass_list_cdma2000->count < 1) || (p_neigh_cells_per_bandclass_list_cdma2000->count > MAX_NCELLS_PER_BS_LIST_CDMA2000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cells_per_bandclass_list_cdma2000->count] should be in range "
            "1 to MAX_NCELLS_PER_BS_LIST_CDMA2000. Incorrect value %u received.", p_neigh_cells_per_bandclass_list_cdma2000->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_neigh_cells_per_bandclass_list_cdma2000->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_neigh_cells_per_bandclass_cdma2000(
                &p_neigh_cells_per_bandclass_list_cdma2000->neigh_cells_per_bandclass_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_cdma2000
(
    neigh_cell_cdma2000_t *p_neigh_cell_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_cdma2000, 0, sizeof(neigh_cell_cdma2000_t));

    /* This function parses neigh_cell_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_cdma2000->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell_cdma2000->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_cdma2000->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_neigh_cell_cdma2000->band_class);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000(
        &p_neigh_cell_cdma2000->neigh_cells_per_freq_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_list_cdma2000
(
    neigh_cell_list_cdma2000_t *p_neigh_cell_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_list_cdma2000, 0, sizeof(neigh_cell_list_cdma2000_t));

    /* This function parses neigh_cell_list_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_list_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_neigh_cell_list_cdma2000->count < 1) || (p_neigh_cell_list_cdma2000->count > MAX_NEIGH_CELL_LIST_CDMA2000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_list_cdma2000->count] should be in range "
            "1 to MAX_NEIGH_CELL_LIST_CDMA2000. Incorrect value %u received.", p_neigh_cell_list_cdma2000->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_neigh_cell_list_cdma2000->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_neigh_cell_cdma2000(
                &p_neigh_cell_list_cdma2000->neigh_cell_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_reselection_params_cdma2000
(
    cell_reselection_params_cdma2000_t *p_cell_reselection_params_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_reselection_params_cdma2000, 0, sizeof(cell_reselection_params_cdma2000_t));

    /* This function parses cell_reselection_params_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_reselection_params_cdma2000->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_band_class_list_cdma2000(
        &p_cell_reselection_params_cdma2000->band_class_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_list_cdma2000(
        &p_cell_reselection_params_cdma2000->neigh_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_reselection_params_cdma2000->t_reselection_cdma2000, p_src + *p_length_read, "t_reselection_cdma2000");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_reselection_params_cdma2000->t_reselection_cdma2000 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_reselection_params_cdma2000->t_reselection_cdma2000] should be less than"
            " or equal to 7. Incorrect value %u received.", p_cell_reselection_params_cdma2000->t_reselection_cdma2000);
        return RRC_FAILURE;
    }

    if (p_cell_reselection_params_cdma2000->presence_bitmask & CELL_RESELECT_CDMA2000_SF_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_cell_reselection_params_cdma2000->t_reselection_cdma2000_sf,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_params_hrpd
(
    params_hrpd_t *p_params_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_params_hrpd, 0, sizeof(params_hrpd_t));

    /* This function parses params_hrpd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_params_hrpd->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_pre_reg_info_hrpd(
        &p_params_hrpd->pre_reg_info_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_params_hrpd->presence_bitmask & PARAMS_HRPD_CELL_RESELECTION_PARAMS_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_reselection_params_cdma2000(
        &p_params_hrpd->cell_reselection_params_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_csfb_reg_param_1_xrtt
(
    csfb_reg_param_1_xrtt_t *p_csfb_reg_param_1_xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_csfb_reg_param_1_xrtt, 0, sizeof(csfb_reg_param_1_xrtt_t));

    /* This function parses csfb_reg_param_1_xrtt */

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->sid) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->sid); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->sid[loop], (void*)(p_src + *p_length_read), "sid[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->nid) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->nid); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->nid[loop], (void*)(p_src + *p_length_read), "nid[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->multiple_sid, p_src + *p_length_read, "multiple_sid");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->multiple_sid > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->multiple_sid] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->multiple_sid);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->multiple_nid, p_src + *p_length_read, "multiple_nid");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->multiple_nid > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->multiple_nid] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->multiple_nid);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->home_reg, p_src + *p_length_read, "home_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->home_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->home_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->home_reg);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->foreign_sid_reg, p_src + *p_length_read, "foreign_sid_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->foreign_sid_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->foreign_sid_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->foreign_sid_reg);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->foreign_nid_reg, p_src + *p_length_read, "foreign_nid_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->foreign_nid_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->foreign_nid_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->foreign_nid_reg);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->parame_reg, p_src + *p_length_read, "parame_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->parame_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->parame_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->parame_reg);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csfb_reg_param_1_xrtt->power_up_reg, p_src + *p_length_read, "power_up_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csfb_reg_param_1_xrtt->power_up_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csfb_reg_param_1_xrtt->power_up_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csfb_reg_param_1_xrtt->power_up_reg);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->reg_period) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->reg_period); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->reg_period[loop], (void*)(p_src + *p_length_read), "reg_period[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->reg_zone) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->reg_zone); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->reg_zone[loop], (void*)(p_src + *p_length_read), "reg_zone[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->total_zone) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->total_zone); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->total_zone[loop], (void*)(p_src + *p_length_read), "total_zone[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_csfb_reg_param_1_xrtt->zone_timer) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_csfb_reg_param_1_xrtt->zone_timer); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_csfb_reg_param_1_xrtt->zone_timer[loop], (void*)(p_src + *p_length_read), "zone_timer[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_params_1_xrtt
(
    params_1_xrtt_t *p_params_1_xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_params_1_xrtt, 0, sizeof(params_1_xrtt_t));

    /* This function parses params_1_xrtt */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_params_1_xrtt->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_params_1_xrtt->presence_bitmask & CFSB_REG_PARAM_1_XRTT_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_csfb_reg_param_1_xrtt(
        &p_params_1_xrtt->csfb_reg_param_1_xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_params_1_xrtt->presence_bitmask & LONG_CODE_STATE_1_XRTT_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(p_params_1_xrtt->long_code_state_1_xrtt) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_params_1_xrtt->long_code_state_1_xrtt); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_params_1_xrtt->long_code_state_1_xrtt[loop], (void*)(p_src + *p_length_read), "long_code_state_1_xrtt[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_params_1_xrtt->presence_bitmask & CELL_RESELECTION_PARAM_1_XRTT_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_reselection_params_cdma2000(
        &p_params_1_xrtt->cell_reselection_params_1_xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phys_cell_id_list_cdma2000_v920
(
    phys_cell_id_list_cdma2000_v920_t *p_phys_cell_id_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phys_cell_id_list_cdma2000_v920, 0, sizeof(phys_cell_id_list_cdma2000_v920_t));

    /* This function parses phys_cell_id_list_cdma2000_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phys_cell_id_list_cdma2000_v920->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phys_cell_id_list_cdma2000_v920->count > MAX_PHYS_CELL_ID_LIST_CDMA2000_v920))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phys_cell_id_list_cdma2000_v920->count] should be less than"
            " or equal to MAX_PHYS_CELL_ID_LIST_CDMA2000_v920. Incorrect value %u received.", p_phys_cell_id_list_cdma2000_v920->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_phys_cell_id_list_cdma2000_v920->count * sizeof(p_phys_cell_id_list_cdma2000_v920->phys_cell_id_cdma2000_v920[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_phys_cell_id_list_cdma2000_v920->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_phys_cell_id_list_cdma2000_v920->phys_cell_id_cdma2000_v920[loop], (void*)(p_src + *p_length_read), "phys_cell_id_cdma2000_v920[]");
            if (p_phys_cell_id_list_cdma2000_v920->phys_cell_id_cdma2000_v920[loop] > 511)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_phys_cell_id_list_cdma2000_v920->phys_cell_id_cdma2000_v920[%u] should be less"
                    " than or equal to 511. "
                    "Incorrect value %d received.", loop, p_phys_cell_id_list_cdma2000_v920->phys_cell_id_cdma2000_v920[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_cdma2000_v920
(
    neigh_cells_per_bandclass_cdma2000_v920_t *p_neigh_cells_per_bandclass_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cells_per_bandclass_cdma2000_v920, 0, sizeof(neigh_cells_per_bandclass_cdma2000_v920_t));

    /* This function parses neigh_cells_per_bandclass_cdma2000_v920 */

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_list_cdma2000_v920(
        &p_neigh_cells_per_bandclass_cdma2000_v920->phys_cell_id_list_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000_v920
(
    neigh_cells_per_bandclass_list_cdma2000_v920_t *p_neigh_cells_per_bandclass_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cells_per_bandclass_list_cdma2000_v920, 0, sizeof(neigh_cells_per_bandclass_list_cdma2000_v920_t));

    /* This function parses neigh_cells_per_bandclass_list_cdma2000_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cells_per_bandclass_list_cdma2000_v920->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_neigh_cells_per_bandclass_list_cdma2000_v920->count < 1) || (p_neigh_cells_per_bandclass_list_cdma2000_v920->count > MAX_NCELLS_PER_BS_LIST_CDMA2000_v920))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cells_per_bandclass_list_cdma2000_v920->count] should be in range "
            "1 to MAX_NCELLS_PER_BS_LIST_CDMA2000_v920. Incorrect value %u received.", p_neigh_cells_per_bandclass_list_cdma2000_v920->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_neigh_cells_per_bandclass_list_cdma2000_v920->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_neigh_cells_per_bandclass_cdma2000_v920(
                &p_neigh_cells_per_bandclass_list_cdma2000_v920->neigh_cells_per_bandclass_cdma2000_v920[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_cdma2000_v920
(
    neigh_cell_cdma2000_v920_t *p_neigh_cell_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_cdma2000_v920, 0, sizeof(neigh_cell_cdma2000_v920_t));

    /* This function parses neigh_cell_cdma2000_v920 */

    if (RRC_FAILURE == rrc_il_parse_neigh_cells_per_bandclass_list_cdma2000_v920(
        &p_neigh_cell_cdma2000_v920->neigh_cells_per_freq_list_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_list_cdma2000_v920
(
    neigh_cell_list_cdma2000_v920_t *p_neigh_cell_list_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_list_cdma2000_v920, 0, sizeof(neigh_cell_list_cdma2000_v920_t));

    /* This function parses neigh_cell_list_cdma2000_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_list_cdma2000_v920->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_neigh_cell_list_cdma2000_v920->count < 1) || (p_neigh_cell_list_cdma2000_v920->count > MAX_NEIGH_CELL_LIST_CDMA2000_v920))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_list_cdma2000_v920->count] should be in range "
            "1 to MAX_NEIGH_CELL_LIST_CDMA2000_v920. Incorrect value %u received.", p_neigh_cell_list_cdma2000_v920->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_neigh_cell_list_cdma2000_v920->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_neigh_cell_cdma2000_v920(
                &p_neigh_cell_list_cdma2000_v920->neigh_cell_cdma2000_v920[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_reselection_params_cdma2000_v920
(
    cell_reselection_params_cdma2000_v920_t *p_cell_reselection_params_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_reselection_params_cdma2000_v920, 0, sizeof(cell_reselection_params_cdma2000_v920_t));

    /* This function parses cell_reselection_params_cdma2000_v920 */

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_list_cdma2000_v920(
        &p_cell_reselection_params_cdma2000_v920->neigh_cell_list_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ac_barring_config_1_xrtt_r9
(
    ac_barring_config_1_xrtt_r9_t *p_ac_barring_config_1_xrtt_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ac_barring_config_1_xrtt_r9, 0, sizeof(ac_barring_config_1_xrtt_r9_t));

    /* This function parses ac_barring_config_1_xrtt_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9, p_src + *p_length_read, "ac_barring_0_to_9_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9 > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9] should be less than"
            " or equal to 63. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_0_to_9_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_10_r9, p_src + *p_length_read, "ac_barring_10_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_10_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_10_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_10_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_11_r9, p_src + *p_length_read, "ac_barring_11_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_11_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_11_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_11_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_12_r9, p_src + *p_length_read, "ac_barring_12_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_12_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_12_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_12_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_13_r9, p_src + *p_length_read, "ac_barring_13_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_13_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_13_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_13_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_14_r9, p_src + *p_length_read, "ac_barring_14_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_14_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_14_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_14_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_15_r9, p_src + *p_length_read, "ac_barring_15_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_15_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_15_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_15_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9, p_src + *p_length_read, "ac_barring_msg_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_msg_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9, p_src + *p_length_read, "ac_barring_reg_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_reg_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9, p_src + *p_length_read, "ac_barring_emg_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_ac_barring_config_1_xrtt_r9->ac_barring_emg_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_8_Info
(
    sib_type_8_Info_t *p_sib_type_8_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_8_Info, 0, sizeof(sib_type_8_Info_t));

    /* This function parses sib_type_8_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_8_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_SYS_TIME_INFO_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sys_time_info_cdma2000(
        &p_sib_type_8_Info->sys_time_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_SEARCH_WIN_SIZE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_8_Info->search_window_size, p_src + *p_length_read, "search_window_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_8_Info->search_window_size > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_8_Info->search_window_size] should be less than"
            " or equal to 15. Incorrect value %u received.", p_sib_type_8_Info->search_window_size);
        return RRC_FAILURE;
    }
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_PARAMS_HRPD_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_params_hrpd(
        &p_sib_type_8_Info->params_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_PARAMS_1_XRTT_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_params_1_xrtt(
        &p_sib_type_8_Info->params_1_xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_CELL_RESEL_PARAMS_HRPD_V920_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_reselection_params_cdma2000_v920(
        &p_sib_type_8_Info->cell_reselection_params_hrpd_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_CELL_RESEL_PARAMS_1_XRTT_V920_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_reselection_params_cdma2000_v920(
        &p_sib_type_8_Info->cell_reselection_params_1_xrtt_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_CSFB_SUPPORT_FOR_DUAL_RX_UES_R9_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9, p_src + *p_length_read, "csfb_support_for_dual_rx_ues_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_sib_type_8_Info->csfb_support_for_dual_rx_ues_r9);
        return RRC_FAILURE;
    }
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_AC_BARRING_CONFIG_1_XRTT_R9_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_ac_barring_config_1_xrtt_r9(
        &p_sib_type_8_Info->ac_barring_config_1_xrtt_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_CSFB_REG_PARAM_1_XRTT_R9_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_8_Info->csfb_registration_param_1xrtt_v920, p_src + *p_length_read, "csfb_registration_param_1xrtt_v920");
    *p_length_read += sizeof(U8);
    }

    if (p_sib_type_8_Info->presence_bitmask & SIB_8_CSFB_DUAL_RX_TX_SUPPORT_R10_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_8_Info->csfb_dual_rx_tx_support_r10, p_src + *p_length_read, "csfb_dual_rx_tx_support_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_8_Info->csfb_dual_rx_tx_support_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_8_Info->csfb_dual_rx_tx_support_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_sib_type_8_Info->csfb_dual_rx_tx_support_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_9_Info
(
    sib_type_9_Info_t *p_sib_type_9_Info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib_type_9_Info, 0, sizeof(sib_type_9_Info_t));

    /* This function parses sib_type_9_Info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_sib_type_9_Info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_sib_type_9_Info->presence_bitmask & SIB_9_HNB_ID_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_9_Info->size_of_hnb_id, p_src + *p_length_read, "size_of_hnb_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_9_Info->size_of_hnb_id > MAX_HNB_ID_OCTET_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_9_Info->size_of_hnb_id] should be less than"
            " or equal to MAX_HNB_ID_OCTET_SIZE. Incorrect value %u received.", p_sib_type_9_Info->size_of_hnb_id);
        return RRC_FAILURE;
    }
    }

    if (p_sib_type_9_Info->presence_bitmask & SIB_9_HNB_ID_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)(p_sib_type_9_Info->size_of_hnb_id * sizeof(p_sib_type_9_Info->hnb_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_sib_type_9_Info->size_of_hnb_id; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sib_type_9_Info->hnb_id[loop], (void*)(p_src + *p_length_read), "hnb_id[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_m2ap_mcch_related_bcch_info
(
    m2ap_mcch_related_bcch_info_t *p_m2ap_mcch_related_bcch_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_m2ap_mcch_related_bcch_info, 0, sizeof(m2ap_mcch_related_bcch_info_t));

    /* This function parses m2ap_mcch_related_bcch_info */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_m2ap_mcch_related_bcch_info->signalling_mcs, p_src + *p_length_read, "signalling_mcs");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->signalling_mcs > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->signalling_mcs] should be less than"
            " or equal to 3. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->signalling_mcs);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_m2ap_mcch_related_bcch_info->mcch_repetition_period, p_src + *p_length_read, "mcch_repetition_period");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->mcch_repetition_period > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->mcch_repetition_period] should be less than"
            " or equal to 3. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->mcch_repetition_period);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_m2ap_mcch_related_bcch_info->mcch_modification_period, p_src + *p_length_read, "mcch_modification_period");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->mcch_modification_period > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->mcch_modification_period] should be less than"
            " or equal to 1. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->mcch_modification_period);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_m2ap_mcch_related_bcch_info->pdcch_length, p_src + *p_length_read, "pdcch_length");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->pdcch_length > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->pdcch_length] should be less than"
            " or equal to 1. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->pdcch_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->mcch_offset, p_src + *p_length_read, "mcch_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->mcch_offset > 10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->mcch_offset] should be less than"
            " or equal to 10. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->mcch_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->sf_alloc_info, p_src + *p_length_read, "sf_alloc_info");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->area_id, p_src + *p_length_read, "area_id");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->notification_indicator_r9, p_src + *p_length_read, "notification_indicator_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->notification_indicator_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->notification_indicator_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->notification_indicator_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->area_index, p_src + *p_length_read, "area_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->area_index > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->area_index] should be less than"
            " or equal to 15. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->area_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_mcch_related_bcch_info->area_type, p_src + *p_length_read, "area_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_mcch_related_bcch_info->area_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_mcch_related_bcch_info->area_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_m2ap_mcch_related_bcch_info->area_type);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_m2ap_notification_config
(
    m2ap_notification_config_t *p_m2ap_notification_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_m2ap_notification_config, 0, sizeof(m2ap_notification_config_t));

    /* This function parses m2ap_notification_config */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_m2ap_notification_config->notification_repetition_coeff, p_src + *p_length_read, "notification_repetition_coeff");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_notification_config->notification_repetition_coeff > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_notification_config->notification_repetition_coeff] should be less than"
            " or equal to 1. Incorrect value %u received.", p_m2ap_notification_config->notification_repetition_coeff);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_notification_config->notification_offset, p_src + *p_length_read, "notification_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_notification_config->notification_offset > 10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_notification_config->notification_offset] should be less than"
            " or equal to 10. Incorrect value %u received.", p_m2ap_notification_config->notification_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_notification_config->notification_sf_Index, p_src + *p_length_read, "notification_sf_Index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_m2ap_notification_config->notification_sf_Index > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_m2ap_notification_config->notification_sf_Index] should be less than"
            " or equal to 6. Incorrect value %u received.", p_m2ap_notification_config->notification_sf_Index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib_type_13_info
(
    sib_type_13_info_t *p_sib_type_13_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_sib_type_13_info, 0, sizeof(sib_type_13_info_t));

    /* This function parses sib_type_13_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib_type_13_info->num_valid_mbsfn_area_info, p_src + *p_length_read, "num_valid_mbsfn_area_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_sib_type_13_info->num_valid_mbsfn_area_info > MAX_MBSFN_SUBFRAME_CONFIG))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sib_type_13_info->num_valid_mbsfn_area_info] should be less than"
            " or equal to MAX_MBSFN_SUBFRAME_CONFIG. Incorrect value %u received.", p_sib_type_13_info->num_valid_mbsfn_area_info);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_sib_type_13_info->num_valid_mbsfn_area_info; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_m2ap_mcch_related_bcch_info(
                &p_sib_type_13_info->m2ap_mbsfn_area_info_list[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (RRC_FAILURE == rrc_il_parse_m2ap_notification_config(
        &p_sib_type_13_info->m2ap_notification_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mbms_updated_area_info
(
    mbms_updated_area_info_t *p_mbms_updated_area_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_mbms_updated_area_info, 0, sizeof(mbms_updated_area_info_t));

    /* This function parses mbms_updated_area_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbms_updated_area_info->area_id, p_src + *p_length_read, "area_id");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbms_updated_area_info->area_index, p_src + *p_length_read, "area_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbms_updated_area_info->area_index > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbms_updated_area_info->area_index] should be less than"
            " or equal to 15. Incorrect value %u received.", p_mbms_updated_area_info->area_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbms_updated_area_info->flag, p_src + *p_length_read, "flag");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbms_updated_area_info->flag > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbms_updated_area_info->flag] should be less than"
            " or equal to 3. Incorrect value %u received.", p_mbms_updated_area_info->flag);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mbms_updated_area_info_list
(
    mbms_updated_area_info_list_t *p_mbms_updated_area_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mbms_updated_area_info_list, 0, sizeof(mbms_updated_area_info_list_t));

    /* This function parses mbms_updated_area_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mbms_updated_area_info_list->num_valid_mbsfn_area_info, p_src + *p_length_read, "num_valid_mbsfn_area_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mbms_updated_area_info_list->num_valid_mbsfn_area_info > MAX_MBMS_UPDATED_AREA_LIST))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mbms_updated_area_info_list->num_valid_mbsfn_area_info] should be less than"
            " or equal to MAX_MBMS_UPDATED_AREA_LIST. Incorrect value %u received.", p_mbms_updated_area_info_list->num_valid_mbsfn_area_info);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_mbms_updated_area_info_list->num_valid_mbsfn_area_info; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_mbms_updated_area_info(
                &p_mbms_updated_area_info_list->mbms_updated_area_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_m2ap_reserved_mcch_related_bcch_info_list
(
    m2ap_reserved_mcch_related_bcch_info_list_t *p_m2ap_reserved_mcch_related_bcch_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_m2ap_reserved_mcch_related_bcch_info_list, 0, sizeof(m2ap_reserved_mcch_related_bcch_info_list_t));

    /* This function parses m2ap_reserved_mcch_related_bcch_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_m2ap_reserved_mcch_related_bcch_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_m2ap_reserved_mcch_related_bcch_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_m2ap_mcch_related_bcch_info(
                &p_m2ap_reserved_mcch_related_bcch_info_list->m2ap_reserved_cell_mcch_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_broadcast_config_info
(
    broadcast_config_info_t *p_broadcast_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_broadcast_config_info, 0, sizeof(broadcast_config_info_t));

    /* This function parses broadcast_config_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_broadcast_config_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_broadcast_config_info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_mib_info(
        &p_broadcast_config_info->mib_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_Info(
        &p_broadcast_config_info->sib_type_1_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 4)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_2_Info(
        &p_broadcast_config_info->sib_type_2_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 8)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_3_Info(
        &p_broadcast_config_info->sib_type_3_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 16)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_4_Info(
        &p_broadcast_config_info->sib_type_4_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 32)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_5_Info(
        &p_broadcast_config_info->sib_type_5_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 64)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_6_Info(
        &p_broadcast_config_info->sib_type_6_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 128)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_7_Info(
        &p_broadcast_config_info->sib_type_7_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 256)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_8_Info(
        &p_broadcast_config_info->sib_type_8_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 512)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_9_Info(
        &p_broadcast_config_info->sib_type_9_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 8192)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_13_info(
        &p_broadcast_config_info->sib_type_13_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 1024)
    {

    if (RRC_FAILURE == rrc_il_parse_mbms_updated_area_info_list(
        &p_broadcast_config_info->mbms_updated_area_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_broadcast_config_info->presence_bitmask & 2048)
    {

    if (RRC_FAILURE == rrc_il_parse_m2ap_reserved_mcch_related_bcch_info_list(
        &p_broadcast_config_info->m2ap_reserved_mcch_related_bcch_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_recfg_phy_cell_parameters
(
    rrc_recfg_phy_cell_parameters_t *p_rrc_recfg_phy_cell_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_recfg_phy_cell_parameters, 0, sizeof(rrc_recfg_phy_cell_parameters_t));

    /* This function parses rrc_recfg_phy_cell_parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_recfg_phy_cell_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_EARFCN_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_recfg_phy_cell_parameters->dl_earfcn, p_src + *p_length_read, "dl_earfcn");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_PARAMS_NUM_OF_ANTENNAS)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_recfg_phy_cell_parameters->num_of_antennas, p_src + *p_length_read, "num_of_antennas");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_recfg_phy_cell_parameters->num_of_antennas < 1) || (p_rrc_recfg_phy_cell_parameters->num_of_antennas > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->num_of_antennas] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->num_of_antennas);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_PARAMS_DL_CYCLIC_PREFIX)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_recfg_phy_cell_parameters->dl_cyclic_prefix, p_src + *p_length_read, "dl_cyclic_prefix");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_recfg_phy_cell_parameters->dl_cyclic_prefix > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->dl_cyclic_prefix] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->dl_cyclic_prefix);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_PARAMS_RB_SIZE)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_recfg_phy_cell_parameters->rb_size, p_src + *p_length_read, "rb_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_recfg_phy_cell_parameters->rb_size > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->rb_size] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->rb_size);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_ID)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_recfg_phy_cell_parameters->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_PRIMARY_SYNC_SIGNAL_EPRE_EPRERS)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_recfg_phy_cell_parameters->pri_sync_sig_epre_eprers, p_src + *p_length_read, "pri_sync_sig_epre_eprers");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_recfg_phy_cell_parameters->pri_sync_sig_epre_eprers > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->pri_sync_sig_epre_eprers] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->pri_sync_sig_epre_eprers);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_SECONDARY_SYNC_SIGNAL_EPRE_EPRERS)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_recfg_phy_cell_parameters->sec_sync_sig_epre_eprers, p_src + *p_length_read, "sec_sync_sig_epre_eprers");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_recfg_phy_cell_parameters->sec_sync_sig_epre_eprers > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->sec_sync_sig_epre_eprers] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->sec_sync_sig_epre_eprers);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_recfg_phy_cell_parameters->bitmask & RRC_RRM_RECONFIG_PHY_CELL_MAX_RS_EPRE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_recfg_phy_cell_parameters->max_rs_epre, p_src + *p_length_read, "max_rs_epre");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_recfg_phy_cell_parameters->max_rs_epre > 160))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_recfg_phy_cell_parameters->max_rs_epre] should be less than"
            " or equal to 160. Incorrect value %u received.", p_rrc_recfg_phy_cell_parameters->max_rs_epre);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_sync_signals
(
    rrc_phy_sync_signals_t *p_rrc_phy_sync_signals,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_sync_signals, 0, sizeof(rrc_phy_sync_signals_t));

    /* This function parses rrc_phy_sync_signals */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_phy_sync_signals->prim_syn_signal_power, p_src + *p_length_read, "prim_syn_signal_power");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_sync_signals->prim_syn_signal_power < -6) || (p_rrc_phy_sync_signals->prim_syn_signal_power > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sync_signals->prim_syn_signal_power] should be in range "
            "-6 to 4. Incorrect value %d received.", p_rrc_phy_sync_signals->prim_syn_signal_power);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_phy_sync_signals->sec_syn_signal_power, p_src + *p_length_read, "sec_syn_signal_power");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_sync_signals->sec_syn_signal_power < -6) || (p_rrc_phy_sync_signals->sec_syn_signal_power > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sync_signals->sec_syn_signal_power] should be in range "
            "-6 to 4. Incorrect value %d received.", p_rrc_phy_sync_signals->sec_syn_signal_power);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sync_signals->sec_syn_signal_m_seq1, p_src + *p_length_read, "sec_syn_signal_m_seq1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sync_signals->sec_syn_signal_m_seq1 > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sync_signals->sec_syn_signal_m_seq1] should be less than"
            " or equal to 30. Incorrect value %u received.", p_rrc_phy_sync_signals->sec_syn_signal_m_seq1);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sync_signals->sec_syn_signal_m_seq2, p_src + *p_length_read, "sec_syn_signal_m_seq2");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sync_signals->sec_syn_signal_m_seq2 > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sync_signals->sec_syn_signal_m_seq2] should be less than"
            " or equal to 30. Incorrect value %u received.", p_rrc_phy_sync_signals->sec_syn_signal_m_seq2);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_si_start_offset
(
    rrc_si_start_offset_t *p_rrc_si_start_offset,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_si_start_offset, 0, sizeof(rrc_si_start_offset_t));

    /* This function parses rrc_si_start_offset */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_si_start_offset->si_start_offset, p_src + *p_length_read, "si_start_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_si_start_offset->si_start_offset > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_si_start_offset->si_start_offset] should be less than"
            " or equal to 39. Incorrect value %u received.", p_rrc_si_start_offset->si_start_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_si_start_offset_info
(
    rrc_si_start_offset_info_t *p_rrc_si_start_offset_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_si_start_offset_info, 0, sizeof(rrc_si_start_offset_info_t));

    /* This function parses rrc_si_start_offset_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_si_start_offset_info->offset_count, p_src + *p_length_read, "offset_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_si_start_offset_info->offset_count < 1) || (p_rrc_si_start_offset_info->offset_count > MAX_SI_START_OFFSET))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_si_start_offset_info->offset_count] should be in range "
            "1 to MAX_SI_START_OFFSET. Incorrect value %u received.", p_rrc_si_start_offset_info->offset_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_si_start_offset_info->offset_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_si_start_offset(
                &p_rrc_si_start_offset_info->si_start_offset[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_si_transmission_info
(
    rrc_si_transmission_info_t *p_rrc_si_transmission_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_si_transmission_info, 0, sizeof(rrc_si_transmission_info_t));

    /* This function parses rrc_si_transmission_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_si_transmission_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_si_transmission_info->si_index, p_src + *p_length_read, "si_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_si_transmission_info->si_index > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_si_transmission_info->si_index] should be less than"
            " or equal to 9. Incorrect value %u received.", p_rrc_si_transmission_info->si_index);
        return RRC_FAILURE;
    }

    if (p_rrc_si_transmission_info->bitmask & RRC_RRM_NUM_OF_TRANSMISSIONS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_si_transmission_info->num_of_transmissions, p_src + *p_length_read, "num_of_transmissions");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_si_transmission_info->num_of_transmissions < 1) || (p_rrc_si_transmission_info->num_of_transmissions > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_si_transmission_info->num_of_transmissions] should be in range "
            "1 to 8. Incorrect value %u received.", p_rrc_si_transmission_info->num_of_transmissions);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_si_transmission_info->bitmask & RRC_RRM_SI_START_OFFSET_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_si_start_offset_info(
        &p_rrc_si_transmission_info->si_start_offset_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_si_transmission_info_list
(
    rrc_si_transmission_info_list_t *p_rrc_si_transmission_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_si_transmission_info_list, 0, sizeof(rrc_si_transmission_info_list_t));

    /* This function parses rrc_si_transmission_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_si_transmission_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_si_transmission_info_list->count < 1) || (p_rrc_si_transmission_info_list->count > MAX_SI_MESSAGE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_si_transmission_info_list->count] should be in range "
            "1 to MAX_SI_MESSAGE. Incorrect value %u received.", p_rrc_si_transmission_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_si_transmission_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_si_transmission_info(
                &p_rrc_si_transmission_info_list->si_transmission[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_sps_crnti_range
(
    rrc_rrm_sps_crnti_range_t *p_rrc_rrm_sps_crnti_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_sps_crnti_range, 0, sizeof(rrc_rrm_sps_crnti_range_t));

    /* This function parses rrc_rrm_sps_crnti_range */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_sps_crnti_range->start_sps_crnti, p_src + *p_length_read, "start_sps_crnti");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_sps_crnti_range->start_sps_crnti < 61) || (p_rrc_rrm_sps_crnti_range->start_sps_crnti > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_sps_crnti_range->start_sps_crnti] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_rrm_sps_crnti_range->start_sps_crnti);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_sps_crnti_range->end_sps_crnti, p_src + *p_length_read, "end_sps_crnti");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_sps_crnti_range->end_sps_crnti < 61) || (p_rrc_rrm_sps_crnti_range->end_sps_crnti > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_sps_crnti_range->end_sps_crnti] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_rrm_sps_crnti_range->end_sps_crnti);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_bandwidth_info
(
    rrc_rrm_prs_bandwidth_info_t *p_rrc_rrm_prs_bandwidth_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_bandwidth_info, 0, sizeof(rrc_rrm_prs_bandwidth_info_t));

    /* This function parses rrc_rrm_prs_bandwidth_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_prs_bandwidth_info->prs_bandwidth, p_src + *p_length_read, "prs_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_bandwidth_info->prs_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_bandwidth_info->prs_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_rrm_prs_bandwidth_info->prs_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_subframes_info
(
    rrc_rrm_prs_subframes_info_t *p_rrc_rrm_prs_subframes_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_subframes_info, 0, sizeof(rrc_rrm_prs_subframes_info_t));

    /* This function parses rrc_rrm_prs_subframes_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_prs_subframes_info->prs_subframes, p_src + *p_length_read, "prs_subframes");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_subframes_info->prs_subframes > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_subframes_info->prs_subframes] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_rrm_prs_subframes_info->prs_subframes);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config_index_info
(
    rrc_rrm_prs_config_index_info_t *p_rrc_rrm_prs_config_index_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_config_index_info, 0, sizeof(rrc_rrm_prs_config_index_info_t));

    /* This function parses rrc_rrm_prs_config_index_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_config_index_info->prs_config_index, p_src + *p_length_read, "prs_config_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_config_index_info->prs_config_index > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_config_index_info->prs_config_index] should be less than"
            " or equal to 4095. Incorrect value %u received.", p_rrc_rrm_prs_config_index_info->prs_config_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_transmission_power_info
(
    rrc_rrm_prs_transmission_power_info_t *p_rrc_rrm_prs_transmission_power_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_transmission_power_info, 0, sizeof(rrc_rrm_prs_transmission_power_info_t));

    /* This function parses rrc_rrm_prs_transmission_power_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_transmission_power_info->prs_transmission_power, p_src + *p_length_read, "prs_transmission_power");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_transmission_power_info->prs_transmission_power > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_transmission_power_info->prs_transmission_power] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_rrm_prs_transmission_power_info->prs_transmission_power);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_muting_config_info
(
    rrc_rrm_prs_muting_config_info_t *p_rrc_rrm_prs_muting_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_muting_config_info, 0, sizeof(rrc_rrm_prs_muting_config_info_t));

    /* This function parses rrc_rrm_prs_muting_config_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_prs_muting_config_info->bits_to_be_read, p_src + *p_length_read, "bits_to_be_read");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_muting_config_info->bits_to_be_read > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_muting_config_info->bits_to_be_read] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_rrm_prs_muting_config_info->bits_to_be_read);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_muting_config_info->prs_muting_config_index, p_src + *p_length_read, "prs_muting_config_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_reconfig
(
    rrc_rrm_prs_reconfig_t *p_rrc_rrm_prs_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_reconfig, 0, sizeof(rrc_rrm_prs_reconfig_t));

    /* This function parses rrc_rrm_prs_reconfig */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_reconfig->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_prs_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_BANDWIDTH_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_bandwidth_info(
        &p_rrc_rrm_prs_reconfig->prs_bandwidth_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_prs_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_SUBFRAMES_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_subframes_info(
        &p_rrc_rrm_prs_reconfig->prs_subframes_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_prs_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_CONFIG_INDEX_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_config_index_info(
        &p_rrc_rrm_prs_reconfig->prs_config_index_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_prs_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_TRANSMISSION_POWER_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_transmission_power_info(
        &p_rrc_rrm_prs_reconfig->prs_transmission_power_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_prs_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_MUTING_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_muting_config_info(
        &p_rrc_rrm_prs_reconfig->prs_muting_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_reconfig_info
(
    rrc_rrm_prs_reconfig_info_t *p_rrc_rrm_prs_reconfig_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_reconfig_info, 0, sizeof(rrc_rrm_prs_reconfig_info_t));

    /* This function parses rrc_rrm_prs_reconfig_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_reconfig_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_prs_reconfig_info->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_reconfig_info->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_reconfig_info->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_prs_reconfig_info->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_prs_reconfig_info->bitmask & RRC_RRM_RECONFIG_PRS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_reconfig(
        &p_rrc_rrm_prs_reconfig_info->prs_reconfig,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_reconfig
(
    rrc_mac_reconfig_t *p_rrc_mac_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_reconfig, 0, sizeof(rrc_mac_reconfig_t));

    /* This function parses rrc_mac_reconfig */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_reconfig->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_DCI_FORMAT_FOR_SI_MESSAGES_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_reconfig->dci_format_for_si_msgs, p_src + *p_length_read, "dci_format_for_si_msgs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_reconfig->dci_format_for_si_msgs > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_reconfig->dci_format_for_si_msgs] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_reconfig->dci_format_for_si_msgs);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_reconfig->bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a[loop], (void*)(p_src + *p_length_read), "num_rbs_per_tbs_dci_1a[]");
            if (p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a[loop] > 100)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a[%u] should be less"
                    " than or equal to 100. "
                    "Incorrect value %d received.", loop, p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1a[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_mac_reconfig->bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c[loop], (void*)(p_src + *p_length_read), "num_rbs_per_tbs_dci_1c[]");
            if (p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c[loop] > 100)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c[%u] should be less"
                    " than or equal to 100. "
                    "Incorrect value %d received.", loop, p_rrc_mac_reconfig->num_rbs_per_tbs_dci_1c[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_SI_TRANSMISSION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_si_transmission_info_list(
        &p_rrc_mac_reconfig->si_transmission_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_UL_SYNC_LOSS_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_reconfig->ul_sync_loss_timer, p_src + *p_length_read, "ul_sync_loss_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_reconfig->ul_sync_loss_timer > 12))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_reconfig->ul_sync_loss_timer] should be less than"
            " or equal to 12. Incorrect value %u received.", p_rrc_mac_reconfig->ul_sync_loss_timer);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_PUCCH_CQI_SINR_THRESHOLD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_reconfig->pucch_cqi_sinr_value, p_src + *p_length_read, "pucch_cqi_sinr_value");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_N_GAP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_reconfig->n_gap, p_src + *p_length_read, "n_gap");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_reconfig->n_gap > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_reconfig->n_gap] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_reconfig->n_gap);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_SPS_CRNTI_RANGE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_sps_crnti_range(
        &p_rrc_mac_reconfig->sps_crnti_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_reconfig->bitmask & RRC_RRM_RECONFIG_PRS_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_reconfig_info(
        &p_rrc_mac_reconfig->prs_reconfig_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_non_broadcast_config_info
(
    non_broadcast_config_info_t *p_non_broadcast_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_non_broadcast_config_info, 0, sizeof(non_broadcast_config_info_t));

    /* This function parses non_broadcast_config_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_non_broadcast_config_info->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_non_broadcast_config_info->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_recfg_phy_cell_parameters(
        &p_non_broadcast_config_info->cell_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_non_broadcast_config_info->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_sync_signals(
        &p_non_broadcast_config_info->sync_signals,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_non_broadcast_config_info->presence_bitmask & CELL_RECONFIG_REQ_API_MAC_RECONFIG_INFO_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_reconfig(
        &p_non_broadcast_config_info->mac_reconfig_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_downlink_power_control_common
(
    rrc_mac_downlink_power_control_common_t *p_rrc_mac_downlink_power_control_common,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_downlink_power_control_common, 0, sizeof(rrc_mac_downlink_power_control_common_t));

    /* This function parses rrc_mac_downlink_power_control_common */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_downlink_power_control_common->pcfichPowerOffset, p_src + *p_length_read, "pcfichPowerOffset");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_downlink_power_control_common->pcfichPowerOffset > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_downlink_power_control_common->pcfichPowerOffset] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_mac_downlink_power_control_common->pcfichPowerOffset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_downlink_power_control_common->phichPowerOffset, p_src + *p_length_read, "phichPowerOffset");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_downlink_power_control_common->phichPowerOffset > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_downlink_power_control_common->phichPowerOffset] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_mac_downlink_power_control_common->phichPowerOffset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_downlink_power_control_common->pdcchPowerOffset, p_src + *p_length_read, "pdcchPowerOffset");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_downlink_power_control_common->pdcchPowerOffset > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_downlink_power_control_common->pdcchPowerOffset] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_mac_downlink_power_control_common->pdcchPowerOffset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_downlink_power_control_common->pbchTransmissionPower, p_src + *p_length_read, "pbchTransmissionPower");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_downlink_power_control_common->pbchTransmissionPower > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_downlink_power_control_common->pbchTransmissionPower] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_mac_downlink_power_control_common->pbchTransmissionPower);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_downlink_power_control_common->pchTransmissionpower, p_src + *p_length_read, "pchTransmissionpower");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_downlink_power_control_common->pchTransmissionpower > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_downlink_power_control_common->pchTransmissionpower] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_mac_downlink_power_control_common->pchTransmissionpower);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_rand
(
    cdma2000_rand_t *p_cdma2000_rand,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_rand, 0, sizeof(cdma2000_rand_t));

    /* This function parses cdma2000_rand */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cdma2000_rand->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_cdma2000_rand->rand_seed, p_src + *p_length_read, "rand_seed");
    *p_length_read += sizeof(U32);

    if (p_cdma2000_rand->bitmask & CDMA2000_PARAM_RAND_MIN_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_cdma2000_rand->rand_min, p_src + *p_length_read, "rand_min");
    *p_length_read += sizeof(U32);
    }

    if (p_cdma2000_rand->bitmask & CDMA2000_PARAM_RAND_MAX_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_cdma2000_rand->rand_max, p_src + *p_length_read, "rand_max");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_cdma2000_rand->rand_regenerate_timer, p_src + *p_length_read, "rand_regenerate_timer");
    *p_length_read += sizeof(U32);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cdma2000_rand->rand_regenerate_timer < 1) || (p_cdma2000_rand->rand_regenerate_timer > 4294967))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_rand->rand_regenerate_timer] should be in range "
            "1 to 4294967. Incorrect value %u received.", p_cdma2000_rand->rand_regenerate_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_1xrtt_cell_identifier
(
    cdma2000_1xrtt_cell_identifier_t *p_cdma2000_1xrtt_cell_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_1xrtt_cell_identifier, 0, sizeof(cdma2000_1xrtt_cell_identifier_t));

    /* This function parses cdma2000_1xrtt_cell_identifier */

    if (*p_length_read + (S32)sizeof(p_cdma2000_1xrtt_cell_identifier->cdma2000_1xrtt_cell_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cdma2000_1xrtt_cell_identifier->cdma2000_1xrtt_cell_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cdma2000_1xrtt_cell_identifier->cdma2000_1xrtt_cell_id[loop], (void*)(p_src + *p_length_read), "cdma2000_1xrtt_cell_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd_sector_identifier
(
    cdma2000_hrpd_sector_identifier_t *p_cdma2000_hrpd_sector_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_hrpd_sector_identifier, 0, sizeof(cdma2000_hrpd_sector_identifier_t));

    /* This function parses cdma2000_hrpd_sector_identifier */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_hrpd_sector_identifier->sector_id_length, p_src + *p_length_read, "sector_id_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cdma2000_hrpd_sector_identifier->sector_id_length < 16) || (p_cdma2000_hrpd_sector_identifier->sector_id_length > MAX_SECTOR_ID_LENGTH))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_hrpd_sector_identifier->sector_id_length] should be in range "
            "16 to MAX_SECTOR_ID_LENGTH. Incorrect value %u received.", p_cdma2000_hrpd_sector_identifier->sector_id_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_cdma2000_hrpd_sector_identifier->sector_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cdma2000_hrpd_sector_identifier->sector_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cdma2000_hrpd_sector_identifier->sector_id[loop], (void*)(p_src + *p_length_read), "sector_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_1xrtt_ref_cell_identifier
(
    cdma2000_1xrtt_ref_cell_identifier_t *p_cdma2000_1xrtt_ref_cell_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_1xrtt_ref_cell_identifier, 0, sizeof(cdma2000_1xrtt_ref_cell_identifier_t));

    /* This function parses cdma2000_1xrtt_ref_cell_identifier */

    if (*p_length_read + (S32)sizeof(p_cdma2000_1xrtt_ref_cell_identifier->cdma2000_1xrtt_ref_cell_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cdma2000_1xrtt_ref_cell_identifier->cdma2000_1xrtt_ref_cell_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cdma2000_1xrtt_ref_cell_identifier->cdma2000_1xrtt_ref_cell_id[loop], (void*)(p_src + *p_length_read), "cdma2000_1xrtt_ref_cell_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd_ref_sector_identifier
(
    cdma2000_hrpd_ref_sector_identifier_t *p_cdma2000_hrpd_ref_sector_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_hrpd_ref_sector_identifier, 0, sizeof(cdma2000_hrpd_ref_sector_identifier_t));

    /* This function parses cdma2000_hrpd_ref_sector_identifier */

    if (*p_length_read + (S32)sizeof(p_cdma2000_hrpd_ref_sector_identifier->cdma2000_hrpd_ref_sector_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cdma2000_hrpd_ref_sector_identifier->cdma2000_hrpd_ref_sector_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cdma2000_hrpd_ref_sector_identifier->cdma2000_hrpd_ref_sector_id[loop], (void*)(p_src + *p_length_read), "cdma2000_hrpd_ref_sector_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_cell_param
(
    cdma2000_cell_param_t *p_cdma2000_cell_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cdma2000_cell_param, 0, sizeof(cdma2000_cell_param_t));

    /* This function parses cdma2000_cell_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cdma2000_cell_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cdma2000_rand(
        &p_cdma2000_cell_param->cdma2000_rand,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_cdma2000_cell_param->bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1xrtt_cell_identifier(
        &p_cdma2000_cell_param->cell_id_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cdma2000_cell_param->bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd_sector_identifier(
        &p_cdma2000_cell_param->sector_id_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cdma2000_cell_param->bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_cell_param->nw_in_sync, p_src + *p_length_read, "nw_in_sync");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_cell_param->nw_in_sync > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_cell_param->nw_in_sync] should be less than"
            " or equal to 1. Incorrect value %u received.", p_cdma2000_cell_param->nw_in_sync);
        return RRC_FAILURE;
    }
    }

    if (p_cdma2000_cell_param->bitmask & CDMA2000_PARAM_1XRTT_REFERENCE_CELL_ID_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1xrtt_ref_cell_identifier(
        &p_cdma2000_cell_param->ref_cell_id_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cdma2000_cell_param->bitmask & CDMA2000_PARAM_HRPD_REFERENCE_CELL_ID_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd_ref_sector_identifier(
        &p_cdma2000_cell_param->ref_sector_id_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_reconfig_resp
(
    rrc_rrm_cell_reconfig_resp_t *p_rrc_rrm_cell_reconfig_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_reconfig_resp, 0, sizeof(rrc_rrm_cell_reconfig_resp_t));

    /* This function parses rrc_rrm_cell_reconfig_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_reconfig_resp->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_reconfig_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_reconfig_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_reconfig_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_reconfig_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_reconfig_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_reconfig_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_reconfig_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_cell_reconfig_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_cell_reconfig_resp->presence_bitmask & CELL_RECONFIG_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_reconfig_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_reconfig_resp->fail_cause > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_reconfig_resp->fail_cause] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_rrm_cell_reconfig_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_setup_req
(
    rrc_rrm_cell_setup_req_t *p_rrc_rrm_cell_setup_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_setup_req, 0, sizeof(rrc_rrm_cell_setup_req_t));

    /* This function parses rrc_rrm_cell_setup_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_setup_req->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_setup_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_setup_req->cell_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_mib_info(
        &p_rrc_rrm_cell_setup_req->mib_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_1_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_sib_type_2_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_2_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_3_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_3_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 2)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_4_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_4_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 4)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_5_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_5_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 8)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_6_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_6_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 16)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_7_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_7_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 32)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_8_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_8_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 64)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_9_Info(
        &p_rrc_rrm_cell_setup_req->sib_type_9_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 512)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_13_info(
        &p_rrc_rrm_cell_setup_req->sib_type_13_Info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_cell_config(
        &p_rrc_rrm_cell_setup_req->cell_config_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_rrc_rrm_cell_setup_req->emergency_area_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_rrm_cell_setup_req->emergency_area_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_cell_setup_req->emergency_area_id[loop], (void*)(p_src + *p_length_read), "emergency_area_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 128)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_setup_req->explicit_start_required, p_src + *p_length_read, "explicit_start_required");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_req->explicit_start_required > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_req->explicit_start_required] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_cell_setup_req->explicit_start_required);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 256)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_cell_param(
        &p_rrc_rrm_cell_setup_req->cdma2000_cell_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 2048)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_setup_req->mbms_transmission_power, p_src + *p_length_read, "mbms_transmission_power");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_setup_req->mbms_transmission_power > 10000))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_setup_req->mbms_transmission_power] should be less than"
            " or equal to 10000. Incorrect value %u received.", p_rrc_rrm_cell_setup_req->mbms_transmission_power);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 4096)
    {

    if (RRC_FAILURE == rrc_il_parse_mbms_updated_area_info_list(
        &p_rrc_rrm_cell_setup_req->mbms_updated_area_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & 1024)
    {

    if (RRC_FAILURE == rrc_il_parse_m2ap_reserved_mcch_related_bcch_info_list(
        &p_rrc_rrm_cell_setup_req->m2ap_reserved_mcch_related_bcch_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_cell_setup_req->presence_bitmask & CELL_SETUP_REQ_API_EMTC_CELL_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_EmtcCellParam(
        &p_rrc_rrm_cell_setup_req->emtcCellParam,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cell_parameters
(
    rrc_phy_cell_parameters_t *p_rrc_phy_cell_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cell_parameters, 0, sizeof(rrc_phy_cell_parameters_t));

    /* This function parses rrc_phy_cell_parameters */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_phy_cell_parameters->dl_earfcn, p_src + *p_length_read, "dl_earfcn");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cell_parameters->num_of_antennas, p_src + *p_length_read, "num_of_antennas");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_cell_parameters->num_of_antennas < 1) || (p_rrc_phy_cell_parameters->num_of_antennas > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->num_of_antennas] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_phy_cell_parameters->num_of_antennas);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cell_parameters->subcarrier_spacing, p_src + *p_length_read, "subcarrier_spacing");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cell_parameters->subcarrier_spacing > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->subcarrier_spacing] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cell_parameters->subcarrier_spacing);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cell_parameters->dl_cyclic_prefix, p_src + *p_length_read, "dl_cyclic_prefix");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cell_parameters->dl_cyclic_prefix > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->dl_cyclic_prefix] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cell_parameters->dl_cyclic_prefix);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cell_parameters->rb_size, p_src + *p_length_read, "rb_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cell_parameters->rb_size > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->rb_size] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cell_parameters->rb_size);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cell_parameters->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cell_parameters->phys_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->phys_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_rrc_phy_cell_parameters->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cell_parameters->max_rs_epre, p_src + *p_length_read, "max_rs_epre");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cell_parameters->max_rs_epre > 160))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cell_parameters->max_rs_epre] should be less than"
            " or equal to 160. Incorrect value %u received.", p_rrc_phy_cell_parameters->max_rs_epre);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_dl_earfcn(
        &p_rrc_phy_cell_parameters->dl_earfcn_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_enable_frequency_selective_scheduling
(
    rrc_mac_enable_frequency_selective_scheduling_t *p_rrc_mac_enable_frequency_selective_scheduling,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_enable_frequency_selective_scheduling, 0, sizeof(rrc_mac_enable_frequency_selective_scheduling_t));

    /* This function parses rrc_mac_enable_frequency_selective_scheduling */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_enable_frequency_selective_scheduling->ul_freq_selective_enable, p_src + *p_length_read, "ul_freq_selective_enable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_enable_frequency_selective_scheduling->ul_freq_selective_enable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_enable_frequency_selective_scheduling->ul_freq_selective_enable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_enable_frequency_selective_scheduling->ul_freq_selective_enable);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_enable_frequency_selective_scheduling->dl_freq_selective_enable, p_src + *p_length_read, "dl_freq_selective_enable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_enable_frequency_selective_scheduling->dl_freq_selective_enable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_enable_frequency_selective_scheduling->dl_freq_selective_enable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_enable_frequency_selective_scheduling->dl_freq_selective_enable);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_tpc_rnti_range
(
    rrc_mac_tpc_rnti_range_t *p_rrc_mac_tpc_rnti_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_tpc_rnti_range, 0, sizeof(rrc_mac_tpc_rnti_range_t));

    /* This function parses rrc_mac_tpc_rnti_range */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_tpc_rnti_range->startTpcRntiPucch, p_src + *p_length_read, "startTpcRntiPucch");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_tpc_rnti_range->startTpcRntiPucch < 61) || (p_rrc_mac_tpc_rnti_range->startTpcRntiPucch > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_tpc_rnti_range->startTpcRntiPucch] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_mac_tpc_rnti_range->startTpcRntiPucch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_tpc_rnti_range->endTpcRntiPucch, p_src + *p_length_read, "endTpcRntiPucch");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_tpc_rnti_range->endTpcRntiPucch < 61) || (p_rrc_mac_tpc_rnti_range->endTpcRntiPucch > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_tpc_rnti_range->endTpcRntiPucch] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_mac_tpc_rnti_range->endTpcRntiPucch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_tpc_rnti_range->startTpcRntiPusch, p_src + *p_length_read, "startTpcRntiPusch");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_tpc_rnti_range->startTpcRntiPusch < 61) || (p_rrc_mac_tpc_rnti_range->startTpcRntiPusch > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_tpc_rnti_range->startTpcRntiPusch] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_mac_tpc_rnti_range->startTpcRntiPusch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_tpc_rnti_range->endTpcRntiPusch, p_src + *p_length_read, "endTpcRntiPusch");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_tpc_rnti_range->endTpcRntiPusch < 61) || (p_rrc_mac_tpc_rnti_range->endTpcRntiPusch > 65523))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_tpc_rnti_range->endTpcRntiPusch] should be in range "
            "61 to 65523. Incorrect value %u received.", p_rrc_mac_tpc_rnti_range->endTpcRntiPusch);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_power_control_enable
(
    rrc_mac_power_control_enable_t *p_rrc_mac_power_control_enable,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_power_control_enable, 0, sizeof(rrc_mac_power_control_enable_t));

    /* This function parses rrc_mac_power_control_enable */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_power_control_enable->harqBlerClpcPucchEnable, p_src + *p_length_read, "harqBlerClpcPucchEnable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_power_control_enable->harqBlerClpcPucchEnable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_power_control_enable->harqBlerClpcPucchEnable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_power_control_enable->harqBlerClpcPucchEnable);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_power_control_enable->cqiSinrClpcPucchEnable, p_src + *p_length_read, "cqiSinrClpcPucchEnable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_power_control_enable->cqiSinrClpcPucchEnable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_power_control_enable->cqiSinrClpcPucchEnable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_power_control_enable->cqiSinrClpcPucchEnable);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_power_control_enable->clpcPuschEnable, p_src + *p_length_read, "clpcPuschEnable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_power_control_enable->clpcPuschEnable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_power_control_enable->clpcPuschEnable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_power_control_enable->clpcPuschEnable);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_power_control_enable->pdcchPowOrAggregationEnable, p_src + *p_length_read, "pdcchPowOrAggregationEnable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_power_control_enable->pdcchPowOrAggregationEnable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_power_control_enable->pdcchPowOrAggregationEnable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_power_control_enable->pdcchPowOrAggregationEnable);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_power_control_enable->clpcPuschfreqSelectiveEnable, p_src + *p_length_read, "clpcPuschfreqSelectiveEnable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_power_control_enable->clpcPuschfreqSelectiveEnable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_power_control_enable->clpcPuschfreqSelectiveEnable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_power_control_enable->clpcPuschfreqSelectiveEnable);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config
(
    rrc_rrm_prs_config_t *p_rrc_rrm_prs_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_config, 0, sizeof(rrc_rrm_prs_config_t));

    /* This function parses rrc_rrm_prs_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_bandwidth_info(
        &p_rrc_rrm_prs_config->prs_bandwidth_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_subframes_info(
        &p_rrc_rrm_prs_config->prs_subframes_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_config_index_info(
        &p_rrc_rrm_prs_config->prs_config_index_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_transmission_power_info(
        &p_rrc_rrm_prs_config->prs_transmission_power_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_prs_config->bitmask & RRC_RRM_CONFIG_PRS_MUTING_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_muting_config_info(
        &p_rrc_rrm_prs_config->prs_muting_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_prs_config_info
(
    rrc_rrm_prs_config_info_t *p_rrc_rrm_prs_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_prs_config_info, 0, sizeof(rrc_rrm_prs_config_info_t));

    /* This function parses rrc_rrm_prs_config_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_prs_config_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_prs_config_info->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_prs_config_info->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_prs_config_info->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_prs_config_info->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_prs_config_info->bitmask & RRC_RRM_CONFIG_PRS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_config(
        &p_rrc_rrm_prs_config_info->prs_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_mocn_operator_info
(
    rrc_rrm_mocn_operator_info_t *p_rrc_rrm_mocn_operator_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_mocn_operator_info, 0, sizeof(rrc_rrm_mocn_operator_info_t));

    /* This function parses rrc_rrm_mocn_operator_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_mocn_operator_info->num_operator_info, p_src + *p_length_read, "num_operator_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_mocn_operator_info->num_operator_info < 2) || (p_rrc_rrm_mocn_operator_info->num_operator_info > MAX_PLMN_IDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_mocn_operator_info->num_operator_info] should be in range "
            "2 to MAX_PLMN_IDS. Incorrect value %u received.", p_rrc_rrm_mocn_operator_info->num_operator_info);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_rrm_mocn_operator_info->num_operator_info * sizeof(p_rrc_rrm_mocn_operator_info->operator_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_mocn_operator_info->num_operator_info; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_mocn_operator_info->operator_id[loop], (void*)(p_src + *p_length_read), "operator_id[]");
            if (p_rrc_rrm_mocn_operator_info->operator_id[loop] > 5)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_rrm_mocn_operator_info->operator_id[%u] should be less"
                    " than or equal to 5. "
                    "Incorrect value %d received.", loop, p_rrc_rrm_mocn_operator_info->operator_id[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sib13_scheduling_info
(
    sib13_scheduling_info_t *p_sib13_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sib13_scheduling_info, 0, sizeof(sib13_scheduling_info_t));

    /* This function parses sib13_scheduling_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sib13_scheduling_info->si_index, p_src + *p_length_read, "si_index");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_laa_scell_config
(
    rrc_radio_res_dedicated_laa_scell_config_t *p_rrc_radio_res_dedicated_laa_scell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_dedicated_laa_scell_config, 0, sizeof(rrc_radio_res_dedicated_laa_scell_config_t));

    /* This function parses rrc_radio_res_dedicated_laa_scell_config */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_radio_res_dedicated_laa_scell_config->subframe_start_position, p_src + *p_length_read, "subframe_start_position");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_radio_res_dedicated_laa_scell_config->subframe_start_position > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_radio_res_dedicated_laa_scell_config->subframe_start_position] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_radio_res_dedicated_laa_scell_config->subframe_start_position);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_radio_res_dedicated_laa_scell_config->laa_scell_subframe_config, p_src + *p_length_read, "laa_scell_subframe_config");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_radio_res_dedicated_laa_scell_config->laa_scell_subframe_config > 255))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_radio_res_dedicated_laa_scell_config->laa_scell_subframe_config] should be less than"
            " or equal to 255. Incorrect value %u received.", p_rrc_radio_res_dedicated_laa_scell_config->laa_scell_subframe_config);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_dmtc_configuration_r13
(
    rrc_dmtc_configuration_r13_t *p_rrc_dmtc_configuration_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_dmtc_configuration_r13, 0, sizeof(rrc_dmtc_configuration_r13_t));

    /* This function parses rrc_dmtc_configuration_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_dmtc_configuration_r13->dmtc_periodicity, p_src + *p_length_read, "dmtc_periodicity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_dmtc_configuration_r13->dmtc_periodicity > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_dmtc_configuration_r13->dmtc_periodicity] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_dmtc_configuration_r13->dmtc_periodicity);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_dmtc_configuration_r13->dmtc_offset, p_src + *p_length_read, "dmtc_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_dmtc_configuration_r13->dmtc_offset > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_dmtc_configuration_r13->dmtc_offset] should be less than"
            " or equal to 159. Incorrect value %u received.", p_rrc_dmtc_configuration_r13->dmtc_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_dmtc_configuration_r13->ds_occassion_duration, p_src + *p_length_read, "ds_occassion_duration");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_dmtc_configuration_r13->ds_occassion_duration > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_dmtc_configuration_r13->ds_occassion_duration] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_dmtc_configuration_r13->ds_occassion_duration);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_config
(
    rrc_mac_config_t *p_rrc_mac_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_config, 0, sizeof(rrc_mac_config_t));

    /* This function parses rrc_mac_config */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_mac_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->dl_res_blocks, p_src + *p_length_read, "dl_res_blocks");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->dl_res_blocks < 1) || (p_rrc_mac_config->dl_res_blocks > 100))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->dl_res_blocks] should be in range "
            "1 to 100. Incorrect value %u received.", p_rrc_mac_config->dl_res_blocks);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->ul_res_blocks, p_src + *p_length_read, "ul_res_blocks");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->ul_res_blocks < 1) || (p_rrc_mac_config->ul_res_blocks > 100))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->ul_res_blocks] should be in range "
            "1 to 100. Incorrect value %u received.", p_rrc_mac_config->ul_res_blocks);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->max_harq_retrans, p_src + *p_length_read, "max_harq_retrans");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->max_harq_retrans < 1) || (p_rrc_mac_config->max_harq_retrans > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->max_harq_retrans] should be in range "
            "1 to 8. Incorrect value %u received.", p_rrc_mac_config->max_harq_retrans);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->start_ra_rnti_range, p_src + *p_length_read, "start_ra_rnti_range");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->start_ra_rnti_range < 1) || (p_rrc_mac_config->start_ra_rnti_range > 60))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->start_ra_rnti_range] should be in range "
            "1 to 60. Incorrect value %u received.", p_rrc_mac_config->start_ra_rnti_range);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->end_ra_rnti_range, p_src + *p_length_read, "end_ra_rnti_range");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->end_ra_rnti_range < 1) || (p_rrc_mac_config->end_ra_rnti_range > 60))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->end_ra_rnti_range] should be in range "
            "1 to 60. Incorrect value %u received.", p_rrc_mac_config->end_ra_rnti_range);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->dci_format_for_si_msgs, p_src + *p_length_read, "dci_format_for_si_msgs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_config->dci_format_for_si_msgs > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->dci_format_for_si_msgs] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_config->dci_format_for_si_msgs);
        return RRC_FAILURE;
    }

    if (p_rrc_mac_config->bitmask & RRC_MAC_ENABLE_FREQUENCY_SELECTIVE_SCHEDULING_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_enable_frequency_selective_scheduling(
        &p_rrc_mac_config->enable_frequency_selective_scheduling,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_downlink_power_control_common(
        &p_rrc_mac_config->downlink_power_control_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_mac_config->bitmask & RRC_MAC_TPC_RNTI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_tpc_rnti_range(
        &p_rrc_mac_config->tpc_rnti_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_MAC_POWER_CONTROL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_power_control_enable(
        &p_rrc_mac_config->power_control_enable,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_CONTENTION_FREE_RACH_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_config->contention_free_rach_timer, p_src + *p_length_read, "contention_free_rach_timer");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_mac_config->bitmask & 32)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_mac_config->num_rbs_per_tbs_dci_1a) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_mac_config->num_rbs_per_tbs_dci_1a); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_mac_config->num_rbs_per_tbs_dci_1a[loop], (void*)(p_src + *p_length_read), "num_rbs_per_tbs_dci_1a[]");
            if (p_rrc_mac_config->num_rbs_per_tbs_dci_1a[loop] > 100)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_mac_config->num_rbs_per_tbs_dci_1a[%u] should be less"
                    " than or equal to 100. "
                    "Incorrect value %d received.", loop, p_rrc_mac_config->num_rbs_per_tbs_dci_1a[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_mac_config->bitmask & 64)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_mac_config->num_rbs_per_tbs_dci_1c) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_mac_config->num_rbs_per_tbs_dci_1c); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_mac_config->num_rbs_per_tbs_dci_1c[loop], (void*)(p_src + *p_length_read), "num_rbs_per_tbs_dci_1c[]");
            if (p_rrc_mac_config->num_rbs_per_tbs_dci_1c[loop] > 100)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_mac_config->num_rbs_per_tbs_dci_1c[%u] should be less"
                    " than or equal to 100. "
                    "Incorrect value %d received.", loop, p_rrc_mac_config->num_rbs_per_tbs_dci_1c[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_SI_TRANSMISSION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_si_transmission_info_list(
        &p_rrc_mac_config->si_transmission_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_UL_SYNC_LOSS_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->ul_sync_loss_timer, p_src + *p_length_read, "ul_sync_loss_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_config->ul_sync_loss_timer > 12))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->ul_sync_loss_timer] should be less than"
            " or equal to 12. Incorrect value %u received.", p_rrc_mac_config->ul_sync_loss_timer);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_PUCCH_CQI_SINR_THRESHOLD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->pucch_cqi_sinr_value, p_src + *p_length_read, "pucch_cqi_sinr_value");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_N_GAP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->n_gap, p_src + *p_length_read, "n_gap");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_config->n_gap > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->n_gap] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_config->n_gap);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_SPS_CRNTI_RANGE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_sps_crnti_range(
        &p_rrc_mac_config->sps_crnti_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_DUPLEXING_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->duplexing_mode, p_src + *p_length_read, "duplexing_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_config->duplexing_mode > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->duplexing_mode] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_mac_config->duplexing_mode);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_IS_DYNAMIC_PDCCH_DISABLED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->dynamic_pdcch, p_src + *p_length_read, "dynamic_pdcch");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_config->dynamic_pdcch > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->dynamic_pdcch] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_config->dynamic_pdcch);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_PRS_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_prs_config_info(
        &p_rrc_mac_config->prs_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_MOCN_OPERATOR_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_mocn_operator_info(
        &p_rrc_mac_config->mocn_operator_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_SIB_13_INFO_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib_type_13_info(
        &p_rrc_mac_config->sib_type_13_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_EMBMS_AREA_INFO_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_mbms_updated_area_info_list(
        &p_rrc_mac_config->mbms_updated_area_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_MCCH_CELL_RESERVATION_INFO_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_m2ap_reserved_mcch_related_bcch_info_list(
        &p_rrc_mac_config->m2ap_reserved_mcch_related_bcch_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_EMBMS_TRANSMISSION_POWER_INFO_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_config->mbms_transmission_power, p_src + *p_length_read, "mbms_transmission_power");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_SIB_13_INFO_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_sib13_scheduling_info(
        &p_rrc_mac_config->sib13_scheduling_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_config->cfi_value, p_src + *p_length_read, "cfi_value");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_mac_config->cfi_value < 1) || (p_rrc_mac_config->cfi_value > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_config->cfi_value] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_mac_config->cfi_value);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_config->num_of_eul, p_src + *p_length_read, "num_of_eul");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_config->size_of_eul, p_src + *p_length_read, "size_of_eul");
    *p_length_read += sizeof(U16);

    if (p_rrc_mac_config->bitmask & RRC_RRM_LAA_SCELL_CONFIGURATION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_dedicated_laa_scell_config(
        &p_rrc_mac_config->laa_scell_configuration_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_config->bitmask & RRC_RRM_DMTC_CONFIGURATION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_dmtc_configuration_r13(
        &p_rrc_mac_config->dmtc_configuration_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_l2_comm_info
(
    rrc_l2_comm_info_t *p_rrc_l2_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_l2_comm_info, 0, sizeof(rrc_l2_comm_info_t));

    /* This function parses rrc_l2_comm_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_l2_comm_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_l2_comm_info->port, p_src + *p_length_read, "port");
    *p_length_read += sizeof(U16);

    if (p_rrc_l2_comm_info->bitmask & RRC_RRM_DATA_PORT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_l2_comm_info->data_port, p_src + *p_length_read, "data_port");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_l2_comm_info->bitmask & RRC_RRM_IPV4_ADDRESS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_l2_comm_info->ip_addr) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_l2_comm_info->ip_addr); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_l2_comm_info->ip_addr[loop], (void*)(p_src + *p_length_read), "ip_addr[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_l2_comm_info->bitmask & RRC_RRM_IPV6_ADDRESS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_l2_comm_info->ip_addr6) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_l2_comm_info->ip_addr6); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_l2_comm_info->ip_addr6[loop], (void*)(p_src + *p_length_read), "ip_addr6[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pdcp_comm_info
(
    rrc_pdcp_comm_info_t *p_rrc_pdcp_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_pdcp_comm_info, 0, sizeof(rrc_pdcp_comm_info_t));

    /* This function parses rrc_pdcp_comm_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_comm_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_comm_info->port, p_src + *p_length_read, "port");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_comm_info->data_port_to_rlc, p_src + *p_length_read, "data_port_to_rlc");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_comm_info->data_port_to_egtpu, p_src + *p_length_read, "data_port_to_egtpu");
    *p_length_read += sizeof(U16);

    if (p_rrc_pdcp_comm_info->bitmask & RRC_RRM_IPV4_ADDRESS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_pdcp_comm_info->ip_addr) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_pdcp_comm_info->ip_addr); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_pdcp_comm_info->ip_addr[loop], (void*)(p_src + *p_length_read), "ip_addr[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_pdcp_comm_info->bitmask & RRC_RRM_IPV6_ADDRESS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_pdcp_comm_info->ip_addr6) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_pdcp_comm_info->ip_addr6); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_pdcp_comm_info->ip_addr6[loop], (void*)(p_src + *p_length_read), "ip_addr6[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_lower_layer_comm_info
(
    rrc_lower_layer_comm_info_t *p_rrc_lower_layer_comm_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_lower_layer_comm_info, 0, sizeof(rrc_lower_layer_comm_info_t));

    /* This function parses rrc_lower_layer_comm_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_lower_layer_comm_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrc_l2_comm_info(
        &p_rrc_lower_layer_comm_info->mac_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_l2_comm_info(
        &p_rrc_lower_layer_comm_info->rlc_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_lower_layer_comm_info->bitmask & RRC_RRM_CRAN_PDCP_COMM_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_comm_info(
        &p_rrc_lower_layer_comm_info->cran_pdcp_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_lower_layer_comm_info->bitmask & RRC_RRM_NON_CRAN_PDCP_COMM_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_l2_comm_info(
        &p_rrc_lower_layer_comm_info->pdcp_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_l2_comm_info(
        &p_rrc_lower_layer_comm_info->egtpu_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_l2_comm_info(
        &p_rrc_lower_layer_comm_info->phy_comm_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_cell_config
(
    rrc_rrm_cell_config_t *p_rrc_rrm_cell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_config, 0, sizeof(rrc_rrm_cell_config_t));

    /* This function parses rrc_rrm_cell_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cell_parameters(
        &p_rrc_rrm_cell_config->cell_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_sync_signals(
        &p_rrc_rrm_cell_config->sync_signals,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_config(
        &p_rrc_rrm_cell_config->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_lower_layer_comm_info(
        &p_rrc_rrm_cell_config->l2_comm_info_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_cell_config->bitmask & RRC_RRM_ASSOCIATED_LAYER2_INST_FIELD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_config->associated_layer2_inst, p_src + *p_length_read, "associated_layer2_inst");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_rrm_cell_config->bitmask & RRC_RRM_ASSOCIATED_PDCP_INST_FIELD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_config->associated_pdcp_inst, p_src + *p_length_read, "associated_pdcp_inst");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_rrm_cell_config->bitmask & RRC_RRM_ASSOCIATED_RLC_INST_FIELD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_config->associated_rlc_inst, p_src + *p_length_read, "associated_rlc_inst");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_rrm_cell_config->bitmask & RRC_RRM_ASSOCIATED_MAC_INST_FIELD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_config->associated_mac_inst, p_src + *p_length_read, "associated_mac_inst");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcUeSpecificNarrowbands
(
    RrcUeSpecificNarrowbands *p_RrcUeSpecificNarrowbands,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RrcUeSpecificNarrowbands, 0, sizeof(RrcUeSpecificNarrowbands));

    /* This function parses RrcUeSpecificNarrowbands */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands, p_src + *p_length_read, "numUeSpecificNarrowbands");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands < 1) || (p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands > EMTC_MAX_AVAILABLE_NARROWBAND))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands] should be in range "
            "1 to EMTC_MAX_AVAILABLE_NARROWBAND. Incorrect value %u received.", p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands * sizeof(p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_RrcUeSpecificNarrowbands->numUeSpecificNarrowbands; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[loop], (void*)(p_src + *p_length_read), "ueSpecificNarrowbands[]");
            if ((p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[loop] < 1) || (p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[loop] > EMTC_MAX_AVAILABLE_NARROWBAND))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[%u] should be in "
                    "range 1 to EMTC_MAX_AVAILABLE_NARROWBAND. "
                    "Incorrect value %d received.", loop, p_RrcUeSpecificNarrowbands->ueSpecificNarrowbands[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_EmtcCellParam
(
    EmtcCellParam *p_EmtcCellParam,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_EmtcCellParam, 0, sizeof(EmtcCellParam));

    /* This function parses EmtcCellParam */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EmtcCellParam->operationMode, p_src + *p_length_read, "operationMode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_EmtcCellParam->operationMode < 1) || (p_EmtcCellParam->operationMode > EMTC_OPERATION_MODE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_EmtcCellParam->operationMode] should be in range "
            "1 to EMTC_OPERATION_MODE_MAX. Incorrect value %u received.", p_EmtcCellParam->operationMode);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EmtcCellParam->duplexingMode, p_src + *p_length_read, "duplexingMode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_EmtcCellParam->duplexingMode > EMTC_DUPLEXING_MODE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_EmtcCellParam->duplexingMode] should be less than"
            " or equal to EMTC_DUPLEXING_MODE_MAX. Incorrect value %u received.", p_EmtcCellParam->duplexingMode);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EmtcCellParam->transmissionType, p_src + *p_length_read, "transmissionType");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_EmtcCellParam->transmissionType > EMTC_TRANSMISSION_TYPE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_EmtcCellParam->transmissionType] should be less than"
            " or equal to EMTC_TRANSMISSION_TYPE_MAX. Incorrect value %u received.", p_EmtcCellParam->transmissionType);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_RrcUeSpecificNarrowbands(
        &p_EmtcCellParam->ueSpecificNarrowbands,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_admission_req
(
    rrc_rrm_ue_admission_req_t *p_rrc_rrm_ue_admission_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_admission_req, 0, sizeof(rrc_rrm_ue_admission_req_t));

    /* This function parses rrc_rrm_ue_admission_req */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_initial_ue_identity(
        &p_rrc_rrm_ue_admission_req->ue_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_req->establishment_cause, p_src + *p_length_read, "establishment_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_req->establishment_cause > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_req->establishment_cause] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_rrm_ue_admission_req->establishment_cause);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_req->timing_advance, p_src + *p_length_read, "timing_advance");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_req->timing_advance > 1282))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_req->timing_advance] should be less than"
            " or equal to 1282. Incorrect value %u received.", p_rrc_rrm_ue_admission_req->timing_advance);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_req->sinr, p_src + *p_length_read, "sinr");
    *p_length_read += sizeof(U8);

    if (p_rrc_rrm_ue_admission_req->bitmask & RRC_RRM_UE_ADMISSION_REQ_CE_LEVEL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_req->ceLevel, p_src + *p_length_read, "ceLevel");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_req->ceLevel > EMTC_CE_LEVEL_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_req->ceLevel] should be less than"
            " or equal to EMTC_CE_LEVEL_MAX. Incorrect value %u received.", p_rrc_rrm_ue_admission_req->ceLevel);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_s_tmsi
(
    rrc_s_tmsi_t *p_rrc_s_tmsi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_s_tmsi, 0, sizeof(rrc_s_tmsi_t));

    /* This function parses rrc_s_tmsi */

    if (*p_length_read + (S32)sizeof(p_rrc_s_tmsi->mmec) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_s_tmsi->mmec); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_s_tmsi->mmec[loop], (void*)(p_src + *p_length_read), "mmec[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_rrc_s_tmsi->m_tmsi) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_s_tmsi->m_tmsi); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_s_tmsi->m_tmsi[loop], (void*)(p_src + *p_length_read), "m_tmsi[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_initial_ue_identity
(
    rrc_initial_ue_identity_t *p_rrc_initial_ue_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_initial_ue_identity, 0, sizeof(rrc_initial_ue_identity_t));

    /* This function parses rrc_initial_ue_identity */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_initial_ue_identity->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_initial_ue_identity->bitmask & RRC_INITIAL_UE_IDENTITY_S_TMSI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_s_tmsi(
        &p_rrc_initial_ue_identity->s_tmsi,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_initial_ue_identity->bitmask & RRC_INITIAL_UE_IDENTITY_RANDOM_VALUE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_initial_ue_identity->random_value) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_initial_ue_identity->random_value); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_initial_ue_identity->random_value[loop], (void*)(p_src + *p_length_read), "random_value[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_admission_resp
(
    rrc_rrm_ue_admission_resp_t *p_rrc_rrm_ue_admission_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_admission_resp, 0, sizeof(rrc_rrm_ue_admission_resp_t));

    /* This function parses rrc_rrm_ue_admission_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_resp->wait_time, p_src + *p_length_read, "wait_time");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_ue_admission_resp->wait_time < 1) || (p_rrc_rrm_ue_admission_resp->wait_time > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_resp->wait_time] should be in range "
            "1 to 16. Incorrect value %u received.", p_rrc_rrm_ue_admission_resp->wait_time);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_admission_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_admission_resp->bitmask & RRM_UE_ADM_RESP_API_UE_ADM_RADIO_RESP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_adm_radio_res_config(
        &p_rrc_rrm_ue_admission_resp->radio_res_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_admission_resp->bitmask & RRM_UE_ADM_RESP_API_UE_ADM_EXTENDED_WAIT_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_resp->extended_wait_time, p_src + *p_length_read, "extended_wait_time");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_ue_admission_resp->extended_wait_time < 1) || (p_rrc_rrm_ue_admission_resp->extended_wait_time > 1800))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_resp->extended_wait_time] should be in range "
            "1 to 1800. Incorrect value %u received.", p_rrc_rrm_ue_admission_resp->extended_wait_time);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ue_admission_resp->bitmask & RRM_UE_ADM_RESP_API_FAIL_CAUSE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_resp->fail_cause > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_resp->fail_cause] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_admission_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ue_admission_resp->bitmask & RRM_UE_ADM_RESP_API_EMTC_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcRrmAdmissionEmtcConfigInfo(
        &p_rrc_rrm_ue_admission_resp->admissionEmtcConfigInfo,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_uplink_am_rlc
(
    rrc_uplink_am_rlc_t *p_rrc_uplink_am_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_uplink_am_rlc, 0, sizeof(rrc_uplink_am_rlc_t));

    /* This function parses rrc_uplink_am_rlc */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->t_poll_retransmit, p_src + *p_length_read, "t_poll_retransmit");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_am_rlc->t_poll_retransmit > 54))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_am_rlc->t_poll_retransmit] should be less than"
            " or equal to 54. Incorrect value %u received.", p_rrc_uplink_am_rlc->t_poll_retransmit);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->poll_pdu, p_src + *p_length_read, "poll_pdu");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_am_rlc->poll_pdu > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_am_rlc->poll_pdu] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_uplink_am_rlc->poll_pdu);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->poll_byte, p_src + *p_length_read, "poll_byte");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_am_rlc->poll_byte > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_am_rlc->poll_byte] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_uplink_am_rlc->poll_byte);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->max_retx_threshold, p_src + *p_length_read, "max_retx_threshold");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_am_rlc->max_retx_threshold > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_am_rlc->max_retx_threshold] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_uplink_am_rlc->max_retx_threshold);
        return RRC_FAILURE;
    }

    if (p_rrc_uplink_am_rlc->bitmask & RRC_RRM_T_POLL_RETRANSMIT_EMTC_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_am_rlc->t_poll_retransmit_emtc, p_src + *p_length_read, "t_poll_retransmit_emtc");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_am_rlc->t_poll_retransmit_emtc > 54))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_am_rlc->t_poll_retransmit_emtc] should be less than"
            " or equal to 54. Incorrect value %u received.", p_rrc_uplink_am_rlc->t_poll_retransmit_emtc);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_downlink_am_rlc
(
    rrc_downlink_am_rlc_t *p_rrc_downlink_am_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_downlink_am_rlc, 0, sizeof(rrc_downlink_am_rlc_t));

    /* This function parses rrc_downlink_am_rlc */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_downlink_am_rlc->t_reordering, p_src + *p_length_read, "t_reordering");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_downlink_am_rlc->t_reordering > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_downlink_am_rlc->t_reordering] should be less than"
            " or equal to 30. Incorrect value %u received.", p_rrc_downlink_am_rlc->t_reordering);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_downlink_am_rlc->t_status_prohibit, p_src + *p_length_read, "t_status_prohibit");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_downlink_am_rlc->t_status_prohibit > 55))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_downlink_am_rlc->t_status_prohibit] should be less than"
            " or equal to 55. Incorrect value %u received.", p_rrc_downlink_am_rlc->t_status_prohibit);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_am_config
(
    rrc_am_config_t *p_rrc_am_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_am_config, 0, sizeof(rrc_am_config_t));

    /* This function parses rrc_am_config */

    if (RRC_FAILURE == rrc_il_parse_rrc_uplink_am_rlc(
        &p_rrc_am_config->ul_am_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_downlink_am_rlc(
        &p_rrc_am_config->dl_am_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_srb_am_config
(
    rrm_srb_am_config_t *p_rrm_srb_am_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_srb_am_config, 0, sizeof(rrm_srb_am_config_t));

    /* This function parses rrm_srb_am_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_srb_am_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_srb_am_config->bitmask & RRM_SRB_AM_CONFIG_EXPLICIT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_am_config(
        &p_rrm_srb_am_config->am_config_explicit,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_ul_specific_parameters
(
    rrc_ul_specific_parameters_t *p_rrc_ul_specific_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_ul_specific_parameters, 0, sizeof(rrc_ul_specific_parameters_t));

    /* This function parses rrc_ul_specific_parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_ul_specific_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_specific_parameters->priority, p_src + *p_length_read, "priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_specific_parameters->priority > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_specific_parameters->priority] should be less than"
            " or equal to 16. Incorrect value %u received.", p_rrc_ul_specific_parameters->priority);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_specific_parameters->prioritized_bit_rate, p_src + *p_length_read, "prioritized_bit_rate");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_specific_parameters->prioritized_bit_rate > 10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_specific_parameters->prioritized_bit_rate] should be less than"
            " or equal to 10. Incorrect value %u received.", p_rrc_ul_specific_parameters->prioritized_bit_rate);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_specific_parameters->bucket_size_duration, p_src + *p_length_read, "bucket_size_duration");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_specific_parameters->bucket_size_duration > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_specific_parameters->bucket_size_duration] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_ul_specific_parameters->bucket_size_duration);
        return RRC_FAILURE;
    }

    if (p_rrc_ul_specific_parameters->bitmask & RRC_UL_SPECIFIC_PARAMETERS_LOGICAL_CH_GROUP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_specific_parameters->logical_channel_group, p_src + *p_length_read, "logical_channel_group");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_specific_parameters->logical_channel_group > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_specific_parameters->logical_channel_group] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_ul_specific_parameters->logical_channel_group);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_logical_channel_config
(
    rrm_logical_channel_config_t *p_rrm_logical_channel_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_logical_channel_config, 0, sizeof(rrm_logical_channel_config_t));

    /* This function parses rrm_logical_channel_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_logical_channel_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_logical_channel_config->bitmask & RRM_UL_SPECIFIC_PARAMETERS_EXPLICIT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_ul_specific_parameters(
        &p_rrm_logical_channel_config->ul_specific_parameters_explicit,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_logical_channel_config->bitmask & RRM_UL_SPECIFIC_PARAMETERS_LC_SR_MASK_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_logical_channel_config->lc_sr_mask_r9, p_src + *p_length_read, "lc_sr_mask_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_logical_channel_config->lc_sr_mask_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_logical_channel_config->lc_sr_mask_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_logical_channel_config->lc_sr_mask_r9);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_ca_lc_bandwidth_dist_info
(
    rrc_mac_ca_lc_bandwidth_dist_info_t *p_rrc_mac_ca_lc_bandwidth_dist_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_ca_lc_bandwidth_dist_info, 0, sizeof(rrc_mac_ca_lc_bandwidth_dist_info_t));

    /* This function parses rrc_mac_ca_lc_bandwidth_dist_info */

    if (*p_length_read + (S32)sizeof(p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution[loop], (void*)(p_src + *p_length_read), "band_width_distribution[]");
            if (p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution[loop] > 100)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution[%u] should be less"
                    " than or equal to 100. "
                    "Incorrect value %d received.", loop, p_rrc_mac_ca_lc_bandwidth_dist_info->band_width_distribution[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_mac_lc_config
(
    rrm_mac_lc_config_t *p_rrm_mac_lc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_mac_lc_config, 0, sizeof(rrm_mac_lc_config_t));

    /* This function parses rrm_mac_lc_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_mac_lc_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_mac_lc_config->bitmask & RRM_MAC_LC_CONFIG_UL_LC_G_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_lc_config->ul_lc_g_id, p_src + *p_length_read, "ul_lc_g_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_lc_config->ul_lc_g_id > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_lc_config->ul_lc_g_id] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrm_mac_lc_config->ul_lc_g_id);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_lc_config->bitmask & RRM_MAC_LC_CONFIG_DL_PRIORITY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_lc_config->dl_lch_priority, p_src + *p_length_read, "dl_lch_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_lc_config->dl_lch_priority > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_lc_config->dl_lch_priority] should be less than"
            " or equal to 16. Incorrect value %u received.", p_rrm_mac_lc_config->dl_lch_priority);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_lc_config->bitmask & RRM_MAC_CA_LC_BANDWIDTH_DIST_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_ca_lc_bandwidth_dist_info(
        &p_rrm_mac_lc_config->ca_lc_bandwidth_dist_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_srb_config
(
    rrm_srb_config_t *p_rrm_srb_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_srb_config, 0, sizeof(rrm_srb_config_t));

    /* This function parses rrm_srb_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_srb_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_srb_config->bitmask & RRM_SRB_CONFIG_AM_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_am_config(
        &p_rrm_srb_config->srb_am_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_srb_config->bitmask & RRM_SRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_logical_channel_config(
        &p_rrm_srb_config->logical_channel_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_srb_config->bitmask & RRM_SRB_CONFIG_MAC_LC_CONFIG_ENB_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_lc_config(
        &p_rrm_srb_config->mac_lc_config_enb,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_srb_info
(
    rrm_srb_info_t *p_rrm_srb_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_srb_info, 0, sizeof(rrm_srb_info_t));

    /* This function parses rrm_srb_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_srb_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_srb_info->bitmask & RRM_SRB_INFO_SRB1_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_config(
        &p_rrm_srb_info->srb1_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_srb_info->bitmask & RRM_SRB_INFO_SRB2_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_config(
        &p_rrm_srb_info->srb2_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_ul_sch_config
(
    rrc_ul_sch_config_t *p_rrc_ul_sch_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_ul_sch_config, 0, sizeof(rrc_ul_sch_config_t));

    /* This function parses rrc_ul_sch_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_ul_sch_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_ul_sch_config->bitmask & RRC_UL_SCH_CONFIG_MAX_HARQ_TX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_sch_config->max_harq_tx, p_src + *p_length_read, "max_harq_tx");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_sch_config->max_harq_tx > 13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_sch_config->max_harq_tx] should be less than"
            " or equal to 13. Incorrect value %u received.", p_rrc_ul_sch_config->max_harq_tx);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_ul_sch_config->bitmask & RRC_UL_SCH_CONFIG_PERIODIC_BSR_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_sch_config->periodic_bsr_timer, p_src + *p_length_read, "periodic_bsr_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_sch_config->periodic_bsr_timer > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_sch_config->periodic_bsr_timer] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_ul_sch_config->periodic_bsr_timer);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_sch_config->retx_bsr_timer, p_src + *p_length_read, "retx_bsr_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_sch_config->retx_bsr_timer > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_sch_config->retx_bsr_timer] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_ul_sch_config->retx_bsr_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_ul_sch_config->tti_bundling, p_src + *p_length_read, "tti_bundling");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_ul_sch_config->tti_bundling > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_ul_sch_config->tti_bundling] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_ul_sch_config->tti_bundling);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_long_drx_cycle_start_offset
(
    rrc_long_drx_cycle_start_offset_t *p_rrc_long_drx_cycle_start_offset,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_long_drx_cycle_start_offset, 0, sizeof(rrc_long_drx_cycle_start_offset_t));

    /* This function parses rrc_long_drx_cycle_start_offset */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_10, p_src + *p_length_read, "sf_10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_10 > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_10] should be less than"
            " or equal to 9. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_10);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_20_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_20, p_src + *p_length_read, "sf_20");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_20 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_20] should be less than"
            " or equal to 19. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_20);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_32_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_32, p_src + *p_length_read, "sf_32");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_32 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_32] should be less than"
            " or equal to 31. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_32);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_40_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_40, p_src + *p_length_read, "sf_40");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_40 > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_40] should be less than"
            " or equal to 39. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_40);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_64_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_64, p_src + *p_length_read, "sf_64");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_64 > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_64] should be less than"
            " or equal to 63. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_64);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_80_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_80, p_src + *p_length_read, "sf_80");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_80 > 79))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_80] should be less than"
            " or equal to 79. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_80);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_128_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_128, p_src + *p_length_read, "sf_128");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_128 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_128] should be less than"
            " or equal to 127. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_128);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_160_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_160, p_src + *p_length_read, "sf_160");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_160 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_160] should be less than"
            " or equal to 159. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_160);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_256_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset->sf_256, p_src + *p_length_read, "sf_256");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_320_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_320, p_src + *p_length_read, "sf_320");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_320 > 319))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_320] should be less than"
            " or equal to 319. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_320);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_512_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_512, p_src + *p_length_read, "sf_512");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_512 > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_512] should be less than"
            " or equal to 511. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_512);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_640_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_640, p_src + *p_length_read, "sf_640");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_640 > 639))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_640] should be less than"
            " or equal to 639. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_640);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1024_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_1024, p_src + *p_length_read, "sf_1024");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_1024 > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_1024] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_1024);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_1280_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_1280, p_src + *p_length_read, "sf_1280");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_1280 > 1279))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_1280] should be less than"
            " or equal to 1279. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_1280);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2048_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_2048, p_src + *p_length_read, "sf_2048");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_2048 > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_2048] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_2048);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_SF_2560_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset->sf_2560, p_src + *p_length_read, "sf_2560");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset->sf_2560 > 2559))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset->sf_2560] should be less than"
            " or equal to 2559. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset->sf_2560);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_short_drx
(
    rrc_short_drx_t *p_rrc_short_drx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_short_drx, 0, sizeof(rrc_short_drx_t));

    /* This function parses rrc_short_drx */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_short_drx->short_drx_cycle, p_src + *p_length_read, "short_drx_cycle");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_short_drx->short_drx_cycle > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_short_drx->short_drx_cycle] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_short_drx->short_drx_cycle);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_short_drx->short_drx_cycle_timer, p_src + *p_length_read, "short_drx_cycle_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_short_drx->short_drx_cycle_timer < 1) || (p_rrc_short_drx->short_drx_cycle_timer > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_short_drx->short_drx_cycle_timer] should be in range "
            "1 to 16. Incorrect value %u received.", p_rrc_short_drx->short_drx_cycle_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_drx_mac_ce_cmd_trigger_info
(
    rrc_drx_mac_ce_cmd_trigger_info_t *p_rrc_drx_mac_ce_cmd_trigger_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_drx_mac_ce_cmd_trigger_info, 0, sizeof(rrc_drx_mac_ce_cmd_trigger_info_t));

    /* This function parses rrc_drx_mac_ce_cmd_trigger_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer, p_src + *p_length_read, "drx_mac_ce_timer");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer < 2) || (p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer > 2559))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer] should be in range "
            "2 to 2559. Incorrect value %u received.", p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold, p_src + *p_length_read, "drx_mac_ce_cmd_threshold");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold < 1) || (p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold > 2559))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold] should be in range "
            "1 to 2559. Incorrect value %u received.", p_rrc_drx_mac_ce_cmd_trigger_info->drx_mac_ce_cmd_threshold);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_long_drx_cycle_start_offset_r15
(
    rrc_long_drx_cycle_start_offset_r15_t *p_rrc_long_drx_cycle_start_offset_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_long_drx_cycle_start_offset_r15, 0, sizeof(rrc_long_drx_cycle_start_offset_r15_t));

    /* This function parses rrc_long_drx_cycle_start_offset_r15 */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_long_drx_cycle_start_offset_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U32);

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_10, p_src + *p_length_read, "sf_10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_10 > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_10] should be less than"
            " or equal to 9. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_10);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_20_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_20, p_src + *p_length_read, "sf_20");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_20 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_20] should be less than"
            " or equal to 19. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_20);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_32_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_32, p_src + *p_length_read, "sf_32");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_32 > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_32] should be less than"
            " or equal to 31. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_32);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_40_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_40, p_src + *p_length_read, "sf_40");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_40 > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_40] should be less than"
            " or equal to 39. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_40);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_64_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_64, p_src + *p_length_read, "sf_64");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_64 > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_64] should be less than"
            " or equal to 63. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_64);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_80_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_80, p_src + *p_length_read, "sf_80");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_80 > 79))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_80] should be less than"
            " or equal to 79. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_80);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_128_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_128, p_src + *p_length_read, "sf_128");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_128 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_128] should be less than"
            " or equal to 127. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_128);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_160_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_160, p_src + *p_length_read, "sf_160");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_160 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_160] should be less than"
            " or equal to 159. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_160);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_256_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_long_drx_cycle_start_offset_r15->sf_256, p_src + *p_length_read, "sf_256");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_320_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_320, p_src + *p_length_read, "sf_320");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_320 > 319))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_320] should be less than"
            " or equal to 319. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_320);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_512_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_512, p_src + *p_length_read, "sf_512");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_512 > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_512] should be less than"
            " or equal to 511. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_512);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_640_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_640, p_src + *p_length_read, "sf_640");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_640 > 639))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_640] should be less than"
            " or equal to 639. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_640);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_1024_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_1024, p_src + *p_length_read, "sf_1024");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_1024 > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_1024] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_1024);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_1280_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_1280, p_src + *p_length_read, "sf_1280");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_1280 > 1279))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_1280] should be less than"
            " or equal to 1279. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_1280);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_2048_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_2048, p_src + *p_length_read, "sf_2048");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_2048 > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_2048] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_2048);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_2560_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_2560, p_src + *p_length_read, "sf_2560");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_2560 > 2559))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_2560] should be less than"
            " or equal to 2559. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_2560);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_5120_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_5120, p_src + *p_length_read, "sf_5120");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_5120 > 5119))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_5120] should be less than"
            " or equal to 5119. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_5120);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_long_drx_cycle_start_offset_r15->bitmask & RRC_LONG_DRX_CYCLE_START_OFFSET_R15_SF_10240_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_long_drx_cycle_start_offset_r15->sf_10240, p_src + *p_length_read, "sf_10240");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_long_drx_cycle_start_offset_r15->sf_10240 > 10239))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_long_drx_cycle_start_offset_r15->sf_10240] should be less than"
            " or equal to 10239. Incorrect value %u received.", p_rrc_long_drx_cycle_start_offset_r15->sf_10240);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_drx_config_param
(
    rrc_drx_config_param_t *p_rrc_drx_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_drx_config_param, 0, sizeof(rrc_drx_config_param_t));

    /* This function parses rrc_drx_config_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_drx_config_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_drx_config_param->on_duration_timer, p_src + *p_length_read, "on_duration_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_drx_config_param->on_duration_timer > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_config_param->on_duration_timer] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_drx_config_param->on_duration_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_drx_config_param->drx_inactivity_timer, p_src + *p_length_read, "drx_inactivity_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_drx_config_param->drx_inactivity_timer > 22))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_config_param->drx_inactivity_timer] should be less than"
            " or equal to 22. Incorrect value %u received.", p_rrc_drx_config_param->drx_inactivity_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_drx_config_param->drx_retransmission_timer, p_src + *p_length_read, "drx_retransmission_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_drx_config_param->drx_retransmission_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_config_param->drx_retransmission_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_drx_config_param->drx_retransmission_timer);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_long_drx_cycle_start_offset(
        &p_rrc_drx_config_param->long_drx_cycle_start_offset,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_drx_config_param->bitmask & RRC_DRX_CONFIG_SHORT_DRX_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_short_drx(
        &p_rrc_drx_config_param->short_drx,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_drx_config_param->bitmask & RRC_DRX_CONFIG_DRX_MAC_CE_CMD_TRIGGER_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_drx_mac_ce_cmd_trigger_info(
        &p_rrc_drx_config_param->drx_mac_ce_cmd_trigger_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_drx_config_param->bitmask & RRC_DRX_CONFIG_LONG_DRX_CYCLE_START_OFFSET_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_long_drx_cycle_start_offset_r15(
        &p_rrc_drx_config_param->long_drx_cycle_start_offset_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_drx_config
(
    rrc_drx_config_t *p_rrc_drx_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_drx_config, 0, sizeof(rrc_drx_config_t));

    /* This function parses rrc_drx_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_drx_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_drx_config->drx_config_type, p_src + *p_length_read, "drx_config_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_drx_config->drx_config_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_drx_config->drx_config_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_drx_config->drx_config_type);
        return RRC_FAILURE;
    }

    if (p_rrc_drx_config->bitmask & RRC_DRX_CONFIG_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_drx_config_param(
        &p_rrc_drx_config->drx_config_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phr_config_param
(
    rrc_phr_config_param_t *p_rrc_phr_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phr_config_param, 0, sizeof(rrc_phr_config_param_t));

    /* This function parses rrc_phr_config_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phr_config_param->periodic_phr_timer, p_src + *p_length_read, "periodic_phr_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phr_config_param->periodic_phr_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phr_config_param->periodic_phr_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phr_config_param->periodic_phr_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phr_config_param->prohibit_phr_timer, p_src + *p_length_read, "prohibit_phr_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phr_config_param->prohibit_phr_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phr_config_param->prohibit_phr_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phr_config_param->prohibit_phr_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phr_config_param->dl_pathloss_change, p_src + *p_length_read, "dl_pathloss_change");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phr_config_param->dl_pathloss_change > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phr_config_param->dl_pathloss_change] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_phr_config_param->dl_pathloss_change);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phr_config
(
    rrc_phr_config_t *p_rrc_phr_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phr_config, 0, sizeof(rrc_phr_config_t));

    /* This function parses rrc_phr_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phr_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phr_config->bitmask & RRC_PHR_CONFIG_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phr_config_param(
        &p_rrc_phr_config->phr_config_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_main_config_v1020
(
    rrc_mac_main_config_v1020_t *p_rrc_mac_main_config_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_main_config_v1020, 0, sizeof(rrc_mac_main_config_v1020_t));

    /* This function parses rrc_mac_main_config_v1020 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_main_config_v1020->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_mac_main_config_v1020->bitmask & RRC_MAC_MAIN_CONFIG_V1020_SCELL_DEACTIVATION_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config_v1020->scell_deactivation_timer, p_src + *p_length_read, "scell_deactivation_timer");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_mac_main_config_v1020->bitmask & RRC_MAC_MAIN_CONFIG_V1020_EXTENDED_BSR_SIZES_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config_v1020->extended_bsr_sizes, p_src + *p_length_read, "extended_bsr_sizes");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_main_config_v1020->extended_bsr_sizes > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_main_config_v1020->extended_bsr_sizes] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_mac_main_config_v1020->extended_bsr_sizes);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_main_config_v1020->bitmask & RRC_MAC_MAIN_CONFIG_V1020_EXTENDED_PHR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config_v1020->extended_phr, p_src + *p_length_read, "extended_phr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_main_config_v1020->extended_phr > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_main_config_v1020->extended_phr] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_mac_main_config_v1020->extended_phr);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_mac_main_config
(
    rrc_mac_main_config_t *p_rrc_mac_main_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_mac_main_config, 0, sizeof(rrc_mac_main_config_t));

    /* This function parses rrc_mac_main_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_mac_main_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_UL_SCH_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_ul_sch_config(
        &p_rrc_mac_main_config->ul_sch_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_DRX_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_drx_config(
        &p_rrc_mac_main_config->drx_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config->time_alignment_timer_dedicated, p_src + *p_length_read, "time_alignment_timer_dedicated");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_main_config->time_alignment_timer_dedicated > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_main_config->time_alignment_timer_dedicated] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_mac_main_config->time_alignment_timer_dedicated);
        return RRC_FAILURE;
    }

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_PHR_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phr_config(
        &p_rrc_mac_main_config->phr_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_SR_PROHIBIT_TIMER_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config->sr_prohibit_timer_r9, p_src + *p_length_read, "sr_prohibit_timer_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_main_config->sr_prohibit_timer_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_main_config->sr_prohibit_timer_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_mac_main_config->sr_prohibit_timer_r9);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_V1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_main_config_v1020(
        &p_rrc_mac_main_config->mac_main_config_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_mac_main_config->bitmask & RRC_MAC_MAIN_CONFIG_UPLINK_RAT1_SUPPORT_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_mac_main_config->is_uplink_rat1_supported, p_src + *p_length_read, "is_uplink_rat1_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_mac_main_config->is_uplink_rat1_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_mac_main_config->is_uplink_rat1_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_mac_main_config->is_uplink_rat1_supported);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_mac_main_config_extensions
(
    rrm_mac_main_config_extensions_t *p_rrm_mac_main_config_extensions,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_mac_main_config_extensions, 0, sizeof(rrm_mac_main_config_extensions_t));

    /* This function parses rrm_mac_main_config_extensions */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_mac_main_config_extensions->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->ue_priority, p_src + *p_length_read, "ue_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->ue_priority > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->ue_priority] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrm_mac_main_config_extensions->ue_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->dl_num_harq_process, p_src + *p_length_read, "dl_num_harq_process");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->dl_num_harq_process < 1) || (p_rrm_mac_main_config_extensions->dl_num_harq_process > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->dl_num_harq_process] should be in range "
            "1 to 15. Incorrect value %u received.", p_rrm_mac_main_config_extensions->dl_num_harq_process);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->dl_i_mcs, p_src + *p_length_read, "dl_i_mcs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->dl_i_mcs > 28))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->dl_i_mcs] should be less than"
            " or equal to 28. Incorrect value %u received.", p_rrm_mac_main_config_extensions->dl_i_mcs);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->dl_max_rb, p_src + *p_length_read, "dl_max_rb");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->dl_max_rb < 1) || (p_rrm_mac_main_config_extensions->dl_max_rb > 100))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->dl_max_rb] should be in range "
            "1 to 100. Incorrect value %u received.", p_rrm_mac_main_config_extensions->dl_max_rb);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->max_ul_harq_tx, p_src + *p_length_read, "max_ul_harq_tx");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->max_ul_harq_tx > 13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->max_ul_harq_tx] should be less than"
            " or equal to 13. Incorrect value %u received.", p_rrm_mac_main_config_extensions->max_ul_harq_tx);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->ul_i_mcs, p_src + *p_length_read, "ul_i_mcs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->ul_i_mcs > 28))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->ul_i_mcs] should be less than"
            " or equal to 28. Incorrect value %u received.", p_rrm_mac_main_config_extensions->ul_i_mcs);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->num_of_layer, p_src + *p_length_read, "num_of_layer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->num_of_layer < 1) || (p_rrm_mac_main_config_extensions->num_of_layer > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->num_of_layer] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrm_mac_main_config_extensions->num_of_layer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->code_book_index, p_src + *p_length_read, "code_book_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->code_book_index > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->code_book_index] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrm_mac_main_config_extensions->code_book_index);
        return RRC_FAILURE;
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_PC_MAX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrm_mac_main_config_extensions->pc_max, p_src + *p_length_read, "pc_max");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->pc_max < -40) || (p_rrm_mac_main_config_extensions->pc_max > 23))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->pc_max] should be in range "
            "-40 to 23. Incorrect value %d received.", p_rrm_mac_main_config_extensions->pc_max);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_USER_LOCATION_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->user_location_type, p_src + *p_length_read, "user_location_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->user_location_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->user_location_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_mac_main_config_extensions->user_location_type);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_UL_MU_MIMO_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->ul_mu_mimo_status, p_src + *p_length_read, "ul_mu_mimo_status");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->ul_mu_mimo_status > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->ul_mu_mimo_status] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_mac_main_config_extensions->ul_mu_mimo_status);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_MIN_UE_POWER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrm_mac_main_config_extensions->min_ue_power, p_src + *p_length_read, "min_ue_power");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->min_ue_power < -40) || (p_rrm_mac_main_config_extensions->min_ue_power > 23))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->min_ue_power] should be in range "
            "-40 to 23. Incorrect value %d received.", p_rrm_mac_main_config_extensions->min_ue_power);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_PDSCH_EPRE_TO_UE_RS_RATIO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrm_mac_main_config_extensions->pdsch_epre_to_ue_rs_ratio, p_src + *p_length_read, "pdsch_epre_to_ue_rs_ratio");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_mac_main_config_extensions->pdsch_epre_to_ue_rs_ratio < -6) || (p_rrm_mac_main_config_extensions->pdsch_epre_to_ue_rs_ratio > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->pdsch_epre_to_ue_rs_ratio] should be in range "
            "-6 to 3. Incorrect value %d received.", p_rrm_mac_main_config_extensions->pdsch_epre_to_ue_rs_ratio);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_mac_main_config_extensions->bitmask & RRM_MAC_MAN_CONFIG_EXT_DL_INTERFERENCE_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_mac_main_config_extensions->dl_interference_info, p_src + *p_length_read, "dl_interference_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_mac_main_config_extensions->dl_interference_info > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_mac_main_config_extensions->dl_interference_info] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_mac_main_config_extensions->dl_interference_info);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_mac_config
(
    rrm_mac_config_t *p_rrm_mac_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_mac_config, 0, sizeof(rrm_mac_config_t));

    /* This function parses rrm_mac_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_mac_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_mac_config->bitmask & RRM_MAC_CONFIG_MAC_MAIN_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_main_config(
        &p_rrm_mac_config->mac_main_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_main_config_extensions(
        &p_rrm_mac_config->mac_main_config_extensions,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_n1_pucch_an_persist_list
(
    rrc_n1_pucch_an_persist_list_t *p_rrc_n1_pucch_an_persist_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_n1_pucch_an_persist_list, 0, sizeof(rrc_n1_pucch_an_persist_list_t));

    /* This function parses rrc_n1_pucch_an_persist_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_n1_pucch_an_persist_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_n1_pucch_an_persist_list->count < 1) || (p_rrc_n1_pucch_an_persist_list->count > MAX_N1_PUCCH_AN_PERSIST_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_n1_pucch_an_persist_list->count] should be in range "
            "1 to MAX_N1_PUCCH_AN_PERSIST_SIZE. Incorrect value %u received.", p_rrc_n1_pucch_an_persist_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_n1_pucch_an_persist_list->count * sizeof(p_rrc_n1_pucch_an_persist_list->n1_pucch_an_persist[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_n1_pucch_an_persist_list->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_rrc_n1_pucch_an_persist_list->n1_pucch_an_persist[loop], (void*)(p_src + *p_length_read), "n1_pucch_an_persist[]");
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_sps_config_dl_param
(
    rrc_sps_config_dl_param_t *p_rrc_sps_config_dl_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_sps_config_dl_param, 0, sizeof(rrc_sps_config_dl_param_t));

    /* This function parses rrc_sps_config_dl_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_dl_param->semi_persist_sched_interval_dl, p_src + *p_length_read, "semi_persist_sched_interval_dl");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_sps_config_dl_param->semi_persist_sched_interval_dl > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_dl_param->semi_persist_sched_interval_dl] should be less than"
            " or equal to 9. Incorrect value %u received.", p_rrc_sps_config_dl_param->semi_persist_sched_interval_dl);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_dl_param->number_of_conf_sps_processes, p_src + *p_length_read, "number_of_conf_sps_processes");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_sps_config_dl_param->number_of_conf_sps_processes < 1) || (p_rrc_sps_config_dl_param->number_of_conf_sps_processes > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_dl_param->number_of_conf_sps_processes] should be in range "
            "1 to 8. Incorrect value %u received.", p_rrc_sps_config_dl_param->number_of_conf_sps_processes);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_n1_pucch_an_persist_list(
        &p_rrc_sps_config_dl_param->n1_pucch_an_persist_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_sps_config_dl
(
    rrc_sps_config_dl_t *p_rrc_sps_config_dl,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_sps_config_dl, 0, sizeof(rrc_sps_config_dl_t));

    /* This function parses rrc_sps_config_dl */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_sps_config_dl->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_sps_config_dl->bitmask & RRC_SPS_CONFIG_DL_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config_dl_param(
        &p_rrc_sps_config_dl->sps_config_dl_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_sps_config_dl->bitmask & RRC_SPS_CONFIG_DL_PARAM_MAX_SPS_HARQ_RETX)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_dl->max_sps_harq_retx, p_src + *p_length_read, "max_sps_harq_retx");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_sps_config_dl->max_sps_harq_retx < 1) || (p_rrc_sps_config_dl->max_sps_harq_retx > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_dl->max_sps_harq_retx] should be in range "
            "1 to 8. Incorrect value %u received.", p_rrc_sps_config_dl->max_sps_harq_retx);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_sps_config_dl->bitmask & RRC_SPS_CONFIG_DL_PARAM_EXPLICIT_RELEASE_AFTER)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_dl->expilcit_release_after, p_src + *p_length_read, "expilcit_release_after");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_sps_config_dl->expilcit_release_after < 2) || (p_rrc_sps_config_dl->expilcit_release_after > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_dl->expilcit_release_after] should be in range "
            "2 to 8. Incorrect value %u received.", p_rrc_sps_config_dl->expilcit_release_after);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_p_zero_persistent
(
    rrc_p_zero_persistent_t *p_rrc_p_zero_persistent,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_p_zero_persistent, 0, sizeof(rrc_p_zero_persistent_t));

    /* This function parses rrc_p_zero_persistent */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_p_zero_persistent->p_zero_nominal_pusch_persistent, p_src + *p_length_read, "p_zero_nominal_pusch_persistent");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_p_zero_persistent->p_zero_nominal_pusch_persistent < -126) || (p_rrc_p_zero_persistent->p_zero_nominal_pusch_persistent > 24))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_p_zero_persistent->p_zero_nominal_pusch_persistent] should be in range "
            "-126 to 24. Incorrect value %d received.", p_rrc_p_zero_persistent->p_zero_nominal_pusch_persistent);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_p_zero_persistent->p_zero_ue_pusch_persistent, p_src + *p_length_read, "p_zero_ue_pusch_persistent");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_p_zero_persistent->p_zero_ue_pusch_persistent < -8) || (p_rrc_p_zero_persistent->p_zero_ue_pusch_persistent > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_p_zero_persistent->p_zero_ue_pusch_persistent] should be in range "
            "-8 to 7. Incorrect value %d received.", p_rrc_p_zero_persistent->p_zero_ue_pusch_persistent);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_sps_config_ul_param
(
    rrc_sps_config_ul_param_t *p_rrc_sps_config_ul_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_sps_config_ul_param, 0, sizeof(rrc_sps_config_ul_param_t));

    /* This function parses rrc_sps_config_ul_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_sps_config_ul_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_ul_param->semi_persist_sched_interval_ul, p_src + *p_length_read, "semi_persist_sched_interval_ul");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_sps_config_ul_param->semi_persist_sched_interval_ul > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_ul_param->semi_persist_sched_interval_ul] should be less than"
            " or equal to 9. Incorrect value %u received.", p_rrc_sps_config_ul_param->semi_persist_sched_interval_ul);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_ul_param->implicit_release_after, p_src + *p_length_read, "implicit_release_after");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_sps_config_ul_param->implicit_release_after > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_sps_config_ul_param->implicit_release_after] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_sps_config_ul_param->implicit_release_after);
        return RRC_FAILURE;
    }

    if (p_rrc_sps_config_ul_param->bitmask & RRC_SPS_CONFIG_UL_P_0_PERSISTENT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_p_zero_persistent(
        &p_rrc_sps_config_ul_param->p_zero_persistent,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_sps_config_ul_param->bitmask & RRC_SPS_CONFIG_UL_TWO_INTERVALS_CONFIG_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_sps_config_ul_param->two_intervals_config, p_src + *p_length_read, "two_intervals_config");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_sps_config_ul
(
    rrc_sps_config_ul_t *p_rrc_sps_config_ul,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_sps_config_ul, 0, sizeof(rrc_sps_config_ul_t));

    /* This function parses rrc_sps_config_ul */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_sps_config_ul->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_sps_config_ul->bitmask & RRC_SPS_CONFIG_UL_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config_ul_param(
        &p_rrc_sps_config_ul->sps_config_ul_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_sps_config
(
    rrc_sps_config_t *p_rrc_sps_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_sps_config, 0, sizeof(rrc_sps_config_t));

    /* This function parses rrc_sps_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_sps_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_sps_config->bitmask & RRC_SPS_CONFIG_C_RNTI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_sps_config->semi_presist_sched_c_rnti) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_sps_config->semi_presist_sched_c_rnti); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_sps_config->semi_presist_sched_c_rnti[loop], (void*)(p_src + *p_length_read), "semi_presist_sched_c_rnti[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_sps_config->bitmask & RRC_SPS_CONFIG_SPS_CONFIG_DL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config_dl(
        &p_rrc_sps_config->sps_config_dl,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_sps_config->bitmask & RRC_SPS_CONFIG_SPS_CONFIG_UL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config_ul(
        &p_rrc_sps_config->sps_config_ul,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_pdsch_configuration_dedicated
(
    rrc_phy_pdsch_configuration_dedicated_t *p_rrc_phy_pdsch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_pdsch_configuration_dedicated, 0, sizeof(rrc_phy_pdsch_configuration_dedicated_t));

    /* This function parses rrc_phy_pdsch_configuration_dedicated */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_pdsch_configuration_dedicated->p_a, p_src + *p_length_read, "p_a");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_pdsch_configuration_dedicated->p_a > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_pdsch_configuration_dedicated->p_a] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phy_pdsch_configuration_dedicated->p_a);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_ack_nack_repetition_param
(
    rrc_phy_ack_nack_repetition_param_t *p_rrc_phy_ack_nack_repetition_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_ack_nack_repetition_param, 0, sizeof(rrc_phy_ack_nack_repetition_param_t));

    /* This function parses rrc_phy_ack_nack_repetition_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_ack_nack_repetition_param->factor, p_src + *p_length_read, "factor");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_ack_nack_repetition_param->factor > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_ack_nack_repetition_param->factor] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_phy_ack_nack_repetition_param->factor);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_ack_nack_repetition_param->an_rep, p_src + *p_length_read, "an_rep");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_ack_nack_repetition_param->an_rep > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_ack_nack_repetition_param->an_rep] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_rrc_phy_ack_nack_repetition_param->an_rep);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_pucch_configuration_dedicated
(
    rrc_phy_pucch_configuration_dedicated_t *p_rrc_phy_pucch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_pucch_configuration_dedicated, 0, sizeof(rrc_phy_pucch_configuration_dedicated_t));

    /* This function parses rrc_phy_pucch_configuration_dedicated */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_pucch_configuration_dedicated->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_pucch_configuration_dedicated->bitmask & RRC_PHY_ACK_NACK_REPETITION_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_ack_nack_repetition_param(
        &p_rrc_phy_pucch_configuration_dedicated->ack_nack_repetition_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_pucch_configuration_dedicated->bitmask & RRC_PHY_TDD_ACK_NACK_FEEDBACK_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode, p_src + *p_length_read, "tdd_ack_nack_feedback_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_pucch_configuration_dedicated->tdd_ack_nack_feedback_mode);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_pusch_configuration_dedicated
(
    rrc_phy_pusch_configuration_dedicated_t *p_rrc_phy_pusch_configuration_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_pusch_configuration_dedicated, 0, sizeof(rrc_phy_pusch_configuration_dedicated_t));

    /* This function parses rrc_phy_pusch_configuration_dedicated */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index, p_src + *p_length_read, "beta_offset_ack_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_phy_pusch_configuration_dedicated->beta_offset_ack_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index, p_src + *p_length_read, "beta_offset_ri_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_phy_pusch_configuration_dedicated->beta_offset_ri_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index, p_src + *p_length_read, "beta_offset_cqi_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_phy_pusch_configuration_dedicated->beta_offset_cqi_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_uplink_power_control_dedicated
(
    rrc_phy_uplink_power_control_dedicated_t *p_rrc_phy_uplink_power_control_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_uplink_power_control_dedicated, 0, sizeof(rrc_phy_uplink_power_control_dedicated_t));

    /* This function parses rrc_phy_uplink_power_control_dedicated */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch, p_src + *p_length_read, "p0_ue_pusch");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch < -8) || (p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch] should be in range "
            "-8 to 7. Incorrect value %d received.", p_rrc_phy_uplink_power_control_dedicated->p0_ue_pusch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled, p_src + *p_length_read, "delta_mcs_enabled");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_uplink_power_control_dedicated->delta_mcs_enabled);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled, p_src + *p_length_read, "accumulation_enabled");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_uplink_power_control_dedicated->accumulation_enabled);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch, p_src + *p_length_read, "p0_ue_pucch");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch < -8) || (p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch] should be in range "
            "-8 to 7. Incorrect value %d received.", p_rrc_phy_uplink_power_control_dedicated->p0_ue_pucch);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_uplink_power_control_dedicated->p_srs_offset, p_src + *p_length_read, "p_srs_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_uplink_power_control_dedicated->p_srs_offset > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->p_srs_offset] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_phy_uplink_power_control_dedicated->p_srs_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_uplink_power_control_dedicated->filter_coefficient, p_src + *p_length_read, "filter_coefficient");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_uplink_power_control_dedicated->filter_coefficient > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_uplink_power_control_dedicated->filter_coefficient] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_phy_uplink_power_control_dedicated->filter_coefficient);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_index
(
    rrc_phy_tpc_index_t *p_rrc_phy_tpc_index,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_tpc_index, 0, sizeof(rrc_phy_tpc_index_t));

    /* This function parses rrc_phy_tpc_index */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_tpc_index->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_tpc_index->bitmask & TPC_INDEX_FORMAT_3_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_tpc_index->index_of_format3, p_src + *p_length_read, "index_of_format3");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_tpc_index->index_of_format3 < 1) || (p_rrc_phy_tpc_index->index_of_format3 > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_tpc_index->index_of_format3] should be in range "
            "1 to 15. Incorrect value %u received.", p_rrc_phy_tpc_index->index_of_format3);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_phy_tpc_index->bitmask & TPC_INDEX_FORMAT_3A_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_tpc_index->index_of_format3a, p_src + *p_length_read, "index_of_format3a");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_tpc_index->index_of_format3a < 1) || (p_rrc_phy_tpc_index->index_of_format3a > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_tpc_index->index_of_format3a] should be in range "
            "1 to 31. Incorrect value %u received.", p_rrc_phy_tpc_index->index_of_format3a);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_pdcch_config_param
(
    rrc_phy_tpc_pdcch_config_param_t *p_rrc_phy_tpc_pdcch_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_tpc_pdcch_config_param, 0, sizeof(rrc_phy_tpc_pdcch_config_param_t));

    /* This function parses rrc_phy_tpc_pdcch_config_param */

    if (*p_length_read + (S32)sizeof(p_rrc_phy_tpc_pdcch_config_param->tpc_rnti) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_tpc_pdcch_config_param->tpc_rnti); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_tpc_pdcch_config_param->tpc_rnti[loop], (void*)(p_src + *p_length_read), "tpc_rnti[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_tpc_index(
        &p_rrc_phy_tpc_pdcch_config_param->tpc_index,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_tpc_pdcch_configuration
(
    rrc_phy_tpc_pdcch_configuration_t *p_rrc_phy_tpc_pdcch_configuration,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_tpc_pdcch_configuration, 0, sizeof(rrc_phy_tpc_pdcch_configuration_t));

    /* This function parses rrc_phy_tpc_pdcch_configuration */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_tpc_pdcch_configuration->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_tpc_pdcch_configuration->bitmask & RRC_PHY_TPC_PDCCH_CONFIG_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_tpc_pdcch_config_param(
        &p_rrc_phy_tpc_pdcch_configuration->tpc_pdcch_config_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_subband_cqi_param_param
(
    rrc_phy_subband_cqi_param_param_t *p_rrc_phy_subband_cqi_param_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_subband_cqi_param_param, 0, sizeof(rrc_phy_subband_cqi_param_param_t));

    /* This function parses rrc_phy_subband_cqi_param_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_subband_cqi_param_param->k, p_src + *p_length_read, "k");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_subband_cqi_param_param->k < 1) || (p_rrc_phy_subband_cqi_param_param->k > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_subband_cqi_param_param->k] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_phy_subband_cqi_param_param->k);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_indicator_periodic
(
    rrc_phy_cqi_format_indicator_periodic_t *p_rrc_phy_cqi_format_indicator_periodic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_format_indicator_periodic, 0, sizeof(rrc_phy_cqi_format_indicator_periodic_t));

    /* This function parses rrc_phy_cqi_format_indicator_periodic */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_format_indicator_periodic->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_format_indicator_periodic->bitmask & RRC_PHY_SUBBAND_CQI_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_subband_cqi_param_param(
        &p_rrc_phy_cqi_format_indicator_periodic->subband_cqi_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting_periodic_param
(
    rrc_phy_cqi_reporting_periodic_param_t *p_rrc_phy_cqi_reporting_periodic_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_reporting_periodic_param, 0, sizeof(rrc_phy_cqi_reporting_periodic_param_t));

    /* This function parses rrc_phy_cqi_reporting_periodic_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting_periodic_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting_periodic_param->cqi_pucch_resource_index, p_src + *p_length_read, "cqi_pucch_resource_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_reporting_periodic_param->cqi_pucch_resource_index > 1185))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting_periodic_param->cqi_pucch_resource_index] should be less than"
            " or equal to 1185. Incorrect value %u received.", p_rrc_phy_cqi_reporting_periodic_param->cqi_pucch_resource_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting_periodic_param->cqi_pmi_config_index, p_src + *p_length_read, "cqi_pmi_config_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_reporting_periodic_param->cqi_pmi_config_index > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting_periodic_param->cqi_pmi_config_index] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_reporting_periodic_param->cqi_pmi_config_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_format_indicator_periodic(
        &p_rrc_phy_cqi_reporting_periodic_param->cqi_format_indicator_periodic,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_phy_cqi_reporting_periodic_param->bitmask & RRC_PHY_CQI_RI_CONFIG_INDEX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting_periodic_param->ri_config_index, p_src + *p_length_read, "ri_config_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_reporting_periodic_param->ri_config_index > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting_periodic_param->ri_config_index] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_reporting_periodic_param->ri_config_index);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi, p_src + *p_length_read, "simultaneous_ack_nack_and_cqi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_reporting_periodic_param->simultaneous_ack_nack_and_cqi);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting_periodic
(
    rrc_phy_cqi_reporting_periodic_t *p_rrc_phy_cqi_reporting_periodic,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_reporting_periodic, 0, sizeof(rrc_phy_cqi_reporting_periodic_t));

    /* This function parses rrc_phy_cqi_reporting_periodic */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting_periodic->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_reporting_periodic->bitmask & RRC_PHY_CQI_REPORTING_PERIODIC_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_reporting_periodic_param(
        &p_rrc_phy_cqi_reporting_periodic->cqi_reporting_periodic_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_reporting
(
    rrc_phy_cqi_reporting_t *p_rrc_phy_cqi_reporting,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_reporting, 0, sizeof(rrc_phy_cqi_reporting_t));

    /* This function parses rrc_phy_cqi_reporting */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_reporting->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_reporting->bitmask & RRC_PHY_CQI_REPORTING_MODE_APERIODIC_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic, p_src + *p_length_read, "cqi_reporting_mode_aperiodic");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic] should be less than"
            " or equal to 4. Incorrect value %u received.", p_rrc_phy_cqi_reporting->cqi_reporting_mode_aperiodic);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset, p_src + *p_length_read, "nom_pdsch_rs_epre_offset");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset < -1) || (p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset] should be in range "
            "-1 to 6. Incorrect value %d received.", p_rrc_phy_cqi_reporting->nom_pdsch_rs_epre_offset);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_reporting->bitmask & RRC_PHY_CQI_REPORTING_PERIODIC_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_reporting_periodic(
        &p_rrc_phy_cqi_reporting->cqi_reporting_periodic,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated_param
(
    rrc_phy_sounding_rs_ul_config_dedicated_param_t *p_rrc_phy_sounding_rs_ul_config_dedicated_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_sounding_rs_ul_config_dedicated_param, 0, sizeof(rrc_phy_sounding_rs_ul_config_dedicated_param_t));

    /* This function parses rrc_phy_sounding_rs_ul_config_dedicated_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_bandwidth, p_src + *p_length_read, "srs_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_bandwidth > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_bandwidth] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_hopping_bandwidth, p_src + *p_length_read, "srs_hopping_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_hopping_bandwidth > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_hopping_bandwidth] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_hopping_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->frequency_domain_position, p_src + *p_length_read, "frequency_domain_position");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->frequency_domain_position > 23))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->frequency_domain_position] should be less than"
            " or equal to 23. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->frequency_domain_position);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->duration, p_src + *p_length_read, "duration");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->duration > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->duration] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->duration);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_configuration_index, p_src + *p_length_read, "srs_configuration_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_configuration_index > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_configuration_index] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->srs_configuration_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->transmission_comb, p_src + *p_length_read, "transmission_comb");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->transmission_comb > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->transmission_comb] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->transmission_comb);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_sounding_rs_ul_config_dedicated_param->cyclic_shift, p_src + *p_length_read, "cyclic_shift");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_sounding_rs_ul_config_dedicated_param->cyclic_shift > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_sounding_rs_ul_config_dedicated_param->cyclic_shift] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phy_sounding_rs_ul_config_dedicated_param->cyclic_shift);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated
(
    rrc_phy_sounding_rs_ul_config_dedicated_t *p_rrc_phy_sounding_rs_ul_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_sounding_rs_ul_config_dedicated, 0, sizeof(rrc_phy_sounding_rs_ul_config_dedicated_t));

    /* This function parses rrc_phy_sounding_rs_ul_config_dedicated */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_sounding_rs_ul_config_dedicated->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_sounding_rs_ul_config_dedicated->bitmask & RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated_param(
        &p_rrc_phy_sounding_rs_ul_config_dedicated->sounding_rs_ul_config_dedicated_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_codebook_subset_restriction
(
    rrc_phy_codebook_subset_restriction_t *p_rrc_phy_codebook_subset_restriction,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_codebook_subset_restriction, 0, sizeof(rrc_phy_codebook_subset_restriction_t));

    /* This function parses rrc_phy_codebook_subset_restriction */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_codebook_subset_restriction->type, p_src + *p_length_read, "type");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_codebook_subset_restriction->type > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_codebook_subset_restriction->type] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phy_codebook_subset_restriction->type);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_rrc_phy_codebook_subset_restriction->value) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_codebook_subset_restriction->value); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_codebook_subset_restriction->value[loop], (void*)(p_src + *p_length_read), "value[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_ue_transmit_antenna_selection
(
    rrc_phy_ue_transmit_antenna_selection_t *p_rrc_phy_ue_transmit_antenna_selection,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_ue_transmit_antenna_selection, 0, sizeof(rrc_phy_ue_transmit_antenna_selection_t));

    /* This function parses rrc_phy_ue_transmit_antenna_selection */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_ue_transmit_antenna_selection->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_ue_transmit_antenna_selection->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_ue_transmit_antenna_selection->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_ue_transmit_antenna_selection->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_ue_transmit_antenna_selection->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_ue_transmit_antenna_selection->bitmask & RRC_PHY_UE_TRANSMIT_ANTENNA_SELECTION_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_ue_transmit_antenna_selection->ue_transmit_antenna_selection_type, p_src + *p_length_read, "ue_transmit_antenna_selection_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_ue_transmit_antenna_selection->ue_transmit_antenna_selection_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_ue_transmit_antenna_selection->ue_transmit_antenna_selection_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_ue_transmit_antenna_selection->ue_transmit_antenna_selection_type);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_information_dedicated
(
    rrc_phy_antenna_information_dedicated_t *p_rrc_phy_antenna_information_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_antenna_information_dedicated, 0, sizeof(rrc_phy_antenna_information_dedicated_t));

    /* This function parses rrc_phy_antenna_information_dedicated */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_antenna_information_dedicated->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_antenna_information_dedicated->transmission_mode, p_src + *p_length_read, "transmission_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_antenna_information_dedicated->transmission_mode > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_antenna_information_dedicated->transmission_mode] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_phy_antenna_information_dedicated->transmission_mode);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_antenna_information_dedicated->bitmask & RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_codebook_subset_restriction(
        &p_rrc_phy_antenna_information_dedicated->codebook_subset_restriction,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_ue_transmit_antenna_selection(
        &p_rrc_phy_antenna_information_dedicated->ue_transmit_antenna_selection,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_information
(
    rrc_phy_antenna_information_t *p_rrc_phy_antenna_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_antenna_information, 0, sizeof(rrc_phy_antenna_information_t));

    /* This function parses rrc_phy_antenna_information */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_antenna_information->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_antenna_information->bitmask & RRC_PHY_ANTENNA_INFORMATION_EXPLICIT_VALUE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_antenna_information_dedicated(
        &p_rrc_phy_antenna_information->antenna_information_explicit_value,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_scheduling_request_config_param
(
    rrc_phy_scheduling_request_config_param_t *p_rrc_phy_scheduling_request_config_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_scheduling_request_config_param, 0, sizeof(rrc_phy_scheduling_request_config_param_t));

    /* This function parses rrc_phy_scheduling_request_config_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_scheduling_request_config_param->sr_pucch_resource_index, p_src + *p_length_read, "sr_pucch_resource_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_scheduling_request_config_param->sr_pucch_resource_index > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_scheduling_request_config_param->sr_pucch_resource_index] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_rrc_phy_scheduling_request_config_param->sr_pucch_resource_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_scheduling_request_config_param->sr_configuration_index, p_src + *p_length_read, "sr_configuration_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_scheduling_request_config_param->sr_configuration_index > 157))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_scheduling_request_config_param->sr_configuration_index] should be less than"
            " or equal to 157. Incorrect value %u received.", p_rrc_phy_scheduling_request_config_param->sr_configuration_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_scheduling_request_config_param->dsr_trans_max, p_src + *p_length_read, "dsr_trans_max");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_scheduling_request_config_param->dsr_trans_max > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_scheduling_request_config_param->dsr_trans_max] should be less than"
            " or equal to 4. Incorrect value %u received.", p_rrc_phy_scheduling_request_config_param->dsr_trans_max);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_scheduling_request_config
(
    rrc_phy_scheduling_request_config_t *p_rrc_phy_scheduling_request_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_scheduling_request_config, 0, sizeof(rrc_phy_scheduling_request_config_t));

    /* This function parses rrc_phy_scheduling_request_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_scheduling_request_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_scheduling_request_config->bitmask & RRC_PHY_SCHEDULING_REQUEST_CONFIG_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_scheduling_request_config_param(
        &p_rrc_phy_scheduling_request_config->scheduling_request_config_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_config_v920
(
    rrc_phy_cqi_report_config_v920_t *p_rrc_phy_cqi_report_config_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_config_v920, 0, sizeof(rrc_phy_cqi_report_config_v920_t));

    /* This function parses rrc_phy_cqi_report_config_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_config_v920->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_report_config_v920->bitmask & RRC_PHY_CQI_MASK_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_config_v920->cqi_mask_r9, p_src + *p_length_read, "cqi_mask_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_config_v920->cqi_mask_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_config_v920->cqi_mask_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_phy_cqi_report_config_v920->cqi_mask_r9);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_phy_cqi_report_config_v920->bitmask & RRC_PHY_PMI_RI_REPORT_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_config_v920->pmi_ri_report_r9, p_src + *p_length_read, "pmi_ri_report_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_config_v920->pmi_ri_report_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_config_v920->pmi_ri_report_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_phy_cqi_report_config_v920->pmi_ri_report_r9);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_codebook_subset_restriction_v920
(
    rrc_phy_codebook_subset_restriction_v920_t *p_rrc_phy_codebook_subset_restriction_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_codebook_subset_restriction_v920, 0, sizeof(rrc_phy_codebook_subset_restriction_v920_t));

    /* This function parses rrc_phy_codebook_subset_restriction_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_codebook_subset_restriction_v920->type, p_src + *p_length_read, "type");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_codebook_subset_restriction_v920->type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_codebook_subset_restriction_v920->type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_codebook_subset_restriction_v920->type);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_rrc_phy_codebook_subset_restriction_v920->value) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_codebook_subset_restriction_v920->value); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_codebook_subset_restriction_v920->value[loop], (void*)(p_src + *p_length_read), "value[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_antenna_info_v920
(
    rrc_phy_antenna_info_v920_t *p_rrc_phy_antenna_info_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_antenna_info_v920, 0, sizeof(rrc_phy_antenna_info_v920_t));

    /* This function parses rrc_phy_antenna_info_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_antenna_info_v920->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_antenna_info_v920->bitmask & RRC_PHY_CODEBOOK_SUBSET_RESTRICTION_V920_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_codebook_subset_restriction_v920(
        &p_rrc_phy_antenna_info_v920->codebook_subset_restriction_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_codebook_subset_restriction_r10
(
    rrc_codebook_subset_restriction_r10_t *p_rrc_codebook_subset_restriction_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_codebook_subset_restriction_r10, 0, sizeof(rrc_codebook_subset_restriction_r10_t));

    /* This function parses rrc_codebook_subset_restriction_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_codebook_subset_restriction_r10->num_bits, p_src + *p_length_read, "num_bits");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_codebook_subset_restriction_r10->num_bits < 2) || (p_rrc_codebook_subset_restriction_r10->num_bits > 109))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_codebook_subset_restriction_r10->num_bits] should be in range "
            "2 to 109. Incorrect value %u received.", p_rrc_codebook_subset_restriction_r10->num_bits);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_rrc_codebook_subset_restriction_r10->value) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_codebook_subset_restriction_r10->value); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_codebook_subset_restriction_r10->value[loop], (void*)(p_src + *p_length_read), "value[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_dedicated_r10
(
    rrc_antenna_info_dedicated_r10_t *p_rrc_antenna_info_dedicated_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_antenna_info_dedicated_r10, 0, sizeof(rrc_antenna_info_dedicated_r10_t));

    /* This function parses rrc_antenna_info_dedicated_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_antenna_info_dedicated_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_antenna_info_dedicated_r10->transmission_mode, p_src + *p_length_read, "transmission_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_antenna_info_dedicated_r10->transmission_mode > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_antenna_info_dedicated_r10->transmission_mode] should be less than"
            " or equal to 8. Incorrect value %u received.", p_rrc_antenna_info_dedicated_r10->transmission_mode);
        return RRC_FAILURE;
    }

    if (p_rrc_antenna_info_dedicated_r10->bitmask & RRM_CODEBOOK_SUBSET_RESTRICTION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_codebook_subset_restriction_r10(
        &p_rrc_antenna_info_dedicated_r10->codebook_subset_restriction_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_ue_transmit_antenna_selection(
        &p_rrc_antenna_info_dedicated_r10->ue_transmit_antenna_selection,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_r10
(
    rrc_antenna_info_r10_t *p_rrc_antenna_info_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_antenna_info_r10, 0, sizeof(rrc_antenna_info_r10_t));

    /* This function parses rrc_antenna_info_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_antenna_info_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_antenna_info_r10->bitmask & RRC_ANTENNA_INFO_R10_EXPLICIT_VALUE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_antenna_info_dedicated_r10(
        &p_rrc_antenna_info_r10->explicit_value,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_antenna_info_ul_r10
(
    rrc_antenna_info_ul_r10_t *p_rrc_antenna_info_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_antenna_info_ul_r10, 0, sizeof(rrc_antenna_info_ul_r10_t));

    /* This function parses rrc_antenna_info_ul_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_antenna_info_ul_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_antenna_info_ul_r10->bitmask & RRC_ANTENNA_INFO_UL_R10_TRANSMISSION_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_antenna_info_ul_r10->transmission_mode_ul, p_src + *p_length_read, "transmission_mode_ul");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_antenna_info_ul_r10->transmission_mode_ul > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_antenna_info_ul_r10->transmission_mode_ul] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_antenna_info_ul_r10->transmission_mode_ul);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_antenna_info_ul_r10->bitmask & RRC_ANTENNA_INFO_UL_R10_FOUR_ANTENNA_PORT_ACTIVATED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_antenna_info_ul_r10->four_antenna_port_activated, p_src + *p_length_read, "four_antenna_port_activated");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_antenna_info_ul_r10->four_antenna_port_activated > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_antenna_info_ul_r10->four_antenna_port_activated] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_antenna_info_ul_r10->four_antenna_port_activated);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger
(
    rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger_t *p_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger, 0, sizeof(rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger_t));

    /* This function parses rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger->trigger1, p_src + *p_length_read, "trigger1");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger->trigger2, p_src + *p_length_read, "trigger2");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup
(
    rrc_phy_cqi_report_aperiodic_r10_setup_t *p_rrc_phy_cqi_report_aperiodic_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_aperiodic_r10_setup, 0, sizeof(rrc_phy_cqi_report_aperiodic_r10_setup_t));

    /* This function parses rrc_phy_cqi_report_aperiodic_r10_setup */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_aperiodic_r10_setup->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_aperiodic_r10_setup->cqi_reporting_mode_aperiodic, p_src + *p_length_read, "cqi_reporting_mode_aperiodic");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_aperiodic_r10_setup->cqi_reporting_mode_aperiodic > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_aperiodic_r10_setup->cqi_reporting_mode_aperiodic] should be less than"
            " or equal to 4. Incorrect value %u received.", p_rrc_phy_cqi_report_aperiodic_r10_setup->cqi_reporting_mode_aperiodic);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_aperiodic_r10_setup->bitmask & RRC_CQI_REPORT_APERIODIC_R10_SETUP_APERIODIC_CSI_TRIGGER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup_csi_trigger(
        &p_rrc_phy_cqi_report_aperiodic_r10_setup->aperiodic_csi_trigger,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10
(
    rrc_phy_cqi_report_aperiodic_r10_t *p_rrc_phy_cqi_report_aperiodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_aperiodic_r10, 0, sizeof(rrc_phy_cqi_report_aperiodic_r10_t));

    /* This function parses rrc_phy_cqi_report_aperiodic_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_aperiodic_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_aperiodic_r10->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_aperiodic_r10->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_aperiodic_r10->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_report_aperiodic_r10->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_aperiodic_r10->bitmask & RRC_PHY_CQI_REPORT_APERIODIC_R10_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10_setup(
        &p_rrc_phy_cqi_report_aperiodic_r10->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_wideband_r10
(
    rrc_phy_cqi_format_ind_wideband_r10_t *p_rrc_phy_cqi_format_ind_wideband_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_format_ind_wideband_r10, 0, sizeof(rrc_phy_cqi_format_ind_wideband_r10_t));

    /* This function parses rrc_phy_cqi_format_ind_wideband_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_format_ind_wideband_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_format_ind_wideband_r10->bitmask & RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_REPORT_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_format_ind_wideband_r10->csi_report_mode, p_src + *p_length_read, "csi_report_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_format_ind_wideband_r10->csi_report_mode > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_format_ind_wideband_r10->csi_report_mode] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_format_ind_wideband_r10->csi_report_mode);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_subband_r10
(
    rrc_phy_cqi_format_ind_subband_r10_t *p_rrc_phy_cqi_format_ind_subband_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_format_ind_subband_r10, 0, sizeof(rrc_phy_cqi_format_ind_subband_r10_t));

    /* This function parses rrc_phy_cqi_format_ind_subband_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_format_ind_subband_r10->k, p_src + *p_length_read, "k");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_phy_cqi_format_ind_subband_r10->k < 1) || (p_rrc_phy_cqi_format_ind_subband_r10->k > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_format_ind_subband_r10->k] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_phy_cqi_format_ind_subband_r10->k);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_format_ind_subband_r10->periodicy_factor, p_src + *p_length_read, "periodicy_factor");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_format_ind_subband_r10->periodicy_factor > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_format_ind_subband_r10->periodicy_factor] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_format_ind_subband_r10->periodicy_factor);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_format_ind_periodic_r10
(
    rrc_phy_cqi_format_ind_periodic_r10_t *p_rrc_phy_cqi_format_ind_periodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_format_ind_periodic_r10, 0, sizeof(rrc_phy_cqi_format_ind_periodic_r10_t));

    /* This function parses rrc_phy_cqi_format_ind_periodic_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_format_ind_periodic_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_cqi_format_ind_periodic_r10->bitmask & RRC_PHY_CQI_FORMAT_IND_PERIODIC_WIDEBAND_CQI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_format_ind_wideband_r10(
        &p_rrc_phy_cqi_format_ind_periodic_r10->cqi_format_ind_wideband,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_cqi_format_ind_periodic_r10->bitmask & RRC_PHY_CQI_FORMAT_IND_PERIODIC_SUBBAND_CQI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_format_ind_subband_r10(
        &p_rrc_phy_cqi_format_ind_periodic_r10->cqi_format_ind_subband,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup
(
    rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup_t *p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup, 0, sizeof(rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup_t));

    /* This function parses rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->cqi_pmi_config_index2, p_src + *p_length_read, "cqi_pmi_config_index2");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->cqi_pmi_config_index2 > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->cqi_pmi_config_index2] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->cqi_pmi_config_index2);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->bitmask & RRC_PHY_CQI_PERIODIC_R10_SETUP_CSI_RI_CONFIG_INDEX2_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->ri_config_index2, p_src + *p_length_read, "ri_config_index2");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->ri_config_index2 > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->ri_config_index2] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup->ri_config_index2);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index
(
    rrc_phy_cqi_report_periodic_r10_setup_csi_config_index *p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index, 0, sizeof(rrc_phy_cqi_report_periodic_r10_setup_csi_config_index));

    /* This function parses rrc_phy_cqi_report_periodic_r10_setup_csi_config_index */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->bitmask & RRC_PHY_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index_setup(
        &p_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup
(
    rrc_phy_cqi_report_periodic_r10_setup_t *p_rrc_phy_cqi_report_periodic_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_periodic_r10_setup, 0, sizeof(rrc_phy_cqi_report_periodic_r10_setup_t));

    /* This function parses rrc_phy_cqi_report_periodic_r10_setup */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index, p_src + *p_length_read, "cqi_pucch_resource_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index > 1184))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index] should be less than"
            " or equal to 1184. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_periodic_r10_setup->bitmask & RRC_CQI_REPORT_PERIODIC_R10_SETUP_PUCCH_REPORT_INDEX_P1_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index_p1, p_src + *p_length_read, "cqi_pucch_resource_index_p1");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index_p1 > 1184))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index_p1] should be less than"
            " or equal to 1184. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pucch_resource_index_p1);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pmi_config_index, p_src + *p_length_read, "cqi_pmi_config_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pmi_config_index > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pmi_config_index] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->cqi_pmi_config_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_format_ind_periodic_r10(
        &p_rrc_phy_cqi_report_periodic_r10_setup->cqi_format_ind_periodic,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_phy_cqi_report_periodic_r10_setup->bitmask & RRC_CQI_REPORT_PERIODIC_R10_SETUP_RI_CONFIG_INDEX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index, p_src + *p_length_read, "ri_config_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->ri_config_index);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_periodic_r10_setup->simultaneous_ack_nack_cqi, p_src + *p_length_read, "simultaneous_ack_nack_cqi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->simultaneous_ack_nack_cqi > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->simultaneous_ack_nack_cqi] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->simultaneous_ack_nack_cqi);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_periodic_r10_setup->bitmask & RRC_CQI_REPORT_PERIODIC_R10_SETUP_CQI_MASK_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_periodic_r10_setup->cqi_mask_r9, p_src + *p_length_read, "cqi_mask_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10_setup->cqi_mask_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10_setup->cqi_mask_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10_setup->cqi_mask_r9);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_phy_cqi_report_periodic_r10_setup->bitmask & RRC_CQI_REPORT_PERIODIC_R10_SETUP_CSI_CONFIG_INDEX_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup_csi_config_index(
        &p_rrc_phy_cqi_report_periodic_r10_setup->csi_config_index,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_periodic_r10
(
    rrc_phy_cqi_report_periodic_r10_t *p_rrc_phy_cqi_report_periodic_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_periodic_r10, 0, sizeof(rrc_phy_cqi_report_periodic_r10_t));

    /* This function parses rrc_phy_cqi_report_periodic_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_periodic_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_periodic_r10->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_periodic_r10->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_periodic_r10->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_report_periodic_r10->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_periodic_r10->bitmask & RRC_PHY_CQI_REPORT_PERIODIC_R10SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_periodic_r10_setup(
        &p_rrc_phy_cqi_report_periodic_r10->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_fdd_r10
(
    rrc_phy_meas_subframe_pattern_fdd_r10_t *p_rrc_phy_meas_subframe_pattern_fdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_meas_subframe_pattern_fdd_r10, 0, sizeof(rrc_phy_meas_subframe_pattern_fdd_r10_t));

    /* This function parses rrc_phy_meas_subframe_pattern_fdd_r10 */

    if (*p_length_read + (S32)sizeof(p_rrc_phy_meas_subframe_pattern_fdd_r10->data) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_meas_subframe_pattern_fdd_r10->data); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_meas_subframe_pattern_fdd_r10->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_tdd_r10
(
    rrc_phy_meas_subframe_pattern_tdd_r10_t *p_rrc_phy_meas_subframe_pattern_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_meas_subframe_pattern_tdd_r10, 0, sizeof(rrc_phy_meas_subframe_pattern_tdd_r10_t));

    /* This function parses rrc_phy_meas_subframe_pattern_tdd_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_meas_subframe_pattern_tdd_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_meas_subframe_pattern_tdd_r10->bitmask & RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG1_5_R10)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config1_5_r10) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config1_5_r10); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config1_5_r10[loop], (void*)(p_src + *p_length_read), "subframe_config1_5_r10[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_phy_meas_subframe_pattern_tdd_r10->bitmask & RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG0_R10)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config0_r10) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config0_r10); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config0_r10[loop], (void*)(p_src + *p_length_read), "subframe_config0_r10[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_phy_meas_subframe_pattern_tdd_r10->bitmask & RRC_PHY_SUBFRAME_PATTERNTDD_SUBFRAME_CONFIG6_R10)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config6_r10) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config6_r10); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_phy_meas_subframe_pattern_tdd_r10->subframe_config6_r10[loop], (void*)(p_src + *p_length_read), "subframe_config6_r10[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_meas_subframe_pattern_r10
(
    rrc_phy_meas_subframe_pattern_r10_t *p_rrc_phy_meas_subframe_pattern_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_meas_subframe_pattern_r10, 0, sizeof(rrc_phy_meas_subframe_pattern_r10_t));

    /* This function parses rrc_phy_meas_subframe_pattern_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_meas_subframe_pattern_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_meas_subframe_pattern_r10->bitmask & RRC_PHY_MEAS_SUBFRAME_PATTERN_FDD_R10)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_fdd_r10(
        &p_rrc_phy_meas_subframe_pattern_r10->subframe_pattern_fdd_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_meas_subframe_pattern_r10->bitmask & RRC_PHY_MEAS_SUBFRAME_PATTERN_TDD_R10)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_tdd_r10(
        &p_rrc_phy_meas_subframe_pattern_r10->subframe_pattern_tdd_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup
(
    rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup_t *p_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup, 0, sizeof(rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup_t));

    /* This function parses rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup */

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_r10(
        &p_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup->csi_meas_subframe_set1_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_r10(
        &p_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup->csi_meas_subframe_set2_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_cqi_report_csi_subframePattern_r10
(
    rrc_phy_cqi_report_csi_subframePattern_r10_t *p_rrc_phy_cqi_report_csi_subframePattern_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_cqi_report_csi_subframePattern_r10, 0, sizeof(rrc_phy_cqi_report_csi_subframePattern_r10_t));

    /* This function parses rrc_phy_cqi_report_csi_subframePattern_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_cqi_report_csi_subframePattern_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_phy_cqi_report_csi_subframePattern_r10->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_phy_cqi_report_csi_subframePattern_r10->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_phy_cqi_report_csi_subframePattern_r10->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_phy_cqi_report_csi_subframePattern_r10->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_phy_cqi_report_csi_subframePattern_r10->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAMEPATTERN_CONFIG_SETUP)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_csi_subframe_pattern_config_r10_setup(
        &p_rrc_phy_cqi_report_csi_subframePattern_r10->csi_subframe_pattern_config_r10_setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_cqi_report_config_r10
(
    rrc_cqi_report_config_r10_t *p_rrc_cqi_report_config_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_cqi_report_config_r10, 0, sizeof(rrc_cqi_report_config_r10_t));

    /* This function parses rrc_cqi_report_config_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_cqi_report_config_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_cqi_report_config_r10->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_APERIODIC_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_aperiodic_r10(
        &p_rrc_cqi_report_config_r10->cqi_report_aperiodic_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_cqi_report_config_r10->nomPDSCH_rs_epre_offset, p_src + *p_length_read, "nomPDSCH_rs_epre_offset");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_cqi_report_config_r10->nomPDSCH_rs_epre_offset < -1) || (p_rrc_cqi_report_config_r10->nomPDSCH_rs_epre_offset > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_cqi_report_config_r10->nomPDSCH_rs_epre_offset] should be in range "
            "-1 to 6. Incorrect value %d received.", p_rrc_cqi_report_config_r10->nomPDSCH_rs_epre_offset);
        return RRC_FAILURE;
    }

    if (p_rrc_cqi_report_config_r10->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_REPORT_PERIODIC_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_periodic_r10(
        &p_rrc_cqi_report_config_r10->cqi_report_periodic_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_cqi_report_config_r10->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_PMI_RI_REPORT_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_cqi_report_config_r10->cqi_report_pmi_ri_report_r10, p_src + *p_length_read, "cqi_report_pmi_ri_report_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_cqi_report_config_r10->cqi_report_pmi_ri_report_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_cqi_report_config_r10->cqi_report_pmi_ri_report_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_cqi_report_config_r10->cqi_report_pmi_ri_report_r10);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_cqi_report_config_r10->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_CSI_SUBFRAME_PATTERN_CONFIG_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_csi_subframePattern_r10(
        &p_rrc_cqi_report_config_r10->csi_subframePattern_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_additional_spectrum_emission_ca_r10
(
    rrc_additional_spectrum_emission_ca_r10_t *p_rrc_additional_spectrum_emission_ca_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_additional_spectrum_emission_ca_r10, 0, sizeof(rrc_additional_spectrum_emission_ca_r10_t));

    /* This function parses rrc_additional_spectrum_emission_ca_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_additional_spectrum_emission_ca_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_additional_spectrum_emission_ca_r10->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_additional_spectrum_emission_ca_r10->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_additional_spectrum_emission_ca_r10->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_additional_spectrum_emission_ca_r10->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_additional_spectrum_emission_ca_r10->bitmask & RRC_PHY_ADDITIONAL_SPECTRUM_EMISSION_CA_R10_PCELL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_additional_spectrum_emission_ca_r10->additional_spectrum_emission_pcell, p_src + *p_length_read, "additional_spectrum_emission_pcell");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_additional_spectrum_emission_ca_r10->additional_spectrum_emission_pcell < 1) || (p_rrc_additional_spectrum_emission_ca_r10->additional_spectrum_emission_pcell > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_additional_spectrum_emission_ca_r10->additional_spectrum_emission_pcell] should be in range "
            "1 to 32. Incorrect value %u received.", p_rrc_additional_spectrum_emission_ca_r10->additional_spectrum_emission_pcell);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_n1pucch_an_cs_r10
(
    n1pucch_an_cs_r10_t *p_n1pucch_an_cs_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_n1pucch_an_cs_r10, 0, sizeof(n1pucch_an_cs_r10_t));

    /* This function parses n1pucch_an_cs_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_n1pucch_an_cs_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_n1pucch_an_cs_r10->count < 1) || (p_n1pucch_an_cs_r10->count > MAX_N1PUCCH_AN_CS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_n1pucch_an_cs_r10->count] should be in range "
            "1 to MAX_N1PUCCH_AN_CS. Incorrect value %u received.", p_n1pucch_an_cs_r10->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_n1pucch_an_cs_r10->count * sizeof(p_n1pucch_an_cs_r10->n1_pucch_an_cs[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_n1pucch_an_cs_r10->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_n1pucch_an_cs_r10->n1_pucch_an_cs[loop], (void*)(p_src + *p_length_read), "n1_pucch_an_cs[]");
            if (p_n1pucch_an_cs_r10->n1_pucch_an_cs[loop] > 2047)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_n1pucch_an_cs_r10->n1_pucch_an_cs[%u] should be less"
                    " than or equal to 2047. "
                    "Incorrect value %d received.", loop, p_n1pucch_an_cs_r10->n1_pucch_an_cs[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_n1pucch_an_cs_list_r10
(
    n1pucch_an_cs_list_r10_t *p_n1pucch_an_cs_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_n1pucch_an_cs_list_r10, 0, sizeof(n1pucch_an_cs_list_r10_t));

    /* This function parses n1pucch_an_cs_list_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_n1pucch_an_cs_list_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_n1pucch_an_cs_list_r10->count < 1) || (p_n1pucch_an_cs_list_r10->count > MAX_N1PUCCH_AN_CS_LIST))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_n1pucch_an_cs_list_r10->count] should be in range "
            "1 to MAX_N1PUCCH_AN_CS_LIST. Incorrect value %u received.", p_n1pucch_an_cs_list_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_n1pucch_an_cs_list_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_n1pucch_an_cs_r10(
                &p_n1pucch_an_cs_list_r10->n1_pucch_an_cs[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_channel_selection_n1_pucch_an_cs_r10
(
    rrc_channel_selection_n1_pucch_an_cs_r10_t *p_rrc_channel_selection_n1_pucch_an_cs_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_channel_selection_n1_pucch_an_cs_r10, 0, sizeof(rrc_channel_selection_n1_pucch_an_cs_r10_t));

    /* This function parses rrc_channel_selection_n1_pucch_an_cs_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_channel_selection_n1_pucch_an_cs_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_channel_selection_n1_pucch_an_cs_r10->request_type, p_src + *p_length_read, "request_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_channel_selection_n1_pucch_an_cs_r10->request_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_channel_selection_n1_pucch_an_cs_r10->request_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_channel_selection_n1_pucch_an_cs_r10->request_type);
        return RRC_FAILURE;
    }

    if (p_rrc_channel_selection_n1_pucch_an_cs_r10->bitmask & RRC_N1PUCCH_AN_CS_LIST_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_n1pucch_an_cs_list_r10(
        &p_rrc_channel_selection_n1_pucch_an_cs_r10->n1pucch_an_cs_list_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pucch_channel_selection_config_v1020
(
    rrc_pucch_channel_selection_config_v1020_t *p_rrc_pucch_channel_selection_config_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_pucch_channel_selection_config_v1020, 0, sizeof(rrc_pucch_channel_selection_config_v1020_t));

    /* This function parses rrc_pucch_channel_selection_config_v1020 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pucch_channel_selection_config_v1020->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_pucch_channel_selection_config_v1020->bitmask & RRC_N1PUCCH_AN_CS_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_channel_selection_n1_pucch_an_cs_r10(
        &p_rrc_pucch_channel_selection_config_v1020->channel_selection_n1_pucch_an_cs_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_physical_config_dedicated_extended
(
    rrc_phy_physical_config_dedicated_extended_t *p_rrc_phy_physical_config_dedicated_extended,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_physical_config_dedicated_extended, 0, sizeof(rrc_phy_physical_config_dedicated_extended_t));

    /* This function parses rrc_phy_physical_config_dedicated_extended */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_physical_config_dedicated_extended->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_physical_config_dedicated_extended->bitmask & RRC_PHY_ADDITIONAL_SPECTRUM_EMISSION_CA_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_additional_spectrum_emission_ca_r10(
        &p_rrc_phy_physical_config_dedicated_extended->additional_spectrum_emission_ca,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated_extended->bitmask & RRC_PHY_PUCCH_CHANNEL_SELECTION_CONFIG_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_pucch_channel_selection_config_v1020(
        &p_rrc_phy_physical_config_dedicated_extended->pucch_channel_selection_config_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_phy_physical_config_dedicated
(
    rrc_phy_physical_config_dedicated_t *p_rrc_phy_physical_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_phy_physical_config_dedicated, 0, sizeof(rrc_phy_physical_config_dedicated_t));

    /* This function parses rrc_phy_physical_config_dedicated */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_phy_physical_config_dedicated->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_PDSCH_CONFIGURATION_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_pdsch_configuration_dedicated(
        &p_rrc_phy_physical_config_dedicated->pdsch_configuration_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_PUCCH_CONFIGURATION_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_pucch_configuration_dedicated(
        &p_rrc_phy_physical_config_dedicated->pucch_configuration_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_PUSCH_CONFIGURATION_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_pusch_configuration_dedicated(
        &p_rrc_phy_physical_config_dedicated->pusch_configuration_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_UPLINK_POWER_CONTROL_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_uplink_power_control_dedicated(
        &p_rrc_phy_physical_config_dedicated->uplink_power_control_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_TPC_PDCCH_CONFIG_PUCCH_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_tpc_pdcch_configuration(
        &p_rrc_phy_physical_config_dedicated->tpc_pdcch_config_pucch,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_TPC_PDCCH_CONFIG_PUSCH_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_tpc_pdcch_configuration(
        &p_rrc_phy_physical_config_dedicated->tpc_pdcch_config_pusch,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_CQI_REPORTING_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_reporting(
        &p_rrc_phy_physical_config_dedicated->cqi_reporting,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_SOUNDING_RS_UL_CONFIG_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_sounding_rs_ul_config_dedicated(
        &p_rrc_phy_physical_config_dedicated->sounding_rs_ul_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_ANTENNA_INFORMATION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_antenna_information(
        &p_rrc_phy_physical_config_dedicated->antenna_information,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_SCHEDULING_REQUEST_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_scheduling_request_config(
        &p_rrc_phy_physical_config_dedicated->scheduling_request_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_CQI_REPORT_CONFIG_V920_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_config_v920(
        &p_rrc_phy_physical_config_dedicated->cqi_report_config_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_ANTENNA_INFO_V920_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_antenna_info_v920(
        &p_rrc_phy_physical_config_dedicated->antenna_info_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_ANTENNA_INFO_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_antenna_info_r10(
        &p_rrc_phy_physical_config_dedicated->antenna_info_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_ANTENNA_INFO_UL_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_antenna_info_ul_r10(
        &p_rrc_phy_physical_config_dedicated->antenna_info_ul_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_CQI_REPORT_CONFIG_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_cqi_report_config_r10(
        &p_rrc_phy_physical_config_dedicated->cqi_report_config_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_phy_physical_config_dedicated->bitmask & RRC_PHY_CONFIG_DEDICATED_EXTENDED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated_extended(
        &p_rrc_phy_physical_config_dedicated->phy_physical_config_dedicated_extended,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_to_remove_list
(
    meas_object_to_remove_list_t *p_meas_object_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_object_to_remove_list, 0, sizeof(meas_object_to_remove_list_t));

    /* This function parses meas_object_to_remove_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_to_remove_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_to_remove_list->count > MAX_MEAS_OBJECT_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_to_remove_list->count] should be less than"
            " or equal to MAX_MEAS_OBJECT_ID. Incorrect value %u received.", p_meas_object_to_remove_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_meas_object_to_remove_list->count * sizeof(p_meas_object_to_remove_list->meas_object_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_object_to_remove_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_meas_object_to_remove_list->meas_object_id[loop], (void*)(p_src + *p_length_read), "meas_object_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_index_list
(
    cell_index_list_t *p_cell_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cell_index_list, 0, sizeof(cell_index_list_t));

    /* This function parses cell_index_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_index_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_index_list->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_index_list->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_cell_index_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_cell_index_list->count * sizeof(p_cell_index_list->cell_index[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cell_index_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_index_list->cell_index[loop], (void*)(p_src + *p_length_read), "cell_index[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod
(
    cells_to_add_mod_t *p_cells_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod, 0, sizeof(cells_to_add_mod_t));

    /* This function parses cells_to_add_mod */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod->cell_index > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod->cell_index] should be less than"
            " or equal to 32. Incorrect value %u received.", p_cells_to_add_mod->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cells_to_add_mod->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod->phys_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod->phys_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_cells_to_add_mod->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod->cell_individual_offset, p_src + *p_length_read, "cell_individual_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod->cell_individual_offset > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod->cell_individual_offset] should be less than"
            " or equal to 30. Incorrect value %u received.", p_cells_to_add_mod->cell_individual_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list
(
    cells_to_add_mod_list_t *p_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_list, 0, sizeof(cells_to_add_mod_list_t));

    /* This function parses cells_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_list->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_list->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_cells_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cells_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod(
                &p_cells_to_add_mod_list->cells_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod
(
    black_cells_to_add_mod_t *p_black_cells_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_black_cells_to_add_mod, 0, sizeof(black_cells_to_add_mod_t));

    /* This function parses black_cells_to_add_mod */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_black_cells_to_add_mod->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_black_cells_to_add_mod->cell_index > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_cells_to_add_mod->cell_index] should be less than"
            " or equal to 32. Incorrect value %u received.", p_black_cells_to_add_mod->cell_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_phy_cell_id_range(
        &p_black_cells_to_add_mod->phys_cell_id_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_list
(
    black_cells_to_add_mod_list_t *p_black_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_black_cells_to_add_mod_list, 0, sizeof(black_cells_to_add_mod_list_t));

    /* This function parses black_cells_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_black_cells_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_black_cells_to_add_mod_list->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_cells_to_add_mod_list->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_black_cells_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_black_cells_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_black_cells_to_add_mod(
                &p_black_cells_to_add_mod_list->black_cells_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_subframe_cell_list_r10
(
    meas_subframe_cell_list_r10_t *p_meas_subframe_cell_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_subframe_cell_list_r10, 0, sizeof(meas_subframe_cell_list_r10_t));

    /* This function parses meas_subframe_cell_list_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_subframe_cell_list_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_subframe_cell_list_r10->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_subframe_cell_list_r10->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_meas_subframe_cell_list_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_subframe_cell_list_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_phy_cell_id_range(
                &p_meas_subframe_cell_list_r10->meas_subframe_cells[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_subframe_pattern_config_neigh_r10_setup
(
    meas_subframe_pattern_config_neigh_r10_setup_t *p_meas_subframe_pattern_config_neigh_r10_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_subframe_pattern_config_neigh_r10_setup, 0, sizeof(meas_subframe_pattern_config_neigh_r10_setup_t));

    /* This function parses meas_subframe_pattern_config_neigh_r10_setup */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_subframe_pattern_config_neigh_r10_setup->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_r10(
        &p_meas_subframe_pattern_config_neigh_r10_setup->meas_subframe_pattern_neigh_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_subframe_pattern_config_neigh_r10_setup->bitmask & MEAS_SUBFRAME_CELL_LIST_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_subframe_cell_list_r10(
        &p_meas_subframe_pattern_config_neigh_r10_setup->meas_subframe_cell_list_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_subframe_pattern_config_neigh_r10
(
    meas_subframe_pattern_config_neigh_r10_t *p_meas_subframe_pattern_config_neigh_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_subframe_pattern_config_neigh_r10, 0, sizeof(meas_subframe_pattern_config_neigh_r10_t));

    /* This function parses meas_subframe_pattern_config_neigh_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_subframe_pattern_config_neigh_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_subframe_pattern_config_neigh_r10->bitmask & MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_subframe_pattern_config_neigh_r10_setup(
        &p_meas_subframe_pattern_config_neigh_r10->meas_subframe_pattern_config_neigh_r10_setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_eutra
(
    meas_object_eutra_t *p_meas_object_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_eutra, 0, sizeof(meas_object_eutra_t));

    /* This function parses meas_object_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_meas_object_eutra->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_eutra->allowed_meas_bandwidth, p_src + *p_length_read, "allowed_meas_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_eutra->allowed_meas_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_eutra->allowed_meas_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_meas_object_eutra->allowed_meas_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_eutra->presence_antenna_port1, p_src + *p_length_read, "presence_antenna_port1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_eutra->presence_antenna_port1 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_eutra->presence_antenna_port1] should be less than"
            " or equal to 1. Incorrect value %u received.", p_meas_object_eutra->presence_antenna_port1);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_eutra->neigh_cell_config, p_src + *p_length_read, "neigh_cell_config");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_eutra->offset_freq, p_src + *p_length_read, "offset_freq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_eutra->offset_freq > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_eutra->offset_freq] should be less than"
            " or equal to 30. Incorrect value %u received.", p_meas_object_eutra->offset_freq);
        return RRC_FAILURE;
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_CELLS_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_index_list(
        &p_meas_object_eutra->cells_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_CELLS_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_list(
        &p_meas_object_eutra->cells_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_index_list(
        &p_meas_object_eutra->black_cells_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_BLACK_CELLS_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_black_cells_to_add_mod_list(
        &p_meas_object_eutra->black_cells_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_eutra->cell_for_which_to_report_cgi, p_src + *p_length_read, "cell_for_which_to_report_cgi");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_eutra->cell_for_which_to_report_cgi > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_eutra->cell_for_which_to_report_cgi] should be less than"
            " or equal to 503. Incorrect value %u received.", p_meas_object_eutra->cell_for_which_to_report_cgi);
        return RRC_FAILURE;
    }
    }

    if (p_meas_object_eutra->bitmask & MEAS_OBJECT_EUTRA_CYCLE_SCELL_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_eutra->meas_cycle_scell_r10, p_src + *p_length_read, "meas_cycle_scell_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_eutra->meas_cycle_scell_r10 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_eutra->meas_cycle_scell_r10] should be less than"
            " or equal to 7. Incorrect value %u received.", p_meas_object_eutra->meas_cycle_scell_r10);
        return RRC_FAILURE;
    }
    }

    if (p_meas_object_eutra->bitmask & MEAS_SUBFRAME_PATTERN_CONFIG_NEIGH_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_subframe_pattern_config_neigh_r10(
        &p_meas_object_eutra->meas_subframe_pattern_config_neigh_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_utra_fdd
(
    cells_to_add_mod_utra_fdd_t *p_cells_to_add_mod_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_utra_fdd, 0, sizeof(cells_to_add_mod_utra_fdd_t));

    /* This function parses cells_to_add_mod_utra_fdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_utra_fdd->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_utra_fdd->cell_index > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_utra_fdd->cell_index] should be less than"
            " or equal to 32. Incorrect value %u received.", p_cells_to_add_mod_utra_fdd->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cells_to_add_mod_utra_fdd->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_utra_fdd->phys_cell_id > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_utra_fdd->phys_cell_id] should be less than"
            " or equal to 511. Incorrect value %u received.", p_cells_to_add_mod_utra_fdd->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_utra_fdd
(
    cells_to_add_mod_list_utra_fdd_t *p_cells_to_add_mod_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_list_utra_fdd, 0, sizeof(cells_to_add_mod_list_utra_fdd_t));

    /* This function parses cells_to_add_mod_list_utra_fdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_list_utra_fdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_list_utra_fdd->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_list_utra_fdd->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_cells_to_add_mod_list_utra_fdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cells_to_add_mod_list_utra_fdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_utra_fdd(
                &p_cells_to_add_mod_list_utra_fdd->cells_to_add_mod_utra_fdd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_utra_tdd
(
    cells_to_add_mod_utra_tdd_t *p_cells_to_add_mod_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_utra_tdd, 0, sizeof(cells_to_add_mod_utra_tdd_t));

    /* This function parses cells_to_add_mod_utra_tdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_utra_tdd->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_utra_tdd->cell_index > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_utra_tdd->cell_index] should be less than"
            " or equal to 32. Incorrect value %u received.", p_cells_to_add_mod_utra_tdd->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_utra_tdd->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_utra_tdd->phys_cell_id > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_utra_tdd->phys_cell_id] should be less than"
            " or equal to 127. Incorrect value %u received.", p_cells_to_add_mod_utra_tdd->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_utra_tdd
(
    cells_to_add_mod_list_utra_tdd_t *p_cells_to_add_mod_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_list_utra_tdd, 0, sizeof(cells_to_add_mod_list_utra_tdd_t));

    /* This function parses cells_to_add_mod_list_utra_tdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_list_utra_tdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_list_utra_tdd->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_list_utra_tdd->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_cells_to_add_mod_list_utra_tdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cells_to_add_mod_list_utra_tdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_utra_tdd(
                &p_cells_to_add_mod_list_utra_tdd->cells_to_add_mod_utra_tdd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_utra_cells_to_add_mod_list
(
    meas_object_utra_cells_to_add_mod_list_t *p_meas_object_utra_cells_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_utra_cells_to_add_mod_list, 0, sizeof(meas_object_utra_cells_to_add_mod_list_t));

    /* This function parses meas_object_utra_cells_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_utra_cells_to_add_mod_list->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_object_utra_cells_to_add_mod_list->bitmask & MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_FDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_list_utra_fdd(
        &p_meas_object_utra_cells_to_add_mod_list->cells_to_add_mod_list_utra_fdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_utra_cells_to_add_mod_list->bitmask & MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_TDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_list_utra_tdd(
        &p_meas_object_utra_cells_to_add_mod_list->cells_to_add_mod_list_utra_tdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_utra_cell_for_which_to_report_cgi
(
    meas_object_utra_cell_for_which_to_report_cgi_t *p_meas_object_utra_cell_for_which_to_report_cgi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_object_utra_cell_for_which_to_report_cgi, 0, sizeof(meas_object_utra_cell_for_which_to_report_cgi_t));

    /* This function parses meas_object_utra_cell_for_which_to_report_cgi */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_utra_cell_for_which_to_report_cgi->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_object_utra_cell_for_which_to_report_cgi->bitmask & MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_FDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_utra_cell_for_which_to_report_cgi->utra_fdd, p_src + *p_length_read, "utra_fdd");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_utra_cell_for_which_to_report_cgi->utra_fdd > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_utra_cell_for_which_to_report_cgi->utra_fdd] should be less than"
            " or equal to 511. Incorrect value %u received.", p_meas_object_utra_cell_for_which_to_report_cgi->utra_fdd);
        return RRC_FAILURE;
    }
    }

    if (p_meas_object_utra_cell_for_which_to_report_cgi->bitmask & MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_UTRA_TDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_utra_cell_for_which_to_report_cgi->utra_tdd, p_src + *p_length_read, "utra_tdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_utra_cell_for_which_to_report_cgi->utra_tdd > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_utra_cell_for_which_to_report_cgi->utra_tdd] should be less than"
            " or equal to 127. Incorrect value %u received.", p_meas_object_utra_cell_for_which_to_report_cgi->utra_tdd);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_utra
(
    meas_object_utra_t *p_meas_object_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_utra, 0, sizeof(meas_object_utra_t));

    /* This function parses meas_object_utra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_utra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_utra->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_utra->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_utra->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_meas_object_utra->carrier_freq);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_meas_object_utra->offset_freq, p_src + *p_length_read, "offset_freq");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_utra->offset_freq < -15) || (p_meas_object_utra->offset_freq > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_utra->offset_freq] should be in range "
            "-15 to 15. Incorrect value %d received.", p_meas_object_utra->offset_freq);
        return RRC_FAILURE;
    }

    if (p_meas_object_utra->bitmask & MEAS_OBJECT_UTRA_CELLS_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_index_list(
        &p_meas_object_utra->cells_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_utra->bitmask & MEAS_OBJECT_UTRA_CELLS_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_utra_cells_to_add_mod_list(
        &p_meas_object_utra->cells_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_utra->bitmask & MEAS_OBJECT_UTRA_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_utra_cell_for_which_to_report_cgi(
        &p_meas_object_utra->cell_for_which_to_report_cgi,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phys_cell_id_geran
(
    phys_cell_id_geran_t *p_phys_cell_id_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phys_cell_id_geran, 0, sizeof(phys_cell_id_geran_t));

    /* This function parses phys_cell_id_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phys_cell_id_geran->network_colour_code, p_src + *p_length_read, "network_colour_code");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phys_cell_id_geran->base_station_colour_code, p_src + *p_length_read, "base_station_colour_code");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_geran
(
    meas_object_geran_t *p_meas_object_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_geran, 0, sizeof(meas_object_geran_t));

    /* This function parses meas_object_geran */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_geran->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_carrier_freqs_geran(
        &p_meas_object_geran->carrier_freqs,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_meas_object_geran->offset_freq, p_src + *p_length_read, "offset_freq");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_geran->offset_freq < -15) || (p_meas_object_geran->offset_freq > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_geran->offset_freq] should be in range "
            "-15 to 15. Incorrect value %d received.", p_meas_object_geran->offset_freq);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_geran->ncc_Permitted, p_src + *p_length_read, "ncc_Permitted");
    *p_length_read += sizeof(U8);

    if (p_meas_object_geran->bitmask & MEAS_OBJECT_GERAN_CELL_FOR_WHICH_TO_REPORT_CGI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_geran(
        &p_meas_object_geran->cell_for_which_to_report_cgi,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_cdma2000
(
    carrier_freq_cdma2000_t *p_carrier_freq_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_cdma2000, 0, sizeof(carrier_freq_cdma2000_t));

    /* This function parses carrier_freq_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_cdma2000->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_cdma2000->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_cdma2000->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_carrier_freq_cdma2000->band_class);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_cdma2000->arfcn, p_src + *p_length_read, "arfcn");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_cdma2000->arfcn > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_cdma2000->arfcn] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_carrier_freq_cdma2000->arfcn);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_cdma2000
(
    cells_to_add_mod_cdma2000_t *p_cells_to_add_mod_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_cdma2000, 0, sizeof(cells_to_add_mod_cdma2000_t));

    /* This function parses cells_to_add_mod_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_cdma2000->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_cdma2000->cell_index > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_cdma2000->cell_index] should be less than"
            " or equal to 32. Incorrect value %u received.", p_cells_to_add_mod_cdma2000->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cells_to_add_mod_cdma2000->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_cdma2000->phys_cell_id > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_cdma2000->phys_cell_id] should be less than"
            " or equal to 511. Incorrect value %u received.", p_cells_to_add_mod_cdma2000->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_add_mod_list_cdma2000_list
(
    cells_to_add_mod_list_cdma2000_list_t *p_cells_to_add_mod_list_cdma2000_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cells_to_add_mod_list_cdma2000_list, 0, sizeof(cells_to_add_mod_list_cdma2000_list_t));

    /* This function parses cells_to_add_mod_list_cdma2000_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_add_mod_list_cdma2000_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cells_to_add_mod_list_cdma2000_list->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_add_mod_list_cdma2000_list->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_cells_to_add_mod_list_cdma2000_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cells_to_add_mod_list_cdma2000_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_cdma2000(
                &p_cells_to_add_mod_list_cdma2000_list->cells_to_add_mod_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_cdma2000
(
    meas_object_cdma2000_t *p_meas_object_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_cdma2000, 0, sizeof(meas_object_cdma2000_t));

    /* This function parses meas_object_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_cdma2000->cdma2000_type, p_src + *p_length_read, "cdma2000_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_cdma2000->cdma2000_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_cdma2000->cdma2000_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_meas_object_cdma2000->cdma2000_type);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_meas_object_cdma2000->carrier_freq_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_object_cdma2000->bitmask & MEAS_OBJECT_CDMA2000_SEARCH_WINDOW_SIZE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_cdma2000->search_window_size, p_src + *p_length_read, "search_window_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_cdma2000->search_window_size > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_cdma2000->search_window_size] should be less than"
            " or equal to 15. Incorrect value %u received.", p_meas_object_cdma2000->search_window_size);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_meas_object_cdma2000->offset_freq, p_src + *p_length_read, "offset_freq");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_cdma2000->offset_freq < -15) || (p_meas_object_cdma2000->offset_freq > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_cdma2000->offset_freq] should be in range "
            "-15 to 15. Incorrect value %d received.", p_meas_object_cdma2000->offset_freq);
        return RRC_FAILURE;
    }

    if (p_meas_object_cdma2000->bitmask & MEAS_OBJECT_CDMA2000_CELLS_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_index_list(
        &p_meas_object_cdma2000->cells_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_cdma2000->bitmask & MEAS_OBJECT_CDMA2000_CELLS_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cells_to_add_mod_list_cdma2000_list(
        &p_meas_object_cdma2000->cells_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_cdma2000->bitmask & MEAS_OBJECT_CDMA2000_CELL_FOR_WHICH_TO_REPEORT_CGI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_cdma2000->cells_for_which_to_report_cgi, p_src + *p_length_read, "cells_for_which_to_report_cgi");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_cdma2000->cells_for_which_to_report_cgi > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_cdma2000->cells_for_which_to_report_cgi] should be less than"
            " or equal to 511. Incorrect value %u received.", p_meas_object_cdma2000->cells_for_which_to_report_cgi);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_band
(
    wlan_band_t *p_wlan_band,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_wlan_band, 0, sizeof(wlan_band_t));

    /* This function parses wlan_band */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_band->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_band->count > MAX_WLAN_BAND))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_band->count] should be less than"
            " or equal to MAX_WLAN_BAND. Incorrect value %u received.", p_wlan_band->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_wlan_band->count * sizeof(p_wlan_band->wlan_band[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_wlan_band->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_wlan_band->wlan_band[loop], (void*)(p_src + *p_length_read), "wlan_band[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_channel
(
    wlan_channel_t *p_wlan_channel,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_wlan_channel, 0, sizeof(wlan_channel_t));

    /* This function parses wlan_channel */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_channel->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_channel->count > MAX_WLAN_CHANNEL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_channel->count] should be less than"
            " or equal to MAX_WLAN_CHANNEL. Incorrect value %u received.", p_wlan_channel->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_wlan_channel->count * sizeof(p_wlan_channel->channel[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_wlan_channel->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_wlan_channel->channel[loop], (void*)(p_src + *p_length_read), "channel[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_carrier_info
(
    wlan_carrier_info_t *p_wlan_carrier_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_carrier_info, 0, sizeof(wlan_carrier_info_t));

    /* This function parses wlan_carrier_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_wlan_carrier_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_wlan_carrier_info->bitmask & WLAN_CARRIER_INFO_OPERATING_CLASS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_carrier_info->operating_class, p_src + *p_length_read, "operating_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_carrier_info->operating_class > 255))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_carrier_info->operating_class] should be less than"
            " or equal to 255. Incorrect value %u received.", p_wlan_carrier_info->operating_class);
        return RRC_FAILURE;
    }
    }

    if (p_wlan_carrier_info->bitmask & WLAN_CARRIER_INFO_COUNTRY_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_carrier_info->country_code, p_src + *p_length_read, "country_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_carrier_info->country_code > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_carrier_info->country_code] should be less than"
            " or equal to 3. Incorrect value %u received.", p_wlan_carrier_info->country_code);
        return RRC_FAILURE;
    }
    }

    if (p_wlan_carrier_info->bitmask & WLAN_CARRIER_INFO_CHANNEL_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_channel(
        &p_wlan_carrier_info->channel_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_carrier_info_list
(
    wlan_carrier_info_list_t *p_wlan_carrier_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_carrier_info_list, 0, sizeof(wlan_carrier_info_list_t));

    /* This function parses wlan_carrier_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_carrier_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_carrier_info_list->count > MAX_WLAN_CARRIER_INFO))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_carrier_info_list->count] should be less than"
            " or equal to MAX_WLAN_CARRIER_INFO. Incorrect value %u received.", p_wlan_carrier_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_wlan_carrier_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_wlan_carrier_info(
                &p_wlan_carrier_info_list->wlan_carrier_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_wlan_carrier_freq
(
    meas_object_wlan_carrier_freq_t *p_meas_object_wlan_carrier_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_wlan_carrier_freq, 0, sizeof(meas_object_wlan_carrier_freq_t));

    /* This function parses meas_object_wlan_carrier_freq */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_wlan_carrier_freq->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_object_wlan_carrier_freq->bitmask & WLAN_CARRIER_FREQ_BAND_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_band(
        &p_meas_object_wlan_carrier_freq->wlan_band_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_wlan_carrier_freq->bitmask & WLAN_CARRIER_FREQ_CARRIER_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_carrier_info_list(
        &p_meas_object_wlan_carrier_freq->wlan_carrier_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_identifier_ssid
(
    wlan_identifier_ssid_t *p_wlan_identifier_ssid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_wlan_identifier_ssid, 0, sizeof(wlan_identifier_ssid_t));

    /* This function parses wlan_identifier_ssid */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_identifier_ssid->numOctets, p_src + *p_length_read, "numOctets");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_wlan_identifier_ssid->numOctets < 1) || (p_wlan_identifier_ssid->numOctets > MAX_SSID_BYTES))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_identifier_ssid->numOctets] should be in range "
            "1 to MAX_SSID_BYTES. Incorrect value %u received.", p_wlan_identifier_ssid->numOctets);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_wlan_identifier_ssid->data) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_wlan_identifier_ssid->data); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_wlan_identifier_ssid->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_identifier
(
    wlan_identifier_t *p_wlan_identifier,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_identifier, 0, sizeof(wlan_identifier_t));

    /* This function parses wlan_identifier */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_wlan_identifier->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_wlan_identifier->bitmask & WLAN_ID_SSID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_identifier_ssid(
        &p_wlan_identifier->ssid,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_wlan_identifier->bitmask & WLAN_ID_BSSID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_wlan_identifier->bssid) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_wlan_identifier->bssid); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_wlan_identifier->bssid[loop], (void*)(p_src + *p_length_read), "bssid[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_wlan_identifier->bitmask & WLAN_ID_HESSID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_wlan_identifier->hessid) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_wlan_identifier->hessid); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_wlan_identifier->hessid[loop], (void*)(p_src + *p_length_read), "hessid[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_wlan_to_add_mod_list
(
    meas_object_wlan_to_add_mod_list_t *p_meas_object_wlan_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_wlan_to_add_mod_list, 0, sizeof(meas_object_wlan_to_add_mod_list_t));

    /* This function parses meas_object_wlan_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_wlan_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_wlan_to_add_mod_list->count > MAX_WLAN_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_wlan_to_add_mod_list->count] should be less than"
            " or equal to MAX_WLAN_ID. Incorrect value %u received.", p_meas_object_wlan_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_object_wlan_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_wlan_identifier(
                &p_meas_object_wlan_to_add_mod_list->wlan_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_index_list
(
    wlan_index_list_t *p_wlan_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_index_list, 0, sizeof(wlan_index_list_t));

    /* This function parses wlan_index_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_index_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_index_list->count > MAX_WLAN_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_index_list->count] should be less than"
            " or equal to MAX_WLAN_ID. Incorrect value %u received.", p_wlan_index_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_wlan_index_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_wlan_identifier(
                &p_wlan_index_list->wlan_to_remove[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_wlan
(
    meas_object_wlan_t *p_meas_object_wlan,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_wlan, 0, sizeof(meas_object_wlan_t));

    /* This function parses meas_object_wlan */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_wlan->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_object_wlan->bitmask & MEAS_OBJECT_WLAN_CARRIER_FREQ_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_wlan_carrier_freq(
        &p_meas_object_wlan->carrier_freq,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_wlan->bitmask & MEAS_OBJECT_WLAN_ID_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_wlan_to_add_mod_list(
        &p_meas_object_wlan->wlan_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_wlan->bitmask & MEAS_OBJECT_WLAN_ID_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_index_list(
        &p_meas_object_wlan->wlan_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_periodicity_and_offfset_r15
(
    periodicity_and_offfset_r15_t *p_periodicity_and_offfset_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_periodicity_and_offfset_r15, 0, sizeof(periodicity_and_offfset_r15_t));

    /* This function parses periodicity_and_offfset_r15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_periodicity_and_offfset_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF5_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf5_r15, p_src + *p_length_read, "sf5_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf5_r15 > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf5_r15] should be less than"
            " or equal to 4. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf5_r15);
        return RRC_FAILURE;
    }
    }

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf10_r15, p_src + *p_length_read, "sf10_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf10_r15 > 9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf10_r15] should be less than"
            " or equal to 9. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf10_r15);
        return RRC_FAILURE;
    }
    }

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF20_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf20_r15, p_src + *p_length_read, "sf20_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf20_r15 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf20_r15] should be less than"
            " or equal to 19. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf20_r15);
        return RRC_FAILURE;
    }
    }

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF40_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf40_r15, p_src + *p_length_read, "sf40_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf40_r15 > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf40_r15] should be less than"
            " or equal to 39. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf40_r15);
        return RRC_FAILURE;
    }
    }

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF80_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf80_r15, p_src + *p_length_read, "sf80_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf80_r15 > 79))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf80_r15] should be less than"
            " or equal to 79. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf80_r15);
        return RRC_FAILURE;
    }
    }

    if (p_periodicity_and_offfset_r15->bitmask & PERIODICITY_AND_OFFSET_SF160_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_periodicity_and_offfset_r15->sf160_r15, p_src + *p_length_read, "sf160_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_periodicity_and_offfset_r15->sf160_r15 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_periodicity_and_offfset_r15->sf160_r15] should be less than"
            " or equal to 159. Incorrect value %u received.", p_periodicity_and_offfset_r15->sf160_r15);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mtc_ssb_nr_r15
(
    mtc_ssb_nr_r15_t *p_mtc_ssb_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mtc_ssb_nr_r15, 0, sizeof(mtc_ssb_nr_r15_t));

    /* This function parses mtc_ssb_nr_r15 */

    if (RRC_FAILURE == rrc_il_parse_periodicity_and_offfset_r15(
        &p_mtc_ssb_nr_r15->periodicity_and_offfset_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mtc_ssb_nr_r15->ssb_duration_r15, p_src + *p_length_read, "ssb_duration_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mtc_ssb_nr_r15->ssb_duration_r15 > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mtc_ssb_nr_r15->ssb_duration_r15] should be less than"
            " or equal to 4. Incorrect value %u received.", p_mtc_ssb_nr_r15->ssb_duration_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rs_config_ssb_nr_r15
(
    rs_config_ssb_nr_r15_t *p_rs_config_ssb_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rs_config_ssb_nr_r15, 0, sizeof(rs_config_ssb_nr_r15_t));

    /* This function parses rs_config_ssb_nr_r15 */

    if (RRC_FAILURE == rrc_il_parse_mtc_ssb_nr_r15(
        &p_rs_config_ssb_nr_r15->meas_timing_config_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rs_config_ssb_nr_r15->subcarrier_spacing_ssb_r15, p_src + *p_length_read, "subcarrier_spacing_ssb_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rs_config_ssb_nr_r15->subcarrier_spacing_ssb_r15 > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rs_config_ssb_nr_r15->subcarrier_spacing_ssb_r15] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rs_config_ssb_nr_r15->subcarrier_spacing_ssb_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_threshold_list_nr_r15
(
    threshold_list_nr_r15_t *p_threshold_list_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_threshold_list_nr_r15, 0, sizeof(threshold_list_nr_r15_t));

    /* This function parses threshold_list_nr_r15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_threshold_list_nr_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_threshold_list_nr_r15->bitmask & THRESHOLD_LIST_NR_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_list_nr_r15->rsrp_nr_r15, p_src + *p_length_read, "rsrp_nr_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_list_nr_r15->rsrp_nr_r15 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_list_nr_r15->rsrp_nr_r15] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_list_nr_r15->rsrp_nr_r15);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_list_nr_r15->bitmask & THRESHOLD_LIST_NR_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_list_nr_r15->rsrq_nr_r15, p_src + *p_length_read, "rsrq_nr_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_list_nr_r15->rsrq_nr_r15 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_list_nr_r15->rsrq_nr_r15] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_list_nr_r15->rsrq_nr_r15);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_list_nr_r15->bitmask & THRESHOLD_LIST_NR_SINR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_list_nr_r15->sinr_nr_r15, p_src + *p_length_read, "sinr_nr_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_list_nr_r15->sinr_nr_r15 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_list_nr_r15->sinr_nr_r15] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_list_nr_r15->sinr_nr_r15);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_r15
(
    black_cells_to_add_mod_r15_t *p_black_cells_to_add_mod_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_black_cells_to_add_mod_r15, 0, sizeof(black_cells_to_add_mod_r15_t));

    /* This function parses black_cells_to_add_mod_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_black_cells_to_add_mod_r15->cell_index_r15, p_src + *p_length_read, "cell_index_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_black_cells_to_add_mod_r15->cell_index_r15 < 1) || (p_black_cells_to_add_mod_r15->cell_index_r15 > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_cells_to_add_mod_r15->cell_index_r15] should be in range "
            "1 to 32. Incorrect value %u received.", p_black_cells_to_add_mod_r15->cell_index_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_black_cells_to_add_mod_r15->phys_cellid_r15, p_src + *p_length_read, "phys_cellid_r15");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - higher boundary] */
    if (p_black_cells_to_add_mod_r15->phys_cellid_r15 > 1007)
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_cells_to_add_mod_r15->phys_cellid_r15] should be in range "
            "0 to 1007. Incorrect value %u received.", p_black_cells_to_add_mod_r15->phys_cellid_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_black_cells_to_add_mod_list_r15
(
    black_cells_to_add_mod_list_r15_t *p_black_cells_to_add_mod_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_black_cells_to_add_mod_list_r15, 0, sizeof(black_cells_to_add_mod_list_r15_t));

    /* This function parses black_cells_to_add_mod_list_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_black_cells_to_add_mod_list_r15->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_black_cells_to_add_mod_list_r15->count > MAX_CELL_MEAS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_black_cells_to_add_mod_list_r15->count] should be less than"
            " or equal to MAX_CELL_MEAS. Incorrect value %u received.", p_black_cells_to_add_mod_list_r15->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_black_cells_to_add_mod_list_r15->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_black_cells_to_add_mod_r15(
                &p_black_cells_to_add_mod_list_r15->black_cells_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cells_to_report_SFTD_r15_list
(
    cells_to_report_SFTD_r15_list_t *p_cells_to_report_SFTD_r15_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cells_to_report_SFTD_r15_list, 0, sizeof(cells_to_report_SFTD_r15_list_t));

    /* This function parses cells_to_report_SFTD_r15_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cells_to_report_SFTD_r15_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cells_to_report_SFTD_r15_list->count < 1) || (p_cells_to_report_SFTD_r15_list->count > MAX_CELL_SFTD))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cells_to_report_SFTD_r15_list->count] should be in range "
            "1 to MAX_CELL_SFTD. Incorrect value %u received.", p_cells_to_report_SFTD_r15_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_cells_to_report_SFTD_r15_list->count * sizeof(p_cells_to_report_SFTD_r15_list->cells_to_report_SFTD_r15[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cells_to_report_SFTD_r15_list->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_cells_to_report_SFTD_r15_list->cells_to_report_SFTD_r15[loop], (void*)(p_src + *p_length_read), "cells_to_report_SFTD_r15[]");
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_nr
(
    meas_object_nr_t *p_meas_object_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_nr, 0, sizeof(meas_object_nr_t));

    /* This function parses meas_object_nr */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_nr->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_meas_object_nr->carrier_freq_r15, p_src + *p_length_read, "carrier_freq_r15");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_nr->carrier_freq_r15 > 3279165))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_nr->carrier_freq_r15] should be less than"
            " or equal to 3279165. Incorrect value %u received.", p_meas_object_nr->carrier_freq_r15);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rs_config_ssb_nr_r15(
        &p_meas_object_nr->rs_config_ssb_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_meas_object_nr->offset_freq_r15, p_src + *p_length_read, "offset_freq_r15");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_nr->offset_freq_r15 < -15) || (p_meas_object_nr->offset_freq_r15 > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_nr->offset_freq_r15] should be in range "
            "-15 to 15. Incorrect value %d received.", p_meas_object_nr->offset_freq_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_nr->quantity_config_set_r15, p_src + *p_length_read, "quantity_config_set_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_nr->quantity_config_set_r15 < 1) || (p_meas_object_nr->quantity_config_set_r15 > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_nr->quantity_config_set_r15] should be in range "
            "1 to 2. Incorrect value %u received.", p_meas_object_nr->quantity_config_set_r15);
        return RRC_FAILURE;
    }

    if (p_meas_object_nr->bitmask & MEAS_OBJECT_NR_THRESHHOLD_RS_INDEX_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_threshold_list_nr_r15(
        &p_meas_object_nr->thresh_rs_index_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_nr->bitmask & MEAS_OBJECT_NR_MAX_RS_IDX_CELL_QUAL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_nr->max_rs_index_cell_qual_r15, p_src + *p_length_read, "max_rs_index_cell_qual_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_nr->max_rs_index_cell_qual_r15 < 1) || (p_meas_object_nr->max_rs_index_cell_qual_r15 > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_nr->max_rs_index_cell_qual_r15] should be in range "
            "1 to 16. Incorrect value %u received.", p_meas_object_nr->max_rs_index_cell_qual_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_object_nr->bitmask & MEAS_OBJECT_NR_BLACK_CELLS_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_index_list(
        &p_meas_object_nr->black_cells_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_nr->bitmask & MEAS_OBJECT_NR_BLACK_CELLS_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_black_cells_to_add_mod_list_r15(
        &p_meas_object_nr->black_cells_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_nr->bitmask & MEAS_OBJECT_NR_CELLS_TO_REPORT_SFTD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cells_to_report_SFTD_r15_list(
        &p_meas_object_nr->cells_to_report_SFTD_r15_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod_meas_object
(
    meas_object_to_add_mod_meas_object_t *p_meas_object_to_add_mod_meas_object,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_to_add_mod_meas_object, 0, sizeof(meas_object_to_add_mod_meas_object_t));

    /* This function parses meas_object_to_add_mod_meas_object */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_object_to_add_mod_meas_object->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_eutra(
        &p_meas_object_to_add_mod_meas_object->meas_object_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_utra(
        &p_meas_object_to_add_mod_meas_object->meas_object_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_geran(
        &p_meas_object_to_add_mod_meas_object->meas_object_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_cdma2000(
        &p_meas_object_to_add_mod_meas_object->meas_object_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_WLAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_wlan(
        &p_meas_object_to_add_mod_meas_object->meas_object_wlan,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_object_to_add_mod_meas_object->bitmask & MEAS_OBJECT_TO_ADD_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_nr(
        &p_meas_object_to_add_mod_meas_object->meas_object_nr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod
(
    meas_object_to_add_mod_t *p_meas_object_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_to_add_mod, 0, sizeof(meas_object_to_add_mod_t));

    /* This function parses meas_object_to_add_mod */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_to_add_mod->meas_object_id, p_src + *p_length_read, "meas_object_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_object_to_add_mod->meas_object_id < 1) || (p_meas_object_to_add_mod->meas_object_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_to_add_mod->meas_object_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_meas_object_to_add_mod->meas_object_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_object_to_add_mod_meas_object(
        &p_meas_object_to_add_mod->meas_object,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_object_to_add_mod_list
(
    meas_object_to_add_mod_list_t *p_meas_object_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_object_to_add_mod_list, 0, sizeof(meas_object_to_add_mod_list_t));

    /* This function parses meas_object_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_object_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_object_to_add_mod_list->count > MAX_MEAS_OBJECT_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_object_to_add_mod_list->count] should be less than"
            " or equal to MAX_MEAS_OBJECT_ID. Incorrect value %u received.", p_meas_object_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_object_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_object_to_add_mod(
                &p_meas_object_to_add_mod_list->meas_object_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_to_remove_list
(
    report_config_to_remove_list_t *p_report_config_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_to_remove_list, 0, sizeof(report_config_to_remove_list_t));

    /* This function parses report_config_to_remove_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_to_remove_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_to_remove_list->count > MAX_REPORT_CONFIG_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_to_remove_list->count] should be less than"
            " or equal to MAX_REPORT_CONFIG_ID. Incorrect value %u received.", p_report_config_to_remove_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_report_config_to_remove_list->count * sizeof(p_report_config_to_remove_list->report_config_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_report_config_to_remove_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_report_config_to_remove_list->report_config_id[loop], (void*)(p_src + *p_length_read), "report_config_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_threshold_eutra
(
    threshold_eutra_t *p_threshold_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_threshold_eutra, 0, sizeof(threshold_eutra_t));

    /* This function parses threshold_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_threshold_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_threshold_eutra->bitmask & THRESHOLD_EUTRA_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_eutra->threshold_rsrp, p_src + *p_length_read, "threshold_rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_eutra->threshold_rsrp > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_eutra->threshold_rsrp] should be less than"
            " or equal to 97. Incorrect value %u received.", p_threshold_eutra->threshold_rsrp);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_eutra->bitmask & THRESHOLD_EUTRA_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_eutra->threshold_rsrq, p_src + *p_length_read, "threshold_rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_eutra->threshold_rsrq > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_eutra->threshold_rsrq] should be less than"
            " or equal to 34. Incorrect value %u received.", p_threshold_eutra->threshold_rsrq);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a1
(
    report_config_eutra_trigger_type_event_eventid_event_a1_t *p_report_config_eutra_trigger_type_event_eventid_event_a1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid_event_a1, 0, sizeof(report_config_eutra_trigger_type_event_eventid_event_a1_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid_event_a1 */

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_eutra_trigger_type_event_eventid_event_a1->a1_threshold,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a2
(
    report_config_eutra_trigger_type_event_eventid_event_a2_t *p_report_config_eutra_trigger_type_event_eventid_event_a2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid_event_a2, 0, sizeof(report_config_eutra_trigger_type_event_eventid_event_a2_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid_event_a2 */

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_eutra_trigger_type_event_eventid_event_a2->a2_threshold,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a3
(
    report_config_eutra_trigger_type_event_eventid_event_a3_t *p_report_config_eutra_trigger_type_event_eventid_event_a3,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid_event_a3, 0, sizeof(report_config_eutra_trigger_type_event_eventid_event_a3_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid_event_a3 */

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_report_config_eutra_trigger_type_event_eventid_event_a3->a3_offset, p_src + *p_length_read, "a3_offset");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_report_config_eutra_trigger_type_event_eventid_event_a3->a3_offset < -30) || (p_report_config_eutra_trigger_type_event_eventid_event_a3->a3_offset > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_trigger_type_event_eventid_event_a3->a3_offset] should be in range "
            "-30 to 30. Incorrect value %d received.", p_report_config_eutra_trigger_type_event_eventid_event_a3->a3_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_trigger_type_event_eventid_event_a3->report_on_leave, p_src + *p_length_read, "report_on_leave");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_trigger_type_event_eventid_event_a3->report_on_leave > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_trigger_type_event_eventid_event_a3->report_on_leave] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_eutra_trigger_type_event_eventid_event_a3->report_on_leave);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a4
(
    report_config_eutra_trigger_type_event_eventid_event_a4_t *p_report_config_eutra_trigger_type_event_eventid_event_a4,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid_event_a4, 0, sizeof(report_config_eutra_trigger_type_event_eventid_event_a4_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid_event_a4 */

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_eutra_trigger_type_event_eventid_event_a4->a4_threshold,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a5
(
    report_config_eutra_trigger_type_event_eventid_event_a5_t *p_report_config_eutra_trigger_type_event_eventid_event_a5,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid_event_a5, 0, sizeof(report_config_eutra_trigger_type_event_eventid_event_a5_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid_event_a5 */

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_eutra_trigger_type_event_eventid_event_a5->a5_threshold1,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_eutra_trigger_type_event_eventid_event_a5->a5_threshold2,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event_eventid
(
    report_config_eutra_trigger_type_event_eventid_t *p_report_config_eutra_trigger_type_event_eventid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event_eventid, 0, sizeof(report_config_eutra_trigger_type_event_eventid_t));

    /* This function parses report_config_eutra_trigger_type_event_eventid */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_eutra_trigger_type_event_eventid->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_eutra_trigger_type_event_eventid->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A1_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a1(
        &p_report_config_eutra_trigger_type_event_eventid->event_a1,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_eutra_trigger_type_event_eventid->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A2_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a2(
        &p_report_config_eutra_trigger_type_event_eventid->event_a2,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_eutra_trigger_type_event_eventid->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A3_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a3(
        &p_report_config_eutra_trigger_type_event_eventid->event_a3,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_eutra_trigger_type_event_eventid->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A4_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a4(
        &p_report_config_eutra_trigger_type_event_eventid->event_a4,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_eutra_trigger_type_event_eventid->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_EVENTID_A5_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid_event_a5(
        &p_report_config_eutra_trigger_type_event_eventid->event_a5,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_event
(
    report_config_eutra_trigger_type_event_t *p_report_config_eutra_trigger_type_event,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_event, 0, sizeof(report_config_eutra_trigger_type_event_t));

    /* This function parses report_config_eutra_trigger_type_event */

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event_eventid(
        &p_report_config_eutra_trigger_type_event->event_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_trigger_type_event->hysteresis, p_src + *p_length_read, "hysteresis");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_trigger_type_event->hysteresis > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_trigger_type_event->hysteresis] should be less than"
            " or equal to 30. Incorrect value %u received.", p_report_config_eutra_trigger_type_event->hysteresis);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_trigger_type_event->time_to_trigger, p_src + *p_length_read, "time_to_trigger");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_trigger_type_event->time_to_trigger > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_trigger_type_event->time_to_trigger] should be less than"
            " or equal to 15. Incorrect value %u received.", p_report_config_eutra_trigger_type_event->time_to_trigger);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type_periodical
(
    report_config_eutra_trigger_type_periodical_t *p_report_config_eutra_trigger_type_periodical,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type_periodical, 0, sizeof(report_config_eutra_trigger_type_periodical_t));

    /* This function parses report_config_eutra_trigger_type_periodical */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_trigger_type_periodical->purpose, p_src + *p_length_read, "purpose");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_trigger_type_periodical->purpose > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_trigger_type_periodical->purpose] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_eutra_trigger_type_periodical->purpose);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_trigger_type
(
    report_config_eutra_trigger_type_t *p_report_config_eutra_trigger_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_trigger_type, 0, sizeof(report_config_eutra_trigger_type_t));

    /* This function parses report_config_eutra_trigger_type */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_eutra_trigger_type->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_eutra_trigger_type->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_EVENT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_event(
        &p_report_config_eutra_trigger_type->event,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_eutra_trigger_type->bitmask & REPORT_CONFIG_EUTRA_TRIGGER_TYPE_PERIODICAL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type_periodical(
        &p_report_config_eutra_trigger_type->periodical,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra
(
    report_config_eutra_t *p_report_config_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra, 0, sizeof(report_config_eutra_t));

    /* This function parses report_config_eutra */

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_trigger_type(
        &p_report_config_eutra->trigger_type,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra->trigger_quantity, p_src + *p_length_read, "trigger_quantity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra->trigger_quantity > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra->trigger_quantity] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_eutra->trigger_quantity);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra->report_quantity, p_src + *p_length_read, "report_quantity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra->report_quantity > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra->report_quantity] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_eutra->report_quantity);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra->max_report_cells, p_src + *p_length_read, "max_report_cells");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_report_config_eutra->max_report_cells < 1) || (p_report_config_eutra->max_report_cells > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra->max_report_cells] should be in range "
            "1 to 8. Incorrect value %u received.", p_report_config_eutra->max_report_cells);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra->report_interval, p_src + *p_length_read, "report_interval");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra->report_interval > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra->report_interval] should be less than"
            " or equal to 15. Incorrect value %u received.", p_report_config_eutra->report_interval);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra->report_amount, p_src + *p_length_read, "report_amount");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra->report_amount > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra->report_amount] should be less than"
            " or equal to 7. Incorrect value %u received.", p_report_config_eutra->report_amount);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_threshold_utra
(
    threshold_utra_t *p_threshold_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_threshold_utra, 0, sizeof(threshold_utra_t));

    /* This function parses threshold_utra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_threshold_utra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_threshold_utra->bitmask & THRESHOLD_UTRA_RSCP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_threshold_utra->threshold_rscp, p_src + *p_length_read, "threshold_rscp");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_threshold_utra->threshold_rscp < -5) || (p_threshold_utra->threshold_rscp > 91))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_utra->threshold_rscp] should be in range "
            "-5 to 91. Incorrect value %d received.", p_threshold_utra->threshold_rscp);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_utra->bitmask & THRESHOLD_UTRA_ECN0_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_utra->threshold_ecn0, p_src + *p_length_read, "threshold_ecn0");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_utra->threshold_ecn0 > 49))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_utra->threshold_ecn0] should be less than"
            " or equal to 49. Incorrect value %u received.", p_threshold_utra->threshold_ecn0);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1
(
    report_config_interrat_trigger_type_event_eventid_event_b1_t *p_report_config_interrat_trigger_type_event_eventid_event_b1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_b1, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_b1_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_b1 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_interrat_trigger_type_event_eventid_event_b1->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_interrat_trigger_type_event_eventid_event_b1->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_threshold_utra(
        &p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid_event_b1->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_GERAN_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_geran, p_src + *p_length_read, "b1_threshold_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_geran > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_geran] should be less than"
            " or equal to 63. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_geran);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat_trigger_type_event_eventid_event_b1->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_THRESHOLD_CDMA2000_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_cdma2000, p_src + *p_length_read, "b1_threshold_cdma2000");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_cdma2000 > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_cdma2000] should be less than"
            " or equal to 63. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b1->b1_threshold_cdma2000);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2
(
    report_config_interrat_trigger_type_event_eventid_event_b2_t *p_report_config_interrat_trigger_type_event_eventid_event_b2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_b2, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_b2_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_b2 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_interrat_trigger_type_event_eventid_event_b2->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_report_config_interrat_trigger_type_event_eventid_event_b2->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_threshold_utra(
        &p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid_event_b2->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_GERAN_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_geran, p_src + *p_length_read, "b2_threshold_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_geran > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_geran] should be less than"
            " or equal to 63. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_geran);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat_trigger_type_event_eventid_event_b2->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_THRESHOLD_CDMA2000_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_cdma2000, p_src + *p_length_read, "b2_threshold_cdma2000");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_cdma2000 > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_cdma2000] should be less than"
            " or equal to 63. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b2->b2_threshold_cdma2000);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w1
(
    report_config_interrat_trigger_type_event_eventid_event_w1_t *p_report_config_interrat_trigger_type_event_eventid_event_w1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_w1, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_w1_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_w1 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_w1->w1_threshold_r13, p_src + *p_length_read, "w1_threshold_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_w1->w1_threshold_r13 > 141))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_w1->w1_threshold_r13] should be less than"
            " or equal to 141. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_w1->w1_threshold_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w2
(
    report_config_interrat_trigger_type_event_eventid_event_w2_t *p_report_config_interrat_trigger_type_event_eventid_event_w2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_w2, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_w2_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_w2 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold1_r13, p_src + *p_length_read, "w2_threshold1_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold1_r13 > 141))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold1_r13] should be less than"
            " or equal to 141. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold1_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold2_r13, p_src + *p_length_read, "w2_threshold2_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold2_r13 > 141))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold2_r13] should be less than"
            " or equal to 141. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_w2->w2_threshold2_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w3
(
    report_config_interrat_trigger_type_event_eventid_event_w3_t *p_report_config_interrat_trigger_type_event_eventid_event_w3,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_w3, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_w3_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_w3 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_w3->w3_threshold_r13, p_src + *p_length_read, "w3_threshold_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_w3->w3_threshold_r13 > 141))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_w3->w3_threshold_r13] should be less than"
            " or equal to 141. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_w3->w3_threshold_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_threshold_nr_r15
(
    threshold_nr_r15_t *p_threshold_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_threshold_nr_r15, 0, sizeof(threshold_nr_r15_t));

    /* This function parses threshold_nr_r15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_threshold_nr_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_threshold_nr_r15->bitmask & THRESHOLD_NR_R15_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_nr_r15->threshold_rsrp, p_src + *p_length_read, "threshold_rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_nr_r15->threshold_rsrp > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_nr_r15->threshold_rsrp] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_nr_r15->threshold_rsrp);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_nr_r15->bitmask & THRESHOLD_NR_R15_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_nr_r15->threshold_rsrq, p_src + *p_length_read, "threshold_rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_nr_r15->threshold_rsrq > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_nr_r15->threshold_rsrq] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_nr_r15->threshold_rsrq);
        return RRC_FAILURE;
    }
    }

    if (p_threshold_nr_r15->bitmask & THRESHOLD_NR_R15_SINR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_threshold_nr_r15->threshold_sinr, p_src + *p_length_read, "threshold_sinr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_threshold_nr_r15->threshold_sinr > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_threshold_nr_r15->threshold_sinr] should be less than"
            " or equal to 127. Incorrect value %u received.", p_threshold_nr_r15->threshold_sinr);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1_nr
(
    report_config_interrat_trigger_type_event_eventid_event_b1_nr_t *p_report_config_interrat_trigger_type_event_eventid_event_b1_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_b1_nr, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_b1_nr_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_b1_nr */

    if (RRC_FAILURE == rrc_il_parse_threshold_nr_r15(
        &p_report_config_interrat_trigger_type_event_eventid_event_b1_nr->b1_threshold_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b1_nr->report_on_leave_r15, p_src + *p_length_read, "report_on_leave_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b1_nr->report_on_leave_r15 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b1_nr->report_on_leave_r15] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b1_nr->report_on_leave_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2_nr
(
    report_config_interrat_trigger_type_event_eventid_event_b2_nr_t *p_report_config_interrat_trigger_type_event_eventid_event_b2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid_event_b2_nr, 0, sizeof(report_config_interrat_trigger_type_event_eventid_event_b2_nr_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid_event_b2_nr */

    if (RRC_FAILURE == rrc_il_parse_threshold_eutra(
        &p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->b2_threshold1_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_threshold_nr_r15(
        &p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->b2_threshold2_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->report_on_leave_r15, p_src + *p_length_read, "report_on_leave_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->report_on_leave_r15 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->report_on_leave_r15] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_interrat_trigger_type_event_eventid_event_b2_nr->report_on_leave_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event_eventid
(
    report_config_interrat_trigger_type_event_eventid_t *p_report_config_interrat_trigger_type_event_eventid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event_eventid, 0, sizeof(report_config_interrat_trigger_type_event_eventid_t));

    /* This function parses report_config_interrat_trigger_type_event_eventid */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_interrat_trigger_type_event_eventid->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1(
        &p_report_config_interrat_trigger_type_event_eventid->event_b1,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2(
        &p_report_config_interrat_trigger_type_event_eventid->event_b2,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_W1_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w1(
        &p_report_config_interrat_trigger_type_event_eventid->event_w1,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_W2_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w2(
        &p_report_config_interrat_trigger_type_event_eventid->event_w2,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_W3_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_w3(
        &p_report_config_interrat_trigger_type_event_eventid->event_w3,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B1_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b1_nr(
        &p_report_config_interrat_trigger_type_event_eventid->event_b1_nr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type_event_eventid->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_EVENTID_B2_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid_event_b2_nr(
        &p_report_config_interrat_trigger_type_event_eventid->event_b2_nr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_event
(
    report_config_interrat_trigger_type_event_t *p_report_config_interrat_trigger_type_event,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_event, 0, sizeof(report_config_interrat_trigger_type_event_t));

    /* This function parses report_config_interrat_trigger_type_event */

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event_eventid(
        &p_report_config_interrat_trigger_type_event->event_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event->hysteresis, p_src + *p_length_read, "hysteresis");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event->hysteresis > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event->hysteresis] should be less than"
            " or equal to 30. Incorrect value %u received.", p_report_config_interrat_trigger_type_event->hysteresis);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_event->time_to_trigger, p_src + *p_length_read, "time_to_trigger");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_event->time_to_trigger > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_event->time_to_trigger] should be less than"
            " or equal to 15. Incorrect value %u received.", p_report_config_interrat_trigger_type_event->time_to_trigger);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type_periodical
(
    report_config_interrat_trigger_type_periodical_t *p_report_config_interrat_trigger_type_periodical,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type_periodical, 0, sizeof(report_config_interrat_trigger_type_periodical_t));

    /* This function parses report_config_interrat_trigger_type_periodical */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat_trigger_type_periodical->purpose, p_src + *p_length_read, "purpose");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat_trigger_type_periodical->purpose > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat_trigger_type_periodical->purpose] should be less than"
            " or equal to 2. Incorrect value %u received.", p_report_config_interrat_trigger_type_periodical->purpose);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat_trigger_type
(
    report_config_interrat_trigger_type_t *p_report_config_interrat_trigger_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat_trigger_type, 0, sizeof(report_config_interrat_trigger_type_t));

    /* This function parses report_config_interrat_trigger_type */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_interrat_trigger_type->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_interrat_trigger_type->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_EVENT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_event(
        &p_report_config_interrat_trigger_type->event,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat_trigger_type->bitmask & REPORT_CONFIG_INTERRAT_TRIGGER_TYPE_PERIODICAL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type_periodical(
        &p_report_config_interrat_trigger_type->periodical,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_reportQuantityWLAN_r13
(
    reportQuantityWLAN_r13_t *p_reportQuantityWLAN_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_reportQuantityWLAN_r13, 0, sizeof(reportQuantityWLAN_r13_t));

    /* This function parses reportQuantityWLAN_r13 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_reportQuantityWLAN_r13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->band_request, p_src + *p_length_read, "band_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->band_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->band_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->band_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->carrier_info_request, p_src + *p_length_read, "carrier_info_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->carrier_info_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->carrier_info_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->carrier_info_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->available_admission_capacity_request, p_src + *p_length_read, "available_admission_capacity_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->available_admission_capacity_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->available_admission_capacity_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->available_admission_capacity_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->backhaul_dl_bandwidth_request, p_src + *p_length_read, "backhaul_dl_bandwidth_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->backhaul_dl_bandwidth_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->backhaul_dl_bandwidth_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->backhaul_dl_bandwidth_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->backhaul_ul_bandwidth_request, p_src + *p_length_read, "backhaul_ul_bandwidth_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->backhaul_ul_bandwidth_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->backhaul_ul_bandwidth_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->backhaul_ul_bandwidth_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->channel_utilization_request, p_src + *p_length_read, "channel_utilization_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->channel_utilization_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->channel_utilization_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->channel_utilization_request);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_reportQuantityWLAN_r13->station_count_request, p_src + *p_length_read, "station_count_request");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_reportQuantityWLAN_r13->station_count_request > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_reportQuantityWLAN_r13->station_count_request] should be less than"
            " or equal to 0. Incorrect value %u received.", p_reportQuantityWLAN_r13->station_count_request);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_quantity_cell_nr_r15
(
    report_quantity_cell_nr_r15_t *p_report_quantity_cell_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_quantity_cell_nr_r15, 0, sizeof(report_quantity_cell_nr_r15_t));

    /* This function parses report_quantity_cell_nr_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_quantity_cell_nr_r15->ss_rsrp, p_src + *p_length_read, "ss_rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_quantity_cell_nr_r15->ss_rsrp > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_quantity_cell_nr_r15->ss_rsrp] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_quantity_cell_nr_r15->ss_rsrp);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_quantity_cell_nr_r15->ss_rsrq, p_src + *p_length_read, "ss_rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_quantity_cell_nr_r15->ss_rsrq > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_quantity_cell_nr_r15->ss_rsrq] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_quantity_cell_nr_r15->ss_rsrq);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_quantity_cell_nr_r15->ss_sinr, p_src + *p_length_read, "ss_sinr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_quantity_cell_nr_r15->ss_sinr > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_quantity_cell_nr_r15->ss_sinr] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_quantity_cell_nr_r15->ss_sinr);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_interrat
(
    report_config_interrat_t *p_report_config_interrat,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_interrat, 0, sizeof(report_config_interrat_t));

    /* This function parses report_config_interrat */

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat_trigger_type(
        &p_report_config_interrat->trigger_type,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->max_report_cells, p_src + *p_length_read, "max_report_cells");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_report_config_interrat->max_report_cells < 1) || (p_report_config_interrat->max_report_cells > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->max_report_cells] should be in range "
            "1 to 8. Incorrect value %u received.", p_report_config_interrat->max_report_cells);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->report_interval, p_src + *p_length_read, "report_interval");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->report_interval > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->report_interval] should be less than"
            " or equal to 15. Incorrect value %u received.", p_report_config_interrat->report_interval);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->report_amount, p_src + *p_length_read, "report_amount");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->report_amount > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->report_amount] should be less than"
            " or equal to 7. Incorrect value %u received.", p_report_config_interrat->report_amount);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_interrat->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_interrat->bitmask & REPORT_QUANTITY_UTRA_FDD_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->report_quantity_UTRA_FDD_r10, p_src + *p_length_read, "report_quantity_UTRA_FDD_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->report_quantity_UTRA_FDD_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->report_quantity_UTRA_FDD_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_report_config_interrat->report_quantity_UTRA_FDD_r10);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat->bitmask & SI_REQUEST_FOR_HO_R9_INTERRAT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->si_request_for_ho_r9, p_src + *p_length_read, "si_request_for_ho_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->si_request_for_ho_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->si_request_for_ho_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_report_config_interrat->si_request_for_ho_r9);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat->bitmask & REPORT_QUANTITY_WLAN_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_reportQuantityWLAN_r13(
        &p_report_config_interrat->report_quantity_wlan_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat->bitmask & REPORT_QUANTITY_CELL_NR_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_quantity_cell_nr_r15(
        &p_report_config_interrat->report_quantity_cell_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat->bitmask & MAX_REPORT_RS_INDEX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->max_report_rs_index_r15, p_src + *p_length_read, "max_report_rs_index_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->max_report_rs_index_r15 > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->max_report_rs_index_r15] should be less than"
            " or equal to 32. Incorrect value %u received.", p_report_config_interrat->max_report_rs_index_r15);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat->bitmask & REPORT_QUANTITY_RS_INDEX_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_quantity_cell_nr_r15(
        &p_report_config_interrat->report_quantity_rs_index_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_interrat->bitmask & REPORT_RS_INDEX_RESULTS_NR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->report_rs_index_results_nr, p_src + *p_length_read, "report_rs_index_results_nr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->report_rs_index_results_nr > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->report_rs_index_results_nr] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_interrat->report_rs_index_results_nr);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_interrat->bitmask & REPORT_SFTD_MEAS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_interrat->report_sftd_meas_r15, p_src + *p_length_read, "report_sftd_meas_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_interrat->report_sftd_meas_r15 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_interrat->report_sftd_meas_r15] should be less than"
            " or equal to 1. Incorrect value %u received.", p_report_config_interrat->report_sftd_meas_r15);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_eutra_ext
(
    report_config_eutra_ext_t *p_report_config_eutra_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_report_config_eutra_ext, 0, sizeof(report_config_eutra_ext_t));

    /* This function parses report_config_eutra_ext */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_eutra_ext->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_eutra_ext->bitmask & REPORT_CFG_EUTRA_UE_RXTX_TIME_DIFF_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_ext->ue_rxtx_time_diff, p_src + *p_length_read, "ue_rxtx_time_diff");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_ext->ue_rxtx_time_diff > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_ext->ue_rxtx_time_diff] should be less than"
            " or equal to 0. Incorrect value %u received.", p_report_config_eutra_ext->ue_rxtx_time_diff);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_eutra_ext->bitmask & SI_REQUEST_FOR_HO_R9_EUTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_ext->si_request_for_ho_r9, p_src + *p_length_read, "si_request_for_ho_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_ext->si_request_for_ho_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_ext->si_request_for_ho_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_report_config_eutra_ext->si_request_for_ho_r9);
        return RRC_FAILURE;
    }
    }

    if (p_report_config_eutra_ext->bitmask & REPORT_CFG_EUTRA_REPORT_ADD_NEIGH_MEAS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_eutra_ext->report_add_neigh_meas_r10, p_src + *p_length_read, "report_add_neigh_meas_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_eutra_ext->report_add_neigh_meas_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_eutra_ext->report_add_neigh_meas_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_report_config_eutra_ext->report_add_neigh_meas_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod_report_config
(
    report_config_to_add_mod_report_config_t *p_report_config_to_add_mod_report_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_to_add_mod_report_config, 0, sizeof(report_config_to_add_mod_report_config_t));

    /* This function parses report_config_to_add_mod_report_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_report_config_to_add_mod_report_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_report_config_to_add_mod_report_config->bitmask & REPORT_CONFIG_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra(
        &p_report_config_to_add_mod_report_config->report_config_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_to_add_mod_report_config->bitmask & REPORT_CONFIG_INTERRAT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_interrat(
        &p_report_config_to_add_mod_report_config->report_config_interrat,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_report_config_to_add_mod_report_config->bitmask & REPORT_CONFIG_EUTRA_EXT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_eutra_ext(
        &p_report_config_to_add_mod_report_config->report_config_eutra_ext,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod
(
    report_config_to_add_mod_t *p_report_config_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_to_add_mod, 0, sizeof(report_config_to_add_mod_t));

    /* This function parses report_config_to_add_mod */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_to_add_mod->report_config_id, p_src + *p_length_read, "report_config_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_report_config_to_add_mod->report_config_id < 1) || (p_report_config_to_add_mod->report_config_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_to_add_mod->report_config_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_report_config_to_add_mod->report_config_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_report_config_to_add_mod_report_config(
        &p_report_config_to_add_mod->report_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_report_config_to_add_mod_list
(
    report_config_to_add_mod_list_t *p_report_config_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_report_config_to_add_mod_list, 0, sizeof(report_config_to_add_mod_list_t));

    /* This function parses report_config_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_report_config_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_report_config_to_add_mod_list->count > MAX_REPORT_CONFIG_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_report_config_to_add_mod_list->count] should be less than"
            " or equal to MAX_REPORT_CONFIG_ID. Incorrect value %u received.", p_report_config_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_report_config_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_report_config_to_add_mod(
                &p_report_config_to_add_mod_list->report_config_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_id_to_remove_list
(
    meas_id_to_remove_list_t *p_meas_id_to_remove_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_id_to_remove_list, 0, sizeof(meas_id_to_remove_list_t));

    /* This function parses meas_id_to_remove_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_id_to_remove_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_id_to_remove_list->count > MAX_MEAS_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_id_to_remove_list->count] should be less than"
            " or equal to MAX_MEAS_ID. Incorrect value %u received.", p_meas_id_to_remove_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_meas_id_to_remove_list->count * sizeof(p_meas_id_to_remove_list->meas_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_id_to_remove_list->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_meas_id_to_remove_list->meas_id[loop], (void*)(p_src + *p_length_read), "meas_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_id_to_add_mod
(
    meas_id_to_add_mod_t *p_meas_id_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_id_to_add_mod, 0, sizeof(meas_id_to_add_mod_t));

    /* This function parses meas_id_to_add_mod */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_id_to_add_mod->meas_id, p_src + *p_length_read, "meas_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_id_to_add_mod->meas_id < 1) || (p_meas_id_to_add_mod->meas_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_id_to_add_mod->meas_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_meas_id_to_add_mod->meas_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_id_to_add_mod->meas_object_id, p_src + *p_length_read, "meas_object_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_id_to_add_mod->meas_object_id < 1) || (p_meas_id_to_add_mod->meas_object_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_id_to_add_mod->meas_object_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_meas_id_to_add_mod->meas_object_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_id_to_add_mod->report_config_id, p_src + *p_length_read, "report_config_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_id_to_add_mod->report_config_id < 1) || (p_meas_id_to_add_mod->report_config_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_id_to_add_mod->report_config_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_meas_id_to_add_mod->report_config_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_id_to_add_mod_list
(
    meas_id_to_add_mod_list_t *p_meas_id_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_id_to_add_mod_list, 0, sizeof(meas_id_to_add_mod_list_t));

    /* This function parses meas_id_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_id_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_id_to_add_mod_list->count > MAX_MEAS_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_id_to_add_mod_list->count] should be less than"
            " or equal to MAX_MEAS_ID. Incorrect value %u received.", p_meas_id_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_id_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_id_to_add_mod(
                &p_meas_id_to_add_mod_list->meas_id_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_eutra
(
    quantity_config_eutra_t *p_quantity_config_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_eutra, 0, sizeof(quantity_config_eutra_t));

    /* This function parses quantity_config_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_eutra->filter_coefficient_rsrp, p_src + *p_length_read, "filter_coefficient_rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_eutra->filter_coefficient_rsrp > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_eutra->filter_coefficient_rsrp] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_eutra->filter_coefficient_rsrp);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_eutra->filter_coefficient_rsrq, p_src + *p_length_read, "filter_coefficient_rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_eutra->filter_coefficient_rsrq > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_eutra->filter_coefficient_rsrq] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_eutra->filter_coefficient_rsrq);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_utra
(
    quantity_config_utra_t *p_quantity_config_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_utra, 0, sizeof(quantity_config_utra_t));

    /* This function parses quantity_config_utra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_utra->meas_quantity_utra_fdd, p_src + *p_length_read, "meas_quantity_utra_fdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_utra->meas_quantity_utra_fdd > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_utra->meas_quantity_utra_fdd] should be less than"
            " or equal to 1. Incorrect value %u received.", p_quantity_config_utra->meas_quantity_utra_fdd);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_utra->meas_quantity_utra_tdd, p_src + *p_length_read, "meas_quantity_utra_tdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_utra->meas_quantity_utra_tdd > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_utra->meas_quantity_utra_tdd] should be less than"
            " or equal to 0. Incorrect value %u received.", p_quantity_config_utra->meas_quantity_utra_tdd);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_utra->filter_coefficient, p_src + *p_length_read, "filter_coefficient");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_utra->filter_coefficient > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_utra->filter_coefficient] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_utra->filter_coefficient);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_geran
(
    quantity_config_geran_t *p_quantity_config_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_geran, 0, sizeof(quantity_config_geran_t));

    /* This function parses quantity_config_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_geran->meas_quantity_geran, p_src + *p_length_read, "meas_quantity_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_geran->meas_quantity_geran > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_geran->meas_quantity_geran] should be less than"
            " or equal to 0. Incorrect value %u received.", p_quantity_config_geran->meas_quantity_geran);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_geran->filter_coefficient, p_src + *p_length_read, "filter_coefficient");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_geran->filter_coefficient > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_geran->filter_coefficient] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_geran->filter_coefficient);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_cdma2000
(
    quantity_config_cdma2000_t *p_quantity_config_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_cdma2000, 0, sizeof(quantity_config_cdma2000_t));

    /* This function parses quantity_config_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_cdma2000->meas_quantity_cdma2000, p_src + *p_length_read, "meas_quantity_cdma2000");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_cdma2000->meas_quantity_cdma2000 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_cdma2000->meas_quantity_cdma2000] should be less than"
            " or equal to 1. Incorrect value %u received.", p_quantity_config_cdma2000->meas_quantity_cdma2000);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_UTRA_v1020
(
    quantity_config_UTRA_v1020_t *p_quantity_config_UTRA_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_UTRA_v1020, 0, sizeof(quantity_config_UTRA_v1020_t));

    /* This function parses quantity_config_UTRA_v1020 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_UTRA_v1020->filterCoefficient2_FDD_r10, p_src + *p_length_read, "filterCoefficient2_FDD_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_UTRA_v1020->filterCoefficient2_FDD_r10 > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_UTRA_v1020->filterCoefficient2_FDD_r10] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_UTRA_v1020->filterCoefficient2_FDD_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantityConfigWLAN_r13
(
    quantityConfigWLAN_r13_t *p_quantityConfigWLAN_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantityConfigWLAN_r13, 0, sizeof(quantityConfigWLAN_r13_t));

    /* This function parses quantityConfigWLAN_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantityConfigWLAN_r13->meas_quantity_wlan_r13, p_src + *p_length_read, "meas_quantity_wlan_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantityConfigWLAN_r13->meas_quantity_wlan_r13 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantityConfigWLAN_r13->meas_quantity_wlan_r13] should be less than"
            " or equal to 0. Incorrect value %u received.", p_quantityConfigWLAN_r13->meas_quantity_wlan_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantityConfigWLAN_r13->filterCoefficient_r13, p_src + *p_length_read, "filterCoefficient_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantityConfigWLAN_r13->filterCoefficient_r13 > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantityConfigWLAN_r13->filterCoefficient_r13] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantityConfigWLAN_r13->filterCoefficient_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_rs_nr_r15
(
    quantity_config_rs_nr_r15_t *p_quantity_config_rs_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_quantity_config_rs_nr_r15, 0, sizeof(quantity_config_rs_nr_r15_t));

    /* This function parses quantity_config_rs_nr_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_rs_nr_r15->filter_coeff_rsrp_r15, p_src + *p_length_read, "filter_coeff_rsrp_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_rs_nr_r15->filter_coeff_rsrp_r15 > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_rs_nr_r15->filter_coeff_rsrp_r15] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_rs_nr_r15->filter_coeff_rsrp_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_rs_nr_r15->filter_coeff_rsrq_r15, p_src + *p_length_read, "filter_coeff_rsrq_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_rs_nr_r15->filter_coeff_rsrq_r15 > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_rs_nr_r15->filter_coeff_rsrq_r15] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_rs_nr_r15->filter_coeff_rsrq_r15);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_rs_nr_r15->filter_coefficient_sinr_r13, p_src + *p_length_read, "filter_coefficient_sinr_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_quantity_config_rs_nr_r15->filter_coefficient_sinr_r13 > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_rs_nr_r15->filter_coefficient_sinr_r13] should be less than"
            " or equal to 14. Incorrect value %u received.", p_quantity_config_rs_nr_r15->filter_coefficient_sinr_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_nr_r15
(
    quantity_config_nr_r15_t *p_quantity_config_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_quantity_config_nr_r15, 0, sizeof(quantity_config_nr_r15_t));

    /* This function parses quantity_config_nr_r15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_quantity_config_nr_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_quantity_config_rs_nr_r15(
        &p_quantity_config_nr_r15->meas_quantity_cell_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_quantity_config_nr_r15->bitmask & QUANTITY_CONFIG_RS_INDEX_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_rs_nr_r15(
        &p_quantity_config_nr_r15->meas_quantity_rs_index_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config_nr_list_r15
(
    quantity_config_nr_list_r15_t *p_quantity_config_nr_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_quantity_config_nr_list_r15, 0, sizeof(quantity_config_nr_list_r15_t));

    /* This function parses quantity_config_nr_list_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_quantity_config_nr_list_r15->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_quantity_config_nr_list_r15->count < 1) || (p_quantity_config_nr_list_r15->count > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_quantity_config_nr_list_r15->count] should be in range "
            "1 to 2. Incorrect value %u received.", p_quantity_config_nr_list_r15->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_quantity_config_nr_list_r15->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_quantity_config_nr_r15(
                &p_quantity_config_nr_list_r15->quantity_config_nr_r15[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_quantity_config
(
    quantity_config_t *p_quantity_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_quantity_config, 0, sizeof(quantity_config_t));

    /* This function parses quantity_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_quantity_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_eutra(
        &p_quantity_config->quantity_config_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_utra(
        &p_quantity_config->quantity_config_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_geran(
        &p_quantity_config->quantity_config_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_cdma2000(
        &p_quantity_config->quantity_config_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_UTRA_v1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_UTRA_v1020(
        &p_quantity_config->quantity_config_UTRA_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_WLAN_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantityConfigWLAN_r13(
        &p_quantity_config->quantity_config_wlan_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_quantity_config->bitmask & QUANTITY_CONFIG_NR_LIST_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config_nr_list_r15(
        &p_quantity_config->quantity_config_nr_list_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_gap_setup_config_info
(
    meas_gap_setup_config_info_t *p_meas_gap_setup_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_gap_setup_config_info, 0, sizeof(meas_gap_setup_config_info_t));

    /* This function parses meas_gap_setup_config_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_gap_setup_config_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP0_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp0, p_src + *p_length_read, "gp0");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp0 > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp0] should be less than"
            " or equal to 39. Incorrect value %u received.", p_meas_gap_setup_config_info->gp0);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP1_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp1, p_src + *p_length_read, "gp1");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp1 > 79))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp1] should be less than"
            " or equal to 79. Incorrect value %u received.", p_meas_gap_setup_config_info->gp1);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP4_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp4_r15, p_src + *p_length_read, "gp4_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp4_r15 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp4_r15] should be less than"
            " or equal to 19. Incorrect value %u received.", p_meas_gap_setup_config_info->gp4_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP5_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp5_r15, p_src + *p_length_read, "gp5_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp5_r15 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp5_r15] should be less than"
            " or equal to 159. Incorrect value %u received.", p_meas_gap_setup_config_info->gp5_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP6_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp6_r15, p_src + *p_length_read, "gp6_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp6_r15 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp6_r15] should be less than"
            " or equal to 19. Incorrect value %u received.", p_meas_gap_setup_config_info->gp6_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP7_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp7_r15, p_src + *p_length_read, "gp7_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp7_r15 > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp7_r15] should be less than"
            " or equal to 39. Incorrect value %u received.", p_meas_gap_setup_config_info->gp7_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP8_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp8_r15, p_src + *p_length_read, "gp8_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp8_r15 > 79))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp8_r15] should be less than"
            " or equal to 79. Incorrect value %u received.", p_meas_gap_setup_config_info->gp8_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp9_r15, p_src + *p_length_read, "gp9_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp9_r15 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp9_r15] should be less than"
            " or equal to 159. Incorrect value %u received.", p_meas_gap_setup_config_info->gp9_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp10_r15, p_src + *p_length_read, "gp10_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp10_r15 > 19))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp10_r15] should be less than"
            " or equal to 19. Incorrect value %u received.", p_meas_gap_setup_config_info->gp10_r15);
        return RRC_FAILURE;
    }
    }

    if (p_meas_gap_setup_config_info->bitmask & MEAS_GAP_CONFIG_GP11_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_setup_config_info->gp11_r15, p_src + *p_length_read, "gp11_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_setup_config_info->gp11_r15 > 159))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_setup_config_info->gp11_r15] should be less than"
            " or equal to 159. Incorrect value %u received.", p_meas_gap_setup_config_info->gp11_r15);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_gap_config
(
    meas_gap_config_t *p_meas_gap_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_gap_config, 0, sizeof(meas_gap_config_t));

    /* This function parses meas_gap_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_gap_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_gap_config->meas_gap_config_type, p_src + *p_length_read, "meas_gap_config_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_gap_config->meas_gap_config_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_gap_config->meas_gap_config_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_meas_gap_config->meas_gap_config_type);
        return RRC_FAILURE;
    }

    if (p_meas_gap_config->bitmask & MEAS_GAP_CONFIG_SETUP_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_gap_setup_config_info(
        &p_meas_gap_config->setup_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_secondary_pre_registration_zone_id_list_hrpd
(
    secondary_pre_registration_zone_id_list_hrpd_t *p_secondary_pre_registration_zone_id_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_secondary_pre_registration_zone_id_list_hrpd, 0, sizeof(secondary_pre_registration_zone_id_list_hrpd_t));

    /* This function parses secondary_pre_registration_zone_id_list_hrpd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_secondary_pre_registration_zone_id_list_hrpd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_secondary_pre_registration_zone_id_list_hrpd->count < 1) || (p_secondary_pre_registration_zone_id_list_hrpd->count > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_secondary_pre_registration_zone_id_list_hrpd->count] should be in range "
            "1 to 2. Incorrect value %u received.", p_secondary_pre_registration_zone_id_list_hrpd->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_secondary_pre_registration_zone_id_list_hrpd->count * sizeof(p_secondary_pre_registration_zone_id_list_hrpd->pre_registration_zone_id_hrpd[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_secondary_pre_registration_zone_id_list_hrpd->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_secondary_pre_registration_zone_id_list_hrpd->pre_registration_zone_id_hrpd[loop], (void*)(p_src + *p_length_read), "pre_registration_zone_id_hrpd[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pre_registration_info_hrpd
(
    pre_registration_info_hrpd_t *p_pre_registration_info_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pre_registration_info_hrpd, 0, sizeof(pre_registration_info_hrpd_t));

    /* This function parses pre_registration_info_hrpd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pre_registration_info_hrpd->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pre_registration_info_hrpd->pre_registration_allowed, p_src + *p_length_read, "pre_registration_allowed");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pre_registration_info_hrpd->pre_registration_allowed > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pre_registration_info_hrpd->pre_registration_allowed] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pre_registration_info_hrpd->pre_registration_allowed);
        return RRC_FAILURE;
    }

    if (p_pre_registration_info_hrpd->bitmask & PRE_REGISTRATION_ZONE_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pre_registration_info_hrpd->pre_registration_zone_id, p_src + *p_length_read, "pre_registration_zone_id");
    *p_length_read += sizeof(U8);
    }

    if (p_pre_registration_info_hrpd->bitmask & PRE_REGISTRATION_SECONDARY_ZONE_ID_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_secondary_pre_registration_zone_id_list_hrpd(
        &p_pre_registration_info_hrpd->secondary_pre_registration_zone_id_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mobility_state_parameters
(
    mobility_state_parameters_t *p_mobility_state_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_mobility_state_parameters, 0, sizeof(mobility_state_parameters_t));

    /* This function parses mobility_state_parameters */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_parameters->t_evaluation, p_src + *p_length_read, "t_evaluation");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_state_parameters->t_evaluation > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_parameters->t_evaluation] should be less than"
            " or equal to 7. Incorrect value %u received.", p_mobility_state_parameters->t_evaluation);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_parameters->t_hyst_normal, p_src + *p_length_read, "t_hyst_normal");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_state_parameters->t_hyst_normal > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_parameters->t_hyst_normal] should be less than"
            " or equal to 7. Incorrect value %u received.", p_mobility_state_parameters->t_hyst_normal);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_parameters->m_cell_charge_medium, p_src + *p_length_read, "m_cell_charge_medium");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_mobility_state_parameters->m_cell_charge_medium < 1) || (p_mobility_state_parameters->m_cell_charge_medium > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_parameters->m_cell_charge_medium] should be in range "
            "1 to 16. Incorrect value %u received.", p_mobility_state_parameters->m_cell_charge_medium);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_state_parameters->m_cell_charge_high, p_src + *p_length_read, "m_cell_charge_high");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_mobility_state_parameters->m_cell_charge_high < 1) || (p_mobility_state_parameters->m_cell_charge_high > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_state_parameters->m_cell_charge_high] should be in range "
            "1 to 16. Incorrect value %u received.", p_mobility_state_parameters->m_cell_charge_high);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_config_speed_state_pars_setup
(
    meas_config_speed_state_pars_setup_t *p_meas_config_speed_state_pars_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_config_speed_state_pars_setup, 0, sizeof(meas_config_speed_state_pars_setup_t));

    /* This function parses meas_config_speed_state_pars_setup */

    if (RRC_FAILURE == rrc_il_parse_mobility_state_parameters(
        &p_meas_config_speed_state_pars_setup->mobility_state_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_speed_state_scale_factors(
        &p_meas_config_speed_state_pars_setup->time_to_trigger_sf,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_config_speed_state_pars
(
    meas_config_speed_state_pars_t *p_meas_config_speed_state_pars,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_config_speed_state_pars, 0, sizeof(meas_config_speed_state_pars_t));

    /* This function parses meas_config_speed_state_pars */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_config_speed_state_pars->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_config_speed_state_pars->bitmask & MEAS_CONFIG_SPEED_STATE_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_config_speed_state_pars_setup(
        &p_meas_config_speed_state_pars->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_meas_config
(
    rrm_meas_config_t *p_rrm_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_meas_config, 0, sizeof(rrm_meas_config_t));

    /* This function parses rrm_meas_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_meas_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_OBJECT_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_to_remove_list(
        &p_rrm_meas_config->meas_object_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_OBJECT_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_object_to_add_mod_list(
        &p_rrm_meas_config->meas_object_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_REPORT_CONFIG_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_to_remove_list(
        &p_rrm_meas_config->report_config_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_REPORT_CONFIG_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_report_config_to_add_mod_list(
        &p_rrm_meas_config->report_config_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_ID_TO_REMOVE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_id_to_remove_list(
        &p_rrm_meas_config->meas_id_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_ID_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_id_to_add_mod_list(
        &p_rrm_meas_config->meas_id_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_QUANTITY_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_quantity_config(
        &p_rrm_meas_config->quantity_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_GAP_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_gap_config(
        &p_rrm_meas_config->meas_gap_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_S_MEASURE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_meas_config->s_measure, p_src + *p_length_read, "s_measure");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_meas_config->s_measure > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_meas_config->s_measure] should be less than"
            " or equal to 97. Incorrect value %u received.", p_rrm_meas_config->s_measure);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_PRE_REGISTRATION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_pre_registration_info_hrpd(
        &p_rrm_meas_config->pre_registration_info_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MEAS_SPEED_STATE_PARS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_config_speed_state_pars(
        &p_rrm_meas_config->meas_config_speed_state_pars,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_FR1_GAP_R15_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_meas_config->fr1_gap_r15, p_src + *p_length_read, "fr1_gap_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_meas_config->fr1_gap_r15 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_meas_config->fr1_gap_r15] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_meas_config->fr1_gap_r15);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_meas_config->bitmask & UE_ADM_MGTA_R15_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_meas_config->mgta_r15, p_src + *p_length_read, "mgta_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_meas_config->mgta_r15 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_meas_config->mgta_r15] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_meas_config->mgta_r15);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_setup
(
    setup_t *p_setup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_setup, 0, sizeof(setup_t));

    /* This function parses setup */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_setup->t301_r9, p_src + *p_length_read, "t301_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_setup->t301_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_setup->t301_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_setup->t301_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_setup->t310_r9, p_src + *p_length_read, "t310_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_setup->t310_r9 > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_setup->t310_r9] should be less than"
            " or equal to 6. Incorrect value %u received.", p_setup->t310_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_setup->n310_r9, p_src + *p_length_read, "n310_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_setup->n310_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_setup->n310_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_setup->n310_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_setup->t311_r9, p_src + *p_length_read, "t311_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_setup->t311_r9 > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_setup->t311_r9] should be less than"
            " or equal to 6. Incorrect value %u received.", p_setup->t311_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_setup->n311_r9, p_src + *p_length_read, "n311_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_setup->n311_r9 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_setup->n311_r9] should be less than"
            " or equal to 7. Incorrect value %u received.", p_setup->n311_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rlf_timers_and_constants_r9
(
    rlf_timers_and_constants_r9_t *p_rlf_timers_and_constants_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rlf_timers_and_constants_r9, 0, sizeof(rlf_timers_and_constants_r9_t));

    /* This function parses rlf_timers_and_constants_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rlf_timers_and_constants_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rlf_timers_and_constants_r9->bitmask & RLF_TIMERS_AND_CONSTANTS_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_setup(
        &p_rlf_timers_and_constants_r9->setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_ue_adm_radio_res_config
(
    rrm_ue_adm_radio_res_config_t *p_rrm_ue_adm_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_ue_adm_radio_res_config, 0, sizeof(rrm_ue_adm_radio_res_config_t));

    /* This function parses rrm_ue_adm_radio_res_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_ue_adm_radio_res_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_SRB_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_info(
        &p_rrm_ue_adm_radio_res_config->srb_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_MAC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_config(
        &p_rrm_ue_adm_radio_res_config->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_rrm_ue_adm_radio_res_config->sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_PHY_CONFIG_DED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated(
        &p_rrm_ue_adm_radio_res_config->physical_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_rrm_ue_adm_radio_res_config->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_ue_adm_radio_res_config->bitmask & RRM_UE_ADM_RADIO_RESP_RLF_TIMERS_AND_CONSTANTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rlf_timers_and_constants_r9(
        &p_rrm_ue_adm_radio_res_config->rlf_timers_and_constants_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcMpdcchConfigSetupR13
(
    RrcMpdcchConfigSetupR13_t *p_RrcMpdcchConfigSetupR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RrcMpdcchConfigSetupR13, 0, sizeof(RrcMpdcchConfigSetupR13_t));

    /* This function parses RrcMpdcchConfigSetupR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcMpdcchConfigSetupR13->mpdcchPdschHoppingConfigR13, p_src + *p_length_read, "mpdcchPdschHoppingConfigR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcMpdcchConfigSetupR13->mpdcchPdschHoppingConfigR13 > EMTC_MPDCCH_PDSCH_HOPPING_CONFIG_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcMpdcchConfigSetupR13->mpdcchPdschHoppingConfigR13] should be less than"
            " or equal to EMTC_MPDCCH_PDSCH_HOPPING_CONFIG_MAX. Incorrect value %u received.", p_RrcMpdcchConfigSetupR13->mpdcchPdschHoppingConfigR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcMpdcchConfigSetupR13->mpdcchStartSfUessFddR13, p_src + *p_length_read, "mpdcchStartSfUessFddR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcMpdcchConfigSetupR13->mpdcchStartSfUessFddR13 > EMTC_MPDCCH_START_SF_UESS_FDD_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcMpdcchConfigSetupR13->mpdcchStartSfUessFddR13] should be less than"
            " or equal to EMTC_MPDCCH_START_SF_UESS_FDD_MAX. Incorrect value %u received.", p_RrcMpdcchConfigSetupR13->mpdcchStartSfUessFddR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcMpdcchConfigSetupR13->mpdcchNumRepetitionR13, p_src + *p_length_read, "mpdcchNumRepetitionR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcMpdcchConfigSetupR13->mpdcchNumRepetitionR13 > EMTC_MPDCCH_NUM_REPETITION_UESS_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcMpdcchConfigSetupR13->mpdcchNumRepetitionR13] should be less than"
            " or equal to EMTC_MPDCCH_NUM_REPETITION_UESS_MAX. Incorrect value %u received.", p_RrcMpdcchConfigSetupR13->mpdcchNumRepetitionR13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcMpdcchConfigR13
(
    RrcMpdcchConfigR13_t *p_RrcMpdcchConfigR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RrcMpdcchConfigR13, 0, sizeof(RrcMpdcchConfigR13_t));

    /* This function parses RrcMpdcchConfigR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcMpdcchConfigR13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcMpdcchConfigR13->mpdcchConfigType, p_src + *p_length_read, "mpdcchConfigType");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcMpdcchConfigR13->mpdcchConfigType > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcMpdcchConfigR13->mpdcchConfigType] should be less than"
            " or equal to 1. Incorrect value %u received.", p_RrcMpdcchConfigR13->mpdcchConfigType);
        return RRC_FAILURE;
    }

    if (p_RrcMpdcchConfigR13->bitmask & RRC_MPDCCH_CONFIG_SETUP_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcMpdcchConfigSetupR13(
        &p_RrcMpdcchConfigR13->mpdcchConfigSetupR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcEpdcchSetConfigR11
(
    RrcEpdcchSetConfigR11_t *p_RrcEpdcchSetConfigR11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RrcEpdcchSetConfigR11, 0, sizeof(RrcEpdcchSetConfigR11_t));

    /* This function parses RrcEpdcchSetConfigR11 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcEpdcchSetConfigR11->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcEpdcchSetConfigR11->setConfigId, p_src + *p_length_read, "setConfigId");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcEpdcchSetConfigR11->setConfigId > EMTC_MAX_EPDCCH_CONFIG_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcEpdcchSetConfigR11->setConfigId] should be less than"
            " or equal to EMTC_MAX_EPDCCH_CONFIG_ID. Incorrect value %u received.", p_RrcEpdcchSetConfigR11->setConfigId);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcEpdcchSetConfigR11->transmissionType, p_src + *p_length_read, "transmissionType");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcEpdcchSetConfigR11->transmissionType > EMTC_TRANSMISSION_TYPE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcEpdcchSetConfigR11->transmissionType] should be less than"
            " or equal to EMTC_TRANSMISSION_TYPE_MAX. Incorrect value %u received.", p_RrcEpdcchSetConfigR11->transmissionType);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcEpdcchSetConfigR11->numPrbPairs, p_src + *p_length_read, "numPrbPairs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcEpdcchSetConfigR11->numPrbPairs > EMTC_NUM_PRB_PAIR_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcEpdcchSetConfigR11->numPrbPairs] should be less than"
            " or equal to EMTC_NUM_PRB_PAIR_MAX. Incorrect value %u received.", p_RrcEpdcchSetConfigR11->numPrbPairs);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcEpdcchSetConfigR11->prbBitmap, p_src + *p_length_read, "prbBitmap");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcEpdcchSetConfigR11->prbBitmap > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcEpdcchSetConfigR11->prbBitmap] should be less than"
            " or equal to 63. Incorrect value %u received.", p_RrcEpdcchSetConfigR11->prbBitmap);
        return RRC_FAILURE;
    }

    if (p_RrcEpdcchSetConfigR11->bitmask & RRC_MPDCCH_CONFIG_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcMpdcchConfigR13(
        &p_RrcEpdcchSetConfigR11->mpdcchConfigR13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_EpdcchConfigSetup
(
    EpdcchConfigSetup_t *p_EpdcchConfigSetup,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_EpdcchConfigSetup, 0, sizeof(EpdcchConfigSetup_t));

    /* This function parses EpdcchConfigSetup */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EpdcchConfigSetup->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (p_EpdcchConfigSetup->bitmask & RRC_EPDCCH_CONFIG_START_SYMBOL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EpdcchConfigSetup->startSymbolR11, p_src + *p_length_read, "startSymbolR11");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_EpdcchConfigSetup->startSymbolR11 < 1) || (p_EpdcchConfigSetup->startSymbolR11 > EMTC_MAX_START_SYMBOL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_EpdcchConfigSetup->startSymbolR11] should be in range "
            "1 to EMTC_MAX_START_SYMBOL. Incorrect value %u received.", p_EpdcchConfigSetup->startSymbolR11);
        return RRC_FAILURE;
    }
    }

    if (p_EpdcchConfigSetup->bitmask & RRC_EPDCCH_CONFIG_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcEpdcchSetConfigR11(
        &p_EpdcchConfigSetup->epdcchSetConfigR11,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_EpdcchConfig
(
    EpdcchConfig_t *p_EpdcchConfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_EpdcchConfig, 0, sizeof(EpdcchConfig_t));

    /* This function parses EpdcchConfig */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EpdcchConfig->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_EpdcchConfig->epdcchConfigType, p_src + *p_length_read, "epdcchConfigType");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_EpdcchConfig->epdcchConfigType > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_EpdcchConfig->epdcchConfigType] should be less than"
            " or equal to 1. Incorrect value %u received.", p_EpdcchConfig->epdcchConfigType);
        return RRC_FAILURE;
    }

    if (p_EpdcchConfig->bitmask & RRC_EPDCCH_CONFIG_SETUP_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_EpdcchConfigSetup(
        &p_EpdcchConfig->epdcchConfigSetup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcAckNackRepetitionSetupR13
(
    RrcAckNackRepetitionSetupR13_t *p_RrcAckNackRepetitionSetupR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RrcAckNackRepetitionSetupR13, 0, sizeof(RrcAckNackRepetitionSetupR13_t));

    /* This function parses RrcAckNackRepetitionSetupR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcAckNackRepetitionSetupR13->repetitionFactorR13, p_src + *p_length_read, "repetitionFactorR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcAckNackRepetitionSetupR13->repetitionFactorR13 > EMTC_REPETITION_FACTOR_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcAckNackRepetitionSetupR13->repetitionFactorR13] should be less than"
            " or equal to EMTC_REPETITION_FACTOR_MAX. Incorrect value %u received.", p_RrcAckNackRepetitionSetupR13->repetitionFactorR13);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_RrcAckNackRepetitionSetupR13->n1PucchAnRepR13, p_src + *p_length_read, "n1PucchAnRepR13");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcAckNackRepetitionSetupR13->n1PucchAnRepR13 > EMTC_MAX_N1_PUCCH_AN))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcAckNackRepetitionSetupR13->n1PucchAnRepR13] should be less than"
            " or equal to EMTC_MAX_N1_PUCCH_AN. Incorrect value %u received.", p_RrcAckNackRepetitionSetupR13->n1PucchAnRepR13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcPucchConfigDedicatedR13
(
    RrcPucchConfigDedicatedR13_t *p_RrcPucchConfigDedicatedR13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RrcPucchConfigDedicatedR13, 0, sizeof(RrcPucchConfigDedicatedR13_t));

    /* This function parses RrcPucchConfigDedicatedR13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcPucchConfigDedicatedR13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcPucchConfigDedicatedR13->type, p_src + *p_length_read, "type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcPucchConfigDedicatedR13->type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcPucchConfigDedicatedR13->type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_RrcPucchConfigDedicatedR13->type);
        return RRC_FAILURE;
    }

    if (p_RrcPucchConfigDedicatedR13->bitmask & RRC_PUCCH_ACK_NACK_REPETITION_SETUP_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcAckNackRepetitionSetupR13(
        &p_RrcPucchConfigDedicatedR13->ackNackRepetitionSetup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_RrcPucchConfigDedicatedR13->bitmask & RRC_PUCCH_NUM_REPETITION_CE_FORMAT1_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcPucchConfigDedicatedR13->pucchNumRepetitionCeFormat1r13, p_src + *p_length_read, "pucchNumRepetitionCeFormat1r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcPucchConfigDedicatedR13->pucchNumRepetitionCeFormat1r13 > EMTC_PUCCH_NUM_REPETITION_CE_MODE_A_FORMAT1_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcPucchConfigDedicatedR13->pucchNumRepetitionCeFormat1r13] should be less than"
            " or equal to EMTC_PUCCH_NUM_REPETITION_CE_MODE_A_FORMAT1_MAX. Incorrect value %u received.", p_RrcPucchConfigDedicatedR13->pucchNumRepetitionCeFormat1r13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcRrmAdmissionEmtcConfigInfo
(
    RrcRrmAdmissionEmtcConfigInfo_t *p_RrcRrmAdmissionEmtcConfigInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RrcRrmAdmissionEmtcConfigInfo, 0, sizeof(RrcRrmAdmissionEmtcConfigInfo_t));

    /* This function parses RrcRrmAdmissionEmtcConfigInfo */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmAdmissionEmtcConfigInfo->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_EpdcchConfig(
        &p_RrcRrmAdmissionEmtcConfigInfo->epdcchConfig,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmAdmissionEmtcConfigInfo->ceMode, p_src + *p_length_read, "ceMode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcRrmAdmissionEmtcConfigInfo->ceMode > EMTC_CE_MODE_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcRrmAdmissionEmtcConfigInfo->ceMode] should be less than"
            " or equal to EMTC_CE_MODE_MAX. Incorrect value %u received.", p_RrcRrmAdmissionEmtcConfigInfo->ceMode);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmAdmissionEmtcConfigInfo->dlMcs, p_src + *p_length_read, "dlMcs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcRrmAdmissionEmtcConfigInfo->dlMcs > EMTC_MAX_MCS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcRrmAdmissionEmtcConfigInfo->dlMcs] should be less than"
            " or equal to EMTC_MAX_MCS. Incorrect value %u received.", p_RrcRrmAdmissionEmtcConfigInfo->dlMcs);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmAdmissionEmtcConfigInfo->ulMcs, p_src + *p_length_read, "ulMcs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RrcRrmAdmissionEmtcConfigInfo->ulMcs > EMTC_MAX_MCS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcRrmAdmissionEmtcConfigInfo->ulMcs] should be less than"
            " or equal to EMTC_MAX_MCS. Incorrect value %u received.", p_RrcRrmAdmissionEmtcConfigInfo->ulMcs);
        return RRC_FAILURE;
    }

    if (p_RrcRrmAdmissionEmtcConfigInfo->bitmask & RRC_RRM_ADMISSION_EMTC_PUCCH_CONFIG_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcPucchConfigDedicatedR13(
        &p_RrcRrmAdmissionEmtcConfigInfo->pucchConfigDedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_admission_cnf
(
    rrc_rrm_ue_admission_cnf_t *p_rrc_rrm_ue_admission_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_admission_cnf, 0, sizeof(rrc_rrm_ue_admission_cnf_t));

    /* This function parses rrc_rrm_ue_admission_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_cnf->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_cnf->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_admission_cnf->response);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_admission_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_admission_cnf->bitmask & RRC_RRM_UE_ADM_CNF_SPS_ERROR_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_admission_cnf->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_admission_cnf->error_code > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_admission_cnf->error_code] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_ue_admission_cnf->error_code);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_reconfig_req
(
    rrc_rrm_ue_reconfig_req_t *p_rrc_rrm_ue_reconfig_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_reconfig_req, 0, sizeof(rrc_rrm_ue_reconfig_req_t));

    /* This function parses rrc_rrm_ue_reconfig_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reconfig_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reconfig_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_reconfig_req->bitmask & RRM_UE_RECONFIG_REQ_API_UE_RECONFIG_REQ_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_radio_resource_reconfig(
        &p_rrc_rrm_ue_reconfig_req->radio_resource_reconfig,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_reconfig_req->bitmask & RRM_UE_RECONFIG_SCELL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_scell_config(
        &p_rrc_rrm_ue_reconfig_req->scell_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_subframe_pattern_pcell_r10
(
    rrc_meas_subframe_pattern_pcell_r10_t *p_rrc_meas_subframe_pattern_pcell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_subframe_pattern_pcell_r10, 0, sizeof(rrc_meas_subframe_pattern_pcell_r10_t));

    /* This function parses rrc_meas_subframe_pattern_pcell_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_subframe_pattern_pcell_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_meas_subframe_pattern_pcell_r10->bitmask & MEAS_SUBFRAME_PATTERN_PCELL_R10_SETUP_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_meas_subframe_pattern_r10(
        &p_rrc_meas_subframe_pattern_pcell_r10->meas_subframe_pattern_r10_setup,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_radio_resource_reconfig
(
    radio_resource_reconfig_t *p_radio_resource_reconfig,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_radio_resource_reconfig, 0, sizeof(radio_resource_reconfig_t));

    /* This function parses radio_resource_reconfig */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_radio_resource_reconfig->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_radio_resource_reconfig->presence_bitmask & RRM_UE_RECONFIG_PHY_CONFIG_DED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated(
        &p_radio_resource_reconfig->rrc_rrm_ue_reconfig_physical_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_reconfig->presence_bitmask & RRM_UE_RECONFIG_MAC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_config(
        &p_radio_resource_reconfig->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_reconfig->presence_bitmask & RRM_UE_RECONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_subframe_pattern_pcell_r10(
        &p_radio_resource_reconfig->rrc_meas_subframe_pattern_pcell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_to_release
(
    rrc_scell_to_release_t *p_rrc_scell_to_release,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_to_release, 0, sizeof(rrc_scell_to_release_t));

    /* This function parses rrc_scell_to_release */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_scell_to_release->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_scell_to_release->bitmask & RRM_SCELL_TO_RELEASE_CELL_INDEX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_release->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_to_release->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_release->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_scell_to_release->cell_index);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_release->scellIndex, p_src + *p_length_read, "scellIndex");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_to_release->scellIndex < 1) || (p_rrc_scell_to_release->scellIndex > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_release->scellIndex] should be in range "
            "1 to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_scell_to_release->scellIndex);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_to_release_list
(
    rrc_scell_to_release_list_t *p_rrc_scell_to_release_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_to_release_list, 0, sizeof(rrc_scell_to_release_list_t));

    /* This function parses rrc_scell_to_release_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_release_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_to_release_list->count < 1) || (p_rrc_scell_to_release_list->count > MAX_SCELL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_release_list->count] should be in range "
            "1 to MAX_SCELL. Incorrect value %u received.", p_rrc_scell_to_release_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_scell_to_release_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_scell_to_release(
                &p_rrc_scell_to_release_list->rrc_scell_to_release[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_Identification
(
    rrc_scell_Identification_t *p_rrc_scell_Identification,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_Identification, 0, sizeof(rrc_scell_Identification_t));

    /* This function parses rrc_scell_Identification */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_scell_Identification->phy_cell_id, p_src + *p_length_read, "phy_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_Identification->phy_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_Identification->phy_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_rrc_scell_Identification->phy_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_scell_Identification->dl_carrier_freq, p_src + *p_length_read, "dl_carrier_freq");
    *p_length_read += sizeof(U32);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_common_scell_non_ul_config
(
    rrc_radio_res_common_scell_non_ul_config_t *p_rrc_radio_res_common_scell_non_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_common_scell_non_ul_config, 0, sizeof(rrc_radio_res_common_scell_non_ul_config_t));

    /* This function parses rrc_radio_res_common_scell_non_ul_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_res_common_scell_non_ul_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_radio_res_common_scell_non_ul_config->dl_bandwidth, p_src + *p_length_read, "dl_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_radio_res_common_scell_non_ul_config->dl_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_radio_res_common_scell_non_ul_config->dl_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_rrc_radio_res_common_scell_non_ul_config->dl_bandwidth);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_radio_res_common_scell_non_ul_config->antenna_port_count, p_src + *p_length_read, "antenna_port_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_radio_res_common_scell_non_ul_config->antenna_port_count > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_radio_res_common_scell_non_ul_config->antenna_port_count] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_radio_res_common_scell_non_ul_config->antenna_port_count);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_phich_config(
        &p_rrc_radio_res_common_scell_non_ul_config->phich_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_pdsch_config_common(
        &p_rrc_radio_res_common_scell_non_ul_config->pdsch_config_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_radio_res_common_scell_non_ul_config->bitmask & RRM_SCELL_COMMOM_NON_UL_TDD_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_tdd_config(
        &p_rrc_radio_res_common_scell_non_ul_config->tdd_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_config_common_scell
(
    rrc_radio_res_config_common_scell_t *p_rrc_radio_res_config_common_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_config_common_scell, 0, sizeof(rrc_radio_res_config_common_scell_t));

    /* This function parses rrc_radio_res_config_common_scell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_res_config_common_scell->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_common_scell_non_ul_config(
        &p_rrc_radio_res_config_common_scell->radio_res_common_scell_non_ul_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_scell_non_ul_config
(
    rrc_radio_res_dedicated_scell_non_ul_config_t *p_rrc_radio_res_dedicated_scell_non_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_dedicated_scell_non_ul_config, 0, sizeof(rrc_radio_res_dedicated_scell_non_ul_config_t));

    /* This function parses rrc_radio_res_dedicated_scell_non_ul_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_res_dedicated_scell_non_ul_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_radio_res_dedicated_scell_non_ul_config->bitmask & RRM_SCELL_DEDICATED_NON_UL_ANTENNA_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_antenna_info_dedicated_r10(
        &p_rrc_radio_res_dedicated_scell_non_ul_config->antenna_info_dedicated_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_res_dedicated_scell_non_ul_config->bitmask & RRM_SCELL_DEDICATED_NON_UL_PDSCH_CONFIG_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_pdsch_configuration_dedicated(
        &p_rrc_radio_res_dedicated_scell_non_ul_config->pdsch_configuration_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_cqi_report_config_scell_r10
(
    rrc_cqi_report_config_scell_r10_t *p_rrc_cqi_report_config_scell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_cqi_report_config_scell_r10, 0, sizeof(rrc_cqi_report_config_scell_r10_t));

    /* This function parses rrc_cqi_report_config_scell_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_cqi_report_config_scell_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_cqi_report_config_scell_r10->bitmask & RRM_SCELL_CQI_REPORT_CONFIG_APERIODIC_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_cqi_report_config_scell_r10->cqi_reporting_mode_aperiodic, p_src + *p_length_read, "cqi_reporting_mode_aperiodic");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_cqi_report_config_scell_r10->cqi_reporting_mode_aperiodic > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_cqi_report_config_scell_r10->cqi_reporting_mode_aperiodic] should be less than"
            " or equal to 4. Incorrect value %u received.", p_rrc_cqi_report_config_scell_r10->cqi_reporting_mode_aperiodic);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_rrc_cqi_report_config_scell_r10->nomPDSCH_RS_EPRE_Offset, p_src + *p_length_read, "nomPDSCH_RS_EPRE_Offset");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_cqi_report_config_scell_r10->nomPDSCH_RS_EPRE_Offset < -1) || (p_rrc_cqi_report_config_scell_r10->nomPDSCH_RS_EPRE_Offset > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_cqi_report_config_scell_r10->nomPDSCH_RS_EPRE_Offset] should be in range "
            "-1 to 6. Incorrect value %d received.", p_rrc_cqi_report_config_scell_r10->nomPDSCH_RS_EPRE_Offset);
        return RRC_FAILURE;
    }

    if (p_rrc_cqi_report_config_scell_r10->bitmask & RRM_SCELL_CQI_REPORT_CONFIG_PERIODIC_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_cqi_report_periodic_r10(
        &p_rrc_cqi_report_config_scell_r10->cqi_report_periodic_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_cqi_report_config_scell_r10->bitmask & RRM_SCELL_CQI_REPORT_CONFIG_PMI_RI_REPORT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_cqi_report_config_scell_r10->cqi_report_pmi_ri_report_r10, p_src + *p_length_read, "cqi_report_pmi_ri_report_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_cqi_report_config_scell_r10->cqi_report_pmi_ri_report_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_cqi_report_config_scell_r10->cqi_report_pmi_ri_report_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_cqi_report_config_scell_r10->cqi_report_pmi_ri_report_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_dedicated_scell_ul_config
(
    rrc_radio_res_dedicated_scell_ul_config_t *p_rrc_radio_res_dedicated_scell_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_dedicated_scell_ul_config, 0, sizeof(rrc_radio_res_dedicated_scell_ul_config_t));

    /* This function parses rrc_radio_res_dedicated_scell_ul_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_res_dedicated_scell_ul_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_radio_res_dedicated_scell_ul_config->bitmask & RRM_SCELL_DEDICATED_UL_CQI_CONFIG_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_cqi_report_config_scell_r10(
        &p_rrc_radio_res_dedicated_scell_ul_config->cqi_report_config_scell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_physical_config_dedicated_scell
(
    rrc_physical_config_dedicated_scell_t *p_rrc_physical_config_dedicated_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_physical_config_dedicated_scell, 0, sizeof(rrc_physical_config_dedicated_scell_t));

    /* This function parses rrc_physical_config_dedicated_scell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_physical_config_dedicated_scell->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_physical_config_dedicated_scell->bitmask & RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_NON_UL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_dedicated_scell_non_ul_config(
        &p_rrc_physical_config_dedicated_scell->radio_res_dedicated_scell_non_ul_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_physical_config_dedicated_scell->bitmask & RRM_RADIO_RES_CONFIG_DEDICATED_SCELL_UL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_dedicated_scell_ul_config(
        &p_rrc_physical_config_dedicated_scell->radio_res_dedicated_scell_ul_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_physical_config_dedicated_scell->bitmask & RRM_LAA_SCELL_CONFIGURATION_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_dedicated_laa_scell_config(
        &p_rrc_physical_config_dedicated_scell->laa_scell_configuration_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_res_config_dedicated_scell
(
    rrc_radio_res_config_dedicated_scell_t *p_rrc_radio_res_config_dedicated_scell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_res_config_dedicated_scell, 0, sizeof(rrc_radio_res_config_dedicated_scell_t));

    /* This function parses rrc_radio_res_config_dedicated_scell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_res_config_dedicated_scell->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_radio_res_config_dedicated_scell->bitmask & RRM_PHYSICAL_CONFIG_DEDICATED_SCELL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_physical_config_dedicated_scell(
        &p_rrc_radio_res_config_dedicated_scell->physical_config_dedicated_scell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_mac_main_config_extensions
(
    rrc_scell_mac_main_config_extensions_t *p_rrc_scell_mac_main_config_extensions,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_mac_main_config_extensions, 0, sizeof(rrc_scell_mac_main_config_extensions_t));

    /* This function parses rrc_scell_mac_main_config_extensions */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_scell_mac_main_config_extensions->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_NUM_HARQ_PROC_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->dl_num_harq_process, p_src + *p_length_read, "dl_num_harq_process");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_mac_main_config_extensions->dl_num_harq_process < 1) || (p_rrc_scell_mac_main_config_extensions->dl_num_harq_process > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->dl_num_harq_process] should be in range "
            "1 to 15. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->dl_num_harq_process);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_DL_INIT_MCS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->dl_i_mcs, p_src + *p_length_read, "dl_i_mcs");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_mac_main_config_extensions->dl_i_mcs > 28))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->dl_i_mcs] should be less than"
            " or equal to 28. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->dl_i_mcs);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_NUM_OF_LAYER_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->num_of_layer, p_src + *p_length_read, "num_of_layer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_mac_main_config_extensions->num_of_layer < 1) || (p_rrc_scell_mac_main_config_extensions->num_of_layer > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->num_of_layer] should be in range "
            "1 to 4. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->num_of_layer);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_CODE_BOOK_INDEX_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->code_book_index, p_src + *p_length_read, "code_book_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_mac_main_config_extensions->code_book_index > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->code_book_index] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->code_book_index);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRC_RRM_SCELL_MAC_MAIN_CONFIG_EXTN_USER_LOCATION_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->user_location_type, p_src + *p_length_read, "user_location_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_mac_main_config_extensions->user_location_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->user_location_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->user_location_type);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRM_MAC_MAIN_CONFIG_EXT_RF_PARAMS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->rf_params_half_duplex_fdd, p_src + *p_length_read, "rf_params_half_duplex_fdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_mac_main_config_extensions->rf_params_half_duplex_fdd > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->rf_params_half_duplex_fdd] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->rf_params_half_duplex_fdd);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_scell_mac_main_config_extensions->bitmask & RRM_MAC_SCELL_ACTIVATE_STATUS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_mac_main_config_extensions->scell_activate_status, p_src + *p_length_read, "scell_activate_status");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_mac_main_config_extensions->scell_activate_status > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_mac_main_config_extensions->scell_activate_status] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_scell_mac_main_config_extensions->scell_activate_status);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_to_add_mod
(
    rrc_scell_to_add_mod_t *p_rrc_scell_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_to_add_mod, 0, sizeof(rrc_scell_to_add_mod_t));

    /* This function parses rrc_scell_to_add_mod */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_scell_to_add_mod->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_CELL_INDEX_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_add_mod->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_scell_to_add_mod->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_add_mod->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_scell_to_add_mod->cell_index);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_add_mod->scellIndex, p_src + *p_length_read, "scellIndex");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_to_add_mod->scellIndex < 1) || (p_rrc_scell_to_add_mod->scellIndex > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_add_mod->scellIndex] should be in range "
            "1 to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_scell_to_add_mod->scellIndex);
        return RRC_FAILURE;
    }

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_CELL_IDENTIFICATION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_scell_Identification(
        &p_rrc_scell_to_add_mod->scell_Id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_COMMON_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_config_common_scell(
        &p_rrc_scell_to_add_mod->radio_res_config_common_scell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_RADIO_RES_CONFIG_DEDICATED_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_res_config_dedicated_scell(
        &p_rrc_scell_to_add_mod->radio_res_config_dedicated_scell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_MAC_SCELL_CONFIG_EXTENSION_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_scell_mac_main_config_extensions(
        &p_rrc_scell_to_add_mod->mac_main_config_extensions,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_scell_to_add_mod->bitmask & RRM_SCELL_ADD_MOD_MIMO_CAPABILITY_DL_R10_SCELL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_add_mod->supported_mimo_capability_dl_r10, p_src + *p_length_read, "supported_mimo_capability_dl_r10");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_scell_to_add_mod_list
(
    rrc_scell_to_add_mod_list_t *p_rrc_scell_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_scell_to_add_mod_list, 0, sizeof(rrc_scell_to_add_mod_list_t));

    /* This function parses rrc_scell_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_scell_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_scell_to_add_mod_list->count < 1) || (p_rrc_scell_to_add_mod_list->count > MAX_SCELL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_scell_to_add_mod_list->count] should be in range "
            "1 to MAX_SCELL. Incorrect value %u received.", p_rrc_scell_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_scell_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_scell_to_add_mod(
                &p_rrc_scell_to_add_mod_list->rrc_scell_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_scell_config
(
    rrm_scell_config_t *p_rrm_scell_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_scell_config, 0, sizeof(rrm_scell_config_t));

    /* This function parses rrm_scell_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_scell_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_scell_config->bitmask & RRM_SCELL_RELEASE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_scell_to_release_list(
        &p_rrm_scell_config->scell_release_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_scell_config->bitmask & RRM_SCELL_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_scell_to_add_mod_list(
        &p_rrm_scell_config->scell_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_scell_config->bitmask & RRM_SCELL_CONFIG_CA_LC_BANDWIDTH_DIST_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_ca_lc_bandwidth_dist_info(
        &p_rrm_scell_config->ca_lc_bandwidth_dist_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_reconfig_resp
(
    rrc_rrm_ue_reconfig_resp_t *p_rrc_rrm_ue_reconfig_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_reconfig_resp, 0, sizeof(rrc_rrm_ue_reconfig_resp_t));

    /* This function parses rrc_rrm_ue_reconfig_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reconfig_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reconfig_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_reconfig_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_reconfig_resp->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_reconfig_resp->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_reconfig_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_reconfig_resp->bitmask & RRM_UE_RECONFIG_RESP_API_FAIL_CAUSE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_reconfig_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_setup_req
(
    rrc_rrm_erb_setup_req_t *p_rrc_rrm_erb_setup_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_setup_req, 0, sizeof(rrc_rrm_erb_setup_req_t));

    /* This function parses rrc_rrm_erb_setup_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_UE_AGG_MAX_BIT_RATE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_erb_setup_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_setup_item_list(
        &p_rrc_rrm_erb_setup_req->erab_to_be_setup_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_SRVCC_HO_OP_POSSIBLE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_req->srvcc_ho_op_possible, p_src + *p_length_read, "srvcc_ho_op_possible");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_setup_req->srvcc_ho_op_possible > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_req->srvcc_ho_op_possible] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_erb_setup_req->srvcc_ho_op_possible);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_CSF_INDICATOR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_req->csf_indicator, p_src + *p_length_read, "csf_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_setup_req->csf_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_req->csf_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_erb_setup_req->csf_indicator);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_HO_RESTRICTION_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ho_restriction_list(
        &p_rrc_rrm_erb_setup_req->ho_restriction_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_SUB_PROFILE_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_req->sub_profile_id, p_src + *p_length_read, "sub_profile_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_erb_setup_req->sub_profile_id < 1) || (p_rrc_rrm_erb_setup_req->sub_profile_id > 256))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_req->sub_profile_id] should be in range "
            "1 to 256. Incorrect value %u received.", p_rrc_rrm_erb_setup_req->sub_profile_id);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_REGISTERED_LAI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_registered_lai(
        &p_rrc_rrm_erb_setup_req->registered_lai,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_req->bitmask & RRC_RRM_ERB_SETUP_REQ_CSG_MEM_STATUS)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_req->csg_mem_status, p_src + *p_length_read, "csg_mem_status");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_ue_agg_max_bit_rate_ext
(
    rrm_ue_agg_max_bit_rate_ext_t *p_rrm_ue_agg_max_bit_rate_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_ue_agg_max_bit_rate_ext, 0, sizeof(rrm_ue_agg_max_bit_rate_ext_t));

    /* This function parses rrm_ue_agg_max_bit_rate_ext */

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_ue_agg_max_bit_rate_ext->ext_ue_agg_max_bit_rate_ul, p_src + *p_length_read, "ext_ue_agg_max_bit_rate_ul");
    *p_length_read += sizeof(U64);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_ue_agg_max_bit_rate_ext->ext_ue_agg_max_bit_rate_dl, p_src + *p_length_read, "ext_ue_agg_max_bit_rate_dl");
    *p_length_read += sizeof(U64);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_ue_agg_max_bit_rate
(
    rrm_ue_agg_max_bit_rate_t *p_rrm_ue_agg_max_bit_rate,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_ue_agg_max_bit_rate, 0, sizeof(rrm_ue_agg_max_bit_rate_t));

    /* This function parses rrm_ue_agg_max_bit_rate */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_ue_agg_max_bit_rate->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_ue_agg_max_bit_rate->ue_agg_max_bit_rate_ul, p_src + *p_length_read, "ue_agg_max_bit_rate_ul");
    *p_length_read += sizeof(U64);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_ue_agg_max_bit_rate->ue_agg_max_bit_rate_dl, p_src + *p_length_read, "ue_agg_max_bit_rate_dl");
    *p_length_read += sizeof(U64);

    if (p_rrm_ue_agg_max_bit_rate->bitmask & RRC_RRM_EXT_UE_AGG_MAX_BITRATE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate_ext(
        &p_rrm_ue_agg_max_bit_rate->ue_agg_max_bit_rate_ext,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_allocation_and_retention_priority
(
    rrm_allocation_and_retention_priority_t *p_rrm_allocation_and_retention_priority,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_allocation_and_retention_priority, 0, sizeof(rrm_allocation_and_retention_priority_t));

    /* This function parses rrm_allocation_and_retention_priority */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_allocation_and_retention_priority->priority_level, p_src + *p_length_read, "priority_level");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_allocation_and_retention_priority->priority_level > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_allocation_and_retention_priority->priority_level] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_allocation_and_retention_priority->priority_level);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_allocation_and_retention_priority->preemption_capability, p_src + *p_length_read, "preemption_capability");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_allocation_and_retention_priority->preemption_capability > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_allocation_and_retention_priority->preemption_capability] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_allocation_and_retention_priority->preemption_capability);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_allocation_and_retention_priority->preemption_vulnerability, p_src + *p_length_read, "preemption_vulnerability");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_allocation_and_retention_priority->preemption_vulnerability > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_allocation_and_retention_priority->preemption_vulnerability] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_allocation_and_retention_priority->preemption_vulnerability);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_gbr_qos_info
(
    rrm_gbr_qos_info_t *p_rrm_gbr_qos_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_gbr_qos_info, 0, sizeof(rrm_gbr_qos_info_t));

    /* This function parses rrm_gbr_qos_info */

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_gbr_qos_info->erab_max_bit_rate_dl, p_src + *p_length_read, "erab_max_bit_rate_dl");
    *p_length_read += sizeof(U64);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_gbr_qos_info->erab_max_bit_rate_ul, p_src + *p_length_read, "erab_max_bit_rate_ul");
    *p_length_read += sizeof(U64);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_gbr_qos_info->erab_guar_bit_rate_dl, p_src + *p_length_read, "erab_guar_bit_rate_dl");
    *p_length_read += sizeof(U64);

    if (*p_length_read + (S32)sizeof(U64) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U64(&p_rrm_gbr_qos_info->erab_guar_bit_rate_ul, p_src + *p_length_read, "erab_guar_bit_rate_ul");
    *p_length_read += sizeof(U64);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_level_qos_params
(
    rrm_erab_level_qos_params_t *p_rrm_erab_level_qos_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_level_qos_params, 0, sizeof(rrm_erab_level_qos_params_t));

    /* This function parses rrm_erab_level_qos_params */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_level_qos_params->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_level_qos_params->qci, p_src + *p_length_read, "qci");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrm_allocation_and_retention_priority(
        &p_rrm_erab_level_qos_params->alloc_and_reten_prior,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_erab_level_qos_params->bitmask & 1)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_gbr_qos_info(
        &p_rrm_erab_level_qos_params->gbr_qos_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_setup_item
(
    rrm_erab_to_be_setup_item_t *p_rrm_erab_to_be_setup_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_to_be_setup_item, 0, sizeof(rrm_erab_to_be_setup_item_t));

    /* This function parses rrm_erab_to_be_setup_item */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_to_be_setup_item->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_setup_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_to_be_setup_item->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_setup_item->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_erab_to_be_setup_item->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_setup_item->dl_fwding, p_src + *p_length_read, "dl_fwding");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_to_be_setup_item->dl_fwding > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_setup_item->dl_fwding] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_erab_to_be_setup_item->dl_fwding);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_level_qos_params(
        &p_rrm_erab_to_be_setup_item->erab_level_qos_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_erab_to_be_setup_item->bitmask & ERAB_TO_BE_SETUP_DATA_FWDING_NOT_POSSIBLE_INFO_PRESENT_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_setup_item->data_fwding_not_possible, p_src + *p_length_read, "data_fwding_not_possible");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_to_be_setup_item->data_fwding_not_possible > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_setup_item->data_fwding_not_possible] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_erab_to_be_setup_item->data_fwding_not_possible);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_erab_to_be_setup_item->bitmask & ERAB_TO_BE_SETUP_LIPA_RAB_IND_PRESENT_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_setup_item->lipa_rab_ind, p_src + *p_length_read, "lipa_rab_ind");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_to_be_setup_item->lipa_rab_ind > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_setup_item->lipa_rab_ind] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_erab_to_be_setup_item->lipa_rab_ind);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_setup_item_list
(
    rrm_erab_to_be_setup_item_list_t *p_rrm_erab_to_be_setup_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_to_be_setup_item_list, 0, sizeof(rrm_erab_to_be_setup_item_list_t));

    /* This function parses rrm_erab_to_be_setup_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_to_be_setup_item_list->num_of_list, p_src + *p_length_read, "num_of_list");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_to_be_setup_item_list->num_of_list > MAX_ERAB_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_setup_item_list->num_of_list] should be less than"
            " or equal to MAX_ERAB_COUNT. Incorrect value %u received.", p_rrm_erab_to_be_setup_item_list->num_of_list);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_to_be_setup_item_list->num_of_list; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_setup_item(
                &p_rrm_erab_to_be_setup_item_list->erab_to_be_setup_item[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_equiv_plmn
(
    equiv_plmn_t *p_equiv_plmn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_equiv_plmn, 0, sizeof(equiv_plmn_t));

    /* This function parses equiv_plmn */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_equiv_plmn->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_equiv_plmn_list
(
    equiv_plmn_list_t *p_equiv_plmn_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_equiv_plmn_list, 0, sizeof(equiv_plmn_list_t));

    /* This function parses equiv_plmn_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_equiv_plmn_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_equiv_plmn_list->count < 1) || (p_equiv_plmn_list->count > MAX_NO_OF_EQUIVALENT_PLMN_IDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_equiv_plmn_list->count] should be in range "
            "1 to MAX_NO_OF_EQUIVALENT_PLMN_IDS. Incorrect value %u received.", p_equiv_plmn_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_equiv_plmn_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_equiv_plmn(
                &p_equiv_plmn_list->equiv_plmn[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_tac
(
    forbidden_tac_t *p_forbidden_tac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_forbidden_tac, 0, sizeof(forbidden_tac_t));

    /* This function parses forbidden_tac */

    if (*p_length_read + (S32)sizeof(p_forbidden_tac->tac) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_forbidden_tac->tac); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_forbidden_tac->tac[loop], (void*)(p_src + *p_length_read), "tac[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_tac_list
(
    forbidden_tac_list_t *p_forbidden_tac_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_tac_list, 0, sizeof(forbidden_tac_list_t));

    /* This function parses forbidden_tac_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_forbidden_tac_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_forbidden_tac_list->count < 1) || (p_forbidden_tac_list->count > MAX_NO_OF_FORBIDDEN_TACS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_forbidden_tac_list->count] should be in range "
            "1 to MAX_NO_OF_FORBIDDEN_TACS. Incorrect value %u received.", p_forbidden_tac_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_forbidden_tac_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_forbidden_tac(
                &p_forbidden_tac_list->forbidden_tac[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_ta
(
    forbidden_ta_t *p_forbidden_ta,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_ta, 0, sizeof(forbidden_ta_t));

    /* This function parses forbidden_ta */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_forbidden_ta->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_forbidden_tac_list(
        &p_forbidden_ta->forbidden_tac,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_ta_list
(
    forbidden_ta_list_t *p_forbidden_ta_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_ta_list, 0, sizeof(forbidden_ta_list_t));

    /* This function parses forbidden_ta_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_forbidden_ta_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_forbidden_ta_list->count < 1) || (p_forbidden_ta_list->count > MAX_NO_OF_EPLMNS_PlUS_ONE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_forbidden_ta_list->count] should be in range "
            "1 to MAX_NO_OF_EPLMNS_PlUS_ONE. Incorrect value %u received.", p_forbidden_ta_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_forbidden_ta_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_forbidden_ta(
                &p_forbidden_ta_list->forbidden_ta[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_lac
(
    forbidden_lac_t *p_forbidden_lac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_forbidden_lac, 0, sizeof(forbidden_lac_t));

    /* This function parses forbidden_lac */

    if (*p_length_read + (S32)sizeof(p_forbidden_lac->lac) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_forbidden_lac->lac); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_forbidden_lac->lac[loop], (void*)(p_src + *p_length_read), "lac[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_lac_list
(
    forbidden_lac_list_t *p_forbidden_lac_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_lac_list, 0, sizeof(forbidden_lac_list_t));

    /* This function parses forbidden_lac_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_forbidden_lac_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_forbidden_lac_list->count < 1) || (p_forbidden_lac_list->count > MAX_NO_OF_FORBIDDEN_LACS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_forbidden_lac_list->count] should be in range "
            "1 to MAX_NO_OF_FORBIDDEN_LACS. Incorrect value %u received.", p_forbidden_lac_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_forbidden_lac_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_forbidden_lac(
                &p_forbidden_lac_list->forbidden_lac[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_la
(
    forbidden_la_t *p_forbidden_la,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_la, 0, sizeof(forbidden_la_t));

    /* This function parses forbidden_la */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_forbidden_la->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_forbidden_lac_list(
        &p_forbidden_la->forbidden_lacs_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_forbidden_la_list
(
    forbidden_la_list_t *p_forbidden_la_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_forbidden_la_list, 0, sizeof(forbidden_la_list_t));

    /* This function parses forbidden_la_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_forbidden_la_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_forbidden_la_list->count < 1) || (p_forbidden_la_list->count > MAX_NO_OF_EPLMNS_PlUS_ONE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_forbidden_la_list->count] should be in range "
            "1 to MAX_NO_OF_EPLMNS_PlUS_ONE. Incorrect value %u received.", p_forbidden_la_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_forbidden_la_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_forbidden_la(
                &p_forbidden_la_list->forbidden_la[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ho_restriction_list
(
    ho_restriction_list_t *p_ho_restriction_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ho_restriction_list, 0, sizeof(ho_restriction_list_t));

    /* This function parses ho_restriction_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ho_restriction_list->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_ho_restriction_list->serving_plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ho_restriction_list->bitmask & HO_RESTRICTION_EQUIV_PLMN_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_equiv_plmn_list(
        &p_ho_restriction_list->equiv_plmn_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_TA_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_forbidden_ta_list(
        &p_ho_restriction_list->forbidden_ta_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_LA_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_forbidden_la_list(
        &p_ho_restriction_list->forbidden_la_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_restriction_list->bitmask & HO_RESTRICTION_FORBIDDEN_INTER_RAT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ho_restriction_list->forbidden_inter_rat, p_src + *p_length_read, "forbidden_inter_rat");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ho_restriction_list->forbidden_inter_rat > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ho_restriction_list->forbidden_inter_rat] should be less than"
            " or equal to 5. Incorrect value %u received.", p_ho_restriction_list->forbidden_inter_rat);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_plmn_identity_lai
(
    plmn_identity_lai_t *p_plmn_identity_lai,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_plmn_identity_lai, 0, sizeof(plmn_identity_lai_t));

    /* This function parses plmn_identity_lai */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_plmn_identity_lai->num, p_src + *p_length_read, "num");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_plmn_identity_lai->num > MAX_PLMN_ID_NUMOCTS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_plmn_identity_lai->num] should be less than"
            " or equal to MAX_PLMN_ID_NUMOCTS. Incorrect value %u received.", p_plmn_identity_lai->num);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_plmn_identity_lai->data) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_plmn_identity_lai->data); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_plmn_identity_lai->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_lac
(
    lac_t *p_lac,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_lac, 0, sizeof(lac_t));

    /* This function parses lac */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_lac->num, p_src + *p_length_read, "num");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_lac->num > MAX_LAC_NUMOCTS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_lac->num] should be less than"
            " or equal to MAX_LAC_NUMOCTS. Incorrect value %u received.", p_lac->num);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_lac->data) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_lac->data); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_lac->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_registered_lai
(
    registered_lai_t *p_registered_lai,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_registered_lai, 0, sizeof(registered_lai_t));

    /* This function parses registered_lai */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity_lai(
        &p_registered_lai->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_lac(
        &p_registered_lai->lac,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_setup_resp
(
    rrc_rrm_erb_setup_resp_t *p_rrc_rrm_erb_setup_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_setup_resp, 0, sizeof(rrc_rrm_erb_setup_resp_t));

    /* This function parses rrc_rrm_erb_setup_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_setup_resp->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_resp->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_erb_setup_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_ADM_RADIO_RES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_setup_radio_res_config(
        &p_rrc_rrm_erb_setup_resp->radio_rsource_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_FAIL_CAUSE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_erb_setup_resp->fail_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_ERAB_TO_BE_RELEASED_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_released_item_list(
        &p_rrc_rrm_erb_setup_resp->erab_to_be_released_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_UE_INACTIVE_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_erb_setup_resp->ue_inactive_time_config, p_src + *p_length_read, "ue_inactive_time_config");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_MPDCCH_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RrcRrmErabMpdcchConfigInfo(
        &p_rrc_rrm_erb_setup_resp->mdcchConfigInfo,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_resp->bitmask & RRM_ERB_SETUP_RESP_API_SGNB_ADD_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_sgnb_add_param(
        &p_rrc_rrm_erb_setup_resp->sgnb_add_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pdcp_rohc_profile
(
    rrc_pdcp_rohc_profile_t *p_rrc_pdcp_rohc_profile,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_pdcp_rohc_profile, 0, sizeof(rrc_pdcp_rohc_profile_t));

    /* This function parses rrc_pdcp_rohc_profile */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0001, p_src + *p_length_read, "profile0x0001");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0001 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0001] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0001);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0002, p_src + *p_length_read, "profile0x0002");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0002 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0002] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0002);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0003, p_src + *p_length_read, "profile0x0003");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0003 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0003] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0003);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0004, p_src + *p_length_read, "profile0x0004");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0004 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0004] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0004);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0006, p_src + *p_length_read, "profile0x0006");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0006 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0006] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0006);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0101, p_src + *p_length_read, "profile0x0101");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0101 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0101] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0101);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0102, p_src + *p_length_read, "profile0x0102");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0102 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0102] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0102);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0103, p_src + *p_length_read, "profile0x0103");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0103 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0103] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0103);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_rohc_profile->profile0x0104, p_src + *p_length_read, "profile0x0104");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_rohc_profile->profile0x0104 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_profile->profile0x0104] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_rohc_profile->profile0x0104);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pdcp_rohc_config
(
    rrc_pdcp_rohc_config_t *p_rrc_pdcp_rohc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_pdcp_rohc_config, 0, sizeof(rrc_pdcp_rohc_config_t));

    /* This function parses rrc_pdcp_rohc_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_rohc_config->max_cid, p_src + *p_length_read, "max_cid");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_pdcp_rohc_config->max_cid < 1) || (p_rrc_pdcp_rohc_config->max_cid > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_rohc_config->max_cid] should be in range "
            "1 to 16383. Incorrect value %u received.", p_rrc_pdcp_rohc_config->max_cid);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_rohc_profile(
        &p_rrc_pdcp_rohc_config->rohc_profile,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pdcp_header_compression_config
(
    rrc_pdcp_header_compression_config_t *p_rrc_pdcp_header_compression_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_pdcp_header_compression_config, 0, sizeof(rrc_pdcp_header_compression_config_t));

    /* This function parses rrc_pdcp_header_compression_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_header_compression_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_pdcp_header_compression_config->bitmask & RRC_PDCP_HEADER_COMPRESSION_ROHC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_rohc_config(
        &p_rrc_pdcp_header_compression_config->rohc_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_pdcp_config
(
    rrc_pdcp_config_t *p_rrc_pdcp_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_pdcp_config, 0, sizeof(rrc_pdcp_config_t));

    /* This function parses rrc_pdcp_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_pdcp_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_pdcp_config->bitmask & RRC_PDCP_CONFIG_DISCARD_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_config->discard_timer, p_src + *p_length_read, "discard_timer");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_config->discard_timer > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_config->discard_timer] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_pdcp_config->discard_timer);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_pdcp_config->bitmask & RRC_PDCP_CONFIG_RLC_AM_STATUS_REPORT_REQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_config->rlc_am_status_report_required, p_src + *p_length_read, "rlc_am_status_report_required");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_config->rlc_am_status_report_required > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_config->rlc_am_status_report_required] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_config->rlc_am_status_report_required);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_pdcp_config->bitmask & RRC_PDCP_CONFIG_RLC_UM_PDCP_SN_SIZE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_config->rlc_um_pdcp_sn_size, p_src + *p_length_read, "rlc_um_pdcp_sn_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_config->rlc_um_pdcp_sn_size > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_config->rlc_um_pdcp_sn_size] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_config->rlc_um_pdcp_sn_size);
        return RRC_FAILURE;
    }
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_header_compression_config(
        &p_rrc_pdcp_config->header_compression,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_pdcp_config->bitmask & RRC_PDCP_CONFIG_RLC_AM_ENB_STATUS_REPORT_REQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_pdcp_config->rlc_am_enb_status_report_required, p_src + *p_length_read, "rlc_am_enb_status_report_required");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_pdcp_config->rlc_am_enb_status_report_required > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_pdcp_config->rlc_am_enb_status_report_required] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_pdcp_config->rlc_am_enb_status_report_required);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_uplink_um_rlc
(
    rrc_uplink_um_rlc_t *p_rrc_uplink_um_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_uplink_um_rlc, 0, sizeof(rrc_uplink_um_rlc_t));

    /* This function parses rrc_uplink_um_rlc */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_uplink_um_rlc->sn_field_length, p_src + *p_length_read, "sn_field_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_uplink_um_rlc->sn_field_length > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_uplink_um_rlc->sn_field_length] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_uplink_um_rlc->sn_field_length);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_downlink_um_rlc
(
    rrc_downlink_um_rlc_t *p_rrc_downlink_um_rlc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_downlink_um_rlc, 0, sizeof(rrc_downlink_um_rlc_t));

    /* This function parses rrc_downlink_um_rlc */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_downlink_um_rlc->sn_field_length, p_src + *p_length_read, "sn_field_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_downlink_um_rlc->sn_field_length > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_downlink_um_rlc->sn_field_length] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_downlink_um_rlc->sn_field_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_downlink_um_rlc->t_reordering, p_src + *p_length_read, "t_reordering");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_downlink_um_rlc->t_reordering > 30))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_downlink_um_rlc->t_reordering] should be less than"
            " or equal to 30. Incorrect value %u received.", p_rrc_downlink_um_rlc->t_reordering);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_um_bi_directional_config
(
    rrc_um_bi_directional_config_t *p_rrc_um_bi_directional_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_um_bi_directional_config, 0, sizeof(rrc_um_bi_directional_config_t));

    /* This function parses rrc_um_bi_directional_config */

    if (RRC_FAILURE == rrc_il_parse_rrc_uplink_um_rlc(
        &p_rrc_um_bi_directional_config->ul_um_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_downlink_um_rlc(
        &p_rrc_um_bi_directional_config->dl_um_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_um_uni_directional_ul_config
(
    rrc_um_uni_directional_ul_config_t *p_rrc_um_uni_directional_ul_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_um_uni_directional_ul_config, 0, sizeof(rrc_um_uni_directional_ul_config_t));

    /* This function parses rrc_um_uni_directional_ul_config */

    if (RRC_FAILURE == rrc_il_parse_rrc_uplink_um_rlc(
        &p_rrc_um_uni_directional_ul_config->ul_um_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_um_uni_directional_dl_config
(
    rrc_um_uni_directional_dl_config_t *p_rrc_um_uni_directional_dl_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_um_uni_directional_dl_config, 0, sizeof(rrc_um_uni_directional_dl_config_t));

    /* This function parses rrc_um_uni_directional_dl_config */

    if (RRC_FAILURE == rrc_il_parse_rrc_downlink_um_rlc(
        &p_rrc_um_uni_directional_dl_config->dl_um_rlc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlc_config
(
    rrc_rlc_config_t *p_rrc_rlc_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlc_config, 0, sizeof(rrc_rlc_config_t));

    /* This function parses rrc_rlc_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlc_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rlc_config->bitmask & RRC_RLC_CONFIG_AM_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_am_config(
        &p_rrc_rlc_config->am_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlc_config->bitmask & RRC_RLC_CONFIG_UM_BI_DIRECTIONAL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_um_bi_directional_config(
        &p_rrc_rlc_config->um_bi_directional_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlc_config->bitmask & RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_UL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_um_uni_directional_ul_config(
        &p_rrc_rlc_config->um_uni_directional_ul_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlc_config->bitmask & RRC_RLC_CONFIG_UM_UNI_DIRECTIONAL_CONFIG_DL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_um_uni_directional_dl_config(
        &p_rrc_rlc_config->um_uni_directional_dl_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlc_config_enb
(
    rrc_rlc_config_enb_t *p_rrc_rlc_config_enb,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlc_config_enb, 0, sizeof(rrc_rlc_config_enb_t));

    /* This function parses rrc_rlc_config_enb */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlc_config_enb->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rlc_config(
        &p_rrc_rlc_config_enb->rlc_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rlc_config_enb->bitmask & RRC_RLC_CONFIG_QCI_LENGTH_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rlc_config_enb->qci_length, p_src + *p_length_read, "qci_length");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rlc_config_enb->qci_length > 28311552))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rlc_config_enb->qci_length] should be less than"
            " or equal to 28311552. Incorrect value %u received.", p_rrc_rlc_config_enb->qci_length);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_s1u_qos_profile
(
    rrm_s1u_qos_profile_t *p_rrm_s1u_qos_profile,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_s1u_qos_profile, 0, sizeof(rrm_s1u_qos_profile_t));

    /* This function parses rrm_s1u_qos_profile */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_s1u_qos_profile->allocation_retention_priority, p_src + *p_length_read, "allocation_retention_priority");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_s1u_qos_profile->qos_profile_data_size, p_src + *p_length_read, "qos_profile_data_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_s1u_qos_profile->qos_profile_data_size < 3) || (p_rrm_s1u_qos_profile->qos_profile_data_size > MAX_S1U_QOS_PROFILE_DATA_OCTET_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_s1u_qos_profile->qos_profile_data_size] should be in range "
            "3 to MAX_S1U_QOS_PROFILE_DATA_OCTET_SIZE. Incorrect value %u received.", p_rrm_s1u_qos_profile->qos_profile_data_size);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrm_s1u_qos_profile->qos_profile_data_size * sizeof(p_rrm_s1u_qos_profile->qos_profile_data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_s1u_qos_profile->qos_profile_data_size; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_s1u_qos_profile->qos_profile_data[loop], (void*)(p_src + *p_length_read), "qos_profile_data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_s1u_config
(
    rrm_s1u_config_t *p_rrm_s1u_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_s1u_config, 0, sizeof(rrm_s1u_config_t));

    /* This function parses rrm_s1u_config */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_s1u_config->qos_id, p_src + *p_length_read, "qos_id");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_s1u_config->sap_flags, p_src + *p_length_read, "sap_flags");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrm_s1u_qos_profile(
        &p_rrm_s1u_config->qos_profile,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_s1u_config->seq_flag, p_src + *p_length_read, "seq_flag");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_s1u_config->seq_flag > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_s1u_config->seq_flag] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_s1u_config->seq_flag);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_s1u_config->reordering_reqd, p_src + *p_length_read, "reordering_reqd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_s1u_config->reordering_reqd > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_s1u_config->reordering_reqd] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_s1u_config->reordering_reqd);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rrc_drb_lwa_config
(
    rrm_rrc_drb_lwa_config_t *p_rrm_rrc_drb_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_drb_lwa_config, 0, sizeof(rrm_rrc_drb_lwa_config_t));

    /* This function parses rrm_rrc_drb_lwa_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_drb_lwa_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rrc_drb_lwa_config->lwa_bearer, p_src + *p_length_read, "lwa_bearer");
    *p_length_read += sizeof(U8);

    if (p_rrm_rrc_drb_lwa_config->bitmask & DRB_LWA_CONFIG_LWA_BEARER_TYPE)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rrc_drb_lwa_config->lwa_bearer_type, p_src + *p_length_read, "lwa_bearer_type");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_config
(
    rrm_drb_config_t *p_rrm_drb_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_config, 0, sizeof(rrm_drb_config_t));

    /* This function parses rrm_drb_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_drb_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_BEARED_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_config->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_drb_config->erab_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->drb_id, p_src + *p_length_read, "drb_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_drb_config->drb_id < 1) || (p_rrm_drb_config->drb_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->drb_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_rrm_drb_config->drb_id);
        return RRC_FAILURE;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_LOGICAL_CHANNEL_IDENTITY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->logical_channel_identity, p_src + *p_length_read, "logical_channel_identity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_drb_config->logical_channel_identity < 3) || (p_rrm_drb_config->logical_channel_identity > 10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->logical_channel_identity] should be in range "
            "3 to 10. Incorrect value %u received.", p_rrm_drb_config->logical_channel_identity);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_PDCP_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_config(
        &p_rrm_drb_config->pdcp_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_RLC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlc_config_enb(
        &p_rrm_drb_config->rlc_config_enb,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_LOGICAL_CHANNEL_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_logical_channel_config(
        &p_rrm_drb_config->logical_channel_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_S1U_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_s1u_config(
        &p_rrm_drb_config->s1u_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_MAC_LC_CONFIG_ENB_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_lc_config(
        &p_rrm_drb_config->mac_lc_config_enb,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_RLC_CONFIG_UE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlc_config(
        &p_rrm_drb_config->rlc_config_ue,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_BEARER_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->bearer_type, p_src + *p_length_read, "bearer_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_config->bearer_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->bearer_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_drb_config->bearer_type);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_LWA_CAPABILITY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->lwa_capable, p_src + *p_length_read, "lwa_capable");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_config->lwa_capable > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->lwa_capable] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_drb_config->lwa_capable);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_LWA_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_rrc_drb_lwa_config(
        &p_rrm_drb_config->lwa_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_config->bitmask & RRM_DRB_CONFIG_DC_BEARER_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_config->dc_bearer_type, p_src + *p_length_read, "dc_bearer_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_config->dc_bearer_type > DC_BEARER_TYPE_LAST))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_config->dc_bearer_type] should be less than"
            " or equal to DC_BEARER_TYPE_LAST. Incorrect value %u received.", p_rrm_drb_config->dc_bearer_type);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_to_add_info_list
(
    rrm_drb_to_add_info_list_t *p_rrm_drb_to_add_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_to_add_info_list, 0, sizeof(rrm_drb_to_add_info_list_t));

    /* This function parses rrm_drb_to_add_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_to_add_info_list->drb_count, p_src + *p_length_read, "drb_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_drb_to_add_info_list->drb_count < 1) || (p_rrm_drb_to_add_info_list->drb_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_to_add_info_list->drb_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_drb_to_add_info_list->drb_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_drb_to_add_info_list->drb_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_drb_config(
                &p_rrm_drb_to_add_info_list->drb_config[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_failed_to_add_item
(
    rrm_drb_failed_to_add_item_t *p_rrm_drb_failed_to_add_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_failed_to_add_item, 0, sizeof(rrm_drb_failed_to_add_item_t));

    /* This function parses rrm_drb_failed_to_add_item */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_failed_to_add_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_failed_to_add_item->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_failed_to_add_item->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_drb_failed_to_add_item->erab_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrm_drb_failed_to_add_item->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_failed_to_add_info_list
(
    rrm_drb_failed_to_add_info_list_t *p_rrm_drb_failed_to_add_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_failed_to_add_info_list, 0, sizeof(rrm_drb_failed_to_add_info_list_t));

    /* This function parses rrm_drb_failed_to_add_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_failed_to_add_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_drb_failed_to_add_info_list->count < 1) || (p_rrm_drb_failed_to_add_info_list->count > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_failed_to_add_info_list->count] should be in range "
            "1 to 16. Incorrect value %u received.", p_rrm_drb_failed_to_add_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_drb_failed_to_add_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_drb_failed_to_add_item(
                &p_rrm_drb_failed_to_add_info_list->drb_failed_to_add[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_report_proximity_config_r9
(
    rrm_report_proximity_config_r9_t *p_rrm_report_proximity_config_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_report_proximity_config_r9, 0, sizeof(rrm_report_proximity_config_r9_t));

    /* This function parses rrm_report_proximity_config_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_report_proximity_config_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_report_proximity_config_r9->bitmask & RRM_PROXIMITY_IND_EUTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_report_proximity_config_r9->proximity_ind_eutra, p_src + *p_length_read, "proximity_ind_eutra");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_report_proximity_config_r9->proximity_ind_eutra > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_report_proximity_config_r9->proximity_ind_eutra] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_report_proximity_config_r9->proximity_ind_eutra);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_report_proximity_config_r9->bitmask & RRM_PROXIMITY_IND_UTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_report_proximity_config_r9->proximity_ind_utra, p_src + *p_length_read, "proximity_ind_utra");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_report_proximity_config_r9->proximity_ind_utra > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_report_proximity_config_r9->proximity_ind_utra] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_report_proximity_config_r9->proximity_ind_utra);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_setup_radio_res_config
(
    rrm_erab_setup_radio_res_config_t *p_rrm_erab_setup_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_setup_radio_res_config, 0, sizeof(rrm_erab_setup_radio_res_config_t));

    /* This function parses rrm_erab_setup_radio_res_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_setup_radio_res_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_DRB_TO_ADD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_to_add_info_list(
        &p_rrm_erab_setup_radio_res_config->drb_to_add_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_MAC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_config(
        &p_rrm_erab_setup_radio_res_config->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_rrm_erab_setup_radio_res_config->sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_PHY_CONFIG_DED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated(
        &p_rrm_erab_setup_radio_res_config->physical_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_rrm_erab_setup_radio_res_config->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_DRB_FAILED_TO_ADD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_failed_to_add_info_list(
        &p_rrm_erab_setup_radio_res_config->drb_failed_to_add_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_SRB_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_info(
        &p_rrm_erab_setup_radio_res_config->srb_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_RLF_TIMERS_AND_CONSTANTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rlf_timers_and_constants_r9(
        &p_rrm_erab_setup_radio_res_config->rlf_timers_and_constants_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_PROXIMITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_report_proximity_config_r9(
        &p_rrm_erab_setup_radio_res_config->proximity_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_setup_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_subframe_pattern_pcell_r10(
        &p_rrm_erab_setup_radio_res_config->rrc_meas_subframe_pattern_pcell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_item
(
    rrm_erab_failed_item_t *p_rrm_erab_failed_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_failed_item, 0, sizeof(rrm_erab_failed_item_t));

    /* This function parses rrm_erab_failed_item */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_failed_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_failed_item->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_failed_item->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_erab_failed_item->erab_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrm_erab_failed_item->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_released_item_list
(
    rrm_erab_to_be_released_item_list_t *p_rrm_erab_to_be_released_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_to_be_released_item_list, 0, sizeof(rrm_erab_to_be_released_item_list_t));

    /* This function parses rrm_erab_to_be_released_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_to_be_released_item_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_to_be_released_item_list->count < 1) || (p_rrm_erab_to_be_released_item_list->count > MAX_ERAB_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_released_item_list->count] should be in range "
            "1 to MAX_ERAB_COUNT. Incorrect value %u received.", p_rrm_erab_to_be_released_item_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_to_be_released_item_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_failed_item(
                &p_rrm_erab_to_be_released_item_list->erab_to_be_release_item[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RrcRrmErabMpdcchConfigInfo
(
    RrcRrmErabMpdcchConfigInfo_t *p_RrcRrmErabMpdcchConfigInfo,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RrcRrmErabMpdcchConfigInfo, 0, sizeof(RrcRrmErabMpdcchConfigInfo_t));

    /* This function parses RrcRrmErabMpdcchConfigInfo */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmErabMpdcchConfigInfo->narrowband_idx, p_src + *p_length_read, "narrowband_idx");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_RrcRrmErabMpdcchConfigInfo->narrowband_idx < 1) || (p_RrcRrmErabMpdcchConfigInfo->narrowband_idx > EMTC_MAX_AVAILABLE_NARROWBAND))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RrcRrmErabMpdcchConfigInfo->narrowband_idx] should be in range "
            "1 to EMTC_MAX_AVAILABLE_NARROWBAND. Incorrect value %u received.", p_RrcRrmErabMpdcchConfigInfo->narrowband_idx);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RrcRrmErabMpdcchConfigInfo->prb_bitmap, p_src + *p_length_read, "prb_bitmap");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_quantity_res
(
    rrc_rrm_meas_quantity_res_t *p_rrc_rrm_meas_quantity_res,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_quantity_res, 0, sizeof(rrc_rrm_meas_quantity_res_t));

    /* This function parses rrc_rrm_meas_quantity_res */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_quantity_res->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_meas_quantity_res->bitmask & RRC_RRM_MEAS_QUANTITY_RES_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_meas_quantity_res->rsrp, p_src + *p_length_read, "rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_quantity_res->rsrp > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_quantity_res->rsrp] should be less than"
            " or equal to 127. Incorrect value %u received.", p_rrc_rrm_meas_quantity_res->rsrp);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_meas_quantity_res->bitmask & RRC_RRM_MEAS_QUANTITY_RES_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_meas_quantity_res->rsrq, p_src + *p_length_read, "rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_quantity_res->rsrq > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_quantity_res->rsrq] should be less than"
            " or equal to 127. Incorrect value %u received.", p_rrc_rrm_meas_quantity_res->rsrq);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_meas_quantity_res->bitmask & RRC_RRM_MEAS_QUANTITY_RES_SINR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_meas_quantity_res->sinr, p_src + *p_length_read, "sinr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_quantity_res->sinr > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_quantity_res->sinr] should be less than"
            " or equal to 127. Incorrect value %u received.", p_rrc_rrm_meas_quantity_res->sinr);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_cell_results
(
    rrc_rrm_meas_cell_results_t *p_rrc_rrm_meas_cell_results,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_cell_results, 0, sizeof(rrc_rrm_meas_cell_results_t));

    /* This function parses rrc_rrm_meas_cell_results */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_cell_results->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_meas_cell_results->bitmask & RRC_RRM_MEAS_CELL_RESULT_SSB_RESULT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_quantity_res(
        &p_rrc_rrm_meas_cell_results->result_ssb_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_meas_cell_results->bitmask & RRC_RRM_MEAS_CELL_RESULT_CSI_RS_RESULT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_quantity_res(
        &p_rrc_rrm_meas_cell_results->result_csi_rs_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_ssb_idx
(
    rrc_rrm_results_per_ssb_idx_t *p_rrc_rrm_results_per_ssb_idx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_results_per_ssb_idx, 0, sizeof(rrc_rrm_results_per_ssb_idx_t));

    /* This function parses rrc_rrm_results_per_ssb_idx */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_results_per_ssb_idx->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_results_per_ssb_idx->ssb_index, p_src + *p_length_read, "ssb_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_results_per_ssb_idx->ssb_index > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_results_per_ssb_idx->ssb_index] should be less than"
            " or equal to 63. Incorrect value %u received.", p_rrc_rrm_results_per_ssb_idx->ssb_index);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_results_per_ssb_idx->bitmask & RRC_RRM_RESULT_PER_SSB_SSB_RESULTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_quantity_res(
        &p_rrc_rrm_results_per_ssb_idx->ssb_results,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_ssb_idx_list
(
    rrc_rrm_results_per_ssb_idx_list_t *p_rrc_rrm_results_per_ssb_idx_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_results_per_ssb_idx_list, 0, sizeof(rrc_rrm_results_per_ssb_idx_list_t));

    /* This function parses rrc_rrm_results_per_ssb_idx_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_results_per_ssb_idx_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_results_per_ssb_idx_list->count > MAX_NUM_OF_IDX_TO_REPORT2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_results_per_ssb_idx_list->count] should be less than"
            " or equal to MAX_NUM_OF_IDX_TO_REPORT2. Incorrect value %u received.", p_rrc_rrm_results_per_ssb_idx_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_results_per_ssb_idx_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_rrm_results_per_ssb_idx(
                &p_rrc_rrm_results_per_ssb_idx_list->rrc_rrm_results_per_ssb_idx[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_csi_rs_idx
(
    rrc_rrm_results_per_csi_rs_idx_t *p_rrc_rrm_results_per_csi_rs_idx,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_results_per_csi_rs_idx, 0, sizeof(rrc_rrm_results_per_csi_rs_idx_t));

    /* This function parses rrc_rrm_results_per_csi_rs_idx */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_results_per_csi_rs_idx->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_results_per_csi_rs_idx->csi_rs_index, p_src + *p_length_read, "csi_rs_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_results_per_csi_rs_idx->csi_rs_index > 95))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_results_per_csi_rs_idx->csi_rs_index] should be less than"
            " or equal to 95. Incorrect value %u received.", p_rrc_rrm_results_per_csi_rs_idx->csi_rs_index);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_results_per_csi_rs_idx->bitmask & RRC_RRM_RESULT_PER_CSI_RS_CSI_RS_RESULTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_quantity_res(
        &p_rrc_rrm_results_per_csi_rs_idx->csi_rs_results,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_results_per_csi_rs_idx_list
(
    rrc_rrm_results_per_csi_rs_idx_list_t *p_rrc_rrm_results_per_csi_rs_idx_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_results_per_csi_rs_idx_list, 0, sizeof(rrc_rrm_results_per_csi_rs_idx_list_t));

    /* This function parses rrc_rrm_results_per_csi_rs_idx_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_results_per_csi_rs_idx_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_results_per_csi_rs_idx_list->count > MAX_NUM_OF_IDX_TO_REPORT2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_results_per_csi_rs_idx_list->count] should be less than"
            " or equal to MAX_NUM_OF_IDX_TO_REPORT2. Incorrect value %u received.", p_rrc_rrm_results_per_csi_rs_idx_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_results_per_csi_rs_idx_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_rrm_results_per_csi_rs_idx(
                &p_rrc_rrm_results_per_csi_rs_idx_list->rrc_rrm_results_per_csi_rs_idx[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_rs_idx_results
(
    rrc_rrm_meas_rs_idx_results_t *p_rrc_rrm_meas_rs_idx_results,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_rs_idx_results, 0, sizeof(rrc_rrm_meas_rs_idx_results_t));

    /* This function parses rrc_rrm_meas_rs_idx_results */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_rs_idx_results->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_meas_rs_idx_results->bitmask & RRC_RRM_MEAS_RESULT_RS_PER_SSB_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_results_per_ssb_idx_list(
        &p_rrc_rrm_meas_rs_idx_results->results_per_ssb_idx_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_meas_rs_idx_results->bitmask & RRC_RRM_MEAS_RESULT_RS_PER_CSI_RS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_results_per_csi_rs_idx_list(
        &p_rrc_rrm_meas_rs_idx_results->results_per_csi_rs_idx_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result
(
    rrc_rrm_meas_result_t *p_rrc_rrm_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_result, 0, sizeof(rrc_rrm_meas_result_t));

    /* This function parses rrc_rrm_meas_result */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_result->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_cell_results(
        &p_rrc_rrm_meas_result->meas_cell_results,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_meas_result->bitmask & RRC_RRM_MEAS_RESULT_RS_IDX_RESULT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_rs_idx_results(
        &p_rrc_rrm_meas_result->meas_rs_idx_results,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_nr
(
    meas_result_nr_t *p_meas_result_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_nr, 0, sizeof(meas_result_nr_t));

    /* This function parses meas_result_nr */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_nr->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_result(
        &p_meas_result_nr->rrc_rrm_meas_result,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_nr->bitmask & RRC_RRM_MEAS_RESULT_NR_PHY_CELL_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_nr->phy_cell_id, p_src + *p_length_read, "phy_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_nr->phy_cell_id > 1007))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_nr->phy_cell_id] should be less than"
            " or equal to 1007. Incorrect value %u received.", p_meas_result_nr->phy_cell_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list_nr
(
    meas_result_list_nr_t *p_meas_result_list_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list_nr, 0, sizeof(meas_result_list_nr_t));

    /* This function parses meas_result_list_nr */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list_nr->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_list_nr->count > MAX_NR_CELL_REPORT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list_nr->count] should be less than"
            " or equal to MAX_NR_CELL_REPORT. Incorrect value %u received.", p_meas_result_list_nr->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list_nr->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_nr(
                &p_meas_result_list_nr->meas_result_nr[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result2_nr
(
    rrc_rrm_meas_result2_nr_t *p_rrc_rrm_meas_result2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_result2_nr, 0, sizeof(rrc_rrm_meas_result2_nr_t));

    /* This function parses rrc_rrm_meas_result2_nr */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_result2_nr->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_meas_result2_nr->bitmask & RRC_RRM_MEAS_RESULT2_NR_SSB_FREQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_meas_result2_nr->ssb_frequency, p_src + *p_length_read, "ssb_frequency");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_result2_nr->ssb_frequency > NR_MAX_EARFCN))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_result2_nr->ssb_frequency] should be less than"
            " or equal to NR_MAX_EARFCN. Incorrect value %u received.", p_rrc_rrm_meas_result2_nr->ssb_frequency);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_meas_result2_nr->bitmask & RRC_RRM_MEAS_RESULT2_NR_REF_FREQ_CSI_RS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_meas_result2_nr->ref_freq_csi_rs, p_src + *p_length_read, "ref_freq_csi_rs");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_result2_nr->ref_freq_csi_rs > NR_MAX_EARFCN))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_result2_nr->ref_freq_csi_rs] should be less than"
            " or equal to NR_MAX_EARFCN. Incorrect value %u received.", p_rrc_rrm_meas_result2_nr->ref_freq_csi_rs);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_meas_result2_nr->bitmask & RRC_RRM_MEAS_RESULT2_NR_MEAS_RES_SERVING_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_nr(
        &p_rrc_rrm_meas_result2_nr->meas_result_serving_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_meas_result2_nr->bitmask & RRC_RRM_MEAS_RESULT2_NR_MEAS_RES_NEIGH_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_nr(
        &p_rrc_rrm_meas_result2_nr->meas_result_neigh_cell_list_nr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_meas_result_list2_nr
(
    rrc_rrm_meas_result_list2_nr_t *p_rrc_rrm_meas_result_list2_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_result_list2_nr, 0, sizeof(rrc_rrm_meas_result_list2_nr_t));

    /* This function parses rrc_rrm_meas_result_list2_nr */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_meas_result_list2_nr->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_result_list2_nr->count > NR_MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_result_list2_nr->count] should be less than"
            " or equal to NR_MAX_FREQ. Incorrect value %u received.", p_rrc_rrm_meas_result_list2_nr->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_meas_result_list2_nr->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_result2_nr(
                &p_rrc_rrm_meas_result_list2_nr->rrc_rrm_meas_result2_nr[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_index_list
(
    band_combination_index_list_t *p_band_combination_index_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_band_combination_index_list, 0, sizeof(band_combination_index_list_t));

    /* This function parses band_combination_index_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_combination_index_list->band_comb_count, p_src + *p_length_read, "band_comb_count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_index_list->band_comb_count < 1) || (p_band_combination_index_list->band_comb_count > MAX_BAND_COMB_EUTRA_NR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_index_list->band_comb_count] should be in range "
            "1 to MAX_BAND_COMB_EUTRA_NR. Incorrect value %u received.", p_band_combination_index_list->band_comb_count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_band_combination_index_list->band_comb_count * sizeof(p_band_combination_index_list->band_comb_index[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_index_list->band_comb_count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_band_combination_index_list->band_comb_index[loop], (void*)(p_src + *p_length_read), "band_comb_index[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_scg_serv_cell_index_range
(
    scg_serv_cell_index_range_t *p_scg_serv_cell_index_range,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_scg_serv_cell_index_range, 0, sizeof(scg_serv_cell_index_range_t));

    /* This function parses scg_serv_cell_index_range */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_scg_serv_cell_index_range->low_bound_cell_index, p_src + *p_length_read, "low_bound_cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_scg_serv_cell_index_range->low_bound_cell_index > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_scg_serv_cell_index_range->low_bound_cell_index] should be less than"
            " or equal to 31. Incorrect value %u received.", p_scg_serv_cell_index_range->low_bound_cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_scg_serv_cell_index_range->up_bound_cell_index, p_src + *p_length_read, "up_bound_cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_scg_serv_cell_index_range->up_bound_cell_index > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_scg_serv_cell_index_range->up_bound_cell_index] should be less than"
            " or equal to 31. Incorrect value %u received.", p_scg_serv_cell_index_range->up_bound_cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_power_coordination_fr1
(
    power_coordination_fr1_t *p_power_coordination_fr1,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_power_coordination_fr1, 0, sizeof(power_coordination_fr1_t));

    /* This function parses power_coordination_fr1 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_power_coordination_fr1->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_power_coordination_fr1->bitmask & POWER_COORDINATION_FR1_P_MAX_NR_FR1_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_power_coordination_fr1->p_max_nr_fr1, p_src + *p_length_read, "p_max_nr_fr1");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_power_coordination_fr1->p_max_nr_fr1 < -30) || (p_power_coordination_fr1->p_max_nr_fr1 > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_power_coordination_fr1->p_max_nr_fr1] should be in range "
            "-30 to 33. Incorrect value %d received.", p_power_coordination_fr1->p_max_nr_fr1);
        return RRC_FAILURE;
    }
    }

    if (p_power_coordination_fr1->bitmask & POWER_COORDINATION_FR1_P_MAX_EUTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_power_coordination_fr1->p_max_eutra, p_src + *p_length_read, "p_max_eutra");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_power_coordination_fr1->p_max_eutra < -30) || (p_power_coordination_fr1->p_max_eutra > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_power_coordination_fr1->p_max_eutra] should be in range "
            "-30 to 33. Incorrect value %d received.", p_power_coordination_fr1->p_max_eutra);
        return RRC_FAILURE;
    }
    }

    if (p_power_coordination_fr1->bitmask & POWER_COORDINATION_FR1_P_MAX_UE_FR1_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_power_coordination_fr1->p_max_ue_fr1, p_src + *p_length_read, "p_max_ue_fr1");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_power_coordination_fr1->p_max_ue_fr1 < -30) || (p_power_coordination_fr1->p_max_ue_fr1 > 33))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_power_coordination_fr1->p_max_ue_fr1] should be in range "
            "-30 to 33. Incorrect value %d received.", p_power_coordination_fr1->p_max_ue_fr1);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_config_restrict_info
(
    config_restrict_info_t *p_config_restrict_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_config_restrict_info, 0, sizeof(config_restrict_info_t));

    /* This function parses config_restrict_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_config_restrict_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_config_restrict_info->bitmask & NR_CG_CONFIG_RESTRICT_INFO_ALLOWED_BC_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_combination_index_list(
        &p_config_restrict_info->allowed_bc_list_mrdc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_config_restrict_info->bitmask & NR_CG_CONFIG_RESTRICT_INFO_SCG_SERV_CELL_INDEX_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_scg_serv_cell_index_range(
        &p_config_restrict_info->scg_serv_cell_index_range,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_config_restrict_info->bitmask & NR_CG_CONFIG_RESTRICT_INFO_POWER_COORD_FR1_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_power_coordination_fr1(
        &p_config_restrict_info->power_coordination_fr1,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_config_restrict_info->bitmask & NR_CG_CONFIG_RESTRICT_INFO_MAX_MEAS_FREQ_SCG_NR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_config_restrict_info->max_meas_freq_scg_nr, p_src + *p_length_read, "max_meas_freq_scg_nr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_config_restrict_info->max_meas_freq_scg_nr < 1) || (p_config_restrict_info->max_meas_freq_scg_nr > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_config_restrict_info->max_meas_freq_scg_nr] should be in range "
            "1 to 32. Incorrect value %u received.", p_config_restrict_info->max_meas_freq_scg_nr);
        return RRC_FAILURE;
    }
    }

    if (p_config_restrict_info->bitmask & NR_CG_CONFIG_RESTRICT_INFO_MAX_MEAS_ID_SCG_NR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_config_restrict_info->max_meas_id_scg_nr, p_src + *p_length_read, "max_meas_id_scg_nr");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_config_restrict_info->max_meas_id_scg_nr < 1) || (p_config_restrict_info->max_meas_id_scg_nr > 62))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_config_restrict_info->max_meas_id_scg_nr] should be in range "
            "1 to 62. Incorrect value %u received.", p_config_restrict_info->max_meas_id_scg_nr);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_cn_association
(
    rrc_rrm_cn_association_t *p_rrc_rrm_cn_association,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cn_association, 0, sizeof(rrc_rrm_cn_association_t));

    /* This function parses rrc_rrm_cn_association */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cn_association->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cn_association->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cn_association->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cn_association->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_rrm_cn_association->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_to_add_mod
(
    drb_to_add_mod_t *p_drb_to_add_mod,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_drb_to_add_mod, 0, sizeof(drb_to_add_mod_t));

    /* This function parses drb_to_add_mod */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_drb_to_add_mod->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_to_add_mod->drb_id, p_src + *p_length_read, "drb_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_to_add_mod->drb_id < 1) || (p_drb_to_add_mod->drb_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_to_add_mod->drb_id] should be in range "
            "1 to 32. Incorrect value %u received.", p_drb_to_add_mod->drb_id);
        return RRC_FAILURE;
    }

    if (p_drb_to_add_mod->bitmask & DRB_TO_ADD_MOD_CN_ASSOCIATION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_cn_association(
        &p_drb_to_add_mod->cn_association,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_drb_to_add_mod->bitmask & DRB_TO_ADD_MOD_PDCP_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_config(
        &p_drb_to_add_mod->pdcp_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_to_add_mod_list
(
    drb_to_add_mod_list_t *p_drb_to_add_mod_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_drb_to_add_mod_list, 0, sizeof(drb_to_add_mod_list_t));

    /* This function parses drb_to_add_mod_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_to_add_mod_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_to_add_mod_list->count < 1) || (p_drb_to_add_mod_list->count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_to_add_mod_list->count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_drb_to_add_mod_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_drb_to_add_mod_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_drb_to_add_mod(
                &p_drb_to_add_mod_list->drb_to_add_mod[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_radio_bearer_config
(
    radio_bearer_config_t *p_radio_bearer_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_radio_bearer_config, 0, sizeof(radio_bearer_config_t));

    /* This function parses radio_bearer_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_radio_bearer_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_radio_bearer_config->bitmask & RADIO_BEARER_CONFIG_DRB_TO_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_drb_to_add_mod_list(
        &p_radio_bearer_config->drb_to_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cg_config_info
(
    cg_config_info_t *p_cg_config_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cg_config_info, 0, sizeof(cg_config_info_t));

    /* This function parses cg_config_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cg_config_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_cg_config_info->bitmask & NR_CG_CONFIG_INFO_MN_CANDID_CELL_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_meas_result_list2_nr(
        &p_cg_config_info->candidate_cell_info_list_mn,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cg_config_info->bitmask & NR_CG_CONFIG_INFO_CONFIG_RESTRICT_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_config_restrict_info(
        &p_cg_config_info->config_restrict_info_scg,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cg_config_info->bitmask & NR_CG_CONFIG_INFO_MCG_RB_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_radio_bearer_config(
        &p_cg_config_info->mcg_rb_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cg_config_info->bitmask & NR_CG_CONFIG_INFO_DRX_INFO_MCG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_drx_config(
        &p_cg_config_info->drx_config_mcg,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_x2ap_plmn_identity
(
    x2ap_plmn_identity_t *p_x2ap_plmn_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_x2ap_plmn_identity, 0, sizeof(x2ap_plmn_identity_t));

    /* This function parses x2ap_plmn_identity */

    if (*p_length_read + (S32)sizeof(p_x2ap_plmn_identity->plmn_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_x2ap_plmn_identity->plmn_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_x2ap_plmn_identity->plmn_id[loop], (void*)(p_src + *p_length_read), "plmn_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_x2_gnb_id
(
    x2_gnb_id_t *p_x2_gnb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_x2_gnb_id, 0, sizeof(x2_gnb_id_t));

    /* This function parses x2_gnb_id */

    if (*p_length_read + (S32)sizeof(p_x2_gnb_id->x2_gnb_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_x2_gnb_id->x2_gnb_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_x2_gnb_id->x2_gnb_id[loop], (void*)(p_src + *p_length_read), "x2_gnb_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_x2_gb_gnb_id
(
    x2_gb_gnb_id_t *p_x2_gb_gnb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_x2_gb_gnb_id, 0, sizeof(x2_gb_gnb_id_t));

    /* This function parses x2_gb_gnb_id */

    if (RRC_FAILURE == rrc_il_parse_x2ap_plmn_identity(
        &p_x2_gb_gnb_id->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_x2_gnb_id(
        &p_x2_gb_gnb_id->x2_en_gnb_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_sgnb_add_param
(
    rrc_rrm_sgnb_add_param_t *p_rrc_rrm_sgnb_add_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_sgnb_add_param, 0, sizeof(rrc_rrm_sgnb_add_param_t));

    /* This function parses rrc_rrm_sgnb_add_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_sgnb_add_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_sgnb_add_param->ue_agg_max_bit_rate_sgnb,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_cg_config_info(
        &p_rrc_rrm_sgnb_add_param->cg_config_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_sgnb_add_param->bitmask & RRC_SGNB_ADD_PARAM_GNB_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_x2_gb_gnb_id(
        &p_rrc_rrm_sgnb_add_param->gnb_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_setup_cnf
(
    rrc_rrm_erb_setup_cnf_t *p_rrc_rrm_erb_setup_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_setup_cnf, 0, sizeof(rrc_rrm_erb_setup_cnf_t));

    /* This function parses rrc_rrm_erb_setup_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_setup_cnf->response_code, p_src + *p_length_read, "response_code");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_setup_cnf->response_code > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_cnf->response_code] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_erb_setup_cnf->response_code);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_ERAB_CNF_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrc_rrm_erb_setup_cnf->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_ERAB_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrc_rrm_erb_setup_cnf->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_ERAB_REL_CNF_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_release_cnf_list(
        &p_rrc_rrm_erb_setup_cnf->erab_rel_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_SPS_ERROR_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_cnf->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_setup_cnf->error_code > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_setup_cnf->error_code] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_erb_setup_cnf->error_code);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_GUMMEI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mme_sel_gummei_info(
        &p_rrc_rrm_erb_setup_cnf->gummei_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_setup_cnf->bitmask & RRC_RRM_ERB_SETUP_CNF_MME_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_setup_cnf->mme_id, p_src + *p_length_read, "mme_id");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_item
(
    rrm_erab_item_t *p_rrm_erab_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_item, 0, sizeof(rrm_erab_item_t));

    /* This function parses rrm_erab_item */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_item->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_item->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_erab_item->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_cnf_list
(
    rrm_erab_cnf_list_t *p_rrm_erab_cnf_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_cnf_list, 0, sizeof(rrm_erab_cnf_list_t));

    /* This function parses rrm_erab_cnf_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_cnf_list->erab_count, p_src + *p_length_read, "erab_count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_cnf_list->erab_count < 1) || (p_rrm_erab_cnf_list->erab_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_cnf_list->erab_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_erab_cnf_list->erab_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_cnf_list->erab_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_item(
                &p_rrm_erab_cnf_list->erab_cnf_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_error_info
(
    rrm_erab_error_info_t *p_rrm_erab_error_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_error_info, 0, sizeof(rrm_erab_error_info_t));

    /* This function parses rrm_erab_error_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_error_info->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_error_info->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_error_info->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_erab_error_info->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_erab_error_info->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U32);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_error_list
(
    rrm_erab_error_list_t *p_rrm_erab_error_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_error_list, 0, sizeof(rrm_erab_error_list_t));

    /* This function parses rrm_erab_error_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_error_list->erab_count, p_src + *p_length_read, "erab_count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_error_list->erab_count < 1) || (p_rrm_erab_error_list->erab_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_error_list->erab_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_erab_error_list->erab_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_error_list->erab_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_info(
                &p_rrm_erab_error_list->erab_error_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_release_cnf_list
(
    rrm_erab_release_cnf_list_t *p_rrm_erab_release_cnf_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_release_cnf_list, 0, sizeof(rrm_erab_release_cnf_list_t));

    /* This function parses rrm_erab_release_cnf_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_release_cnf_list->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_erab_release_cnf_list->bitmask & RRC_RRM_ERB_REL_CNF_ERAB_CNF_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrm_erab_release_cnf_list->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_release_cnf_list->bitmask & RRC_RRM_ERB_REL_CNF_ERAB_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrm_erab_release_cnf_list->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mme_sel_gummei_info
(
    mme_sel_gummei_info_t *p_mme_sel_gummei_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mme_sel_gummei_info, 0, sizeof(mme_sel_gummei_info_t));

    /* This function parses mme_sel_gummei_info */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_mme_sel_gummei_info->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_mme_sel_gummei_info->mme_group_id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_mme_sel_gummei_info->mme_group_id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_mme_sel_gummei_info->mme_group_id[loop], (void*)(p_src + *p_length_read), "mme_group_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mme_sel_gummei_info->mmec, p_src + *p_length_read, "mmec");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erab_reconfig_req
(
    rrc_rrm_erab_reconfig_req_t *p_rrc_rrm_erab_reconfig_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erab_reconfig_req, 0, sizeof(rrc_rrm_erab_reconfig_req_t));

    /* This function parses rrc_rrm_erab_reconfig_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_reconfig_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_reconfig_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erab_reconfig_req->bitmask & RRC_RRM_ERB_RECONFIG_REQ_UE_AMBR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_erab_reconfig_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_reconfigured_item_list(
        &p_rrc_rrm_erab_reconfig_req->erab_to_be_reconfigured_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_erab_reconfig_req->bitmask & RRC_RRM_ERB_RECONFIG_REQ_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_rrc_rrm_erab_reconfig_req->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erab_reconfig_req->bitmask & RRC_RRM_ERB_RECONFIG_REQ_LWA_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_lwa_r13_config(
        &p_rrc_rrm_erab_reconfig_req->lwa_config_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_reconfig_lwa_config
(
    rrm_erab_reconfig_lwa_config_t *p_rrm_erab_reconfig_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_reconfig_lwa_config, 0, sizeof(rrm_erab_reconfig_lwa_config_t));

    /* This function parses rrm_erab_reconfig_lwa_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_reconfig_lwa_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_reconfig_lwa_config->lwa_bearer, p_src + *p_length_read, "lwa_bearer");
    *p_length_read += sizeof(U8);

    if (p_rrm_erab_reconfig_lwa_config->bitmask & RRM_ERB_TO_BE_RECONFIGURED_LWA_CONFIG_LWA_BEARER_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_reconfig_lwa_config->lwa_bearer_type, p_src + *p_length_read, "lwa_bearer_type");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_reconfigured_item
(
    rrm_erab_to_be_reconfigured_item_t *p_rrm_erab_to_be_reconfigured_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_to_be_reconfigured_item, 0, sizeof(rrm_erab_to_be_reconfigured_item_t));

    /* This function parses rrm_erab_to_be_reconfigured_item */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_reconfigured_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_to_be_reconfigured_item->lc_id, p_src + *p_length_read, "lc_id");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_reconfig_lwa_config(
        &p_rrm_erab_to_be_reconfigured_item->lwa_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_to_be_reconfigured_item_list
(
    rrm_erab_to_be_reconfigured_item_list_t *p_rrm_erab_to_be_reconfigured_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_to_be_reconfigured_item_list, 0, sizeof(rrm_erab_to_be_reconfigured_item_list_t));

    /* This function parses rrm_erab_to_be_reconfigured_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_to_be_reconfigured_item_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_to_be_reconfigured_item_list->count < 1) || (p_rrm_erab_to_be_reconfigured_item_list->count > MAX_ERAB_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_to_be_reconfigured_item_list->count] should be in range "
            "1 to MAX_ERAB_COUNT. Incorrect value %u received.", p_rrm_erab_to_be_reconfigured_item_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_to_be_reconfigured_item_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_reconfigured_item(
                &p_rrm_erab_to_be_reconfigured_item_list->erab_to_be_reconfigured[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_identifier_list
(
    wlan_identifier_list_t *p_wlan_identifier_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_identifier_list, 0, sizeof(wlan_identifier_list_t));

    /* This function parses wlan_identifier_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_wlan_identifier_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_identifier_list->count > MAX_WLAN_ID))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_identifier_list->count] should be less than"
            " or equal to MAX_WLAN_ID. Incorrect value %u received.", p_wlan_identifier_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_wlan_identifier_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_wlan_identifier(
                &p_wlan_identifier_list->supported_wlan_id[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_mobility_config
(
    wlan_mobility_config_t *p_wlan_mobility_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_wlan_mobility_config, 0, sizeof(wlan_mobility_config_t));

    /* This function parses wlan_mobility_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_wlan_mobility_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_wlan_mobility_config->bitmask & WLAN_TO_ADD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_identifier_list(
        &p_wlan_mobility_config->wlan_to_add_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_wlan_mobility_config->bitmask & WLAN_TO_RELEASE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_identifier_list(
        &p_wlan_mobility_config->wlan_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_wlan_mobility_config->bitmask & WLAN_ASSOCIATION_TIMER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_wlan_mobility_config->association_timer, p_src + *p_length_read, "association_timer");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_mobility_config->association_timer > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_mobility_config->association_timer] should be less than"
            " or equal to 4. Incorrect value %u received.", p_wlan_mobility_config->association_timer);
        return RRC_FAILURE;
    }
    }

    if (p_wlan_mobility_config->bitmask & WLAN_SUCCESS_REPORT_REQUESTED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_mobility_config->success_report_requested, p_src + *p_length_read, "success_report_requested");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_lwa_config
(
    rrc_lwa_config_t *p_rrc_lwa_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_lwa_config, 0, sizeof(rrc_lwa_config_t));

    /* This function parses rrc_lwa_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_lwa_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_lwa_config->bitmask & RRM_LWA_CONFIG_MOBILITY_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_mobility_config(
        &p_rrc_lwa_config->wlan_mobility_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_lwa_config->bitmask & RRM_LWA_CONFIG_WT_COUNTER_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_lwa_config->lwa_wt_counter, p_src + *p_length_read, "lwa_wt_counter");
    *p_length_read += sizeof(U16);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_lwa_r13_config
(
    rrc_rrm_lwa_r13_config_t *p_rrc_rrm_lwa_r13_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_lwa_r13_config, 0, sizeof(rrc_rrm_lwa_r13_config_t));

    /* This function parses rrc_rrm_lwa_r13_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_lwa_r13_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_lwa_r13_config->bitmask & RRM_LWA_CONFIG_R13_SETUP)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_lwa_config(
        &p_rrc_rrm_lwa_r13_config->lwa_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_reconfig_resp
(
    rrc_rrm_erb_reconfig_resp_t *p_rrc_rrm_erb_reconfig_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_reconfig_resp, 0, sizeof(rrc_rrm_erb_reconfig_resp_t));

    /* This function parses rrc_rrm_erb_reconfig_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_reconfig_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_reconfig_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_reconfig_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_reconfig_resp->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_reconfig_resp->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_erb_reconfig_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_erb_reconfig_resp->bitmask & RRC_RRM_ERB_RECONFIG_RESP_CONFIRM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrc_rrm_erb_reconfig_resp->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_reconfig_resp->bitmask & RRC_RRM_ERB_RECONFIG_RESP_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrc_rrm_erb_reconfig_resp->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erab_modify_req
(
    rrc_rrm_erab_modify_req_t *p_rrc_rrm_erab_modify_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erab_modify_req, 0, sizeof(rrc_rrm_erab_modify_req_t));

    /* This function parses rrc_rrm_erab_modify_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_modify_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_modify_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erab_modify_req->bitmask & RRC_RRM_ERB_MODIFY_REQ_UE_AGG_MAX_BIT_RATE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_erab_modify_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_setup_item_list(
        &p_rrc_rrm_erab_modify_req->erab_to_be_modified_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erab_modify_resp
(
    rrc_rrm_erab_modify_resp_t *p_rrc_rrm_erab_modify_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erab_modify_resp, 0, sizeof(rrc_rrm_erab_modify_resp_t));

    /* This function parses rrc_rrm_erab_modify_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_modify_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_modify_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erab_modify_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erab_modify_resp->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erab_modify_resp->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_erab_modify_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_erab_modify_resp->bitmask & RRM_ERB_MODIFY_RESP_API_ADM_RADIO_RES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_modify_radio_res_config(
        &p_rrc_rrm_erab_modify_resp->radio_rsource_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erab_modify_resp->bitmask & RRM_ERB_MODIFY_RESP_API_UE_INACTIVE_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_erab_modify_resp->ue_inactive_time_config, p_src + *p_length_read, "ue_inactive_time_config");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rrm_erab_modify_resp->bitmask & RRM_ERB_MODIFY_RESP_API_ERAB_TO_BE_RELEASED_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_released_item_list(
        &p_rrc_rrm_erab_modify_resp->erab_to_be_released_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_modify_radio_res_config
(
    rrm_erab_modify_radio_res_config_t *p_rrm_erab_modify_radio_res_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_modify_radio_res_config, 0, sizeof(rrm_erab_modify_radio_res_config_t));

    /* This function parses rrm_erab_modify_radio_res_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_modify_radio_res_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_DRB_TO_MODIFY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_to_add_info_list(
        &p_rrm_erab_modify_radio_res_config->drb_to_modify_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_MAC_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_config(
        &p_rrm_erab_modify_radio_res_config->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_rrm_erab_modify_radio_res_config->sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_SETUP_RADIO_RES_CONFIG_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_rrm_erab_modify_radio_res_config->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_DRB_FAILED_TO_MODIFY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_failed_to_add_info_list(
        &p_rrm_erab_modify_radio_res_config->drb_failed_to_modify_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_RLF_TIMERS_AND_CONSTANTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rlf_timers_and_constants_r9(
        &p_rrm_erab_modify_radio_res_config->rlf_timers_and_constants_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_erab_modify_radio_res_config->bitmask & RRM_ERAB_MODIFY_RADIO_RES_CONFIG_PROXIMITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_report_proximity_config_r9(
        &p_rrm_erab_modify_radio_res_config->proximity_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_modify_cnf
(
    rrc_rrm_erb_modify_cnf_t *p_rrc_rrm_erb_modify_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_modify_cnf, 0, sizeof(rrc_rrm_erb_modify_cnf_t));

    /* This function parses rrc_rrm_erb_modify_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_modify_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_modify_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_modify_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_modify_cnf->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_modify_cnf->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_erb_modify_cnf->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_erb_modify_cnf->bitmask & RRM_ERB_MODIFY_CNF_CONFIRM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrc_rrm_erb_modify_cnf->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_modify_cnf->bitmask & RRM_ERB_MODIFY_CNF_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrc_rrm_erb_modify_cnf->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_modify_cnf->bitmask & RRC_RRM_ERB_MODIFY_CNF_SPS_ERROR_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_modify_cnf->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_modify_cnf->error_code > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_modify_cnf->error_code] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_erb_modify_cnf->error_code);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_connection_release_ind
(
    rrc_rrm_ue_connection_release_ind_t *p_rrc_rrm_ue_connection_release_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_connection_release_ind, 0, sizeof(rrc_rrm_ue_connection_release_ind_t));

    /* This function parses rrc_rrm_ue_connection_release_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_connection_release_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_connection_release_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ue_connection_release_ind->release_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_ue_connection_release_ind->bitmask & RRC_RRM_UE_CONNECTION_RELEASE_IND_REDIRECTED_CARRIER_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_redirected_carrier_info(
        &p_rrc_rrm_ue_connection_release_ind->redirected_carrier_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_connection_release_ind->bitmask & RRC_RRM_UE_CONNECTION_RELEASE_IND_IDLE_MODE_MOBILITY_CONTROL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_idle_mode_mobility_control_info(
        &p_rrc_rrm_ue_connection_release_ind->idle_mode_mobility_control,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_connection_release_ind->bitmask & RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V890_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_rrc_connection_release_v890_ies(
        &p_rrc_rrm_ue_connection_release_ind->rrc_connection_release_v890_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_redirected_carrier_info_utra_tdd_r10
(
    redirected_carrier_info_utra_tdd_r10_t *p_redirected_carrier_info_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_redirected_carrier_info_utra_tdd_r10, 0, sizeof(redirected_carrier_info_utra_tdd_r10_t));

    /* This function parses redirected_carrier_info_utra_tdd_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_redirected_carrier_info_utra_tdd_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_redirected_carrier_info_utra_tdd_r10->count < 1) || (p_redirected_carrier_info_utra_tdd_r10->count > MAX_FREQ_UTRA_TDD_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_redirected_carrier_info_utra_tdd_r10->count] should be in range "
            "1 to MAX_FREQ_UTRA_TDD_R10. Incorrect value %u received.", p_redirected_carrier_info_utra_tdd_r10->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_redirected_carrier_info_utra_tdd_r10->count * sizeof(p_redirected_carrier_info_utra_tdd_r10->utra_tdd_r10[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_redirected_carrier_info_utra_tdd_r10->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_redirected_carrier_info_utra_tdd_r10->utra_tdd_r10[loop], (void*)(p_src + *p_length_read), "utra_tdd_r10[]");
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_redirected_carrier_info
(
    rrm_redirected_carrier_info_t *p_rrm_redirected_carrier_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_redirected_carrier_info, 0, sizeof(rrm_redirected_carrier_info_t));

    /* This function parses rrm_redirected_carrier_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_redirected_carrier_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_EUTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_redirected_carrier_info->eutra, p_src + *p_length_read, "eutra");
    *p_length_read += sizeof(U32);
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freqs_geran(
        &p_rrm_redirected_carrier_info->geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_UTRA_FDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_redirected_carrier_info->utra_fdd, p_src + *p_length_read, "utra_fdd");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_redirected_carrier_info->utra_fdd > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_redirected_carrier_info->utra_fdd] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_rrm_redirected_carrier_info->utra_fdd);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_redirected_carrier_info->utra_tdd, p_src + *p_length_read, "utra_tdd");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_redirected_carrier_info->utra_tdd > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_redirected_carrier_info->utra_tdd] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_rrm_redirected_carrier_info->utra_tdd);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_CDMA2000_HRPD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_rrm_redirected_carrier_info->cdma2000_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_CDMA2000_1XRTT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_rrm_redirected_carrier_info->cdma2000_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_redirected_carrier_info->bitmask & RRM_REDIRECTED_CARRIER_INFO_UTRA_TDD_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_redirected_carrier_info_utra_tdd_r10(
        &p_rrm_redirected_carrier_info->redirected_carrier_info_utra_tdd_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_eutra
(
    rrm_freq_priority_eutra_t *p_rrm_freq_priority_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_eutra, 0, sizeof(rrm_freq_priority_eutra_t));

    /* This function parses rrm_freq_priority_eutra */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_freq_priority_eutra->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_eutra->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freq_priority_eutra->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_eutra->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_freq_priority_eutra->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_eutra
(
    rrm_freq_priority_list_eutra_t *p_rrm_freq_priority_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_list_eutra, 0, sizeof(rrm_freq_priority_list_eutra_t));

    /* This function parses rrm_freq_priority_list_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_list_eutra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_freq_priority_list_eutra->count < 1) || (p_rrm_freq_priority_list_eutra->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_list_eutra->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_rrm_freq_priority_list_eutra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_freq_priority_list_eutra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_eutra(
                &p_rrm_freq_priority_list_eutra->freq_priority_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freqs_priority_geran
(
    rrm_freqs_priority_geran_t *p_rrm_freqs_priority_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_freqs_priority_geran, 0, sizeof(rrm_freqs_priority_geran_t));

    /* This function parses rrm_freqs_priority_geran */

    if (RRC_FAILURE == rrc_il_parse_carrier_freqs_geran(
        &p_rrm_freqs_priority_geran->carrier_freq,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freqs_priority_geran->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freqs_priority_geran->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freqs_priority_geran->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_freqs_priority_geran->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freqs_priority_list_geran
(
    rrm_freqs_priority_list_geran_t *p_rrm_freqs_priority_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_freqs_priority_list_geran, 0, sizeof(rrm_freqs_priority_list_geran_t));

    /* This function parses rrm_freqs_priority_list_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freqs_priority_list_geran->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_freqs_priority_list_geran->count < 1) || (p_rrm_freqs_priority_list_geran->count > MAX_GNFG))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freqs_priority_list_geran->count] should be in range "
            "1 to MAX_GNFG. Incorrect value %u received.", p_rrm_freqs_priority_list_geran->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_freqs_priority_list_geran->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_freqs_priority_geran(
                &p_rrm_freqs_priority_list_geran->freqs_priority_geran[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_utra_fdd
(
    rrm_freq_priority_utra_fdd_t *p_rrm_freq_priority_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_utra_fdd, 0, sizeof(rrm_freq_priority_utra_fdd_t));

    /* This function parses rrm_freq_priority_utra_fdd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_freq_priority_utra_fdd->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freq_priority_utra_fdd->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_utra_fdd->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_rrm_freq_priority_utra_fdd->carrier_freq);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_utra_fdd->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freq_priority_utra_fdd->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_utra_fdd->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_freq_priority_utra_fdd->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_utra_fdd
(
    rrm_freq_priority_list_utra_fdd_t *p_rrm_freq_priority_list_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_list_utra_fdd, 0, sizeof(rrm_freq_priority_list_utra_fdd_t));

    /* This function parses rrm_freq_priority_list_utra_fdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_list_utra_fdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_freq_priority_list_utra_fdd->count < 1) || (p_rrm_freq_priority_list_utra_fdd->count > MAX_UTRA_FDD_CARRIER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_list_utra_fdd->count] should be in range "
            "1 to MAX_UTRA_FDD_CARRIER. Incorrect value %u received.", p_rrm_freq_priority_list_utra_fdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_freq_priority_list_utra_fdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_utra_fdd(
                &p_rrm_freq_priority_list_utra_fdd->freq_priority_utra_fdd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_utra_tdd
(
    rrm_freq_priority_utra_tdd_t *p_rrm_freq_priority_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_utra_tdd, 0, sizeof(rrm_freq_priority_utra_tdd_t));

    /* This function parses rrm_freq_priority_utra_tdd */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_freq_priority_utra_tdd->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freq_priority_utra_tdd->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_utra_tdd->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_rrm_freq_priority_utra_tdd->carrier_freq);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_utra_tdd->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_freq_priority_utra_tdd->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_utra_tdd->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_freq_priority_utra_tdd->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_freq_priority_list_utra_tdd
(
    rrm_freq_priority_list_utra_tdd_t *p_rrm_freq_priority_list_utra_tdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_freq_priority_list_utra_tdd, 0, sizeof(rrm_freq_priority_list_utra_tdd_t));

    /* This function parses rrm_freq_priority_list_utra_tdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_freq_priority_list_utra_tdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_freq_priority_list_utra_tdd->count < 1) || (p_rrm_freq_priority_list_utra_tdd->count > MAX_UTRA_TDD_CARRIER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_freq_priority_list_utra_tdd->count] should be in range "
            "1 to MAX_UTRA_TDD_CARRIER. Incorrect value %u received.", p_rrm_freq_priority_list_utra_tdd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_freq_priority_list_utra_tdd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_utra_tdd(
                &p_rrm_freq_priority_list_utra_tdd->freq_priority_utra_tdd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_hrpd
(
    rrm_band_class_priority_hrpd_t *p_rrm_band_class_priority_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_band_class_priority_hrpd, 0, sizeof(rrm_band_class_priority_hrpd_t));

    /* This function parses rrm_band_class_priority_hrpd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_hrpd->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_band_class_priority_hrpd->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_hrpd->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_rrm_band_class_priority_hrpd->band_class);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_hrpd->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_band_class_priority_hrpd->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_hrpd->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_band_class_priority_hrpd->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_list_hrpd
(
    rrm_band_class_priority_list_hrpd_t *p_rrm_band_class_priority_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_band_class_priority_list_hrpd, 0, sizeof(rrm_band_class_priority_list_hrpd_t));

    /* This function parses rrm_band_class_priority_list_hrpd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_list_hrpd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_band_class_priority_list_hrpd->count < 1) || (p_rrm_band_class_priority_list_hrpd->count > MAX_CDMA_BAND_CLASS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_list_hrpd->count] should be in range "
            "1 to MAX_CDMA_BAND_CLASS. Incorrect value %u received.", p_rrm_band_class_priority_list_hrpd->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_band_class_priority_list_hrpd->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_band_class_priority_hrpd(
                &p_rrm_band_class_priority_list_hrpd->band_class_priority[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_1xrtt
(
    rrm_band_class_priority_1xrtt_t *p_rrm_band_class_priority_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_band_class_priority_1xrtt, 0, sizeof(rrm_band_class_priority_1xrtt_t));

    /* This function parses rrm_band_class_priority_1xrtt */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_1xrtt->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_band_class_priority_1xrtt->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_1xrtt->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_rrm_band_class_priority_1xrtt->band_class);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_1xrtt->cell_reselection_priority, p_src + *p_length_read, "cell_reselection_priority");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_band_class_priority_1xrtt->cell_reselection_priority > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_1xrtt->cell_reselection_priority] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_band_class_priority_1xrtt->cell_reselection_priority);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_band_class_priority_list_1xrtt
(
    rrm_band_class_priority_list_1xrtt_t *p_rrm_band_class_priority_list_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_band_class_priority_list_1xrtt, 0, sizeof(rrm_band_class_priority_list_1xrtt_t));

    /* This function parses rrm_band_class_priority_list_1xrtt */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_band_class_priority_list_1xrtt->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_band_class_priority_list_1xrtt->count < 1) || (p_rrm_band_class_priority_list_1xrtt->count > MAX_CDMA_BAND_CLASS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_band_class_priority_list_1xrtt->count] should be in range "
            "1 to MAX_CDMA_BAND_CLASS. Incorrect value %u received.", p_rrm_band_class_priority_list_1xrtt->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_band_class_priority_list_1xrtt->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_band_class_priority_1xrtt(
                &p_rrm_band_class_priority_list_1xrtt->band_class_priority[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_idle_mode_mobility_control_info
(
    rrm_idle_mode_mobility_control_info_t *p_rrm_idle_mode_mobility_control_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_idle_mode_mobility_control_info, 0, sizeof(rrm_idle_mode_mobility_control_info_t));

    /* This function parses rrm_idle_mode_mobility_control_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_idle_mode_mobility_control_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_list_eutra(
        &p_rrm_idle_mode_mobility_control_info->freq_priority_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_freqs_priority_list_geran(
        &p_rrm_idle_mode_mobility_control_info->freq_priority_list_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_UTRA_FDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_list_utra_fdd(
        &p_rrm_idle_mode_mobility_control_info->freq_priority_list_utra_fdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_FREQ_PRIORITY_LIST_UTRA_TDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_freq_priority_list_utra_tdd(
        &p_rrm_idle_mode_mobility_control_info->freq_priority_list_utra_tdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_HRPD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_band_class_priority_list_hrpd(
        &p_rrm_idle_mode_mobility_control_info->band_class_priority_list_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_BAND_CLASS_PRIORITY_LIST_1XRTT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_band_class_priority_list_1xrtt(
        &p_rrm_idle_mode_mobility_control_info->band_class_priority_list_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_idle_mode_mobility_control_info->bitmask & RRM_IDLE_MODE_MOBILITY_CONTROL_INFO_T320_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_idle_mode_mobility_control_info->t320, p_src + *p_length_read, "t320");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_idle_mode_mobility_control_info->t320 > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_idle_mode_mobility_control_info->t320] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrm_idle_mode_mobility_control_info->t320);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_carrier_freq_geran
(
    carrier_freq_geran_t *p_carrier_freq_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_carrier_freq_geran, 0, sizeof(carrier_freq_geran_t));

    /* This function parses carrier_freq_geran */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_carrier_freq_geran->arfcn, p_src + *p_length_read, "arfcn");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_geran->arfcn > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_geran->arfcn] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_carrier_freq_geran->arfcn);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_carrier_freq_geran->band_indicator, p_src + *p_length_read, "band_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_carrier_freq_geran->band_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_carrier_freq_geran->band_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_carrier_freq_geran->band_indicator);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sys_info_container_encoded_si_info
(
    sys_info_container_encoded_si_info_t *p_sys_info_container_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sys_info_container_encoded_si_info, 0, sizeof(sys_info_container_encoded_si_info_t));

    /* This function parses sys_info_container_encoded_si_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sys_info_container_encoded_si_info->length, p_src + *p_length_read, "length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_sys_info_container_encoded_si_info->length < 1) || (p_sys_info_container_encoded_si_info->length > GERAN_SI_DATA_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_sys_info_container_encoded_si_info->length] should be in range "
            "1 to GERAN_SI_DATA_SIZE. Incorrect value %u received.", p_sys_info_container_encoded_si_info->length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_sys_info_container_encoded_si_info->length * sizeof(p_sys_info_container_encoded_si_info->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_sys_info_container_encoded_si_info->length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_sys_info_container_encoded_si_info->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_sys_info_container_expanded_si_info
(
    sys_info_container_expanded_si_info_t *p_sys_info_container_expanded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_sys_info_container_expanded_si_info, 0, sizeof(sys_info_container_expanded_si_info_t));

    /* This function parses sys_info_container_expanded_si_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_sys_info_container_expanded_si_info->dummy, p_src + *p_length_read, "dummy");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_system_info_list_geran_element
(
    system_info_list_geran_element_t *p_system_info_list_geran_element,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_system_info_list_geran_element, 0, sizeof(system_info_list_geran_element_t));

    /* This function parses system_info_list_geran_element */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_system_info_list_geran_element->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_system_info_list_geran_element->bitmask & RRC_RRM_SYS_INFO_CONTAINER_ENCODED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_sys_info_container_encoded_si_info(
        &p_system_info_list_geran_element->sys_info_container_encoded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_system_info_list_geran_element->bitmask & RRC_RRM_SYS_INFO_CONTAINTER_EXPANDED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_sys_info_container_expanded_si_info(
        &p_system_info_list_geran_element->sys_info_container_expanded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_system_info_list_geran
(
    system_info_list_geran_t *p_system_info_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_system_info_list_geran, 0, sizeof(system_info_list_geran_t));

    /* This function parses system_info_list_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_system_info_list_geran->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_system_info_list_geran->count < 1) || (p_system_info_list_geran->count > MAX_GERAN_SI))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_system_info_list_geran->count] should be in range "
            "1 to MAX_GERAN_SI. Incorrect value %u received.", p_system_info_list_geran->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_system_info_list_geran->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_system_info_list_geran_element(
                &p_system_info_list_geran->system_info_geran_elem[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_geran_r9
(
    cell_info_geran_r9_t *p_cell_info_geran_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_geran_r9, 0, sizeof(cell_info_geran_r9_t));

    /* This function parses cell_info_geran_r9 */

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_geran(
        &p_cell_info_geran_r9->phys_cell_id_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_geran(
        &p_cell_info_geran_r9->carrier_freq_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_system_info_list_geran(
        &p_cell_info_geran_r9->system_information_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_list_geran_r9
(
    cell_info_list_geran_r9_t *p_cell_info_list_geran_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_list_geran_r9, 0, sizeof(cell_info_list_geran_r9_t));

    /* This function parses cell_info_list_geran_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_list_geran_r9->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_info_list_geran_r9->count < 1) || (p_cell_info_list_geran_r9->count > MAX_CELL_INFO_GERAN_R9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_list_geran_r9->count] should be in range "
            "1 to MAX_CELL_INFO_GERAN_R9. Incorrect value %u received.", p_cell_info_list_geran_r9->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cell_info_list_geran_r9->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cell_info_geran_r9(
                &p_cell_info_list_geran_r9->cell_info_geran_r9[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r9_encoded_si_info
(
    utra_bcch_container_r9_encoded_si_info_t *p_utra_bcch_container_r9_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_bcch_container_r9_encoded_si_info, 0, sizeof(utra_bcch_container_r9_encoded_si_info_t));

    /* This function parses utra_bcch_container_r9_encoded_si_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length, p_src + *p_length_read, "utra_bcch_container_length");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length > UTRA_BCCH_CONAINER_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length] should be less than"
            " or equal to UTRA_BCCH_CONAINER_SIZE. Incorrect value %u received.", p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length * sizeof(p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container_length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_bcch_container_r9_encoded_si_info->utra_bcch_container[loop], (void*)(p_src + *p_length_read), "utra_bcch_container[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r9_expanded_si_info
(
    utra_bcch_container_r9_expanded_si_info_t *p_utra_bcch_container_r9_expanded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_bcch_container_r9_expanded_si_info, 0, sizeof(utra_bcch_container_r9_expanded_si_info_t));

    /* This function parses utra_bcch_container_r9_expanded_si_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_bcch_container_r9_expanded_si_info->dummy, p_src + *p_length_read, "dummy");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_utra_fdd_r9
(
    cell_info_utra_fdd_r9_t *p_cell_info_utra_fdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_utra_fdd_r9, 0, sizeof(cell_info_utra_fdd_r9_t));

    /* This function parses cell_info_utra_fdd_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_utra_fdd_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_utra_fdd_r9->phys_cell_id_r9, p_src + *p_length_read, "phys_cell_id_r9");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_info_utra_fdd_r9->phys_cell_id_r9 > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_utra_fdd_r9->phys_cell_id_r9] should be less than"
            " or equal to 511. Incorrect value %u received.", p_cell_info_utra_fdd_r9->phys_cell_id_r9);
        return RRC_FAILURE;
    }

    if (p_cell_info_utra_fdd_r9->bitmask & RRC_RRM_UTRA_FDD_BCCH_CONTAINER_ENCODED_SI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_bcch_container_r9_encoded_si_info(
        &p_cell_info_utra_fdd_r9->utra_fdd_bcch_cont_r9_encoded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cell_info_utra_fdd_r9->bitmask & RRC_RRM_UTRA_FDD_BCCH_CONTAINTER_EXPANDED_SI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_bcch_container_r9_expanded_si_info(
        &p_cell_info_utra_fdd_r9->utra_fdd_bcch_cont_expanded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_fdd_r9
(
    cell_info_list_utra_fdd_r9_t *p_cell_info_list_utra_fdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_list_utra_fdd_r9, 0, sizeof(cell_info_list_utra_fdd_r9_t));

    /* This function parses cell_info_list_utra_fdd_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_list_utra_fdd_r9->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_info_list_utra_fdd_r9->count < 1) || (p_cell_info_list_utra_fdd_r9->count > MAX_CELL_INFO_UTRA_R9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_list_utra_fdd_r9->count] should be in range "
            "1 to MAX_CELL_INFO_UTRA_R9. Incorrect value %u received.", p_cell_info_list_utra_fdd_r9->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cell_info_list_utra_fdd_r9->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cell_info_utra_fdd_r9(
                &p_cell_info_list_utra_fdd_r9->cell_info_utra_fdd_r9[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_utra_tdd_r9
(
    cell_info_utra_tdd_r9_t *p_cell_info_utra_tdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_utra_tdd_r9, 0, sizeof(cell_info_utra_tdd_r9_t));

    /* This function parses cell_info_utra_tdd_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_utra_tdd_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_utra_tdd_r9->phys_cell_id_r9, p_src + *p_length_read, "phys_cell_id_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_info_utra_tdd_r9->phys_cell_id_r9 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_utra_tdd_r9->phys_cell_id_r9] should be less than"
            " or equal to 127. Incorrect value %u received.", p_cell_info_utra_tdd_r9->phys_cell_id_r9);
        return RRC_FAILURE;
    }

    if (p_cell_info_utra_tdd_r9->bitmask & RRC_RRM_UTRA_TDD_BCCH_CONTAINER_ENCODED_SI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_bcch_container_r9_encoded_si_info(
        &p_cell_info_utra_tdd_r9->utra_tdd_bcch_cont_r9_encoded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cell_info_utra_tdd_r9->bitmask & RRC_RRM_UTRA_TDD_BCCH_CONTAINTER_EXPANDED_SI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_bcch_container_r9_expanded_si_info(
        &p_cell_info_utra_tdd_r9->utra_tdd_bcch_cont_expanded_si_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_tdd_r9
(
    cell_info_list_utra_tdd_r9_t *p_cell_info_list_utra_tdd_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_list_utra_tdd_r9, 0, sizeof(cell_info_list_utra_tdd_r9_t));

    /* This function parses cell_info_list_utra_tdd_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_list_utra_tdd_r9->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_info_list_utra_tdd_r9->count < 1) || (p_cell_info_list_utra_tdd_r9->count > MAX_CELL_INFO_UTRA_R9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_list_utra_tdd_r9->count] should be in range "
            "1 to MAX_CELL_INFO_UTRA_R9. Incorrect value %u received.", p_cell_info_list_utra_tdd_r9->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cell_info_list_utra_tdd_r9->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cell_info_utra_tdd_r9(
                &p_cell_info_list_utra_tdd_r9->cell_info_utra_tdd_r9[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_bcch_container_r10_encoded_si_info
(
    utra_bcch_container_r10_encoded_si_info_t *p_utra_bcch_container_r10_encoded_si_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_bcch_container_r10_encoded_si_info, 0, sizeof(utra_bcch_container_r10_encoded_si_info_t));

    /* This function parses utra_bcch_container_r10_encoded_si_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length, p_src + *p_length_read, "utra_bcch_container_length");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length > UTRA_BCCH_CONAINER_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length] should be less than"
            " or equal to UTRA_BCCH_CONAINER_SIZE. Incorrect value %u received.", p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length * sizeof(p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container_length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_bcch_container_r10_encoded_si_info->utra_bcch_container[loop], (void*)(p_src + *p_length_read), "utra_bcch_container[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_utra_tdd_r10
(
    cell_info_utra_tdd_r10_t *p_cell_info_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_utra_tdd_r10, 0, sizeof(cell_info_utra_tdd_r10_t));

    /* This function parses cell_info_utra_tdd_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_utra_tdd_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_utra_tdd_r10->phys_cell_id_r10, p_src + *p_length_read, "phys_cell_id_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_info_utra_tdd_r10->phys_cell_id_r10 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_utra_tdd_r10->phys_cell_id_r10] should be less than"
            " or equal to 127. Incorrect value %u received.", p_cell_info_utra_tdd_r10->phys_cell_id_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_utra_tdd_r10->carrier_freq_r10, p_src + *p_length_read, "carrier_freq_r10");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_cell_info_utra_tdd_r10->carrier_freq_r10 > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_utra_tdd_r10->carrier_freq_r10] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_cell_info_utra_tdd_r10->carrier_freq_r10);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_utra_bcch_container_r10_encoded_si_info(
        &p_cell_info_utra_tdd_r10->utra_BCCH_Container_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_list_utra_tdd_r10
(
    cell_info_list_utra_tdd_r10_t *p_cell_info_list_utra_tdd_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_list_utra_tdd_r10, 0, sizeof(cell_info_list_utra_tdd_r10_t));

    /* This function parses cell_info_list_utra_tdd_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cell_info_list_utra_tdd_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cell_info_list_utra_tdd_r10->count < 1) || (p_cell_info_list_utra_tdd_r10->count > MAX_CELL_INFO_UTRA_R9))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cell_info_list_utra_tdd_r10->count] should be in range "
            "1 to MAX_CELL_INFO_UTRA_R9. Incorrect value %u received.", p_cell_info_list_utra_tdd_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cell_info_list_utra_tdd_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cell_info_utra_tdd_r10(
                &p_cell_info_list_utra_tdd_r10->cell_info_utra_tdd_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_info_list_r9
(
    cell_info_list_r9_t *p_cell_info_list_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_info_list_r9, 0, sizeof(cell_info_list_r9_t));

    /* This function parses cell_info_list_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_info_list_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_cell_info_list_r9->bitmask & RRC_RRM_CELL_INFO_LIST_GERAN_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_info_list_geran_r9(
        &p_cell_info_list_r9->geran_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cell_info_list_r9->bitmask & RRC_RRM_CELL_INFO_LIST_UTRA_FDD_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_info_list_utra_fdd_r9(
        &p_cell_info_list_r9->utra_fdd_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cell_info_list_r9->bitmask & RRC_RRM_CELL_INFO_LIST_UTRA_TDD_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_info_list_utra_tdd_r9(
        &p_cell_info_list_r9->utra_tdd_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_cell_info_list_r9->bitmask & RRC_RRM_CELL_INFO_LIST_UTRA_TDD_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_info_list_utra_tdd_r10(
        &p_cell_info_list_r9->utra_tdd_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v1020_ies
(
    rrm_rrc_connection_release_v1020_ies_t *p_rrm_rrc_connection_release_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_connection_release_v1020_ies, 0, sizeof(rrm_rrc_connection_release_v1020_ies_t));

    /* This function parses rrm_rrc_connection_release_v1020_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_connection_release_v1020_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_rrc_connection_release_v1020_ies->bitmask & RRC_RRM_EXTENDED_WAIT_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_connection_release_v1020_ies->extended_wait_time_r10, p_src + *p_length_read, "extended_wait_time_r10");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_rrc_connection_release_v1020_ies->extended_wait_time_r10 < 1) || (p_rrm_rrc_connection_release_v1020_ies->extended_wait_time_r10 > 1800))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_rrc_connection_release_v1020_ies->extended_wait_time_r10] should be in range "
            "1 to 1800. Incorrect value %u received.", p_rrm_rrc_connection_release_v1020_ies->extended_wait_time_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v920_ies
(
    rrm_rrc_connection_release_v920_ies_t *p_rrm_rrc_connection_release_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_connection_release_v920_ies, 0, sizeof(rrm_rrc_connection_release_v920_ies_t));

    /* This function parses rrm_rrc_connection_release_v920_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_connection_release_v920_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_rrc_connection_release_v920_ies->bitmask & RRC_RRM_CELL_INFO_LIST_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_info_list_r9(
        &p_rrm_rrc_connection_release_v920_ies->cell_info_list_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_rrc_connection_release_v920_ies->bitmask & RRC_RRM_CONNECTION_RELEASE_V1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_rrc_connection_release_v1020_ies(
        &p_rrm_rrc_connection_release_v920_ies->rrc_connection_release_v1020_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rrc_connection_release_v890_ies
(
    rrm_rrc_connection_release_v890_ies_t *p_rrm_rrc_connection_release_v890_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_connection_release_v890_ies, 0, sizeof(rrm_rrc_connection_release_v890_ies_t));

    /* This function parses rrm_rrc_connection_release_v890_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_connection_release_v890_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_rrc_connection_release_v890_ies->bitmask & RRC_RRM_UE_CONNECTION_RELEASE_IND_RRC_CONN_REL_V920_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_rrc_connection_release_v920_ies(
        &p_rrm_rrc_connection_release_v890_ies->rrc_connection_release_v920_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_measurment_results_ind
(
    rrc_rrm_measurment_results_ind_t *p_rrc_rrm_measurment_results_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_measurment_results_ind, 0, sizeof(rrc_rrm_measurment_results_ind_t));

    /* This function parses rrc_rrm_measurment_results_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_measurment_results_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_measurment_results_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_measurment_results_ind->meas_id, p_src + *p_length_read, "meas_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_measurment_results_ind->meas_id > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_measurment_results_ind->meas_id] should be less than"
            " or equal to 32. Incorrect value %u received.", p_rrc_rrm_measurment_results_ind->meas_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_serv_cell(
        &p_rrc_rrm_measurment_results_ind->meas_result_serv_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_measurment_results_ind->bitmask & RRM_MEASURMENT_RESULTS_NEIGH_CELLS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_neigh_cells(
        &p_rrc_rrm_measurment_results_ind->meas_result_neigh_cells,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_measurment_results_ind->bitmask & RRM_MEASURMENT_RESULTS_FOR_ECID_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_ecid_r9(
        &p_rrc_rrm_measurment_results_ind->meas_result_ecid_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_measurment_results_ind->bitmask & RRM_MEASURMENT_RESULTS_SERV_FREQ_LIST_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_serv_freq_list_r10(
        &p_rrc_rrm_measurment_results_ind->meas_result_serv_freq_list_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_measurment_results_ind->bitmask & RRM_MEASURMENT_RESULTS_WLAN_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_wlan_list_r13(
        &p_rrc_rrm_measurment_results_ind->meas_result_wlan_list_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_cell
(
    rrc_meas_result_serv_cell_t *p_rrc_meas_result_serv_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_serv_cell, 0, sizeof(rrc_meas_result_serv_cell_t));

    /* This function parses rrc_meas_result_serv_cell */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_serv_cell->rsrp_result, p_src + *p_length_read, "rsrp_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_serv_cell->rsrp_result > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_serv_cell->rsrp_result] should be less than"
            " or equal to 97. Incorrect value %u received.", p_rrc_meas_result_serv_cell->rsrp_result);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_serv_cell->rsrq_result, p_src + *p_length_read, "rsrq_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_serv_cell->rsrq_result > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_serv_cell->rsrq_result] should be less than"
            " or equal to 34. Incorrect value %u received.", p_rrc_meas_result_serv_cell->rsrq_result);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_global_id_eutra
(
    cell_global_id_eutra_t *p_cell_global_id_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_global_id_eutra, 0, sizeof(cell_global_id_eutra_t));

    /* This function parses cell_global_id_eutra */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_cell_global_id_eutra->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_cell_global_id_eutra->cell_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_eutra->cell_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_eutra->cell_identity[loop], (void*)(p_src + *p_length_read), "cell_identity[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_plmn_identity_list2
(
    plmn_identity_list2_t *p_plmn_identity_list2,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_plmn_identity_list2, 0, sizeof(plmn_identity_list2_t));

    /* This function parses plmn_identity_list2 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_plmn_identity_list2->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_plmn_identity_list2->count > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_plmn_identity_list2->count] should be less than"
            " or equal to 5. Incorrect value %u received.", p_plmn_identity_list2->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_plmn_identity_list2->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_plmn_identity(
                &p_plmn_identity_list2->cell_identity[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_eutra_cgi_info
(
    meas_result_eutra_cgi_info_t *p_meas_result_eutra_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_eutra_cgi_info, 0, sizeof(meas_result_eutra_cgi_info_t));

    /* This function parses meas_result_eutra_cgi_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_eutra_cgi_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_eutra(
        &p_meas_result_eutra_cgi_info->cell_global_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_meas_result_eutra_cgi_info->tracking_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_meas_result_eutra_cgi_info->tracking_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_meas_result_eutra_cgi_info->tracking_area_code[loop], (void*)(p_src + *p_length_read), "tracking_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (p_meas_result_eutra_cgi_info->bitmask & MEAS_RESULT_EUTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_plmn_identity_list2(
        &p_meas_result_eutra_cgi_info->plmn_identity_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_eutra_meas_result
(
    meas_result_eutra_meas_result_t *p_meas_result_eutra_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_eutra_meas_result, 0, sizeof(meas_result_eutra_meas_result_t));

    /* This function parses meas_result_eutra_meas_result */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_eutra_meas_result->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_result_eutra_meas_result->bitmask & MEAS_RESULT_EUTRA_MEAS_RESULT_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_eutra_meas_result->rsrp_result, p_src + *p_length_read, "rsrp_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_eutra_meas_result->rsrp_result > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_eutra_meas_result->rsrp_result] should be less than"
            " or equal to 97. Incorrect value %u received.", p_meas_result_eutra_meas_result->rsrp_result);
        return RRC_FAILURE;
    }
    }

    if (p_meas_result_eutra_meas_result->bitmask & MEAS_RESULT_EUTRA_MEAS_RESULT_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_eutra_meas_result->rsrq_result, p_src + *p_length_read, "rsrq_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_eutra_meas_result->rsrq_result > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_eutra_meas_result->rsrq_result] should be less than"
            " or equal to 34. Incorrect value %u received.", p_meas_result_eutra_meas_result->rsrq_result);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_csg_info
(
    meas_result_csg_info_t *p_meas_result_csg_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_csg_info, 0, sizeof(meas_result_csg_info_t));

    /* This function parses meas_result_csg_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_csg_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_result_csg_info->bitmask & MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_MEM_STATUS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_csg_info->csg_membershipStatus, p_src + *p_length_read, "csg_membershipStatus");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_csg_info->csg_membershipStatus > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_csg_info->csg_membershipStatus] should be less than"
            " or equal to 0. Incorrect value %u received.", p_meas_result_csg_info->csg_membershipStatus);
        return RRC_FAILURE;
    }
    }

    if (p_meas_result_csg_info->bitmask & MEAS_RESULT_EUTRA_MEAS_RESULT_CSG_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_meas_result_csg_info->csg_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_meas_result_csg_info->csg_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_meas_result_csg_info->csg_identity[loop], (void*)(p_src + *p_length_read), "csg_identity[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_eutra
(
    meas_result_eutra_t *p_meas_result_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_eutra, 0, sizeof(meas_result_eutra_t));

    /* This function parses meas_result_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_eutra->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_eutra->phys_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_eutra->phys_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_meas_result_eutra->phys_cell_id);
        return RRC_FAILURE;
    }

    if (p_meas_result_eutra->bitmask & MEAS_RESULT_EUTRA_CGI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_eutra_cgi_info(
        &p_meas_result_eutra->cgi_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_eutra_meas_result(
        &p_meas_result_eutra->meas_result,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_eutra->bitmask & MEAS_RESULT_EUTRA_CSG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_csg_info(
        &p_meas_result_eutra->eutra_csg_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list_eutra
(
    meas_result_list_eutra_t *p_meas_result_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list_eutra, 0, sizeof(meas_result_list_eutra_t));

    /* This function parses meas_result_list_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list_eutra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_list_eutra->count > MAX_CELL_REPORT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list_eutra->count] should be less than"
            " or equal to MAX_CELL_REPORT. Incorrect value %u received.", p_meas_result_list_eutra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list_eutra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_eutra(
                &p_meas_result_list_eutra->meas_result_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_utra_phys_cell_id
(
    meas_result_utra_phys_cell_id_t *p_meas_result_utra_phys_cell_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_utra_phys_cell_id, 0, sizeof(meas_result_utra_phys_cell_id_t));

    /* This function parses meas_result_utra_phys_cell_id */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_utra_phys_cell_id->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_result_utra_phys_cell_id->bitmask & MEAS_RESULT_UTRA_PHYS_CELL_ID_FDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_utra_phys_cell_id->fdd, p_src + *p_length_read, "fdd");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_utra_phys_cell_id->fdd > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_utra_phys_cell_id->fdd] should be less than"
            " or equal to 511. Incorrect value %u received.", p_meas_result_utra_phys_cell_id->fdd);
        return RRC_FAILURE;
    }
    }

    if (p_meas_result_utra_phys_cell_id->bitmask & MEAS_RESULT_UTRA_PHYS_CELL_ID_TDD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_utra_phys_cell_id->tdd, p_src + *p_length_read, "tdd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_utra_phys_cell_id->tdd > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_utra_phys_cell_id->tdd] should be less than"
            " or equal to 127. Incorrect value %u received.", p_meas_result_utra_phys_cell_id->tdd);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_global_id_utra
(
    cell_global_id_utra_t *p_cell_global_id_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_global_id_utra, 0, sizeof(cell_global_id_utra_t));

    /* This function parses cell_global_id_utra */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_cell_global_id_utra->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_cell_global_id_utra->cell_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_utra->cell_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_utra->cell_identity[loop], (void*)(p_src + *p_length_read), "cell_identity[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_utra_cgi_info
(
    meas_result_utra_cgi_info_t *p_meas_result_utra_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_utra_cgi_info, 0, sizeof(meas_result_utra_cgi_info_t));

    /* This function parses meas_result_utra_cgi_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_utra_cgi_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_utra(
        &p_meas_result_utra_cgi_info->cell_global_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_utra_cgi_info->bitmask & MEAS_RESULT_UTRA_CGI_INFO_LOCATION_AREA_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_meas_result_utra_cgi_info->location_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_meas_result_utra_cgi_info->location_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_meas_result_utra_cgi_info->location_area_code[loop], (void*)(p_src + *p_length_read), "location_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_meas_result_utra_cgi_info->bitmask & MEAS_RESULT_UTRA_CGI_INFO_ROUTING_AREA_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_utra_cgi_info->routing_area_code, p_src + *p_length_read, "routing_area_code");
    *p_length_read += sizeof(U8);
    }

    if (p_meas_result_utra_cgi_info->bitmask & MEAS_RESULT_UTRA_CGI_INFO_PLMN_IDENTITY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_plmn_identity_list2(
        &p_meas_result_utra_cgi_info->plmn_identity_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_utra_meas_result
(
    meas_result_utra_meas_result_t *p_meas_result_utra_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_utra_meas_result, 0, sizeof(meas_result_utra_meas_result_t));

    /* This function parses meas_result_utra_meas_result */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_utra_meas_result->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_result_utra_meas_result->bitmask & MEAS_RESULT_UTRA_MEAS_RESULT_RSCP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(S8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_S8(&p_meas_result_utra_meas_result->utra_rscp, p_src + *p_length_read, "utra_rscp");
    *p_length_read += sizeof(S8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_result_utra_meas_result->utra_rscp < -5) || (p_meas_result_utra_meas_result->utra_rscp > 91))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_utra_meas_result->utra_rscp] should be in range "
            "-5 to 91. Incorrect value %d received.", p_meas_result_utra_meas_result->utra_rscp);
        return RRC_FAILURE;
    }
    }

    if (p_meas_result_utra_meas_result->bitmask & MEAS_RESULT_UTRA_MEAS_RESULT_ECN0_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_utra_meas_result->utra_ecn0, p_src + *p_length_read, "utra_ecn0");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_utra_meas_result->utra_ecn0 > 49))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_utra_meas_result->utra_ecn0] should be less than"
            " or equal to 49. Incorrect value %u received.", p_meas_result_utra_meas_result->utra_ecn0);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_utra
(
    meas_result_utra_t *p_meas_result_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_utra, 0, sizeof(meas_result_utra_t));

    /* This function parses meas_result_utra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_utra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_meas_result_utra_phys_cell_id(
        &p_meas_result_utra->phys_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_utra->bitmask & MEAS_RESULT_UTRA_CGI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_utra_cgi_info(
        &p_meas_result_utra->cgi_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_meas_result_utra->bitmask & MEAS_RESULT_UTRA_CSG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_csg_info(
        &p_meas_result_utra->utra_csg_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_utra_meas_result(
        &p_meas_result_utra->meas_result,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list_utra
(
    meas_result_list_utra_t *p_meas_result_list_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list_utra, 0, sizeof(meas_result_list_utra_t));

    /* This function parses meas_result_list_utra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list_utra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_list_utra->count > MAX_CELL_REPORT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list_utra->count] should be less than"
            " or equal to MAX_CELL_REPORT. Incorrect value %u received.", p_meas_result_list_utra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list_utra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_utra(
                &p_meas_result_list_utra->meas_result_utra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_global_id_geran
(
    cell_global_id_geran_t *p_cell_global_id_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cell_global_id_geran, 0, sizeof(cell_global_id_geran_t));

    /* This function parses cell_global_id_geran */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_cell_global_id_geran->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_cell_global_id_geran->location_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_geran->location_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_geran->location_area_code[loop], (void*)(p_src + *p_length_read), "location_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_cell_global_id_geran->cell_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_geran->cell_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_geran->cell_identity[loop], (void*)(p_src + *p_length_read), "cell_identity[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_geran_cgi_info
(
    meas_result_geran_cgi_info_t *p_meas_result_geran_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_geran_cgi_info, 0, sizeof(meas_result_geran_cgi_info_t));

    /* This function parses meas_result_geran_cgi_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_geran_cgi_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_geran(
        &p_meas_result_geran_cgi_info->cell_global_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_geran_cgi_info->bitmask & MEAS_RESULT_GERAN_CGI_INFO_ROUTING_AREA_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_geran_cgi_info->routing_area_code, p_src + *p_length_read, "routing_area_code");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_geran_meas_result
(
    meas_result_geran_meas_result_t *p_meas_result_geran_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_geran_meas_result, 0, sizeof(meas_result_geran_meas_result_t));

    /* This function parses meas_result_geran_meas_result */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_geran_meas_result->rssi, p_src + *p_length_read, "rssi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_geran_meas_result->rssi > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_geran_meas_result->rssi] should be less than"
            " or equal to 63. Incorrect value %u received.", p_meas_result_geran_meas_result->rssi);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_geran
(
    meas_result_geran_t *p_meas_result_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_geran, 0, sizeof(meas_result_geran_t));

    /* This function parses meas_result_geran */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_geran->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_geran(
        &p_meas_result_geran->carrier_freq,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_geran(
        &p_meas_result_geran->phys_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_geran->bitmask & MEAS_RESULT_GERAN_CGI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_geran_cgi_info(
        &p_meas_result_geran->cgi_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_geran_meas_result(
        &p_meas_result_geran->meas_result,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list_geran
(
    meas_result_list_geran_t *p_meas_result_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list_geran, 0, sizeof(meas_result_list_geran_t));

    /* This function parses meas_result_list_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list_geran->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_list_geran->count > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list_geran->count] should be less than"
            " or equal to 8. Incorrect value %u received.", p_meas_result_list_geran->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list_geran->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_geran(
                &p_meas_result_list_geran->meas_result_geran[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cell_global_id_cdma2000
(
    cell_global_id_cdma2000_t *p_cell_global_id_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cell_global_id_cdma2000, 0, sizeof(cell_global_id_cdma2000_t));

    /* This function parses cell_global_id_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cell_global_id_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_cell_global_id_cdma2000->bitmask & CELL_GLOBAL_ID_CDMA2000_1XRTT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_cell_global_id_cdma2000->cell_global_id_1xrtt) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_cdma2000->cell_global_id_1xrtt); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_cdma2000->cell_global_id_1xrtt[loop], (void*)(p_src + *p_length_read), "cell_global_id_1xrtt[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_cell_global_id_cdma2000->bitmask & CELL_GLOBAL_ID_CDMA2000_HRPD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_cell_global_id_cdma2000->cell_global_id_hrpd) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cell_global_id_cdma2000->cell_global_id_hrpd); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cell_global_id_cdma2000->cell_global_id_hrpd[loop], (void*)(p_src + *p_length_read), "cell_global_id_hrpd[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_cdma2000_meas_result
(
    meas_result_cdma2000_meas_result_t *p_meas_result_cdma2000_meas_result,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_cdma2000_meas_result, 0, sizeof(meas_result_cdma2000_meas_result_t));

    /* This function parses meas_result_cdma2000_meas_result */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_cdma2000_meas_result->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_meas_result_cdma2000_meas_result->bitmask & MEAS_RESULT_CDMA2000_PILOT_PN_PHASE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_cdma2000_meas_result->pilot_pn_phase, p_src + *p_length_read, "pilot_pn_phase");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_cdma2000_meas_result->pilot_pn_phase > 32767))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_cdma2000_meas_result->pilot_pn_phase] should be less than"
            " or equal to 32767. Incorrect value %u received.", p_meas_result_cdma2000_meas_result->pilot_pn_phase);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_cdma2000_meas_result->pilot_strength, p_src + *p_length_read, "pilot_strength");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_cdma2000_meas_result->pilot_strength > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_cdma2000_meas_result->pilot_strength] should be less than"
            " or equal to 63. Incorrect value %u received.", p_meas_result_cdma2000_meas_result->pilot_strength);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_cdma2000
(
    meas_result_cdma2000_t *p_meas_result_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_cdma2000, 0, sizeof(meas_result_cdma2000_t));

    /* This function parses meas_result_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_cdma2000->phy_cell_id, p_src + *p_length_read, "phy_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_cdma2000->phy_cell_id > 511))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_cdma2000->phy_cell_id] should be less than"
            " or equal to 511. Incorrect value %u received.", p_meas_result_cdma2000->phy_cell_id);
        return RRC_FAILURE;
    }

    if (p_meas_result_cdma2000->bitmask & MEAS_RESULT_CDMA2000_CGI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_cdma2000(
        &p_meas_result_cdma2000->cgi_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_cdma2000_meas_result(
        &p_meas_result_cdma2000->meas_result,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list_cdma2000
(
    meas_result_list_cdma2000_t *p_meas_result_list_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list_cdma2000, 0, sizeof(meas_result_list_cdma2000_t));

    /* This function parses meas_result_list_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_list_cdma2000->count > MAX_CELL_REPORT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list_cdma2000->count] should be less than"
            " or equal to MAX_CELL_REPORT. Incorrect value %u received.", p_meas_result_list_cdma2000->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list_cdma2000->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_cdma2000(
                &p_meas_result_list_cdma2000->meas_result_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_results_cdma2000
(
    meas_results_cdma2000_t *p_meas_results_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_results_cdma2000, 0, sizeof(meas_results_cdma2000_t));

    /* This function parses meas_results_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_results_cdma2000->pre_registration_status_hrpd, p_src + *p_length_read, "pre_registration_status_hrpd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_results_cdma2000->pre_registration_status_hrpd > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_results_cdma2000->pre_registration_status_hrpd] should be less than"
            " or equal to 1. Incorrect value %u received.", p_meas_results_cdma2000->pre_registration_status_hrpd);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_cdma2000(
        &p_meas_results_cdma2000->meas_result_list_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_ssb_index_r15
(
    meas_result_ssb_index_r15_t *p_meas_result_ssb_index_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_ssb_index_r15, 0, sizeof(meas_result_ssb_index_r15_t));

    /* This function parses meas_result_ssb_index_r15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_ssb_index_r15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_ssb_index_r15->ssb_index_r15, p_src + *p_length_read, "ssb_index_r15");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_ssb_index_r15->ssb_index_r15 > MAX_RS_INDEX_R15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_ssb_index_r15->ssb_index_r15] should be less than"
            " or equal to MAX_RS_INDEX_R15. Incorrect value %u received.", p_meas_result_ssb_index_r15->ssb_index_r15);
        return RRC_FAILURE;
    }

    if (p_meas_result_ssb_index_r15->bitmask & MEAS_RESULT_SSB_INDEX_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_threshold_list_nr_r15(
        &p_meas_result_ssb_index_r15->meas_result_ssb_index_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_ssb_index_list_r15
(
    meas_result_ssb_index_list_r15_t *p_meas_result_ssb_index_list_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_ssb_index_list_r15, 0, sizeof(meas_result_ssb_index_list_r15_t));

    /* This function parses meas_result_ssb_index_list_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_ssb_index_list_r15->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_result_ssb_index_list_r15->count < 1) || (p_meas_result_ssb_index_list_r15->count > MAX_RS_INDEX_REPORT_R15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_ssb_index_list_r15->count] should be in range "
            "1 to MAX_RS_INDEX_REPORT_R15. Incorrect value %u received.", p_meas_result_ssb_index_list_r15->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_ssb_index_list_r15->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_ssb_index_r15(
                &p_meas_result_ssb_index_list_r15->meas_result_ssb_index_r15[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_ind_nr
(
    meas_result_ind_nr_t *p_meas_result_ind_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_ind_nr, 0, sizeof(meas_result_ind_nr_t));

    /* This function parses meas_result_ind_nr */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_ind_nr->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_ind_nr->phys_cell_id_r15, p_src + *p_length_read, "phys_cell_id_r15");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_ind_nr->phys_cell_id_r15 > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_ind_nr->phys_cell_id_r15] should be less than"
            " or equal to 503. Incorrect value %u received.", p_meas_result_ind_nr->phys_cell_id_r15);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_threshold_list_nr_r15(
        &p_meas_result_ind_nr->meas_result_cell_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_meas_result_ind_nr->bitmask & MEAS_RESULT_NR_RS_INDEX_LIST_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_ssb_index_list_r15(
        &p_meas_result_ind_nr->rs_index_list_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_results_list_nr_r15
(
    meas_results_list_nr_r15_t *p_meas_results_list_nr_r15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_results_list_nr_r15, 0, sizeof(meas_results_list_nr_r15_t));

    /* This function parses meas_results_list_nr_r15 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_results_list_nr_r15->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_results_list_nr_r15->count > MAX_CELL_REPORT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_results_list_nr_r15->count] should be less than"
            " or equal to MAX_CELL_REPORT. Incorrect value %u received.", p_meas_results_list_nr_r15->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_results_list_nr_r15->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_meas_result_ind_nr(
                &p_meas_results_list_nr_r15->meas_result_nr[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_neigh_cells
(
    rrc_meas_result_neigh_cells_t *p_rrc_meas_result_neigh_cells,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_neigh_cells, 0, sizeof(rrc_meas_result_neigh_cells_t));

    /* This function parses rrc_meas_result_neigh_cells */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_neigh_cells->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_meas_result_neigh_cells->bitmask & RRM_MEAS_RESULT_LIST_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_eutra(
        &p_rrc_meas_result_neigh_cells->meas_result_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_neigh_cells->bitmask & RRM_MEAS_RESULT_LIST_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_utra(
        &p_rrc_meas_result_neigh_cells->meas_result_list_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_neigh_cells->bitmask & RRM_MEAS_RESULT_LIST_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_geran(
        &p_rrc_meas_result_neigh_cells->meas_result_list_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_neigh_cells->bitmask & RRM_MEAS_RESULTS_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_results_cdma2000(
        &p_rrc_meas_result_neigh_cells->meas_result_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_neigh_cells->bitmask & RRM_MEAS_RESULT_LIST_NR_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_results_list_nr_r15(
        &p_rrc_meas_result_neigh_cells->meas_result_list_nr_r15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_ecid_r9
(
    rrc_meas_result_ecid_r9_t *p_rrc_meas_result_ecid_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_ecid_r9, 0, sizeof(rrc_meas_result_ecid_r9_t));

    /* This function parses rrc_meas_result_ecid_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_ecid_r9->ue_rxtx_time_diff_result, p_src + *p_length_read, "ue_rxtx_time_diff_result");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_ecid_r9->ue_rxtx_time_diff_result > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_ecid_r9->ue_rxtx_time_diff_result] should be less than"
            " or equal to 4095. Incorrect value %u received.", p_rrc_meas_result_ecid_r9->ue_rxtx_time_diff_result);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(p_rrc_meas_result_ecid_r9->current_sfn_r9) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_meas_result_ecid_r9->current_sfn_r9); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_meas_result_ecid_r9->current_sfn_r9[loop], (void*)(p_src + *p_length_read), "current_sfn_r9[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_attr
(
    meas_result_attr_t *p_meas_result_attr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_meas_result_attr, 0, sizeof(meas_result_attr_t));

    /* This function parses meas_result_attr */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_attr->rsrp_result_r10, p_src + *p_length_read, "rsrp_result_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_attr->rsrp_result_r10 > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_attr->rsrp_result_r10] should be less than"
            " or equal to 97. Incorrect value %u received.", p_meas_result_attr->rsrp_result_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_attr->rsrq_result_r10, p_src + *p_length_read, "rsrq_result_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_attr->rsrq_result_r10 > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_attr->rsrq_result_r10] should be less than"
            " or equal to 34. Incorrect value %u received.", p_meas_result_attr->rsrq_result_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_best_neigh_cell_r10
(
    meas_result_best_neigh_cell_r10_t *p_meas_result_best_neigh_cell_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_best_neigh_cell_r10, 0, sizeof(meas_result_best_neigh_cell_r10_t));

    /* This function parses meas_result_best_neigh_cell_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_meas_result_best_neigh_cell_r10->phys_cell_id_r10, p_src + *p_length_read, "phys_cell_id_r10");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_meas_result_best_neigh_cell_r10->phys_cell_id_r10 > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_best_neigh_cell_r10->phys_cell_id_r10] should be less than"
            " or equal to 503. Incorrect value %u received.", p_meas_result_best_neigh_cell_r10->phys_cell_id_r10);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_attr(
        &p_meas_result_best_neigh_cell_r10->best_neigh_cell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_freq_r10
(
    rrc_meas_result_serv_freq_r10_t *p_rrc_meas_result_serv_freq_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_serv_freq_r10, 0, sizeof(rrc_meas_result_serv_freq_r10_t));

    /* This function parses rrc_meas_result_serv_freq_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_serv_freq_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_serv_freq_r10->serv_cell_index_r10, p_src + *p_length_read, "serv_cell_index_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_serv_freq_r10->serv_cell_index_r10 > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_serv_freq_r10->serv_cell_index_r10] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_meas_result_serv_freq_r10->serv_cell_index_r10);
        return RRC_FAILURE;
    }

    if (p_rrc_meas_result_serv_freq_r10->bitmask & RRM_MEAS_RESULT_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_attr(
        &p_rrc_meas_result_serv_freq_r10->meas_result_scell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_serv_freq_r10->bitmask & RRM_MEAS_RESULT_BEST_NEIGH_CELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_best_neigh_cell_r10(
        &p_rrc_meas_result_serv_freq_r10->meas_result_best_neigh_cell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_serv_freq_list_r10
(
    rrc_meas_result_serv_freq_list_r10_t *p_rrc_meas_result_serv_freq_list_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_serv_freq_list_r10, 0, sizeof(rrc_meas_result_serv_freq_list_r10_t));

    /* This function parses rrc_meas_result_serv_freq_list_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_serv_freq_list_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_serv_freq_list_r10->count > MAX_SERVING_CELL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_serv_freq_list_r10->count] should be less than"
            " or equal to MAX_SERVING_CELL. Incorrect value %u received.", p_rrc_meas_result_serv_freq_list_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_meas_result_serv_freq_list_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_serv_freq_r10(
                &p_rrc_meas_result_serv_freq_list_r10->rrc_meas_result_serv_freq_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_wlan_r13
(
    rrc_meas_result_wlan_r13_t *p_rrc_meas_result_wlan_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_wlan_r13, 0, sizeof(rrc_meas_result_wlan_r13_t));

    /* This function parses rrc_meas_result_wlan_r13 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_wlan_r13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_wlan_identifier(
        &p_rrc_meas_result_wlan_r13->wlan_identifier,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_CARRIER_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_wlan_carrier_info(
        &p_rrc_meas_result_wlan_r13->wlan_carrier_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_BAND_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->wlan_band, p_src + *p_length_read, "wlan_band");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->wlan_band > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->wlan_band] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->wlan_band);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->rssi, p_src + *p_length_read, "rssi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->rssi > 141))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->rssi] should be less than"
            " or equal to 141. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->rssi);
        return RRC_FAILURE;
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_AVAILABLE_ADMISSION_CAPACITY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_wlan_r13->available_admission_capacity, p_src + *p_length_read, "available_admission_capacity");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->available_admission_capacity > 31250))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->available_admission_capacity] should be less than"
            " or equal to 31250. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->available_admission_capacity);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_BACKHAUL_DL_BANDWIDTH_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->backhaul_dl_bandwidth, p_src + *p_length_read, "backhaul_dl_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->backhaul_dl_bandwidth > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->backhaul_dl_bandwidth] should be less than"
            " or equal to 32. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->backhaul_dl_bandwidth);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_BACKHAUL_UL_BANDWIDTH_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->backhaul_ul_bandwidth, p_src + *p_length_read, "backhaul_ul_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->backhaul_ul_bandwidth > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->backhaul_ul_bandwidth] should be less than"
            " or equal to 32. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->backhaul_ul_bandwidth);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_CHANNEL_UTILIZATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->channel_utilization, p_src + *p_length_read, "channel_utilization");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->channel_utilization > 255))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->channel_utilization] should be less than"
            " or equal to 255. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->channel_utilization);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_STATION_COUNT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result_wlan_r13->station_count, p_src + *p_length_read, "station_count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->station_count > 65535))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->station_count] should be less than"
            " or equal to 65535. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->station_count);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_meas_result_wlan_r13->bitmask & WLAN_CONNECTED_WLAN_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_r13->connected_wlan, p_src + *p_length_read, "connected_wlan");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_r13->connected_wlan > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_r13->connected_wlan] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_meas_result_wlan_r13->connected_wlan);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_wlan_list_r13
(
    rrc_meas_result_wlan_list_r13_t *p_rrc_meas_result_wlan_list_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_wlan_list_r13, 0, sizeof(rrc_meas_result_wlan_list_r13_t));

    /* This function parses rrc_meas_result_wlan_list_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_wlan_list_r13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result_wlan_list_r13->count > MAX_CELL_INFO_WLAN_R13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_wlan_list_r13->count] should be less than"
            " or equal to MAX_CELL_INFO_WLAN_R13. Incorrect value %u received.", p_rrc_meas_result_wlan_list_r13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_meas_result_wlan_list_r13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_wlan_r13(
                &p_rrc_meas_result_wlan_list_r13->meas_result_wlan_r13[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_proximity_ind
(
    rrc_rrm_proximity_ind_t *p_rrc_rrm_proximity_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_proximity_ind, 0, sizeof(rrc_rrm_proximity_ind_t));

    /* This function parses rrc_rrm_proximity_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_proximity_ind->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_proximity_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_proximity_ind->proximity_ind_type, p_src + *p_length_read, "proximity_ind_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_proximity_ind->proximity_ind_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_proximity_ind->proximity_ind_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_proximity_ind->proximity_ind_type);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_ProximityIndication_r9_IEs_carrierFreq_r9(
        &p_rrc_rrm_proximity_ind->carrier_Freq,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ProximityIndication_r9_IEs_carrierFreq_r9
(
    ProximityIndication_r9_IEs_carrierFreq_r9_t *p_ProximityIndication_r9_IEs_carrierFreq_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ProximityIndication_r9_IEs_carrierFreq_r9, 0, sizeof(ProximityIndication_r9_IEs_carrierFreq_r9_t));

    /* This function parses ProximityIndication_r9_IEs_carrierFreq_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ProximityIndication_r9_IEs_carrierFreq_r9->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_ProximityIndication_r9_IEs_carrierFreq_r9->presence_bitmask & RRM_PROXIMITY_ARFCN_VALUE_EUTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ProximityIndication_r9_IEs_carrierFreq_r9->carrier_freq_eutra, p_src + *p_length_read, "carrier_freq_eutra");
    *p_length_read += sizeof(U16);
    }

    if (p_ProximityIndication_r9_IEs_carrierFreq_r9->presence_bitmask & RRM_PROXIMITY_ARFCN_VALUE_UTRA_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ProximityIndication_r9_IEs_carrierFreq_r9->carrier_freq_utra, p_src + *p_length_read, "carrier_freq_utra");
    *p_length_read += sizeof(U16);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrm_rrc_cell_del_resp
(
    rrm_rrc_cell_del_resp_t *p_rrm_rrc_cell_del_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_cell_del_resp, 0, sizeof(rrm_rrc_cell_del_resp_t));

    /* This function parses rrm_rrc_cell_del_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_cell_del_resp->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rrc_cell_del_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_rrc_cell_del_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_rrc_cell_del_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrm_rrc_cell_del_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rrc_cell_del_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_rrc_cell_del_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_rrc_cell_del_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_rrc_cell_del_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrm_rrc_cell_del_resp->presence_bitmask & CELL_DEL_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rrc_cell_del_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_rrc_cell_del_resp->fail_cause > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_rrc_cell_del_resp->fail_cause] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrm_rrc_cell_del_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_del_req
(
    rrc_rrm_cell_del_req_t *p_rrc_rrm_cell_del_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_del_req, 0, sizeof(rrc_rrm_cell_del_req_t));

    /* This function parses rrc_rrm_cell_del_req */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_del_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_del_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_del_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_del_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_del_req->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_capability_enquiry_req
(
    rrc_rrm_ue_capability_enquiry_req_t *p_rrc_rrm_ue_capability_enquiry_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_capability_enquiry_req, 0, sizeof(rrc_rrm_ue_capability_enquiry_req_t));

    /* This function parses rrc_rrm_ue_capability_enquiry_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_capability_enquiry_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_capability_enquiry_req->ue_Index, p_src + *p_length_read, "ue_Index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_capability_enquiry_req->bitmask & RAT_TYPE_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rat_type_info(
        &p_rrc_rrm_ue_capability_enquiry_req->rat_type_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rat_type_info
(
    rat_type_info_t *p_rat_type_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rat_type_info, 0, sizeof(rat_type_info_t));

    /* This function parses rat_type_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rat_type_info->rat_type_count, p_src + *p_length_read, "rat_type_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rat_type_info->rat_type_count > MAX_RAT_CAPABILITY))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rat_type_info->rat_type_count] should be less than"
            " or equal to MAX_RAT_CAPABILITY. Incorrect value %u received.", p_rat_type_info->rat_type_count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rat_type_info->rat_type_count * sizeof(p_rat_type_info->rat_type[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rat_type_info->rat_type_count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rat_type_info->rat_type[loop], (void*)(p_src + *p_length_read), "rat_type[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_release_req
(
    rrc_rrm_erb_release_req_t *p_rrc_rrm_erb_release_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_release_req, 0, sizeof(rrc_rrm_erb_release_req_t));

    /* This function parses rrc_rrm_erb_release_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erb_release_req->bitmask & RRC_RRM_ERB_RELEASE_REQ_UE_AGG_MAX_BIT_RATE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_erb_release_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_released_item_list(
        &p_rrc_rrm_erb_release_req->erab_to_be_released_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_release_resp
(
    rrc_rrm_erb_release_resp_t *p_rrc_rrm_erb_release_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_release_resp, 0, sizeof(rrc_rrm_erb_release_resp_t));

    /* This function parses rrc_rrm_erb_release_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erb_release_resp->bitmask & RRC_RRM_DRB_RELEASE_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_release_item_list(
        &p_rrc_rrm_erb_release_resp->drb_release_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_release_resp->bitmask & RRC_RRM_DRB_FAILED_TO_RELEASE_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_failed_to_release_item_list(
        &p_rrc_rrm_erb_release_resp->drb_failed_to_release_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_release_resp->bitmask & RRC_RRM_ERB_RELEASE_RESP_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_rrc_rrm_erb_release_resp->sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_release_resp->bitmask & RRM_RRM_ERB_RELEASE_RESP_UE_INACTIVE_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_erb_release_resp->ue_inactive_time_config, p_src + *p_length_read, "ue_inactive_time_config");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_release_item_list
(
    rrm_erab_release_item_list_t *p_rrm_erab_release_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_release_item_list, 0, sizeof(rrm_erab_release_item_list_t));

    /* This function parses rrm_erab_release_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_release_item_list->num_of_list, p_src + *p_length_read, "num_of_list");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_release_item_list->num_of_list < 1) || (p_rrm_erab_release_item_list->num_of_list > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_release_item_list->num_of_list] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_erab_release_item_list->num_of_list);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_release_item_list->num_of_list; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_item(
                &p_rrm_erab_release_item_list->drb_release_item[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_to_release_item
(
    rrm_erab_failed_to_release_item_t *p_rrm_erab_failed_to_release_item,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_failed_to_release_item, 0, sizeof(rrm_erab_failed_to_release_item_t));

    /* This function parses rrm_erab_failed_to_release_item */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_erab_failed_to_release_item->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_erab_failed_to_release_item->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_failed_to_release_item->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_erab_failed_to_release_item->erab_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrm_erab_failed_to_release_item->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_to_release_item_list
(
    rrm_erab_failed_to_release_item_list_t *p_rrm_erab_failed_to_release_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_failed_to_release_item_list, 0, sizeof(rrm_erab_failed_to_release_item_list_t));

    /* This function parses rrm_erab_failed_to_release_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_failed_to_release_item_list->num_of_list, p_src + *p_length_read, "num_of_list");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_erab_failed_to_release_item_list->num_of_list < 1) || (p_rrm_erab_failed_to_release_item_list->num_of_list > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_erab_failed_to_release_item_list->num_of_list] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_erab_failed_to_release_item_list->num_of_list);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_failed_to_release_item_list->num_of_list; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_failed_to_release_item(
                &p_rrm_erab_failed_to_release_item_list->drb_failed_to_release_item[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_release_cnf
(
    rrc_rrm_erb_release_cnf_t *p_rrc_rrm_erb_release_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_release_cnf, 0, sizeof(rrc_rrm_erb_release_cnf_t));

    /* This function parses rrc_rrm_erb_release_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_erb_release_cnf->bitmask & RRM_ERB_RELEASE_CNF_CONFIRM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrc_rrm_erb_release_cnf->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_release_cnf->bitmask & RRM_ERB_RELEASE_CNF_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrc_rrm_erb_release_cnf->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_erb_release_cnf->bitmask & RRC_RRM_ERB_RELEASE_CNF_SPS_ERROR_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_erb_release_cnf->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_erb_release_cnf->error_code > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_erb_release_cnf->error_code] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_erb_release_cnf->error_code);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_erb_release_ind
(
    rrc_rrm_erb_release_ind_t *p_rrc_rrm_erb_release_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_erb_release_ind, 0, sizeof(rrc_rrm_erb_release_ind_t));

    /* This function parses rrc_rrm_erb_release_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_erb_release_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_released_item_list(
        &p_rrc_rrm_erb_release_ind->erab_to_be_released_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_erb_release_ind->bitmask & RRM_ERB_RELEASE_IND_API_UE_INACTIVE_TIME_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_erb_release_ind->ue_inactive_time_config, p_src + *p_length_read, "ue_inactive_time_config");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_capability_enquiry_resp
(
    rrc_rrm_ue_capability_enquiry_resp_t *p_rrc_rrm_ue_capability_enquiry_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_capability_enquiry_resp, 0, sizeof(rrc_rrm_ue_capability_enquiry_resp_t));

    /* This function parses rrc_rrm_ue_capability_enquiry_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_capability_enquiry_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_capability_enquiry_resp->ue_Index, p_src + *p_length_read, "ue_Index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_capability_enquiry_resp->result, p_src + *p_length_read, "result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_capability_enquiry_resp->result > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_capability_enquiry_resp->result] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_capability_enquiry_resp->result);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_capability_enquiry_resp->bitmask & RADIO_CAPABILITY_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_capability_info(
        &p_rrc_rrm_ue_capability_enquiry_resp->radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pdcp_parameters
(
    pdcp_parameters_t *p_pdcp_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pdcp_parameters, 0, sizeof(pdcp_parameters_t));

    /* This function parses pdcp_parameters */

    if (RRC_FAILURE == rrc_il_parse_rrc_pdcp_rohc_profile(
        &p_pdcp_parameters->rohc_profile,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pdcp_parameters->max_num_rohc_context_session, p_src + *p_length_read, "max_num_rohc_context_session");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pdcp_parameters->max_num_rohc_context_session > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pdcp_parameters->max_num_rohc_context_session] should be less than"
            " or equal to 15. Incorrect value %u received.", p_pdcp_parameters->max_num_rohc_context_session);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_physical_layer_params
(
    physical_layer_params_t *p_physical_layer_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_physical_layer_params, 0, sizeof(physical_layer_params_t));

    /* This function parses physical_layer_params */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_physical_layer_params->ue_TxAntennaSelectionSupported, p_src + *p_length_read, "ue_TxAntennaSelectionSupported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_physical_layer_params->ue_TxAntennaSelectionSupported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_physical_layer_params->ue_TxAntennaSelectionSupported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_physical_layer_params->ue_TxAntennaSelectionSupported);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_physical_layer_params->ue_SpecificRefSigsSupported, p_src + *p_length_read, "ue_SpecificRefSigsSupported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_physical_layer_params->ue_SpecificRefSigsSupported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_physical_layer_params->ue_SpecificRefSigsSupported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_physical_layer_params->ue_SpecificRefSigsSupported);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_eutra
(
    supported_band_eutra_t *p_supported_band_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_supported_band_eutra, 0, sizeof(supported_band_eutra_t));

    /* This function parses supported_band_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_eutra->band_eutra, p_src + *p_length_read, "band_eutra");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_eutra->band_eutra < 1) || (p_supported_band_eutra->band_eutra > 64))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_eutra->band_eutra] should be in range "
            "1 to 64. Incorrect value %u received.", p_supported_band_eutra->band_eutra);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_eutra->half_duplex, p_src + *p_length_read, "half_duplex");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_supported_band_eutra->half_duplex > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_eutra->half_duplex] should be less than"
            " or equal to 1. Incorrect value %u received.", p_supported_band_eutra->half_duplex);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_list_eutra
(
    supported_band_list_eutra_t *p_supported_band_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_list_eutra, 0, sizeof(supported_band_list_eutra_t));

    /* This function parses supported_band_list_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_list_eutra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_list_eutra->count < 1) || (p_supported_band_list_eutra->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_list_eutra->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_supported_band_list_eutra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_list_eutra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_supported_band_eutra(
                &p_supported_band_list_eutra->supported_band_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters
(
    rf_parameters_t *p_rf_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters, 0, sizeof(rf_parameters_t));

    /* This function parses rf_parameters */

    if (RRC_FAILURE == rrc_il_parse_supported_band_list_eutra(
        &p_rf_parameters->supported_band_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_band_info
(
    inter_freq_band_info_t *p_inter_freq_band_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_inter_freq_band_info, 0, sizeof(inter_freq_band_info_t));

    /* This function parses inter_freq_band_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_band_info->inter_freq_need_for_gaps, p_src + *p_length_read, "inter_freq_need_for_gaps");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_freq_band_info->inter_freq_need_for_gaps > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_band_info->inter_freq_need_for_gaps] should be less than"
            " or equal to 1. Incorrect value %u received.", p_inter_freq_band_info->inter_freq_need_for_gaps);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_freq_band_list
(
    inter_freq_band_list_t *p_inter_freq_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_freq_band_list, 0, sizeof(inter_freq_band_list_t));

    /* This function parses inter_freq_band_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_freq_band_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_freq_band_list->count < 1) || (p_inter_freq_band_list->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_freq_band_list->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_inter_freq_band_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_inter_freq_band_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_inter_freq_band_info(
                &p_inter_freq_band_list->inter_freq_band_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_rat_band_info
(
    inter_rat_band_info_t *p_inter_rat_band_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_inter_rat_band_info, 0, sizeof(inter_rat_band_info_t));

    /* This function parses inter_rat_band_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_rat_band_info->inter_rat_need_for_gaps, p_src + *p_length_read, "inter_rat_need_for_gaps");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_inter_rat_band_info->inter_rat_need_for_gaps > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_rat_band_info->inter_rat_need_for_gaps] should be less than"
            " or equal to 1. Incorrect value %u received.", p_inter_rat_band_info->inter_rat_need_for_gaps);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_rat_band_list
(
    inter_rat_band_list_t *p_inter_rat_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_rat_band_list, 0, sizeof(inter_rat_band_list_t));

    /* This function parses inter_rat_band_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_inter_rat_band_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_inter_rat_band_list->count < 1) || (p_inter_rat_band_list->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_inter_rat_band_list->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_inter_rat_band_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_inter_rat_band_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_inter_rat_band_info(
                &p_inter_rat_band_list->inter_rat_band_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_info_eutra
(
    band_info_eutra_t *p_band_info_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_info_eutra, 0, sizeof(band_info_eutra_t));

    /* This function parses band_info_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_info_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_inter_freq_band_list(
        &p_band_info_eutra->inter_freq_band_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_band_info_eutra->bitmask & EUTRA_INTER_RAT_BAND_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_inter_rat_band_list(
        &p_band_info_eutra->inter_rat_band_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_list_eutra
(
    band_list_eutra_t *p_band_list_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_list_eutra, 0, sizeof(band_list_eutra_t));

    /* This function parses band_list_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_list_eutra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_list_eutra->count < 1) || (p_band_list_eutra->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_list_eutra->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_band_list_eutra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_list_eutra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_info_eutra(
                &p_band_list_eutra->band_info_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_pameters
(
    meas_pameters_t *p_meas_pameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_pameters, 0, sizeof(meas_pameters_t));

    /* This function parses meas_pameters */

    if (RRC_FAILURE == rrc_il_parse_band_list_eutra(
        &p_meas_pameters->band_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_fdd
(
    utra_fdd_t *p_utra_fdd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_fdd, 0, sizeof(utra_fdd_t));

    /* This function parses utra_fdd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_fdd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_utra_fdd->count < 1) || (p_utra_fdd->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_fdd->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_utra_fdd->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_fdd->count * sizeof(p_utra_fdd->supported_band_utra_fdd[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_fdd->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_fdd->supported_band_utra_fdd[loop], (void*)(p_src + *p_length_read), "supported_band_utra_fdd[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_tdd128
(
    utra_tdd128_t *p_utra_tdd128,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_tdd128, 0, sizeof(utra_tdd128_t));

    /* This function parses utra_tdd128 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_tdd128->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_utra_tdd128->count < 1) || (p_utra_tdd128->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_tdd128->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_utra_tdd128->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_tdd128->count * sizeof(p_utra_tdd128->supported_band_utra_tdd128[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_tdd128->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_tdd128->supported_band_utra_tdd128[loop], (void*)(p_src + *p_length_read), "supported_band_utra_tdd128[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_tdd384
(
    utra_tdd384_t *p_utra_tdd384,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_tdd384, 0, sizeof(utra_tdd384_t));

    /* This function parses utra_tdd384 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_tdd384->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_utra_tdd384->count < 1) || (p_utra_tdd384->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_tdd384->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_utra_tdd384->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_tdd384->count * sizeof(p_utra_tdd384->supported_band_utra_tdd384[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_tdd384->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_tdd384->supported_band_utra_tdd384[loop], (void*)(p_src + *p_length_read), "supported_band_utra_tdd384[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_tdd768
(
    utra_tdd768_t *p_utra_tdd768,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_tdd768, 0, sizeof(utra_tdd768_t));

    /* This function parses utra_tdd768 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_utra_tdd768->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_utra_tdd768->count < 1) || (p_utra_tdd768->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_tdd768->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_utra_tdd768->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_tdd768->count * sizeof(p_utra_tdd768->supported_band_utra_tdd768[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_tdd768->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_tdd768->supported_band_utra_tdd768[loop], (void*)(p_src + *p_length_read), "supported_band_utra_tdd768[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_list_geran
(
    supported_band_list_geran_t *p_supported_band_list_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_supported_band_list_geran, 0, sizeof(supported_band_list_geran_t));

    /* This function parses supported_band_list_geran */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_list_geran->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_list_geran->count < 1) || (p_supported_band_list_geran->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_list_geran->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_supported_band_list_geran->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_supported_band_list_geran->count * sizeof(p_supported_band_list_geran->supported_band_geran[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_list_geran->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_supported_band_list_geran->supported_band_geran[loop], (void*)(p_src + *p_length_read), "supported_band_geran[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_geran
(
    geran_t *p_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_geran, 0, sizeof(geran_t));

    /* This function parses geran */

    if (RRC_FAILURE == rrc_il_parse_supported_band_list_geran(
        &p_geran->supported_band_list_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_geran->inter_rat_ps_ho_to_geran, p_src + *p_length_read, "inter_rat_ps_ho_to_geran");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_geran->inter_rat_ps_ho_to_geran > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_geran->inter_rat_ps_ho_to_geran] should be less than"
            " or equal to 1. Incorrect value %u received.", p_geran->inter_rat_ps_ho_to_geran);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_list_hrpd
(
    supported_band_list_hrpd_t *p_supported_band_list_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_supported_band_list_hrpd, 0, sizeof(supported_band_list_hrpd_t));

    /* This function parses supported_band_list_hrpd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_list_hrpd->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_list_hrpd->count < 1) || (p_supported_band_list_hrpd->count > MAX_CDMA_BAND_CLASS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_list_hrpd->count] should be in range "
            "1 to MAX_CDMA_BAND_CLASS. Incorrect value %u received.", p_supported_band_list_hrpd->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_supported_band_list_hrpd->count * sizeof(p_supported_band_list_hrpd->band_class_cdma2000[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_list_hrpd->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_supported_band_list_hrpd->band_class_cdma2000[loop], (void*)(p_src + *p_length_read), "band_class_cdma2000[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_hrpd
(
    cdma2000_hrpd_t *p_cdma2000_hrpd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cdma2000_hrpd, 0, sizeof(cdma2000_hrpd_t));

    /* This function parses cdma2000_hrpd */

    if (RRC_FAILURE == rrc_il_parse_supported_band_list_hrpd(
        &p_cdma2000_hrpd->supported_band_list_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_hrpd->tx_confiig_hrpd, p_src + *p_length_read, "tx_confiig_hrpd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_hrpd->tx_confiig_hrpd > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_hrpd->tx_confiig_hrpd] should be less than"
            " or equal to 16. Incorrect value %u received.", p_cdma2000_hrpd->tx_confiig_hrpd);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_hrpd->rx_confiig_hrpd, p_src + *p_length_read, "rx_confiig_hrpd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_hrpd->rx_confiig_hrpd > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_hrpd->rx_confiig_hrpd] should be less than"
            " or equal to 16. Incorrect value %u received.", p_cdma2000_hrpd->rx_confiig_hrpd);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_list_1xrtt
(
    supported_band_list_1xrtt_t *p_supported_band_list_1xrtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_supported_band_list_1xrtt, 0, sizeof(supported_band_list_1xrtt_t));

    /* This function parses supported_band_list_1xrtt */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_list_1xrtt->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_list_1xrtt->count < 1) || (p_supported_band_list_1xrtt->count > MAX_CDMA_BAND_CLASS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_list_1xrtt->count] should be in range "
            "1 to MAX_CDMA_BAND_CLASS. Incorrect value %u received.", p_supported_band_list_1xrtt->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_supported_band_list_1xrtt->count * sizeof(p_supported_band_list_1xrtt->band_class_cdma2000[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_list_1xrtt->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_supported_band_list_1xrtt->band_class_cdma2000[loop], (void*)(p_src + *p_length_read), "band_class_cdma2000[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_1x_rtt
(
    cdma2000_1x_rtt_t *p_cdma2000_1x_rtt,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cdma2000_1x_rtt, 0, sizeof(cdma2000_1x_rtt_t));

    /* This function parses cdma2000_1x_rtt */

    if (RRC_FAILURE == rrc_il_parse_supported_band_list_1xrtt(
        &p_cdma2000_1x_rtt->supported_band_list_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_1x_rtt->tx_confiig_1xrtt, p_src + *p_length_read, "tx_confiig_1xrtt");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_1x_rtt->tx_confiig_1xrtt > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_1x_rtt->tx_confiig_1xrtt] should be less than"
            " or equal to 16. Incorrect value %u received.", p_cdma2000_1x_rtt->tx_confiig_1xrtt);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cdma2000_1x_rtt->rx_confiig_1xrtt, p_src + *p_length_read, "rx_confiig_1xrtt");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_1x_rtt->rx_confiig_1xrtt > 16))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_1x_rtt->rx_confiig_1xrtt] should be less than"
            " or equal to 16. Incorrect value %u received.", p_cdma2000_1x_rtt->rx_confiig_1xrtt);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_inter_rat_Parameters
(
    inter_rat_Parameters_t *p_inter_rat_Parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_inter_rat_Parameters, 0, sizeof(inter_rat_Parameters_t));

    /* This function parses inter_rat_Parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_inter_rat_Parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_FDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_fdd(
        &p_inter_rat_Parameters->utra_fdd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_TDD128_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_tdd128(
        &p_inter_rat_Parameters->utra_tdd128,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_TDD384_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_tdd384(
        &p_inter_rat_Parameters->utra_tdd384,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_TDD768_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_tdd768(
        &p_inter_rat_Parameters->utra_tdd768,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_geran(
        &p_inter_rat_Parameters->geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_CDMA2000_HRPD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd(
        &p_inter_rat_Parameters->cdma2000_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_inter_rat_Parameters->bitmask & INTER_RAT_UTRA_CDMA2000_1XRTT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1x_rtt(
        &p_inter_rat_Parameters->cdma2000_1x_rtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_radio_capability_info_def
(
    eutra_radio_capability_info_def_t *p_eutra_radio_capability_info_def,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_eutra_radio_capability_info_def, 0, sizeof(eutra_radio_capability_info_def_t));

    /* This function parses eutra_radio_capability_info_def */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_eutra_radio_capability_info_def->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_eutra_radio_capability_info_def->access_stratum_release, p_src + *p_length_read, "access_stratum_release");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_eutra_radio_capability_info_def->access_stratum_release > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_eutra_radio_capability_info_def->access_stratum_release] should be less than"
            " or equal to 7. Incorrect value %u received.", p_eutra_radio_capability_info_def->access_stratum_release);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_eutra_radio_capability_info_def->ue_category, p_src + *p_length_read, "ue_category");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_eutra_radio_capability_info_def->ue_category < 1) || (p_eutra_radio_capability_info_def->ue_category > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_eutra_radio_capability_info_def->ue_category] should be in range "
            "1 to 5. Incorrect value %u received.", p_eutra_radio_capability_info_def->ue_category);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_pdcp_parameters(
        &p_eutra_radio_capability_info_def->pdcp_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_physical_layer_params(
        &p_eutra_radio_capability_info_def->physical_layer_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rf_parameters(
        &p_eutra_radio_capability_info_def->rf_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_meas_pameters(
        &p_eutra_radio_capability_info_def->meas_prameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_eutra_radio_capability_info_def->bitmask & EUTRA_FEATURE_GROUP_INDICATORS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_eutra_radio_capability_info_def->feature_group_indicators) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_eutra_radio_capability_info_def->feature_group_indicators); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_eutra_radio_capability_info_def->feature_group_indicators[loop], (void*)(p_src + *p_length_read), "feature_group_indicators[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (RRC_FAILURE == rrc_il_parse_inter_rat_Parameters(
        &p_eutra_radio_capability_info_def->inter_rat_Parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phy_layer_parameters_v920
(
    phy_layer_parameters_v920_t *p_phy_layer_parameters_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_phy_layer_parameters_v920, 0, sizeof(phy_layer_parameters_v920_t));

    /* This function parses phy_layer_parameters_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phy_layer_parameters_v920->enhanced_dual_layer_fdd_supported_r9, p_src + *p_length_read, "enhanced_dual_layer_fdd_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phy_layer_parameters_v920->enhanced_dual_layer_fdd_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phy_layer_parameters_v920->enhanced_dual_layer_fdd_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_phy_layer_parameters_v920->enhanced_dual_layer_fdd_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phy_layer_parameters_v920->enhanced_dual_layer_tdd_supported_r9, p_src + *p_length_read, "enhanced_dual_layer_tdd_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_phy_layer_parameters_v920->enhanced_dual_layer_tdd_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_phy_layer_parameters_v920->enhanced_dual_layer_tdd_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_phy_layer_parameters_v920->enhanced_dual_layer_tdd_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_geran_v920
(
    irat_parameters_geran_v920_t *p_irat_parameters_geran_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_geran_v920, 0, sizeof(irat_parameters_geran_v920_t));

    /* This function parses irat_parameters_geran_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_irat_parameters_geran_v920->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_irat_parameters_geran_v920->bitmask & IRAT_PARAMS_GERAN_V920_DTM_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_geran_v920->dtm_r9, p_src + *p_length_read, "dtm_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_parameters_geran_v920->dtm_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_parameters_geran_v920->dtm_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_irat_parameters_geran_v920->dtm_r9);
        return RRC_FAILURE;
    }
    }

    if (p_irat_parameters_geran_v920->bitmask & IRAT_PARAMS_GERAN_V920_E_REDIRECTION_GERAN_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_geran_v920->e_redirection_geran_r9, p_src + *p_length_read, "e_redirection_geran_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_parameters_geran_v920->e_redirection_geran_r9 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_parameters_geran_v920->e_redirection_geran_r9] should be less than"
            " or equal to 0. Incorrect value %u received.", p_irat_parameters_geran_v920->e_redirection_geran_r9);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_v920
(
    irat_parameters_utra_v920_t *p_irat_parameters_utra_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_utra_v920, 0, sizeof(irat_parameters_utra_v920_t));

    /* This function parses irat_parameters_utra_v920 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v920->e_redirection_utra_r9, p_src + *p_length_read, "e_redirection_utra_r9");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_cdma2000_v920
(
    irat_parameters_cdma2000_v920_t *p_irat_parameters_cdma2000_v920,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_cdma2000_v920, 0, sizeof(irat_parameters_cdma2000_v920_t));

    /* This function parses irat_parameters_cdma2000_v920 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_irat_parameters_cdma2000_v920->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_cdma2000_v920->eCSFB_1xrtt_r9, p_src + *p_length_read, "eCSFB_1xrtt_r9");
    *p_length_read += sizeof(U8);

    if (p_irat_parameters_cdma2000_v920->bitmask & IRAT_PARAMS_CDMA_V920_E_CSFB_CONC_PS_MOB_1XRTT_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_cdma2000_v920->eCSFB_conc_ps_mobility_1xrtt_r9, p_src + *p_length_read, "eCSFB_conc_ps_mobility_1xrtt_r9");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_csg_proximity_indication_parameters_r9
(
    csg_proximity_indication_parameters_r9_t *p_csg_proximity_indication_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_csg_proximity_indication_parameters_r9, 0, sizeof(csg_proximity_indication_parameters_r9_t));

    /* This function parses csg_proximity_indication_parameters_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csg_proximity_indication_parameters_r9->intra_freq_proximity_indication_supported_r9, p_src + *p_length_read, "intra_freq_proximity_indication_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csg_proximity_indication_parameters_r9->intra_freq_proximity_indication_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csg_proximity_indication_parameters_r9->intra_freq_proximity_indication_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csg_proximity_indication_parameters_r9->intra_freq_proximity_indication_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csg_proximity_indication_parameters_r9->inter_freq_proximity_indication_supported_r9, p_src + *p_length_read, "inter_freq_proximity_indication_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csg_proximity_indication_parameters_r9->inter_freq_proximity_indication_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csg_proximity_indication_parameters_r9->inter_freq_proximity_indication_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csg_proximity_indication_parameters_r9->inter_freq_proximity_indication_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_csg_proximity_indication_parameters_r9->utran_proximity_indication_supported_r9, p_src + *p_length_read, "utran_proximity_indication_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_csg_proximity_indication_parameters_r9->utran_proximity_indication_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_csg_proximity_indication_parameters_r9->utran_proximity_indication_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_csg_proximity_indication_parameters_r9->utran_proximity_indication_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_neigh_cell_si_acquisition_parameters_r9
(
    neigh_cell_si_acquisition_parameters_r9_t *p_neigh_cell_si_acquisition_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_neigh_cell_si_acquisition_parameters_r9, 0, sizeof(neigh_cell_si_acquisition_parameters_r9_t));

    /* This function parses neigh_cell_si_acquisition_parameters_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_si_acquisition_parameters_r9->intra_freq_si_acquisition_for_ho_supported_r9, p_src + *p_length_read, "intra_freq_si_acquisition_for_ho_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell_si_acquisition_parameters_r9->intra_freq_si_acquisition_for_ho_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_si_acquisition_parameters_r9->intra_freq_si_acquisition_for_ho_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_neigh_cell_si_acquisition_parameters_r9->intra_freq_si_acquisition_for_ho_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_si_acquisition_parameters_r9->inter_freq_si_acquisition_for_ho_supported_r9, p_src + *p_length_read, "inter_freq_si_acquisition_for_ho_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell_si_acquisition_parameters_r9->inter_freq_si_acquisition_for_ho_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_si_acquisition_parameters_r9->inter_freq_si_acquisition_for_ho_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_neigh_cell_si_acquisition_parameters_r9->inter_freq_si_acquisition_for_ho_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_neigh_cell_si_acquisition_parameters_r9->utran_si_acquisition_for_ho_supported_r9, p_src + *p_length_read, "utran_si_acquisition_for_ho_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_neigh_cell_si_acquisition_parameters_r9->utran_si_acquisition_for_ho_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_neigh_cell_si_acquisition_parameters_r9->utran_si_acquisition_for_ho_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_neigh_cell_si_acquisition_parameters_r9->utran_si_acquisition_for_ho_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_son_parameters_r9
(
    son_parameters_r9_t *p_son_parameters_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_son_parameters_r9, 0, sizeof(son_parameters_r9_t));

    /* This function parses son_parameters_r9 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_son_parameters_r9->rach_report_supported_r9, p_src + *p_length_read, "rach_report_supported_r9");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_son_parameters_r9->rach_report_supported_r9 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_son_parameters_r9->rach_report_supported_r9] should be less than"
            " or equal to 1. Incorrect value %u received.", p_son_parameters_r9->rach_report_supported_r9);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_addxdd_mode_r9
(
    ue_eutra_capability_addxdd_mode_r9_t *p_ue_eutra_capability_addxdd_mode_r9,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_addxdd_mode_r9, 0, sizeof(ue_eutra_capability_addxdd_mode_r9_t));

    /* This function parses ue_eutra_capability_addxdd_mode_r9 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_addxdd_mode_r9->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_PHY_LAYER_PARAMETERS_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_physical_layer_params(
        &p_ue_eutra_capability_addxdd_mode_r9->phy_layer_parameters_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_INDICATORS_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_ue_eutra_capability_addxdd_mode_r9->feature_group_indicators_r9) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_ue_eutra_capability_addxdd_mode_r9->feature_group_indicators_r9); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_ue_eutra_capability_addxdd_mode_r9->feature_group_indicators_r9[loop], (void*)(p_src + *p_length_read), "feature_group_indicators_r9[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_R9ADD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_ue_eutra_capability_addxdd_mode_r9->feature_group_ind_rel9add_r9) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_ue_eutra_capability_addxdd_mode_r9->feature_group_ind_rel9add_r9); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_ue_eutra_capability_addxdd_mode_r9->feature_group_ind_rel9add_r9[loop], (void*)(p_src + *p_length_read), "feature_group_ind_rel9add_r9[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_GERAN_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_geran(
        &p_ue_eutra_capability_addxdd_mode_r9->inter_rat_parameters_geran_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_UTRA_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_utra_v920(
        &p_ue_eutra_capability_addxdd_mode_r9->inter_rat_parameters_utra_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMETERS_CDMA2000_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_cdma2000_v920(
        &p_ue_eutra_capability_addxdd_mode_r9->inter_rat_parameters_cdma2000_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_r9->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_NEIGH_CELLSI_ACQUISITION_PARAMS_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_si_acquisition_parameters_r9(
        &p_ue_eutra_capability_addxdd_mode_r9->neigh_cellsi_acquisition_parameters_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_v9c0
(
    irat_parameters_utra_v9c0_t *p_irat_parameters_utra_v9c0,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_utra_v9c0, 0, sizeof(irat_parameters_utra_v9c0_t));

    /* This function parses irat_parameters_utra_v9c0 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_irat_parameters_utra_v9c0->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_irat_parameters_utra_v9c0->bitmask & VOICEOVERPS_HS_UTRA_FDD_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->voice_over_ps_hs_utra_fdd_r9, p_src + *p_length_read, "voice_over_ps_hs_utra_fdd_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_irat_parameters_utra_v9c0->bitmask & VOICEOVERPS_HS_UTRA_TDD_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->voice_over_ps_hs_utra_tdd128_r9, p_src + *p_length_read, "voice_over_ps_hs_utra_tdd128_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_irat_parameters_utra_v9c0->bitmask & SRVCC_FROM_UTRA_FDD_TO_UTRA_FDD_r9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->srvcc_from_utra_fdd_to_utra_fdd_r9, p_src + *p_length_read, "srvcc_from_utra_fdd_to_utra_fdd_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_irat_parameters_utra_v9c0->bitmask & SRVCC_FROM_UTRA_FDD_TO_GERAN_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->srvcc_from_utra_fdd_to_geran_r9, p_src + *p_length_read, "srvcc_from_utra_fdd_to_geran_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_irat_parameters_utra_v9c0->bitmask & SRVCC_FROM_UTRA_TDD128_TO_UTRA_TDD128_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->srvcc_from_utra_tdd128_to_utra_tdd128_r9, p_src + *p_length_read, "srvcc_from_utra_tdd128_to_utra_tdd128_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_irat_parameters_utra_v9c0->bitmask & SRVCC_FROM_UTRA_TDD128_TO_GERAN_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_v9c0->srvcc_from_utra_tdd128_to_geran_r9, p_src + *p_length_read, "srvcc_from_utra_tdd128_to_geran_r9");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v9c0_ies
(
    ue_eutra_capability_v9c0_ies_t *p_ue_eutra_capability_v9c0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v9c0_ies, 0, sizeof(ue_eutra_capability_v9c0_ies_t));

    /* This function parses ue_eutra_capability_v9c0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v9c0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v9c0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_IRAT_PARAMS_UTRA_v9c0_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_utra_v9c0(
        &p_ue_eutra_capability_v9c0_ies->inter_rat_parameters_utra_v9c0,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v9a0_ies
(
    ue_eutra_capability_v9a0_ies_t *p_ue_eutra_capability_v9a0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v9a0_ies, 0, sizeof(ue_eutra_capability_v9a0_ies_t));

    /* This function parses ue_eutra_capability_v9a0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v9a0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v9a0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_FEATURE_GRP_IND_REL9_ADD_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_ue_eutra_capability_v9a0_ies->feature_group_ind_rel9add_r9) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_ue_eutra_capability_v9a0_ies->feature_group_ind_rel9add_r9); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_ue_eutra_capability_v9a0_ies->feature_group_ind_rel9add_r9[loop], (void*)(p_src + *p_length_read), "feature_group_ind_rel9add_r9[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_ue_eutra_capability_v9a0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_ADDFDD_MODE_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_addxdd_mode_r9(
        &p_ue_eutra_capability_v9a0_ies->fdd_add_ue_eutra_capabilities_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v9a0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_ADDTDD_MODE_R9_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_addxdd_mode_r9(
        &p_ue_eutra_capability_v9a0_ies->tdd_add_ue_eutra_capabilities_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v9a0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V9c0_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v9c0_ies(
        &p_ue_eutra_capability_v9a0_ies->ue_eutra_capability_v9c0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_noncontiguousul_ra_withincc_r10_ies
(
    noncontiguousul_ra_withincc_r10_ies_t *p_noncontiguousul_ra_withincc_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_noncontiguousul_ra_withincc_r10_ies, 0, sizeof(noncontiguousul_ra_withincc_r10_ies_t));

    /* This function parses noncontiguousul_ra_withincc_r10_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_noncontiguousul_ra_withincc_r10_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_noncontiguousul_ra_withincc_r10_ies->bitmask & RRC_RRM_NONCONTIGUOUSUL_RA_WITHINCC_INFO_R10)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_noncontiguousul_ra_withincc_r10_ies->noncontiguousul_ra_withincc_info_r10, p_src + *p_length_read, "noncontiguousul_ra_withincc_info_r10");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_noncontiguousul_ra_withincc_list_r10_ies
(
    noncontiguousul_ra_withincc_list_r10_ies_t *p_noncontiguousul_ra_withincc_list_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_noncontiguousul_ra_withincc_list_r10_ies, 0, sizeof(noncontiguousul_ra_withincc_list_r10_ies_t));

    /* This function parses noncontiguousul_ra_withincc_list_r10_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_noncontiguousul_ra_withincc_list_r10_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_noncontiguousul_ra_withincc_list_r10_ies->count < 1) || (p_noncontiguousul_ra_withincc_list_r10_ies->count > MAX_BAND_EUTRA))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_noncontiguousul_ra_withincc_list_r10_ies->count] should be in range "
            "1 to MAX_BAND_EUTRA. Incorrect value %u received.", p_noncontiguousul_ra_withincc_list_r10_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_noncontiguousul_ra_withincc_list_r10_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_noncontiguousul_ra_withincc_r10_ies(
                &p_noncontiguousul_ra_withincc_list_r10_ies->noncontiguousul_ra_withincc_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_phylayer_parameters_v1020_ies
(
    phylayer_parameters_v1020_ies_t *p_phylayer_parameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_phylayer_parameters_v1020_ies, 0, sizeof(phylayer_parameters_v1020_ies_t));

    /* This function parses phylayer_parameters_v1020_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_phylayer_parameters_v1020_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_TWO_ANTENNA_PORTS_FOR_PUCCH_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->two_antenna_ports_for_pucch_r10, p_src + *p_length_read, "two_antenna_ports_for_pucch_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_TM9_WITH_8TX_FDD_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->tm9_with_8tx_fdd_r10, p_src + *p_length_read, "tm9_with_8tx_fdd_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_PMI_DISABLING_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->pmi_disabling_r10, p_src + *p_length_read, "pmi_disabling_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_CROSS_CARRIER_SCHEDULING_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->cross_carrier_scheduling_r10, p_src + *p_length_read, "cross_carrier_scheduling_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_SIMULTANEOUS_PUCCH_PUSCH_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->simultaneous_pucch_pusch_r10, p_src + *p_length_read, "simultaneous_pucch_pusch_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_MULTI_CLUSTER_PUSCH_WITHINCC_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_phylayer_parameters_v1020_ies->multi_cluster_pusch_withincc_r10, p_src + *p_length_read, "multi_cluster_pusch_withincc_r10");
    *p_length_read += sizeof(U8);
    }

    if (p_phylayer_parameters_v1020_ies->bitmask & RRC_RRM_MULTI_NONCONTIGUOUSUL_RA_WITHINCC_LIST_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_noncontiguousul_ra_withincc_list_r10_ies(
        &p_phylayer_parameters_v1020_ies->noncontiguousul_ra_withincc_list_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_ul_r10
(
    ca_mimo_parameters_ul_r10_t *p_ca_mimo_parameters_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ca_mimo_parameters_ul_r10, 0, sizeof(ca_mimo_parameters_ul_r10_t));

    /* This function parses ca_mimo_parameters_ul_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_ul_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_ul_r10->ca_band_width_class_ul_r10, p_src + *p_length_read, "ca_band_width_class_ul_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_ul_r10->ca_band_width_class_ul_r10 > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_ul_r10->ca_band_width_class_ul_r10] should be less than"
            " or equal to 5. Incorrect value %u received.", p_ca_mimo_parameters_ul_r10->ca_band_width_class_ul_r10);
        return RRC_FAILURE;
    }

    if (p_ca_mimo_parameters_ul_r10->bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_UL_R10_IE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_ul_r10->supported_mimo_capability_ul_r10, p_src + *p_length_read, "supported_mimo_capability_ul_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_ul_r10->supported_mimo_capability_ul_r10 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_ul_r10->supported_mimo_capability_ul_r10] should be less than"
            " or equal to 1. Incorrect value %u received.", p_ca_mimo_parameters_ul_r10->supported_mimo_capability_ul_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_ul_r10
(
    band_parameters_ul_r10_t *p_band_parameters_ul_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_ul_r10, 0, sizeof(band_parameters_ul_r10_t));

    /* This function parses band_parameters_ul_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_ul_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_ul_r10->count < 1) || (p_band_parameters_ul_r10->count > MAX_BANDWIDTH_CLASS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_ul_r10->count] should be in range "
            "1 to MAX_BANDWIDTH_CLASS_R10. Incorrect value %u received.", p_band_parameters_ul_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_parameters_ul_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_ca_mimo_parameters_ul_r10(
                &p_band_parameters_ul_r10->ca_mimo_parameters_ul_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_dl_r10
(
    ca_mimo_parameters_dl_r10_t *p_ca_mimo_parameters_dl_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ca_mimo_parameters_dl_r10, 0, sizeof(ca_mimo_parameters_dl_r10_t));

    /* This function parses ca_mimo_parameters_dl_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r10->ca_band_width_class_dl_r10, p_src + *p_length_read, "ca_band_width_class_dl_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_dl_r10->ca_band_width_class_dl_r10 > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_dl_r10->ca_band_width_class_dl_r10] should be less than"
            " or equal to 5. Incorrect value %u received.", p_ca_mimo_parameters_dl_r10->ca_band_width_class_dl_r10);
        return RRC_FAILURE;
    }

    if (p_ca_mimo_parameters_dl_r10->bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r10->supported_mimo_capability_dl_r10, p_src + *p_length_read, "supported_mimo_capability_dl_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_dl_r10->supported_mimo_capability_dl_r10 > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_dl_r10->supported_mimo_capability_dl_r10] should be less than"
            " or equal to 2. Incorrect value %u received.", p_ca_mimo_parameters_dl_r10->supported_mimo_capability_dl_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_dl_r10
(
    band_parameters_dl_r10_t *p_band_parameters_dl_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_dl_r10, 0, sizeof(band_parameters_dl_r10_t));

    /* This function parses band_parameters_dl_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_dl_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_dl_r10->count < 1) || (p_band_parameters_dl_r10->count > MAX_BANDWIDTH_CLASS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_dl_r10->count] should be in range "
            "1 to MAX_BANDWIDTH_CLASS_R10. Incorrect value %u received.", p_band_parameters_dl_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_parameters_dl_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_ca_mimo_parameters_dl_r10(
                &p_band_parameters_dl_r10->ca_mimo_parameters_dl_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_r10
(
    band_parameters_r10_t *p_band_parameters_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_r10, 0, sizeof(band_parameters_r10_t));

    /* This function parses band_parameters_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_r10->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_r10->band_eutra_r10, p_src + *p_length_read, "band_eutra_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_r10->band_eutra_r10 < 1) || (p_band_parameters_r10->band_eutra_r10 > MAX_FREQ_BAND_INDICATOR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_r10->band_eutra_r10] should be in range "
            "1 to MAX_FREQ_BAND_INDICATOR. Incorrect value %u received.", p_band_parameters_r10->band_eutra_r10);
        return RRC_FAILURE;
    }

    if (p_band_parameters_r10->bitmask & RRC_RRM_BAND_PARAMETERS_UL_R10_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_ul_r10(
        &p_band_parameters_r10->band_parameters_ul_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_band_parameters_r10->bitmask & RRC_RRM_BAND_PARAMETERS_DL_R10_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_dl_r10(
        &p_band_parameters_r10->band_parameters_dl_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r10
(
    band_combination_parameters_r10_t *p_band_combination_parameters_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_r10, 0, sizeof(band_combination_parameters_r10_t));

    /* This function parses band_combination_parameters_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_combination_parameters_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_parameters_r10->count < 1) || (p_band_combination_parameters_r10->count > MAX_SIM_BANDS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_parameters_r10->count] should be in range "
            "1 to MAX_SIM_BANDS_R10. Incorrect value %u received.", p_band_combination_parameters_r10->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_parameters_r10->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_parameters_r10(
                &p_band_combination_parameters_r10->band_parameters_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_combination_r10_ies
(
    supported_band_combination_r10_ies_t *p_supported_band_combination_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_combination_r10_ies, 0, sizeof(supported_band_combination_r10_ies_t));

    /* This function parses supported_band_combination_r10_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_combination_r10_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_combination_r10_ies->count < 1) || (p_supported_band_combination_r10_ies->count > MAX_BAND_COMB_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_combination_r10_ies->count] should be in range "
            "1 to MAX_BAND_COMB_R10. Incorrect value %u received.", p_supported_band_combination_r10_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_combination_r10_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_r10(
                &p_supported_band_combination_r10_ies->band_combination_parameters_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_v1020_ies
(
    rf_parameters_v1020_ies_t *p_rf_parameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_v1020_ies, 0, sizeof(rf_parameters_v1020_ies_t));

    /* This function parses rf_parameters_v1020_ies */

    if (RRC_FAILURE == rrc_il_parse_supported_band_combination_r10_ies(
        &p_rf_parameters_v1020_ies->supported_band_combination_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_list_eutra_r10_ies
(
    band_combination_list_eutra_r10_ies_t *p_band_combination_list_eutra_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_list_eutra_r10_ies, 0, sizeof(band_combination_list_eutra_r10_ies_t));

    /* This function parses band_combination_list_eutra_r10_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_combination_list_eutra_r10_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_list_eutra_r10_ies->count < 1) || (p_band_combination_list_eutra_r10_ies->count > MAX_BAND_COMB_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_list_eutra_r10_ies->count] should be in range "
            "1 to MAX_BAND_COMB_R10. Incorrect value %u received.", p_band_combination_list_eutra_r10_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_list_eutra_r10_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_info_eutra(
                &p_band_combination_list_eutra_r10_ies->band_info_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_measparameters_v1020_ies
(
    measparameters_v1020_ies_t *p_measparameters_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_measparameters_v1020_ies, 0, sizeof(measparameters_v1020_ies_t));

    /* This function parses measparameters_v1020_ies */

    if (RRC_FAILURE == rrc_il_parse_band_combination_list_eutra_r10_ies(
        &p_measparameters_v1020_ies->band_combination_list_eutra_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_cdma2000_v1020
(
    irat_parameters_cdma2000_v1020_t *p_irat_parameters_cdma2000_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_cdma2000_v1020, 0, sizeof(irat_parameters_cdma2000_v1020_t));

    /* This function parses irat_parameters_cdma2000_v1020 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_cdma2000_v1020->eCSFB_dual_1xrtt_r10, p_src + *p_length_read, "eCSFB_dual_1xrtt_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_parameters_cdma2000_v1020->eCSFB_dual_1xrtt_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_parameters_cdma2000_v1020->eCSFB_dual_1xrtt_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_irat_parameters_cdma2000_v1020->eCSFB_dual_1xrtt_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_utra_tdd_v1020
(
    irat_parameters_utra_tdd_v1020_t *p_irat_parameters_utra_tdd_v1020,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_utra_tdd_v1020, 0, sizeof(irat_parameters_utra_tdd_v1020_t));

    /* This function parses irat_parameters_utra_tdd_v1020 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_parameters_utra_tdd_v1020->e_redirection_utra_tdd_r10, p_src + *p_length_read, "e_redirection_utra_tdd_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_parameters_utra_tdd_v1020->e_redirection_utra_tdd_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_parameters_utra_tdd_v1020->e_redirection_utra_tdd_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_irat_parameters_utra_tdd_v1020->e_redirection_utra_tdd_r10);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_addxdd_mode_v1060
(
    ue_eutra_capability_addxdd_mode_v1060_t *p_ue_eutra_capability_addxdd_mode_v1060,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_addxdd_mode_v1060, 0, sizeof(ue_eutra_capability_addxdd_mode_v1060_t));

    /* This function parses ue_eutra_capability_addxdd_mode_v1060 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_addxdd_mode_v1060->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_addxdd_mode_v1060->bitmask & RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_PHY_LAYER_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_phylayer_parameters_v1020_ies(
        &p_ue_eutra_capability_addxdd_mode_v1060->phylayer_parameter_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_v1060->bitmask & RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_FEATURE_GRP_IND_REL10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_ue_eutra_capability_addxdd_mode_v1060->featuregroup_ind_r10_v1060) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_ue_eutra_capability_addxdd_mode_v1060->featuregroup_ind_r10_v1060); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_ue_eutra_capability_addxdd_mode_v1060->featuregroup_ind_r10_v1060[loop], (void*)(p_src + *p_length_read), "featuregroup_ind_r10_v1060[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_ue_eutra_capability_addxdd_mode_v1060->bitmask & RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_cdma2000_v1020(
        &p_ue_eutra_capability_addxdd_mode_v1060->inter_rat_parameters_cdma2000_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_addxdd_mode_v1060->bitmask & RRC_RRM_UE_EUTRA_CAPABILITIES_v1060_IRAT_PARAMS_UTRA_TDD_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_utra_tdd_v1020(
        &p_ue_eutra_capability_addxdd_mode_v1060->inter_rat_parameters_utra_tdd_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_width_combination_set_r10
(
    supported_band_width_combination_set_r10_t *p_supported_band_width_combination_set_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_supported_band_width_combination_set_r10, 0, sizeof(supported_band_width_combination_set_r10_t));

    /* This function parses supported_band_width_combination_set_r10 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_width_combination_set_r10->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_width_combination_set_r10->count < 1) || (p_supported_band_width_combination_set_r10->count > 4))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_width_combination_set_r10->count] should be in range "
            "1 to 4. Incorrect value %u received.", p_supported_band_width_combination_set_r10->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_supported_band_width_combination_set_r10->count * sizeof(p_supported_band_width_combination_set_r10->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_width_combination_set_r10->count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_supported_band_width_combination_set_r10->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_ext_r10
(
    band_combination_parameters_ext_r10_t *p_band_combination_parameters_ext_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_ext_r10, 0, sizeof(band_combination_parameters_ext_r10_t));

    /* This function parses band_combination_parameters_ext_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_combination_parameters_ext_r10->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (p_band_combination_parameters_ext_r10->presence_bitmask & RRC_RRM_SUPPORTED_BAND_WIDTH_COMB_SET_R10)
    {

    if (RRC_FAILURE == rrc_il_parse_supported_band_width_combination_set_r10(
        &p_band_combination_parameters_ext_r10->supported_band_width_combination_set_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_combination_ext_r10_ies
(
    supported_band_combination_ext_r10_ies_t *p_supported_band_combination_ext_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_combination_ext_r10_ies, 0, sizeof(supported_band_combination_ext_r10_ies_t));

    /* This function parses supported_band_combination_ext_r10_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_combination_ext_r10_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_combination_ext_r10_ies->count < 1) || (p_supported_band_combination_ext_r10_ies->count > MAX_BAND_COMB_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_combination_ext_r10_ies->count] should be in range "
            "1 to MAX_BAND_COMB_R10. Incorrect value %u received.", p_supported_band_combination_ext_r10_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_combination_ext_r10_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_ext_r10(
                &p_supported_band_combination_ext_r10_ies->band_combination_parameters_ext_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_v1060_ies
(
    rf_parameters_v1060_ies_t *p_rf_parameters_v1060_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_v1060_ies, 0, sizeof(rf_parameters_v1060_ies_t));

    /* This function parses rf_parameters_v1060_ies */

    if (RRC_FAILURE == rrc_il_parse_supported_band_combination_ext_r10_ies(
        &p_rf_parameters_v1060_ies->supported_band_combination_ext_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_v1090
(
    band_parameters_v1090_t *p_band_parameters_v1090,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_band_parameters_v1090, 0, sizeof(band_parameters_v1090_t));

    /* This function parses band_parameters_v1090 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_v1090->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_v1090->band_eutra_v1090, p_src + *p_length_read, "band_eutra_v1090");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_v1090
(
    band_combination_parameters_v1090_t *p_band_combination_parameters_v1090,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_v1090, 0, sizeof(band_combination_parameters_v1090_t));

    /* This function parses band_combination_parameters_v1090 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_combination_parameters_v1090->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_parameters_v1090->count < 1) || (p_band_combination_parameters_v1090->count > MAX_SIM_BANDS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_parameters_v1090->count] should be in range "
            "1 to MAX_SIM_BANDS_R10. Incorrect value %u received.", p_band_combination_parameters_v1090->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_parameters_v1090->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_parameters_v1090(
                &p_band_combination_parameters_v1090->band_parameters_v1090[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_combination_v1090_ies
(
    supported_band_combination_v1090_ies_t *p_supported_band_combination_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_combination_v1090_ies, 0, sizeof(supported_band_combination_v1090_ies_t));

    /* This function parses supported_band_combination_v1090_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_combination_v1090_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_combination_v1090_ies->count < 1) || (p_supported_band_combination_v1090_ies->count > MAX_BAND_COMB_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_combination_v1090_ies->count] should be in range "
            "1 to MAX_BAND_COMB_R10. Incorrect value %u received.", p_supported_band_combination_v1090_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_combination_v1090_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_v1090(
                &p_supported_band_combination_v1090_ies->band_combination_parameters_v1090[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_v1090_ies
(
    rf_parameters_v1090_ies_t *p_rf_parameters_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_v1090_ies, 0, sizeof(rf_parameters_v1090_ies_t));

    /* This function parses rf_parameters_v1090_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rf_parameters_v1090_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rf_parameters_v1090_ies->bitmask & RRC_RRM_RF_PARAMETERS_V1090_SUPPORTED_BAND_COMB_V1090_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_supported_band_combination_v1090_ies(
        &p_rf_parameters_v1090_ies->supported_band_combination_v1090_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_r11
(
    band_parameters_r11_t *p_band_parameters_r11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_r11, 0, sizeof(band_parameters_r11_t));

    /* This function parses band_parameters_r11 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_r11->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_r11->band_eutra_r11, p_src + *p_length_read, "band_eutra_r11");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_r11->band_eutra_r11 < 1) || (p_band_parameters_r11->band_eutra_r11 > 256))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_r11->band_eutra_r11] should be in range "
            "1 to 256. Incorrect value %u received.", p_band_parameters_r11->band_eutra_r11);
        return RRC_FAILURE;
    }

    if (p_band_parameters_r11->bitmask & RRC_RRM_BAND_PARAMETERS_UL_R11_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_ul_r10(
        &p_band_parameters_r11->band_parameters_ul_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_band_parameters_r11->bitmask & RRC_RRM_BAND_PARAMETERS_DL_R11_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_dl_r10(
        &p_band_parameters_r11->band_parameters_dl_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r11
(
    band_combination_parameters_r11_t *p_band_combination_parameters_r11,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_r11, 0, sizeof(band_combination_parameters_r11_t));

    /* This function parses band_combination_parameters_r11 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_combination_parameters_r11->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_parameters_r11->count < 1) || (p_band_combination_parameters_r11->count > MAX_SIM_BANDS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_parameters_r11->count] should be in range "
            "1 to MAX_SIM_BANDS_R10. Incorrect value %u received.", p_band_combination_parameters_r11->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_parameters_r11->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_parameters_r11(
                &p_band_combination_parameters_r11->band_parameters_r11[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_combination_add_r11_ies
(
    supported_band_combination_add_r11_ies_t *p_supported_band_combination_add_r11_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_combination_add_r11_ies, 0, sizeof(supported_band_combination_add_r11_ies_t));

    /* This function parses supported_band_combination_add_r11_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_combination_add_r11_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [L - lower boundary] */
    if ((p_supported_band_combination_add_r11_ies->count < 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_combination_add_r11_ies->count] should be greater than"
            " or equal to 1. Incorrect value %u received.", p_supported_band_combination_add_r11_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_combination_add_r11_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_r11(
                &p_supported_band_combination_add_r11_ies->band_combination_parameters_r11[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_v1180_ies
(
    rf_parameters_v1180_ies_t *p_rf_parameters_v1180_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_v1180_ies, 0, sizeof(rf_parameters_v1180_ies_t));

    /* This function parses rf_parameters_v1180_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rf_parameters_v1180_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rf_parameters_v1180_ies->bitmask & RRC_RRM_RF_PARAMETERS_V1180_SUPPORTED_BAND_COMB_ADD_R11_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_supported_band_combination_add_r11_ies(
        &p_rf_parameters_v1180_ies->supported_band_combination_add_r11_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pdcp_parameters_v1310
(
    pdcp_parameters_v1310_t *p_pdcp_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pdcp_parameters_v1310, 0, sizeof(pdcp_parameters_v1310_t));

    /* This function parses pdcp_parameters_v1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pdcp_parameters_v1310->pdcp_sn_ext_18bits_supported_r13, p_src + *p_length_read, "pdcp_sn_ext_18bits_supported_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pdcp_parameters_v1310->pdcp_sn_ext_18bits_supported_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pdcp_parameters_v1310->pdcp_sn_ext_18bits_supported_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pdcp_parameters_v1310->pdcp_sn_ext_18bits_supported_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rlc_parameters_v1310
(
    rlc_parameters_v1310_t *p_rlc_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rlc_parameters_v1310, 0, sizeof(rlc_parameters_v1310_t));

    /* This function parses rlc_parameters_v1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rlc_parameters_v1310->rlc_sn_so_field_supported_r13, p_src + *p_length_read, "rlc_sn_so_field_supported_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rlc_parameters_v1310->rlc_sn_so_field_supported_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rlc_parameters_v1310->rlc_sn_so_field_supported_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rlc_parameters_v1310->rlc_sn_so_field_supported_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_ul_r13
(
    band_parameters_ul_r13_t *p_band_parameters_ul_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_ul_r13, 0, sizeof(band_parameters_ul_r13_t));

    /* This function parses band_parameters_ul_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_ul_r13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_ul_r13->count < 1) || (p_band_parameters_ul_r13->count > MAX_BANDWIDTH_CLASS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_ul_r13->count] should be in range "
            "1 to MAX_BANDWIDTH_CLASS_R10. Incorrect value %u received.", p_band_parameters_ul_r13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_parameters_ul_r13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_ca_mimo_parameters_ul_r10(
                &p_band_parameters_ul_r13->ca_mimo_parameters_ul_r10[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_intra_band_contiguous_cc_info_r12
(
    intra_band_contiguous_cc_info_r12_t *p_intra_band_contiguous_cc_info_r12,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_intra_band_contiguous_cc_info_r12, 0, sizeof(intra_band_contiguous_cc_info_r12_t));

    /* This function parses intra_band_contiguous_cc_info_r12 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_band_contiguous_cc_info_r12->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (p_intra_band_contiguous_cc_info_r12->bitmask & FOUR_LAYER_TM3_TM4_PER_CC_R12_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_band_contiguous_cc_info_r12->four_layer_tm3_tm4_per_cc_r12, p_src + *p_length_read, "four_layer_tm3_tm4_per_cc_r12");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_band_contiguous_cc_info_r12->four_layer_tm3_tm4_per_cc_r12 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_band_contiguous_cc_info_r12->four_layer_tm3_tm4_per_cc_r12] should be less than"
            " or equal to 0. Incorrect value %u received.", p_intra_band_contiguous_cc_info_r12->four_layer_tm3_tm4_per_cc_r12);
        return RRC_FAILURE;
    }
    }

    if (p_intra_band_contiguous_cc_info_r12->bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_band_contiguous_cc_info_r12->supported_mimo_capability_dl_r12, p_src + *p_length_read, "supported_mimo_capability_dl_r12");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_band_contiguous_cc_info_r12->supported_mimo_capability_dl_r12 > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_band_contiguous_cc_info_r12->supported_mimo_capability_dl_r12] should be less than"
            " or equal to 2. Incorrect value %u received.", p_intra_band_contiguous_cc_info_r12->supported_mimo_capability_dl_r12);
        return RRC_FAILURE;
    }
    }

    if (p_intra_band_contiguous_cc_info_r12->bitmask & SUPPORTED_CSI_PROC_R12_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_band_contiguous_cc_info_r12->supported_csi_proc_r12, p_src + *p_length_read, "supported_csi_proc_r12");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_intra_band_contiguous_cc_info_r12->supported_csi_proc_r12 > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_band_contiguous_cc_info_r12->supported_csi_proc_r12] should be less than"
            " or equal to 2. Incorrect value %u received.", p_intra_band_contiguous_cc_info_r12->supported_csi_proc_r12);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_intra_band_contiguous_cc_info_list_r13
(
    intra_band_contiguous_cc_info_list_r13_t *p_intra_band_contiguous_cc_info_list_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_intra_band_contiguous_cc_info_list_r13, 0, sizeof(intra_band_contiguous_cc_info_list_r13_t));

    /* This function parses intra_band_contiguous_cc_info_list_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_intra_band_contiguous_cc_info_list_r13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_intra_band_contiguous_cc_info_list_r13->count < 1) || (p_intra_band_contiguous_cc_info_list_r13->count > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_intra_band_contiguous_cc_info_list_r13->count] should be in range "
            "1 to 32. Incorrect value %u received.", p_intra_band_contiguous_cc_info_list_r13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_intra_band_contiguous_cc_info_list_r13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_intra_band_contiguous_cc_info_r12(
                &p_intra_band_contiguous_cc_info_list_r13->intra_band_contiguous_cc_info_r12[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ca_mimo_parameters_dl_r13
(
    ca_mimo_parameters_dl_r13_t *p_ca_mimo_parameters_dl_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ca_mimo_parameters_dl_r13, 0, sizeof(ca_mimo_parameters_dl_r13_t));

    /* This function parses ca_mimo_parameters_dl_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r13->ca_band_width_class_dl_r10, p_src + *p_length_read, "ca_band_width_class_dl_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_dl_r13->ca_band_width_class_dl_r10 > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_dl_r13->ca_band_width_class_dl_r10] should be less than"
            " or equal to 5. Incorrect value %u received.", p_ca_mimo_parameters_dl_r13->ca_band_width_class_dl_r10);
        return RRC_FAILURE;
    }

    if (p_ca_mimo_parameters_dl_r13->bitmask & RRC_RRM_SUPPORTED_MIMO_CAPABILITY_DL_R10_IE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ca_mimo_parameters_dl_r13->supported_mimo_capability_dl_r10, p_src + *p_length_read, "supported_mimo_capability_dl_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ca_mimo_parameters_dl_r13->supported_mimo_capability_dl_r10 > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ca_mimo_parameters_dl_r13->supported_mimo_capability_dl_r10] should be less than"
            " or equal to 2. Incorrect value %u received.", p_ca_mimo_parameters_dl_r13->supported_mimo_capability_dl_r10);
        return RRC_FAILURE;
    }
    }

    if (RRC_FAILURE == rrc_il_parse_intra_band_contiguous_cc_info_list_r13(
        &p_ca_mimo_parameters_dl_r13->intra_band_contiguous_cc_info_list_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_dl_r13
(
    band_parameters_dl_r13_t *p_band_parameters_dl_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_dl_r13, 0, sizeof(band_parameters_dl_r13_t));

    /* This function parses band_parameters_dl_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_parameters_dl_r13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_dl_r13->count < 1) || (p_band_parameters_dl_r13->count > MAX_BANDWIDTH_CLASS_R13))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_dl_r13->count] should be in range "
            "1 to MAX_BANDWIDTH_CLASS_R13. Incorrect value %u received.", p_band_parameters_dl_r13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_parameters_dl_r13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_ca_mimo_parameters_dl_r13(
                &p_band_parameters_dl_r13->ca_mimo_parameters_dl_r13[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_r13
(
    band_parameters_r13_t *p_band_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters_r13, 0, sizeof(band_parameters_r13_t));

    /* This function parses band_parameters_r13 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_r13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_r13->band_eutra_r13, p_src + *p_length_read, "band_eutra_r13");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_r13->band_eutra_r13 < 1) || (p_band_parameters_r13->band_eutra_r13 > 64))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_r13->band_eutra_r13] should be in range "
            "1 to 64. Incorrect value %u received.", p_band_parameters_r13->band_eutra_r13);
        return RRC_FAILURE;
    }

    if (p_band_parameters_r13->bitmask & RRC_RRM_BAND_PARAMETERS_UL_R13_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_ul_r13(
        &p_band_parameters_r13->band_parameters_ul_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_band_parameters_r13->bitmask & RRC_RRM_BAND_PARAMETERS_DL_R13_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_dl_r13(
        &p_band_parameters_r13->band_parameters_dl_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r13_bandParameterList_r13
(
    band_combination_parameters_r13_bandParameterList_r13_t *p_band_combination_parameters_r13_bandParameterList_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_r13_bandParameterList_r13, 0, sizeof(band_combination_parameters_r13_bandParameterList_r13_t));

    /* This function parses band_combination_parameters_r13_bandParameterList_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_band_combination_parameters_r13_bandParameterList_r13->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_combination_parameters_r13_bandParameterList_r13->count < 1) || (p_band_combination_parameters_r13_bandParameterList_r13->count > MAX_SIM_BANDS_R10))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_parameters_r13_bandParameterList_r13->count] should be in range "
            "1 to MAX_SIM_BANDS_R10. Incorrect value %u received.", p_band_combination_parameters_r13_bandParameterList_r13->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_parameters_r13_bandParameterList_r13->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_parameters_r13(
                &p_band_combination_parameters_r13_bandParameterList_r13->band_parameters_r13[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_parameters_r13
(
    band_combination_parameters_r13_t *p_band_combination_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_parameters_r13, 0, sizeof(band_combination_parameters_r13_t));

    /* This function parses band_combination_parameters_r13 */

    if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_r13_bandParameterList_r13(
        &p_band_combination_parameters_r13->band_parameter_list_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_combination_reduced_r13_ies
(
    supported_band_combination_reduced_r13_ies_t *p_supported_band_combination_reduced_r13_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_combination_reduced_r13_ies, 0, sizeof(supported_band_combination_reduced_r13_ies_t));

    /* This function parses supported_band_combination_reduced_r13_ies */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_supported_band_combination_reduced_r13_ies->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_supported_band_combination_reduced_r13_ies->count < 1) || (p_supported_band_combination_reduced_r13_ies->count > 46))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_combination_reduced_r13_ies->count] should be in range "
            "1 to 46. Incorrect value %u received.", p_supported_band_combination_reduced_r13_ies->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_combination_reduced_r13_ies->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination_parameters_r13(
                &p_supported_band_combination_reduced_r13_ies->band_combination_parameters_r13[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_v1310_ies
(
    rf_parameters_v1310_ies_t *p_rf_parameters_v1310_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_v1310_ies, 0, sizeof(rf_parameters_v1310_ies_t));

    /* This function parses rf_parameters_v1310_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rf_parameters_v1310_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rf_parameters_v1310_ies->bitmask & RRC_RRM_RF_PARAMETERS_V1310_SUPPORTED_BAND_COMB_V1310_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_supported_band_combination_reduced_r13_ies(
        &p_rf_parameters_v1310_ies->supported_band_combination_reduced_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_parameters_wlan_r13
(
    irat_parameters_wlan_r13_t *p_irat_parameters_wlan_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_irat_parameters_wlan_r13, 0, sizeof(irat_parameters_wlan_r13_t));

    /* This function parses irat_parameters_wlan_r13 */

    if (*p_length_read + (S32)sizeof(p_irat_parameters_wlan_r13->supported_band_list_wlan_r13) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_irat_parameters_wlan_r13->supported_band_list_wlan_r13); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_irat_parameters_wlan_r13->supported_band_list_wlan_r13[loop], (void*)(p_src + *p_length_read), "supported_band_list_wlan_r13[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_laa_parameters_r13
(
    laa_parameters_r13_t *p_laa_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_laa_parameters_r13, 0, sizeof(laa_parameters_r13_t));

    /* This function parses laa_parameters_r13 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_laa_parameters_r13->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_laa_parameters_r13->bitmask & RRC_RRM_CROSS_CARRIER_SCHEDULING_LAA_DL_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->cross_carrier_scheduling_laa_dl_r13, p_src + *p_length_read, "cross_carrier_scheduling_laa_dl_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->cross_carrier_scheduling_laa_dl_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->cross_carrier_scheduling_laa_dl_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->cross_carrier_scheduling_laa_dl_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_CSI_RS_DRS_RRM_MEASUREMENTS_LAA_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->csi_rs_drs_rrm_measurements_laa_r13, p_src + *p_length_read, "csi_rs_drs_rrm_measurements_laa_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->csi_rs_drs_rrm_measurements_laa_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->csi_rs_drs_rrm_measurements_laa_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->csi_rs_drs_rrm_measurements_laa_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_DOWNLINK_LAA_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->downlink_laa_r13, p_src + *p_length_read, "downlink_laa_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->downlink_laa_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->downlink_laa_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->downlink_laa_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_ENDING_DWPTS_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->ending_DwPTS_r13, p_src + *p_length_read, "ending_DwPTS_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->ending_DwPTS_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->ending_DwPTS_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->ending_DwPTS_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_SECOND_SLOT_STARTING_POSITION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->second_slot_starting_position_r13, p_src + *p_length_read, "second_slot_starting_position_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->second_slot_starting_position_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->second_slot_starting_position_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->second_slot_starting_position_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_TM9_LAA_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->tm9_laa_r13, p_src + *p_length_read, "tm9_laa_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->tm9_laa_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->tm9_laa_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->tm9_laa_r13);
        return RRC_FAILURE;
    }
    }

    if (p_laa_parameters_r13->bitmask & RRC_RRM_TM10_LAA_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_laa_parameters_r13->tm10_laa_r13, p_src + *p_length_read, "tm10_laa_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_laa_parameters_r13->tm10_laa_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_laa_parameters_r13->tm10_laa_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_laa_parameters_r13->tm10_laa_r13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_wlan_iw_parameters_v1310
(
    wlan_iw_parameters_v1310_t *p_wlan_iw_parameters_v1310,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_wlan_iw_parameters_v1310, 0, sizeof(wlan_iw_parameters_v1310_t));

    /* This function parses wlan_iw_parameters_v1310 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_wlan_iw_parameters_v1310->rclwi_r13, p_src + *p_length_read, "rclwi_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_wlan_iw_parameters_v1310->rclwi_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_wlan_iw_parameters_v1310->rclwi_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_wlan_iw_parameters_v1310->rclwi_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_lwip_parameters_r13
(
    lwip_parameters_r13_t *p_lwip_parameters_r13,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_lwip_parameters_r13, 0, sizeof(lwip_parameters_r13_t));

    /* This function parses lwip_parameters_r13 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_lwip_parameters_r13->lwip_r13, p_src + *p_length_read, "lwip_r13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_lwip_parameters_r13->lwip_r13 > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_lwip_parameters_r13->lwip_r13] should be less than"
            " or equal to 1. Incorrect value %u received.", p_lwip_parameters_r13->lwip_r13);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_lwa_parameters
(
    ue_eutra_capability_lwa_parameters_t *p_ue_eutra_capability_lwa_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_lwa_parameters, 0, sizeof(ue_eutra_capability_lwa_parameters_t));

    /* This function parses ue_eutra_capability_lwa_parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_lwa_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_lwa_parameters->bitmask & LWA_CAPABILITY_LWA_SUPPORTED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_lwa_parameters->lwa_supported, p_src + *p_length_read, "lwa_supported");
    *p_length_read += sizeof(U8);
    }

    if (p_ue_eutra_capability_lwa_parameters->bitmask & LWA_CAPABILITY_SPLIT_BEARER_SUPPORTED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_lwa_parameters->split_bearer_supported, p_src + *p_length_read, "split_bearer_supported");
    *p_length_read += sizeof(U8);
    }

    if (p_ue_eutra_capability_lwa_parameters->bitmask & LWA_CAPABILITY_WLAN_MAC_ADDRESS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_lwa_parameters->wlan_mac_address, p_src + *p_length_read, "wlan_mac_address");
    *p_length_read += sizeof(U8);
    }

    if (p_ue_eutra_capability_lwa_parameters->bitmask & LWA_CAPABILITY_LWA_BUFFER_SIZE_SUPPORTED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_lwa_parameters->lwa_buffer_size_supported, p_src + *p_length_read, "lwa_buffer_size_supported");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityEmtcParamaters
(
    UeEutraCapabilityEmtcParamaters_t *p_UeEutraCapabilityEmtcParamaters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_UeEutraCapabilityEmtcParamaters, 0, sizeof(UeEutraCapabilityEmtcParamaters_t));

    /* This function parses UeEutraCapabilityEmtcParamaters */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_UeEutraCapabilityEmtcParamaters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (p_UeEutraCapabilityEmtcParamaters->bitmask & RRC_RRM_UE_CATEGORY_DL_V1310_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_UeEutraCapabilityEmtcParamaters->ueCategoryDlV1310, p_src + *p_length_read, "ueCategoryDlV1310");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_UeEutraCapabilityEmtcParamaters->ueCategoryDlV1310 > EMTC_DL_UE_CATEGORY_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_UeEutraCapabilityEmtcParamaters->ueCategoryDlV1310] should be less than"
            " or equal to EMTC_DL_UE_CATEGORY_MAX. Incorrect value %u received.", p_UeEutraCapabilityEmtcParamaters->ueCategoryDlV1310);
        return RRC_FAILURE;
    }
    }

    if (p_UeEutraCapabilityEmtcParamaters->bitmask & RRC_RRM_UE_CATEGORY_UL_V1310_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_UeEutraCapabilityEmtcParamaters->ueCategoryUlV1310, p_src + *p_length_read, "ueCategoryUlV1310");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_UeEutraCapabilityEmtcParamaters->ueCategoryUlV1310 > EMTC_UL_UE_CATEGORY_MAX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_UeEutraCapabilityEmtcParamaters->ueCategoryUlV1310] should be less than"
            " or equal to EMTC_UL_UE_CATEGORY_MAX. Incorrect value %u received.", p_UeEutraCapabilityEmtcParamaters->ueCategoryUlV1310);
        return RRC_FAILURE;
    }
    }

    if (p_UeEutraCapabilityEmtcParamaters->bitmask & RRC_RRM_CE_PARAMETERS_R13_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_UeEutraCapabilityEmtcParamaters->ceParametersR13, p_src + *p_length_read, "ceParametersR13");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_UeEutraCapabilityEmtcParamaters->ceParametersR13 > EMTC_CE_MODE_MAX_SUPPORTED))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_UeEutraCapabilityEmtcParamaters->ceParametersR13] should be less than"
            " or equal to EMTC_CE_MODE_MAX_SUPPORTED. Incorrect value %u received.", p_UeEutraCapabilityEmtcParamaters->ceParametersR13);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityIratParametersNrR15
(
    UeEutraCapabilityIratParametersNrR15_t *p_UeEutraCapabilityIratParametersNrR15,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_UeEutraCapabilityIratParametersNrR15, 0, sizeof(UeEutraCapabilityIratParametersNrR15_t));

    /* This function parses UeEutraCapabilityIratParametersNrR15 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_UeEutraCapabilityIratParametersNrR15->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_UeEutraCapabilityIratParametersNrR15->bitmask & RRC_RRM_EN_DC_R15_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_UeEutraCapabilityIratParametersNrR15->enDcR15Supported, p_src + *p_length_read, "enDcR15Supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_UeEutraCapabilityIratParametersNrR15->enDcR15Supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_UeEutraCapabilityIratParametersNrR15->enDcR15Supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_UeEutraCapabilityIratParametersNrR15->enDcR15Supported);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_UeEutraCapabilityEndcParamaters
(
    UeEutraCapabilityEndcParamaters_t *p_UeEutraCapabilityEndcParamaters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_UeEutraCapabilityEndcParamaters, 0, sizeof(UeEutraCapabilityEndcParamaters_t));

    /* This function parses UeEutraCapabilityEndcParamaters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_UeEutraCapabilityEndcParamaters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_UeEutraCapabilityEndcParamaters->bitmask & RRC_RRM_IRAT_PARAMETERS_NR_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_UeEutraCapabilityIratParametersNrR15(
        &p_UeEutraCapabilityEndcParamaters->iratParametersNrR15,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1510_ies
(
    ue_eutra_capability_v1510_ies_t *p_ue_eutra_capability_v1510_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1510_ies, 0, sizeof(ue_eutra_capability_v1510_ies_t));

    /* This function parses ue_eutra_capability_v1510_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1510_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1510_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_ENDC_PARAMETERS_R15_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_UeEutraCapabilityEndcParamaters(
        &p_ue_eutra_capability_v1510_ies->endcParameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1460_ies
(
    ue_eutra_capability_v1460_ies_t *p_ue_eutra_capability_v1460_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1460_ies, 0, sizeof(ue_eutra_capability_v1460_ies_t));

    /* This function parses ue_eutra_capability_v1460_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1460_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1460_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1510_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1510_ies(
        &p_ue_eutra_capability_v1460_ies->ue_eutra_capability_v1510_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1450_ies
(
    ue_eutra_capability_v1450_ies_t *p_ue_eutra_capability_v1450_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1450_ies, 0, sizeof(ue_eutra_capability_v1450_ies_t));

    /* This function parses ue_eutra_capability_v1450_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1450_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1450_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1460_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1460_ies(
        &p_ue_eutra_capability_v1450_ies->ue_eutra_capability_v1460_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1440_ies
(
    ue_eutra_capability_v1440_ies_t *p_ue_eutra_capability_v1440_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1440_ies, 0, sizeof(ue_eutra_capability_v1440_ies_t));

    /* This function parses ue_eutra_capability_v1440_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1440_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1440_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1450_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1450_ies(
        &p_ue_eutra_capability_v1440_ies->ue_eutra_capability_v1450_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1430_ies
(
    ue_eutra_capability_v1430_ies_t *p_ue_eutra_capability_v1430_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1430_ies, 0, sizeof(ue_eutra_capability_v1430_ies_t));

    /* This function parses ue_eutra_capability_v1430_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1430_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1430_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1440_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1440_ies(
        &p_ue_eutra_capability_v1430_ies->ue_eutra_capability_v1440_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1360_ies
(
    ue_eutra_capability_v1360_ies_t *p_ue_eutra_capability_v1360_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1360_ies, 0, sizeof(ue_eutra_capability_v1360_ies_t));

    /* This function parses ue_eutra_capability_v1360_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1360_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1360_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1430_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1430_ies(
        &p_ue_eutra_capability_v1360_ies->ue_eutra_capability_v1430_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1350_ies
(
    ue_eutra_capability_v1350_ies_t *p_ue_eutra_capability_v1350_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1350_ies, 0, sizeof(ue_eutra_capability_v1350_ies_t));

    /* This function parses ue_eutra_capability_v1350_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1350_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1350_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1360_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1360_ies(
        &p_ue_eutra_capability_v1350_ies->ue_eutra_capability_v1360_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1340_ies
(
    ue_eutra_capability_v1340_ies_t *p_ue_eutra_capability_v1340_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1340_ies, 0, sizeof(ue_eutra_capability_v1340_ies_t));

    /* This function parses ue_eutra_capability_v1340_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1340_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1340_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1350_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1350_ies(
        &p_ue_eutra_capability_v1340_ies->ue_eutra_capability_v1350_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1330_ies
(
    ue_eutra_capability_v1330_ies_t *p_ue_eutra_capability_v1330_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1330_ies, 0, sizeof(ue_eutra_capability_v1330_ies_t));

    /* This function parses ue_eutra_capability_v1330_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1330_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1330_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1340_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1340_ies(
        &p_ue_eutra_capability_v1330_ies->ue_eutra_capability_v1340_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1320_ies
(
    ue_eutra_capability_v1320_ies_t *p_ue_eutra_capability_v1320_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1320_ies, 0, sizeof(ue_eutra_capability_v1320_ies_t));

    /* This function parses ue_eutra_capability_v1320_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1320_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1320_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1330_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1330_ies(
        &p_ue_eutra_capability_v1320_ies->ue_eutra_capability_v1330_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1310_ies
(
    ue_eutra_capability_v1310_ies_t *p_ue_eutra_capability_v1310_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1310_ies, 0, sizeof(ue_eutra_capability_v1310_ies_t));

    /* This function parses ue_eutra_capability_v1310_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1310_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_pdcp_parameters_v1310(
        &p_ue_eutra_capability_v1310_ies->pdcp_parameters_v1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rlc_parameters_v1310(
        &p_ue_eutra_capability_v1310_ies->rlc_parameters_v1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ue_eutra_capability_v1310_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1310_RF_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_v1310_ies(
        &p_ue_eutra_capability_v1310_ies->rf_parameters_v1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_wlan_r13(
        &p_ue_eutra_capability_v1310_ies->inter_rat_parameters_wlan_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ue_eutra_capability_v1310_ies->bitmask & RRC_RRM_UE_LAA_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_laa_parameters_r13(
        &p_ue_eutra_capability_v1310_ies->laa_parameters_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_wlan_iw_parameters_v1310(
        &p_ue_eutra_capability_v1310_ies->wlan_iw_parameters_v1310,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_lwip_parameters_r13(
        &p_ue_eutra_capability_v1310_ies->lwip_parameters_r13,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ue_eutra_capability_v1310_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_LWA_PARAMETERS_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_lwa_parameters(
        &p_ue_eutra_capability_v1310_ies->lwa_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1310_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_EMTC_PARAMETERS_R13_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_UeEutraCapabilityEmtcParamaters(
        &p_ue_eutra_capability_v1310_ies->emtcParameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1310_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1320_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1320_ies(
        &p_ue_eutra_capability_v1310_ies->ue_eutra_capability_v1320_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1280_ies
(
    ue_eutra_capability_v1280_ies_t *p_ue_eutra_capability_v1280_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1280_ies, 0, sizeof(ue_eutra_capability_v1280_ies_t));

    /* This function parses ue_eutra_capability_v1280_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1280_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1280_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1310_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1310_ies(
        &p_ue_eutra_capability_v1280_ies->ue_eutra_capability_v1310_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1270_ies
(
    ue_eutra_capability_v1270_ies_t *p_ue_eutra_capability_v1270_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1270_ies, 0, sizeof(ue_eutra_capability_v1270_ies_t));

    /* This function parses ue_eutra_capability_v1270_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1270_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1270_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1280_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1280_ies(
        &p_ue_eutra_capability_v1270_ies->ue_eutra_capability_v1280_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1260_ies
(
    ue_eutra_capability_v1260_ies_t *p_ue_eutra_capability_v1260_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1260_ies, 0, sizeof(ue_eutra_capability_v1260_ies_t));

    /* This function parses ue_eutra_capability_v1260_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1260_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1260_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1270_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1270_ies(
        &p_ue_eutra_capability_v1260_ies->ue_eutra_capability_v1270_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1250_ies
(
    ue_eutra_capability_v1250_ies_t *p_ue_eutra_capability_v1250_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1250_ies, 0, sizeof(ue_eutra_capability_v1250_ies_t));

    /* This function parses ue_eutra_capability_v1250_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1250_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1250_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1260_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1260_ies(
        &p_ue_eutra_capability_v1250_ies->ue_eutra_capability_v1260_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v11a0_ies
(
    ue_eutra_capability_v11a0_ies_t *p_ue_eutra_capability_v11a0_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v11a0_ies, 0, sizeof(ue_eutra_capability_v11a0_ies_t));

    /* This function parses ue_eutra_capability_v11a0_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v11a0_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v11a0_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1250_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1250_ies(
        &p_ue_eutra_capability_v11a0_ies->ue_eutra_capability_v1250_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1180_ies
(
    ue_eutra_capability_v1180_ies_t *p_ue_eutra_capability_v1180_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1180_ies, 0, sizeof(ue_eutra_capability_v1180_ies_t));

    /* This function parses ue_eutra_capability_v1180_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1180_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1180_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1180_RF_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_v1180_ies(
        &p_ue_eutra_capability_v1180_ies->rf_parameters_v1180,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1180_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v11a0_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v11a0_ies(
        &p_ue_eutra_capability_v1180_ies->ue_eutra_capability_v11a0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1090_ies
(
    ue_eutra_capability_v1090_ies_t *p_ue_eutra_capability_v1090_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1090_ies, 0, sizeof(ue_eutra_capability_v1090_ies_t));

    /* This function parses ue_eutra_capability_v1090_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1090_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1090_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1090_RF_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_v1090_ies(
        &p_ue_eutra_capability_v1090_ies->rf_parameters_v1090,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1090_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1180_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1180_ies(
        &p_ue_eutra_capability_v1090_ies->ue_eutra_capability_v1180_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1060_ies
(
    ue_eutra_capability_v1060_ies_t *p_ue_eutra_capability_v1060_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1060_ies, 0, sizeof(ue_eutra_capability_v1060_ies_t));

    /* This function parses ue_eutra_capability_v1060_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1060_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1060_ies->bitmask & RRC_RRM_FDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_addxdd_mode_v1060(
        &p_ue_eutra_capability_v1060_ies->fdd_add_ue_eutra_capability_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1060_ies->bitmask & RRC_RRM_TDD_ADD_UE_EUTRA_CAPABILITIES_v1060_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_addxdd_mode_v1060(
        &p_ue_eutra_capability_v1060_ies->tdd_add_ue_eutra_capability_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1060_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1060_RF_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_v1060_ies(
        &p_ue_eutra_capability_v1060_ies->rf_parameters_v1060,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1060_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1090_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1090_ies(
        &p_ue_eutra_capability_v1060_ies->ue_eutra_capability_v1090_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_based_nw_perf_meas_params
(
    ue_based_nw_perf_meas_params_t *p_ue_based_nw_perf_meas_params,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_ue_based_nw_perf_meas_params, 0, sizeof(ue_based_nw_perf_meas_params_t));

    /* This function parses ue_based_nw_perf_meas_params */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_based_nw_perf_meas_params->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_based_nw_perf_meas_params->bitmask & RRC_RRM_LOGGED_MEAS_IDLE_UE_EUTRA_CAPABILITY_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_based_nw_perf_meas_params->logged_measurements_idle_r10, p_src + *p_length_read, "logged_measurements_idle_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_based_nw_perf_meas_params->logged_measurements_idle_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_based_nw_perf_meas_params->logged_measurements_idle_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_ue_based_nw_perf_meas_params->logged_measurements_idle_r10);
        return RRC_FAILURE;
    }
    }

    if (p_ue_based_nw_perf_meas_params->bitmask & RRC_RRM_STANDALONE_GNSS_LOC_UE_EUTRA_CAPABILITY_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_based_nw_perf_meas_params->standalone_gnss_location_r10, p_src + *p_length_read, "standalone_gnss_location_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ue_based_nw_perf_meas_params->standalone_gnss_location_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_based_nw_perf_meas_params->standalone_gnss_location_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_ue_based_nw_perf_meas_params->standalone_gnss_location_r10);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v1020_ies
(
    ue_eutra_capability_v1020_ies_t *p_ue_eutra_capability_v1020_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v1020_ies, 0, sizeof(ue_eutra_capability_v1020_ies_t));

    /* This function parses ue_eutra_capability_v1020_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v1020_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_UE_CATEGORY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_v1020_ies->ue_category_v1020, p_src + *p_length_read, "ue_category_v1020");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_ue_eutra_capability_v1020_ies->ue_category_v1020 < 6) || (p_ue_eutra_capability_v1020_ies->ue_category_v1020 > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ue_eutra_capability_v1020_ies->ue_category_v1020] should be in range "
            "6 to 8. Incorrect value %u received.", p_ue_eutra_capability_v1020_ies->ue_category_v1020);
        return RRC_FAILURE;
    }
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_PHYLAYERS_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_phylayer_parameters_v1020_ies(
        &p_ue_eutra_capability_v1020_ies->phylayer_parameter_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_RF_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_v1020_ies(
        &p_ue_eutra_capability_v1020_ies->rf_parameters_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_MEAS_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_measparameters_v1020_ies(
        &p_ue_eutra_capability_v1020_ies->meas_parameters_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_FEATUREGROUP_IND_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_ue_eutra_capability_v1020_ies->featuregroup_ind_r10) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_ue_eutra_capability_v1020_ies->featuregroup_ind_r10); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_ue_eutra_capability_v1020_ies->featuregroup_ind_r10[loop], (void*)(p_src + *p_length_read), "featuregroup_ind_r10[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_CDMA2000_V1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_cdma2000_v1020(
        &p_ue_eutra_capability_v1020_ies->inter_rat_parameters_cdma2000_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_INTER_RAT_PARAMS_UTRA_TDD_V1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_utra_tdd_v1020(
        &p_ue_eutra_capability_v1020_ies->inter_rat_parameters_utra_tdd_v1020,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_v1060_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1060_ies(
        &p_ue_eutra_capability_v1020_ies->ue_eutra_capability_v1060_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v1020_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_NW_PERF_MEAS_PARAMS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_based_nw_perf_meas_params(
        &p_ue_eutra_capability_v1020_ies->ue_based_nw_perf_meas_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v940_ies
(
    ue_eutra_capability_v940_ies_t *p_ue_eutra_capability_v940_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v940_ies, 0, sizeof(ue_eutra_capability_v940_ies_t));

    /* This function parses ue_eutra_capability_v940_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v940_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ue_eutra_capability_v940_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V9a0_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v9a0_ies(
        &p_ue_eutra_capability_v940_ies->ue_eutra_capability_v9a0_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v940_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V1020_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v1020_ies(
        &p_ue_eutra_capability_v940_ies->ue_eutra_capability_v1020_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_eutra_capability_v920_ies
(
    ue_eutra_capability_v920_ies_t *p_ue_eutra_capability_v920_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_eutra_capability_v920_ies, 0, sizeof(ue_eutra_capability_v920_ies_t));

    /* This function parses ue_eutra_capability_v920_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ue_eutra_capability_v920_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_phy_layer_parameters_v920(
        &p_ue_eutra_capability_v920_ies->phy_layer_parameters_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_geran_v920(
        &p_ue_eutra_capability_v920_ies->inter_rat_parameters_geran_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ue_eutra_capability_v920_ies->bitmask & RRC_RRM_INTER_RAT_PARAMS_UTRA_V920_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_utra_v920(
        &p_ue_eutra_capability_v920_ies->inter_rat_parameters_utra_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ue_eutra_capability_v920_ies->bitmask & RRC_RRM_INTER_RAT_PARAMS_CDMA2000_V920_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_parameters_cdma2000_v920(
        &p_ue_eutra_capability_v920_ies->inter_rat_parameters_cdma2000_v920,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_csg_proximity_indication_parameters_r9(
        &p_ue_eutra_capability_v920_ies->csg_proximity_indication_parameters_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_neigh_cell_si_acquisition_parameters_r9(
        &p_ue_eutra_capability_v920_ies->neigh_cell_si_acquisition_parameters_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_son_parameters_r9(
        &p_ue_eutra_capability_v920_ies->son_parameters_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_ue_eutra_capability_v920_ies->bitmask & RRC_RRM_DEVICE_TYPE_R9_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ue_eutra_capability_v920_ies->device_type_r9, p_src + *p_length_read, "device_type_r9");
    *p_length_read += sizeof(U8);
    }

    if (p_ue_eutra_capability_v920_ies->bitmask & RRC_RRM_UE_EUTRA_CAPABILITY_V940_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v940_ies(
        &p_ue_eutra_capability_v920_ies->ue_eutra_capability_v940_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_radio_capability_info
(
    eutra_radio_capability_info_t *p_eutra_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_eutra_radio_capability_info, 0, sizeof(eutra_radio_capability_info_t));

    /* This function parses eutra_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_eutra_radio_capability_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_eutra_radio_capability_info_def(
        &p_eutra_radio_capability_info->eutra_radio_capability_info_def,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_eutra_radio_capability_info->bitmask & UE_EUTRA_CAPABILITY_V920_IES_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ue_eutra_capability_v920_ies(
        &p_eutra_radio_capability_info->ue_eutra_capability_v920_ies,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_utra_radio_capability_info
(
    utra_radio_capability_info_t *p_utra_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_utra_radio_capability_info, 0, sizeof(utra_radio_capability_info_t));

    /* This function parses utra_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_utra_radio_capability_info->len_utra_radio_capability_info, p_src + *p_length_read, "len_utra_radio_capability_info");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_utra_radio_capability_info->len_utra_radio_capability_info > MAX_ASN_BUFFER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_utra_radio_capability_info->len_utra_radio_capability_info] should be less than"
            " or equal to MAX_ASN_BUFFER. Incorrect value %u received.", p_utra_radio_capability_info->len_utra_radio_capability_info);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_utra_radio_capability_info->len_utra_radio_capability_info * sizeof(p_utra_radio_capability_info->utra_radio_capability_asn_buff[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_utra_radio_capability_info->len_utra_radio_capability_info; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_utra_radio_capability_info->utra_radio_capability_asn_buff[loop], (void*)(p_src + *p_length_read), "utra_radio_capability_asn_buff[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cdma2000_radio_capability_info
(
    cdma2000_radio_capability_info_t *p_cdma2000_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cdma2000_radio_capability_info, 0, sizeof(cdma2000_radio_capability_info_t));

    /* This function parses cdma2000_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info, p_src + *p_length_read, "len_cdma2000_radio_capability_info");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info > MAX_ASN_BUFFER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info] should be less than"
            " or equal to MAX_ASN_BUFFER. Incorrect value %u received.", p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info * sizeof(p_cdma2000_radio_capability_info->cdma2000_radio_capability_asn_buff[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cdma2000_radio_capability_info->len_cdma2000_radio_capability_info; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cdma2000_radio_capability_info->cdma2000_radio_capability_asn_buff[loop], (void*)(p_src + *p_length_read), "cdma2000_radio_capability_asn_buff[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_geran_cs_radio_capability_info
(
    geran_cs_radio_capability_info_t *p_geran_cs_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_geran_cs_radio_capability_info, 0, sizeof(geran_cs_radio_capability_info_t));

    /* This function parses geran_cs_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info, p_src + *p_length_read, "len_geran_cs_radio_capability_info");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info > MAX_ASN_BUFFER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info] should be less than"
            " or equal to MAX_ASN_BUFFER. Incorrect value %u received.", p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info * sizeof(p_geran_cs_radio_capability_info->geran_cs_radio_capability_asn_buff[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_geran_cs_radio_capability_info->len_geran_cs_radio_capability_info; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_geran_cs_radio_capability_info->geran_cs_radio_capability_asn_buff[loop], (void*)(p_src + *p_length_read), "geran_cs_radio_capability_asn_buff[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_geran_ps_radio_capability_info
(
    geran_ps_radio_capability_info_t *p_geran_ps_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_geran_ps_radio_capability_info, 0, sizeof(geran_ps_radio_capability_info_t));

    /* This function parses geran_ps_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info, p_src + *p_length_read, "len_geran_ps_radio_capability_info");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info > MAX_ASN_BUFFER))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info] should be less than"
            " or equal to MAX_ASN_BUFFER. Incorrect value %u received.", p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info * sizeof(p_geran_ps_radio_capability_info->geran_ps_radio_capability_asn_buff[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_geran_ps_radio_capability_info->len_geran_ps_radio_capability_info; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_geran_ps_radio_capability_info->geran_ps_radio_capability_asn_buff[loop], (void*)(p_src + *p_length_read), "geran_ps_radio_capability_asn_buff[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_eutra
(
    band_parameters_eutra_t *p_band_parameters_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_band_parameters_eutra, 0, sizeof(band_parameters_eutra_t));

    /* This function parses band_parameters_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_eutra->band_eutra, p_src + *p_length_read, "band_eutra");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_eutra->band_eutra < 1) || (p_band_parameters_eutra->band_eutra > MAX_EUTRA_FREQ_BANDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_eutra->band_eutra] should be in range "
            "1 to MAX_EUTRA_FREQ_BANDS. Incorrect value %u received.", p_band_parameters_eutra->band_eutra);
        return RRC_FAILURE;
    }

    if (p_band_parameters_eutra->bitmask & BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_band_parameters_eutra->ca_bandwidth_class_dl_eutra, p_src + *p_length_read, "ca_bandwidth_class_dl_eutra");
    *p_length_read += sizeof(U32);
    }

    if (p_band_parameters_eutra->bitmask & BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_band_parameters_eutra->ca_bandwidth_class_ul_eutra, p_src + *p_length_read, "ca_bandwidth_class_ul_eutra");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters_nr
(
    band_parameters_nr_t *p_band_parameters_nr,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_band_parameters_nr, 0, sizeof(band_parameters_nr_t));

    /* This function parses band_parameters_nr */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_nr->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters_nr->band_nr, p_src + *p_length_read, "band_nr");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_band_parameters_nr->band_nr < 1) || (p_band_parameters_nr->band_nr > MAX_NR_FREQ_BANDS))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_parameters_nr->band_nr] should be in range "
            "1 to MAX_NR_FREQ_BANDS. Incorrect value %u received.", p_band_parameters_nr->band_nr);
        return RRC_FAILURE;
    }

    if (p_band_parameters_nr->bitmask & BAND_PARAMETERS_CA_BANDWIDTH_CLASS_DL_NR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_band_parameters_nr->ca_bandwidth_class_dl_nr, p_src + *p_length_read, "ca_bandwidth_class_dl_nr");
    *p_length_read += sizeof(U32);
    }

    if (p_band_parameters_nr->bitmask & BAND_PARAMETERS_CA_BANDWIDTH_CLASS_UL_NR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_band_parameters_nr->ca_bandwidth_class_ul_nr, p_src + *p_length_read, "ca_bandwidth_class_ul_nr");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_parameters
(
    band_parameters_t *p_band_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_parameters, 0, sizeof(band_parameters_t));

    /* This function parses band_parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_band_parameters->bitmask & BAND_PARAMETERS_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_eutra(
        &p_band_parameters->eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_band_parameters->bitmask & BAND_PARAMETERS_NR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_band_parameters_nr(
        &p_band_parameters->nr,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination_band_list
(
    band_combination_band_list_t *p_band_combination_band_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination_band_list, 0, sizeof(band_combination_band_list_t));

    /* This function parses band_combination_band_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_combination_band_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_band_combination_band_list->count > MAX_SIMULTANEOUS_BANDS_EUTRA_NR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_band_combination_band_list->count] should be less than"
            " or equal to MAX_SIMULTANEOUS_BANDS_EUTRA_NR. Incorrect value %u received.", p_band_combination_band_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_band_combination_band_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_parameters(
                &p_band_combination_band_list->band[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_band_combination
(
    band_combination_t *p_band_combination,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_band_combination, 0, sizeof(band_combination_t));

    /* This function parses band_combination */

    if (RRC_FAILURE == rrc_il_parse_band_combination_band_list(
        &p_band_combination->band_combination_band_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_band_combination->feature_set_combination, p_src + *p_length_read, "feature_set_combination");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_supported_band_comb_list
(
    supported_band_comb_list_t *p_supported_band_comb_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_supported_band_comb_list, 0, sizeof(supported_band_comb_list_t));

    /* This function parses supported_band_comb_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_supported_band_comb_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_supported_band_comb_list->count > MAX_BAND_COMB_EUTRA_NR))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_supported_band_comb_list->count] should be less than"
            " or equal to MAX_BAND_COMB_EUTRA_NR. Incorrect value %u received.", p_supported_band_comb_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_supported_band_comb_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_band_combination(
                &p_supported_band_comb_list->band_combination[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rf_parameters_mrdc
(
    rf_parameters_mrdc_t *p_rf_parameters_mrdc,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rf_parameters_mrdc, 0, sizeof(rf_parameters_mrdc_t));

    /* This function parses rf_parameters_mrdc */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rf_parameters_mrdc->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rf_parameters_mrdc->bitmask & RF_PARAMETERS_MRDC_SUPPORTED_BAND_COMB_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_supported_band_comb_list(
        &p_rf_parameters_mrdc->supported_band_comb_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_nr_radio_capability_info
(
    eutra_nr_radio_capability_info_t *p_eutra_nr_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_eutra_nr_radio_capability_info, 0, sizeof(eutra_nr_radio_capability_info_t));

    /* This function parses eutra_nr_radio_capability_info */

    if (RRC_FAILURE == rrc_il_parse_rf_parameters_mrdc(
        &p_eutra_nr_radio_capability_info->rf_parameters_mrdc,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_nr_radio_capability_info
(
    nr_radio_capability_info_t *p_nr_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_nr_radio_capability_info, 0, sizeof(nr_radio_capability_info_t));

    /* This function parses nr_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_nr_radio_capability_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_nr_radio_capability_info->bitmask & RRC_NR_SUPPORTED_GAP_PATTERN_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_nr_radio_capability_info->supported_gap_pattern, p_src + *p_length_read, "supported_gap_pattern");
    *p_length_read += sizeof(U32);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_radio_capability_info
(
    rrc_radio_capability_info_t *p_rrc_radio_capability_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_radio_capability_info, 0, sizeof(rrc_radio_capability_info_t));

    /* This function parses rrc_radio_capability_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_radio_capability_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_radio_capability_info->bitmask & EUTRA_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_eutra_radio_capability_info(
        &p_rrc_radio_capability_info->eutra_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & UTRA_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_utra_radio_capability_info(
        &p_rrc_radio_capability_info->utra_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & CDMA2000_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_radio_capability_info(
        &p_rrc_radio_capability_info->cdma2000_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & GERAN_CS_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_geran_cs_radio_capability_info(
        &p_rrc_radio_capability_info->geran_cs_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & GERAN_PS_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_geran_ps_radio_capability_info(
        &p_rrc_radio_capability_info->geran_ps_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & EURTA_NR_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_eutra_nr_radio_capability_info(
        &p_rrc_radio_capability_info->eutra_nr_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_radio_capability_info->bitmask & NR_RADIO_CAPABILITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_nr_radio_capability_info(
        &p_rrc_radio_capability_info->nr_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_capability_ind
(
    rrc_rrm_ue_capability_ind_t *p_rrc_rrm_ue_capability_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_capability_ind, 0, sizeof(rrc_rrm_ue_capability_ind_t));

    /* This function parses rrc_rrm_ue_capability_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_capability_ind->ue_Index, p_src + *p_length_read, "ue_Index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_capability_info(
        &p_rrc_rrm_ue_capability_ind->radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ho_required
(
    rrc_rrm_ho_required_t *p_rrc_rrm_ho_required,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ho_required, 0, sizeof(rrc_rrm_ho_required_t));

    /* This function parses rrc_rrm_ho_required */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_required->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->cell_index > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->cell_index] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_rrm_ho_required->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_required->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->ho_type, p_src + *p_length_read, "ho_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->ho_type > 11))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->ho_type] should be less than"
            " or equal to 11. Incorrect value %u received.", p_rrc_rrm_ho_required->ho_type);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ho_required->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_target_id(
        &p_rrc_rrm_ho_required->target_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_DIRECT_FORWARD_PATH_AVAILABLE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->direct_fwd_path_available, p_src + *p_length_read, "direct_fwd_path_available");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->direct_fwd_path_available > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->direct_fwd_path_available] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_ho_required->direct_fwd_path_available);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_INDICATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->srvcc_ho_indication, p_src + *p_length_read, "srvcc_ho_indication");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->srvcc_ho_indication > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->srvcc_ho_indication] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ho_required->srvcc_ho_indication);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_soruce_to_target_transparent_container(
        &p_rrc_rrm_ho_required->source_to_target_container,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_RE_SRC_TO_TARGET_CONTAINER_SECONDARY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_old_bss_to_new_bss_information(
        &p_rrc_rrm_ho_required->source_to_target_container_secondary,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_PS_SERVICE_NOT_AVAILABLE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->ps_service_not_available, p_src + *p_length_read, "ps_service_not_available");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->ps_service_not_available > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->ps_service_not_available] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrc_rrm_ho_required->ps_service_not_available);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_CELL_ACCESS_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ho_required->cell_access_mode, p_src + *p_length_read, "cell_access_mode");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_RE_BAND_INDICATOR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->band_indicator, p_src + *p_length_read, "band_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->band_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->band_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ho_required->band_indicator);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_CSG_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_rrm_ho_required->csg_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_rrm_ho_required->csg_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_ho_required->csg_identity[loop], (void*)(p_src + *p_length_read), "csg_identity[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_MOBILITY_CONTROL_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mobility_control_info(
        &p_rrc_rrm_ho_required->mobility_control_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_RE_HO_FREQ_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->ho_freq_type, p_src + *p_length_read, "ho_freq_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_required->ho_freq_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->ho_freq_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ho_required->ho_freq_type);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_CDMA2000_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cdma2000_information(
        &p_rrc_rrm_ho_required->cdma2000_information,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_CCO_PARAMS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cco_parameters(
        &p_rrc_rrm_ho_required->cco_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_ADM_REQ_SRVCC_HO_OP_POSSIBLE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_required->srvcc_ho_op_possible, p_src + *p_length_read, "srvcc_ho_op_possible");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_ho_required->srvcc_ho_op_possible < 1) || (p_rrc_rrm_ho_required->srvcc_ho_op_possible > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_required->srvcc_ho_op_possible] should be in range "
            "1 to 1. Incorrect value %u received.", p_rrc_rrm_ho_required->srvcc_ho_op_possible);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_CDMA2000_1XRTT_REF_CELL_ID_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1xrtt_ref_cell_identifier(
        &p_rrc_rrm_ho_required->ref_cell_id_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_CDMA2000_HRPD_REF_CELL_ID_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd_ref_sector_identifier(
        &p_rrc_rrm_ho_required->ref_sector_id_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ho_required->bitmask & RRC_RRM_UE_HO_REQUIRED_GUMMEI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mme_sel_gummei_info(
        &p_rrc_rrm_ho_required->gummei_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_globalEnb_ecgi
(
    eutra_globalEnb_ecgi_t *p_eutra_globalEnb_ecgi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_eutra_globalEnb_ecgi, 0, sizeof(eutra_globalEnb_ecgi_t));

    /* This function parses eutra_globalEnb_ecgi */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_eutra_globalEnb_ecgi->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_eutra_globalEnb_ecgi->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_eutra_globalEnb_ecgi->cell_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_eutra_globalEnb_ecgi->cell_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_eutra_globalEnb_ecgi->cell_identity[loop], (void*)(p_src + *p_length_read), "cell_identity[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (p_eutra_globalEnb_ecgi->bitmask & EUTRAN_CELL_GLOBAL_IDENTITY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_eutra_globalEnb_ecgi->ecgi) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_eutra_globalEnb_ecgi->ecgi); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_eutra_globalEnb_ecgi->ecgi[loop], (void*)(p_src + *p_length_read), "ecgi[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_eutra_globalEnb_ecgi->cell_type, p_src + *p_length_read, "cell_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_eutra_globalEnb_ecgi->cell_type < 1) || (p_eutra_globalEnb_ecgi->cell_type > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_eutra_globalEnb_ecgi->cell_type] should be in range "
            "1 to 2. Incorrect value %u received.", p_eutra_globalEnb_ecgi->cell_type);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_tai_info
(
    rrm_tai_info_t *p_rrm_tai_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_tai_info, 0, sizeof(rrm_tai_info_t));

    /* This function parses rrm_tai_info */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_rrm_tai_info->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_rrm_tai_info->tracking_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrm_tai_info->tracking_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_tai_info->tracking_area_code[loop], (void*)(p_src + *p_length_read), "tracking_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_enb_id
(
    rrm_enb_id_t *p_rrm_enb_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_enb_id, 0, sizeof(rrm_enb_id_t));

    /* This function parses rrm_enb_id */

    if (RRC_FAILURE == rrc_il_parse_eutra_globalEnb_ecgi(
        &p_rrm_enb_id->global_enb_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_tai_info(
        &p_rrm_enb_id->tracking_area_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_lai_info
(
    rrm_lai_info_t *p_rrm_lai_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_lai_info, 0, sizeof(rrm_lai_info_t));

    /* This function parses rrm_lai_info */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_rrm_lai_info->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_rrm_lai_info->location_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrm_lai_info->location_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_lai_info->location_area_code[loop], (void*)(p_src + *p_length_read), "location_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rnc_id
(
    rrm_rnc_id_t *p_rrm_rnc_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_rnc_id, 0, sizeof(rrm_rnc_id_t));

    /* This function parses rrm_rnc_id */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rnc_id->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_lai_info(
        &p_rrm_rnc_id->lai,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_rnc_id->bitmask & RRM_RNC_ROUTING_AREA_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_rnc_id->routing_area_code, p_src + *p_length_read, "routing_area_code");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rnc_id->rnc_id, p_src + *p_length_read, "rnc_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_rnc_id->rnc_id > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_rnc_id->rnc_id] should be less than"
            " or equal to 4095. Incorrect value %u received.", p_rrm_rnc_id->rnc_id);
        return RRC_FAILURE;
    }

    if (p_rrm_rnc_id->bitmask & RRM_RNC_EXTENDED_RNC_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rnc_id->extended_rnc_id, p_src + *p_length_read, "extended_rnc_id");
    *p_length_read += sizeof(U16);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_cgi_info
(
    rrm_cgi_info_t *p_rrm_cgi_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_cgi_info, 0, sizeof(rrm_cgi_info_t));

    /* This function parses rrm_cgi_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_cgi_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_rrm_cgi_info->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_rrm_cgi_info->location_area_code) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrm_cgi_info->location_area_code); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_cgi_info->location_area_code[loop], (void*)(p_src + *p_length_read), "location_area_code[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_rrm_cgi_info->ci_info) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrm_cgi_info->ci_info); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_cgi_info->ci_info[loop], (void*)(p_src + *p_length_read), "ci_info[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (p_rrm_cgi_info->bitmask & RRM_CGI_INFO_ROUTING_AREA_CODE)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_cgi_info->routing_area_code, p_src + *p_length_read, "routing_area_code");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_target_id
(
    rrm_target_id_t *p_rrm_target_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_target_id, 0, sizeof(rrm_target_id_t));

    /* This function parses rrm_target_id */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_target_id->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_target_id->bitmask & RRM_TARGET_ID_ENB_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_enb_id(
        &p_rrm_target_id->enb_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_target_id->bitmask & RRM_TARGET_ID_RNC_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_rnc_id(
        &p_rrm_target_id->rnc_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_target_id->bitmask & RRM_TARGET_ID_CGI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cgi_info(
        &p_rrm_target_id->cgi,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_target_id->bitmask & RRM_TARGET_ID_CDMA2000_1XRTT_CELL_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1xrtt_cell_identifier(
        &p_rrm_target_id->cell_id_1xrtt,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_target_id->bitmask & RRM_TARGET_ID_CDMA2000_HRPD_SECTOR_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd_sector_identifier(
        &p_rrm_target_id->sector_id_hrpd,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_target_cell_identity
(
    target_cell_identity_t *p_target_cell_identity,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_target_cell_identity, 0, sizeof(target_cell_identity_t));

    /* This function parses target_cell_identity */

    if (*p_length_read + (S32)sizeof(p_target_cell_identity->target_cell_Id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_target_cell_identity->target_cell_Id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_target_cell_identity->target_cell_Id[loop], (void*)(p_src + *p_length_read), "target_cell_Id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_target_cell_identity_list
(
    target_cell_identity_list_t *p_target_cell_identity_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_target_cell_identity_list, 0, sizeof(target_cell_identity_list_t));

    /* This function parses target_cell_identity_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_target_cell_identity_list->target_cell_count, p_src + *p_length_read, "target_cell_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_target_cell_identity_list->target_cell_count < 1) || (p_target_cell_identity_list->target_cell_count > MAX_NUM_TARGET_CELL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_target_cell_identity_list->target_cell_count] should be in range "
            "1 to MAX_NUM_TARGET_CELL. Incorrect value %u received.", p_target_cell_identity_list->target_cell_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_target_cell_identity_list->target_cell_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_target_cell_identity(
                &p_target_cell_identity_list->target_cell_identity[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_candidate_cell_info
(
    candidate_cell_info_t *p_candidate_cell_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_candidate_cell_info, 0, sizeof(candidate_cell_info_t));

    /* This function parses candidate_cell_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_candidate_cell_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_candidate_cell_info->phy_cell_id, p_src + *p_length_read, "phy_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_candidate_cell_info->phy_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_candidate_cell_info->phy_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_candidate_cell_info->phy_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_candidate_cell_info->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    if (p_candidate_cell_info->bitmask & CANDIDATE_CELL_INFO_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_candidate_cell_info->rsrp_result, p_src + *p_length_read, "rsrp_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_candidate_cell_info->rsrp_result > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_candidate_cell_info->rsrp_result] should be less than"
            " or equal to 97. Incorrect value %u received.", p_candidate_cell_info->rsrp_result);
        return RRC_FAILURE;
    }
    }

    if (p_candidate_cell_info->bitmask & CANDIDATE_CELL_INFO_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_candidate_cell_info->rsrq_result, p_src + *p_length_read, "rsrq_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_candidate_cell_info->rsrq_result > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_candidate_cell_info->rsrq_result] should be less than"
            " or equal to 34. Incorrect value %u received.", p_candidate_cell_info->rsrq_result);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_candidate_cell_info_list
(
    candidate_cell_info_list_t *p_candidate_cell_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_candidate_cell_info_list, 0, sizeof(candidate_cell_info_list_t));

    /* This function parses candidate_cell_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_candidate_cell_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_candidate_cell_info_list->count < 1) || (p_candidate_cell_info_list->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_candidate_cell_info_list->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_candidate_cell_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_candidate_cell_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_candidate_cell_info(
                &p_candidate_cell_info_list->candidate_cell_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_config
(
    rrm_config_t *p_rrm_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_config, 0, sizeof(rrm_config_t));

    /* This function parses rrm_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_config->bitmask & RRM_CONFIG_EXT_CANDIDATE_CELL_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_candidate_cell_info_list(
        &p_rrm_config->candidate_cell_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_rrc_container
(
    rrm_rrc_container_t *p_rrm_rrc_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_rrc_container, 0, sizeof(rrm_rrc_container_t));

    /* This function parses rrm_rrc_container */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_rrc_container->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_rrc_container->bitmask & RRM_RRC_CONTAINER_TARGET_CELL_IDENTITY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_target_cell_identity_list(
        &p_rrm_rrc_container->target_cell_identity_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_rrc_container->bitmask & RRM_RRC_CONTAINER_RRM_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_config(
        &p_rrm_rrc_container->rrm_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_erab_list
(
    rrc_erab_list_t *p_rrc_erab_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_erab_list, 0, sizeof(rrc_erab_list_t));

    /* This function parses rrc_erab_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_erab_list->erab_count, p_src + *p_length_read, "erab_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_erab_list->erab_count < 1) || (p_rrc_erab_list->erab_count > MAX_ERAB_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_erab_list->erab_count] should be in range "
            "1 to MAX_ERAB_COUNT. Incorrect value %u received.", p_rrc_erab_list->erab_count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_erab_list->erab_count * sizeof(p_rrc_erab_list->erab_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_erab_list->erab_count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_erab_list->erab_id[loop], (void*)(p_src + *p_length_read), "erab_id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_eutran_type
(
    rrc_eutran_type_t *p_rrc_eutran_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_eutran_type, 0, sizeof(rrc_eutran_type_t));

    /* This function parses rrc_eutran_type */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_eutran_type->cell_size, p_src + *p_length_read, "cell_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_eutran_type->cell_size > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_eutran_type->cell_size] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_eutran_type->cell_size);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_last_visited_e_utran_cell_information
(
    last_visited_e_utran_cell_information_t *p_last_visited_e_utran_cell_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_last_visited_e_utran_cell_information, 0, sizeof(last_visited_e_utran_cell_information_t));

    /* This function parses last_visited_e_utran_cell_information */

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_eutra(
        &p_last_visited_e_utran_cell_information->global_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_eutran_type(
        &p_last_visited_e_utran_cell_information->cell_type,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_last_visited_e_utran_cell_information->time_ue_stayed_in_cell, p_src + *p_length_read, "time_ue_stayed_in_cell");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_last_visited_e_utran_cell_information->time_ue_stayed_in_cell > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_last_visited_e_utran_cell_information->time_ue_stayed_in_cell] should be less than"
            " or equal to 4095. Incorrect value %u received.", p_last_visited_e_utran_cell_information->time_ue_stayed_in_cell);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_utran_type
(
    rrc_utran_type_t *p_rrc_utran_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_utran_type, 0, sizeof(rrc_utran_type_t));

    /* This function parses rrc_utran_type */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_utran_type->cell_size, p_src + *p_length_read, "cell_size");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_utran_type->cell_size > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_utran_type->cell_size] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_utran_type->cell_size);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_last_visited_utran_cell_information
(
    last_visited_utran_cell_information_t *p_last_visited_utran_cell_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_last_visited_utran_cell_information, 0, sizeof(last_visited_utran_cell_information_t));

    /* This function parses last_visited_utran_cell_information */

    if (RRC_FAILURE == rrc_il_parse_cell_global_id_utra(
        &p_last_visited_utran_cell_information->utran_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_utran_type(
        &p_last_visited_utran_cell_information->cell_type,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_last_visited_utran_cell_information->time_ue_stayed_in_cell, p_src + *p_length_read, "time_ue_stayed_in_cell");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_last_visited_utran_cell_information->time_ue_stayed_in_cell > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_last_visited_utran_cell_information->time_ue_stayed_in_cell] should be less than"
            " or equal to 4095. Incorrect value %u received.", p_last_visited_utran_cell_information->time_ue_stayed_in_cell);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_last_visited_cell_info
(
    last_visited_cell_info_t *p_last_visited_cell_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_last_visited_cell_info, 0, sizeof(last_visited_cell_info_t));

    /* This function parses last_visited_cell_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_last_visited_cell_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_last_visited_cell_info->bitmask & LAST_VISITED_CELL_INFO_E_UTRAN_CELL_INFORMATION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_last_visited_e_utran_cell_information(
        &p_last_visited_cell_info->last_visited_e_utran_cell_information,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_last_visited_cell_info->bitmask & LAST_VISITED_CELL_INFO_UTRAN_CELL_INFORMATION_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_last_visited_utran_cell_information(
        &p_last_visited_cell_info->last_visited_utran_cell_information,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_last_visited_cell_list
(
    last_visited_cell_list_t *p_last_visited_cell_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_last_visited_cell_list, 0, sizeof(last_visited_cell_list_t));

    /* This function parses last_visited_cell_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_last_visited_cell_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_last_visited_cell_list->count < 1) || (p_last_visited_cell_list->count > MAX_NO_OF_CELLS_UE_HISTORY))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_last_visited_cell_list->count] should be in range "
            "1 to MAX_NO_OF_CELLS_UE_HISTORY. Incorrect value %u received.", p_last_visited_cell_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_last_visited_cell_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_last_visited_cell_info(
                &p_last_visited_cell_list->last_visited_cell_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ue_history
(
    ue_history_t *p_ue_history,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ue_history, 0, sizeof(ue_history_t));

    /* This function parses ue_history */

    if (RRC_FAILURE == rrc_il_parse_last_visited_cell_list(
        &p_ue_history->last_visited_cell_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_sourceenb_to_targetenb_transparent_cotainer
(
    rrm_sourceenb_to_targetenb_transparent_cotainer_t *p_rrm_sourceenb_to_targetenb_transparent_cotainer,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_sourceenb_to_targetenb_transparent_cotainer, 0, sizeof(rrm_sourceenb_to_targetenb_transparent_cotainer_t));

    /* This function parses rrm_sourceenb_to_targetenb_transparent_cotainer */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_sourceenb_to_targetenb_transparent_cotainer->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_rrc_container(
        &p_rrm_sourceenb_to_targetenb_transparent_cotainer->rrc_container,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_sourceenb_to_targetenb_transparent_cotainer->bitmask & SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_ERAB_DL_FWDING_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_erab_list(
        &p_rrm_sourceenb_to_targetenb_transparent_cotainer->erab_dl_fwding_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_ue_history(
        &p_rrm_sourceenb_to_targetenb_transparent_cotainer->ue_histroy,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_sourceenb_to_targetenb_transparent_cotainer->bitmask & SOURCE_ENB_TO_TARGET_ENB_TRANSPARENT_CONTAINER_SUB_PROFILE_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_sourceenb_to_targetenb_transparent_cotainer->sub_profile_id, p_src + *p_length_read, "sub_profile_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_sourceenb_to_targetenb_transparent_cotainer->sub_profile_id < 1) || (p_rrm_sourceenb_to_targetenb_transparent_cotainer->sub_profile_id > 256))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_sourceenb_to_targetenb_transparent_cotainer->sub_profile_id] should be in range "
            "1 to 256. Incorrect value %u received.", p_rrm_sourceenb_to_targetenb_transparent_cotainer->sub_profile_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_security_info
(
    security_info_t *p_security_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_security_info, 0, sizeof(security_info_t));

    /* This function parses security_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_security_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_security_info->bitmask & SECURITY_INFO_CHOSEN_INTEGRITY_PROTECTION_ALGO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_info->chosen_integrity_protection_algo, p_src + *p_length_read, "chosen_integrity_protection_algo");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_info->chosen_integrity_protection_algo > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_info->chosen_integrity_protection_algo] should be less than"
            " or equal to 1. Incorrect value %u received.", p_security_info->chosen_integrity_protection_algo);
        return RRC_FAILURE;
    }
    }

    if (p_security_info->bitmask & SECURITY_INFO_INTEGRITY_PROTECTION_KEY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_security_info->integration_protection_key) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_security_info->integration_protection_key); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_security_info->integration_protection_key[loop], (void*)(p_src + *p_length_read), "integration_protection_key[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_security_info->bitmask & SECURITY_INFO_CHOSEN_ENCRYPTION_ALGO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_info->chosen_encryption_algo, p_src + *p_length_read, "chosen_encryption_algo");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_info->chosen_encryption_algo > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_info->chosen_encryption_algo] should be less than"
            " or equal to 2. Incorrect value %u received.", p_security_info->chosen_encryption_algo);
        return RRC_FAILURE;
    }
    }

    if (p_security_info->bitmask & SECURITY_INFO_CIPHERING_KEY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_security_info->ciphering_key) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_security_info->ciphering_key); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_security_info->ciphering_key[loop], (void*)(p_src + *p_length_read), "ciphering_key[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (p_security_info->bitmask & SECURITY_INFO_CHOSEN_CS_ENCRYPTION_ALGO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_info->chosen_cs_encryption_algorithm, p_src + *p_length_read, "chosen_cs_encryption_algorithm");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_info->chosen_cs_encryption_algorithm > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_info->chosen_cs_encryption_algorithm] should be less than"
            " or equal to 2. Incorrect value %u received.", p_security_info->chosen_cs_encryption_algorithm);
        return RRC_FAILURE;
    }
    }

    if (p_security_info->bitmask & SECURITY_INFO_CHOSEN_PS_ENCRYPTION_ALGO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_info->chosen_ps_encryption_algorithm, p_src + *p_length_read, "chosen_ps_encryption_algorithm");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_info->chosen_ps_encryption_algorithm > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_info->chosen_ps_encryption_algorithm] should be less than"
            " or equal to 2. Incorrect value %u received.", p_security_info->chosen_ps_encryption_algorithm);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_transport_channel_id
(
    transport_channel_id_t *p_transport_channel_id,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_transport_channel_id, 0, sizeof(transport_channel_id_t));

    /* This function parses transport_channel_id */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_transport_channel_id->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_transport_channel_id->bitmask & TRANSPORT_CHANNEL_ID_DCH_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_transport_channel_id->dch_id, p_src + *p_length_read, "dch_id");
    *p_length_read += sizeof(U8);
    }

    if (p_transport_channel_id->bitmask & TRANSPORT_CHANNEL_ID_DSCH_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_transport_channel_id->dsch_id, p_src + *p_length_read, "dsch_id");
    *p_length_read += sizeof(U8);
    }

    if (p_transport_channel_id->bitmask & TRANSPORT_CHANNEL_ID_USCH_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_transport_channel_id->usch_id, p_src + *p_length_read, "usch_id");
    *p_length_read += sizeof(U8);
    }

    if (p_transport_channel_id->bitmask & TRANSPORT_CHANNEL_ID_HS_DSCH_MAC_D_FLOW_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_transport_channel_id->hs_dsch_mac_d_flow_id, p_src + *p_length_read, "hs_dsch_mac_d_flow_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_transport_channel_id->hs_dsch_mac_d_flow_id > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_transport_channel_id->hs_dsch_mac_d_flow_id] should be less than"
            " or equal to 7. Incorrect value %u received.", p_transport_channel_id->hs_dsch_mac_d_flow_id);
        return RRC_FAILURE;
    }
    }

    if (p_transport_channel_id->bitmask & TRANSPORT_CHANNEL_ID_E_DCH_MAC_D_FLOW_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_transport_channel_id->e_dch_mac_d_flow_id, p_src + *p_length_read, "e_dch_mac_d_flow_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_transport_channel_id->e_dch_mac_d_flow_id > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_transport_channel_id->e_dch_mac_d_flow_id] should be less than"
            " or equal to 7. Incorrect value %u received.", p_transport_channel_id->e_dch_mac_d_flow_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rab_transport_channel_mapping
(
    rab_transport_channel_mapping_t *p_rab_transport_channel_mapping,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rab_transport_channel_mapping, 0, sizeof(rab_transport_channel_mapping_t));

    /* This function parses rab_transport_channel_mapping */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rab_transport_channel_mapping->rab_id, p_src + *p_length_read, "rab_id");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rab_transport_channel_mapping->no_of_rab_subflow, p_src + *p_length_read, "no_of_rab_subflow");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rab_transport_channel_mapping->no_of_rab_subflow < 1) || (p_rab_transport_channel_mapping->no_of_rab_subflow > MAX_NUM_SUB_FLOW_PER_RAB))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rab_transport_channel_mapping->no_of_rab_subflow] should be in range "
            "1 to MAX_NUM_SUB_FLOW_PER_RAB. Incorrect value %u received.", p_rab_transport_channel_mapping->no_of_rab_subflow);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rab_transport_channel_mapping->no_of_rab_subflow; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_transport_channel_id(
                &p_rab_transport_channel_mapping->transport_channel_id[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rab_transport_channel_mapping->cn_domain_indicator, p_src + *p_length_read, "cn_domain_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rab_transport_channel_mapping->cn_domain_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rab_transport_channel_mapping->cn_domain_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rab_transport_channel_mapping->cn_domain_indicator);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_srb_transport_channel_mapping
(
    srb_transport_channel_mapping_t *p_srb_transport_channel_mapping,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_srb_transport_channel_mapping, 0, sizeof(srb_transport_channel_mapping_t));

    /* This function parses srb_transport_channel_mapping */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_srb_transport_channel_mapping->srb_id, p_src + *p_length_read, "srb_id");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_transport_channel_id(
        &p_srb_transport_channel_mapping->srb_transport_channel_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_trace_recording_session_info
(
    trace_recording_session_info_t *p_trace_recording_session_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_trace_recording_session_info, 0, sizeof(trace_recording_session_info_t));

    /* This function parses trace_recording_session_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_trace_recording_session_info->trace_recording_length, p_src + *p_length_read, "trace_recording_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_trace_recording_session_info->trace_recording_length < 2) || (p_trace_recording_session_info->trace_recording_length > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_trace_recording_session_info->trace_recording_length] should be in range "
            "2 to 3. Incorrect value %u received.", p_trace_recording_session_info->trace_recording_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_trace_recording_session_info->trace_recording_length * sizeof(p_trace_recording_session_info->trace_reference[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_trace_recording_session_info->trace_recording_length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_trace_recording_session_info->trace_reference[loop], (void*)(p_src + *p_length_read), "trace_reference[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_trace_recording_session_info->trace_recording_session_reference, p_src + *p_length_read, "trace_recording_session_reference");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_srvcc_information
(
    srvcc_information_t *p_srvcc_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_srvcc_information, 0, sizeof(srvcc_information_t));

    /* This function parses srvcc_information */

    if (*p_length_read + (S32)sizeof(p_srvcc_information->nonce) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_srvcc_information->nonce); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_srvcc_information->nonce[loop], (void*)(p_src + *p_length_read), "nonce[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_freq
(
    eutra_freq_t *p_eutra_freq,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_eutra_freq, 0, sizeof(eutra_freq_t));

    /* This function parses eutra_freq */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_eutra_freq->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_eutra_freq->e_arfcn, p_src + *p_length_read, "e_arfcn");
    *p_length_read += sizeof(U16);

    if (p_eutra_freq->bitmask & E_UTRA_FREQ_MEASUREMENT_BAND_WIDTH_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_eutra_freq->measurement_bandwidth, p_src + *p_length_read, "measurement_bandwidth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_eutra_freq->measurement_bandwidth > 5))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_eutra_freq->measurement_bandwidth] should be less than"
            " or equal to 5. Incorrect value %u received.", p_eutra_freq->measurement_bandwidth);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_eutra_freq_list
(
    eutra_freq_list_t *p_eutra_freq_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_eutra_freq_list, 0, sizeof(eutra_freq_list_t));

    /* This function parses eutra_freq_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_eutra_freq_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_eutra_freq_list->count < 1) || (p_eutra_freq_list->count > MAX_EUTRA_CARRIER_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_eutra_freq_list->count] should be in range "
            "1 to MAX_EUTRA_CARRIER_FREQ. Incorrect value %u received.", p_eutra_freq_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_eutra_freq_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_eutra_freq(
                &p_eutra_freq_list->eutra_freq[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_meas_param
(
    irat_meas_param_t *p_irat_meas_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_irat_meas_param, 0, sizeof(irat_meas_param_t));

    /* This function parses irat_meas_param */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_irat_meas_param->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_meas_param->meas_duration, p_src + *p_length_read, "meas_duration");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_irat_meas_param->meas_duration < 1) || (p_irat_meas_param->meas_duration > 100))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_meas_param->meas_duration] should be in range "
            "1 to 100. Incorrect value %u received.", p_irat_meas_param->meas_duration);
        return RRC_FAILURE;
    }

    if (p_irat_meas_param->bitmask & IRAT_MEAS_PARAM_EUTRA_FREQ_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_eutra_freq_list(
        &p_irat_meas_param->eutra_freq_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_irat_meas_config
(
    irat_meas_config_t *p_irat_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_irat_meas_config, 0, sizeof(irat_meas_config_t));

    /* This function parses irat_meas_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_irat_meas_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_irat_meas_config->bitmask & IRAT_MEAS_CONFIG_PARAM_RSRP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_meas_config->rsrp, p_src + *p_length_read, "rsrp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_meas_config->rsrp > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_meas_config->rsrp] should be less than"
            " or equal to 97. Incorrect value %u received.", p_irat_meas_config->rsrp);
        return RRC_FAILURE;
    }
    }

    if (p_irat_meas_config->bitmask & IRAT_MEAS_CONFIG_PARAM_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_irat_meas_config->rsrq, p_src + *p_length_read, "rsrq");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_irat_meas_config->rsrq > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_irat_meas_config->rsrq] should be less than"
            " or equal to 34. Incorrect value %u received.", p_irat_meas_config->rsrq);
        return RRC_FAILURE;
    }
    }

    if (RRC_FAILURE == rrc_il_parse_irat_meas_param(
        &p_irat_meas_config->irat_meas_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_source_rnc_to_target_rnc_transparent_container
(
    rrm_source_rnc_to_target_rnc_transparent_container_t *p_rrm_source_rnc_to_target_rnc_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_source_rnc_to_target_rnc_transparent_container, 0, sizeof(rrm_source_rnc_to_target_rnc_transparent_container_t));

    /* This function parses rrm_source_rnc_to_target_rnc_transparent_container */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->number_of_Iu_instances, p_src + *p_length_read, "number_of_Iu_instances");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->number_of_Iu_instances < 1) || (p_rrm_source_rnc_to_target_rnc_transparent_container->number_of_Iu_instances > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->number_of_Iu_instances] should be in range "
            "1 to 2. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->number_of_Iu_instances);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->relocation_type, p_src + *p_length_read, "relocation_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->relocation_type > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->relocation_type] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->relocation_type);
        return RRC_FAILURE;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SECURITY_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_security_info(
        &p_rrm_source_rnc_to_target_rnc_transparent_container->security_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_D_RNTI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti, p_src + *p_length_read, "d_rnti");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti > 1048575))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti] should be less than"
            " or equal to 1048575. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TARGET_CELL_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_source_rnc_to_target_rnc_transparent_container->target_cell_id, p_src + *p_length_read, "target_cell_id");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->target_cell_id > 268435455))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->target_cell_id] should be less than"
            " or equal to 268435455. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->target_cell_id);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_rab_transport_channel_mappings, p_src + *p_length_read, "no_of_rab_transport_channel_mappings");
    *p_length_read += sizeof(U8);

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_RAB_TRANSPORT_CH_MAP_PRESENT)
    {

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_rab_transport_channel_mappings; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rab_transport_channel_mapping(
                &p_rrm_source_rnc_to_target_rnc_transparent_container->rab_transport_channel_mapping[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_srb_transport_channel_mappings, p_src + *p_length_read, "no_of_srb_transport_channel_mappings");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_srb_transport_channel_mappings > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_srb_transport_channel_mappings] should be less than"
            " or equal to 8. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_srb_transport_channel_mappings);
        return RRC_FAILURE;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SRB_TRANSPORT_CH_MAP_PRESENT)
    {

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_source_rnc_to_target_rnc_transparent_container->no_of_srb_transport_channel_mappings; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_srb_transport_channel_mapping(
                &p_rrm_source_rnc_to_target_rnc_transparent_container->srb_transport_channel_mapping[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_TRACE_REC_SESSION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_trace_recording_session_info(
        &p_rrm_source_rnc_to_target_rnc_transparent_container->trace_recording_session_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_MBMS_LINKING_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->mbms_linking_info, p_src + *p_length_read, "mbms_linking_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->mbms_linking_info > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->mbms_linking_info] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->mbms_linking_info);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_DRNTI_FOR_NO_UI_CS_UP_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti_for_no_ui_cs_up, p_src + *p_length_read, "d_rnti_for_no_ui_cs_up");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti_for_no_ui_cs_up > 1048575))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti_for_no_ui_cs_up] should be less than"
            " or equal to 1048575. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->d_rnti_for_no_ui_cs_up);
        return RRC_FAILURE;
    }
    }

    if (RRC_FAILURE == rrc_il_parse_ue_history(
        &p_rrm_source_rnc_to_target_rnc_transparent_container->ue_histroy_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SUB_PROF_ID_FOR_RAT_OR_FREQ_PRI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_source_rnc_to_target_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority, p_src + *p_length_read, "subscriber_profile_id_for_rat_or_frequency_priority");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority < 1) || (p_rrm_source_rnc_to_target_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority > 256))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority] should be in range "
            "1 to 256. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->subscriber_profile_id_for_rat_or_frequency_priority);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_SRVCC_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_srvcc_information(
        &p_rrm_source_rnc_to_target_rnc_transparent_container->srvcc_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_PS_RAB_TO_BE_REPLACED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->ps_rab_to_be_replaced, p_src + *p_length_read, "ps_rab_to_be_replaced");
    *p_length_read += sizeof(U8);
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_CSFB_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->csfb_info, p_src + *p_length_read, "csfb_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->csfb_info > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->csfb_info] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->csfb_info);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_IRAT_MEAS_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_irat_meas_config(
        &p_rrm_source_rnc_to_target_rnc_transparent_container->irat_meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_source_rnc_to_target_rnc_transparent_container->bitmask & RRM_SOURCE_RNC_TO_TARGET_RNC_TRANSPARENT_CONTAINER_MGMT_BASED_MDT_ALLOWED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_rnc_to_target_rnc_transparent_container->mgmt_based_mdt_allowed, p_src + *p_length_read, "mgmt_based_mdt_allowed");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_rnc_to_target_rnc_transparent_container->mgmt_based_mdt_allowed > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_rnc_to_target_rnc_transparent_container->mgmt_based_mdt_allowed] should be less than"
            " or equal to 0. Incorrect value %u received.", p_rrm_source_rnc_to_target_rnc_transparent_container->mgmt_based_mdt_allowed);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_irat_meas_config
(
    rrm_old_bss_to_new_bss_irat_meas_config_t *p_rrm_old_bss_to_new_bss_irat_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_old_bss_to_new_bss_irat_meas_config, 0, sizeof(rrm_old_bss_to_new_bss_irat_meas_config_t));

    /* This function parses rrm_old_bss_to_new_bss_irat_meas_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_old_bss_to_new_bss_irat_meas_config->reporting_threshold, p_src + *p_length_read, "reporting_threshold");
    *p_length_read += sizeof(U8);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_old_bss_to_new_bss_irat_meas_config->rep_quant, p_src + *p_length_read, "rep_quant");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_old_bss_to_new_bss_irat_meas_config->rep_quant > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_old_bss_to_new_bss_irat_meas_config->rep_quant] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_old_bss_to_new_bss_irat_meas_config->rep_quant);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_irat_meas_param(
        &p_rrm_old_bss_to_new_bss_irat_meas_config->irat_meas_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_source_bss_to_target_bss_transparent_container
(
    rrm_source_bss_to_target_bss_transparent_container_t *p_rrm_source_bss_to_target_bss_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_source_bss_to_target_bss_transparent_container, 0, sizeof(rrm_source_bss_to_target_bss_transparent_container_t));

    /* This function parses rrm_source_bss_to_target_bss_transparent_container */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_source_bss_to_target_bss_transparent_container->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_PAGE_MODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_bss_to_target_bss_transparent_container->page_mode, p_src + *p_length_read, "page_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_bss_to_target_bss_transparent_container->page_mode > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_bss_to_target_bss_transparent_container->page_mode] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrm_source_bss_to_target_bss_transparent_container->page_mode);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_CONTAINER_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_bss_to_target_bss_transparent_container->container_id, p_src + *p_length_read, "container_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_bss_to_target_bss_transparent_container->container_id > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_bss_to_target_bss_transparent_container->container_id] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrm_source_bss_to_target_bss_transparent_container->container_id);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_GLOBAL_TFI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_bss_to_target_bss_transparent_container->global_tfi, p_src + *p_length_read, "global_tfi");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_bss_to_target_bss_transparent_container->global_tfi > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_bss_to_target_bss_transparent_container->global_tfi] should be less than"
            " or equal to 63. Incorrect value %u received.", p_rrm_source_bss_to_target_bss_transparent_container->global_tfi);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_PS_INDICATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_bss_to_target_bss_transparent_container->ps_handover_indication, p_src + *p_length_read, "ps_handover_indication");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_source_bss_to_target_bss_transparent_container->ps_handover_indication > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_source_bss_to_target_bss_transparent_container->ps_handover_indication] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrm_source_bss_to_target_bss_transparent_container->ps_handover_indication);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_CS_INDICATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_source_bss_to_target_bss_transparent_container->cs_indication, p_src + *p_length_read, "cs_indication");
    *p_length_read += sizeof(U8);
    }

    if (p_rrm_source_bss_to_target_bss_transparent_container->bitmask & RRM_SOURCE_BSS_TO_TARGET_BSS_TRANSPARENT_CONTAINER_IRAT_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_old_bss_to_new_bss_irat_meas_config(
        &p_rrm_source_bss_to_target_bss_transparent_container->irat_meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_extra_information
(
    rrm_old_bss_to_new_bss_extra_information_t *p_rrm_old_bss_to_new_bss_extra_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_old_bss_to_new_bss_extra_information, 0, sizeof(rrm_old_bss_to_new_bss_extra_information_t));

    /* This function parses rrm_old_bss_to_new_bss_extra_information */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_old_bss_to_new_bss_extra_information->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U8);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_old_bss_to_new_bss_information
(
    rrm_old_bss_to_new_bss_information_t *p_rrm_old_bss_to_new_bss_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_old_bss_to_new_bss_information, 0, sizeof(rrm_old_bss_to_new_bss_information_t));

    /* This function parses rrm_old_bss_to_new_bss_information */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_old_bss_to_new_bss_information->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_old_bss_to_new_bss_information->bitmask & RRM_OLD_BSS_TO_NEW_BSS_INFO_EXTRA_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_old_bss_to_new_bss_extra_information(
        &p_rrm_old_bss_to_new_bss_information->extra_information,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_old_bss_to_new_bss_information->bitmask & RRM_OLD_BSS_TO_NEW_BSS_INFO_TARGET_CELL_RADIO_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_old_bss_to_new_bss_information->target_cell_rxlev, p_src + *p_length_read, "target_cell_rxlev");
    *p_length_read += sizeof(U8);
    }

    if (p_rrm_old_bss_to_new_bss_information->bitmask & RRM_OLD_BSS_TO_NEW_BSS_INFO_PS_INDICATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_old_bss_to_new_bss_information->old_bss_to_new_bss_ps_indication, p_src + *p_length_read, "old_bss_to_new_bss_ps_indication");
    *p_length_read += sizeof(U8);
    }

    if (p_rrm_old_bss_to_new_bss_information->bitmask & RRM_OLD_BSS_TO_NEW_BSS_INFO_IRAT_MEAS_CONFIG_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_old_bss_to_new_bss_irat_meas_config(
        &p_rrm_old_bss_to_new_bss_information->irat_meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_soruce_to_target_transparent_container
(
    rrm_soruce_to_target_transparent_container_t *p_rrm_soruce_to_target_transparent_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_soruce_to_target_transparent_container, 0, sizeof(rrm_soruce_to_target_transparent_container_t));

    /* This function parses rrm_soruce_to_target_transparent_container */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_soruce_to_target_transparent_container->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_soruce_to_target_transparent_container->bitmask & SOURCE_TO_TARGET_TRANSPARENT_ENB_CONTAINER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_sourceenb_to_targetenb_transparent_cotainer(
        &p_rrm_soruce_to_target_transparent_container->eNBContainer,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_soruce_to_target_transparent_container->bitmask & SOURCE_TO_TARGET_TRANSPARENT_RNC_CONTAINER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_source_rnc_to_target_rnc_transparent_container(
        &p_rrm_soruce_to_target_transparent_container->rncContainer,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_soruce_to_target_transparent_container->bitmask & SOURCE_TO_TARGET_TRANSPARENT_BSS_CONTAINER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_source_bss_to_target_bss_transparent_container(
        &p_rrm_soruce_to_target_transparent_container->bssContainer,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_soruce_to_target_transparent_container->bitmask & OLD_TO_NEW_TRANSPARENT_BSS_CONTAINER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_old_bss_to_new_bss_information(
        &p_rrm_soruce_to_target_transparent_container->old_to_new_bssContainer,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mobility_control_info
(
    mobility_control_info_t *p_mobility_control_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mobility_control_info, 0, sizeof(mobility_control_info_t));

    /* This function parses mobility_control_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mobility_control_info->t304_timer, p_src + *p_length_read, "t304_timer");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_control_info->t304_timer > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_control_info->t304_timer] should be less than"
            " or equal to 6. Incorrect value %u received.", p_mobility_control_info->t304_timer);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mobility_control_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_mobility_control_info->bitmask & RRC_RRM_UE_HO_ADM_RESP_MCI_UPLINK_POWER_CNTRL_COMMON_V1020_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_uplink_power_control_common(
        &p_mobility_control_info->uplink_power_control_common,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pz_hyst_parameters_included
(
    pz_hyst_parameters_included_t *p_pz_hyst_parameters_included,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_pz_hyst_parameters_included, 0, sizeof(pz_hyst_parameters_included_t));

    /* This function parses pz_hyst_parameters_included */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pz_hyst_parameters_included->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_pz_hyst_parameters_included->bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_enabled, p_src + *p_length_read, "pz_hyst_enabled");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pz_hyst_parameters_included->pz_hyst_enabled > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pz_hyst_parameters_included->pz_hyst_enabled] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pz_hyst_parameters_included->pz_hyst_enabled);
        return RRC_FAILURE;
    }
    }

    if (p_pz_hyst_parameters_included->bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_info_incl, p_src + *p_length_read, "pz_hyst_info_incl");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pz_hyst_parameters_included->pz_hyst_info_incl > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pz_hyst_parameters_included->pz_hyst_info_incl] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pz_hyst_parameters_included->pz_hyst_info_incl);
        return RRC_FAILURE;
    }
    }

    if (p_pz_hyst_parameters_included->bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_list_len, p_src + *p_length_read, "pz_hyst_list_len");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pz_hyst_parameters_included->pz_hyst_list_len > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pz_hyst_parameters_included->pz_hyst_list_len] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pz_hyst_parameters_included->pz_hyst_list_len);
        return RRC_FAILURE;
    }
    }

    if (p_pz_hyst_parameters_included->bitmask & 8)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_act_timer, p_src + *p_length_read, "pz_hyst_act_timer");
    *p_length_read += sizeof(U8);
    }

    if (p_pz_hyst_parameters_included->bitmask & 16)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_timer_mul, p_src + *p_length_read, "pz_hyst_timer_mul");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pz_hyst_parameters_included->pz_hyst_timer_mul > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pz_hyst_parameters_included->pz_hyst_timer_mul] should be less than"
            " or equal to 7. Incorrect value %u received.", p_pz_hyst_parameters_included->pz_hyst_timer_mul);
        return RRC_FAILURE;
    }
    }

    if (p_pz_hyst_parameters_included->bitmask & 32)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pz_hyst_parameters_included->pz_hyst_timer_exp, p_src + *p_length_read, "pz_hyst_timer_exp");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pz_hyst_parameters_included->pz_hyst_timer_exp > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pz_hyst_parameters_included->pz_hyst_timer_exp] should be less than"
            " or equal to 31. Incorrect value %u received.", p_pz_hyst_parameters_included->pz_hyst_timer_exp);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_mobility_parameters
(
    mobility_parameters_t *p_mobility_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_mobility_parameters, 0, sizeof(mobility_parameters_t));

    /* This function parses mobility_parameters */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_mobility_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U32);

    if (p_mobility_parameters->bitmask & SID_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mobility_parameters->sid, p_src + *p_length_read, "sid");
    *p_length_read += sizeof(U16);
    }

    if (p_mobility_parameters->bitmask & NID_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mobility_parameters->nid, p_src + *p_length_read, "nid");
    *p_length_read += sizeof(U16);
    }

    if (p_mobility_parameters->bitmask & MULT_SIDS_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->multi_sids, p_src + *p_length_read, "multi_sids");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->multi_sids > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->multi_sids] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->multi_sids);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & MULT_NIDS_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->multi_nids, p_src + *p_length_read, "multi_nids");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->multi_nids > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->multi_nids] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->multi_nids);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & REG_ZONE_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_mobility_parameters->reg_zone, p_src + *p_length_read, "reg_zone");
    *p_length_read += sizeof(U16);
    }

    if (p_mobility_parameters->bitmask & TOTAL_ZONES_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->total_zones, p_src + *p_length_read, "total_zones");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & ZONE_TIMER_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->zone_timer, p_src + *p_length_read, "zone_timer");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & PACKET_ZONE_ID_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->packet_zone_id, p_src + *p_length_read, "packet_zone_id");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & PZ_ID_HYST_PARAMETERS_INCLUDED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_pz_hyst_parameters_included(
        &p_mobility_parameters->pz_hyst_parameters_included,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_mobility_parameters->bitmask & P_REV_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->p_rev, p_src + *p_length_read, "p_rev");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & MIN_P_REV_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->min_p_rev, p_src + *p_length_read, "min_p_rev");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & NEG_SLOT_CYCLE_INDEX_SUP_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->neg_slot_cycle_index_sup, p_src + *p_length_read, "neg_slot_cycle_index_sup");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->neg_slot_cycle_index_sup > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->neg_slot_cycle_index_sup] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->neg_slot_cycle_index_sup);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & ENCRYPT_MODE_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->encrypt_mode, p_src + *p_length_read, "encrypt_mode");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->encrypt_mode > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->encrypt_mode] should be less than"
            " or equal to 3. Incorrect value %u received.", p_mobility_parameters->encrypt_mode);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & ENC_SUPPORTED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->enc_supported, p_src + *p_length_read, "enc_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->enc_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->enc_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->enc_supported);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & SIG_ENCRYPT_SUP_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->sig_encrypt_sup, p_src + *p_length_read, "sig_encrypt_sup");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & MSG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->msg_integrity_sup, p_src + *p_length_read, "msg_integrity_sup");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->msg_integrity_sup > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->msg_integrity_sup] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->msg_integrity_sup);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & SIG_INTEGRITY_SUP_INCL_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->sig_integrity_sup_incl, p_src + *p_length_read, "sig_integrity_sup_incl");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->sig_integrity_sup_incl > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->sig_integrity_sup_incl] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->sig_integrity_sup_incl);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & SIG_INTEGRITY_SUP_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->sig_integrity_sup, p_src + *p_length_read, "sig_integrity_sup");
    *p_length_read += sizeof(U8);
    }

    if (p_mobility_parameters->bitmask & AUTH_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->auth, p_src + *p_length_read, "auth");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->auth > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->auth] should be less than"
            " or equal to 3. Incorrect value %u received.", p_mobility_parameters->auth);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & MAX_NUM_ALT_SO_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->max_num_alt_so, p_src + *p_length_read, "max_num_alt_so");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->max_num_alt_so > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->max_num_alt_so] should be less than"
            " or equal to 7. Incorrect value %u received.", p_mobility_parameters->max_num_alt_so);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & USE_SYNC_ID_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->use_sync_id, p_src + *p_length_read, "use_sync_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->use_sync_id > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->use_sync_id] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->use_sync_id);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & MS_INIT_POS_LOC_SUP_IND_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->ms_init_pos_loc_sup_ind, p_src + *p_length_read, "ms_init_pos_loc_sup_ind");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->ms_init_pos_loc_sup_ind > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->ms_init_pos_loc_sup_ind] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->ms_init_pos_loc_sup_ind);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & MOB_QOS_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->mob_qos, p_src + *p_length_read, "mob_qos");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->mob_qos > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->mob_qos] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->mob_qos);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & BAND_CLASS_INFO_REQ_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->band_class_info_req, p_src + *p_length_read, "band_class_info_req");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->band_class_info_req > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->band_class_info_req] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->band_class_info_req);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & BAND_CLASS_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_mobility_parameters->band_class);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & BYPASS_REG_IND_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->bypass_reg_ind, p_src + *p_length_read, "bypass_reg_ind");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->bypass_reg_ind > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->bypass_reg_ind] should be less than"
            " or equal to 31. Incorrect value %u received.", p_mobility_parameters->bypass_reg_ind);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & ALT_BAND_CLASS_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->alt_band_class, p_src + *p_length_read, "alt_band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->alt_band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->alt_band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_mobility_parameters->alt_band_class);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & MAX_ADD_SERV_INSTANCE_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->max_add_serv_instance, p_src + *p_length_read, "max_add_serv_instance");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->max_add_serv_instance > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->max_add_serv_instance] should be less than"
            " or equal to 7. Incorrect value %u received.", p_mobility_parameters->max_add_serv_instance);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & HOME_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->home_reg, p_src + *p_length_read, "home_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->home_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->home_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->home_reg);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & FOR_SID_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->for_sid_reg, p_src + *p_length_read, "for_sid_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->for_sid_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->for_sid_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->for_sid_reg);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & FOR_NID_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->for_nid_reg, p_src + *p_length_read, "for_nid_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->for_nid_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->for_nid_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->for_nid_reg);
        return RRC_FAILURE;
    }
    }

    if (p_mobility_parameters->bitmask & POWER_UP_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_mobility_parameters->power_up_reg, p_src + *p_length_read, "power_up_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_mobility_parameters->power_up_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_mobility_parameters->power_up_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_mobility_parameters->power_up_reg);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_fpc_fch_included
(
    fpc_fch_included_t *p_fpc_fch_included,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_fpc_fch_included, 0, sizeof(fpc_fch_included_t));

    /* This function parses fpc_fch_included */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_fpc_fch_included->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_fpc_fch_included->bitmask & 1)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_fpc_fch_included->fpc_fch_init_setpt_rc3, p_src + *p_length_read, "fpc_fch_init_setpt_rc3");
    *p_length_read += sizeof(U8);
    }

    if (p_fpc_fch_included->bitmask & 2)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_fpc_fch_included->fpc_fch_init_setpt_rc4, p_src + *p_length_read, "fpc_fch_init_setpt_rc4");
    *p_length_read += sizeof(U8);
    }

    if (p_fpc_fch_included->bitmask & 4)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_fpc_fch_included->fpc_fch_init_setpt_rc5, p_src + *p_length_read, "fpc_fch_init_setpt_rc5");
    *p_length_read += sizeof(U8);
    }

    if (p_fpc_fch_included->bitmask & 8)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_fpc_fch_included->fpc_fch_init_setpt_rc11, p_src + *p_length_read, "fpc_fch_init_setpt_rc11");
    *p_length_read += sizeof(U8);
    }

    if (p_fpc_fch_included->bitmask & 16)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_fpc_fch_included->fpc_fch_init_setpt_rc12, p_src + *p_length_read, "fpc_fch_init_setpt_rc12");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_additional_mobility_parameters
(
    additional_mobility_parameters_t *p_additional_mobility_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_additional_mobility_parameters, 0, sizeof(additional_mobility_parameters_t));

    /* This function parses additional_mobility_parameters */

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_additional_mobility_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U32);

    if (p_additional_mobility_parameters->bitmask & POWER_DOWN_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->power_down_reg, p_src + *p_length_read, "power_down_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->power_down_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->power_down_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->power_down_reg);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & PARAMETER_REG_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->parameter_reg, p_src + *p_length_read, "parameter_reg");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->parameter_reg > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->parameter_reg] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->parameter_reg);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & REG_PRD_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->reg_prd, p_src + *p_length_read, "reg_prd");
    *p_length_read += sizeof(U8);
    }

    if (p_additional_mobility_parameters->bitmask & REG_DIST_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_additional_mobility_parameters->reg_dist, p_src + *p_length_read, "reg_dist");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->reg_dist > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->reg_dist] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_additional_mobility_parameters->reg_dist);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & PREF_MSID_TYPE_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->pref_msid_type, p_src + *p_length_read, "pref_msid_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->pref_msid_type > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->pref_msid_type] should be less than"
            " or equal to 3. Incorrect value %u received.", p_additional_mobility_parameters->pref_msid_type);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & EXT_PREF_MSID_TYPE_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->ext_pref_msid_type, p_src + *p_length_read, "ext_pref_msid_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->ext_pref_msid_type > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->ext_pref_msid_type] should be less than"
            " or equal to 3. Incorrect value %u received.", p_additional_mobility_parameters->ext_pref_msid_type);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & MEID_REQD_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->meid_reqd, p_src + *p_length_read, "meid_reqd");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->meid_reqd > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->meid_reqd] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->meid_reqd);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & MCC_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_additional_mobility_parameters->mcc, p_src + *p_length_read, "mcc");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->mcc > 1023))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->mcc] should be less than"
            " or equal to 1023. Incorrect value %u received.", p_additional_mobility_parameters->mcc);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & IMSI_11_12_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->imsi_11_12, p_src + *p_length_read, "imsi_11_12");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->imsi_11_12 > 127))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->imsi_11_12] should be less than"
            " or equal to 127. Incorrect value %u received.", p_additional_mobility_parameters->imsi_11_12);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & IMSI_T_SUPPORTED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->imsi_t_supported, p_src + *p_length_read, "imsi_t_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->imsi_t_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->imsi_t_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->imsi_t_supported);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & RECONNECT_MSG_IND_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->reconnect_msg_ind, p_src + *p_length_read, "reconnect_msg_ind");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->reconnect_msg_ind > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->reconnect_msg_ind] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->reconnect_msg_ind);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & RER_MODE_SUPPORTED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->rer_mode_supported, p_src + *p_length_read, "rer_mode_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->rer_mode_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->rer_mode_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->rer_mode_supported);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & TKZ_MODE_SUPPORTED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->tkz_mode_supported, p_src + *p_length_read, "tkz_mode_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->tkz_mode_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->tkz_mode_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->tkz_mode_supported);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & TKZ_ID_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->tkz_id, p_src + *p_length_read, "tkz_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->tkz_id > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->tkz_id] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->tkz_id);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & PILOT_REPORT_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->pilot_report, p_src + *p_length_read, "pilot_report");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->pilot_report > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->pilot_report] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->pilot_report);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & SDB_SUPPORTED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->sdb_supported, p_src + *p_length_read, "sdb_supported");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->sdb_supported > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->sdb_supported] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->sdb_supported);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & AUTO_FCSO_ALLOWED_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->auto_fcso_allowed, p_src + *p_length_read, "auto_fcso_allowed");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->auto_fcso_allowed > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->auto_fcso_allowed] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->auto_fcso_allowed);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & SDB_IN_RCNM_IND_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->sdb_in_rcnm_ind, p_src + *p_length_read, "sdb_in_rcnm_ind");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->sdb_in_rcnm_ind > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->sdb_in_rcnm_ind] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->sdb_in_rcnm_ind);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & FPC_FCH_INCLUDED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_fpc_fch_included(
        &p_additional_mobility_parameters->fpc_fch_included,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_additional_mobility_parameters->bitmask & T_ADD_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->t_add, p_src + *p_length_read, "t_add");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->t_add > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->t_add] should be less than"
            " or equal to 63. Incorrect value %u received.", p_additional_mobility_parameters->t_add);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & PILOT_INC_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->pilot_inc, p_src + *p_length_read, "pilot_inc");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->pilot_inc > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->pilot_inc] should be less than"
            " or equal to 15. Incorrect value %u received.", p_additional_mobility_parameters->pilot_inc);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & LP_SEC_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->lp_sec, p_src + *p_length_read, "lp_sec");
    *p_length_read += sizeof(U8);
    }

    if (p_additional_mobility_parameters->bitmask & DAYLT_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->daylt, p_src + *p_length_read, "daylt");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_additional_mobility_parameters->daylt > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_mobility_parameters->daylt] should be less than"
            " or equal to 1. Incorrect value %u received.", p_additional_mobility_parameters->daylt);
        return RRC_FAILURE;
    }
    }

    if (p_additional_mobility_parameters->bitmask & GCSNA_L2_ACK_TIMER_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->gcsna_l2_ack_timer, p_src + *p_length_read, "gcsna_l2_ack_timer");
    *p_length_read += sizeof(U8);
    }

    if (p_additional_mobility_parameters->bitmask & GCSNA_SEQUENCE_CONTEXT_TIMER_INCLUDED_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_mobility_parameters->gcsna_sequence_context_timer, p_src + *p_length_read, "gcsna_sequence_context_timer");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_channel_record
(
    channel_record_t *p_channel_record,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_channel_record, 0, sizeof(channel_record_t));

    /* This function parses channel_record */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_channel_record->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_channel_record->system_type, p_src + *p_length_read, "system_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_channel_record->system_type > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_channel_record->system_type] should be less than"
            " or equal to 2. Incorrect value %u received.", p_channel_record->system_type);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_channel_record->band_class, p_src + *p_length_read, "band_class");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_channel_record->band_class > 31))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_channel_record->band_class] should be less than"
            " or equal to 31. Incorrect value %u received.", p_channel_record->band_class);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_channel_record->channel_number, p_src + *p_length_read, "channel_number");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_channel_record->channel_number > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_channel_record->channel_number] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_channel_record->channel_number);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pilot_entry
(
    pilot_entry_t *p_pilot_entry,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pilot_entry, 0, sizeof(pilot_entry_t));

    /* This function parses pilot_entry */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pilot_entry->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_channel_record(
        &p_pilot_entry->channel_record,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pilot_entry->cell_id_info, p_src + *p_length_read, "cell_id_info");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pilot_entry->cell_id_info > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_entry->cell_id_info] should be less than"
            " or equal to 7. Incorrect value %u received.", p_pilot_entry->cell_id_info);
        return RRC_FAILURE;
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_1X_CELL_IDENTIFIER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_1xrtt_cell_identifier(
        &p_pilot_entry->cdma2000_1xrtt_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_HRPD_SECTOR_IDENTIFIER_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cdma2000_hrpd_sector_identifier(
        &p_pilot_entry->cdma2000_hrpd_sector_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_REFERENCE_PILOT_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pilot_entry->reference_pilot, p_src + *p_length_read, "reference_pilot");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pilot_entry->reference_pilot > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_entry->reference_pilot] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pilot_entry->reference_pilot);
        return RRC_FAILURE;
    }
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_PILOT_PN_INFORMATION_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pilot_entry->pilot_pn_info, p_src + *p_length_read, "pilot_pn_info");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_pilot_entry->pilot_pn_info > 32767))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_entry->pilot_pn_info] should be less than"
            " or equal to 32767. Incorrect value %u received.", p_pilot_entry->pilot_pn_info);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pilot_entry->pilot_one_way_delay_included, p_src + *p_length_read, "pilot_one_way_delay_included");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pilot_entry->pilot_one_way_delay_included > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_entry->pilot_one_way_delay_included] should be less than"
            " or equal to 1. Incorrect value %u received.", p_pilot_entry->pilot_one_way_delay_included);
        return RRC_FAILURE;
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_PILOT_STRENGTH_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pilot_entry->pilot_strength, p_src + *p_length_read, "pilot_strength");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_pilot_entry->pilot_strength > 63))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_entry->pilot_strength] should be less than"
            " or equal to 63. Incorrect value %u received.", p_pilot_entry->pilot_strength);
        return RRC_FAILURE;
    }
    }

    if (p_pilot_entry->bitmask & PILOT_ENTRY_PILOT_ONE_WAY_DELAY_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_pilot_entry->pilot_one_way_delay, p_src + *p_length_read, "pilot_one_way_delay");
    *p_length_read += sizeof(U16);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_pilot_list
(
    pilot_list_t *p_pilot_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_pilot_list, 0, sizeof(pilot_list_t));

    /* This function parses pilot_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_pilot_list->num_of_pilots, p_src + *p_length_read, "num_of_pilots");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_pilot_list->num_of_pilots < 1) || (p_pilot_list->num_of_pilots > MAX_PILOT_ENTRY))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_pilot_list->num_of_pilots] should be in range "
            "1 to MAX_PILOT_ENTRY. Incorrect value %u received.", p_pilot_list->num_of_pilots);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_pilot_list->num_of_pilots; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_pilot_entry(
                &p_pilot_list->pilot_entry[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ho_from_eutra_preperation_req_r10_ies
(
    ho_from_eutra_preperation_req_r10_ies_t *p_ho_from_eutra_preperation_req_r10_ies,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ho_from_eutra_preperation_req_r10_ies, 0, sizeof(ho_from_eutra_preperation_req_r10_ies_t));

    /* This function parses ho_from_eutra_preperation_req_r10_ies */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ho_from_eutra_preperation_req_r10_ies->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_ho_from_eutra_preperation_req_r10_ies->bitmask & RRC_RRM_HO_FROM_EUTRA_DUAL_RX_TX_REDIRECT_IND_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ho_from_eutra_preperation_req_r10_ies->dual_rx_tx_redirect_ind_r10, p_src + *p_length_read, "dual_rx_tx_redirect_ind_r10");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ho_from_eutra_preperation_req_r10_ies->dual_rx_tx_redirect_ind_r10 > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ho_from_eutra_preperation_req_r10_ies->dual_rx_tx_redirect_ind_r10] should be less than"
            " or equal to 0. Incorrect value %u received.", p_ho_from_eutra_preperation_req_r10_ies->dual_rx_tx_redirect_ind_r10);
        return RRC_FAILURE;
    }
    }

    if (p_ho_from_eutra_preperation_req_r10_ies->bitmask & RRC_RRM_HO_FROM_EUTRA_REDIRECT_CARRIER_CDMA2000_1XRTT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_ho_from_eutra_preperation_req_r10_ies->redirect_carrier_cdma2000_1XRTT_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_cdma2000_information
(
    rrm_cdma2000_information_t *p_rrm_cdma2000_information,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_cdma2000_information, 0, sizeof(rrm_cdma2000_information_t));

    /* This function parses rrm_cdma2000_information */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_cdma2000_information->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_cdma2000_information->bitmask & RRC_RRM_HO_REQUIRED_MOBILITY_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mobility_parameters(
        &p_rrm_cdma2000_information->mobility_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_cdma2000_information->bitmask & RRC_RRM_HO_REQUIRED_ADDITIONAL_MOBILITY_PARAMETERS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_additional_mobility_parameters(
        &p_rrm_cdma2000_information->add_mobility_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_cdma2000_information->bitmask & RRC_RRM_HO_REQUIRED_PILOT_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_pilot_list(
        &p_rrm_cdma2000_information->pilot_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_cdma2000_information->bitmask & RRC_RRM_EUTRAN_ROUND_TRIP_DELAY_EST_INFO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_cdma2000_information->eutran_round_trip_delay_estimation_info, p_src + *p_length_read, "eutran_round_trip_delay_estimation_info");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_cdma2000_information->eutran_round_trip_delay_estimation_info > 2047))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_cdma2000_information->eutran_round_trip_delay_estimation_info] should be less than"
            " or equal to 2047. Incorrect value %u received.", p_rrm_cdma2000_information->eutran_round_trip_delay_estimation_info);
        return RRC_FAILURE;
    }
    }

    if (p_rrm_cdma2000_information->bitmask & RRC_RRM_HO_REQUIRED_HO_FROM_EUTRA_PREPERATION_REQ_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ho_from_eutra_preperation_req_r10_ies(
        &p_rrm_cdma2000_information->ho_from_eutra_preperation_req_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_system_info_list_geran_si_psi
(
    system_info_list_geran_si_psi_t *p_system_info_list_geran_si_psi,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_system_info_list_geran_si_psi, 0, sizeof(system_info_list_geran_si_psi_t));

    /* This function parses system_info_list_geran_si_psi */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_system_info_list_geran_si_psi->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_system_info_list_geran_si_psi->bitmask & SYSTEM_INFO_LIST_GERAN_SI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_system_info_list_geran(
        &p_system_info_list_geran_si_psi->si,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_system_info_list_geran_si_psi->bitmask & SYSTEM_INFO_LIST_GERAN_PSI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_system_info_list_geran(
        &p_system_info_list_geran_si_psi->psi,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_target_rat_type_geran
(
    rrc_target_rat_type_geran_t *p_rrc_target_rat_type_geran,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_target_rat_type_geran, 0, sizeof(rrc_target_rat_type_geran_t));

    /* This function parses rrc_target_rat_type_geran */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_target_rat_type_geran->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_phys_cell_id_geran(
        &p_rrc_target_rat_type_geran->pci_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_geran(
        &p_rrc_target_rat_type_geran->carr_freq,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_target_rat_type_geran->bitmask & RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_NCO_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_target_rat_type_geran->nco, p_src + *p_length_read, "nco");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_target_rat_type_geran->nco > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_target_rat_type_geran->nco] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_target_rat_type_geran->nco);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_target_rat_type_geran->bitmask & RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_SI_PSI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_system_info_list_geran_si_psi(
        &p_rrc_target_rat_type_geran->si_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_target_rat_type
(
    rrc_target_rat_type_t *p_rrc_target_rat_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_target_rat_type, 0, sizeof(rrc_target_rat_type_t));

    /* This function parses rrc_target_rat_type */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_target_rat_type->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_target_rat_type->bitmask & RRC_RRM_UE_CCO_TARGET_RAT_GERAN_TYPE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_target_rat_type_geran(
        &p_rrc_target_rat_type->geran_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cco_parameters
(
    cco_parameters_t *p_cco_parameters,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cco_parameters, 0, sizeof(cco_parameters_t));

    /* This function parses cco_parameters */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cco_parameters->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cco_parameters->cs_fallback_indicator, p_src + *p_length_read, "cs_fallback_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_cco_parameters->cs_fallback_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cco_parameters->cs_fallback_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_cco_parameters->cs_fallback_indicator);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_target_rat_type(
        &p_cco_parameters->target_rat_params,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_ho_adm_req
(
    rrc_rrm_ue_ho_adm_req_t *p_rrc_rrm_ue_ho_adm_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_ho_adm_req, 0, sizeof(rrc_rrm_ue_ho_adm_req_t));

    /* This function parses rrc_rrm_ue_ho_adm_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_ho_adm_req->ho_type, p_src + *p_length_read, "ho_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_ho_adm_req->ho_type > 11))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_ho_adm_req->ho_type] should be less than"
            " or equal to 11. Incorrect value %u received.", p_rrc_rrm_ue_ho_adm_req->ho_type);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ue_ho_adm_req->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_ue_ho_adm_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_setup_item_list(
        &p_rrc_rrm_ue_ho_adm_req->erab_to_be_setup_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_src_to_trg_container(
        &p_rrc_rrm_ue_ho_adm_req->src_to_trg_container,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_HO_RESTRICTION_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_ho_restriction_list(
        &p_rrc_rrm_ue_ho_adm_req->ho_restriction_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_REQUEST_TYPE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_request_type(
        &p_rrc_rrm_ue_ho_adm_req->request_type,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_SRVCC_OP_POSSIBLE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_ho_adm_req->srvcc_op_possible, p_src + *p_length_read, "srvcc_op_possible");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_CSG_MEMBERSHIP_STATUS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ue_ho_adm_req->csg_membership_status, p_src + *p_length_read, "csg_membership_status");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_GUMMEI_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mme_sel_gummei_info(
        &p_rrc_rrm_ue_ho_adm_req->gummei_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_req->bitmask & RRC_RRM_UE_HO_ADM_REQ_MME_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_ho_adm_req->mme_id, p_src + *p_length_read, "mme_id");
    *p_length_read += sizeof(U8);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_radio_resource_config_dedicated
(
    radio_resource_config_dedicated_t *p_radio_resource_config_dedicated,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_radio_resource_config_dedicated, 0, sizeof(radio_resource_config_dedicated_t));

    /* This function parses radio_resource_config_dedicated */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_radio_resource_config_dedicated->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_info(
        &p_radio_resource_config_dedicated->rrm_srb_to_add_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_to_add_info_list(
        &p_radio_resource_config_dedicated->rrm_drb_to_add_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrc_mac_main_config(
        &p_radio_resource_config_dedicated->mac_main_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_radio_resource_config_dedicated->bitmask & RADIO_RESOURCE_CONFIG_DEDICATED_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_radio_resource_config_dedicated->sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_dedicated->bitmask & RADIO_RESOURCE_CONFIG_DEDICATED_PHYSICAL_CONFIG_DEDICATED_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated(
        &p_radio_resource_config_dedicated->rrc_phy_physical_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config_dedicated->bitmask & RADIO_RESOURCE_CONFIG_DEDICATED_RLF_TIMERS_AND_CONSTANTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rlf_timers_and_constants_r9(
        &p_radio_resource_config_dedicated->rlf_timers_and_constants_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_security_algorithm_config
(
    security_algorithm_config_t *p_security_algorithm_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_security_algorithm_config, 0, sizeof(security_algorithm_config_t));

    /* This function parses security_algorithm_config */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_algorithm_config->ciphering_algo, p_src + *p_length_read, "ciphering_algo");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_algorithm_config->ciphering_algo > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_algorithm_config->ciphering_algo] should be less than"
            " or equal to 2. Incorrect value %u received.", p_security_algorithm_config->ciphering_algo);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_security_algorithm_config->integrity_protect_algo, p_src + *p_length_read, "integrity_protect_algo");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_security_algorithm_config->integrity_protect_algo > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_security_algorithm_config->integrity_protect_algo] should be less than"
            " or equal to 2. Incorrect value %u received.", p_security_algorithm_config->integrity_protect_algo);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_as_config
(
    as_config_t *p_as_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_as_config, 0, sizeof(as_config_t));

    /* This function parses as_config */

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_as_config->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_radio_resource_config_dedicated(
        &p_as_config->radio_resource_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_security_algorithm_config(
        &p_as_config->security_algorithm_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_mib_info(
        &p_as_config->master_information_block,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_sib_type_1_Info(
        &p_as_config->sib_type1_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_sib_type_2_Info(
        &p_as_config->sib_type2_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_as_config->antenna_info_common, p_src + *p_length_read, "antenna_info_common");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_as_config->antenna_info_common > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_as_config->antenna_info_common] should be less than"
            " or equal to 2. Incorrect value %u received.", p_as_config->antenna_info_common);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_as_config->dl_carrier_freq, p_src + *p_length_read, "dl_carrier_freq");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_additional_reestab_info
(
    additional_reestab_info_t *p_additional_reestab_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_additional_reestab_info, 0, sizeof(additional_reestab_info_t));

    /* This function parses additional_reestab_info */

    if (*p_length_read + (S32)sizeof(p_additional_reestab_info->cell_Id) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_additional_reestab_info->cell_Id); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_additional_reestab_info->cell_Id[loop], (void*)(p_src + *p_length_read), "cell_Id[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_additional_reestab_info->short_mac_i, p_src + *p_length_read, "short_mac_i");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_additional_reestab_info_list
(
    additional_reestab_info_list_t *p_additional_reestab_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_additional_reestab_info_list, 0, sizeof(additional_reestab_info_list_t));

    /* This function parses additional_reestab_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_additional_reestab_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_additional_reestab_info_list->count < 1) || (p_additional_reestab_info_list->count > MAX_NUM_TARGET_CELL))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_additional_reestab_info_list->count] should be in range "
            "1 to MAX_NUM_TARGET_CELL. Incorrect value %u received.", p_additional_reestab_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_additional_reestab_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_additional_reestab_info(
                &p_additional_reestab_info_list->additional_reestab_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_as_context
(
    as_context_t *p_as_context,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_as_context, 0, sizeof(as_context_t));

    /* This function parses as_context */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_as_context->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_as_context->source_phy_cell_id, p_src + *p_length_read, "source_phy_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_as_context->source_phy_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_as_context->source_phy_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_as_context->source_phy_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_as_context->target_cell_short_mac_i, p_src + *p_length_read, "target_cell_short_mac_i");
    *p_length_read += sizeof(U16);

    if (p_as_context->bitmask & AS_CONTEXT_ADDITIONAL_REESTAB_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_additional_reestab_info_list(
        &p_as_context->additional_reestab_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_as_config_ext
(
    as_config_ext_t *p_as_config_ext,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_as_config_ext, 0, sizeof(as_config_ext_t));

    /* This function parses as_config_ext */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_as_config_ext->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_as_config_ext->bitmask & SRC_TO_TRG_CONTAINER_AS_CONFIG_SCELL_ADD_MOD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_scell_to_add_mod_list(
        &p_as_config_ext->scell_add_mod_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_src_to_trg_container
(
    src_to_trg_container_t *p_src_to_trg_container,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_src_to_trg_container, 0, sizeof(src_to_trg_container_t));

    /* This function parses src_to_trg_container */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_src_to_trg_container->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_radio_capability_info(
        &p_src_to_trg_container->rrc_radio_capability_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_AS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_as_config(
        &p_src_to_trg_container->as_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_AS_CONTEXT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_as_context(
        &p_src_to_trg_container->as_context,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_SUB_PROFILE_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_src_to_trg_container->sub_profile_id, p_src + *p_length_read, "sub_profile_id");
    *p_length_read += sizeof(U16);
    }

    if (RRC_FAILURE == rrc_il_parse_ue_history(
        &p_src_to_trg_container->ue_history,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_AS_CONFIG_PROXIMITY_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_report_proximity_config_r9(
        &p_src_to_trg_container->proximity_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_RRM_CONFIG_EXT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_config(
        &p_src_to_trg_container->rrm_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_src_to_trg_container->bitmask & SRC_TO_TRG_CONTAINER_AS_CONFIG_EXT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_as_config_ext(
        &p_src_to_trg_container->as_config_ext,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_request_type
(
    request_type_t *p_request_type,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_request_type, 0, sizeof(request_type_t));

    /* This function parses request_type */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_request_type->event_type, p_src + *p_length_read, "event_type");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_request_type->event_type > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_request_type->event_type] should be less than"
            " or equal to 2. Incorrect value %u received.", p_request_type->event_type);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_request_type->report_area, p_src + *p_length_read, "report_area");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_request_type->report_area > 0))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_request_type->report_area] should be less than"
            " or equal to 0. Incorrect value %u received.", p_request_type->report_area);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_ho_adm_resp
(
    rrc_rrm_ue_ho_adm_resp_t *p_rrc_rrm_ue_ho_adm_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_ho_adm_resp, 0, sizeof(rrc_rrm_ue_ho_adm_resp_t));

    /* This function parses rrc_rrm_ue_ho_adm_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ue_ho_adm_resp->ue_inactive_time_config, p_src + *p_length_read, "ue_inactive_time_config");
    *p_length_read += sizeof(U32);

    if (RRC_FAILURE == rrc_il_parse_rrm_response(
        &p_rrc_rrm_ue_ho_adm_resp->response,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_ue_ho_adm_resp->bitmask & RRC_RRM_UE_HO_ADM_RESP_RADIO_REOURCE_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_radio_resource_config(
        &p_rrc_rrm_ue_ho_adm_resp->radio_resource_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_resp->bitmask & RRC_RRM_UE_HO_ADM_RESP_MOBILITY_CONTROL_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_mobility_control_info(
        &p_rrc_rrm_ue_ho_adm_resp->mobility_control_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_resp->bitmask & RRC_RRM_UE_HO_ADM_RESP_CONFIG_PROXIMITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_report_proximity_config_r9(
        &p_rrc_rrm_ue_ho_adm_resp->proximity_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_resp->bitmask & RRC_RRM_UE_HO_ADM_RESP_CONFIG_SCELL_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_scell_config(
        &p_rrc_rrm_ue_ho_adm_resp->scell_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_response
(
    rrm_response_t *p_rrm_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_response, 0, sizeof(rrm_response_t));

    /* This function parses rrm_response */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_response->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_response->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_response->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_response->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrm_response->response);
        return RRC_FAILURE;
    }

    if (p_rrm_response->bitmask & RRM_RESPONSE_CAUSE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrm_response->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd
(
    rrm_drb_sub_to_fwd_t *p_rrm_drb_sub_to_fwd,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_sub_to_fwd, 0, sizeof(rrm_drb_sub_to_fwd_t));

    /* This function parses rrm_drb_sub_to_fwd */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_sub_to_fwd->forward_direction, p_src + *p_length_read, "forward_direction");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_sub_to_fwd->forward_direction > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_sub_to_fwd->forward_direction] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrm_drb_sub_to_fwd->forward_direction);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_sub_to_fwd->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_sub_to_fwd->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_sub_to_fwd->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_drb_sub_to_fwd->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd_list
(
    rrm_drb_sub_to_fwd_list_t *p_rrm_drb_sub_to_fwd_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_sub_to_fwd_list, 0, sizeof(rrm_drb_sub_to_fwd_list_t));

    /* This function parses rrm_drb_sub_to_fwd_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_sub_to_fwd_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_sub_to_fwd_list->count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_sub_to_fwd_list->count] should be less than"
            " or equal to MAX_LC_COUNT. Incorrect value %u received.", p_rrm_drb_sub_to_fwd_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_drb_sub_to_fwd_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_drb_sub_to_fwd(
                &p_rrm_drb_sub_to_fwd_list->drb_sub_to_fwd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_radio_resource_config
(
    radio_resource_config_t *p_radio_resource_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_radio_resource_config, 0, sizeof(radio_resource_config_t));

    /* This function parses radio_resource_config */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_radio_resource_config->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_srb_info(
        &p_radio_resource_config->srb_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_to_add_info_list(
        &p_radio_resource_config->drb_to_add_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_rrm_mac_config(
        &p_radio_resource_config->mac_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_radio_resource_config->bitmask & RADIO_RESOURCE_CONFIG_SPS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_sps_config(
        &p_radio_resource_config->rrc_sps_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_phy_physical_config_dedicated(
        &p_radio_resource_config->physical_config_dedicated,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_radio_resource_config->bitmask & RADIO_RESOURCE_CONFIG_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_radio_resource_config->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config->bitmask & RADIO_RESOURCE_CONFIG_DRB_SUB_FWR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_sub_to_fwd_list(
        &p_radio_resource_config->drb_sub_to_fwd_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config->bitmask & RADIO_RESOURCE_CONFIG_DRB_FAIL_TO_ADD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_failed_to_add_info_list(
        &p_radio_resource_config->drb_failed_to_add_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config->bitmask & RADIO_RESOURCE_CONFIG_RLF_TIMERS_AND_CONSTANTS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rlf_timers_and_constants_r9(
        &p_radio_resource_config->rlf_timers_and_constants_r9,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_radio_resource_config->bitmask & RRM_UE_CONFIG_MEAS_SUBFRAME_PATTERN_PCELL_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_subframe_pattern_pcell_r10(
        &p_radio_resource_config->rrc_meas_subframe_pattern_pcell_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_ho_adm_cnf
(
    rrc_rrm_ue_ho_adm_cnf_t *p_rrc_rrm_ue_ho_adm_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_ho_adm_cnf, 0, sizeof(rrc_rrm_ue_ho_adm_cnf_t));

    /* This function parses rrc_rrm_ue_ho_adm_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_adm_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_ho_adm_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_ho_adm_cnf->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_ho_adm_cnf->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_ho_adm_cnf->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_ho_adm_cnf->bitmask & RRC_RRM_UE_HO_ADM_CNF_ERAB_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_erab_item_list(
        &p_rrc_rrm_ue_ho_adm_cnf->erab_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_cnf->bitmask & RRC_RRM_UE_HO_ADM_CNF_ERAB_FAILED_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_failed_item_list(
        &p_rrc_rrm_ue_ho_adm_cnf->erab_failed_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_cnf->bitmask & RRC_RRM_UE_HO_ADM_CNF_ERAB_RELEASE_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_to_be_released_item_list(
        &p_rrc_rrm_ue_ho_adm_cnf->erab_to_be_released_item_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_adm_cnf->bitmask & RRC_RRM_UE_HO_ADM_CNF_ERROR_CODE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_ho_adm_cnf->error_code, p_src + *p_length_read, "error_code");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_ho_adm_cnf->error_code > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_ho_adm_cnf->error_code] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_ho_adm_cnf->error_code);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_erab_item_list
(
    erab_item_list_t *p_erab_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_erab_item_list, 0, sizeof(erab_item_list_t));

    /* This function parses erab_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_erab_item_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_erab_item_list->count > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_erab_item_list->count] should be less than"
            " or equal to 8. Incorrect value %u received.", p_erab_item_list->count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_erab_item_list->count * sizeof(p_erab_item_list->erab_id[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with HIGHER boundary
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_erab_item_list->count; loop++)
        {
            rrc_cp_unpack_U16((void*)&p_erab_item_list->erab_id[loop], (void*)(p_src + *p_length_read), "erab_id[]");
            if (p_erab_item_list->erab_id[loop] > 15)
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_erab_item_list->erab_id[%u] should be less"
                    " than or equal to 15. "
                    "Incorrect value %d received.", loop, p_erab_item_list->erab_id[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U16);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_erab_failed_item_list
(
    rrm_erab_failed_item_list_t *p_rrm_erab_failed_item_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_erab_failed_item_list, 0, sizeof(rrm_erab_failed_item_list_t));

    /* This function parses rrm_erab_failed_item_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_erab_failed_item_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U16);

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrm_erab_failed_item_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_erab_failed_item(
                &p_rrm_erab_failed_item_list->erab_failed_item[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ho_failure
(
    rrc_rrm_ho_failure_t *p_rrc_rrm_ho_failure,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ho_failure, 0, sizeof(rrc_rrm_ho_failure_t));

    /* This function parses rrc_rrm_ho_failure */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_failure->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ho_failure->rrm_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ho_cancel_req
(
    rrc_rrm_ho_cancel_req_t *p_rrc_rrm_ho_cancel_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ho_cancel_req, 0, sizeof(rrc_rrm_ho_cancel_req_t));

    /* This function parses rrc_rrm_ho_cancel_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_cancel_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ho_cancel_req->rrm_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ho_cancel_resp
(
    rrc_rrm_ho_cancel_resp_t *p_rrc_rrm_ho_cancel_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ho_cancel_resp, 0, sizeof(rrc_rrm_ho_cancel_resp_t));

    /* This function parses rrc_rrm_ho_cancel_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_cancel_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ho_cancel_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ho_cancel_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ho_cancel_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ho_cancel_resp->response);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ho_restriction_list_ind
(
    rrc_rrm_ho_restriction_list_ind_t *p_rrc_rrm_ho_restriction_list_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ho_restriction_list_ind, 0, sizeof(rrc_rrm_ho_restriction_list_ind_t));

    /* This function parses rrc_rrm_ho_restriction_list_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ho_restriction_list_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_ho_restriction_list(
        &p_rrc_rrm_ho_restriction_list_ind->ho_restriction_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_dl_nas_transport_ind
(
    rrc_rrm_dl_nas_transport_ind_t *p_rrc_rrm_dl_nas_transport_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_dl_nas_transport_ind, 0, sizeof(rrc_rrm_dl_nas_transport_ind_t));

    /* This function parses rrc_rrm_dl_nas_transport_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dl_nas_transport_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dl_nas_transport_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_dl_nas_transport_ind->bitmask & RRC_RRM_DL_NAS_TRANSPORT_IND_SUBS_PROF_ID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dl_nas_transport_ind->subscriber_profile_id_for_rfp, p_src + *p_length_read, "subscriber_profile_id_for_rfp");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_dl_nas_transport_ind->subscriber_profile_id_for_rfp < 1) || (p_rrc_rrm_dl_nas_transport_ind->subscriber_profile_id_for_rfp > 256))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_dl_nas_transport_ind->subscriber_profile_id_for_rfp] should be in range "
            "1 to 256. Incorrect value %u received.", p_rrc_rrm_dl_nas_transport_ind->subscriber_profile_id_for_rfp);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_ho_command_request
(
    rrc_rrm_ue_ho_command_request_t *p_rrc_rrm_ue_ho_command_request,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_ho_command_request, 0, sizeof(rrc_rrm_ue_ho_command_request_t));

    /* This function parses rrc_rrm_ue_ho_command_request */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_command_request->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_command_request->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_ho_command_request->bitmask & RRC_RRM_UE_HO_CMD_REQ_NAS_SECURITY_PARAM_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_nas_security_param(
        &p_rrc_rrm_ue_ho_command_request->nas_security_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_command_request->bitmask & RRC_RRM_UE_HO_CMD_REQ_ERAB_SUB_TO_FORWARD_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_erab_info_list(
        &p_rrc_rrm_ue_ho_command_request->erab_sub_to_fwd_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_command_request->bitmask & RRC_RRM_UE_HO_CMD_REQ_ERAB_TO_RELEASE_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_erab_to_release_list(
        &p_rrc_rrm_ue_ho_command_request->erab_to_release_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_ho_command_request->bitmask & RRC_RRM_UE_HO_CMD_REQ_CDMA2000_HO_STATUS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(p_rrc_rrm_ue_ho_command_request->cdma2000_ho_status) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_rrm_ue_ho_command_request->cdma2000_ho_status); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_ue_ho_command_request->cdma2000_ho_status[loop], (void*)(p_src + *p_length_read), "cdma2000_ho_status[]");
            *p_length_read += sizeof(U8);
        }
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_nas_security_param
(
    nas_security_param_t *p_nas_security_param,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_nas_security_param, 0, sizeof(nas_security_param_t));

    /* This function parses nas_security_param */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_nas_security_param->nas_msg_length, p_src + *p_length_read, "nas_msg_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_nas_security_param->nas_msg_length < 1) || (p_nas_security_param->nas_msg_length > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_nas_security_param->nas_msg_length] should be in range "
            "1 to 2. Incorrect value %u received.", p_nas_security_param->nas_msg_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_nas_security_param->nas_msg_length * sizeof(p_nas_security_param->nas_security_param[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_nas_security_param->nas_msg_length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_nas_security_param->nas_security_param[loop], (void*)(p_src + *p_length_read), "nas_security_param[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_tansport_layer_address
(
    rrc_rrm_tansport_layer_address_t *p_rrc_rrm_tansport_layer_address,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_tansport_layer_address, 0, sizeof(rrc_rrm_tansport_layer_address_t));

    /* This function parses rrc_rrm_tansport_layer_address */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_tansport_layer_address->length, p_src + *p_length_read, "length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_tansport_layer_address->length > MAX_TRANSPORT_LAYER_ADDR_SIZE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_tansport_layer_address->length] should be less than"
            " or equal to MAX_TRANSPORT_LAYER_ADDR_SIZE. Incorrect value %u received.", p_rrc_rrm_tansport_layer_address->length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_rrm_tansport_layer_address->length * sizeof(p_rrc_rrm_tansport_layer_address->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_tansport_layer_address->length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rrm_tansport_layer_address->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_drb_sub_to_fwd_info
(
    rrm_drb_sub_to_fwd_info_t *p_rrm_drb_sub_to_fwd_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_drb_sub_to_fwd_info, 0, sizeof(rrm_drb_sub_to_fwd_info_t));

    /* This function parses rrm_drb_sub_to_fwd_info */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_sub_to_fwd_info->forward_direction, p_src + *p_length_read, "forward_direction");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_sub_to_fwd_info->forward_direction > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_sub_to_fwd_info->forward_direction] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrm_drb_sub_to_fwd_info->forward_direction);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrm_drb_sub_to_fwd_info->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrm_drb_sub_to_fwd_info->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrm_drb_sub_to_fwd_info->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrm_drb_sub_to_fwd_info->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrm_drb_sub_to_fwd_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrm_drb_sub_to_fwd_info->bitmask & ERAB_SUB_TO_FORWARD_LIST_UL_GTP_TUNNEL_END_POINT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_tansport_layer_address(
        &p_rrm_drb_sub_to_fwd_info->ul_transport_layer_address,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrm_drb_sub_to_fwd_info->bitmask & ERAB_SUB_TO_FORWARD_LIST_DL_GTP_TUNNEL_END_POINT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_tansport_layer_address(
        &p_rrm_drb_sub_to_fwd_info->dl_transport_layer_address,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_erab_info_list
(
    rrc_erab_info_list_t *p_rrc_erab_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_erab_info_list, 0, sizeof(rrc_erab_info_list_t));

    /* This function parses rrc_erab_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_erab_info_list->erab_count, p_src + *p_length_read, "erab_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_erab_info_list->erab_count < 1) || (p_rrc_erab_info_list->erab_count > 8))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_erab_info_list->erab_count] should be in range "
            "1 to 8. Incorrect value %u received.", p_rrc_erab_info_list->erab_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_erab_info_list->erab_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrm_drb_sub_to_fwd_info(
                &p_rrc_erab_info_list->drb_sub_to_fwd[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_erab_to_release
(
    erab_to_release_t *p_erab_to_release,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_erab_to_release, 0, sizeof(erab_to_release_t));

    /* This function parses erab_to_release */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_erab_to_release->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_erab_to_release->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_erab_to_release->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_erab_to_release->erab_id);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_erab_to_release->rrm_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_erab_to_release_list
(
    erab_to_release_list_t *p_erab_to_release_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_erab_to_release_list, 0, sizeof(erab_to_release_list_t));

    /* This function parses erab_to_release_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_erab_to_release_list->erab_count, p_src + *p_length_read, "erab_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_erab_to_release_list->erab_count < 1) || (p_erab_to_release_list->erab_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_erab_to_release_list->erab_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_erab_to_release_list->erab_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_erab_to_release_list->erab_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_erab_to_release(
                &p_erab_to_release_list->erab_to_release[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_ho_command_response
(
    rrc_rrm_ue_ho_command_response_t *p_rrc_rrm_ue_ho_command_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_ho_command_response, 0, sizeof(rrc_rrm_ue_ho_command_response_t));

    /* This function parses rrc_rrm_ue_ho_command_response */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_ho_command_response->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_ho_response(
        &p_rrc_rrm_ue_ho_command_response->ho_command_response,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_ho_response
(
    ho_response_t *p_ho_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_ho_response, 0, sizeof(ho_response_t));

    /* This function parses ho_response */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_ho_response->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ho_response->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ho_response->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ho_response->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_ho_response->response);
        return RRC_FAILURE;
    }

    if (p_ho_response->bitmask & HO_RESPONSE_CAUSE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_ho_response->rrm_cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_response->bitmask & HO_RESPONSE_CS_FALLBACK_INDICATOR_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_ho_response->cs_fallback_indicator, p_src + *p_length_read, "cs_fallback_indicator");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_ho_response->cs_fallback_indicator > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_ho_response->cs_fallback_indicator] should be less than"
            " or equal to 1. Incorrect value %u received.", p_ho_response->cs_fallback_indicator);
        return RRC_FAILURE;
    }
    }

    if (p_ho_response->bitmask & ERAB_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_erab_info_list(
        &p_ho_response->erab_sub_to_fwd_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_response->bitmask & HO_RESPONSE_CARRIER_FREQ_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_ho_response->carrier_freq_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_ho_response->bitmask & HO_RESPONSE_ERAB_LOSSY_HO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_erab_item_list(
        &p_ho_response->erab_lossy_ho_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_meas_config_req
(
    rrc_rrm_meas_config_req_t *p_rrc_rrm_meas_config_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_config_req, 0, sizeof(rrc_rrm_meas_config_req_t));

    /* This function parses rrc_rrm_meas_config_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_config_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrm_meas_config(
        &p_rrc_rrm_meas_config_req->meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_meas_config_response
(
    rrc_rrm_meas_config_response_t *p_rrc_rrm_meas_config_response,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_meas_config_response, 0, sizeof(rrc_rrm_meas_config_response_t));

    /* This function parses rrc_rrm_meas_config_response */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_config_response->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_meas_config_response->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_meas_config_response->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_meas_config_response->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_meas_config_response->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_meas_config_response->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_meas_config_response->bitmask & RRC_RRM_MEAS_CONFIG_RESP_CAUSE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_meas_config_response->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_contxt_mod_req
(
    rrc_rrm_ue_contxt_mod_req_t *p_rrc_rrm_ue_contxt_mod_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_contxt_mod_req, 0, sizeof(rrc_rrm_ue_contxt_mod_req_t));

    /* This function parses rrc_rrm_ue_contxt_mod_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_SPID_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_req->SPID, p_src + *p_length_read, "SPID");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_AMBR_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_ue_agg_max_bit_rate(
        &p_rrc_rrm_ue_contxt_mod_req->ue_agg_max_bit_rate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_CS_FALLBACK_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ue_contxt_mod_req->CS_Fallback_Indicator, p_src + *p_length_read, "CS_Fallback_Indicator");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_REGISTERED_LAI_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_registered_lai(
        &p_rrc_rrm_ue_contxt_mod_req->registered_lai,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_CSG_MEMBERSHIP_STATUS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_contxt_mod_req->csg_membership_status, p_src + *p_length_read, "csg_membership_status");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_contxt_mod_req->csg_membership_status > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_contxt_mod_req->csg_membership_status] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_contxt_mod_req->csg_membership_status);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ue_contxt_mod_req->bitmask & RRC_RRM_UE_CONTXT_MOD_SECURITY_KEY_CHANGE_HO_ONGOING_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_contxt_mod_req->security_key_ho_ongoing, p_src + *p_length_read, "security_key_ho_ongoing");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_ue_contxt_mod_req->security_key_ho_ongoing < 1) || (p_rrc_rrm_ue_contxt_mod_req->security_key_ho_ongoing > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_contxt_mod_req->security_key_ho_ongoing] should be in range "
            "1 to 1. Incorrect value %u received.", p_rrc_rrm_ue_contxt_mod_req->security_key_ho_ongoing);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_contxt_mod_resp
(
    rrc_rrm_ue_contxt_mod_resp_t *p_rrc_rrm_ue_contxt_mod_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_contxt_mod_resp, 0, sizeof(rrc_rrm_ue_contxt_mod_resp_t));

    /* This function parses rrc_rrm_ue_contxt_mod_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_contxt_mod_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_contxt_mod_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_contxt_mod_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_contxt_mod_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_contxt_mod_resp->bitmask & UE_CONTEXT_MOD_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cause(
        &p_rrc_rrm_ue_contxt_mod_resp->cause,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_contxt_mod_resp->bitmask & UE_CONTEXT_MOD_RESP_T304_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_resp->t304_timer, p_src + *p_length_read, "t304_timer");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_contxt_mod_resp->t304_timer > 6))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_contxt_mod_resp->t304_timer] should be less than"
            " or equal to 6. Incorrect value %u received.", p_rrc_rrm_ue_contxt_mod_resp->t304_timer);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_contxt_mod_cnf
(
    rrc_rrm_ue_contxt_mod_cnf_t *p_rrc_rrm_ue_contxt_mod_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_contxt_mod_cnf, 0, sizeof(rrc_rrm_ue_contxt_mod_cnf_t));

    /* This function parses rrc_rrm_ue_contxt_mod_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_contxt_mod_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_contxt_mod_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_contxt_mod_cnf->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_contxt_mod_cnf->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_contxt_mod_cnf->response);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_updated_pws_si_list_req
(
    rrc_rrm_updated_pws_si_list_req_t *p_rrc_rrm_updated_pws_si_list_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_updated_pws_si_list_req, 0, sizeof(rrc_rrm_updated_pws_si_list_req_t));

    /* This function parses rrc_rrm_updated_pws_si_list_req */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_updated_pws_si_list_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_updated_pws_si_list_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_updated_pws_si_list_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_updated_pws_si_list_req->cell_index);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_rrc_warning_info_list(
        &p_rrc_rrm_updated_pws_si_list_req->warning_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_warning_info
(
    rrc_warning_info_t *p_rrc_warning_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_warning_info, 0, sizeof(rrc_warning_info_t));

    /* This function parses rrc_warning_info */

    if (*p_length_read + (S32)sizeof(p_rrc_warning_info->message_identifier) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_warning_info->message_identifier); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_warning_info->message_identifier[loop], (void*)(p_src + *p_length_read), "message_identifier[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_rrc_warning_info->serial_number) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrc_warning_info->serial_number); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_warning_info->serial_number[loop], (void*)(p_src + *p_length_read), "serial_number[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_warning_info_list
(
    rrc_warning_info_list_t *p_rrc_warning_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_warning_info_list, 0, sizeof(rrc_warning_info_list_t));

    /* This function parses rrc_warning_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_warning_info_list->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_warning_info_list->count < 1) || (p_rrc_warning_info_list->count > MAX_WARNING_MESSAGE))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_warning_info_list->count] should be in range "
            "1 to MAX_WARNING_MESSAGE. Incorrect value %u received.", p_rrc_warning_info_list->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_warning_info_list->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_warning_info(
                &p_rrc_warning_info_list->warning_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_updated_pws_si_list_resp
(
    rrc_rrm_updated_pws_si_list_resp_t *p_rrc_rrm_updated_pws_si_list_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_updated_pws_si_list_resp, 0, sizeof(rrc_rrm_updated_pws_si_list_resp_t));

    /* This function parses rrc_rrm_updated_pws_si_list_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_updated_pws_si_list_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_updated_pws_si_list_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_updated_pws_si_list_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_updated_pws_si_list_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_updated_pws_si_list_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_updated_pws_si_list_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_scheduling_info_list(
        &p_rrc_rrm_updated_pws_si_list_resp->scheduling_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rrm_updated_pws_si_list_resp->bitmask & UPDATED_PWS_SI_LIST_RESP_SI_TRANSMISSION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_si_transmission_info_list(
        &p_rrc_rrm_updated_pws_si_list_resp->si_transmission_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_updated_pws_si_list_resp->bitmask & UPDATED_PWS_SI_LIST_RESP_ETWS_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_etws_scheduling_info(
        &p_rrc_rrm_updated_pws_si_list_resp->etws_scheduling_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_updated_pws_si_list_resp->bitmask & UPDATED_PWS_SI_LIST_RESP_CMAS_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_cmas_scheduling_info_list(
        &p_rrc_rrm_updated_pws_si_list_resp->cmas_scheduling_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_etws_scheduling_info
(
    etws_scheduling_info_t *p_etws_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_etws_scheduling_info, 0, sizeof(etws_scheduling_info_t));

    /* This function parses etws_scheduling_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_etws_scheduling_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(p_etws_scheduling_info->message_identifier) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_etws_scheduling_info->message_identifier); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_etws_scheduling_info->message_identifier[loop], (void*)(p_src + *p_length_read), "message_identifier[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_etws_scheduling_info->serial_number) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_etws_scheduling_info->serial_number); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_etws_scheduling_info->serial_number[loop], (void*)(p_src + *p_length_read), "serial_number[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (p_etws_scheduling_info->bitmask & RRC_RRM_ETWS_SCHEDULING_NUM_OF_SEGMENTS_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_etws_scheduling_info->num_of_segments, p_src + *p_length_read, "num_of_segments");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_etws_scheduling_info->num_of_segments < 1) || (p_etws_scheduling_info->num_of_segments > 64))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_etws_scheduling_info->num_of_segments] should be in range "
            "1 to 64. Incorrect value %u received.", p_etws_scheduling_info->num_of_segments);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cmas_scheduling_info
(
    cmas_scheduling_info_t *p_cmas_scheduling_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_cmas_scheduling_info, 0, sizeof(cmas_scheduling_info_t));

    /* This function parses cmas_scheduling_info */

    if (*p_length_read + (S32)sizeof(p_cmas_scheduling_info->message_identifier) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cmas_scheduling_info->message_identifier); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cmas_scheduling_info->message_identifier[loop], (void*)(p_src + *p_length_read), "message_identifier[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(p_cmas_scheduling_info->serial_number) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_cmas_scheduling_info->serial_number); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_cmas_scheduling_info->serial_number[loop], (void*)(p_src + *p_length_read), "serial_number[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cmas_scheduling_info->num_of_segments, p_src + *p_length_read, "num_of_segments");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cmas_scheduling_info->num_of_segments < 1) || (p_cmas_scheduling_info->num_of_segments > 64))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cmas_scheduling_info->num_of_segments] should be in range "
            "1 to 64. Incorrect value %u received.", p_cmas_scheduling_info->num_of_segments);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_cmas_scheduling_info->num_of_repetitions, p_src + *p_length_read, "num_of_repetitions");
    *p_length_read += sizeof(U16);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cmas_scheduling_info->num_of_repetitions < 1) || (p_cmas_scheduling_info->num_of_repetitions > 4095))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cmas_scheduling_info->num_of_repetitions] should be in range "
            "1 to 4095. Incorrect value %u received.", p_cmas_scheduling_info->num_of_repetitions);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_cmas_scheduling_info_list
(
    cmas_scheduling_info_list_t *p_cmas_scheduling_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_cmas_scheduling_info_list, 0, sizeof(cmas_scheduling_info_list_t));

    /* This function parses cmas_scheduling_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_cmas_scheduling_info_list->cmas_warning_count, p_src + *p_length_read, "cmas_warning_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_cmas_scheduling_info_list->cmas_warning_count < 1) || (p_cmas_scheduling_info_list->cmas_warning_count > MAX_NUM_CMAS_WARNING))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_cmas_scheduling_info_list->cmas_warning_count] should be in range "
            "1 to MAX_NUM_CMAS_WARNING. Incorrect value %u received.", p_cmas_scheduling_info_list->cmas_warning_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_cmas_scheduling_info_list->cmas_warning_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_cmas_scheduling_info(
                &p_cmas_scheduling_info_list->cmas_scheduling_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_updated_pws_si_list_cnf
(
    rrc_rrm_updated_pws_si_list_cnf_t *p_rrc_rrm_updated_pws_si_list_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_updated_pws_si_list_cnf, 0, sizeof(rrc_rrm_updated_pws_si_list_cnf_t));

    /* This function parses rrc_rrm_updated_pws_si_list_cnf */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_updated_pws_si_list_cnf->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_updated_pws_si_list_cnf->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_updated_pws_si_list_cnf->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_updated_pws_si_list_cnf->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_updated_pws_si_list_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    if (RRC_FAILURE == rrc_il_parse_rrc_warning_info_list(
        &p_rrc_rrm_updated_pws_si_list_cnf->warning_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_inactive_ues_ind
(
    rrc_rrm_inactive_ues_ind_t *p_rrc_rrm_inactive_ues_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_inactive_ues_ind, 0, sizeof(rrc_rrm_inactive_ues_ind_t));

    /* This function parses rrc_rrm_inactive_ues_ind */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue, p_src + *p_length_read, "num_of_inactive_ue");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue < 1) || (p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue > RRC_MAX_INACTIVE_UES))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue] should be in range "
            "1 to RRC_MAX_INACTIVE_UES. Incorrect value %u received.", p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rrm_inactive_ues_ind->num_of_inactive_ue; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_rrm_inactive_ue_info(
                &p_rrc_rrm_inactive_ues_ind->inactive_ue_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_inactive_ue_info
(
    rrc_rrm_inactive_ue_info_t *p_rrc_rrm_inactive_ue_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_inactive_ue_info, 0, sizeof(rrc_rrm_inactive_ue_info_t));

    /* This function parses rrc_rrm_inactive_ue_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_inactive_ue_info->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_start_resp
(
    rrc_rrm_cell_start_resp_t *p_rrc_rrm_cell_start_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_start_resp, 0, sizeof(rrc_rrm_cell_start_resp_t));

    /* This function parses rrc_rrm_cell_start_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_start_resp->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_start_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_start_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_start_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_start_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_start_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_start_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_start_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_cell_start_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_cell_start_resp->presence_bitmask & CELL_START_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_start_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_start_resp->fail_cause > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_start_resp->fail_cause] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_rrm_cell_start_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_start_req
(
    rrc_rrm_cell_start_req_t *p_rrc_rrm_cell_start_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_start_req, 0, sizeof(rrc_rrm_cell_start_req_t));

    /* This function parses rrc_rrm_cell_start_req */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_start_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_start_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_start_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_start_req->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_stop_req
(
    rrc_rrm_cell_stop_req_t *p_rrc_rrm_cell_stop_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_stop_req, 0, sizeof(rrc_rrm_cell_stop_req_t));

    /* This function parses rrc_rrm_cell_stop_req */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_stop_req->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_stop_req->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_stop_req->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_stop_req->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_cell_stop_resp
(
    rrc_rrm_cell_stop_resp_t *p_rrc_rrm_cell_stop_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_cell_stop_resp, 0, sizeof(rrc_rrm_cell_stop_resp_t));

    /* This function parses rrc_rrm_cell_stop_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_cell_stop_resp->presence_bitmask, p_src + *p_length_read, "presence_bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_stop_resp->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_stop_resp->cell_index > MAX_CELL_INDEX))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_stop_resp->cell_index] should be less than"
            " or equal to MAX_CELL_INDEX. Incorrect value %u received.", p_rrc_rrm_cell_stop_resp->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_stop_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_stop_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_stop_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_cell_stop_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_cell_stop_resp->presence_bitmask & CELL_STOP_RESP_API_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_cell_stop_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_cell_stop_resp->fail_cause > 14))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_cell_stop_resp->fail_cause] should be less than"
            " or equal to 14. Incorrect value %u received.", p_rrc_rrm_cell_stop_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_intra_enb_ho_ind
(
    rrc_rrm_intra_enb_ho_ind_t *p_rrc_rrm_intra_enb_ho_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_intra_enb_ho_ind, 0, sizeof(rrc_rrm_intra_enb_ho_ind_t));

    /* This function parses rrc_rrm_intra_enb_ho_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_intra_enb_ho_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_intra_enb_ho_ind->cell_index, p_src + *p_length_read, "cell_index");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_intra_enb_ho_ind->cell_index > 7))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_intra_enb_ho_ind->cell_index] should be less than"
            " or equal to 7. Incorrect value %u received.", p_rrc_rrm_intra_enb_ho_ind->cell_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_intra_enb_ho_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_intra_enb_ho_ind->bitmask & RRC_RRM_INTRA_CELL_HO_CAUSE_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_intra_enb_ho_ind->intracell_ho_cause, p_src + *p_length_read, "intracell_ho_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_intra_enb_ho_ind->intracell_ho_cause > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_intra_enb_ho_ind->intracell_ho_cause] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_intra_enb_ho_ind->intracell_ho_cause);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_csfb_parameters_req_cdma2000
(
    rrc_rrm_csfb_parameters_req_cdma2000_t *p_rrc_rrm_csfb_parameters_req_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_csfb_parameters_req_cdma2000, 0, sizeof(rrc_rrm_csfb_parameters_req_cdma2000_t));

    /* This function parses rrc_rrm_csfb_parameters_req_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_csfb_parameters_req_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_csfb_parameters_req_cdma2000->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_csfb_parameters_resp_cdma2000
(
    rrc_rrm_csfb_parameters_resp_cdma2000_t *p_rrc_rrm_csfb_parameters_resp_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_csfb_parameters_resp_cdma2000, 0, sizeof(rrc_rrm_csfb_parameters_resp_cdma2000_t));

    /* This function parses rrc_rrm_csfb_parameters_resp_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_csfb_parameters_resp_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_csfb_parameters_resp_cdma2000->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_mobility_parameters(
        &p_rrc_rrm_csfb_parameters_resp_cdma2000->mobility_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_additional_mobility_parameters(
        &p_rrc_rrm_csfb_parameters_resp_cdma2000->add_mobility_parameters,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_counter_check_req
(
    rrc_rrm_counter_check_req_t *p_rrc_rrm_counter_check_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_counter_check_req, 0, sizeof(rrc_rrm_counter_check_req_t));

    /* This function parses rrc_rrm_counter_check_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_counter_check_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_counter_check_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_counter_check_req->bitmask & COUNTER_CHECK_REQ_DRB_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_drb_list(
        &p_rrc_rrm_counter_check_req->drb_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_list
(
    drb_list_t *p_drb_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_drb_list, 0, sizeof(drb_list_t));

    /* This function parses drb_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_list->drb_count, p_src + *p_length_read, "drb_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_list->drb_count < 1) || (p_drb_list->drb_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_list->drb_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_drb_list->drb_count);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_drb_list->drb_count * sizeof(p_drb_list->drb_Identity[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements with BOTH boundaries
     * range check */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_drb_list->drb_count; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_drb_list->drb_Identity[loop], (void*)(p_src + *p_length_read), "drb_Identity[]");
            if ((p_drb_list->drb_Identity[loop] < 1) || (p_drb_list->drb_Identity[loop] > 32))
            {
                RRC_TRACE(RRC_WARNING, "Parameter p_drb_list->drb_Identity[%u] should be in "
                    "range 1 to 32. "
                    "Incorrect value %d received.", loop, p_drb_list->drb_Identity[loop]);
                return RRC_FAILURE;
            }
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_counter_check_resp
(
    rrc_rrm_counter_check_resp_t *p_rrc_rrm_counter_check_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_counter_check_resp, 0, sizeof(rrc_rrm_counter_check_resp_t));

    /* This function parses rrc_rrm_counter_check_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_counter_check_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_counter_check_resp->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_counter_check_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_counter_check_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_counter_check_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_counter_check_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_counter_check_resp->bitmask & RRM_COUNTER_CHECK_RESP_FAIL_CAUSE_PRESENCE_FLAG)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_counter_check_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);
    }

    if (p_rrc_rrm_counter_check_resp->bitmask & RRM_COUNTER_CHECK_RESP_DRB_COUNT_INFO_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_drb_count_info_list(
        &p_rrc_rrm_counter_check_resp->drb_count_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_counter_check_resp->bitmask & RRM_COUNTER_CHECK_RESP_DRB_COUNTMSB_INFO_LIST_PRESENCE_FLAG)
    {

    if (RRC_FAILURE == rrc_il_parse_drb_countMSB_info_list(
        &p_rrc_rrm_counter_check_resp->drb_countMSB_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_count_info
(
    drb_count_info_t *p_drb_count_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_drb_count_info, 0, sizeof(drb_count_info_t));

    /* This function parses drb_count_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_drb_count_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_count_info->drb_Identity, p_src + *p_length_read, "drb_Identity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_count_info->drb_Identity < 1) || (p_drb_count_info->drb_Identity > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_count_info->drb_Identity] should be in range "
            "1 to 32. Incorrect value %u received.", p_drb_count_info->drb_Identity);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_drb_count_info->count_Uplink, p_src + *p_length_read, "count_Uplink");
    *p_length_read += sizeof(U32);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_drb_count_info->count_Downlink, p_src + *p_length_read, "count_Downlink");
    *p_length_read += sizeof(U32);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_count_info_list
(
    drb_count_info_list_t *p_drb_count_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_drb_count_info_list, 0, sizeof(drb_count_info_list_t));

    /* This function parses drb_count_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_count_info_list->drb_count, p_src + *p_length_read, "drb_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_drb_count_info_list->drb_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_count_info_list->drb_count] should be less than"
            " or equal to MAX_LC_COUNT. Incorrect value %u received.", p_drb_count_info_list->drb_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_drb_count_info_list->drb_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_drb_count_info(
                &p_drb_count_info_list->drb_count_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_countMSB_info
(
    drb_countMSB_info_t *p_drb_countMSB_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_drb_countMSB_info, 0, sizeof(drb_countMSB_info_t));

    /* This function parses drb_countMSB_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_drb_countMSB_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_countMSB_info->drb_Identity, p_src + *p_length_read, "drb_Identity");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_countMSB_info->drb_Identity < 1) || (p_drb_countMSB_info->drb_Identity > 32))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_countMSB_info->drb_Identity] should be in range "
            "1 to 32. Incorrect value %u received.", p_drb_countMSB_info->drb_Identity);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_drb_countMSB_info->countMSB_Uplink, p_src + *p_length_read, "countMSB_Uplink");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_drb_countMSB_info->countMSB_Uplink > 33554431))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_countMSB_info->countMSB_Uplink] should be less than"
            " or equal to 33554431. Incorrect value %u received.", p_drb_countMSB_info->countMSB_Uplink);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_drb_countMSB_info->countMSB_Downlink, p_src + *p_length_read, "countMSB_Downlink");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_drb_countMSB_info->countMSB_Downlink > 33554431))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_countMSB_info->countMSB_Downlink] should be less than"
            " or equal to 33554431. Incorrect value %u received.", p_drb_countMSB_info->countMSB_Downlink);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_drb_countMSB_info_list
(
    drb_countMSB_info_list_t *p_drb_countMSB_info_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_drb_countMSB_info_list, 0, sizeof(drb_countMSB_info_list_t));

    /* This function parses drb_countMSB_info_list */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_drb_countMSB_info_list->drb_count, p_src + *p_length_read, "drb_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_drb_countMSB_info_list->drb_count < 1) || (p_drb_countMSB_info_list->drb_count > MAX_LC_COUNT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_drb_countMSB_info_list->drb_count] should be in range "
            "1 to MAX_LC_COUNT. Incorrect value %u received.", p_drb_countMSB_info_list->drb_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_drb_countMSB_info_list->drb_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_drb_countMSB_info(
                &p_drb_countMSB_info_list->drb_countMSB_info[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_information_req
(
    rrc_rrm_ue_information_req_t *p_rrc_rrm_ue_information_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_information_req, 0, sizeof(rrc_rrm_ue_information_req_t));

    /* This function parses rrc_rrm_ue_information_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_information_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_information_req->ue_Index, p_src + *p_length_read, "ue_Index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_information_req->rach_report_req, p_src + *p_length_read, "rach_report_req");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_information_req->rach_report_req > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_information_req->rach_report_req] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_information_req->rach_report_req);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_information_req->rlf_report_req, p_src + *p_length_read, "rlf_report_req");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_information_req->rlf_report_req > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_information_req->rlf_report_req] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_information_req->rlf_report_req);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_information_resp
(
    rrc_rrm_ue_information_resp_t *p_rrc_rrm_ue_information_resp,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_information_resp, 0, sizeof(rrc_rrm_ue_information_resp_t));

    /* This function parses rrc_rrm_ue_information_resp */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_information_resp->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_information_resp->ue_Index, p_src + *p_length_read, "ue_Index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_information_resp->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_information_resp->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_information_resp->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_information_resp->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_information_resp->bitmask & RRC_RRM_UE_INFO_RESP_CAUSE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_information_resp->fail_cause, p_src + *p_length_read, "fail_cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_information_resp->fail_cause > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_information_resp->fail_cause] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_ue_information_resp->fail_cause);
        return RRC_FAILURE;
    }
    }

    if (p_rrc_rrm_ue_information_resp->bitmask & RRC_UE_INFO_RACH_REPORT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rach_report(
        &p_rrc_rrm_ue_information_resp->rach_report,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_ue_information_resp->bitmask & RRC_UE_INFO_RLF_REPORT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_report(
        &p_rrc_rrm_ue_information_resp->rlf_report,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rach_report
(
    rrc_rach_report_t *p_rrc_rach_report,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rach_report, 0, sizeof(rrc_rach_report_t));

    /* This function parses rrc_rach_report */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rach_report->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rach_report->no_of_preamables_sent, p_src + *p_length_read, "no_of_preamables_sent");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rach_report->no_of_preamables_sent < 1) || (p_rrc_rach_report->no_of_preamables_sent > 200))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rach_report->no_of_preamables_sent] should be in range "
            "1 to 200. Incorrect value %u received.", p_rrc_rach_report->no_of_preamables_sent);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rach_report->contention_detected, p_src + *p_length_read, "contention_detected");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rach_report->contention_detected > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rach_report->contention_detected] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rach_report->contention_detected);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_meas_result_serv_cell
(
    rrc_rlf_report_meas_result_serv_cell_t *p_rrc_rlf_report_meas_result_serv_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_report_meas_result_serv_cell, 0, sizeof(rrc_rlf_report_meas_result_serv_cell_t));

    /* This function parses rrc_rlf_report_meas_result_serv_cell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report_meas_result_serv_cell->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rlf_report_meas_result_serv_cell->rsrp_result, p_src + *p_length_read, "rsrp_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rlf_report_meas_result_serv_cell->rsrp_result > 97))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rlf_report_meas_result_serv_cell->rsrp_result] should be less than"
            " or equal to 97. Incorrect value %u received.", p_rrc_rlf_report_meas_result_serv_cell->rsrp_result);
        return RRC_FAILURE;
    }

    if (p_rrc_rlf_report_meas_result_serv_cell->bitmask & RRC_UE_INFO_MEAS_RESULT_RSRQ_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rlf_report_meas_result_serv_cell->rsrq_result, p_src + *p_length_read, "rsrq_result");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rlf_report_meas_result_serv_cell->rsrq_result > 34))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rlf_report_meas_result_serv_cell->rsrq_result] should be less than"
            " or equal to 34. Incorrect value %u received.", p_rrc_rlf_report_meas_result_serv_cell->rsrq_result);
        return RRC_FAILURE;
    }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_eutra
(
    rrc_meas_result2_eutra_t *p_rrc_meas_result2_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result2_eutra, 0, sizeof(rrc_meas_result2_eutra_t));

    /* This function parses rrc_meas_result2_eutra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result2_eutra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result2_eutra->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_eutra(
        &p_rrc_meas_result2_eutra->meas_result_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_list2_eutra
(
    rrc_meas_result_list2_eutra_t *p_rrc_meas_result_list2_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_list2_eutra, 0, sizeof(rrc_meas_result_list2_eutra_t));

    /* This function parses rrc_meas_result_list2_eutra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_list2_eutra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_meas_result_list2_eutra->count < 1) || (p_rrc_meas_result_list2_eutra->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_list2_eutra->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_rrc_meas_result_list2_eutra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_meas_result_list2_eutra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_meas_result2_eutra(
                &p_rrc_meas_result_list2_eutra->meas_result_eutra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_utra
(
    rrc_meas_result2_utra_t *p_rrc_meas_result2_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result2_utra, 0, sizeof(rrc_meas_result2_utra_t));

    /* This function parses rrc_meas_result2_utra */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result2_utra->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result2_utra->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_meas_result2_utra->carrier_freq > 16383))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result2_utra->carrier_freq] should be less than"
            " or equal to 16383. Incorrect value %u received.", p_rrc_meas_result2_utra->carrier_freq);
        return RRC_FAILURE;
    }

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_utra(
        &p_rrc_meas_result2_utra->meas_result_list_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result_list2_utra
(
    rrc_meas_result_list2_utra_t *p_rrc_meas_result_list2_utra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result_list2_utra, 0, sizeof(rrc_meas_result_list2_utra_t));

    /* This function parses rrc_meas_result_list2_utra */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_meas_result_list2_utra->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_meas_result_list2_utra->count < 1) || (p_rrc_meas_result_list2_utra->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_meas_result_list2_utra->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_rrc_meas_result_list2_utra->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_meas_result_list2_utra->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_meas_result2_utra(
                &p_rrc_meas_result_list2_utra->meas_result_utra[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_meas_result2_cdma2000
(
    rrc_meas_result2_cdma2000_t *p_rrc_meas_result2_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_meas_result2_cdma2000, 0, sizeof(rrc_meas_result2_cdma2000_t));

    /* This function parses rrc_meas_result2_cdma2000 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_meas_result2_cdma2000->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_carrier_freq_cdma2000(
        &p_rrc_meas_result2_cdma2000->carrier_freq_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_meas_results_cdma2000(
        &p_rrc_meas_result2_cdma2000->meas_result_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_meas_result_list2_cdma2000
(
    meas_result_list2_cdma2000_t *p_meas_result_list2_cdma2000,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_meas_result_list2_cdma2000, 0, sizeof(meas_result_list2_cdma2000_t));

    /* This function parses meas_result_list2_cdma2000 */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_meas_result_list2_cdma2000->count, p_src + *p_length_read, "count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_meas_result_list2_cdma2000->count < 1) || (p_meas_result_list2_cdma2000->count > MAX_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_meas_result_list2_cdma2000->count] should be in range "
            "1 to MAX_FREQ. Incorrect value %u received.", p_meas_result_list2_cdma2000->count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_meas_result_list2_cdma2000->count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_meas_result2_cdma2000(
                &p_meas_result_list2_cdma2000->meas_result_cdma2000[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_meas_result_neigh_cell
(
    rrc_rlf_report_meas_result_neigh_cell_t *p_rrc_rlf_report_meas_result_neigh_cell,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_report_meas_result_neigh_cell, 0, sizeof(rrc_rlf_report_meas_result_neigh_cell_t));

    /* This function parses rrc_rlf_report_meas_result_neigh_cell */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report_meas_result_neigh_cell->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rlf_report_meas_result_neigh_cell->bitmask & RRC_UE_INFO_MEAS_RESULT_LIST_EUTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_list2_eutra(
        &p_rrc_rlf_report_meas_result_neigh_cell->meas_result_list_eutra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report_meas_result_neigh_cell->bitmask & RRC_UE_INFO_MEAS_RESULT_LIST_UTRA_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_meas_result_list2_utra(
        &p_rrc_rlf_report_meas_result_neigh_cell->meas_result_list_utra,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report_meas_result_neigh_cell->bitmask & RRC_UE_INFO_MEAS_RESULT_LIST_GERAN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list_geran(
        &p_rrc_rlf_report_meas_result_neigh_cell->meas_result_list_geran,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report_meas_result_neigh_cell->bitmask & RRC_UE_INFO_MEAS_RESULT_LIST_CDMA2000_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_meas_result_list2_cdma2000(
        &p_rrc_rlf_report_meas_result_neigh_cell->meas_result_list2_cdma2000,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrm_cell_global_id_eutra
(
    rrm_cell_global_id_eutra_t *p_rrm_cell_global_id_eutra,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrm_cell_global_id_eutra, 0, sizeof(rrm_cell_global_id_eutra_t));

    /* This function parses rrm_cell_global_id_eutra */

    if (RRC_FAILURE == rrc_il_parse_plmn_identity(
        &p_rrm_cell_global_id_eutra->plmn_identity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read + (S32)sizeof(p_rrm_cell_global_id_eutra->cell_identity) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING FIXED of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < ARRSIZE(p_rrm_cell_global_id_eutra->cell_identity); loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrm_cell_global_id_eutra->cell_identity[loop], (void*)(p_src + *p_length_read), "cell_identity[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_dynamic_string
(
    rrc_rlf_dynamic_string_t *p_rrc_rlf_dynamic_string,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_dynamic_string, 0, sizeof(rrc_rlf_dynamic_string_t));

    /* This function parses rrc_rlf_dynamic_string */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rlf_dynamic_string->data_length, p_src + *p_length_read, "data_length");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rlf_dynamic_string->data_length > 64))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rlf_dynamic_string->data_length] should be less than"
            " or equal to 64. Incorrect value %u received.", p_rrc_rlf_dynamic_string->data_length);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)(p_rrc_rlf_dynamic_string->data_length * sizeof(p_rrc_rlf_dynamic_string->data[0])) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of basic type elements */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_rlf_dynamic_string->data_length; loop++)
        {
            rrc_cp_unpack_U8((void*)&p_rrc_rlf_dynamic_string->data[loop], (void*)(p_src + *p_length_read), "data[]");
            *p_length_read += sizeof(U8);
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_location_coordinates
(
    rrc_rlf_report_location_coordinates_t *p_rrc_rlf_report_location_coordinates,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_report_location_coordinates, 0, sizeof(rrc_rlf_report_location_coordinates_t));

    /* This function parses rrc_rlf_report_location_coordinates */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report_location_coordinates->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rlf_report_location_coordinates->bitmask & RRC_RLF_LOCATION_CORD_ELLIPSOID_POINT_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_dynamic_string(
        &p_rrc_rlf_report_location_coordinates->ellipsoid_point,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report_location_coordinates->bitmask & RRC_RLF_LOCATION_CORD_ELLIPSOID_POINT_ALTITUDE_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_dynamic_string(
        &p_rrc_rlf_report_location_coordinates->ellipsoid_point_altitude,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_report_location_info
(
    rrc_rlf_report_location_info_t *p_rrc_rlf_report_location_info,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_report_location_info, 0, sizeof(rrc_rlf_report_location_info_t));

    /* This function parses rrc_rlf_report_location_info */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report_location_info->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_report_location_coordinates(
        &p_rrc_rlf_report_location_info->location_coordiate,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rlf_report_location_info->bitmask & RRC_RLF_LOCATION_INFO_HORIZON_VELOCITY_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_dynamic_string(
        &p_rrc_rlf_report_location_info->horizontal_velocity,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report_location_info->bitmask & RRC_RLF_LOCATION_INFO_GNSS_TOD_MSEC_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_dynamic_string(
        &p_rrc_rlf_report_location_info->gnss_tod_msec,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_failed_pci_arfcn
(
    rrc_rlf_failed_pci_arfcn_t *p_rrc_rlf_failed_pci_arfcn,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_failed_pci_arfcn, 0, sizeof(rrc_rlf_failed_pci_arfcn_t));

    /* This function parses rrc_rlf_failed_pci_arfcn */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_failed_pci_arfcn->phys_cell_id, p_src + *p_length_read, "phys_cell_id");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rlf_failed_pci_arfcn->phys_cell_id > 503))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rlf_failed_pci_arfcn->phys_cell_id] should be less than"
            " or equal to 503. Incorrect value %u received.", p_rrc_rlf_failed_pci_arfcn->phys_cell_id);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_failed_pci_arfcn->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_failed_pcellid
(
    rrc_rlf_failed_pcellid_t *p_rrc_rlf_failed_pcellid,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_failed_pcellid, 0, sizeof(rrc_rlf_failed_pcellid_t));

    /* This function parses rrc_rlf_failed_pcellid */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_failed_pcellid->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (p_rrc_rlf_failed_pcellid->bitmask & RRC_RLF_FAILED_PCI_CELL_GLOBAL_ID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cell_global_id_eutra(
        &p_rrc_rlf_failed_pcellid->cell_global_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_failed_pcellid->bitmask & RRC_RLF_FAILED_PCI_ARFCN_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_failed_pci_arfcn(
        &p_rrc_rlf_failed_pcellid->pci_arfcn,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rlf_report
(
    rrc_rlf_report_t *p_rrc_rlf_report,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rlf_report, 0, sizeof(rrc_rlf_report_t));

    /* This function parses rrc_rlf_report */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_report_meas_result_serv_cell(
        &p_rrc_rlf_report->meas_result_serv_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_MEAS_RESULT_NEIGH_CELLS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_report_meas_result_neigh_cell(
        &p_rrc_rlf_report->meas_result_neigh_cell,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_REESTABLISMENT_CELLID_R10_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cell_global_id_eutra(
        &p_rrc_rlf_report->reestablishment_cellid_r10,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_TIME_CONN_FAILURE_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report->time_conn_failure_r10, p_src + *p_length_read, "time_conn_failure_r10");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_CONN_FAILURE_TYPE_R10_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rlf_report->connection_failure_type_r10, p_src + *p_length_read, "connection_failure_type_r10");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_RLF_REPORT_LOACTION_INFO_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_report_location_info(
        &p_rrc_rlf_report->location_info,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_FAILED_PCELLID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rlf_failed_pcellid(
        &p_rrc_rlf_report->failed_pcellid,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_REESTABLISHMENT_CELLID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cell_global_id_eutra(
        &p_rrc_rlf_report->reestablish_cell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_TIME_CONN_FALURE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rlf_report->time_conn_failure, p_src + *p_length_read, "time_conn_failure");
    *p_length_read += sizeof(U16);
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_CONN_FALURE_TYPE_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rlf_report->conn_failure_type, p_src + *p_length_read, "conn_failure_type");
    *p_length_read += sizeof(U32);
    }

    if (p_rrc_rlf_report->bitmask & RRC_UE_INFO_PREV_PCELLID_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_cell_global_id_eutra(
        &p_rrc_rlf_report->previous_pcell_id,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_inter_freq_rstd_measurement_ind
(
    rrc_rrm_inter_freq_rstd_measurement_ind_t *p_rrc_rrm_inter_freq_rstd_measurement_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_inter_freq_rstd_measurement_ind, 0, sizeof(rrc_rrm_inter_freq_rstd_measurement_ind_t));

    /* This function parses rrc_rrm_inter_freq_rstd_measurement_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_inter_freq_rstd_measurement_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_inter_freq_rstd_measurement_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_inter_freq_rstd_measurement_ind->bitmask & RRM_INTER_FREQ_RSTD_INFO_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_RstdInterFreqInfoList(
        &p_rrc_rrm_inter_freq_rstd_measurement_ind->rstd_inter_freq_info_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RstdInterFreqInfoList_r10
(
    RstdInterFreqInfoList_r10_t *p_RstdInterFreqInfoList_r10,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_RstdInterFreqInfoList_r10, 0, sizeof(RstdInterFreqInfoList_r10_t));

    /* This function parses RstdInterFreqInfoList_r10 */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_RstdInterFreqInfoList_r10->carrier_freq, p_src + *p_length_read, "carrier_freq");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RstdInterFreqInfoList_r10->meas_prs_offset, p_src + *p_length_read, "meas_prs_offset");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_RstdInterFreqInfoList_r10->meas_prs_offset > 39))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RstdInterFreqInfoList_r10->meas_prs_offset] should be less than"
            " or equal to 39. Incorrect value %u received.", p_RstdInterFreqInfoList_r10->meas_prs_offset);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_RstdInterFreqInfoList
(
    RstdInterFreqInfoList_t *p_RstdInterFreqInfoList,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_RstdInterFreqInfoList, 0, sizeof(RstdInterFreqInfoList_t));

    /* This function parses RstdInterFreqInfoList */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_RstdInterFreqInfoList->num_rstd_intfreq_list, p_src + *p_length_read, "num_rstd_intfreq_list");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_RstdInterFreqInfoList->num_rstd_intfreq_list < 1) || (p_RstdInterFreqInfoList->num_rstd_intfreq_list > MAXRSTD_FREQ))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_RstdInterFreqInfoList->num_rstd_intfreq_list] should be in range "
            "1 to MAXRSTD_FREQ. Incorrect value %u received.", p_RstdInterFreqInfoList->num_rstd_intfreq_list);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_RstdInterFreqInfoList->num_rstd_intfreq_list; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_RstdInterFreqInfoList_r10(
                &p_RstdInterFreqInfoList->rstd_interfreq_list[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_local_error_ind
(
    rrc_rrm_local_error_ind_t *p_rrc_rrm_local_error_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_local_error_ind, 0, sizeof(rrc_rrm_local_error_ind_t));

    /* This function parses rrc_rrm_local_error_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_local_error_ind->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_local_error_ind->cause, p_src + *p_length_read, "cause");
    *p_length_read += sizeof(U8);

    /* Check for correct range [B - both higher and lower boundaries] */
    if ((p_rrc_rrm_local_error_ind->cause < 1) || (p_rrc_rrm_local_error_ind->cause > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_local_error_ind->cause] should be in range "
            "1 to 3. Incorrect value %u received.", p_rrc_rrm_local_error_ind->cause);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_local_error_ind->bitmask & RRM_LOCAL_ERROR_IND_IMPACTED_ITEM_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_impacted_items(
        &p_rrc_rrm_local_error_ind->impacted_items,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_impacted_items_list
(
    rrc_impacted_items_list_t *p_rrc_impacted_items_list,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_impacted_items_list, 0, sizeof(rrc_impacted_items_list_t));

    /* This function parses rrc_impacted_items_list */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_impacted_items_list->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_impacted_items_list->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_impacted_items_list->erab_id, p_src + *p_length_read, "erab_id");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_impacted_items_list->erab_id > 15))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_impacted_items_list->erab_id] should be less than"
            " or equal to 15. Incorrect value %u received.", p_rrc_impacted_items_list->erab_id);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_impacted_items
(
    rrc_impacted_items_t *p_rrc_impacted_items,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_impacted_items, 0, sizeof(rrc_impacted_items_t));

    /* This function parses rrc_impacted_items */

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_impacted_items->impacted_items_count, p_src + *p_length_read, "impacted_items_count");
    *p_length_read += sizeof(U8);

    /* Check for correct range [L - lower boundary] */
    if ((p_rrc_impacted_items->impacted_items_count < 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_impacted_items->impacted_items_count] should be greater than"
            " or equal to 1. Incorrect value %u received.", p_rrc_impacted_items->impacted_items_count);
        return RRC_FAILURE;
    }

    /* Parse OCTET_STRING VARIABLE of IEs */
    {
        rrc_counter_t loop;
        for (loop = 0; loop < p_rrc_impacted_items->impacted_items_count; loop++)
        {
            if (RRC_FAILURE == rrc_il_parse_rrc_impacted_items_list(
                &p_rrc_impacted_items->impacted_items_list[loop],
                p_src + *p_length_read,
                length_left - *p_length_read,
                &length_read))
            {
                return RRC_FAILURE;
            }

            *p_length_read += length_read;
        }
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_reestab_config_req
(
    rrc_rrm_ue_reestab_config_req_t *p_rrc_rrm_ue_reestab_config_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_reestab_config_req, 0, sizeof(rrc_rrm_ue_reestab_config_req_t));

    /* This function parses rrc_rrm_ue_reestab_config_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_config_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_config_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U32) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U32(&p_rrc_rrm_ue_reestab_config_req->rrc_rrm_re_estab_cause, p_src + *p_length_read, "rrc_rrm_re_estab_cause");
    *p_length_read += sizeof(U32);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_reestab_config_req->rrc_rrm_re_estab_cause > 3))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_reestab_config_req->rrc_rrm_re_estab_cause] should be less than"
            " or equal to 3. Incorrect value %u received.", p_rrc_rrm_ue_reestab_config_req->rrc_rrm_re_estab_cause);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_ue_reestab_config_req->bitmask & RRC_RRM_UE_REESTAB_FAILURE_CELL_PCI_PRESENT)
    {

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_config_req->failure_cell_pci, p_src + *p_length_read, "failure_cell_pci");
    *p_length_read += sizeof(U16);
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_ue_reestab_config_cnf
(
    rrc_rrm_ue_reestab_config_cnf_t *p_rrc_rrm_ue_reestab_config_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_ue_reestab_config_cnf, 0, sizeof(rrc_rrm_ue_reestab_config_cnf_t));

    /* This function parses rrc_rrm_ue_reestab_config_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_config_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_ue_reestab_config_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_ue_reestab_config_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_ue_reestab_config_cnf->response > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_ue_reestab_config_cnf->response] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_ue_reestab_config_cnf->response);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_wlan_connection_status_ind
(
    rrc_rrm_wlan_connection_status_ind *p_rrc_rrm_wlan_connection_status_ind,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_wlan_connection_status_ind, 0, sizeof(rrc_rrm_wlan_connection_status_ind));

    /* This function parses rrc_rrm_wlan_connection_status_ind */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_wlan_connection_status_ind->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_wlan_connection_status_ind->ue_index > 1))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_wlan_connection_status_ind->ue_index] should be less than"
            " or equal to 1. Incorrect value %u received.", p_rrc_rrm_wlan_connection_status_ind->ue_index);
        return RRC_FAILURE;
    }

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_wlan_connection_status_ind->status, p_src + *p_length_read, "status");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_wlan_connection_status_ind->status > WLAN_STATUS_FAILURE_TIMEOUT))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_wlan_connection_status_ind->status] should be less than"
            " or equal to WLAN_STATUS_FAILURE_TIMEOUT. Incorrect value %u received.", p_rrc_rrm_wlan_connection_status_ind->status);
        return RRC_FAILURE;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_dc_bearer_change_req
(
    rrc_rrm_dc_bearer_change_req_t *p_rrc_rrm_dc_bearer_change_req,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_dc_bearer_change_req, 0, sizeof(rrc_rrm_dc_bearer_change_req_t));

    /* This function parses rrc_rrm_dc_bearer_change_req */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dc_bearer_change_req->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dc_bearer_change_req->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (p_rrc_rrm_dc_bearer_change_req->bitmask & RRM_DC_BEARER_CHANGE_REQ_DRB_TO_MODIFY_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_drb_to_add_info_list(
        &p_rrc_rrm_dc_bearer_change_req->drb_to_modify_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_dc_bearer_change_req->bitmask & RRM_DC_BEARER_CHANGE_REQ_SGNB_ADD_PARAMS_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_sgnb_add_param(
        &p_rrc_rrm_dc_bearer_change_req->sgnb_add_param,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_dc_bearer_change_req->bitmask & RRM_DC_BEARER_REQ_MEAS_CONFIG_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrc_rrm_endc_meas_config(
        &p_rrc_rrm_dc_bearer_change_req->rrc_rrm_endc_meas_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

static
rrc_return_et
rrc_il_parse_rrc_rrm_endc_meas_config
(
    rrc_rrm_endc_meas_config_t *p_rrc_rrm_endc_meas_config,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_endc_meas_config, 0, sizeof(rrc_rrm_endc_meas_config_t));

    /* This function parses rrc_rrm_endc_meas_config */

    if (RRC_FAILURE == rrc_il_parse_meas_object_to_remove_list(
        &p_rrc_rrm_endc_meas_config->meas_object_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_report_config_to_remove_list(
        &p_rrc_rrm_endc_meas_config->report_config_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_meas_id_to_remove_list(
        &p_rrc_rrm_endc_meas_config->meas_id_to_remove_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (RRC_FAILURE == rrc_il_parse_meas_gap_config(
        &p_rrc_rrm_endc_meas_config->meas_gap_config,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

rrc_return_et
rrc_il_parse_rrc_rrm_dc_bearer_change_cnf
(
    rrc_rrm_dc_bearer_change_cnf_t *p_rrc_rrm_dc_bearer_change_cnf,
    U8  *p_src,
    S32 length_left,
    S32 *p_length_read
)
{
    S32 length_read = 0;

    *p_length_read = 0;

    memset_wrapper(p_rrc_rrm_dc_bearer_change_cnf, 0, sizeof(rrc_rrm_dc_bearer_change_cnf_t));

    /* This function parses rrc_rrm_dc_bearer_change_cnf */

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dc_bearer_change_cnf->bitmask, p_src + *p_length_read, "bitmask");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U16) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U16(&p_rrc_rrm_dc_bearer_change_cnf->ue_index, p_src + *p_length_read, "ue_index");
    *p_length_read += sizeof(U16);

    if (*p_length_read + (S32)sizeof(U8) > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    /* Parse/Unpack parameter of basic type */
    rrc_cp_unpack_U8(&p_rrc_rrm_dc_bearer_change_cnf->response, p_src + *p_length_read, "response");
    *p_length_read += sizeof(U8);

    /* Check for correct range [H - higher boundary] */
    if ((p_rrc_rrm_dc_bearer_change_cnf->response > 2))
    {
        RRC_TRACE(RRC_WARNING, "Parameter [p_rrc_rrm_dc_bearer_change_cnf->response] should be less than"
            " or equal to 2. Incorrect value %u received.", p_rrc_rrm_dc_bearer_change_cnf->response);
        return RRC_FAILURE;
    }

    if (p_rrc_rrm_dc_bearer_change_cnf->bitmask & RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_CNF_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_cnf_list(
        &p_rrc_rrm_dc_bearer_change_cnf->erab_cnf_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (p_rrc_rrm_dc_bearer_change_cnf->bitmask & RRC_RRM_DC_BEARER_CHANGE_CNF_ERAB_ERROR_LIST_PRESENT)
    {

    if (RRC_FAILURE == rrc_il_parse_rrm_erab_error_list(
        &p_rrc_rrm_dc_bearer_change_cnf->erab_error_list,
        p_src + *p_length_read,
        length_left - *p_length_read,
        &length_read))
    {
        return RRC_FAILURE;
    }

    *p_length_read += length_read;
    }

    if (*p_length_read > length_left)
    {
        RRC_TRACE(RRC_WARNING, "Incoming message damaged!");
        return RRC_FAILURE;
    }

    return(RRC_SUCCESS);
}

