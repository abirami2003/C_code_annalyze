/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.1.0, Date: 24-Jan-2017.
 */
#include "ranap_asn_enc_dec.h"
#include "rtsrc/rtPrint.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1PE_ranap_ProcedureCode (OSCTXT* pctxt, ranap_ProcedureCode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProcedureCode");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProcedureCode (OSCTXT* pctxt, ranap_ProcedureCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProcedureCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Criticality_ENUMTAB[] = {
   { OSUTF8("ignore"), 1, 6, 2 },
   { OSUTF8("notify"), 2, 6, 0 },
   { OSUTF8("reject"), 0, 6, 1 }
} ;
#define ranap_Criticality_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Criticality_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Criticality_ENUMTABSIZE) {
      return ranap_Criticality_ENUMTAB
         [ranap_Criticality_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Criticality_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Criticality* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Criticality_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Criticality_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Criticality* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_Criticality_ENUMTAB, 
      ranap_Criticality_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Criticality)ranap_Criticality_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Criticality (OSCTXT* pctxt, ranap_Criticality value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Criticality (OSCTXT* pctxt, ranap_Criticality* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Criticality");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ProtocolIE_ID (OSCTXT* pctxt, ranap_ProtocolIE_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolIE_ID (OSCTXT* pctxt, ranap_ProtocolIE_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ProtocolExtensionID (OSCTXT* pctxt, ranap_ProtocolExtensionID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolExtensionID (OSCTXT* pctxt, ranap_ProtocolExtensionID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_PrivateIE_ID (OSCTXT* pctxt, ranap_PrivateIE_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-ID");

   /* Encode choice index value */

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* local */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "local");

         stat = pe_ConsUnsigned (pctxt, pvalue->u.local, 0, 65535);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* global */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "global");

         stat = pe_ObjectIdentifier (pctxt, pvalue->u.global);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PrivateIE_ID (OSCTXT* pctxt, ranap_PrivateIE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-ID");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* local */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "local");

         stat = pd_ConsUInt16 (pctxt, &pvalue->u.local, 0, 65535);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* global */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "global");

         pvalue->u.global = rtxMemAllocType (pctxt, ASN1OBJID);

         if (pvalue->u.global == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.global->numids = 0;

         stat = pd_ObjectIdentifier (pctxt, pvalue->u.global);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PrivateIE_ID (ranap_PrivateIE_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_PrivateIE_ID (OSCTXT *pctxt, ranap_PrivateIE_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.global) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.global);
            pvalue->u.global = 0;
         }
         break;

   }
}

static const OSEnumItem ranap_TriggeringMessage_ENUMTAB[] = {
   { OSUTF8("initiating-message"), 0, 18, 0 },
   { OSUTF8("outcome"), 3, 7, 2 },
   { OSUTF8("successful-outcome"), 1, 18, 3 },
   { OSUTF8("unsuccessfull-outcome"), 2, 21, 1 }
} ;
#define ranap_TriggeringMessage_ENUMTABSIZE 4

const OSUTF8CHAR* ranap_TriggeringMessage_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_TriggeringMessage_ENUMTABSIZE) {
      return ranap_TriggeringMessage_ENUMTAB
         [ranap_TriggeringMessage_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_TriggeringMessage_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_TriggeringMessage* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_TriggeringMessage_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_TriggeringMessage_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_TriggeringMessage* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_TriggeringMessage_ENUMTAB, ranap_TriggeringMessage_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_TriggeringMessage)
         ranap_TriggeringMessage_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_TriggeringMessage (OSCTXT* pctxt, ranap_TriggeringMessage value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TriggeringMessage (OSCTXT* pctxt, ranap_TriggeringMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggeringMessage");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Presence_ENUMTAB[] = {
   { OSUTF8("conditional"), 1, 11, 2 },
   { OSUTF8("mandatory"), 2, 9, 0 },
   { OSUTF8("optional"), 0, 8, 1 }
} ;
#define ranap_Presence_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Presence_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Presence_ENUMTABSIZE) {
      return ranap_Presence_ENUMTAB
         [ranap_Presence_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Presence_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Presence* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Presence_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Presence_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Presence* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_Presence_ENUMTAB, 
      ranap_Presence_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Presence)ranap_Presence_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Presence (OSCTXT* pctxt, ranap_Presence value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Presence");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Presence (OSCTXT* pctxt, ranap_Presence* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Presence");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

void asn1Print_ranap_ProcedureCode 
   (const char* name, const ranap_ProcedureCode* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Criticality 
   (const char* name, const ranap_Criticality* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("reject\n"); break;
      case 1: printf ("ignore\n"); break;
      case 2: printf ("notify\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_ProtocolIE_ID 
   (const char* name, const ranap_ProtocolIE_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_ProtocolExtensionID 
   (const char* name, const ranap_ProtocolExtensionID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_PrivateIE_ID 
   (const char* name, const ranap_PrivateIE_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* local */
      case 1:
      {
         rtxPrintIndent ();
         rtxPrintUnsigned ("local", pvalue->u.local);
         break;
      }
      /* global */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintOID ("global", pvalue->u.global);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TriggeringMessage 
   (const char* name, const ranap_TriggeringMessage* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("initiating-message\n"); break;
      case 1: printf ("successful-outcome\n"); break;
      case 2: printf ("unsuccessfull-outcome\n"); break;
      case 3: printf ("outcome\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_Presence (const char* name, const ranap_Presence* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("optional\n"); break;
      case 1: printf ("conditional\n"); break;
      case 2: printf ("mandatory\n"); break;
      default: printf ("???\n");
   }
}

EXTERN int asn1PE_ranap_ProtocolIE_Field (OSCTXT* pctxt, ranap_ProtocolIE_Field* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-Field");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ranap_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolIE_Field (OSCTXT* pctxt, ranap_ProtocolIE_Field* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-Field");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ranap_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolIE_Field (ranap_ProtocolIE_Field* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_ProtocolIE_Field (OSCTXT *pctxt, 
   ranap_ProtocolIE_Field* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_ProtocolIE_Container (OSCTXT* pctxt, ranap_ProtocolIE_Container* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-Container");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Field", xx1);

      stat = asn1PE_ranap_ProtocolIE_Field (pctxt, ((ranap_ProtocolIE_Field*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolIE_Container (OSCTXT* pctxt, ranap_ProtocolIE_Container* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-Container");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_Field* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Field", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_Field, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_Field (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_Field (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolIE_Container (ranap_ProtocolIE_Container* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ProtocolIE_Container (OSCTXT *pctxt, 
   ranap_ProtocolIE_Container* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_Field* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_Field*)pnode->data;
      asn1Free_ranap_ProtocolIE_Field (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_ProtocolIE_FieldPair (OSCTXT* pctxt, ranap_ProtocolIE_FieldPair* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-FieldPair");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ranap_ProtocolIE_ID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode firstCriticality */

   RTXCTXTPUSHELEMNAME (pctxt, "firstCriticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->firstCriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode firstValue */

   RTXCTXTPUSHELEMNAME (pctxt, "firstValue");

   stat = pe_OpenType (pctxt, pvalue->firstValue.numocts, pvalue->firstValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode secondCriticality */

   RTXCTXTPUSHELEMNAME (pctxt, "secondCriticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->secondCriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode secondValue */

   RTXCTXTPUSHELEMNAME (pctxt, "secondValue");

   stat = pe_OpenType (pctxt, pvalue->secondValue.numocts, pvalue->secondValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolIE_FieldPair (OSCTXT* pctxt, ranap_ProtocolIE_FieldPair* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-FieldPair");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ranap_ProtocolIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstCriticality */
   RTXCTXTPUSHELEMNAME (pctxt, "firstCriticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->firstCriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode firstValue */
   RTXCTXTPUSHELEMNAME (pctxt, "firstValue");

   stat = pd_OpenType (pctxt, &pvalue->firstValue.data, &pvalue->firstValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondCriticality */
   RTXCTXTPUSHELEMNAME (pctxt, "secondCriticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->secondCriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode secondValue */
   RTXCTXTPUSHELEMNAME (pctxt, "secondValue");

   stat = pd_OpenType (pctxt, &pvalue->secondValue.data, &pvalue->secondValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolIE_FieldPair (ranap_ProtocolIE_FieldPair* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->firstValue.numocts = 0;
   pvalue->firstValue.data = 0;
   pvalue->secondValue.numocts = 0;
   pvalue->secondValue.data = 0;
   return 0;
}

void asn1Free_ranap_ProtocolIE_FieldPair (OSCTXT *pctxt, 
   ranap_ProtocolIE_FieldPair* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->firstValue.data);
   }
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->secondValue.data);
   }
}

EXTERN int asn1PE_ranap_ProtocolIE_ContainerPair (OSCTXT* pctxt, ranap_ProtocolIE_ContainerPair* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ContainerPair");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-FieldPair", xx1);

      stat = asn1PE_ranap_ProtocolIE_FieldPair (pctxt, ((ranap_ProtocolIE_FieldPair*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolIE_ContainerPair (OSCTXT* pctxt, ranap_ProtocolIE_ContainerPair* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolIE-ContainerPair");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(0), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_FieldPair* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-FieldPair", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_FieldPair, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_FieldPair (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_FieldPair (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolIE_ContainerPair (
   ranap_ProtocolIE_ContainerPair* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ProtocolIE_ContainerPair (OSCTXT *pctxt, 
   ranap_ProtocolIE_ContainerPair* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_FieldPair* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_FieldPair*)pnode->data;
      asn1Free_ranap_ProtocolIE_FieldPair (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_ProtocolExtensionField (OSCTXT* pctxt, ranap_ProtocolExtensionField* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionField");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ranap_ProtocolExtensionID (pctxt, pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode extensionValue */

   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pe_OpenType (pctxt, pvalue->extensionValue.numocts, pvalue->extensionValue.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolExtensionField (OSCTXT* pctxt, ranap_ProtocolExtensionField* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionField");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ranap_ProtocolExtensionID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extensionValue */
   RTXCTXTPUSHELEMNAME (pctxt, "extensionValue");

   stat = pd_OpenType (pctxt, &pvalue->extensionValue.data, &pvalue->extensionValue.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolExtensionField (
   ranap_ProtocolExtensionField* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->extensionValue.numocts = 0;
   pvalue->extensionValue.data = 0;
   return 0;
}

void asn1Free_ranap_ProtocolExtensionField (OSCTXT *pctxt, 
   ranap_ProtocolExtensionField* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->extensionValue.data);
   }
}

EXTERN int asn1PE_ranap_ProtocolExtensionContainer (OSCTXT* pctxt, ranap_ProtocolExtensionContainer* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionContainer");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolExtensionField", xx1);

      stat = asn1PE_ranap_ProtocolExtensionField (pctxt, ((ranap_ProtocolExtensionField*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolExtensionContainer (OSCTXT* pctxt, ranap_ProtocolExtensionContainer* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolExtensionContainer");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolExtensionField* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolExtensionField", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolExtensionField, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolExtensionField (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolExtensionField (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolExtensionContainer (
   ranap_ProtocolExtensionContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ProtocolExtensionContainer (OSCTXT *pctxt, 
   ranap_ProtocolExtensionContainer* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolExtensionField* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolExtensionField*)pnode->data;
      asn1Free_ranap_ProtocolExtensionField (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_PrivateIE_Field (OSCTXT* pctxt, ranap_PrivateIE_Field* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-Field");

   /* encode id */

   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PE_ranap_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PrivateIE_Field (OSCTXT* pctxt, ranap_PrivateIE_Field* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-Field");

   /* decode root elements */
   /* decode id */
   RTXCTXTPUSHELEMNAME (pctxt, "id");

   stat = asn1PD_ranap_PrivateIE_ID (pctxt, &pvalue->id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PrivateIE_Field (ranap_PrivateIE_Field* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_PrivateIE_ID (&pvalue->id);
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_PrivateIE_Field (OSCTXT *pctxt, 
   ranap_PrivateIE_Field* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_PrivateIE_ID (pctxt, &pvalue->id);
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_PrivateIE_Container (OSCTXT* pctxt, ranap_PrivateIE_Container* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-Container");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PrivateIE-Field", xx1);

      stat = asn1PE_ranap_PrivateIE_Field (pctxt, ((ranap_PrivateIE_Field*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PrivateIE_Container (OSCTXT* pctxt, ranap_PrivateIE_Container* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateIE-Container");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65535), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_PrivateIE_Field* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PrivateIE-Field", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_PrivateIE_Field, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_PrivateIE_Field (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_PrivateIE_Field (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PrivateIE_Container (ranap_PrivateIE_Container* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_PrivateIE_Container (OSCTXT *pctxt, 
   ranap_PrivateIE_Container* pvalue)
{
   if (0 == pvalue) return;
   { ranap_PrivateIE_Field* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_PrivateIE_Field*)pnode->data;
      asn1Free_ranap_PrivateIE_Field (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Print_ranap_ProtocolIE_Field 
   (const char* name, const ranap_ProtocolIE_Field* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ProtocolIE_Container 
   (const char* name, const ranap_ProtocolIE_Container* pvalue)
{
   ranap_ProtocolIE_Field* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_Field*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_Field (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_ProtocolIE_FieldPair 
   (const char* name, const ranap_ProtocolIE_FieldPair* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_ID ("id", &pvalue->id);

   asn1Print_ranap_Criticality ("firstCriticality", &pvalue->firstCriticality
      );

   rtxPrintIndent ();
   rtxPrintHexStr ("firstValue", pvalue->firstValue.numocts,
   pvalue->firstValue.data);

   asn1Print_ranap_Criticality ("secondCriticality", &pvalue->secondCriticality
      );

   rtxPrintIndent ();
   rtxPrintHexStr ("secondValue", pvalue->secondValue.numocts,
   pvalue->secondValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ProtocolIE_ContainerPair 
   (const char* name, const ranap_ProtocolIE_ContainerPair* pvalue)
{
   ranap_ProtocolIE_FieldPair* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_FieldPair*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_FieldPair (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_ProtocolExtensionField 
   (const char* name, const ranap_ProtocolExtensionField* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolExtensionID ("id", &pvalue->id);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("extensionValue", pvalue->extensionValue.numocts,
   pvalue->extensionValue.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ProtocolExtensionContainer 
   (const char* name, const ranap_ProtocolExtensionContainer* pvalue)
{
   ranap_ProtocolExtensionField* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolExtensionField*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolExtensionField (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_PrivateIE_Field 
   (const char* name, const ranap_PrivateIE_Field* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PrivateIE_ID ("id", &pvalue->id);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PrivateIE_Container 
   (const char* name, const ranap_PrivateIE_Container* pvalue)
{
   ranap_PrivateIE_Field* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_PrivateIE_Field*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PrivateIE_Field (namebuf, pdata0);
      xx1++;
   }
}

EXTERN int asn1PE_ranap_RAB_ID (OSCTXT* pctxt, ranap_RAB_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ID (OSCTXT* pctxt, ranap_RAB_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ID (ranap_RAB_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_UnsuccessfullyTransmittedDataVolume (OSCTXT* pctxt, ranap_UnsuccessfullyTransmittedDataVolume value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfullyTransmittedDataVolume");

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UnsuccessfullyTransmittedDataVolume (OSCTXT* pctxt, ranap_UnsuccessfullyTransmittedDataVolume* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfullyTransmittedDataVolume");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINT32_MAX);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_DataVolumeReference (OSCTXT* pctxt, ranap_DataVolumeReference value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReference");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeReference (OSCTXT* pctxt, ranap_DataVolumeReference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReference");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_DL_GTP_PDU_SequenceNumber (OSCTXT* pctxt, ranap_DL_GTP_PDU_SequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-GTP-PDU-SequenceNumber");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DL_GTP_PDU_SequenceNumber (OSCTXT* pctxt, ranap_DL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-GTP-PDU-SequenceNumber");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UL_GTP_PDU_SequenceNumber (OSCTXT* pctxt, ranap_UL_GTP_PDU_SequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-GTP-PDU-SequenceNumber");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UL_GTP_PDU_SequenceNumber (OSCTXT* pctxt, ranap_UL_GTP_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-GTP-PDU-SequenceNumber");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TransportLayerAddress (OSCTXT* pctxt, ranap_TransportLayerAddress value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransportLayerAddress");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(160), OSUINTCONST(0), OSUINT32_MAX);

   stat = pe_BitString (pctxt, value.numbits, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TransportLayerAddress (OSCTXT* pctxt, ranap_TransportLayerAddress* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransportLayerAddress");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(160), OSUINTCONST(0), OSUINT32_MAX);

   stat = pd_DynBitString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TransportLayerAddress (ranap_TransportLayerAddress* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_TransportLayerAddress (OSCTXT *pctxt, 
   ranap_TransportLayerAddress* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numbits = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_GTP_TEI (OSCTXT* pctxt, ranap_GTP_TEI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GTP-TEI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GTP_TEI (OSCTXT* pctxt, ranap_GTP_TEI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GTP-TEI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GTP_TEI (ranap_GTP_TEI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_BindingID (OSCTXT* pctxt, ranap_BindingID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BindingID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_BindingID (OSCTXT* pctxt, ranap_BindingID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BindingID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_BindingID (ranap_BindingID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IuTransportAssociation (OSCTXT* pctxt, ranap_IuTransportAssociation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "IuTransportAssociation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* gTP_TEI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "gTP-TEI");

            stat = asn1PE_ranap_GTP_TEI (pctxt, pvalue->u.gTP_TEI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* bindingID */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "bindingID");

            stat = asn1PE_ranap_BindingID (pctxt, pvalue->u.bindingID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IuTransportAssociation (OSCTXT* pctxt, ranap_IuTransportAssociation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "IuTransportAssociation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* gTP_TEI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "gTP-TEI");

            pvalue->u.gTP_TEI = rtxMemAllocType (pctxt, ranap_GTP_TEI);

            if (pvalue->u.gTP_TEI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GTP_TEI (pvalue->u.gTP_TEI);

            stat = asn1PD_ranap_GTP_TEI (pctxt, pvalue->u.gTP_TEI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* bindingID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "bindingID");

            pvalue->u.bindingID = rtxMemAllocType (pctxt, ranap_BindingID);

            if (pvalue->u.bindingID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_BindingID (pvalue->u.bindingID);

            stat = asn1PD_ranap_BindingID (pctxt, pvalue->u.bindingID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IuTransportAssociation (
   ranap_IuTransportAssociation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_IuTransportAssociation (OSCTXT *pctxt, 
   ranap_IuTransportAssociation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.gTP_TEI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gTP_TEI);
            pvalue->u.gTP_TEI = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.bindingID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bindingID);
            pvalue->u.bindingID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_NAS_SynchronisationIndicator (OSCTXT* pctxt, ranap_NAS_SynchronisationIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-SynchronisationIndicator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(4), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NAS_SynchronisationIndicator (OSCTXT* pctxt, ranap_NAS_SynchronisationIndicator* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-SynchronisationIndicator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(4), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NAS_SynchronisationIndicator (
   ranap_NAS_SynchronisationIndicator* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_TrafficClass_ENUMTAB[] = {
   { OSUTF8("background"), 3, 10, 1 },
   { OSUTF8("conversational"), 0, 14, 3 },
   { OSUTF8("interactive"), 2, 11, 2 },
   { OSUTF8("streaming"), 1, 9, 0 }
} ;
#define ranap_TrafficClass_ENUMTABSIZE 4

const OSUTF8CHAR* ranap_TrafficClass_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_TrafficClass_ENUMTABSIZE) {
      return ranap_TrafficClass_ENUMTAB
         [ranap_TrafficClass_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_TrafficClass_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_TrafficClass* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_TrafficClass_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_TrafficClass_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_TrafficClass* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_TrafficClass_ENUMTAB, 
      ranap_TrafficClass_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_TrafficClass)ranap_TrafficClass_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_TrafficClass (OSCTXT* pctxt, ranap_TrafficClass value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrafficClass");

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TrafficClass (OSCTXT* pctxt, ranap_TrafficClass* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TrafficClass");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RAB_AsymmetryIndicator_ENUMTAB[] = {
   { OSUTF8("asymmetric-bidirectional"), 3, 24, 3 },
   { OSUTF8("asymmetric-unidirectional-downlink"), 1, 34, 1 },
   { OSUTF8("asymmetric-unidirectional-uplink"), 2, 32, 2 },
   { OSUTF8("symmetric-bidirectional"), 0, 23, 0 }
} ;
#define ranap_RAB_AsymmetryIndicator_ENUMTABSIZE 4

const OSUTF8CHAR* ranap_RAB_AsymmetryIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RAB_AsymmetryIndicator_ENUMTABSIZE) {
      return ranap_RAB_AsymmetryIndicator_ENUMTAB
         [ranap_RAB_AsymmetryIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RAB_AsymmetryIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RAB_AsymmetryIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RAB_AsymmetryIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RAB_AsymmetryIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RAB_AsymmetryIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RAB_AsymmetryIndicator_ENUMTAB, 
      ranap_RAB_AsymmetryIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RAB_AsymmetryIndicator)
         ranap_RAB_AsymmetryIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RAB_AsymmetryIndicator (OSCTXT* pctxt, ranap_RAB_AsymmetryIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AsymmetryIndicator");

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_AsymmetryIndicator (OSCTXT* pctxt, ranap_RAB_AsymmetryIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AsymmetryIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_MaxBitrate (OSCTXT* pctxt, ranap_MaxBitrate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxBitrate");

   if ( (value >= 1 && value <= 16000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 16000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MaxBitrate (OSCTXT* pctxt, ranap_MaxBitrate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxBitrate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 1, 16000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-MaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PE_ranap_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-MaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PD_ranap_MaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_Parameter_MaxBitrateList (
   ranap_RAB_Parameter_MaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_GuaranteedBitrate (OSCTXT* pctxt, ranap_GuaranteedBitrate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GuaranteedBitrate");

   if ( value <= 16000000 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 16000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GuaranteedBitrate (OSCTXT* pctxt, ranap_GuaranteedBitrate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GuaranteedBitrate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 16000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-GuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PE_ranap_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-GuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PD_ranap_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_Parameter_GuaranteedBitrateList (
   ranap_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

static const OSEnumItem ranap_DeliveryOrder_ENUMTAB[] = {
   { OSUTF8("delivery-order-not-requested"), 1, 28, 1 },
   { OSUTF8("delivery-order-requested"), 0, 24, 0 }
} ;
#define ranap_DeliveryOrder_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_DeliveryOrder_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_DeliveryOrder_ENUMTABSIZE) {
      return ranap_DeliveryOrder_ENUMTAB
         [ranap_DeliveryOrder_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_DeliveryOrder_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_DeliveryOrder* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_DeliveryOrder_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_DeliveryOrder_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_DeliveryOrder* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_DeliveryOrder_ENUMTAB, 
      ranap_DeliveryOrder_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_DeliveryOrder)ranap_DeliveryOrder_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_DeliveryOrder (OSCTXT* pctxt, ranap_DeliveryOrder value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeliveryOrder");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DeliveryOrder (OSCTXT* pctxt, ranap_DeliveryOrder* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeliveryOrder");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_MaxSDU_Size (OSCTXT* pctxt, ranap_MaxSDU_Size value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxSDU-Size");

   if ( value <= 32768 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 32768);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MaxSDU_Size (OSCTXT* pctxt, ranap_MaxSDU_Size* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MaxSDU-Size");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 32768);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SDU_ErrorRatio (OSCTXT* pctxt, ranap_SDU_ErrorRatio* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-ErrorRatio");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mantissa */

   RTXCTXTPUSHELEMNAME (pctxt, "mantissa");

   if ( (pvalue->mantissa >= 1 && pvalue->mantissa <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->mantissa, 1, 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->mantissa);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode exponent */

   RTXCTXTPUSHELEMNAME (pctxt, "exponent");

   if ( (pvalue->exponent >= 1 && pvalue->exponent <= 6) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->exponent, 1, 6);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->exponent);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SDU_ErrorRatio (OSCTXT* pctxt, ranap_SDU_ErrorRatio* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-ErrorRatio");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mantissa */
   RTXCTXTPUSHELEMNAME (pctxt, "mantissa");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, 1, 9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode exponent */
   RTXCTXTPUSHELEMNAME (pctxt, "exponent");

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, 1, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SDU_ErrorRatio (ranap_SDU_ErrorRatio* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_SDU_ErrorRatio (OSCTXT *pctxt, 
   ranap_SDU_ErrorRatio* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_ResidualBitErrorRatio (OSCTXT* pctxt, ranap_ResidualBitErrorRatio* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResidualBitErrorRatio");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mantissa */

   RTXCTXTPUSHELEMNAME (pctxt, "mantissa");

   if ( (pvalue->mantissa >= 1 && pvalue->mantissa <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->mantissa, 1, 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->mantissa);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode exponent */

   RTXCTXTPUSHELEMNAME (pctxt, "exponent");

   if ( (pvalue->exponent >= 1 && pvalue->exponent <= 8) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->exponent, 1, 8);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->exponent);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResidualBitErrorRatio (OSCTXT* pctxt, ranap_ResidualBitErrorRatio* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResidualBitErrorRatio");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mantissa */
   RTXCTXTPUSHELEMNAME (pctxt, "mantissa");

   stat = pd_ConsUInt8 (pctxt, &pvalue->mantissa, 1, 9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode exponent */
   RTXCTXTPUSHELEMNAME (pctxt, "exponent");

   stat = pd_ConsUInt8 (pctxt, &pvalue->exponent, 1, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResidualBitErrorRatio (ranap_ResidualBitErrorRatio* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_ResidualBitErrorRatio (OSCTXT *pctxt, 
   ranap_ResidualBitErrorRatio* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

static const OSEnumItem ranap_DeliveryOfErroneousSDU_ENUMTAB[] = {
   { OSUTF8("no"), 1, 2, 2 },
   { OSUTF8("no-error-detection-consideration"), 2, 32, 0 },
   { OSUTF8("yes"), 0, 3, 1 }
} ;
#define ranap_DeliveryOfErroneousSDU_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_DeliveryOfErroneousSDU_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_DeliveryOfErroneousSDU_ENUMTABSIZE) {
      return ranap_DeliveryOfErroneousSDU_ENUMTAB
         [ranap_DeliveryOfErroneousSDU_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_DeliveryOfErroneousSDU_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_DeliveryOfErroneousSDU* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_DeliveryOfErroneousSDU_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_DeliveryOfErroneousSDU_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_DeliveryOfErroneousSDU* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_DeliveryOfErroneousSDU_ENUMTAB, 
      ranap_DeliveryOfErroneousSDU_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_DeliveryOfErroneousSDU)
         ranap_DeliveryOfErroneousSDU_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_DeliveryOfErroneousSDU (OSCTXT* pctxt, ranap_DeliveryOfErroneousSDU value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeliveryOfErroneousSDU");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DeliveryOfErroneousSDU (OSCTXT* pctxt, ranap_DeliveryOfErroneousSDU* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeliveryOfErroneousSDU");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SubflowSDU_Size (OSCTXT* pctxt, ranap_SubflowSDU_Size value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubflowSDU-Size");

   if ( value <= 4095 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SubflowSDU_Size (OSCTXT* pctxt, ranap_SubflowSDU_Size* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubflowSDU-Size");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 4095);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RAB_SubflowCombinationBitRate (OSCTXT* pctxt, ranap_RAB_SubflowCombinationBitRate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SubflowCombinationBitRate");

   if ( value <= 16000000 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 16000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SubflowCombinationBitRate (OSCTXT* pctxt, ranap_RAB_SubflowCombinationBitRate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SubflowCombinationBitRate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 16000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SDU_FormatInformationParameters_element (OSCTXT* pctxt, ranap_SDU_FormatInformationParameters_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.subflowSDU_SizePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rAB_SubflowCombinationBitRatePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode subflowSDU_Size */

   if (pvalue->m.subflowSDU_SizePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "subflowSDU-Size");

      stat = asn1PE_ranap_SubflowSDU_Size (pctxt, pvalue->subflowSDU_Size);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rAB_SubflowCombinationBitRate */

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-SubflowCombinationBitRate");

      stat = asn1PE_ranap_RAB_SubflowCombinationBitRate (pctxt, pvalue->rAB_SubflowCombinationBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_SDU_FormatInformationParameters_element (OSCTXT* pctxt, ranap_SDU_FormatInformationParameters_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode subflowSDU_Size */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "subflowSDU-Size");

      pvalue->m.subflowSDU_SizePresent = 1;

      stat = asn1PD_ranap_SubflowSDU_Size (pctxt, &pvalue->subflowSDU_Size);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAB_SubflowCombinationBitRate */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-SubflowCombinationBitRate");

      pvalue->m.rAB_SubflowCombinationBitRatePresent = 1;

      stat = asn1PD_ranap_RAB_SubflowCombinationBitRate (pctxt, &pvalue->rAB_SubflowCombinationBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_SDU_FormatInformationParameters_element (
   ranap_SDU_FormatInformationParameters_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SDU_FormatInformationParameters_element (OSCTXT *pctxt, 
   ranap_SDU_FormatInformationParameters_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SDU_FormatInformationParameters (OSCTXT* pctxt, ranap_SDU_FormatInformationParameters* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-FormatInformationParameters");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_SDU_FormatInformationParameters_element (pctxt, ((ranap_SDU_FormatInformationParameters_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SDU_FormatInformationParameters (OSCTXT* pctxt, ranap_SDU_FormatInformationParameters* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-FormatInformationParameters");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_SDU_FormatInformationParameters_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_SDU_FormatInformationParameters_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_SDU_FormatInformationParameters_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_SDU_FormatInformationParameters_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SDU_FormatInformationParameters (
   ranap_SDU_FormatInformationParameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_SDU_FormatInformationParameters (OSCTXT *pctxt, 
   ranap_SDU_FormatInformationParameters* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SDU_FormatInformationParameters_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SDU_FormatInformationParameters_element*)pnode->data;
      asn1Free_ranap_SDU_FormatInformationParameters_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_SDU_Parameters_element (OSCTXT* pctxt, ranap_SDU_Parameters_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sDU_ErrorRatioPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sDU_FormatInformationParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sDU_ErrorRatio */

   if (pvalue->m.sDU_ErrorRatioPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sDU-ErrorRatio");

      stat = asn1PE_ranap_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode residualBitErrorRatio */

   RTXCTXTPUSHELEMNAME (pctxt, "residualBitErrorRatio");

   stat = asn1PE_ranap_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode deliveryOfErroneousSDU */

   RTXCTXTPUSHELEMNAME (pctxt, "deliveryOfErroneousSDU");

   stat = asn1PE_ranap_DeliveryOfErroneousSDU (pctxt, pvalue->deliveryOfErroneousSDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sDU_FormatInformationParameters */

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sDU-FormatInformationParameters");

      stat = asn1PE_ranap_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_SDU_Parameters_element (OSCTXT* pctxt, ranap_SDU_Parameters_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sDU_ErrorRatio */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sDU-ErrorRatio");

      pvalue->m.sDU_ErrorRatioPresent = 1;

      stat = asn1PD_ranap_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode residualBitErrorRatio */
   RTXCTXTPUSHELEMNAME (pctxt, "residualBitErrorRatio");

   stat = asn1PD_ranap_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode deliveryOfErroneousSDU */
   RTXCTXTPUSHELEMNAME (pctxt, "deliveryOfErroneousSDU");

   stat = asn1PD_ranap_DeliveryOfErroneousSDU (pctxt, &pvalue->deliveryOfErroneousSDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sDU_FormatInformationParameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sDU-FormatInformationParameters");

      pvalue->m.sDU_FormatInformationParametersPresent = 1;

      stat = asn1PD_ranap_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_SDU_Parameters_element (
   ranap_SDU_Parameters_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_SDU_ErrorRatio (&pvalue->sDU_ErrorRatio);
   asn1Init_ranap_ResidualBitErrorRatio (&pvalue->residualBitErrorRatio);
   asn1Init_ranap_SDU_FormatInformationParameters (&pvalue->sDU_FormatInformationParameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SDU_Parameters_element (OSCTXT *pctxt, 
   ranap_SDU_Parameters_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.sDU_ErrorRatioPresent) {
      asn1Free_ranap_SDU_ErrorRatio (pctxt, &pvalue->sDU_ErrorRatio);
   }
   asn1Free_ranap_ResidualBitErrorRatio (pctxt, &pvalue->residualBitErrorRatio);
   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      asn1Free_ranap_SDU_FormatInformationParameters (pctxt, &pvalue->sDU_FormatInformationParameters);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SDU_Parameters (OSCTXT* pctxt, ranap_SDU_Parameters* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-Parameters");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(7), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_SDU_Parameters_element (pctxt, ((ranap_SDU_Parameters_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SDU_Parameters (OSCTXT* pctxt, ranap_SDU_Parameters* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SDU-Parameters");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(7), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_SDU_Parameters_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_SDU_Parameters_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_SDU_Parameters_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_SDU_Parameters_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SDU_Parameters (ranap_SDU_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_SDU_Parameters (OSCTXT *pctxt, 
   ranap_SDU_Parameters* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SDU_Parameters_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SDU_Parameters_element*)pnode->data;
      asn1Free_ranap_SDU_Parameters_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_TransferDelay (OSCTXT* pctxt, ranap_TransferDelay value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransferDelay");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TransferDelay (OSCTXT* pctxt, ranap_TransferDelay* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TransferDelay");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TrafficHandlingPriority (OSCTXT* pctxt, ranap_TrafficHandlingPriority value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrafficHandlingPriority");

   if ( value <= 15 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TrafficHandlingPriority (OSCTXT* pctxt, ranap_TrafficHandlingPriority* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrafficHandlingPriority");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_PriorityLevel (OSCTXT* pctxt, ranap_PriorityLevel value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PriorityLevel");

   if ( value <= 15 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PriorityLevel (OSCTXT* pctxt, ranap_PriorityLevel* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PriorityLevel");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Pre_emptionCapability_ENUMTAB[] = {
   { OSUTF8("may-trigger-pre-emption"), 1, 23, 1 },
   { OSUTF8("shall-not-trigger-pre-emption"), 0, 29, 0 }
} ;
#define ranap_Pre_emptionCapability_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_Pre_emptionCapability_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Pre_emptionCapability_ENUMTABSIZE) {
      return ranap_Pre_emptionCapability_ENUMTAB
         [ranap_Pre_emptionCapability_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Pre_emptionCapability_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Pre_emptionCapability* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Pre_emptionCapability_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Pre_emptionCapability_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Pre_emptionCapability* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Pre_emptionCapability_ENUMTAB, 
      ranap_Pre_emptionCapability_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Pre_emptionCapability)
         ranap_Pre_emptionCapability_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Pre_emptionCapability (OSCTXT* pctxt, ranap_Pre_emptionCapability value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionCapability");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Pre_emptionCapability (OSCTXT* pctxt, ranap_Pre_emptionCapability* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionCapability");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Pre_emptionVulnerability_ENUMTAB[] = {
   { OSUTF8("not-pre-emptable"), 0, 16, 0 },
   { OSUTF8("pre-emptable"), 1, 12, 1 }
} ;
#define ranap_Pre_emptionVulnerability_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_Pre_emptionVulnerability_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Pre_emptionVulnerability_ENUMTABSIZE) {
      return ranap_Pre_emptionVulnerability_ENUMTAB
         [ranap_Pre_emptionVulnerability_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Pre_emptionVulnerability_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Pre_emptionVulnerability* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Pre_emptionVulnerability_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Pre_emptionVulnerability_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Pre_emptionVulnerability* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Pre_emptionVulnerability_ENUMTAB, 
      ranap_Pre_emptionVulnerability_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Pre_emptionVulnerability)
         ranap_Pre_emptionVulnerability_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Pre_emptionVulnerability (OSCTXT* pctxt, ranap_Pre_emptionVulnerability value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionVulnerability");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Pre_emptionVulnerability (OSCTXT* pctxt, ranap_Pre_emptionVulnerability* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Pre-emptionVulnerability");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_QueuingAllowed_ENUMTAB[] = {
   { OSUTF8("queueing-allowed"), 1, 16, 1 },
   { OSUTF8("queueing-not-allowed"), 0, 20, 0 }
} ;
#define ranap_QueuingAllowed_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_QueuingAllowed_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_QueuingAllowed_ENUMTABSIZE) {
      return ranap_QueuingAllowed_ENUMTAB
         [ranap_QueuingAllowed_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_QueuingAllowed_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_QueuingAllowed* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_QueuingAllowed_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_QueuingAllowed_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_QueuingAllowed* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_QueuingAllowed_ENUMTAB, 
      ranap_QueuingAllowed_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_QueuingAllowed)ranap_QueuingAllowed_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_QueuingAllowed (OSCTXT* pctxt, ranap_QueuingAllowed value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QueuingAllowed");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_QueuingAllowed (OSCTXT* pctxt, ranap_QueuingAllowed* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "QueuingAllowed");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_AllocationOrRetentionPriority (OSCTXT* pctxt, ranap_AllocationOrRetentionPriority* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AllocationOrRetentionPriority");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode priorityLevel */

   RTXCTXTPUSHELEMNAME (pctxt, "priorityLevel");

   stat = asn1PE_ranap_PriorityLevel (pctxt, pvalue->priorityLevel);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pre_emptionCapability */

   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionCapability");

   stat = asn1PE_ranap_Pre_emptionCapability (pctxt, pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pre_emptionVulnerability */

   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionVulnerability");

   stat = asn1PE_ranap_Pre_emptionVulnerability (pctxt, pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode queuingAllowed */

   RTXCTXTPUSHELEMNAME (pctxt, "queuingAllowed");

   stat = asn1PE_ranap_QueuingAllowed (pctxt, pvalue->queuingAllowed);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AllocationOrRetentionPriority (OSCTXT* pctxt, ranap_AllocationOrRetentionPriority* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "AllocationOrRetentionPriority");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode priorityLevel */
   RTXCTXTPUSHELEMNAME (pctxt, "priorityLevel");

   stat = asn1PD_ranap_PriorityLevel (pctxt, &pvalue->priorityLevel);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pre_emptionCapability */
   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionCapability");

   stat = asn1PD_ranap_Pre_emptionCapability (pctxt, &pvalue->pre_emptionCapability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pre_emptionVulnerability */
   RTXCTXTPUSHELEMNAME (pctxt, "pre-emptionVulnerability");

   stat = asn1PD_ranap_Pre_emptionVulnerability (pctxt, &pvalue->pre_emptionVulnerability);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode queuingAllowed */
   RTXCTXTPUSHELEMNAME (pctxt, "queuingAllowed");

   stat = asn1PD_ranap_QueuingAllowed (pctxt, &pvalue->queuingAllowed);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_AllocationOrRetentionPriority (
   ranap_AllocationOrRetentionPriority* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_AllocationOrRetentionPriority (OSCTXT *pctxt, 
   ranap_AllocationOrRetentionPriority* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem ranap_SourceStatisticsDescriptor_ENUMTAB[] = {
   { OSUTF8("speech"), 0, 6, 0 },
   { OSUTF8("unknown"), 1, 7, 1 }
} ;
#define ranap_SourceStatisticsDescriptor_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_SourceStatisticsDescriptor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_SourceStatisticsDescriptor_ENUMTABSIZE) {
      return ranap_SourceStatisticsDescriptor_ENUMTAB
         [ranap_SourceStatisticsDescriptor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_SourceStatisticsDescriptor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_SourceStatisticsDescriptor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_SourceStatisticsDescriptor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_SourceStatisticsDescriptor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_SourceStatisticsDescriptor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_SourceStatisticsDescriptor_ENUMTAB, 
      ranap_SourceStatisticsDescriptor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_SourceStatisticsDescriptor)
         ranap_SourceStatisticsDescriptor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_SourceStatisticsDescriptor (OSCTXT* pctxt, ranap_SourceStatisticsDescriptor value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceStatisticsDescriptor");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceStatisticsDescriptor (OSCTXT* pctxt, ranap_SourceStatisticsDescriptor* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceStatisticsDescriptor");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RelocationRequirement_ENUMTAB[] = {
   { OSUTF8("lossless"), 0, 8, 0 },
   { OSUTF8("none"), 1, 4, 1 },
   { OSUTF8("realtime"), 2, 8, 2 }
} ;
#define ranap_RelocationRequirement_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_RelocationRequirement_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RelocationRequirement_ENUMTABSIZE) {
      return ranap_RelocationRequirement_ENUMTAB
         [ranap_RelocationRequirement_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RelocationRequirement_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RelocationRequirement* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RelocationRequirement_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RelocationRequirement_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RelocationRequirement* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RelocationRequirement_ENUMTAB, 
      ranap_RelocationRequirement_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RelocationRequirement)
         ranap_RelocationRequirement_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RelocationRequirement (OSCTXT* pctxt, ranap_RelocationRequirement value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequirement");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(1));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 2);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationRequirement (OSCTXT* pctxt, ranap_RelocationRequirement* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequirement");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_realtime; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RAB_Parameters (OSCTXT* pctxt, ranap_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.guaranteedBitRatePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transferDelayPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.trafficHandlingPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.allocationOrRetentionPriorityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourceStatisticsDescriptorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.relocationRequirementPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode trafficClass */

   RTXCTXTPUSHELEMNAME (pctxt, "trafficClass");

   stat = asn1PE_ranap_TrafficClass (pctxt, pvalue->trafficClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAB_AsymmetryIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-AsymmetryIndicator");

   stat = asn1PE_ranap_RAB_AsymmetryIndicator (pctxt, pvalue->rAB_AsymmetryIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxBitrate */

   RTXCTXTPUSHELEMNAME (pctxt, "maxBitrate");

   stat = asn1PE_ranap_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->maxBitrate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode guaranteedBitRate */

   if (pvalue->m.guaranteedBitRatePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "guaranteedBitRate");

      stat = asn1PE_ranap_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->guaranteedBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode deliveryOrder */

   RTXCTXTPUSHELEMNAME (pctxt, "deliveryOrder");

   stat = asn1PE_ranap_DeliveryOrder (pctxt, pvalue->deliveryOrder);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode maxSDU_Size */

   RTXCTXTPUSHELEMNAME (pctxt, "maxSDU-Size");

   stat = asn1PE_ranap_MaxSDU_Size (pctxt, pvalue->maxSDU_Size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sDU_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "sDU-Parameters");

   stat = asn1PE_ranap_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transferDelay */

   if (pvalue->m.transferDelayPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "transferDelay");

      stat = asn1PE_ranap_TransferDelay (pctxt, pvalue->transferDelay);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode trafficHandlingPriority */

   if (pvalue->m.trafficHandlingPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "trafficHandlingPriority");

      stat = asn1PE_ranap_TrafficHandlingPriority (pctxt, pvalue->trafficHandlingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode allocationOrRetentionPriority */

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "allocationOrRetentionPriority");

      stat = asn1PE_ranap_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sourceStatisticsDescriptor */

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceStatisticsDescriptor");

      stat = asn1PE_ranap_SourceStatisticsDescriptor (pctxt, pvalue->sourceStatisticsDescriptor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode relocationRequirement */

   if (pvalue->m.relocationRequirementPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "relocationRequirement");

      stat = asn1PE_ranap_RelocationRequirement (pctxt, pvalue->relocationRequirement);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_Parameters (OSCTXT* pctxt, ranap_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode trafficClass */
   RTXCTXTPUSHELEMNAME (pctxt, "trafficClass");

   stat = asn1PD_ranap_TrafficClass (pctxt, &pvalue->trafficClass);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAB_AsymmetryIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-AsymmetryIndicator");

   stat = asn1PD_ranap_RAB_AsymmetryIndicator (pctxt, &pvalue->rAB_AsymmetryIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxBitrate */
   RTXCTXTPUSHELEMNAME (pctxt, "maxBitrate");

   stat = asn1PD_ranap_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->maxBitrate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode guaranteedBitRate */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "guaranteedBitRate");

      pvalue->m.guaranteedBitRatePresent = 1;

      stat = asn1PD_ranap_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->guaranteedBitRate);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode deliveryOrder */
   RTXCTXTPUSHELEMNAME (pctxt, "deliveryOrder");

   stat = asn1PD_ranap_DeliveryOrder (pctxt, &pvalue->deliveryOrder);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode maxSDU_Size */
   RTXCTXTPUSHELEMNAME (pctxt, "maxSDU-Size");

   stat = asn1PD_ranap_MaxSDU_Size (pctxt, &pvalue->maxSDU_Size);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sDU_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "sDU-Parameters");

   stat = asn1PD_ranap_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transferDelay */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transferDelay");

      pvalue->m.transferDelayPresent = 1;

      stat = asn1PD_ranap_TransferDelay (pctxt, &pvalue->transferDelay);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode trafficHandlingPriority */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "trafficHandlingPriority");

      pvalue->m.trafficHandlingPriorityPresent = 1;

      stat = asn1PD_ranap_TrafficHandlingPriority (pctxt, &pvalue->trafficHandlingPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode allocationOrRetentionPriority */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "allocationOrRetentionPriority");

      pvalue->m.allocationOrRetentionPriorityPresent = 1;

      stat = asn1PD_ranap_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sourceStatisticsDescriptor */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceStatisticsDescriptor");

      pvalue->m.sourceStatisticsDescriptorPresent = 1;

      stat = asn1PD_ranap_SourceStatisticsDescriptor (pctxt, &pvalue->sourceStatisticsDescriptor);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode relocationRequirement */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "relocationRequirement");

      pvalue->m.relocationRequirementPresent = 1;

      stat = asn1PD_ranap_RelocationRequirement (pctxt, &pvalue->relocationRequirement);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_Parameters (ranap_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_Parameter_MaxBitrateList (&pvalue->maxBitrate);
   asn1Init_ranap_RAB_Parameter_GuaranteedBitrateList (&pvalue->guaranteedBitRate);
   asn1Init_ranap_SDU_Parameters (&pvalue->sDU_Parameters);
   asn1Init_ranap_AllocationOrRetentionPriority (&pvalue->allocationOrRetentionPriority);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_Parameters (OSCTXT *pctxt, 
   ranap_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_SDU_Parameters (pctxt, &pvalue->sDU_Parameters);
   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      asn1Free_ranap_AllocationOrRetentionPriority (pctxt, &pvalue->allocationOrRetentionPriority);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem ranap_DataVolumeReportingIndication_ENUMTAB[] = {
   { OSUTF8("do-not-report"), 1, 13, 1 },
   { OSUTF8("do-report"), 0, 9, 0 }
} ;
#define ranap_DataVolumeReportingIndication_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_DataVolumeReportingIndication_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_DataVolumeReportingIndication_ENUMTABSIZE) {
      return ranap_DataVolumeReportingIndication_ENUMTAB
         [ranap_DataVolumeReportingIndication_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_DataVolumeReportingIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_DataVolumeReportingIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_DataVolumeReportingIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_DataVolumeReportingIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_DataVolumeReportingIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_DataVolumeReportingIndication_ENUMTAB, 
      ranap_DataVolumeReportingIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_DataVolumeReportingIndication)
         ranap_DataVolumeReportingIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_DataVolumeReportingIndication (OSCTXT* pctxt, ranap_DataVolumeReportingIndication value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReportingIndication");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeReportingIndication (OSCTXT* pctxt, ranap_DataVolumeReportingIndication* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReportingIndication");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_PDP_Type_ENUMTAB[] = {
   { OSUTF8("empty"), 0, 5, 0 },
   { OSUTF8("ipv4"), 3, 4, 4 },
   { OSUTF8("ipv6"), 4, 4, 3 },
   { OSUTF8("osp-ihoss"), 2, 9, 1 },
   { OSUTF8("ppp"), 1, 3, 2 }
} ;
#define ranap_PDP_Type_ENUMTABSIZE 5

const OSUTF8CHAR* ranap_PDP_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_PDP_Type_ENUMTABSIZE) {
      return ranap_PDP_Type_ENUMTAB
         [ranap_PDP_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PDP_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PDP_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PDP_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PDP_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_PDP_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_PDP_Type_ENUMTAB, 
      ranap_PDP_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PDP_Type)ranap_PDP_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PDP_Type (OSCTXT* pctxt, ranap_PDP_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-Type");

   if (value >= 5) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PDP_Type (OSCTXT* pctxt, ranap_PDP_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-Type");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_PDP_TypeInformation (OSCTXT* pctxt, ranap_PDP_TypeInformation* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-TypeInformation");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDP-Type", xx1);

      stat = asn1PE_ranap_PDP_Type (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PDP_TypeInformation (OSCTXT* pctxt, ranap_PDP_TypeInformation* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-TypeInformation");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDP-Type", xx1);

      stat = asn1PD_ranap_PDP_Type (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PDP_TypeInformation (ranap_PDP_TypeInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

static const OSEnumItem ranap_UserPlaneMode_ENUMTAB[] = {
   { OSUTF8("support-mode-for-predefined-SDU-sizes"), 1, 37, 1 },
   { OSUTF8("transparent-mode"), 0, 16, 0 }
} ;
#define ranap_UserPlaneMode_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_UserPlaneMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_UserPlaneMode_ENUMTABSIZE) {
      return ranap_UserPlaneMode_ENUMTAB
         [ranap_UserPlaneMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_UserPlaneMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_UserPlaneMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_UserPlaneMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_UserPlaneMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_UserPlaneMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_UserPlaneMode_ENUMTAB, 
      ranap_UserPlaneMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_UserPlaneMode)ranap_UserPlaneMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_UserPlaneMode (OSCTXT* pctxt, ranap_UserPlaneMode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UserPlaneMode");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UserPlaneMode (OSCTXT* pctxt, ranap_UserPlaneMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UserPlaneMode");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UP_ModeVersions (OSCTXT* pctxt, ranap_UP_ModeVersions value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UP-ModeVersions");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UP_ModeVersions (OSCTXT* pctxt, ranap_UP_ModeVersions* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UP-ModeVersions");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(16), OSUINTCONST(16), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(16), OSUINTCONST(16));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UP_ModeVersions (ranap_UP_ModeVersions* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_Service_Handover_ENUMTAB[] = {
   { OSUTF8("handover-to-GSM-shall-not-be-performed"), 2, 38, 1 },
   { OSUTF8("handover-to-GSM-should-be-performed"), 0, 35, 2 },
   { OSUTF8("handover-to-GSM-should-not-be-performed"), 1, 39, 0 }
} ;
#define ranap_Service_Handover_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Service_Handover_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Service_Handover_ENUMTABSIZE) {
      return ranap_Service_Handover_ENUMTAB
         [ranap_Service_Handover_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Service_Handover_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Service_Handover* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Service_Handover_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Service_Handover_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Service_Handover* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Service_Handover_ENUMTAB, ranap_Service_Handover_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Service_Handover)
         ranap_Service_Handover_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Service_Handover (OSCTXT* pctxt, ranap_Service_Handover value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Service-Handover");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Service_Handover (OSCTXT* pctxt, ranap_Service_Handover* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Service-Handover");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TBCD_STRING (OSCTXT* pctxt, ranap_TBCD_STRING value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TBCD-STRING");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TBCD_STRING (OSCTXT* pctxt, ranap_TBCD_STRING* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TBCD-STRING");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TBCD_STRING (ranap_TBCD_STRING* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_TBCD_STRING (OSCTXT *pctxt, ranap_TBCD_STRING* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_PLMNidentity (OSCTXT* pctxt, ranap_PLMNidentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNidentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PLMNidentity (OSCTXT* pctxt, ranap_PLMNidentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNidentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PLMNidentity (ranap_PLMNidentity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TMGI_serviceID (OSCTXT* pctxt, ranap_TMGI_serviceID* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_TMGI_serviceID (OSCTXT* pctxt, ranap_TMGI_serviceID* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_TMGI_serviceID (ranap_TMGI_serviceID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TMGI (OSCTXT* pctxt, ranap_TMGI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMGI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serviceID */

   RTXCTXTPUSHELEMNAME (pctxt, "serviceID");

   stat = asn1PE_ranap_TMGI_serviceID (pctxt, &pvalue->serviceID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TMGI (OSCTXT* pctxt, ranap_TMGI* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TMGI");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serviceID */
   RTXCTXTPUSHELEMNAME (pctxt, "serviceID");

   stat = asn1PD_ranap_TMGI_serviceID (pctxt, &pvalue->serviceID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TMGI (ranap_TMGI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_TMGI_serviceID (&pvalue->serviceID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_TMGI (OSCTXT *pctxt, ranap_TMGI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_MBMS_PTP_RAB_ID (OSCTXT* pctxt, ranap_MBMS_PTP_RAB_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-PTP-RAB-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMS_PTP_RAB_ID (OSCTXT* pctxt, ranap_MBMS_PTP_RAB_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMS-PTP-RAB-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMS_PTP_RAB_ID (ranap_MBMS_PTP_RAB_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_CauseRadioNetwork (OSCTXT* pctxt, ranap_CauseRadioNetwork value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetwork");

   if ( (value >= 1 && value <= 64) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 64);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseRadioNetwork (OSCTXT* pctxt, ranap_CauseRadioNetwork* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetwork");

   stat = pd_ConsUInt8 (pctxt, pvalue, 1, 64);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseTransmissionNetwork (OSCTXT* pctxt, ranap_CauseTransmissionNetwork value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseTransmissionNetwork");

   if ( (value >= 65 && value <= 80) ) {
      stat = pe_ConsUnsigned (pctxt, value, 65, 80);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseTransmissionNetwork (OSCTXT* pctxt, ranap_CauseTransmissionNetwork* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseTransmissionNetwork");

   stat = pd_ConsUInt8 (pctxt, pvalue, 65, 80);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseNAS (OSCTXT* pctxt, ranap_CauseNAS value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseNAS");

   if ( (value >= 81 && value <= 96) ) {
      stat = pe_ConsUnsigned (pctxt, value, 81, 96);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseNAS (OSCTXT* pctxt, ranap_CauseNAS* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseNAS");

   stat = pd_ConsUInt8 (pctxt, pvalue, 81, 96);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseProtocol (OSCTXT* pctxt, ranap_CauseProtocol value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   if ( (value >= 97 && value <= 112) ) {
      stat = pe_ConsUnsigned (pctxt, value, 97, 112);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseProtocol (OSCTXT* pctxt, ranap_CauseProtocol* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseProtocol");

   stat = pd_ConsUInt8 (pctxt, pvalue, 97, 112);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseMisc (OSCTXT* pctxt, ranap_CauseMisc value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   if ( (value >= 113 && value <= 128) ) {
      stat = pe_ConsUnsigned (pctxt, value, 113, 128);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseMisc (OSCTXT* pctxt, ranap_CauseMisc* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseMisc");

   stat = pd_ConsUInt8 (pctxt, pvalue, 113, 128);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseNon_Standard (OSCTXT* pctxt, ranap_CauseNon_Standard value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseNon-Standard");

   if ( (value >= 129 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, 129, 256);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseNon_Standard (OSCTXT* pctxt, ranap_CauseNon_Standard* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseNon-Standard");

   stat = pd_ConsUInt16 (pctxt, pvalue, 129, 256);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CauseRadioNetworkExtension (OSCTXT* pctxt, ranap_CauseRadioNetworkExtension value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetworkExtension");

   if ( (value >= 257 && value <= 512) ) {
      stat = pe_ConsUnsigned (pctxt, value, 257, 512);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CauseRadioNetworkExtension (OSCTXT* pctxt, ranap_CauseRadioNetworkExtension* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CauseRadioNetworkExtension");

   stat = pd_ConsUInt16 (pctxt, pvalue, 257, 512);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Cause (OSCTXT* pctxt, ranap_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 6);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* radioNetwork */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "radioNetwork");

            stat = asn1PE_ranap_CauseRadioNetwork (pctxt, pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* transmissionNetwork */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "transmissionNetwork");

            stat = asn1PE_ranap_CauseTransmissionNetwork (pctxt, pvalue->u.transmissionNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* nAS */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "nAS");

            stat = asn1PE_ranap_CauseNAS (pctxt, pvalue->u.nAS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* protocol */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "protocol");

            stat = asn1PE_ranap_CauseProtocol (pctxt, pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* misc */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "misc");

            stat = asn1PE_ranap_CauseMisc (pctxt, pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* non_Standard */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "non-Standard");

            stat = asn1PE_ranap_CauseNon_Standard (pctxt, pvalue->u.non_Standard);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 7);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* radioNetworkExtension */
         case 7:
            stat = asn1PE_ranap_CauseRadioNetworkExtension (pctxt, pvalue->u.radioNetworkExtension);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Cause (OSCTXT* pctxt, ranap_Cause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "Cause");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* radioNetwork */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "radioNetwork");

            stat = asn1PD_ranap_CauseRadioNetwork (pctxt, &pvalue->u.radioNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* transmissionNetwork */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "transmissionNetwork");

            stat = asn1PD_ranap_CauseTransmissionNetwork (pctxt, &pvalue->u.transmissionNetwork);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* nAS */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "nAS");

            stat = asn1PD_ranap_CauseNAS (pctxt, &pvalue->u.nAS);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* protocol */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "protocol");

            stat = asn1PD_ranap_CauseProtocol (pctxt, &pvalue->u.protocol);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* misc */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "misc");

            stat = asn1PD_ranap_CauseMisc (pctxt, &pvalue->u.misc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* non_Standard */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "non-Standard");

            stat = asn1PD_ranap_CauseNon_Standard (pctxt, &pvalue->u.non_Standard);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 7;

      if (pvalue->t < 7) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 8) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* radioNetworkExtension */
         case 7:
            RTXCTXTPUSHELEMNAME (pctxt, "radioNetworkExtension");

            stat = asn1PD_ranap_CauseRadioNetworkExtension (pctxt, &pvalue->u.radioNetworkExtension);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 8) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Cause (ranap_Cause* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_Cause (OSCTXT *pctxt, ranap_Cause* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_DL_N_PDU_SequenceNumber (OSCTXT* pctxt, ranap_DL_N_PDU_SequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-N-PDU-SequenceNumber");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DL_N_PDU_SequenceNumber (OSCTXT* pctxt, ranap_DL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DL-N-PDU-SequenceNumber");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UL_N_PDU_SequenceNumber (OSCTXT* pctxt, ranap_UL_N_PDU_SequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-N-PDU-SequenceNumber");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UL_N_PDU_SequenceNumber (OSCTXT* pctxt, ranap_UL_N_PDU_SequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UL-N-PDU-SequenceNumber");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_IuSignallingConnectionIdentifier (OSCTXT* pctxt, ranap_IuSignallingConnectionIdentifier value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IuSignallingConnectionIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(24), OSUINTCONST(24), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(24), OSUINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IuSignallingConnectionIdentifier (OSCTXT* pctxt, ranap_IuSignallingConnectionIdentifier* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IuSignallingConnectionIdentifier");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(24), OSUINTCONST(24), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(24), OSUINTCONST(24));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IuSignallingConnectionIdentifier (
   ranap_IuSignallingConnectionIdentifier* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Ass_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-MaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PE_ranap_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Ass_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-MaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PD_ranap_MaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Ass_RAB_Parameter_MaxBitrateList (
   ranap_Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-GuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PE_ranap_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-GuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PD_ranap_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (
   ranap_Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Ass_RAB_Parameters (OSCTXT* pctxt, ranap_Ass_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.assMaxBitrateInfPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.assGuaranteedBitRateInfPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode assMaxBitrateInf */

   if (pvalue->m.assMaxBitrateInfPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "assMaxBitrateInf");

      stat = asn1PE_ranap_Ass_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->assMaxBitrateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode assGuaranteedBitRateInf */

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "assGuaranteedBitRateInf");

      stat = asn1PE_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->assGuaranteedBitRateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Ass_RAB_Parameters (OSCTXT* pctxt, ranap_Ass_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode assMaxBitrateInf */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "assMaxBitrateInf");

      pvalue->m.assMaxBitrateInfPresent = 1;

      stat = asn1PD_ranap_Ass_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->assMaxBitrateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode assGuaranteedBitRateInf */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "assGuaranteedBitRateInf");

      pvalue->m.assGuaranteedBitRateInfPresent = 1;

      stat = asn1PD_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->assGuaranteedBitRateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Ass_RAB_Parameters (ranap_Ass_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Ass_RAB_Parameter_MaxBitrateList (&pvalue->assMaxBitrateInf);
   asn1Init_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (&pvalue->assGuaranteedBitRateInf);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Ass_RAB_Parameters (OSCTXT *pctxt, 
   ranap_Ass_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GERAN_Classmark (OSCTXT* pctxt, ranap_GERAN_Classmark value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Classmark");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GERAN_Classmark (OSCTXT* pctxt, ranap_GERAN_Classmark* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Classmark");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GERAN_Classmark (ranap_GERAN_Classmark* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_GERAN_Classmark (OSCTXT *pctxt, 
   ranap_GERAN_Classmark* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_NAS_PDU (OSCTXT* pctxt, ranap_NAS_PDU value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-PDU");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NAS_PDU (OSCTXT* pctxt, ranap_NAS_PDU* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-PDU");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NAS_PDU (ranap_NAS_PDU* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_NAS_PDU (OSCTXT *pctxt, ranap_NAS_PDU* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

static const OSEnumItem ranap_SAPI_ENUMTAB[] = {
   { OSUTF8("sapi-0"), 0, 6, 0 },
   { OSUTF8("sapi-3"), 1, 6, 1 }
} ;
#define ranap_SAPI_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_SAPI_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_SAPI_ENUMTABSIZE) {
      return ranap_SAPI_ENUMTAB[ranap_SAPI_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_SAPI_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_SAPI* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_SAPI_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_SAPI_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_SAPI* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_SAPI_ENUMTAB, 
      ranap_SAPI_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_SAPI)ranap_SAPI_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_SAPI (OSCTXT* pctxt, ranap_SAPI value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SAPI");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SAPI (OSCTXT* pctxt, ranap_SAPI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SAPI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_CN_DomainIndicator_ENUMTAB[] = {
   { OSUTF8("cs-domain"), 0, 9, 0 },
   { OSUTF8("ps-domain"), 1, 9, 1 }
} ;
#define ranap_CN_DomainIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_CN_DomainIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_CN_DomainIndicator_ENUMTABSIZE) {
      return ranap_CN_DomainIndicator_ENUMTAB
         [ranap_CN_DomainIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_CN_DomainIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_CN_DomainIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_CN_DomainIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_CN_DomainIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_CN_DomainIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_CN_DomainIndicator_ENUMTAB, ranap_CN_DomainIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_CN_DomainIndicator)
         ranap_CN_DomainIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_CN_DomainIndicator (OSCTXT* pctxt, ranap_CN_DomainIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-DomainIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CN_DomainIndicator (OSCTXT* pctxt, ranap_CN_DomainIndicator* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-DomainIndicator");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTAB[] = {
   { OSUTF8("discrete-values"), 2, 15, 1 },
   { OSUTF8("unspecified"), 0, 11, 2 },
   { OSUTF8("value-range"), 1, 11, 0 }
} ;
#define ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Alt_RAB_Parameter_MaxBitrateType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTABSIZE) {
      return ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTAB
         [ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Alt_RAB_Parameter_MaxBitrateType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Alt_RAB_Parameter_MaxBitrateType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Alt_RAB_Parameter_MaxBitrateType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTAB, 
      ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Alt_RAB_Parameter_MaxBitrateType)
         ranap_Alt_RAB_Parameter_MaxBitrateType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateType (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateType");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateType (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PE_ranap_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PD_ranap_MaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_MaxBitrateList (
   ranap_Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_MaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-MaxBitrateList", xx1);

      stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateList (pctxt, ((ranap_Alt_RAB_Parameter_MaxBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_MaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_Alt_RAB_Parameter_MaxBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-MaxBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_Alt_RAB_Parameter_MaxBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_Alt_RAB_Parameter_MaxBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_MaxBitrates (
   ranap_Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_MaxBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_Alt_RAB_Parameter_MaxBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_Alt_RAB_Parameter_MaxBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altMaxBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altMaxBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, pvalue->altMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altMaxBitrates */

   if (pvalue->m.altMaxBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-MaxBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altMaxBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, &pvalue->altMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altMaxBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrates");

      pvalue->m.altMaxBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_MaxBitrateInf (
   ranap_Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_MaxBitrates (&pvalue->altMaxBitrates);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_MaxBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altMaxBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_MaxBitrates (pctxt, &pvalue->altMaxBitrates);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTAB[] = {
   { OSUTF8("discrete-values"), 2, 15, 1 },
   { OSUTF8("unspecified"), 0, 11, 2 },
   { OSUTF8("value-range"), 1, 11, 0 }
} ;
#define ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTABSIZE) {
      return ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTAB
         [ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ranap_Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTAB, 
      ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Alt_RAB_Parameter_GuaranteedBitrateType)
         ranap_Alt_RAB_Parameter_GuaranteedBitrateType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateType");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PE_ranap_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PD_ranap_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (
   ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateList", xx1);

      stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (pctxt, ((ranap_Alt_RAB_Parameter_GuaranteedBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrates (
   ranap_Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_GuaranteedBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_Alt_RAB_Parameter_GuaranteedBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altGuaranteedBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altGuaranteedBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, pvalue->altGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altGuaranteedBitrates */

   if (pvalue->m.altGuaranteedBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-GuaranteedBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altGuaranteedBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, &pvalue->altGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altGuaranteedBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitrates");

      pvalue->m.altGuaranteedBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (
   ranap_Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrates (&pvalue->altGuaranteedBitrates);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altGuaranteedBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_GuaranteedBitrates (pctxt, &pvalue->altGuaranteedBitrates);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameters (OSCTXT* pctxt, ranap_Alt_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altMaxBitrateInfPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altGuaranteedBitRateInfPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altMaxBitrateInf */

   if (pvalue->m.altMaxBitrateInfPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrateInf");

      stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode altGuaranteedBitRateInf */

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitRateInf");

      stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameters (OSCTXT* pctxt, ranap_Alt_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altMaxBitrateInf */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altMaxBitrateInf");

      pvalue->m.altMaxBitrateInfPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode altGuaranteedBitRateInf */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altGuaranteedBitRateInf");

      pvalue->m.altGuaranteedBitRateInfPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameters (ranap_Alt_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_MaxBitrateInf (&pvalue->altMaxBitrateInf);
   asn1Init_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (&pvalue->altGuaranteedBitRateInf);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameters (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altMaxBitrateInfPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_MaxBitrateInf (pctxt, &pvalue->altMaxBitrateInf);
   }
   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (pctxt, &pvalue->altGuaranteedBitRateInf);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Requested_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-MaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PE_ranap_MaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Requested_RAB_Parameter_MaxBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-MaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MaxBitrate", xx1);

      stat = asn1PD_ranap_MaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Requested_RAB_Parameter_MaxBitrateList (
   ranap_Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-GuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PE_ranap_GuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-GuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GuaranteedBitrate", xx1);

      stat = asn1PD_ranap_GuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (
   ranap_Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Requested_RAB_Parameter_Values (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_Values* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-Values");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestedMaxBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestedGuaranteedBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode requestedMaxBitrates */

   if (pvalue->m.requestedMaxBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedMaxBitrates");

      stat = asn1PE_ranap_Requested_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->requestedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode requestedGuaranteedBitrates */

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedGuaranteedBitrates");

      stat = asn1PE_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->requestedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Requested_RAB_Parameter_Values (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_Values* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-Values");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode requestedMaxBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedMaxBitrates");

      pvalue->m.requestedMaxBitratesPresent = 1;

      stat = asn1PD_ranap_Requested_RAB_Parameter_MaxBitrateList (pctxt, &pvalue->requestedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode requestedGuaranteedBitrates */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedGuaranteedBitrates");

      pvalue->m.requestedGuaranteedBitratesPresent = 1;

      stat = asn1PD_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (pctxt, &pvalue->requestedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Requested_RAB_Parameter_Values (
   ranap_Requested_RAB_Parameter_Values* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Requested_RAB_Parameter_MaxBitrateList (&pvalue->requestedMaxBitrates);
   asn1Init_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (&pvalue->requestedGuaranteedBitrates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Requested_RAB_Parameter_Values (OSCTXT *pctxt, 
   ranap_Requested_RAB_Parameter_Values* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

static const OSEnumItem ranap_MBMSHCIndicator_ENUMTAB[] = {
   { OSUTF8("compressed-header"), 1, 17, 1 },
   { OSUTF8("uncompressed-header"), 0, 19, 0 }
} ;
#define ranap_MBMSHCIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_MBMSHCIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MBMSHCIndicator_ENUMTABSIZE) {
      return ranap_MBMSHCIndicator_ENUMTAB
         [ranap_MBMSHCIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSHCIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSHCIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSHCIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSHCIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_MBMSHCIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSHCIndicator_ENUMTAB, ranap_MBMSHCIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSHCIndicator)
         ranap_MBMSHCIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSHCIndicator (OSCTXT* pctxt, ranap_MBMSHCIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSHCIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSHCIndicator (OSCTXT* pctxt, ranap_MBMSHCIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSHCIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_IPMulticastAddress (OSCTXT* pctxt, ranap_IPMulticastAddress* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IPMulticastAddress");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(16), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IPMulticastAddress (OSCTXT* pctxt, ranap_IPMulticastAddress* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IPMulticastAddress");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(16), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IPMulticastAddress (ranap_IPMulticastAddress* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_AccuracyFulfilmentIndicator_ENUMTAB[] = {
   { OSUTF8("requested-Accuracy-Fulfilled"), 0, 28, 0 },
   { OSUTF8("requested-Accuracy-Not-Fulfilled"), 1, 32, 1 }
} ;
#define ranap_AccuracyFulfilmentIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_AccuracyFulfilmentIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_AccuracyFulfilmentIndicator_ENUMTABSIZE) {
      return ranap_AccuracyFulfilmentIndicator_ENUMTAB
         [ranap_AccuracyFulfilmentIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_AccuracyFulfilmentIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_AccuracyFulfilmentIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_AccuracyFulfilmentIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_AccuracyFulfilmentIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_AccuracyFulfilmentIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_AccuracyFulfilmentIndicator_ENUMTAB, 
      ranap_AccuracyFulfilmentIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_AccuracyFulfilmentIndicator)
         ranap_AccuracyFulfilmentIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_AccuracyFulfilmentIndicator (OSCTXT* pctxt, ranap_AccuracyFulfilmentIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AccuracyFulfilmentIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AccuracyFulfilmentIndicator (OSCTXT* pctxt, ranap_AccuracyFulfilmentIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AccuracyFulfilmentIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Additional_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_Additional_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Additional_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_Additional_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Additional_PositioningMethodAndUsage (
   ranap_Additional_PositioningMethodAndUsage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_AlternativeRABConfigurationRequest_ENUMTAB[] = {
   { OSUTF8("alternative-RAB-configuration-Requested"), 0, 39, 0 }
} ;
#define ranap_AlternativeRABConfigurationRequest_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_AlternativeRABConfigurationRequest_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_AlternativeRABConfigurationRequest_ENUMTAB, 
      ranap_AlternativeRABConfigurationRequest_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_AlternativeRABConfigurationRequest_ENUMTABSIZE) {
      return ranap_AlternativeRABConfigurationRequest_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_AlternativeRABConfigurationRequest_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_AlternativeRABConfigurationRequest* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_AlternativeRABConfigurationRequest_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_AlternativeRABConfigurationRequest_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_AlternativeRABConfigurationRequest* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_AlternativeRABConfigurationRequest_ENUMTAB, 
      ranap_AlternativeRABConfigurationRequest_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_AlternativeRABConfigurationRequest)
         ranap_AlternativeRABConfigurationRequest_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_AlternativeRABConfigurationRequest (OSCTXT* pctxt, ranap_AlternativeRABConfigurationRequest value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "AlternativeRABConfigurationRequest");

   switch (value) {
      case ranap_alternative_RAB_configuration_Requested: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AlternativeRABConfigurationRequest (OSCTXT* pctxt, ranap_AlternativeRABConfigurationRequest* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AlternativeRABConfigurationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_alternative_RAB_configuration_Requested; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_APN (OSCTXT* pctxt, ranap_APN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "APN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_APN (OSCTXT* pctxt, ranap_APN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "APN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_APN (ranap_APN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_BarometricPressure (OSCTXT* pctxt, ranap_BarometricPressure value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BarometricPressure");

   if ( (value >= 30000 && value <= 115000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 30000, 115000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_BarometricPressure (OSCTXT* pctxt, ranap_BarometricPressure* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BarometricPressure");

   stat = pd_ConsUnsigned (pctxt, pvalue, 30000, 115000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Cell_Access_Mode_ENUMTAB[] = {
   { OSUTF8("hybrid"), 0, 6, 0 }
} ;
#define ranap_Cell_Access_Mode_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_Cell_Access_Mode_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ranap_Cell_Access_Mode_ENUMTAB, 
      ranap_Cell_Access_Mode_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_Cell_Access_Mode_ENUMTABSIZE) {
      return ranap_Cell_Access_Mode_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Cell_Access_Mode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Cell_Access_Mode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Cell_Access_Mode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Cell_Access_Mode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Cell_Access_Mode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Cell_Access_Mode_ENUMTAB, ranap_Cell_Access_Mode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Cell_Access_Mode)
         ranap_Cell_Access_Mode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Cell_Access_Mode (OSCTXT* pctxt, ranap_Cell_Access_Mode value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Access-Mode");

   switch (value) {
      case ranap_hybrid: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Cell_Access_Mode (OSCTXT* pctxt, ranap_Cell_Access_Mode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Access-Mode");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_hybrid; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Cell_Id (OSCTXT* pctxt, ranap_Cell_Id value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Id");

   if ( value <= 268435455 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 268435455);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Cell_Id (OSCTXT* pctxt, ranap_Cell_Id* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Id");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 268435455);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Cell_Capacity_Class_Value (OSCTXT* pctxt, ranap_Cell_Capacity_Class_Value value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Capacity-Class-Value");

   if ( (value >= 1 && value <= 100) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 1, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Cell_Capacity_Class_Value (OSCTXT* pctxt, ranap_Cell_Capacity_Class_Value* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Cell-Capacity-Class-Value");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_CellType_ENUMTAB[] = {
   { OSUTF8("femto"), 3, 5, 1 },
   { OSUTF8("macro"), 0, 5, 2 },
   { OSUTF8("micro"), 1, 5, 3 },
   { OSUTF8("pico"), 2, 4, 0 }
} ;
#define ranap_CellType_ENUMTABSIZE 4

const OSUTF8CHAR* ranap_CellType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_CellType_ENUMTABSIZE) {
      return ranap_CellType_ENUMTAB
         [ranap_CellType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_CellType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_CellType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_CellType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_CellType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_CellType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_CellType_ENUMTAB, 
      ranap_CellType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_CellType)ranap_CellType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_CellType (OSCTXT* pctxt, ranap_CellType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellType");

   if (value >= 4) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CellType (OSCTXT* pctxt, ranap_CellType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CivicAddress (OSCTXT* pctxt, ranap_CivicAddress value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CivicAddress");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CivicAddress (OSCTXT* pctxt, ranap_CivicAddress* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CivicAddress");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CivicAddress (ranap_CivicAddress* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_CivicAddress (OSCTXT *pctxt, ranap_CivicAddress* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

static const OSEnumItem ranap_ClientType_ENUMTAB[] = {
   { OSUTF8("emergency-Services"), 0, 18, 0 },
   { OSUTF8("lawful-Intercept-Services"), 3, 25, 7 },
   { OSUTF8("pLMN-Operator-Anonymous-Statistics"), 6, 34, 5 },
   { OSUTF8("pLMN-Operator-Broadcast-Services"), 4, 32, 1 },
   { OSUTF8("pLMN-Operator-O-et-M"), 5, 20, 3 },
   { OSUTF8("pLMN-Operator-Services"), 2, 22, 4 },
   { OSUTF8("pLMN-Operator-Target-MS-Service-Support"), 7, 39, 2 },
   { OSUTF8("value-Added-Services"), 1, 20, 6 }
} ;
#define ranap_ClientType_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_ClientType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_ClientType_ENUMTABSIZE) {
      return ranap_ClientType_ENUMTAB
         [ranap_ClientType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ClientType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ClientType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ClientType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ClientType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ClientType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_ClientType_ENUMTAB, 
      ranap_ClientType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ClientType)ranap_ClientType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ClientType (OSCTXT* pctxt, ranap_ClientType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClientType");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ClientType (OSCTXT* pctxt, ranap_ClientType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ClientType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_EncryptionAlgorithm (OSCTXT* pctxt, ranap_EncryptionAlgorithm value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionAlgorithm");

   if ( value <= 15 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EncryptionAlgorithm (OSCTXT* pctxt, ranap_EncryptionAlgorithm* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionAlgorithm");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ChosenEncryptionAlgorithm (OSCTXT* pctxt, ranap_ChosenEncryptionAlgorithm value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ChosenEncryptionAlgorithm");

   stat = asn1PE_ranap_EncryptionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ChosenEncryptionAlgorithm (OSCTXT* pctxt, ranap_ChosenEncryptionAlgorithm* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ChosenEncryptionAlgorithm");

   stat = asn1PD_ranap_EncryptionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_IntegrityProtectionAlgorithm (OSCTXT* pctxt, ranap_IntegrityProtectionAlgorithm value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionAlgorithm");

   if ( value <= 15 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IntegrityProtectionAlgorithm (OSCTXT* pctxt, ranap_IntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionAlgorithm");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ChosenIntegrityProtectionAlgorithm (OSCTXT* pctxt, ranap_ChosenIntegrityProtectionAlgorithm value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ChosenIntegrityProtectionAlgorithm");

   stat = asn1PE_ranap_IntegrityProtectionAlgorithm (pctxt, value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ChosenIntegrityProtectionAlgorithm (OSCTXT* pctxt, ranap_ChosenIntegrityProtectionAlgorithm* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ChosenIntegrityProtectionAlgorithm");

   stat = asn1PD_ranap_IntegrityProtectionAlgorithm (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CI (OSCTXT* pctxt, ranap_CI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CI (OSCTXT* pctxt, ranap_CI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CI (ranap_CI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_ClassmarkInformation2 (OSCTXT* pctxt, ranap_ClassmarkInformation2 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassmarkInformation2");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ClassmarkInformation2 (OSCTXT* pctxt, ranap_ClassmarkInformation2* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassmarkInformation2");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ClassmarkInformation2 (ranap_ClassmarkInformation2* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_ClassmarkInformation2 (OSCTXT *pctxt, 
   ranap_ClassmarkInformation2* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_ClassmarkInformation3 (OSCTXT* pctxt, ranap_ClassmarkInformation3 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassmarkInformation3");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ClassmarkInformation3 (OSCTXT* pctxt, ranap_ClassmarkInformation3* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassmarkInformation3");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ClassmarkInformation3 (ranap_ClassmarkInformation3* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_ClassmarkInformation3 (OSCTXT *pctxt, 
   ranap_ClassmarkInformation3* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_CN_ID (OSCTXT* pctxt, ranap_CN_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-ID");

   if ( value <= 4095 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CN_ID (OSCTXT* pctxt, ranap_CN_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-ID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 4095);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Correlation_ID (OSCTXT* pctxt, ranap_Correlation_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Correlation-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Correlation_ID (OSCTXT* pctxt, ranap_Correlation_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Correlation-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Correlation_ID (ranap_Correlation_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_CSFB_Information_ENUMTAB[] = {
   { OSUTF8("csfb"), 0, 4, 0 },
   { OSUTF8("csfb-high-priority"), 1, 18, 1 }
} ;
#define ranap_CSFB_Information_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_CSFB_Information_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_CSFB_Information_ENUMTABSIZE) {
      return ranap_CSFB_Information_ENUMTAB
         [ranap_CSFB_Information_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_CSFB_Information_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_CSFB_Information* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_CSFB_Information_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_CSFB_Information_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_CSFB_Information* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_CSFB_Information_ENUMTAB, ranap_CSFB_Information_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_CSFB_Information)
         ranap_CSFB_Information_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_CSFB_Information (OSCTXT* pctxt, ranap_CSFB_Information value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-Information");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CSFB_Information (OSCTXT* pctxt, ranap_CSFB_Information* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CSFB-Information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_CSG_Id (OSCTXT* pctxt, ranap_CSG_Id value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Id");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(27), OSUINTCONST(27), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(27), OSUINTCONST(27));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CSG_Id (OSCTXT* pctxt, ranap_CSG_Id* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Id");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(27), OSUINTCONST(27), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(27), OSUINTCONST(27));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CSG_Id (ranap_CSG_Id* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_CSG_Membership_Status_ENUMTAB[] = {
   { OSUTF8("member"), 0, 6, 0 },
   { OSUTF8("non-member"), 1, 10, 1 }
} ;
#define ranap_CSG_Membership_Status_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_CSG_Membership_Status_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_CSG_Membership_Status_ENUMTABSIZE) {
      return ranap_CSG_Membership_Status_ENUMTAB
         [ranap_CSG_Membership_Status_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_CSG_Membership_Status_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_CSG_Membership_Status* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_CSG_Membership_Status_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_CSG_Membership_Status_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_CSG_Membership_Status* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_CSG_Membership_Status_ENUMTAB, 
      ranap_CSG_Membership_Status_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_CSG_Membership_Status)
         ranap_CSG_Membership_Status_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_CSG_Membership_Status (OSCTXT* pctxt, ranap_CSG_Membership_Status value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Membership-Status");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CSG_Membership_Status (OSCTXT* pctxt, ranap_CSG_Membership_Status* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Membership-Status");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_DataPDUType_ENUMTAB[] = {
   { OSUTF8("pDUtype0"), 0, 8, 0 },
   { OSUTF8("pDUtype1"), 1, 8, 1 }
} ;
#define ranap_DataPDUType_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_DataPDUType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_DataPDUType_ENUMTABSIZE) {
      return ranap_DataPDUType_ENUMTAB
         [ranap_DataPDUType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_DataPDUType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_DataPDUType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_DataPDUType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_DataPDUType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_DataPDUType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_DataPDUType_ENUMTAB, 
      ranap_DataPDUType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_DataPDUType)ranap_DataPDUType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_DataPDUType (OSCTXT* pctxt, ranap_DataPDUType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataPDUType");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataPDUType (OSCTXT* pctxt, ranap_DataPDUType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DataPDUType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_DCH_ID (OSCTXT* pctxt, ranap_DCH_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DCH-ID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DCH_ID (OSCTXT* pctxt, ranap_DCH_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DCH-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ForwardingIndication_ENUMTAB[] = {
   { OSUTF8("forwarding-admitted"), 0, 19, 0 }
} ;
#define ranap_ForwardingIndication_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_ForwardingIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_ForwardingIndication_ENUMTAB, 
      ranap_ForwardingIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_ForwardingIndication_ENUMTABSIZE) {
      return ranap_ForwardingIndication_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ForwardingIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ForwardingIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ForwardingIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ForwardingIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_ForwardingIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_ForwardingIndication_ENUMTAB, 
      ranap_ForwardingIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ForwardingIndication)
         ranap_ForwardingIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ForwardingIndication (OSCTXT* pctxt, ranap_ForwardingIndication value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ForwardingIndication");

   switch (value) {
      case ranap_forwarding_admitted: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ForwardingIndication (OSCTXT* pctxt, ranap_ForwardingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ForwardingIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_forwarding_admitted; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_D_RNTI (OSCTXT* pctxt, ranap_D_RNTI value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "D-RNTI");

   if ( value <= 1048575 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 1048575);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_D_RNTI (OSCTXT* pctxt, ranap_D_RNTI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "D-RNTI");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1048575);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_DRX_CycleLengthCoefficient (OSCTXT* pctxt, ranap_DRX_CycleLengthCoefficient value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRX-CycleLengthCoefficient");

   if ( (value >= 6 && value <= 9) ) {
      stat = pe_ConsUnsigned (pctxt, value, 6, 9);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DRX_CycleLengthCoefficient (OSCTXT* pctxt, ranap_DRX_CycleLengthCoefficient* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DRX-CycleLengthCoefficient");

   stat = pd_ConsUInt8 (pctxt, pvalue, 6, 9);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_DSCH_ID (OSCTXT* pctxt, ranap_DSCH_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-ID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DSCH_ID (OSCTXT* pctxt, ranap_DSCH_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DSCH-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_EARFCN_Extended (OSCTXT* pctxt, ranap_EARFCN_Extended value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EARFCN-Extended");

   if ( (value >= 65536 && value <= 262143) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 65536, 262143);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EARFCN_Extended (OSCTXT* pctxt, ranap_EARFCN_Extended* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EARFCN-Extended");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 65536, 262143);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_E_DCH_MAC_d_Flow_ID (OSCTXT* pctxt, ranap_E_DCH_MAC_d_Flow_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-Flow-ID");

   if ( value <= 7 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 7);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_E_DCH_MAC_d_Flow_ID (OSCTXT* pctxt, ranap_E_DCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "E-DCH-MAC-d-Flow-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_EncryptionKey (OSCTXT* pctxt, ranap_EncryptionKey* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionKey");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EncryptionKey (OSCTXT* pctxt, ranap_EncryptionKey* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionKey");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EncryptionKey (ranap_EncryptionKey* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_End_Of_CSFB_ENUMTAB[] = {
   { OSUTF8("end-of-CSFB"), 0, 11, 0 }
} ;
#define ranap_End_Of_CSFB_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_End_Of_CSFB_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ranap_End_Of_CSFB_ENUMTAB, 
      ranap_End_Of_CSFB_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_End_Of_CSFB_ENUMTABSIZE) {
      return ranap_End_Of_CSFB_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_End_Of_CSFB_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_End_Of_CSFB* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_End_Of_CSFB_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_End_Of_CSFB_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_End_Of_CSFB* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_End_Of_CSFB_ENUMTAB, 
      ranap_End_Of_CSFB_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_End_Of_CSFB)ranap_End_Of_CSFB_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_End_Of_CSFB (OSCTXT* pctxt, ranap_End_Of_CSFB value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "End-Of-CSFB");

   switch (value) {
      case ranap_end_of_CSFB: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_End_Of_CSFB (OSCTXT* pctxt, ranap_End_Of_CSFB* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "End-Of-CSFB");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_end_of_CSFB; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_E_UTRAN_Service_Handover_ENUMTAB[] = {
   { OSUTF8("handover-to-E-UTRAN-shall-not-be-performed"), 0, 42, 0 }
} ;
#define ranap_E_UTRAN_Service_Handover_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_E_UTRAN_Service_Handover_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_E_UTRAN_Service_Handover_ENUMTAB, 
      ranap_E_UTRAN_Service_Handover_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_E_UTRAN_Service_Handover_ENUMTABSIZE) {
      return ranap_E_UTRAN_Service_Handover_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_E_UTRAN_Service_Handover_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_E_UTRAN_Service_Handover* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_E_UTRAN_Service_Handover_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_E_UTRAN_Service_Handover_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_E_UTRAN_Service_Handover* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_E_UTRAN_Service_Handover_ENUMTAB, 
      ranap_E_UTRAN_Service_Handover_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_E_UTRAN_Service_Handover)
         ranap_E_UTRAN_Service_Handover_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_E_UTRAN_Service_Handover (OSCTXT* pctxt, ranap_E_UTRAN_Service_Handover value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "E-UTRAN-Service-Handover");

   switch (value) {
      case ranap_handover_to_E_UTRAN_shall_not_be_performed: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_E_UTRAN_Service_Handover (OSCTXT* pctxt, ranap_E_UTRAN_Service_Handover* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "E-UTRAN-Service-Handover");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_handover_to_E_UTRAN_shall_not_be_performed; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Event_ENUMTAB[] = {
   { OSUTF8("change-of-servicearea"), 2, 21, 3 },
   { OSUTF8("direct"), 1, 6, 1 },
   { OSUTF8("periodic"), 4, 8, 0 },
   { OSUTF8("stop-change-of-service-area"), 0, 27, 4 },
   { OSUTF8("stop-direct"), 3, 11, 2 },
   { OSUTF8("stop-periodic"), 5, 13, 5 }
} ;
#define ranap_Event_ENUMTABSIZE 6

const OSUTF8CHAR* ranap_Event_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Event_ENUMTABSIZE) {
      return ranap_Event_ENUMTAB[ranap_Event_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Event_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Event* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Event_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Event_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Event* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_Event_ENUMTAB, 
      ranap_Event_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Event)ranap_Event_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Event (OSCTXT* pctxt, ranap_Event value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(2));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 3);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Event (OSCTXT* pctxt, ranap_Event* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_stop_direct; break;
         case 1: *pvalue = ranap_periodic; break;
         case 2: *pvalue = ranap_stop_periodic; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ExtendedGuaranteedBitrate (OSCTXT* pctxt, ranap_ExtendedGuaranteedBitrate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedGuaranteedBitrate");

   if ( (value >= 16000001 && value <= 256000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 16000001, 256000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ExtendedGuaranteedBitrate (OSCTXT* pctxt, ranap_ExtendedGuaranteedBitrate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedGuaranteedBitrate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 16000001, 256000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ExtendedMaxBitrate (OSCTXT* pctxt, ranap_ExtendedMaxBitrate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedMaxBitrate");

   if ( (value >= 16000001 && value <= 256000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 16000001, 256000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ExtendedMaxBitrate (OSCTXT* pctxt, ranap_ExtendedMaxBitrate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedMaxBitrate");

   stat = pd_ConsUnsigned (pctxt, pvalue, 16000001, 256000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_ExtendedRNC_ID (OSCTXT* pctxt, ranap_ExtendedRNC_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedRNC-ID");

   if ( value >= 4096 ) {
      stat = pe_ConsUnsigned (pctxt, value, 4096, 65535);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ExtendedRNC_ID (OSCTXT* pctxt, ranap_ExtendedRNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedRNC-ID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 4096, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_FrameSequenceNumber (OSCTXT* pctxt, ranap_FrameSequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FrameSequenceNumber");

   if ( value <= 15 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 15);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_FrameSequenceNumber (OSCTXT* pctxt, ranap_FrameSequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FrameSequenceNumber");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 15);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_FrequenceLayerConvergenceFlag_ENUMTAB[] = {
   { OSUTF8("no-FLC-flag"), 0, 11, 0 }
} ;
#define ranap_FrequenceLayerConvergenceFlag_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_FrequenceLayerConvergenceFlag_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_FrequenceLayerConvergenceFlag_ENUMTAB, 
      ranap_FrequenceLayerConvergenceFlag_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_FrequenceLayerConvergenceFlag_ENUMTABSIZE) {
      return ranap_FrequenceLayerConvergenceFlag_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_FrequenceLayerConvergenceFlag_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_FrequenceLayerConvergenceFlag* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_FrequenceLayerConvergenceFlag_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_FrequenceLayerConvergenceFlag_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_FrequenceLayerConvergenceFlag* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_FrequenceLayerConvergenceFlag_ENUMTAB, 
      ranap_FrequenceLayerConvergenceFlag_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_FrequenceLayerConvergenceFlag)
         ranap_FrequenceLayerConvergenceFlag_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_FrequenceLayerConvergenceFlag (OSCTXT* pctxt, ranap_FrequenceLayerConvergenceFlag value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "FrequenceLayerConvergenceFlag");

   switch (value) {
      case ranap_no_FLC_flag: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_FrequenceLayerConvergenceFlag (OSCTXT* pctxt, ranap_FrequenceLayerConvergenceFlag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "FrequenceLayerConvergenceFlag");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_no_FLC_flag; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_GANSS_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_GANSS_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GANSS-PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GANSS_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_GANSS_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GANSS-PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GANSS_PositioningMethodAndUsage (
   ranap_GANSS_PositioningMethodAndUsage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_GERAN_BSC_Container (OSCTXT* pctxt, ranap_GERAN_BSC_Container value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-BSC-Container");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GERAN_BSC_Container (OSCTXT* pctxt, ranap_GERAN_BSC_Container* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-BSC-Container");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GERAN_BSC_Container (ranap_GERAN_BSC_Container* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_GERAN_BSC_Container (OSCTXT *pctxt, 
   ranap_GERAN_BSC_Container* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

static const OSEnumItem ranap_HigherBitratesThan16MbpsFlag_ENUMTAB[] = {
   { OSUTF8("allowed"), 0, 7, 0 },
   { OSUTF8("not-allowed"), 1, 11, 1 }
} ;
#define ranap_HigherBitratesThan16MbpsFlag_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_HigherBitratesThan16MbpsFlag_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_HigherBitratesThan16MbpsFlag_ENUMTABSIZE) {
      return ranap_HigherBitratesThan16MbpsFlag_ENUMTAB
         [ranap_HigherBitratesThan16MbpsFlag_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_HigherBitratesThan16MbpsFlag_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_HigherBitratesThan16MbpsFlag* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_HigherBitratesThan16MbpsFlag_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_HigherBitratesThan16MbpsFlag_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_HigherBitratesThan16MbpsFlag* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_HigherBitratesThan16MbpsFlag_ENUMTAB, 
      ranap_HigherBitratesThan16MbpsFlag_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_HigherBitratesThan16MbpsFlag)
         ranap_HigherBitratesThan16MbpsFlag_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_HigherBitratesThan16MbpsFlag (OSCTXT* pctxt, ranap_HigherBitratesThan16MbpsFlag value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HigherBitratesThan16MbpsFlag");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HigherBitratesThan16MbpsFlag (OSCTXT* pctxt, ranap_HigherBitratesThan16MbpsFlag* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HigherBitratesThan16MbpsFlag");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_HS_DSCH_MAC_d_Flow_ID (OSCTXT* pctxt, ranap_HS_DSCH_MAC_d_Flow_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-MAC-d-Flow-ID");

   if ( value <= 7 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 7);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HS_DSCH_MAC_d_Flow_ID (OSCTXT* pctxt, ranap_HS_DSCH_MAC_d_Flow_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HS-DSCH-MAC-d-Flow-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 7);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_IMEI (OSCTXT* pctxt, ranap_IMEI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEI (OSCTXT* pctxt, ranap_IMEI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEI (ranap_IMEI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IMEISV (OSCTXT* pctxt, ranap_IMEISV* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISV");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEISV (OSCTXT* pctxt, ranap_IMEISV* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISV");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEISV (ranap_IMEISV* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IMSI (OSCTXT* pctxt, ranap_IMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(8), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMSI (OSCTXT* pctxt, ranap_IMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(8), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMSI (ranap_IMSI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_IncludeVelocity_ENUMTAB[] = {
   { OSUTF8("requested"), 0, 9, 0 }
} ;
#define ranap_IncludeVelocity_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_IncludeVelocity_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ranap_IncludeVelocity_ENUMTAB, 
      ranap_IncludeVelocity_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_IncludeVelocity_ENUMTABSIZE) {
      return ranap_IncludeVelocity_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_IncludeVelocity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_IncludeVelocity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_IncludeVelocity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_IncludeVelocity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_IncludeVelocity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_IncludeVelocity_ENUMTAB, ranap_IncludeVelocity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_IncludeVelocity)
         ranap_IncludeVelocity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_IncludeVelocity (OSCTXT* pctxt, ranap_IncludeVelocity value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "IncludeVelocity");

   switch (value) {
      case ranap_requested: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IncludeVelocity (OSCTXT* pctxt, ranap_IncludeVelocity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "IncludeVelocity");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   switch (ui) {
      case 0: *pvalue = ranap_requested; break;
      default: return LOG_RTERR (pctxt, RTERR_INVENUM);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_InformationExchangeID (OSCTXT* pctxt, ranap_InformationExchangeID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationExchangeID");

   if ( value <= 1048575 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 1048575);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationExchangeID (OSCTXT* pctxt, ranap_InformationExchangeID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationExchangeID");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1048575);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_InformationExchangeType_ENUMTAB[] = {
   { OSUTF8("request"), 1, 7, 1 },
   { OSUTF8("transfer"), 0, 8, 0 }
} ;
#define ranap_InformationExchangeType_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_InformationExchangeType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_InformationExchangeType_ENUMTABSIZE) {
      return ranap_InformationExchangeType_ENUMTAB
         [ranap_InformationExchangeType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_InformationExchangeType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_InformationExchangeType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_InformationExchangeType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_InformationExchangeType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_InformationExchangeType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_InformationExchangeType_ENUMTAB, 
      ranap_InformationExchangeType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_InformationExchangeType)
         ranap_InformationExchangeType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_InformationExchangeType (OSCTXT* pctxt, ranap_InformationExchangeType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationExchangeType");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationExchangeType (OSCTXT* pctxt, ranap_InformationExchangeType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationExchangeType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_InformationTransferID (OSCTXT* pctxt, ranap_InformationTransferID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferID");

   if ( value <= 1048575 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 1048575);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationTransferID (OSCTXT* pctxt, ranap_InformationTransferID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferID");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1048575);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_IntegrityProtectionKey (OSCTXT* pctxt, ranap_IntegrityProtectionKey* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionKey");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IntegrityProtectionKey (OSCTXT* pctxt, ranap_IntegrityProtectionKey* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionKey");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IntegrityProtectionKey (
   ranap_IntegrityProtectionKey* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_KeyStatus_ENUMTAB[] = {
   { OSUTF8("new"), 1, 3, 1 },
   { OSUTF8("old"), 0, 3, 0 }
} ;
#define ranap_KeyStatus_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_KeyStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_KeyStatus_ENUMTABSIZE) {
      return ranap_KeyStatus_ENUMTAB
         [ranap_KeyStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_KeyStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_KeyStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_KeyStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_KeyStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_KeyStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_KeyStatus_ENUMTAB, 
      ranap_KeyStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_KeyStatus)ranap_KeyStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_KeyStatus (OSCTXT* pctxt, ranap_KeyStatus value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyStatus");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_KeyStatus (OSCTXT* pctxt, ranap_KeyStatus* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyStatus");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_LAC (OSCTXT* pctxt, ranap_LAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LAC (OSCTXT* pctxt, ranap_LAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LAC (ranap_LAC* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_LHN_ID (OSCTXT* pctxt, ranap_LHN_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LHN-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(256), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LHN_ID (OSCTXT* pctxt, ranap_LHN_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LHN-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(32), OSUINTCONST(256), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LHN_ID (ranap_LHN_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_Links_to_log_ENUMTAB[] = {
   { OSUTF8("both-uplink-and-downlink"), 2, 24, 2 },
   { OSUTF8("downlink"), 1, 8, 1 },
   { OSUTF8("uplink"), 0, 6, 0 }
} ;
#define ranap_Links_to_log_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_Links_to_log_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_Links_to_log_ENUMTABSIZE) {
      return ranap_Links_to_log_ENUMTAB
         [ranap_Links_to_log_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Links_to_log_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Links_to_log* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Links_to_log_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Links_to_log_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Links_to_log* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_Links_to_log_ENUMTAB, 
      ranap_Links_to_log_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Links_to_log)ranap_Links_to_log_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Links_to_log (OSCTXT* pctxt, ranap_Links_to_log value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Links-to-log");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Links_to_log (OSCTXT* pctxt, ranap_Links_to_log* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Links-to-log");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_LoadValue (OSCTXT* pctxt, ranap_LoadValue value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LoadValue");

   if ( value <= 100 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LoadValue (OSCTXT* pctxt, ranap_LoadValue* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LoadValue");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 100);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTAB[] = {
   { OSUTF8("decipheringKeysEOTD"), 0, 19, 0 },
   { OSUTF8("dedicatedMobileAssistedEOTDAssistanceData"), 1, 41, 1 },
   { OSUTF8("dedicatedMobileBasedEOTDAssistanceData"), 2, 38, 2 }
} ;
#define ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTABSIZE) {
      return ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTAB
         [ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTAB, 
      ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode)
         ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode (OSCTXT* pctxt, ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequestTypeSpecificToGERANIuMode");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode (OSCTXT* pctxt, ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequestTypeSpecificToGERANIuMode");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ReportChangeOfSAI_ENUMTAB[] = {
   { OSUTF8("requested"), 0, 9, 0 }
} ;
#define ranap_ReportChangeOfSAI_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_ReportChangeOfSAI_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ranap_ReportChangeOfSAI_ENUMTAB, 
      ranap_ReportChangeOfSAI_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_ReportChangeOfSAI_ENUMTABSIZE) {
      return ranap_ReportChangeOfSAI_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ReportChangeOfSAI_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ReportChangeOfSAI* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ReportChangeOfSAI_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ReportChangeOfSAI_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ReportChangeOfSAI* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_ReportChangeOfSAI_ENUMTAB, ranap_ReportChangeOfSAI_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ReportChangeOfSAI)
         ranap_ReportChangeOfSAI_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ReportChangeOfSAI (OSCTXT* pctxt, ranap_ReportChangeOfSAI value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportChangeOfSAI");

   switch (value) {
      case ranap_requested_1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ReportChangeOfSAI (OSCTXT* pctxt, ranap_ReportChangeOfSAI* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportChangeOfSAI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_requested_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_PeriodicReportingIndicator_ENUMTAB[] = {
   { OSUTF8("periodicGeo"), 1, 11, 1 },
   { OSUTF8("periodicSAI"), 0, 11, 0 }
} ;
#define ranap_PeriodicReportingIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_PeriodicReportingIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_PeriodicReportingIndicator_ENUMTABSIZE) {
      return ranap_PeriodicReportingIndicator_ENUMTAB
         [ranap_PeriodicReportingIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PeriodicReportingIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PeriodicReportingIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PeriodicReportingIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PeriodicReportingIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_PeriodicReportingIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_PeriodicReportingIndicator_ENUMTAB, 
      ranap_PeriodicReportingIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PeriodicReportingIndicator)
         ranap_PeriodicReportingIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PeriodicReportingIndicator (OSCTXT* pctxt, ranap_PeriodicReportingIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PeriodicReportingIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PeriodicReportingIndicator (OSCTXT* pctxt, ranap_PeriodicReportingIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PeriodicReportingIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_DirectReportingIndicator_ENUMTAB[] = {
   { OSUTF8("directGeo"), 1, 9, 1 },
   { OSUTF8("directSAI"), 0, 9, 0 }
} ;
#define ranap_DirectReportingIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_DirectReportingIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_DirectReportingIndicator_ENUMTABSIZE) {
      return ranap_DirectReportingIndicator_ENUMTAB
         [ranap_DirectReportingIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_DirectReportingIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_DirectReportingIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_DirectReportingIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_DirectReportingIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_DirectReportingIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_DirectReportingIndicator_ENUMTAB, 
      ranap_DirectReportingIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_DirectReportingIndicator)
         ranap_DirectReportingIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_DirectReportingIndicator (OSCTXT* pctxt, ranap_DirectReportingIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectReportingIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectReportingIndicator (OSCTXT* pctxt, ranap_DirectReportingIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectReportingIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_L3_Information (OSCTXT* pctxt, ranap_L3_Information value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "L3-Information");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_L3_Information (OSCTXT* pctxt, ranap_L3_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "L3-Information");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_L3_Information (ranap_L3_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_L3_Information (OSCTXT *pctxt, 
   ranap_L3_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

static const OSEnumItem ranap_M4_Period_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 3, 6, 3 },
   { OSUTF8("ms2000"), 4, 6, 6 },
   { OSUTF8("ms250"), 1, 5, 1 },
   { OSUTF8("ms3000"), 5, 6, 2 },
   { OSUTF8("ms4000"), 6, 6, 4 },
   { OSUTF8("ms500"), 2, 5, 5 },
   { OSUTF8("ms6000"), 7, 6, 7 }
} ;
#define ranap_M4_Period_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_M4_Period_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_M4_Period_ENUMTABSIZE) {
      return ranap_M4_Period_ENUMTAB
         [ranap_M4_Period_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_M4_Period_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_M4_Period* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_M4_Period_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_M4_Period_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_M4_Period* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_M4_Period_ENUMTAB, 
      ranap_M4_Period_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_M4_Period)ranap_M4_Period_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_M4_Period (OSCTXT* pctxt, ranap_M4_Period value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Period");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M4_Period (OSCTXT* pctxt, ranap_M4_Period* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Period");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_M4_Threshold (OSCTXT* pctxt, ranap_M4_Threshold value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Threshold");

   if ( value <= 31 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 31);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M4_Threshold (OSCTXT* pctxt, ranap_M4_Threshold* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Threshold");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 31);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_M5_Period_ENUMTAB[] = {
   { OSUTF8("ms100"), 0, 5, 0 },
   { OSUTF8("ms1000"), 3, 6, 3 },
   { OSUTF8("ms2000"), 4, 6, 6 },
   { OSUTF8("ms250"), 1, 5, 1 },
   { OSUTF8("ms3000"), 5, 6, 2 },
   { OSUTF8("ms4000"), 6, 6, 4 },
   { OSUTF8("ms500"), 2, 5, 5 },
   { OSUTF8("ms6000"), 7, 6, 7 }
} ;
#define ranap_M5_Period_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_M5_Period_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_M5_Period_ENUMTABSIZE) {
      return ranap_M5_Period_ENUMTAB
         [ranap_M5_Period_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_M5_Period_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_M5_Period* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_M5_Period_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_M5_Period_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_M5_Period* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_M5_Period_ENUMTAB, 
      ranap_M5_Period_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_M5_Period)ranap_M5_Period_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_M5_Period (OSCTXT* pctxt, ranap_M5_Period value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M5-Period");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M5_Period (OSCTXT* pctxt, ranap_M5_Period* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M5-Period");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_M6_Period_ENUMTAB[] = {
   { OSUTF8("ms1000"), 0, 6, 0 },
   { OSUTF8("ms12000"), 6, 7, 3 },
   { OSUTF8("ms16000"), 7, 7, 7 },
   { OSUTF8("ms2000"), 1, 6, 9 },
   { OSUTF8("ms20000"), 8, 7, 10 },
   { OSUTF8("ms24000"), 9, 7, 12 },
   { OSUTF8("ms28000"), 10, 7, 1 },
   { OSUTF8("ms3000"), 2, 6, 2 },
   { OSUTF8("ms32000"), 11, 7, 4 },
   { OSUTF8("ms4000"), 3, 6, 5 },
   { OSUTF8("ms6000"), 4, 6, 6 },
   { OSUTF8("ms64000"), 12, 7, 8 },
   { OSUTF8("ms8000"), 5, 6, 11 }
} ;
#define ranap_M6_Period_ENUMTABSIZE 13

const OSUTF8CHAR* ranap_M6_Period_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_M6_Period_ENUMTABSIZE) {
      return ranap_M6_Period_ENUMTAB
         [ranap_M6_Period_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_M6_Period_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_M6_Period* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_M6_Period_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_M6_Period_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_M6_Period* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_M6_Period_ENUMTAB, 
      ranap_M6_Period_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_M6_Period)ranap_M6_Period_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_M6_Period (OSCTXT* pctxt, ranap_M6_Period value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M6-Period");

   if (value >= 13) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M6_Period (OSCTXT* pctxt, ranap_M6_Period* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M6-Period");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(12));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_M7_Period_ENUMTAB[] = {
   { OSUTF8("ms1000"), 0, 6, 0 },
   { OSUTF8("ms12000"), 6, 7, 3 },
   { OSUTF8("ms16000"), 7, 7, 7 },
   { OSUTF8("ms2000"), 1, 6, 9 },
   { OSUTF8("ms20000"), 8, 7, 10 },
   { OSUTF8("ms24000"), 9, 7, 12 },
   { OSUTF8("ms28000"), 10, 7, 1 },
   { OSUTF8("ms3000"), 2, 6, 2 },
   { OSUTF8("ms32000"), 11, 7, 4 },
   { OSUTF8("ms4000"), 3, 6, 5 },
   { OSUTF8("ms6000"), 4, 6, 6 },
   { OSUTF8("ms64000"), 12, 7, 8 },
   { OSUTF8("ms8000"), 5, 6, 11 }
} ;
#define ranap_M7_Period_ENUMTABSIZE 13

const OSUTF8CHAR* ranap_M7_Period_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_M7_Period_ENUMTABSIZE) {
      return ranap_M7_Period_ENUMTAB
         [ranap_M7_Period_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_M7_Period_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_M7_Period* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_M7_Period_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_M7_Period_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_M7_Period* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_M7_Period_ENUMTAB, 
      ranap_M7_Period_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_M7_Period)ranap_M7_Period_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_M7_Period (OSCTXT* pctxt, ranap_M7_Period value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "M7-Period");

   if (value >= 13) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(12));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M7_Period (OSCTXT* pctxt, ranap_M7_Period* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M7-Period");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(12));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Management_Based_MDT_Allowed_ENUMTAB[] = {
   { OSUTF8("allowed"), 0, 7, 0 }
} ;
#define ranap_Management_Based_MDT_Allowed_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_Management_Based_MDT_Allowed_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_Management_Based_MDT_Allowed_ENUMTAB, 
      ranap_Management_Based_MDT_Allowed_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_Management_Based_MDT_Allowed_ENUMTABSIZE) {
      return ranap_Management_Based_MDT_Allowed_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Management_Based_MDT_Allowed_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Management_Based_MDT_Allowed* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Management_Based_MDT_Allowed_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Management_Based_MDT_Allowed_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Management_Based_MDT_Allowed* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Management_Based_MDT_Allowed_ENUMTAB, 
      ranap_Management_Based_MDT_Allowed_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Management_Based_MDT_Allowed)
         ranap_Management_Based_MDT_Allowed_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Management_Based_MDT_Allowed (OSCTXT* pctxt, ranap_Management_Based_MDT_Allowed value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Management-Based-MDT-Allowed");

   switch (value) {
      case ranap_allowed_1: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Management_Based_MDT_Allowed (OSCTXT* pctxt, ranap_Management_Based_MDT_Allowed* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Management-Based-MDT-Allowed");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_allowed_1; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MBMSBearerServiceType_ENUMTAB[] = {
   { OSUTF8("broadcast"), 1, 9, 1 },
   { OSUTF8("multicast"), 0, 9, 0 }
} ;
#define ranap_MBMSBearerServiceType_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_MBMSBearerServiceType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MBMSBearerServiceType_ENUMTABSIZE) {
      return ranap_MBMSBearerServiceType_ENUMTAB
         [ranap_MBMSBearerServiceType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSBearerServiceType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSBearerServiceType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSBearerServiceType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSBearerServiceType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_MBMSBearerServiceType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSBearerServiceType_ENUMTAB, 
      ranap_MBMSBearerServiceType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSBearerServiceType)
         ranap_MBMSBearerServiceType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSBearerServiceType (OSCTXT* pctxt, ranap_MBMSBearerServiceType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSBearerServiceType");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSBearerServiceType (OSCTXT* pctxt, ranap_MBMSBearerServiceType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSBearerServiceType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MBMSCNDe_Registration_ENUMTAB[] = {
   { OSUTF8("deregister"), 1, 10, 1 },
   { OSUTF8("normalsessionstop"), 0, 17, 0 }
} ;
#define ranap_MBMSCNDe_Registration_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_MBMSCNDe_Registration_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MBMSCNDe_Registration_ENUMTABSIZE) {
      return ranap_MBMSCNDe_Registration_ENUMTAB
         [ranap_MBMSCNDe_Registration_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSCNDe_Registration_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSCNDe_Registration* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSCNDe_Registration_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSCNDe_Registration_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_MBMSCNDe_Registration* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSCNDe_Registration_ENUMTAB, 
      ranap_MBMSCNDe_Registration_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSCNDe_Registration)
         ranap_MBMSCNDe_Registration_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSCNDe_Registration (OSCTXT* pctxt, ranap_MBMSCNDe_Registration value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-Registration");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSCNDe_Registration (OSCTXT* pctxt, ranap_MBMSCNDe_Registration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-Registration");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MBMSCountingInformation_ENUMTAB[] = {
   { OSUTF8("counting"), 0, 8, 0 },
   { OSUTF8("notcounting"), 1, 11, 1 }
} ;
#define ranap_MBMSCountingInformation_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_MBMSCountingInformation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MBMSCountingInformation_ENUMTABSIZE) {
      return ranap_MBMSCountingInformation_ENUMTAB
         [ranap_MBMSCountingInformation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSCountingInformation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSCountingInformation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSCountingInformation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSCountingInformation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_MBMSCountingInformation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSCountingInformation_ENUMTAB, 
      ranap_MBMSCountingInformation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSCountingInformation)
         ranap_MBMSCountingInformation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSCountingInformation (OSCTXT* pctxt, ranap_MBMSCountingInformation value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCountingInformation");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSCountingInformation (OSCTXT* pctxt, ranap_MBMSCountingInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCountingInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MBMSLinkingInformation_ENUMTAB[] = {
   { OSUTF8("uE-has-joined-multicast-services"), 0, 32, 0 }
} ;
#define ranap_MBMSLinkingInformation_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_MBMSLinkingInformation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_MBMSLinkingInformation_ENUMTAB, 
      ranap_MBMSLinkingInformation_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_MBMSLinkingInformation_ENUMTABSIZE) {
      return ranap_MBMSLinkingInformation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSLinkingInformation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSLinkingInformation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSLinkingInformation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSLinkingInformation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_MBMSLinkingInformation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSLinkingInformation_ENUMTAB, 
      ranap_MBMSLinkingInformation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSLinkingInformation)
         ranap_MBMSLinkingInformation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSLinkingInformation (OSCTXT* pctxt, ranap_MBMSLinkingInformation value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSLinkingInformation");

   switch (value) {
      case ranap_uE_has_joined_multicast_services: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSLinkingInformation (OSCTXT* pctxt, ranap_MBMSLinkingInformation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSLinkingInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_uE_has_joined_multicast_services; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MBMSRegistrationRequestType_ENUMTAB[] = {
   { OSUTF8("deregister"), 1, 10, 1 },
   { OSUTF8("register"), 0, 8, 0 }
} ;
#define ranap_MBMSRegistrationRequestType_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_MBMSRegistrationRequestType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MBMSRegistrationRequestType_ENUMTABSIZE) {
      return ranap_MBMSRegistrationRequestType_ENUMTAB
         [ranap_MBMSRegistrationRequestType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MBMSRegistrationRequestType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MBMSRegistrationRequestType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MBMSRegistrationRequestType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MBMSRegistrationRequestType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_MBMSRegistrationRequestType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MBMSRegistrationRequestType_ENUMTAB, 
      ranap_MBMSRegistrationRequestType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MBMSRegistrationRequestType)
         ranap_MBMSRegistrationRequestType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MBMSRegistrationRequestType (OSCTXT* pctxt, ranap_MBMSRegistrationRequestType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationRequestType");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRegistrationRequestType (OSCTXT* pctxt, ranap_MBMSRegistrationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationRequestType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_MBMSServiceArea (OSCTXT* pctxt, ranap_MBMSServiceArea value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSServiceArea");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSServiceArea (OSCTXT* pctxt, ranap_MBMSServiceArea* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSServiceArea");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSServiceArea (ranap_MBMSServiceArea* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_MBMSServiceArea (OSCTXT *pctxt, 
   ranap_MBMSServiceArea* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_MBMSSessionDuration (OSCTXT* pctxt, ranap_MBMSSessionDuration* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionDuration");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionDuration (OSCTXT* pctxt, ranap_MBMSSessionDuration* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionDuration");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionDuration (ranap_MBMSSessionDuration* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_MBMSSessionIdentity (OSCTXT* pctxt, ranap_MBMSSessionIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionIdentity (OSCTXT* pctxt, ranap_MBMSSessionIdentity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionIdentity");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionIdentity (ranap_MBMSSessionIdentity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_MBMSSessionRepetitionNumber (OSCTXT* pctxt, ranap_MBMSSessionRepetitionNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionRepetitionNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionRepetitionNumber (OSCTXT* pctxt, ranap_MBMSSessionRepetitionNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionRepetitionNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionRepetitionNumber (
   ranap_MBMSSessionRepetitionNumber* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_MDT_Activation_ENUMTAB[] = {
   { OSUTF8("immediateMDTandTrace"), 2, 20, 1 },
   { OSUTF8("immediateMDTonly"), 0, 16, 2 },
   { OSUTF8("loggedMDTonly"), 1, 13, 0 }
} ;
#define ranap_MDT_Activation_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_MDT_Activation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MDT_Activation_ENUMTABSIZE) {
      return ranap_MDT_Activation_ENUMTAB
         [ranap_MDT_Activation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MDT_Activation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MDT_Activation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MDT_Activation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MDT_Activation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_MDT_Activation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_MDT_Activation_ENUMTAB, 
      ranap_MDT_Activation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MDT_Activation)ranap_MDT_Activation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MDT_Activation (OSCTXT* pctxt, ranap_MDT_Activation value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Activation");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDT_Activation (OSCTXT* pctxt, ranap_MDT_Activation* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Activation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MeasurementQuantity_ENUMTAB[] = {
   { OSUTF8("cpichEcNo"), 0, 9, 0 },
   { OSUTF8("cpichRSCP"), 1, 9, 1 },
   { OSUTF8("pathloss"), 2, 8, 2 }
} ;
#define ranap_MeasurementQuantity_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_MeasurementQuantity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MeasurementQuantity_ENUMTABSIZE) {
      return ranap_MeasurementQuantity_ENUMTAB
         [ranap_MeasurementQuantity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MeasurementQuantity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MeasurementQuantity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MeasurementQuantity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MeasurementQuantity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_MeasurementQuantity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_MeasurementQuantity_ENUMTAB, 
      ranap_MeasurementQuantity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MeasurementQuantity)
         ranap_MeasurementQuantity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MeasurementQuantity (OSCTXT* pctxt, ranap_MeasurementQuantity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantity");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MeasurementQuantity (OSCTXT* pctxt, ranap_MeasurementQuantity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementQuantity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_MeasurementsToActivate (OSCTXT* pctxt, ranap_MeasurementsToActivate value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementsToActivate");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MeasurementsToActivate (OSCTXT* pctxt, ranap_MeasurementsToActivate* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasurementsToActivate");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MeasurementsToActivate (
   ranap_MeasurementsToActivate* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_MSISDN (OSCTXT* pctxt, ranap_MSISDN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MSISDN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MSISDN (OSCTXT* pctxt, ranap_MSISDN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MSISDN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MSISDN (ranap_MSISDN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_NAS_SequenceNumber (OSCTXT* pctxt, ranap_NAS_SequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-SequenceNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NAS_SequenceNumber (OSCTXT* pctxt, ranap_NAS_SequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NAS-SequenceNumber");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(2), OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NAS_SequenceNumber (ranap_NAS_SequenceNumber* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_NewBSS_To_OldBSS_Information (OSCTXT* pctxt, ranap_NewBSS_To_OldBSS_Information value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NewBSS-To-OldBSS-Information");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NewBSS_To_OldBSS_Information (OSCTXT* pctxt, ranap_NewBSS_To_OldBSS_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NewBSS-To-OldBSS-Information");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NewBSS_To_OldBSS_Information (
   ranap_NewBSS_To_OldBSS_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_NewBSS_To_OldBSS_Information (OSCTXT *pctxt, 
   ranap_NewBSS_To_OldBSS_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

static const OSEnumItem ranap_NonSearchingIndication_ENUMTAB[] = {
   { OSUTF8("non-searching"), 0, 13, 0 },
   { OSUTF8("searching"), 1, 9, 1 }
} ;
#define ranap_NonSearchingIndication_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_NonSearchingIndication_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_NonSearchingIndication_ENUMTABSIZE) {
      return ranap_NonSearchingIndication_ENUMTAB
         [ranap_NonSearchingIndication_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_NonSearchingIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_NonSearchingIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_NonSearchingIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_NonSearchingIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_NonSearchingIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_NonSearchingIndication_ENUMTAB, 
      ranap_NonSearchingIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_NonSearchingIndication)
         ranap_NonSearchingIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_NonSearchingIndication (OSCTXT* pctxt, ranap_NonSearchingIndication value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NonSearchingIndication");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NonSearchingIndication (OSCTXT* pctxt, ranap_NonSearchingIndication* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NonSearchingIndication");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_NRI (OSCTXT* pctxt, ranap_NRI value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NRI (OSCTXT* pctxt, ranap_NRI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NRI (ranap_NRI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_NRTLoadInformationValue (OSCTXT* pctxt, ranap_NRTLoadInformationValue value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRTLoadInformationValue");

   if ( value <= 3 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NRTLoadInformationValue (OSCTXT* pctxt, ranap_NRTLoadInformationValue* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NRTLoadInformationValue");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Null_NRI (OSCTXT* pctxt, ranap_Null_NRI value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Null-NRI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Null_NRI (OSCTXT* pctxt, ranap_Null_NRI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Null-NRI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(10), OSUINTCONST(10), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(10), OSUINTCONST(10));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Null_NRI (ranap_Null_NRI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_NumberOfIuInstances (OSCTXT* pctxt, ranap_NumberOfIuInstances value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfIuInstances");

   if ( (value >= 1 && value <= 2) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NumberOfIuInstances (OSCTXT* pctxt, ranap_NumberOfIuInstances* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfIuInstances");

   stat = pd_ConsUInt8 (pctxt, pvalue, 1, 2);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_NumberOfSteps (OSCTXT* pctxt, ranap_NumberOfSteps value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfSteps");

   if ( (value >= 1 && value <= 16) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 16);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NumberOfSteps (OSCTXT* pctxt, ranap_NumberOfSteps* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumberOfSteps");

   stat = pd_ConsUInt8 (pctxt, pvalue, 1, 16);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Offload_RAB_Parameters_APN (OSCTXT* pctxt, ranap_Offload_RAB_Parameters_APN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters-APN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Offload_RAB_Parameters_APN (OSCTXT* pctxt, ranap_Offload_RAB_Parameters_APN* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters-APN");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(255), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Offload_RAB_Parameters_APN (
   ranap_Offload_RAB_Parameters_APN* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Offload_RAB_Parameters_ChargingCharacteristics (OSCTXT* pctxt, ranap_Offload_RAB_Parameters_ChargingCharacteristics* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters-ChargingCharacteristics");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Offload_RAB_Parameters_ChargingCharacteristics (OSCTXT* pctxt, ranap_Offload_RAB_Parameters_ChargingCharacteristics* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters-ChargingCharacteristics");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Offload_RAB_Parameters_ChargingCharacteristics (
   ranap_Offload_RAB_Parameters_ChargingCharacteristics* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_OldBSS_ToNewBSS_Information (OSCTXT* pctxt, ranap_OldBSS_ToNewBSS_Information value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OldBSS-ToNewBSS-Information");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_OldBSS_ToNewBSS_Information (OSCTXT* pctxt, ranap_OldBSS_ToNewBSS_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OldBSS-ToNewBSS-Information");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_OldBSS_ToNewBSS_Information (
   ranap_OldBSS_ToNewBSS_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_OldBSS_ToNewBSS_Information (OSCTXT *pctxt, 
   ranap_OldBSS_ToNewBSS_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_OMC_ID (OSCTXT* pctxt, ranap_OMC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OMC-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(22), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_OMC_ID (OSCTXT* pctxt, ranap_OMC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OMC-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(22), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_OMC_ID (ranap_OMC_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_Out_Of_UTRAN_ENUMTAB[] = {
   { OSUTF8("cell-reselection-to-EUTRAN"), 0, 26, 0 }
} ;
#define ranap_Out_Of_UTRAN_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_Out_Of_UTRAN_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ranap_Out_Of_UTRAN_ENUMTAB, 
      ranap_Out_Of_UTRAN_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_Out_Of_UTRAN_ENUMTABSIZE) {
      return ranap_Out_Of_UTRAN_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Out_Of_UTRAN_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Out_Of_UTRAN* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Out_Of_UTRAN_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Out_Of_UTRAN_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_Out_Of_UTRAN* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_Out_Of_UTRAN_ENUMTAB, 
      ranap_Out_Of_UTRAN_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Out_Of_UTRAN)ranap_Out_Of_UTRAN_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Out_Of_UTRAN (OSCTXT* pctxt, ranap_Out_Of_UTRAN value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Out-Of-UTRAN");

   switch (value) {
      case ranap_cell_reselection_to_EUTRAN: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Out_Of_UTRAN (OSCTXT* pctxt, ranap_Out_Of_UTRAN* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Out-Of-UTRAN");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_cell_reselection_to_EUTRAN; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_PagingCause_ENUMTAB[] = {
   { OSUTF8("terminating-background-call"), 3, 27, 1 },
   { OSUTF8("terminating-conversational-call"), 0, 31, 5 },
   { OSUTF8("terminating-high-priority-signalling"), 5, 36, 3 },
   { OSUTF8("terminating-interactive-call"), 2, 28, 0 },
   { OSUTF8("terminating-low-priority-signalling"), 4, 35, 4 },
   { OSUTF8("terminating-streaming-call"), 1, 26, 2 }
} ;
#define ranap_PagingCause_ENUMTABSIZE 6

const OSUTF8CHAR* ranap_PagingCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_PagingCause_ENUMTABSIZE) {
      return ranap_PagingCause_ENUMTAB
         [ranap_PagingCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PagingCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PagingCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PagingCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PagingCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_PagingCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_PagingCause_ENUMTAB, 
      ranap_PagingCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PagingCause)ranap_PagingCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PagingCause (OSCTXT* pctxt, ranap_PagingCause value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingCause");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(4));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 5);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(4));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PagingCause (OSCTXT* pctxt, ranap_PagingCause* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingCause");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_terminating_high_priority_signalling; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_PDP_Type_extension_ENUMTAB[] = {
   { OSUTF8("ipv4-and-ipv6"), 0, 13, 0 }
} ;
#define ranap_PDP_Type_extension_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_PDP_Type_extension_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_PDP_Type_extension_ENUMTAB, ranap_PDP_Type_extension_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_PDP_Type_extension_ENUMTABSIZE) {
      return ranap_PDP_Type_extension_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PDP_Type_extension_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PDP_Type_extension* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PDP_Type_extension_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PDP_Type_extension_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_PDP_Type_extension* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_PDP_Type_extension_ENUMTAB, ranap_PDP_Type_extension_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PDP_Type_extension)
         ranap_PDP_Type_extension_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PDP_Type_extension (OSCTXT* pctxt, ranap_PDP_Type_extension value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-Type-extension");

   switch (value) {
      case ranap_ipv4_and_ipv6: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PDP_Type_extension (OSCTXT* pctxt, ranap_PDP_Type_extension* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-Type-extension");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_ipv4_and_ipv6; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_PDUType14FrameSequenceNumber (OSCTXT* pctxt, ranap_PDUType14FrameSequenceNumber value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUType14FrameSequenceNumber");

   if ( value <= 3 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PDUType14FrameSequenceNumber (OSCTXT* pctxt, ranap_PDUType14FrameSequenceNumber* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDUType14FrameSequenceNumber");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_LoggingInterval_ENUMTAB[] = {
   { OSUTF8("s10d24"), 3, 6, 1 },
   { OSUTF8("s1d28"), 0, 5, 3 },
   { OSUTF8("s20d48"), 4, 6, 6 },
   { OSUTF8("s2d56"), 1, 5, 0 },
   { OSUTF8("s30d72"), 5, 6, 2 },
   { OSUTF8("s40d96"), 6, 6, 4 },
   { OSUTF8("s5d12"), 2, 5, 5 },
   { OSUTF8("s61d44"), 7, 6, 7 }
} ;
#define ranap_LoggingInterval_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_LoggingInterval_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_LoggingInterval_ENUMTABSIZE) {
      return ranap_LoggingInterval_ENUMTAB
         [ranap_LoggingInterval_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_LoggingInterval_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_LoggingInterval* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_LoggingInterval_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_LoggingInterval_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_LoggingInterval* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_LoggingInterval_ENUMTAB, ranap_LoggingInterval_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_LoggingInterval)
         ranap_LoggingInterval_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_LoggingInterval (OSCTXT* pctxt, ranap_LoggingInterval value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LoggingInterval");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LoggingInterval (OSCTXT* pctxt, ranap_LoggingInterval* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LoggingInterval");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_LoggingDuration_ENUMTAB[] = {
   { OSUTF8("min10"), 0, 5, 0 },
   { OSUTF8("min120"), 5, 6, 2 },
   { OSUTF8("min20"), 1, 5, 3 },
   { OSUTF8("min40"), 2, 5, 4 },
   { OSUTF8("min60"), 3, 5, 5 },
   { OSUTF8("min90"), 4, 5, 1 }
} ;
#define ranap_LoggingDuration_ENUMTABSIZE 6

const OSUTF8CHAR* ranap_LoggingDuration_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_LoggingDuration_ENUMTABSIZE) {
      return ranap_LoggingDuration_ENUMTAB
         [ranap_LoggingDuration_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_LoggingDuration_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_LoggingDuration* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_LoggingDuration_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_LoggingDuration_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_LoggingDuration* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_LoggingDuration_ENUMTAB, ranap_LoggingDuration_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_LoggingDuration)
         ranap_LoggingDuration_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_LoggingDuration (OSCTXT* pctxt, ranap_LoggingDuration value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LoggingDuration");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LoggingDuration (OSCTXT* pctxt, ranap_LoggingDuration* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LoggingDuration");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Port_Number (OSCTXT* pctxt, ranap_Port_Number* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Port-Number");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Port_Number (OSCTXT* pctxt, ranap_Port_Number* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Port-Number");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Port_Number (ranap_Port_Number* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_PositioningDataDiscriminator (OSCTXT* pctxt, ranap_PositioningDataDiscriminator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningDataDiscriminator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(4), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositioningDataDiscriminator (OSCTXT* pctxt, ranap_PositioningDataDiscriminator* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningDataDiscriminator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(4), OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PositioningDataDiscriminator (
   ranap_PositioningDataDiscriminator* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositioningMethodAndUsage (OSCTXT* pctxt, ranap_PositioningMethodAndUsage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningMethodAndUsage");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PositioningMethodAndUsage (
   ranap_PositioningMethodAndUsage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_PositioningPriority_ENUMTAB[] = {
   { OSUTF8("high-Priority"), 0, 13, 0 },
   { OSUTF8("normal-Priority"), 1, 15, 1 }
} ;
#define ranap_PositioningPriority_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_PositioningPriority_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_PositioningPriority_ENUMTABSIZE) {
      return ranap_PositioningPriority_ENUMTAB
         [ranap_PositioningPriority_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PositioningPriority_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PositioningPriority* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PositioningPriority_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PositioningPriority_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_PositioningPriority* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_PositioningPriority_ENUMTAB, 
      ranap_PositioningPriority_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PositioningPriority)
         ranap_PositioningPriority_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PositioningPriority (OSCTXT* pctxt, ranap_PositioningPriority value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningPriority");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositioningPriority (OSCTXT* pctxt, ranap_PositioningPriority* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningPriority");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_PositionDataSpecificToGERANIuMode (OSCTXT* pctxt, ranap_PositionDataSpecificToGERANIuMode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositionDataSpecificToGERANIuMode");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositionDataSpecificToGERANIuMode (OSCTXT* pctxt, ranap_PositionDataSpecificToGERANIuMode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositionDataSpecificToGERANIuMode");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PositionDataSpecificToGERANIuMode (
   ranap_PositionDataSpecificToGERANIuMode* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_PositionDataSpecificToGERANIuMode (OSCTXT *pctxt, 
   ranap_PositionDataSpecificToGERANIuMode* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_Priority_Class_Indicator (OSCTXT* pctxt, ranap_Priority_Class_Indicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Priority-Class-Indicator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pe_BitString32 (pctxt, &value, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Priority_Class_Indicator (OSCTXT* pctxt, ranap_Priority_Class_Indicator* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Priority-Class-Indicator");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(8), OSUINTCONST(8), 0, 0);

   stat = pd_BitString32 (pctxt, pvalue, OSUINTCONST(8), OSUINTCONST(8));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Priority_Class_Indicator (
   ranap_Priority_Class_Indicator* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_PowerSavingIndicator_ENUMTAB[] = {
   { OSUTF8("eDRXConfigured"), 1, 14, 1 },
   { OSUTF8("psmConfigured"), 0, 13, 0 }
} ;
#define ranap_PowerSavingIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_PowerSavingIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_PowerSavingIndicator_ENUMTABSIZE) {
      return ranap_PowerSavingIndicator_ENUMTAB
         [ranap_PowerSavingIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_PowerSavingIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_PowerSavingIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_PowerSavingIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_PowerSavingIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_PowerSavingIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_PowerSavingIndicator_ENUMTAB, 
      ranap_PowerSavingIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_PowerSavingIndicator)
         ranap_PowerSavingIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_PowerSavingIndicator (OSCTXT* pctxt, ranap_PowerSavingIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PowerSavingIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PowerSavingIndicator (OSCTXT* pctxt, ranap_PowerSavingIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PowerSavingIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_P_TMSI (OSCTXT* pctxt, ranap_P_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "P-TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_P_TMSI (OSCTXT* pctxt, ranap_P_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "P-TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_P_TMSI (ranap_P_TMSI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_RAC (OSCTXT* pctxt, ranap_RAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAC (OSCTXT* pctxt, ranap_RAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAC (ranap_RAC* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_RAT_Type_ENUMTAB[] = {
   { OSUTF8("geran"), 1, 5, 1 },
   { OSUTF8("utran"), 0, 5, 0 }
} ;
#define ranap_RAT_Type_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_RAT_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RAT_Type_ENUMTABSIZE) {
      return ranap_RAT_Type_ENUMTAB
         [ranap_RAT_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RAT_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RAT_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RAT_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RAT_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_RAT_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_RAT_Type_ENUMTAB, 
      ranap_RAT_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RAT_Type)ranap_RAT_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RAT_Type (OSCTXT* pctxt, ranap_RAT_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAT-Type");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAT_Type (OSCTXT* pctxt, ranap_RAT_Type* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAT-Type");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RateControlAllowed_ENUMTAB[] = {
   { OSUTF8("allowed"), 1, 7, 1 },
   { OSUTF8("not-allowed"), 0, 11, 0 }
} ;
#define ranap_RateControlAllowed_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_RateControlAllowed_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RateControlAllowed_ENUMTABSIZE) {
      return ranap_RateControlAllowed_ENUMTAB
         [ranap_RateControlAllowed_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RateControlAllowed_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RateControlAllowed* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RateControlAllowed_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RateControlAllowed_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_RateControlAllowed* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RateControlAllowed_ENUMTAB, ranap_RateControlAllowed_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RateControlAllowed)
         ranap_RateControlAllowed_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RateControlAllowed (OSCTXT* pctxt, ranap_RateControlAllowed value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RateControlAllowed");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RateControlAllowed (OSCTXT* pctxt, ranap_RateControlAllowed* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RateControlAllowed");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RedirectAttemptFlag_ (OSCTXT* pctxt, void* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG(pvalue) ;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectAttemptFlag");

   /* NULL */

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RedirectAttemptFlag_ (OSCTXT* pctxt, void* pvalue)
{
   int stat = 0;
   OS_UNUSED_ARG(pvalue) ;
   OS_UNUSED_ARG(pctxt) ;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectAttemptFlag");

   /* NULL */

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RedirectionCompleted_ENUMTAB[] = {
   { OSUTF8("redirection-completed"), 0, 21, 0 }
} ;
#define ranap_RedirectionCompleted_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_RedirectionCompleted_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_RedirectionCompleted_ENUMTAB, 
      ranap_RedirectionCompleted_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_RedirectionCompleted_ENUMTABSIZE) {
      return ranap_RedirectionCompleted_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RedirectionCompleted_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RedirectionCompleted* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RedirectionCompleted_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RedirectionCompleted_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RedirectionCompleted* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RedirectionCompleted_ENUMTAB, 
      ranap_RedirectionCompleted_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RedirectionCompleted)
         ranap_RedirectionCompleted_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RedirectionCompleted (OSCTXT* pctxt, ranap_RedirectionCompleted value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectionCompleted");

   switch (value) {
      case ranap_redirection_completed: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RedirectionCompleted (OSCTXT* pctxt, ranap_RedirectionCompleted* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectionCompleted");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_redirection_completed; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RejectCauseValue_ENUMTAB[] = {
   { OSUTF8("cS-PS-coordination-required"), 5, 27, 6 },
   { OSUTF8("gPRS-Services-Not-Allowed-In-This-PLMN"), 4, 38, 2 },
   { OSUTF8("location-Area-Not-Allowed"), 1, 25, 7 },
   { OSUTF8("network-failure"), 6, 15, 4 },
   { OSUTF8("no-Suitable-Cell-In-Location-Area"), 3, 33, 1 },
   { OSUTF8("not-authorized-for-this-CSG"), 7, 27, 0 },
   { OSUTF8("pLMN-Not-Allowed"), 0, 16, 3 },
   { OSUTF8("roaming-Not-Allowed-In-This-Location-Area"), 2, 41, 5 }
} ;
#define ranap_RejectCauseValue_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_RejectCauseValue_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RejectCauseValue_ENUMTABSIZE) {
      return ranap_RejectCauseValue_ENUMTAB
         [ranap_RejectCauseValue_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RejectCauseValue_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RejectCauseValue* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RejectCauseValue_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RejectCauseValue_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_RejectCauseValue* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RejectCauseValue_ENUMTAB, ranap_RejectCauseValue_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RejectCauseValue)
         ranap_RejectCauseValue_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RejectCauseValue (OSCTXT* pctxt, ranap_RejectCauseValue value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RejectCauseValue");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(5));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 6);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RejectCauseValue (OSCTXT* pctxt, ranap_RejectCauseValue* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RejectCauseValue");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_network_failure; break;
         case 1: *pvalue = ranap_not_authorized_for_this_CSG; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RelocationType_ENUMTAB[] = {
   { OSUTF8("ue-involved"), 1, 11, 1 },
   { OSUTF8("ue-not-involved"), 0, 15, 0 }
} ;
#define ranap_RelocationType_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_RelocationType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RelocationType_ENUMTABSIZE) {
      return ranap_RelocationType_ENUMTAB
         [ranap_RelocationType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RelocationType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RelocationType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RelocationType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RelocationType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_RelocationType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_RelocationType_ENUMTAB, 
      ranap_RelocationType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RelocationType)ranap_RelocationType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RelocationType (OSCTXT* pctxt, ranap_RelocationType value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationType");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationType (OSCTXT* pctxt, ranap_RelocationType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RepetitionNumber0 (OSCTXT* pctxt, ranap_RepetitionNumber0 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionNumber0");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RepetitionNumber0 (OSCTXT* pctxt, ranap_RepetitionNumber0* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionNumber0");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RepetitionNumber1 (OSCTXT* pctxt, ranap_RepetitionNumber1 value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionNumber1");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 256);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RepetitionNumber1 (OSCTXT* pctxt, ranap_RepetitionNumber1* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RepetitionNumber1");

   stat = pd_ConsUInt16 (pctxt, pvalue, 1, 256);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ReportArea_ENUMTAB[] = {
   { OSUTF8("geographical-area"), 1, 17, 1 },
   { OSUTF8("service-area"), 0, 12, 0 }
} ;
#define ranap_ReportArea_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_ReportArea_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_ReportArea_ENUMTABSIZE) {
      return ranap_ReportArea_ENUMTAB
         [ranap_ReportArea_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ReportArea_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ReportArea* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ReportArea_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ReportArea_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ReportArea* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_ReportArea_ENUMTAB, 
      ranap_ReportArea_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ReportArea)ranap_ReportArea_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ReportArea (OSCTXT* pctxt, ranap_ReportArea value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportArea");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ReportArea (OSCTXT* pctxt, ranap_ReportArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportArea");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ReportInterval_ENUMTAB[] = {
   { OSUTF8("ms1000"), 2, 6, 6 },
   { OSUTF8("ms12000"), 7, 7, 11 },
   { OSUTF8("ms16000"), 8, 7, 0 },
   { OSUTF8("ms2000"), 3, 6, 3 },
   { OSUTF8("ms20000"), 9, 7, 8 },
   { OSUTF8("ms24000"), 10, 7, 10 },
   { OSUTF8("ms250"), 0, 5, 12 },
   { OSUTF8("ms28000"), 14, 7, 1 },
   { OSUTF8("ms3000"), 4, 6, 2 },
   { OSUTF8("ms32000"), 11, 7, 4 },
   { OSUTF8("ms4000"), 5, 6, 5 },
   { OSUTF8("ms500"), 1, 5, 9 },
   { OSUTF8("ms6000"), 6, 6, 13 },
   { OSUTF8("ms64000"), 12, 7, 14 },
   { OSUTF8("ms8000"), 13, 6, 7 }
} ;
#define ranap_ReportInterval_ENUMTABSIZE 15

const OSUTF8CHAR* ranap_ReportInterval_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_ReportInterval_ENUMTABSIZE) {
      return ranap_ReportInterval_ENUMTAB
         [ranap_ReportInterval_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ReportInterval_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ReportInterval* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ReportInterval_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ReportInterval_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ReportInterval* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_ReportInterval_ENUMTAB, 
      ranap_ReportInterval_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ReportInterval)ranap_ReportInterval_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ReportInterval (OSCTXT* pctxt, ranap_ReportInterval value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportInterval");

   if (value >= 15) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(12));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 13);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(12));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ReportInterval (OSCTXT* pctxt, ranap_ReportInterval* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportInterval");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_ms8000_2; break;
         case 1: *pvalue = ranap_ms28000_2; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(12));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ReportAmount_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("n1"), 0, 2, 3 },
   { OSUTF8("n16"), 4, 3, 5 },
   { OSUTF8("n2"), 1, 2, 7 },
   { OSUTF8("n32"), 5, 3, 2 },
   { OSUTF8("n4"), 2, 2, 4 },
   { OSUTF8("n64"), 6, 3, 6 },
   { OSUTF8("n8"), 3, 2, 0 }
} ;
#define ranap_ReportAmount_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_ReportAmount_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_ReportAmount_ENUMTABSIZE) {
      return ranap_ReportAmount_ENUMTAB
         [ranap_ReportAmount_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ReportAmount_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ReportAmount* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ReportAmount_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ReportAmount_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ReportAmount* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_ReportAmount_ENUMTAB, 
      ranap_ReportAmount_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ReportAmount)ranap_ReportAmount_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ReportAmount (OSCTXT* pctxt, ranap_ReportAmount value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportAmount");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ReportAmount (OSCTXT* pctxt, ranap_ReportAmount* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ReportAmount");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(7));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RequestedGPSAssistanceData (OSCTXT* pctxt, ranap_RequestedGPSAssistanceData* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedGPSAssistanceData");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(38), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestedGPSAssistanceData (OSCTXT* pctxt, ranap_RequestedGPSAssistanceData* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedGPSAssistanceData");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(38), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RequestedGPSAssistanceData (
   ranap_RequestedGPSAssistanceData* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_RequestedGANSSAssistanceData (OSCTXT* pctxt, ranap_RequestedGANSSAssistanceData* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedGANSSAssistanceData");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(201), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestedGANSSAssistanceData (OSCTXT* pctxt, ranap_RequestedGANSSAssistanceData* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedGANSSAssistanceData");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(201), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RequestedGANSSAssistanceData (
   ranap_RequestedGANSSAssistanceData* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_RequestedLocationRelatedDataType_ENUMTAB[] = {
   { OSUTF8("decipheringKeysAssistedGANSS"), 4, 28, 3 },
   { OSUTF8("decipheringKeysAssistedGPS"), 1, 26, 1 },
   { OSUTF8("decipheringKeysAssistedGPSandGANSS"), 6, 34, 7 },
   { OSUTF8("decipheringKeysUEBasedOTDOA"), 0, 27, 5 },
   { OSUTF8("dedicatedAssistanceDataAssistedGANSS"), 5, 36, 0 },
   { OSUTF8("dedicatedAssistanceDataAssistedGPS"), 3, 34, 4 },
   { OSUTF8("dedicatedAssistanceDataAssistedGPSandGANSS"), 7, 42, 2 },
   { OSUTF8("dedicatedAssistanceDataUEBasedOTDOA"), 2, 35, 6 }
} ;
#define ranap_RequestedLocationRelatedDataType_ENUMTABSIZE 8

const OSUTF8CHAR* ranap_RequestedLocationRelatedDataType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RequestedLocationRelatedDataType_ENUMTABSIZE) {
      return ranap_RequestedLocationRelatedDataType_ENUMTAB
         [ranap_RequestedLocationRelatedDataType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RequestedLocationRelatedDataType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RequestedLocationRelatedDataType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RequestedLocationRelatedDataType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RequestedLocationRelatedDataType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RequestedLocationRelatedDataType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RequestedLocationRelatedDataType_ENUMTAB, 
      ranap_RequestedLocationRelatedDataType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RequestedLocationRelatedDataType)
         ranap_RequestedLocationRelatedDataType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RequestedLocationRelatedDataType (OSCTXT* pctxt, ranap_RequestedLocationRelatedDataType value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedLocationRelatedDataType");

   if (value >= 8) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   extbit = (value > OSUINTCONST(3));

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_SmallNonNegWholeNumber (pctxt, value - 4);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(3));
   }
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestedLocationRelatedDataType (OSCTXT* pctxt, ranap_RequestedLocationRelatedDataType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedLocationRelatedDataType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_decipheringKeysAssistedGANSS; break;
         case 1: *pvalue = ranap_dedicatedAssistanceDataAssistedGANSS; break;
         case 2: *pvalue = ranap_decipheringKeysAssistedGPSandGANSS; break;
         case 3: *pvalue = ranap_dedicatedAssistanceDataAssistedGPSandGANSS; break;
         default: *pvalue = 0x7fffffff;
      }
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_ResponseTime_ENUMTAB[] = {
   { OSUTF8("delaytolerant"), 1, 13, 1 },
   { OSUTF8("lowdelay"), 0, 8, 0 }
} ;
#define ranap_ResponseTime_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_ResponseTime_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_ResponseTime_ENUMTABSIZE) {
      return ranap_ResponseTime_ENUMTAB
         [ranap_ResponseTime_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_ResponseTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_ResponseTime* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_ResponseTime_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_ResponseTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_ResponseTime* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_ResponseTime_ENUMTAB, 
      ranap_ResponseTime_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_ResponseTime)ranap_ResponseTime_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_ResponseTime (OSCTXT* pctxt, ranap_ResponseTime value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResponseTime");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResponseTime (OSCTXT* pctxt, ranap_ResponseTime* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResponseTime");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RIMInformation (OSCTXT* pctxt, ranap_RIMInformation value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RIMInformation");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RIMInformation (OSCTXT* pctxt, ranap_RIMInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RIMInformation");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RIMInformation (ranap_RIMInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_RIMInformation (OSCTXT *pctxt, 
   ranap_RIMInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_RNC_ID (OSCTXT* pctxt, ranap_RNC_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RNC-ID");

   if ( value <= 4095 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RNC_ID (OSCTXT* pctxt, ranap_RNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RNC-ID");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 4095);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_RRC_Container (OSCTXT* pctxt, ranap_RRC_Container value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRC-Container");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RRC_Container (OSCTXT* pctxt, ranap_RRC_Container* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RRC-Container");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RRC_Container (ranap_RRC_Container* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_RRC_Container (OSCTXT *pctxt, ranap_RRC_Container* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_RTLoadValue (OSCTXT* pctxt, ranap_RTLoadValue value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RTLoadValue");

   if ( value <= 100 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RTLoadValue (OSCTXT* pctxt, ranap_RTLoadValue* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RTLoadValue");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 100);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RSRVCC_HO_Indication_ENUMTAB[] = {
   { OSUTF8("ps-only"), 0, 7, 0 }
} ;
#define ranap_RSRVCC_HO_Indication_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_RSRVCC_HO_Indication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_RSRVCC_HO_Indication_ENUMTAB, 
      ranap_RSRVCC_HO_Indication_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_RSRVCC_HO_Indication_ENUMTABSIZE) {
      return ranap_RSRVCC_HO_Indication_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RSRVCC_HO_Indication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RSRVCC_HO_Indication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RSRVCC_HO_Indication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RSRVCC_HO_Indication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RSRVCC_HO_Indication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RSRVCC_HO_Indication_ENUMTAB, 
      ranap_RSRVCC_HO_Indication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RSRVCC_HO_Indication)
         ranap_RSRVCC_HO_Indication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RSRVCC_HO_Indication (OSCTXT* pctxt, ranap_RSRVCC_HO_Indication value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-HO-Indication");

   switch (value) {
      case ranap_ps_only: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRVCC_HO_Indication (OSCTXT* pctxt, ranap_RSRVCC_HO_Indication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-HO-Indication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_ps_only; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_RSRVCC_Operation_Possible_ENUMTAB[] = {
   { OSUTF8("rsrvcc-possible"), 0, 15, 0 }
} ;
#define ranap_RSRVCC_Operation_Possible_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_RSRVCC_Operation_Possible_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_RSRVCC_Operation_Possible_ENUMTAB, 
      ranap_RSRVCC_Operation_Possible_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_RSRVCC_Operation_Possible_ENUMTABSIZE) {
      return ranap_RSRVCC_Operation_Possible_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RSRVCC_Operation_Possible_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_RSRVCC_Operation_Possible* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RSRVCC_Operation_Possible_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RSRVCC_Operation_Possible_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RSRVCC_Operation_Possible* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RSRVCC_Operation_Possible_ENUMTAB, 
      ranap_RSRVCC_Operation_Possible_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RSRVCC_Operation_Possible)
         ranap_RSRVCC_Operation_Possible_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RSRVCC_Operation_Possible (OSCTXT* pctxt, ranap_RSRVCC_Operation_Possible value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-Operation-Possible");

   switch (value) {
      case ranap_rsrvcc_possible: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRVCC_Operation_Possible (OSCTXT* pctxt, ranap_RSRVCC_Operation_Possible* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-Operation-Possible");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_rsrvcc_possible; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SAC (OSCTXT* pctxt, ranap_SAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SAC (OSCTXT* pctxt, ranap_SAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SAC (ranap_SAC* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_SessionUpdateID (OSCTXT* pctxt, ranap_SessionUpdateID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SessionUpdateID");

   if ( value <= 1048575 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 1048575);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SessionUpdateID (OSCTXT* pctxt, ranap_SessionUpdateID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SessionUpdateID");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 1048575);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_Session_Re_establishment_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define ranap_Session_Re_establishment_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_Session_Re_establishment_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_Session_Re_establishment_Indicator_ENUMTAB, 
      ranap_Session_Re_establishment_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_Session_Re_establishment_Indicator_ENUMTABSIZE) {
      return ranap_Session_Re_establishment_Indicator_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_Session_Re_establishment_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_Session_Re_establishment_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_Session_Re_establishment_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_Session_Re_establishment_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_Session_Re_establishment_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_Session_Re_establishment_Indicator_ENUMTAB, 
      ranap_Session_Re_establishment_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_Session_Re_establishment_Indicator)
         ranap_Session_Re_establishment_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_Session_Re_establishment_Indicator (OSCTXT* pctxt, ranap_Session_Re_establishment_Indicator value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "Session-Re-establishment-Indicator");

   switch (value) {
      case ranap_true_: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Session_Re_establishment_Indicator (OSCTXT* pctxt, ranap_Session_Re_establishment_Indicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Session-Re-establishment-Indicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_true_; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_SignallingIndication_ENUMTAB[] = {
   { OSUTF8("signalling"), 0, 10, 0 }
} ;
#define ranap_SignallingIndication_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_SignallingIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_SignallingIndication_ENUMTAB, 
      ranap_SignallingIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_SignallingIndication_ENUMTABSIZE) {
      return ranap_SignallingIndication_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_SignallingIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_SignallingIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_SignallingIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_SignallingIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_SignallingIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_SignallingIndication_ENUMTAB, 
      ranap_SignallingIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_SignallingIndication)
         ranap_SignallingIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_SignallingIndication (OSCTXT* pctxt, ranap_SignallingIndication value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SignallingIndication");

   switch (value) {
      case ranap_signalling: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SignallingIndication (OSCTXT* pctxt, ranap_SignallingIndication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SignallingIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_signalling; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SGSN_Group_ID (OSCTXT* pctxt, ranap_SGSN_Group_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SGSN-Group-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SGSN_Group_ID (OSCTXT* pctxt, ranap_SGSN_Group_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SGSN-Group-ID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SGSN_Group_ID (ranap_SGSN_Group_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_SNAC (OSCTXT* pctxt, ranap_SNAC value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SNAC");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SNAC (OSCTXT* pctxt, ranap_SNAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SNAC");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Source_ToTarget_TransparentContainer (OSCTXT* pctxt, ranap_Source_ToTarget_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Source-ToTarget-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Source_ToTarget_TransparentContainer (OSCTXT* pctxt, ranap_Source_ToTarget_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Source-ToTarget-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Source_ToTarget_TransparentContainer (
   ranap_Source_ToTarget_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_Source_ToTarget_TransparentContainer (OSCTXT *pctxt, 
   ranap_Source_ToTarget_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer (OSCTXT* pctxt, ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceeNodeB-ToTargeteNodeB-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer (OSCTXT* pctxt, ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceeNodeB-ToTargeteNodeB-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer (
   ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer (OSCTXT *pctxt, 
   ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_SourceBSS_ToTargetBSS_TransparentContainer (OSCTXT* pctxt, ranap_SourceBSS_ToTargetBSS_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceBSS-ToTargetBSS-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceBSS_ToTargetBSS_TransparentContainer (OSCTXT* pctxt, ranap_SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceBSS-ToTargetBSS-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceBSS_ToTargetBSS_TransparentContainer (
   ranap_SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_SourceBSS_ToTargetBSS_TransparentContainer (OSCTXT *pctxt, 
   ranap_SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_RSRQ_Extension (OSCTXT* pctxt, ranap_RSRQ_Extension value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Extension");

   if ( (value >= -30 && value <= 46) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsInteger (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsInteger (pctxt, value, -30, 46);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRQ_Extension (OSCTXT* pctxt, ranap_RSRQ_Extension* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Extension");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsInteger (pctxt, pvalue, -30, 46);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsInteger (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_MeasBand_ENUMTAB[] = {
   { OSUTF8("v100"), 5, 4, 4 },
   { OSUTF8("v15"), 1, 3, 1 },
   { OSUTF8("v25"), 2, 3, 2 },
   { OSUTF8("v50"), 3, 3, 3 },
   { OSUTF8("v6"), 0, 2, 5 },
   { OSUTF8("v75"), 4, 3, 0 }
} ;
#define ranap_MeasBand_ENUMTABSIZE 6

const OSUTF8CHAR* ranap_MeasBand_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_MeasBand_ENUMTABSIZE) {
      return ranap_MeasBand_ENUMTAB
         [ranap_MeasBand_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_MeasBand_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_MeasBand* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_MeasBand_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_MeasBand_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_MeasBand* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_MeasBand_ENUMTAB, 
      ranap_MeasBand_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_MeasBand)ranap_MeasBand_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_MeasBand (OSCTXT* pctxt, ranap_MeasBand value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasBand");

   if (value >= 6) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MeasBand (OSCTXT* pctxt, ranap_MeasBand* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MeasBand");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(5));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SubscriberProfileIDforRFP (OSCTXT* pctxt, ranap_SubscriberProfileIDforRFP value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubscriberProfileIDforRFP");

   if ( (value >= 1 && value <= 256) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 256);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SubscriberProfileIDforRFP (OSCTXT* pctxt, ranap_SubscriberProfileIDforRFP* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubscriberProfileIDforRFP");

   stat = pd_ConsUInt16 (pctxt, pvalue, 1, 256);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SupportedBitrate (OSCTXT* pctxt, ranap_SupportedBitrate value)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBitrate");

   if ( (value >= 1 && value <= 1000000000) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, value);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, value, 1, 1000000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SupportedBitrate (OSCTXT* pctxt, ranap_SupportedBitrate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedBitrate");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, pvalue, 1, 1000000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, pvalue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SRB_ID (OSCTXT* pctxt, ranap_SRB_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ID");

   if ( (value >= 1 && value <= 32) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 32);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRB_ID (OSCTXT* pctxt, ranap_SRB_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 1, 32);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_SRVCC_HO_Indication_ENUMTAB[] = {
   { OSUTF8("cs-only"), 1, 7, 1 },
   { OSUTF8("ps-and-cs"), 0, 9, 0 }
} ;
#define ranap_SRVCC_HO_Indication_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_SRVCC_HO_Indication_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_SRVCC_HO_Indication_ENUMTABSIZE) {
      return ranap_SRVCC_HO_Indication_ENUMTAB
         [ranap_SRVCC_HO_Indication_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_SRVCC_HO_Indication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_SRVCC_HO_Indication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_SRVCC_HO_Indication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_SRVCC_HO_Indication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_SRVCC_HO_Indication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_SRVCC_HO_Indication_ENUMTAB, 
      ranap_SRVCC_HO_Indication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_SRVCC_HO_Indication)
         ranap_SRVCC_HO_Indication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_SRVCC_HO_Indication (OSCTXT* pctxt, ranap_SRVCC_HO_Indication value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-HO-Indication");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_HO_Indication (OSCTXT* pctxt, ranap_SRVCC_HO_Indication* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-HO-Indication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_SRVCC_Operation_Possible_ENUMTAB[] = {
   { OSUTF8("srvcc-possible"), 0, 14, 0 }
} ;
#define ranap_SRVCC_Operation_Possible_ENUMTABSIZE 1

const OSUTF8CHAR* ranap_SRVCC_Operation_Possible_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ranap_SRVCC_Operation_Possible_ENUMTAB, 
      ranap_SRVCC_Operation_Possible_ENUMTABSIZE);

   if (idx >= 0 && idx < ranap_SRVCC_Operation_Possible_ENUMTABSIZE) {
      return ranap_SRVCC_Operation_Possible_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_SRVCC_Operation_Possible_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_SRVCC_Operation_Possible* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_SRVCC_Operation_Possible_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_SRVCC_Operation_Possible_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_SRVCC_Operation_Possible* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_SRVCC_Operation_Possible_ENUMTAB, 
      ranap_SRVCC_Operation_Possible_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_SRVCC_Operation_Possible)
         ranap_SRVCC_Operation_Possible_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_SRVCC_Operation_Possible (OSCTXT* pctxt, ranap_SRVCC_Operation_Possible value)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-Operation-Possible");

   switch (value) {
      case ranap_srvcc_possible: ui = 0; break;
      default: 
         rtxErrAddUIntParm (pctxt, value);
         return LOG_RTERR (pctxt, RTERR_INVENUM);
      break;
   }

   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, ui, 0, OSUINTCONST(0));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_Operation_Possible (OSCTXT* pctxt, ranap_SRVCC_Operation_Possible* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-Operation-Possible");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (ui) {
         case 0: *pvalue = ranap_srvcc_possible; break;
         default: return LOG_RTERR (pctxt, RTERR_INVENUM);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TAC (OSCTXT* pctxt, ranap_TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TAC (OSCTXT* pctxt, ranap_TAC* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAC");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(2), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TAC (ranap_TAC* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Target_ToSource_TransparentContainer (OSCTXT* pctxt, ranap_Target_ToSource_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Target-ToSource-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Target_ToSource_TransparentContainer (OSCTXT* pctxt, ranap_Target_ToSource_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Target-ToSource-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Target_ToSource_TransparentContainer (
   ranap_Target_ToSource_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_Target_ToSource_TransparentContainer (OSCTXT *pctxt, 
   ranap_Target_ToSource_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer (OSCTXT* pctxt, ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargeteNodeB-ToSourceeNodeB-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer (OSCTXT* pctxt, ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargeteNodeB-ToSourceeNodeB-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer (
   ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer (OSCTXT *pctxt, 
   ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_TargetBSS_ToSourceBSS_TransparentContainer (OSCTXT* pctxt, ranap_TargetBSS_ToSourceBSS_TransparentContainer value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetBSS-ToSourceBSS-TransparentContainer");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetBSS_ToSourceBSS_TransparentContainer (OSCTXT* pctxt, ranap_TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetBSS-ToSourceBSS-TransparentContainer");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargetBSS_ToSourceBSS_TransparentContainer (
   ranap_TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_TargetBSS_ToSourceBSS_TransparentContainer (OSCTXT *pctxt, 
   ranap_TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_TargetCellId (OSCTXT* pctxt, ranap_TargetCellId value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetCellId");

   if ( value <= 268435455 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 268435455);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetCellId (OSCTXT* pctxt, ranap_TargetCellId* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetCellId");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, 268435455);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Time_UE_StayedInCell (OSCTXT* pctxt, ranap_Time_UE_StayedInCell value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Time-UE-StayedInCell");

   if ( value <= 4095 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 4095);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Time_UE_StayedInCell (OSCTXT* pctxt, ranap_Time_UE_StayedInCell* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Time-UE-StayedInCell");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 4095);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_Time_UE_StayedInCell_EnhancedGranularity (OSCTXT* pctxt, ranap_Time_UE_StayedInCell_EnhancedGranularity value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Time-UE-StayedInCell-EnhancedGranularity");

   if ( value <= 40950 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 40950);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Time_UE_StayedInCell_EnhancedGranularity (OSCTXT* pctxt, ranap_Time_UE_StayedInCell_EnhancedGranularity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Time-UE-StayedInCell-EnhancedGranularity");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 40950);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TimeToMBMSDataTransfer (OSCTXT* pctxt, ranap_TimeToMBMSDataTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToMBMSDataTransfer");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TimeToMBMSDataTransfer (OSCTXT* pctxt, ranap_TimeToMBMSDataTransfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeToMBMSDataTransfer");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TimeToMBMSDataTransfer (
   ranap_TimeToMBMSDataTransfer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TimingDifferenceULDL (OSCTXT* pctxt, ranap_TimingDifferenceULDL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimingDifferenceULDL");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TimingDifferenceULDL (OSCTXT* pctxt, ranap_TimingDifferenceULDL* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimingDifferenceULDL");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TimingDifferenceULDL (ranap_TimingDifferenceULDL* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TMSI (OSCTXT* pctxt, ranap_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TMSI (OSCTXT* pctxt, ranap_TMSI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMSI");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(4), OSUINTCONST(4), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TMSI (ranap_TMSI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_TraceDepth_ENUMTAB[] = {
   { OSUTF8("maximum"), 2, 7, 2 },
   { OSUTF8("medium"), 1, 6, 1 },
   { OSUTF8("minimum"), 0, 7, 0 }
} ;
#define ranap_TraceDepth_ENUMTABSIZE 3

const OSUTF8CHAR* ranap_TraceDepth_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_TraceDepth_ENUMTABSIZE) {
      return ranap_TraceDepth_ENUMTAB
         [ranap_TraceDepth_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_TraceDepth_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_TraceDepth* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_TraceDepth_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_TraceDepth_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_TraceDepth* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_TraceDepth_ENUMTAB, 
      ranap_TraceDepth_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_TraceDepth)ranap_TraceDepth_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_TraceDepth (OSCTXT* pctxt, ranap_TraceDepth value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceDepth");

   if (value >= 3) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(2));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceDepth (OSCTXT* pctxt, ranap_TraceDepth* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceDepth");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TraceRecordingSessionReference (OSCTXT* pctxt, ranap_TraceRecordingSessionReference value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceRecordingSessionReference");

   stat = pe_ConsUnsigned (pctxt, value, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceRecordingSessionReference (OSCTXT* pctxt, ranap_TraceRecordingSessionReference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceRecordingSessionReference");

   stat = pd_ConsUInt16 (pctxt, pvalue, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_TraceReference (OSCTXT* pctxt, ranap_TraceReference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceReference");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(3), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceReference (OSCTXT* pctxt, ranap_TraceReference* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceReference");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(2), OSUINTCONST(3), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TraceReference (ranap_TraceReference* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TraceType (OSCTXT* pctxt, ranap_TraceType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceType");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceType (OSCTXT* pctxt, ranap_TraceType* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceType");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TraceType (ranap_TraceType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_TriggerID (OSCTXT* pctxt, ranap_TriggerID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggerID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(22), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TriggerID (OSCTXT* pctxt, ranap_TriggerID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TriggerID");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(3), OSUINTCONST(22), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TriggerID (ranap_TriggerID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

static const OSEnumItem ranap_TypeOfError_ENUMTAB[] = {
   { OSUTF8("missing"), 1, 7, 1 },
   { OSUTF8("not-understood"), 0, 14, 0 }
} ;
#define ranap_TypeOfError_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_TypeOfError_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_TypeOfError_ENUMTABSIZE) {
      return ranap_TypeOfError_ENUMTAB
         [ranap_TypeOfError_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_TypeOfError_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_TypeOfError* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_TypeOfError_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_TypeOfError_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ranap_TypeOfError* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ranap_TypeOfError_ENUMTAB, 
      ranap_TypeOfError_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_TypeOfError)ranap_TypeOfError_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_TypeOfError (OSCTXT* pctxt, ranap_TypeOfError value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfError");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TypeOfError (OSCTXT* pctxt, ranap_TypeOfError* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfError");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UE_AggregateMaximumBitRateDownlink (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRateDownlink value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRateDownlink");

   if ( (value >= 1 && value <= 1000000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 1000000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_AggregateMaximumBitRateDownlink (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRateDownlink* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRateDownlink");

   stat = pd_ConsUnsigned (pctxt, pvalue, 1, 1000000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UE_AggregateMaximumBitRateUplink (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRateUplink value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRateUplink");

   if ( (value >= 1 && value <= 1000000000) ) {
      stat = pe_ConsUnsigned (pctxt, value, 1, 1000000000);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_AggregateMaximumBitRateUplink (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRateUplink* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRateUplink");

   stat = pd_ConsUnsigned (pctxt, pvalue, 1, 1000000000);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UE_History_Information (OSCTXT* pctxt, ranap_UE_History_Information value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-History-Information");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_History_Information (OSCTXT* pctxt, ranap_UE_History_Information* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-History-Information");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UE_History_Information (
   ranap_UE_History_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_UE_History_Information (OSCTXT *pctxt, 
   ranap_UE_History_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_UE_Usage_Type (OSCTXT* pctxt, ranap_UE_Usage_Type value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-Usage-Type");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_Usage_Type (OSCTXT* pctxt, ranap_UE_Usage_Type* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-Usage-Type");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_UESBI_IuA (OSCTXT* pctxt, ranap_UESBI_IuA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-IuA");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UESBI_IuA (OSCTXT* pctxt, ranap_UESBI_IuA* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-IuA");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UESBI_IuA (ranap_UESBI_IuA* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_UESBI_IuB (OSCTXT* pctxt, ranap_UESBI_IuB* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-IuB");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UESBI_IuB (OSCTXT* pctxt, ranap_UESBI_IuB* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-IuB");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UESBI_IuB (ranap_UESBI_IuB* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_UPInitialisationFrame (OSCTXT* pctxt, ranap_UPInitialisationFrame value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UPInitialisationFrame");

   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UPInitialisationFrame (OSCTXT* pctxt, ranap_UPInitialisationFrame* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UPInitialisationFrame");

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UPInitialisationFrame (ranap_UPInitialisationFrame* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap_UPInitialisationFrame (OSCTXT *pctxt, 
   ranap_UPInitialisationFrame* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_USCH_ID (OSCTXT* pctxt, ranap_USCH_ID value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "USCH-ID");

   stat = pe_ConsUnsigned (pctxt, value, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_USCH_ID (OSCTXT* pctxt, ranap_USCH_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "USCH-ID");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_VerticalSpeedDirection_ENUMTAB[] = {
   { OSUTF8("downward"), 1, 8, 1 },
   { OSUTF8("upward"), 0, 6, 0 }
} ;
#define ranap_VerticalSpeedDirection_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_VerticalSpeedDirection_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_VerticalSpeedDirection_ENUMTABSIZE) {
      return ranap_VerticalSpeedDirection_ENUMTAB
         [ranap_VerticalSpeedDirection_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_VerticalSpeedDirection_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_VerticalSpeedDirection* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_VerticalSpeedDirection_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_VerticalSpeedDirection_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_VerticalSpeedDirection* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_VerticalSpeedDirection_ENUMTAB, 
      ranap_VerticalSpeedDirection_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_VerticalSpeedDirection)
         ranap_VerticalSpeedDirection_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_VerticalSpeedDirection (OSCTXT* pctxt, ranap_VerticalSpeedDirection value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalSpeedDirection");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_VerticalSpeedDirection (OSCTXT* pctxt, ranap_VerticalSpeedDirection* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalSpeedDirection");

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_VerticalAccuracyCode (OSCTXT* pctxt, ranap_VerticalAccuracyCode value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalAccuracyCode");

   if ( value <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, value, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_VerticalAccuracyCode (OSCTXT* pctxt, ranap_VerticalAccuracyCode* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalAccuracyCode");

   stat = pd_ConsUInt8 (pctxt, pvalue, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

static const OSEnumItem ranap_VoiceSupportMatchIndicator_ENUMTAB[] = {
   { OSUTF8("not-supported"), 1, 13, 1 },
   { OSUTF8("supported"), 0, 9, 0 }
} ;
#define ranap_VoiceSupportMatchIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_VoiceSupportMatchIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_VoiceSupportMatchIndicator_ENUMTABSIZE) {
      return ranap_VoiceSupportMatchIndicator_ENUMTAB
         [ranap_VoiceSupportMatchIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_VoiceSupportMatchIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_VoiceSupportMatchIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_VoiceSupportMatchIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_VoiceSupportMatchIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_VoiceSupportMatchIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_VoiceSupportMatchIndicator_ENUMTAB, 
      ranap_VoiceSupportMatchIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_VoiceSupportMatchIndicator)
         ranap_VoiceSupportMatchIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_VoiceSupportMatchIndicator (OSCTXT* pctxt, ranap_VoiceSupportMatchIndicator value)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VoiceSupportMatchIndicator");

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_VoiceSupportMatchIndicator (OSCTXT* pctxt, ranap_VoiceSupportMatchIndicator* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "VoiceSupportMatchIndicator");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (
   ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(56), OSUINTCONST(56), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (
   ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

static const OSEnumItem ranap_GeographicalCoordinates_latitudeSign_ENUMTAB[] = {
   { OSUTF8("north"), 0, 5, 0 },
   { OSUTF8("south"), 1, 5, 1 }
} ;
#define ranap_GeographicalCoordinates_latitudeSign_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_GeographicalCoordinates_latitudeSign_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_GeographicalCoordinates_latitudeSign_ENUMTABSIZE) {
      return ranap_GeographicalCoordinates_latitudeSign_ENUMTAB
         [ranap_GeographicalCoordinates_latitudeSign_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_GeographicalCoordinates_latitudeSign_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_GeographicalCoordinates_latitudeSign* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_GeographicalCoordinates_latitudeSign_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_GeographicalCoordinates_latitudeSign_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_GeographicalCoordinates_latitudeSign* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_GeographicalCoordinates_latitudeSign_ENUMTAB, 
      ranap_GeographicalCoordinates_latitudeSign_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_GeographicalCoordinates_latitudeSign)
         ranap_GeographicalCoordinates_latitudeSign_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_GeographicalCoordinates_latitudeSign (OSCTXT* pctxt, ranap_GeographicalCoordinates_latitudeSign value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_GeographicalCoordinates_latitudeSign (OSCTXT* pctxt, ranap_GeographicalCoordinates_latitudeSign* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTAB[] = {
   { OSUTF8("depth"), 1, 5, 1 },
   { OSUTF8("height"), 0, 6, 0 }
} ;
#define ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_GA_AltitudeAndDirection_directionOfAltitude_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTABSIZE) {
      return ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTAB
         [ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_GA_AltitudeAndDirection_directionOfAltitude_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ranap_GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_GA_AltitudeAndDirection_directionOfAltitude_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_GA_AltitudeAndDirection_directionOfAltitude_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTAB, 
      ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_GA_AltitudeAndDirection_directionOfAltitude)
         ranap_GA_AltitudeAndDirection_directionOfAltitude_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_GA_AltitudeAndDirection_directionOfAltitude (OSCTXT* pctxt, ranap_GA_AltitudeAndDirection_directionOfAltitude value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_AltitudeAndDirection_directionOfAltitude (OSCTXT* pctxt, ranap_GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

static const OSEnumItem ranap_InterfacesToTraceItem_interface__ENUMTAB[] = {
   { OSUTF8("iu-cs"), 0, 5, 0 },
   { OSUTF8("iu-ps"), 1, 5, 1 },
   { OSUTF8("iub"), 3, 3, 3 },
   { OSUTF8("iur"), 2, 3, 2 },
   { OSUTF8("uu"), 4, 2, 4 }
} ;
#define ranap_InterfacesToTraceItem_interface__ENUMTABSIZE 5

const OSUTF8CHAR* ranap_InterfacesToTraceItem_interface__ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_InterfacesToTraceItem_interface__ENUMTABSIZE) {
      return ranap_InterfacesToTraceItem_interface__ENUMTAB
         [ranap_InterfacesToTraceItem_interface__ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_InterfacesToTraceItem_interface__ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ranap_InterfacesToTraceItem_interface_* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_InterfacesToTraceItem_interface__ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_InterfacesToTraceItem_interface__ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_InterfacesToTraceItem_interface_* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_InterfacesToTraceItem_interface__ENUMTAB, 
      ranap_InterfacesToTraceItem_interface__ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_InterfacesToTraceItem_interface_)
         ranap_InterfacesToTraceItem_interface__ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_InterfacesToTraceItem_interface_ (OSCTXT* pctxt, ranap_InterfacesToTraceItem_interface_ value)
{
   int stat = 0;

   if (value >= 5) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(4));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_InterfacesToTraceItem_interface_ (OSCTXT* pctxt, ranap_InterfacesToTraceItem_interface_* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(4));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

static const OSEnumItem ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTAB[] = {
   { OSUTF8("emptylist"), 0, 9, 0 },
   { OSUTF8("fulllist"), 1, 8, 1 }
} ;
#define ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTABSIZE) {
      return ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTAB
         [ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTAB, 
      ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs)
         ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (OSCTXT* pctxt, ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   /* extension bit */

   stat = rtxEncBit (pctxt, 0);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (OSCTXT* pctxt, ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      *pvalue = 0x7fffffff;
   }
   else {
      stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   return (stat);
}

static const OSEnumItem ranap_RNCTraceInformation_traceActivationIndicator_ENUMTAB[] = {
   { OSUTF8("activated"), 0, 9, 0 },
   { OSUTF8("deactivated"), 1, 11, 1 }
} ;
#define ranap_RNCTraceInformation_traceActivationIndicator_ENUMTABSIZE 2

const OSUTF8CHAR* ranap_RNCTraceInformation_traceActivationIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ranap_RNCTraceInformation_traceActivationIndicator_ENUMTABSIZE) {
      return ranap_RNCTraceInformation_traceActivationIndicator_ENUMTAB
         [ranap_RNCTraceInformation_traceActivationIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ranap_RNCTraceInformation_traceActivationIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ranap_RNCTraceInformation_traceActivationIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ranap_RNCTraceInformation_traceActivationIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ranap_RNCTraceInformation_traceActivationIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ranap_RNCTraceInformation_traceActivationIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ranap_RNCTraceInformation_traceActivationIndicator_ENUMTAB, 
      ranap_RNCTraceInformation_traceActivationIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ranap_RNCTraceInformation_traceActivationIndicator)
         ranap_RNCTraceInformation_traceActivationIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

EXTERN int asn1PE_ranap_RNCTraceInformation_traceActivationIndicator (OSCTXT* pctxt, ranap_RNCTraceInformation_traceActivationIndicator value)
{
   int stat = 0;

   if (value >= 2) {
      rtxErrAddUIntParm (pctxt, value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
   stat = pe_ConsUnsigned (pctxt, value, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_RNCTraceInformation_traceActivationIndicator (OSCTXT* pctxt, ranap_RNCTraceInformation_traceActivationIndicator* pvalue)
{
   int stat = 0;

   stat = pd_ConsUnsigned (pctxt, pvalue, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PE_ranap_RSRVCC_Information_nonce (OSCTXT* pctxt, ranap_RSRVCC_Information_nonce* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRVCC_Information_nonce (OSCTXT* pctxt, ranap_RSRVCC_Information_nonce* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_RSRVCC_Information_nonce (
   ranap_RSRVCC_Information_nonce* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_RSRVCC_Information_iMSInformation (OSCTXT* pctxt, ranap_RSRVCC_Information_iMSInformation* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_OctetString (pctxt, pvalue->numocts, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRVCC_Information_iMSInformation (OSCTXT* pctxt, ranap_RSRVCC_Information_iMSInformation* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_OctetString (pctxt, &pvalue->numocts, pvalue->data, sizeof(pvalue->data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_RSRVCC_Information_iMSInformation (
   ranap_RSRVCC_Information_iMSInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   return 0;
}

EXTERN int asn1PE_ranap_SRVCC_Information_nonce (OSCTXT* pctxt, ranap_SRVCC_Information_nonce* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pe_BitString (pctxt, pvalue->numbits, pvalue->data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_Information_nonce (OSCTXT* pctxt, ranap_SRVCC_Information_nonce* pvalue)
{
   int stat = 0;

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(128), OSUINTCONST(128), 0, 0);

   stat = pd_BitString (pctxt, &pvalue->numbits, pvalue->data, sizeof(pvalue->
      data));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap_SRVCC_Information_nonce (
   ranap_SRVCC_Information_nonce* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numbits = 0;
   return 0;
}

EXTERN int asn1PE_ranap_LAI (OSCTXT* pctxt, ranap_LAI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LAI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lAC */

   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PE_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LAI (OSCTXT* pctxt, ranap_LAI* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LAI");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lAC */
   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PD_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LAI (ranap_LAI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_LAC (&pvalue->lAC);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_LAI (OSCTXT *pctxt, ranap_LAI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_Additional_CSPS_coordination_information (OSCTXT* pctxt, ranap_Additional_CSPS_coordination_information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-CSPS-coordination-information");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.old_LAIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.old_RACPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nRIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uE_is_AttachingPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode old_LAI */

   if (pvalue->m.old_LAIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "old-LAI");

      stat = asn1PE_ranap_LAI (pctxt, &pvalue->old_LAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode old_RAC */

   if (pvalue->m.old_RACPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "old-RAC");

      stat = asn1PE_ranap_RAC (pctxt, &pvalue->old_RAC);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nRI */

   if (pvalue->m.nRIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nRI");

      stat = asn1PE_ranap_NRI (pctxt, pvalue->nRI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uE_is_Attaching */

   if (pvalue->m.uE_is_AttachingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-is-Attaching");

      /* NULL */

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Additional_CSPS_coordination_information (OSCTXT* pctxt, ranap_Additional_CSPS_coordination_information* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-CSPS-coordination-information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode old_LAI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "old-LAI");

      pvalue->m.old_LAIPresent = 1;

      stat = asn1PD_ranap_LAI (pctxt, &pvalue->old_LAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode old_RAC */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "old-RAC");

      pvalue->m.old_RACPresent = 1;

      stat = asn1PD_ranap_RAC (pctxt, &pvalue->old_RAC);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nRI */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nRI");

      pvalue->m.nRIPresent = 1;

      stat = asn1PD_ranap_NRI (pctxt, &pvalue->nRI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uE_is_Attaching */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-is-Attaching");

      pvalue->m.uE_is_AttachingPresent = 1;

      /* NULL */

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Additional_CSPS_coordination_information (
   ranap_Additional_CSPS_coordination_information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAI (&pvalue->old_LAI);
   asn1Init_ranap_RAC (&pvalue->old_RAC);
   asn1Init_ranap_NRI (&pvalue->nRI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Additional_CSPS_coordination_information (OSCTXT *pctxt, 
   ranap_Additional_CSPS_coordination_information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.old_LAIPresent) {
      asn1Free_ranap_LAI (pctxt, &pvalue->old_LAI);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Additional_PositioningDataSet (OSCTXT* pctxt, ranap_Additional_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-PositioningDataSet");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Additional-PositioningMethodAndUsage", xx1);

      stat = asn1PE_ranap_Additional_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Additional_PositioningDataSet (OSCTXT* pctxt, ranap_Additional_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Additional-PositioningDataSet");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 3);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 8){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Additional-PositioningMethodAndUsage", xx1);

      asn1Init_ranap_Additional_PositioningMethodAndUsage (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_Additional_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Additional_PositioningDataSet (
   ranap_Additional_PositioningDataSet* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PE_ranap_ExtendedGuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PD_ranap_ExtendedGuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateList", xx1);

      stat = asn1PE_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (pctxt, ((ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altExtendedGuaranteedBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altExtendedGuaranteedBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altExtendedGuaranteedBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, pvalue->altExtendedGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altExtendedGuaranteedBitrates */

   if (pvalue->m.altExtendedGuaranteedBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altExtendedGuaranteedBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (pctxt, &pvalue->altExtendedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedGuaranteedBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altExtendedGuaranteedBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altExtendedGuaranteedBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, &pvalue->altExtendedGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altExtendedGuaranteedBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altExtendedGuaranteedBitrates");

      pvalue->m.altExtendedGuaranteedBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (pctxt, &pvalue->altExtendedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf (
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (&pvalue->altExtendedGuaranteedBitrates);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altExtendedGuaranteedBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (pctxt, &pvalue->altExtendedGuaranteedBitrates);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SupportedRAB_ParameterBitrateList (OSCTXT* pctxt, ranap_SupportedRAB_ParameterBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedRAB-ParameterBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBitrate", xx1);

      stat = asn1PE_ranap_SupportedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SupportedRAB_ParameterBitrateList (OSCTXT* pctxt, ranap_SupportedRAB_ParameterBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SupportedRAB-ParameterBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedBitrate", xx1);

      stat = asn1PD_ranap_SupportedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SupportedRAB_ParameterBitrateList (
   ranap_SupportedRAB_ParameterBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedGuaranteedBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedRAB-ParameterBitrateList", xx1);

      stat = asn1PE_ranap_SupportedRAB_ParameterBitrateList (pctxt, ((ranap_SupportedRAB_ParameterBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedGuaranteedBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_SupportedRAB_ParameterBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedRAB-ParameterBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_SupportedRAB_ParameterBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_SupportedRAB_ParameterBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_SupportedRAB_ParameterBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (
   ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SupportedRAB_ParameterBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SupportedRAB_ParameterBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedGuaranteedBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altSupportedGuaranteedBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altSupportedGuaranteedBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altSupportedGuaranteedBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, pvalue->altSupportedGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altSupportedGuaranteedBitrates */

   if (pvalue->m.altSupportedGuaranteedBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altSupportedGuaranteedBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (pctxt, &pvalue->altSupportedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedGuaranteedBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altSupportedGuaranteedBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altSupportedGuaranteedBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (pctxt, &pvalue->altSupportedGuaranteedBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altSupportedGuaranteedBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altSupportedGuaranteedBitrates");

      pvalue->m.altSupportedGuaranteedBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (pctxt, &pvalue->altSupportedGuaranteedBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf (
   ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (&pvalue->altSupportedGuaranteedBitrates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altSupportedGuaranteedBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (pctxt, &pvalue->altSupportedGuaranteedBitrates);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PE_ranap_ExtendedMaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PD_ranap_ExtendedMaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateList", xx1);

      stat = asn1PE_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (pctxt, ((ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altExtendedMaxBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altExtendedMaxBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altExtendedMaxBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, pvalue->altExtendedMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altExtendedMaxBitrates */

   if (pvalue->m.altExtendedMaxBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altExtendedMaxBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (pctxt, &pvalue->altExtendedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-ExtendedMaxBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altExtendedMaxBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altExtendedMaxBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, &pvalue->altExtendedMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altExtendedMaxBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altExtendedMaxBitrates");

      pvalue->m.altExtendedMaxBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (pctxt, &pvalue->altExtendedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf (
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (&pvalue->altExtendedMaxBitrates);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altExtendedMaxBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (pctxt, &pvalue->altExtendedMaxBitrates);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedMaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedMaxBitrates");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedRAB-ParameterBitrateList", xx1);

      stat = asn1PE_ranap_SupportedRAB_ParameterBitrateList (pctxt, ((ranap_SupportedRAB_ParameterBitrateList*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedMaxBitrates* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedMaxBitrates");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_SupportedRAB_ParameterBitrateList* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SupportedRAB-ParameterBitrateList", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_SupportedRAB_ParameterBitrateList, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_SupportedRAB_ParameterBitrateList (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_SupportedRAB_ParameterBitrateList (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (
   ranap_Alt_RAB_Parameter_SupportedMaxBitrates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_SupportedMaxBitrates* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SupportedRAB_ParameterBitrateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SupportedRAB_ParameterBitrateList*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedMaxBitrateInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.altSupportedMaxBitratesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode altSupportedMaxBitrateType */

   RTXCTXTPUSHELEMNAME (pctxt, "altSupportedMaxBitrateType");

   stat = asn1PE_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, pvalue->altSupportedMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altSupportedMaxBitrates */

   if (pvalue->m.altSupportedMaxBitratesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "altSupportedMaxBitrates");

      stat = asn1PE_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (pctxt, &pvalue->altSupportedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf (OSCTXT* pctxt, ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "Alt-RAB-Parameter-SupportedMaxBitrateInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode altSupportedMaxBitrateType */
   RTXCTXTPUSHELEMNAME (pctxt, "altSupportedMaxBitrateType");

   stat = asn1PD_ranap_Alt_RAB_Parameter_MaxBitrateType (pctxt, &pvalue->altSupportedMaxBitrateType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altSupportedMaxBitrates */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "altSupportedMaxBitrates");

      pvalue->m.altSupportedMaxBitratesPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (pctxt, &pvalue->altSupportedMaxBitrates);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf (
   ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (&pvalue->altSupportedMaxBitrates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf (OSCTXT *pctxt, 
   ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.altSupportedMaxBitratesPresent) {
      asn1Free_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (pctxt, &pvalue->altSupportedMaxBitrates);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SAI (OSCTXT* pctxt, ranap_SAI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SAI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lAC */

   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PE_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sAC */

   RTXCTXTPUSHELEMNAME (pctxt, "sAC");

   stat = asn1PE_ranap_SAC (pctxt, &pvalue->sAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SAI (OSCTXT* pctxt, ranap_SAI* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SAI");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lAC */
   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PD_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sAC */
   RTXCTXTPUSHELEMNAME (pctxt, "sAC");

   stat = asn1PD_ranap_SAC (pctxt, &pvalue->sAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SAI (ranap_SAI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_LAC (&pvalue->lAC);
   asn1Init_ranap_SAC (&pvalue->sAC);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_SAI (OSCTXT *pctxt, ranap_SAI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_GeographicalCoordinates (OSCTXT* pctxt, ranap_GeographicalCoordinates* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GeographicalCoordinates");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode latitudeSign */

   RTXCTXTPUSHELEMNAME (pctxt, "latitudeSign");

   stat = asn1PE_ranap_GeographicalCoordinates_latitudeSign (pctxt, pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode latitude */

   RTXCTXTPUSHELEMNAME (pctxt, "latitude");

   if ( pvalue->latitude <= 8388607 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->latitude, 0, 8388607);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->latitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode longitude */

   RTXCTXTPUSHELEMNAME (pctxt, "longitude");

   if ( (pvalue->longitude >= -8388608 && pvalue->longitude <= 8388607) ) {
      stat = pe_ConsInteger (pctxt, pvalue->longitude, -8388608, 8388607);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->longitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GeographicalCoordinates (OSCTXT* pctxt, ranap_GeographicalCoordinates* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GeographicalCoordinates");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode latitudeSign */
   RTXCTXTPUSHELEMNAME (pctxt, "latitudeSign");

   stat = asn1PD_ranap_GeographicalCoordinates_latitudeSign (pctxt, &pvalue->latitudeSign);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode latitude */
   RTXCTXTPUSHELEMNAME (pctxt, "latitude");

   stat = pd_ConsUnsigned (pctxt, &pvalue->latitude, 0, 8388607);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode longitude */
   RTXCTXTPUSHELEMNAME (pctxt, "longitude");

   stat = pd_ConsInteger (pctxt, &pvalue->longitude, -8388608, 8388607);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GeographicalCoordinates (
   ranap_GeographicalCoordinates* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GeographicalCoordinates (OSCTXT *pctxt, 
   ranap_GeographicalCoordinates* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_Point (OSCTXT* pctxt, ranap_GA_Point* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-Point");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_Point (OSCTXT* pctxt, ranap_GA_Point* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-Point");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_Point (ranap_GA_Point* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_Point (OSCTXT *pctxt, ranap_GA_Point* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_PointWithUnCertainty (OSCTXT* pctxt, ranap_GA_PointWithUnCertainty* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithUnCertainty");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uncertaintyCode */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyCode");

   if ( pvalue->uncertaintyCode <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyCode, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintyCode);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_PointWithUnCertainty (OSCTXT* pctxt, ranap_GA_PointWithUnCertainty* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithUnCertainty");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uncertaintyCode */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyCode");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyCode, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_PointWithUnCertainty (
   ranap_GA_PointWithUnCertainty* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_GA_PointWithUnCertainty (OSCTXT *pctxt, 
   ranap_GA_PointWithUnCertainty* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_GA_Polygon_element (OSCTXT* pctxt, ranap_GA_Polygon_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_GA_Polygon_element (OSCTXT* pctxt, ranap_GA_Polygon_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_GA_Polygon_element (ranap_GA_Polygon_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_Polygon_element (OSCTXT *pctxt, 
   ranap_GA_Polygon_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_Polygon (OSCTXT* pctxt, ranap_GA_Polygon* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-Polygon");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_GA_Polygon_element (pctxt, ((ranap_GA_Polygon_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_Polygon (OSCTXT* pctxt, ranap_GA_Polygon* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-Polygon");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_GA_Polygon_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_GA_Polygon_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_GA_Polygon_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_GA_Polygon_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_Polygon (ranap_GA_Polygon* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_GA_Polygon (OSCTXT *pctxt, ranap_GA_Polygon* pvalue)
{
   if (0 == pvalue) return;
   { ranap_GA_Polygon_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_GA_Polygon_element*)pnode->data;
      asn1Free_ranap_GA_Polygon_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_GA_UncertaintyEllipse (OSCTXT* pctxt, ranap_GA_UncertaintyEllipse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-UncertaintyEllipse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uncertaintySemi_major */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-major");

   if ( pvalue->uncertaintySemi_major <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_major, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintySemi_major);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintySemi_minor */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-minor");

   if ( pvalue->uncertaintySemi_minor <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySemi_minor, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintySemi_minor);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode orientationOfMajorAxis */

   RTXCTXTPUSHELEMNAME (pctxt, "orientationOfMajorAxis");

   if ( pvalue->orientationOfMajorAxis <= 179 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->orientationOfMajorAxis, 0, 179);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->orientationOfMajorAxis);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_UncertaintyEllipse (OSCTXT* pctxt, ranap_GA_UncertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-UncertaintyEllipse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode uncertaintySemi_major */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-major");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_major, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintySemi_minor */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySemi-minor");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySemi_minor, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode orientationOfMajorAxis */
   RTXCTXTPUSHELEMNAME (pctxt, "orientationOfMajorAxis");

   stat = pd_ConsUInt8 (pctxt, &pvalue->orientationOfMajorAxis, 0, 179);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_UncertaintyEllipse (ranap_GA_UncertaintyEllipse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_UncertaintyEllipse (OSCTXT *pctxt, 
   ranap_GA_UncertaintyEllipse* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_PointWithUnCertaintyEllipse (OSCTXT* pctxt, ranap_GA_PointWithUnCertaintyEllipse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithUnCertaintyEllipse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintyEllipse */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyEllipse");

   stat = asn1PE_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode confidence */

   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   if ( pvalue->confidence <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->confidence);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_PointWithUnCertaintyEllipse (OSCTXT* pctxt, ranap_GA_PointWithUnCertaintyEllipse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithUnCertaintyEllipse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintyEllipse */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyEllipse");

   stat = asn1PD_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidence */
   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_PointWithUnCertaintyEllipse (
   ranap_GA_PointWithUnCertaintyEllipse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_GA_UncertaintyEllipse (&pvalue->uncertaintyEllipse);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_PointWithUnCertaintyEllipse (OSCTXT *pctxt, 
   ranap_GA_PointWithUnCertaintyEllipse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   asn1Free_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_AltitudeAndDirection (OSCTXT* pctxt, ranap_GA_AltitudeAndDirection* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-AltitudeAndDirection");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode directionOfAltitude */

   RTXCTXTPUSHELEMNAME (pctxt, "directionOfAltitude");

   stat = asn1PE_ranap_GA_AltitudeAndDirection_directionOfAltitude (pctxt, pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altitude */

   RTXCTXTPUSHELEMNAME (pctxt, "altitude");

   if ( pvalue->altitude <= 32767 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->altitude, 0, 32767);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->altitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_AltitudeAndDirection (OSCTXT* pctxt, ranap_GA_AltitudeAndDirection* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-AltitudeAndDirection");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode directionOfAltitude */
   RTXCTXTPUSHELEMNAME (pctxt, "directionOfAltitude");

   stat = asn1PD_ranap_GA_AltitudeAndDirection_directionOfAltitude (pctxt, &pvalue->directionOfAltitude);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altitude */
   RTXCTXTPUSHELEMNAME (pctxt, "altitude");

   stat = pd_ConsUInt16 (pctxt, &pvalue->altitude, 0, 32767);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_AltitudeAndDirection (
   ranap_GA_AltitudeAndDirection* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_AltitudeAndDirection (OSCTXT *pctxt, 
   ranap_GA_AltitudeAndDirection* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_PointWithAltitude (OSCTXT* pctxt, ranap_GA_PointWithAltitude* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithAltitude");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altitudeAndDirection */

   RTXCTXTPUSHELEMNAME (pctxt, "altitudeAndDirection");

   stat = asn1PE_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_PointWithAltitude (OSCTXT* pctxt, ranap_GA_PointWithAltitude* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithAltitude");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altitudeAndDirection */
   RTXCTXTPUSHELEMNAME (pctxt, "altitudeAndDirection");

   stat = asn1PD_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_PointWithAltitude (ranap_GA_PointWithAltitude* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_GA_AltitudeAndDirection (&pvalue->altitudeAndDirection);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_PointWithAltitude (OSCTXT *pctxt, 
   ranap_GA_PointWithAltitude* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   asn1Free_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (OSCTXT* pctxt, ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithAltitudeAndUncertaintyEllipsoid");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode altitudeAndDirection */

   RTXCTXTPUSHELEMNAME (pctxt, "altitudeAndDirection");

   stat = asn1PE_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintyEllipse */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyEllipse");

   stat = asn1PE_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintyAltitude */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyAltitude");

   if ( pvalue->uncertaintyAltitude <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyAltitude, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintyAltitude);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode confidence */

   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   if ( pvalue->confidence <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->confidence);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (OSCTXT* pctxt, ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-PointWithAltitudeAndUncertaintyEllipsoid");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode altitudeAndDirection */
   RTXCTXTPUSHELEMNAME (pctxt, "altitudeAndDirection");

   stat = asn1PD_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintyEllipse */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyEllipse");

   stat = asn1PD_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintyAltitude */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyAltitude");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyAltitude, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidence */
   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (
   ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_GA_AltitudeAndDirection (&pvalue->altitudeAndDirection);
   asn1Init_ranap_GA_UncertaintyEllipse (&pvalue->uncertaintyEllipse);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (OSCTXT *pctxt, 
   ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   asn1Free_ranap_GA_AltitudeAndDirection (pctxt, &pvalue->altitudeAndDirection);
   asn1Free_ranap_GA_UncertaintyEllipse (pctxt, &pvalue->uncertaintyEllipse);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GA_EllipsoidArc (OSCTXT* pctxt, ranap_GA_EllipsoidArc* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GA-EllipsoidArc");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode geographicalCoordinates */

   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PE_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode innerRadius */

   RTXCTXTPUSHELEMNAME (pctxt, "innerRadius");

   stat = pe_ConsUnsigned (pctxt, pvalue->innerRadius, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintyRadius */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyRadius");

   if ( pvalue->uncertaintyRadius <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintyRadius, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->uncertaintyRadius);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode offsetAngle */

   RTXCTXTPUSHELEMNAME (pctxt, "offsetAngle");

   if ( pvalue->offsetAngle <= 179 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->offsetAngle, 0, 179);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->offsetAngle);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode includedAngle */

   RTXCTXTPUSHELEMNAME (pctxt, "includedAngle");

   if ( pvalue->includedAngle <= 179 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->includedAngle, 0, 179);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->includedAngle);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode confidence */

   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   if ( pvalue->confidence <= 127 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->confidence, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->confidence);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GA_EllipsoidArc (OSCTXT* pctxt, ranap_GA_EllipsoidArc* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GA-EllipsoidArc");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode geographicalCoordinates */
   RTXCTXTPUSHELEMNAME (pctxt, "geographicalCoordinates");

   stat = asn1PD_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode innerRadius */
   RTXCTXTPUSHELEMNAME (pctxt, "innerRadius");

   stat = pd_ConsUInt16 (pctxt, &pvalue->innerRadius, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintyRadius */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintyRadius");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintyRadius, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode offsetAngle */
   RTXCTXTPUSHELEMNAME (pctxt, "offsetAngle");

   stat = pd_ConsUInt8 (pctxt, &pvalue->offsetAngle, 0, 179);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode includedAngle */
   RTXCTXTPUSHELEMNAME (pctxt, "includedAngle");

   stat = pd_ConsUInt8 (pctxt, &pvalue->includedAngle, 0, 179);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode confidence */
   RTXCTXTPUSHELEMNAME (pctxt, "confidence");

   stat = pd_ConsUInt8 (pctxt, &pvalue->confidence, 0, 127);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GA_EllipsoidArc (ranap_GA_EllipsoidArc* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_GeographicalCoordinates (&pvalue->geographicalCoordinates);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GA_EllipsoidArc (OSCTXT *pctxt, 
   ranap_GA_EllipsoidArc* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_GeographicalCoordinates (pctxt, &pvalue->geographicalCoordinates);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GeographicalArea (OSCTXT* pctxt, ranap_GeographicalArea* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GeographicalArea");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 3);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* point */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "point");

            stat = asn1PE_ranap_GA_Point (pctxt, pvalue->u.point);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* pointWithUnCertainty */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "pointWithUnCertainty");

            stat = asn1PE_ranap_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* polygon */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "polygon");

            stat = asn1PE_ranap_GA_Polygon (pctxt, pvalue->u.polygon);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 4);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* pointWithUncertaintyEllipse */
         case 4:
            stat = asn1PE_ranap_GA_PointWithUnCertaintyEllipse (pctxt, pvalue->u.pointWithUncertaintyEllipse);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* pointWithAltitude */
         case 5:
            stat = asn1PE_ranap_GA_PointWithAltitude (pctxt, pvalue->u.pointWithAltitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* pointWithAltitudeAndUncertaintyEllipsoid */
         case 6:
            stat = asn1PE_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (pctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         /* ellipsoidArc */
         case 7:
            stat = asn1PE_ranap_GA_EllipsoidArc (pctxt, pvalue->u.ellipsoidArc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GeographicalArea (OSCTXT* pctxt, ranap_GeographicalArea* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "GeographicalArea");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(2));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* point */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "point");

            pvalue->u.point = rtxMemAllocType (pctxt, ranap_GA_Point);

            if (pvalue->u.point == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_Point (pvalue->u.point);

            stat = asn1PD_ranap_GA_Point (pctxt, pvalue->u.point);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* pointWithUnCertainty */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "pointWithUnCertainty");

            pvalue->u.pointWithUnCertainty = rtxMemAllocType (pctxt, 
               ranap_GA_PointWithUnCertainty);

            if (pvalue->u.pointWithUnCertainty == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_PointWithUnCertainty (pvalue->u.pointWithUnCertainty);

            stat = asn1PD_ranap_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* polygon */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "polygon");

            pvalue->u.polygon = rtxMemAllocType (pctxt, ranap_GA_Polygon);

            if (pvalue->u.polygon == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_Polygon (pvalue->u.polygon);

            stat = asn1PD_ranap_GA_Polygon (pctxt, pvalue->u.polygon);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 4;

      if (pvalue->t < 4) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 8) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* pointWithUncertaintyEllipse */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "pointWithUncertaintyEllipse");

            pvalue->u.pointWithUncertaintyEllipse = rtxMemAllocType (pctxt, 
               ranap_GA_PointWithUnCertaintyEllipse);

            if (pvalue->u.pointWithUncertaintyEllipse == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_PointWithUnCertaintyEllipse (pvalue->u.pointWithUncertaintyEllipse);

            stat = asn1PD_ranap_GA_PointWithUnCertaintyEllipse (pctxt, pvalue->u.pointWithUncertaintyEllipse);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* pointWithAltitude */
         case 5:
            RTXCTXTPUSHELEMNAME (pctxt, "pointWithAltitude");

            pvalue->u.pointWithAltitude = rtxMemAllocType (pctxt, 
               ranap_GA_PointWithAltitude);

            if (pvalue->u.pointWithAltitude == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_PointWithAltitude (pvalue->u.pointWithAltitude);

            stat = asn1PD_ranap_GA_PointWithAltitude (pctxt, pvalue->u.pointWithAltitude);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* pointWithAltitudeAndUncertaintyEllipsoid */
         case 6:
            RTXCTXTPUSHELEMNAME (pctxt, "pointWithAltitudeAndUncertaintyEllipsoid");

            pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid
                = rtxMemAllocType (pctxt, 
               ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid);

            if (pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);

            stat = asn1PD_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (pctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* ellipsoidArc */
         case 7:
            RTXCTXTPUSHELEMNAME (pctxt, "ellipsoidArc");

            pvalue->u.ellipsoidArc = rtxMemAllocType (pctxt, 
               ranap_GA_EllipsoidArc);

            if (pvalue->u.ellipsoidArc == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GA_EllipsoidArc (pvalue->u.ellipsoidArc);

            stat = asn1PD_ranap_GA_EllipsoidArc (pctxt, pvalue->u.ellipsoidArc);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 8) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GeographicalArea (ranap_GeographicalArea* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_GeographicalArea (OSCTXT *pctxt, 
   ranap_GeographicalArea* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.point) {
            asn1Free_ranap_GA_Point (pctxt, pvalue->u.point);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.point);
            pvalue->u.point = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.pointWithUnCertainty) {
            asn1Free_ranap_GA_PointWithUnCertainty (pctxt, pvalue->u.pointWithUnCertainty);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pointWithUnCertainty);
            pvalue->u.pointWithUnCertainty = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.polygon) {
            asn1Free_ranap_GA_Polygon (pctxt, pvalue->u.polygon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.polygon);
            pvalue->u.polygon = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.pointWithUncertaintyEllipse) {
            asn1Free_ranap_GA_PointWithUnCertaintyEllipse (pctxt, pvalue->u.pointWithUncertaintyEllipse);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pointWithUncertaintyEllipse);
            pvalue->u.pointWithUncertaintyEllipse = 0;
         }
         break;

      case 5:
         if (0 != pvalue->u.pointWithAltitude) {
            asn1Free_ranap_GA_PointWithAltitude (pctxt, pvalue->u.pointWithAltitude);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pointWithAltitude);
            pvalue->u.pointWithAltitude = 0;
         }
         break;

      case 6:
         if (0 != pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid) {
            asn1Free_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (pctxt, pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid);
            pvalue->u.pointWithAltitudeAndUncertaintyEllipsoid = 0;
         }
         break;

      case 7:
         if (0 != pvalue->u.ellipsoidArc) {
            asn1Free_ranap_GA_EllipsoidArc (pctxt, pvalue->u.ellipsoidArc);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ellipsoidArc);
            pvalue->u.ellipsoidArc = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_AreaIdentity (OSCTXT* pctxt, ranap_AreaIdentity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaIdentity");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sAI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sAI");

            stat = asn1PE_ranap_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* geographicalArea */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "geographicalArea");

            stat = asn1PE_ranap_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AreaIdentity (OSCTXT* pctxt, ranap_AreaIdentity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "AreaIdentity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sAI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "sAI");

            pvalue->u.sAI = rtxMemAllocType (pctxt, ranap_SAI);

            if (pvalue->u.sAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_SAI (pvalue->u.sAI);

            stat = asn1PD_ranap_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* geographicalArea */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "geographicalArea");

            pvalue->u.geographicalArea = rtxMemAllocType (pctxt, 
               ranap_GeographicalArea);

            if (pvalue->u.geographicalArea == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GeographicalArea (pvalue->u.geographicalArea);

            stat = asn1PD_ranap_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_AreaIdentity (ranap_AreaIdentity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_AreaIdentity (OSCTXT *pctxt, ranap_AreaIdentity* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sAI) {
            asn1Free_ranap_SAI (pctxt, pvalue->u.sAI);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sAI);
            pvalue->u.sAI = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.geographicalArea) {
            asn1Free_ranap_GeographicalArea (pctxt, pvalue->u.geographicalArea);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.geographicalArea);
            pvalue->u.geographicalArea = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PE_ranap_ExtendedGuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PD_ranap_ExtendedGuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList (
   ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-ExtendedMaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PE_ranap_ExtendedMaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Ass-RAB-Parameter-ExtendedMaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PD_ranap_ExtendedMaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList (
   ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_AuthorisedSNAs (OSCTXT* pctxt, ranap_AuthorisedSNAs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorisedSNAs");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SNAC", xx1);

         stat = asn1PE_ranap_SNAC (pctxt, *((ranap_SNAC*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AuthorisedSNAs (OSCTXT* pctxt, ranap_AuthorisedSNAs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorisedSNAs");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_SNAC* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SNAC", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_SNAC, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_SNAC (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_AuthorisedSNAs (ranap_AuthorisedSNAs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_AuthorisedSNAs (OSCTXT *pctxt, 
   ranap_AuthorisedSNAs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SNAC* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SNAC*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_AuthorisedPLMNs_element (OSCTXT* pctxt, ranap_AuthorisedPLMNs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.authorisedSNAsListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode authorisedSNAsList */

   if (pvalue->m.authorisedSNAsListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "authorisedSNAsList");

      stat = asn1PE_ranap_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_AuthorisedPLMNs_element (OSCTXT* pctxt, ranap_AuthorisedPLMNs_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode authorisedSNAsList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "authorisedSNAsList");

      pvalue->m.authorisedSNAsListPresent = 1;

      stat = asn1PD_ranap_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_AuthorisedPLMNs_element (
   ranap_AuthorisedPLMNs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_AuthorisedSNAs (&pvalue->authorisedSNAsList);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_AuthorisedPLMNs_element (OSCTXT *pctxt, 
   ranap_AuthorisedPLMNs_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.authorisedSNAsListPresent) {
      asn1Free_ranap_AuthorisedSNAs (pctxt, &pvalue->authorisedSNAsList);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_AuthorisedPLMNs (OSCTXT* pctxt, ranap_AuthorisedPLMNs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorisedPLMNs");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_AuthorisedPLMNs_element (pctxt, ((ranap_AuthorisedPLMNs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_AuthorisedPLMNs (OSCTXT* pctxt, ranap_AuthorisedPLMNs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorisedPLMNs");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_AuthorisedPLMNs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_AuthorisedPLMNs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_AuthorisedPLMNs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_AuthorisedPLMNs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_AuthorisedPLMNs (ranap_AuthorisedPLMNs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_AuthorisedPLMNs (OSCTXT *pctxt, 
   ranap_AuthorisedPLMNs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_AuthorisedPLMNs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_AuthorisedPLMNs_element*)pnode->data;
      asn1Free_ranap_AuthorisedPLMNs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_BroadcastAssistanceDataDecipheringKeys (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastAssistanceDataDecipheringKeys");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cipheringKeyFlag */

   RTXCTXTPUSHELEMNAME (pctxt, "cipheringKeyFlag");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->cipheringKeyFlag, OSUINTCONST(1), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode currentDecipheringKey */

   RTXCTXTPUSHELEMNAME (pctxt, "currentDecipheringKey");

   stat = asn1PE_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (pctxt, &pvalue->currentDecipheringKey);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nextDecipheringKey */

   RTXCTXTPUSHELEMNAME (pctxt, "nextDecipheringKey");

   stat = asn1PE_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (pctxt, &pvalue->nextDecipheringKey);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_BroadcastAssistanceDataDecipheringKeys (OSCTXT* pctxt, ranap_BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "BroadcastAssistanceDataDecipheringKeys");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode cipheringKeyFlag */
   RTXCTXTPUSHELEMNAME (pctxt, "cipheringKeyFlag");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(1), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->cipheringKeyFlag
      , OSUINTCONST(1), OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode currentDecipheringKey */
   RTXCTXTPUSHELEMNAME (pctxt, "currentDecipheringKey");

   stat = asn1PD_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (pctxt, &pvalue->currentDecipheringKey);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nextDecipheringKey */
   RTXCTXTPUSHELEMNAME (pctxt, "nextDecipheringKey");

   stat = asn1PD_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (pctxt, &pvalue->nextDecipheringKey);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_BroadcastAssistanceDataDecipheringKeys (
   ranap_BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->cipheringKeyFlag.numbits = 0;
   asn1Init_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (&pvalue->currentDecipheringKey);
   asn1Init_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (&pvalue->nextDecipheringKey);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_BroadcastAssistanceDataDecipheringKeys (OSCTXT *pctxt, 
   ranap_BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CellIdList (OSCTXT* pctxt, ranap_CellIdList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIdList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Cell-Id", xx1);

      stat = asn1PE_ranap_Cell_Id (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CellIdList (OSCTXT* pctxt, ranap_CellIdList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CellIdList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 5);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 32){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Cell-Id", xx1);

      stat = asn1PD_ranap_Cell_Id (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CellIdList (ranap_CellIdList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_CellBased (OSCTXT* pctxt, ranap_CellBased* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellBased");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cellIdList */

   RTXCTXTPUSHELEMNAME (pctxt, "cellIdList");

   stat = asn1PE_ranap_CellIdList (pctxt, &pvalue->cellIdList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CellBased (OSCTXT* pctxt, ranap_CellBased* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CellBased");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cellIdList */
   RTXCTXTPUSHELEMNAME (pctxt, "cellIdList");

   stat = asn1PD_ranap_CellIdList (pctxt, &pvalue->cellIdList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CellBased (ranap_CellBased* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_CellIdList (&pvalue->cellIdList);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CellBased (OSCTXT *pctxt, ranap_CellBased* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CellLoadInformation (OSCTXT* pctxt, ranap_CellLoadInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellLoadInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rTLoadValuePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nRTLoadInformationValuePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cell_Capacity_Class_Value */

   RTXCTXTPUSHELEMNAME (pctxt, "cell-Capacity-Class-Value");

   stat = asn1PE_ranap_Cell_Capacity_Class_Value (pctxt, pvalue->cell_Capacity_Class_Value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode loadValue */

   RTXCTXTPUSHELEMNAME (pctxt, "loadValue");

   stat = asn1PE_ranap_LoadValue (pctxt, pvalue->loadValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rTLoadValue */

   if (pvalue->m.rTLoadValuePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rTLoadValue");

      stat = asn1PE_ranap_RTLoadValue (pctxt, pvalue->rTLoadValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode nRTLoadInformationValue */

   if (pvalue->m.nRTLoadInformationValuePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nRTLoadInformationValue");

      stat = asn1PE_ranap_NRTLoadInformationValue (pctxt, pvalue->nRTLoadInformationValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CellLoadInformation (OSCTXT* pctxt, ranap_CellLoadInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "CellLoadInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cell_Capacity_Class_Value */
   RTXCTXTPUSHELEMNAME (pctxt, "cell-Capacity-Class-Value");

   stat = asn1PD_ranap_Cell_Capacity_Class_Value (pctxt, &pvalue->cell_Capacity_Class_Value);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode loadValue */
   RTXCTXTPUSHELEMNAME (pctxt, "loadValue");

   stat = asn1PD_ranap_LoadValue (pctxt, &pvalue->loadValue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rTLoadValue */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rTLoadValue");

      pvalue->m.rTLoadValuePresent = 1;

      stat = asn1PD_ranap_RTLoadValue (pctxt, &pvalue->rTLoadValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode nRTLoadInformationValue */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nRTLoadInformationValue");

      pvalue->m.nRTLoadInformationValuePresent = 1;

      stat = asn1PD_ranap_NRTLoadInformationValue (pctxt, &pvalue->nRTLoadInformationValue);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CellLoadInformation (ranap_CellLoadInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CellLoadInformation (OSCTXT *pctxt, 
   ranap_CellLoadInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SourceUTRANCellID (OSCTXT* pctxt, ranap_SourceUTRANCellID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceUTRANCellID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uTRANcellID */

   RTXCTXTPUSHELEMNAME (pctxt, "uTRANcellID");

   stat = asn1PE_ranap_TargetCellId (pctxt, pvalue->uTRANcellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceUTRANCellID (OSCTXT* pctxt, ranap_SourceUTRANCellID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceUTRANCellID");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uTRANcellID */
   RTXCTXTPUSHELEMNAME (pctxt, "uTRANcellID");

   stat = asn1PD_ranap_TargetCellId (pctxt, &pvalue->uTRANcellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceUTRANCellID (ranap_SourceUTRANCellID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_SourceUTRANCellID (OSCTXT *pctxt, 
   ranap_SourceUTRANCellID* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_CGI (OSCTXT* pctxt, ranap_CGI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CGI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lAC */

   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PE_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cI */

   RTXCTXTPUSHELEMNAME (pctxt, "cI");

   stat = asn1PE_ranap_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CGI (OSCTXT* pctxt, ranap_CGI* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CGI");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lAC */
   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PD_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cI */
   RTXCTXTPUSHELEMNAME (pctxt, "cI");

   stat = asn1PD_ranap_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CGI (ranap_CGI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_LAC (&pvalue->lAC);
   asn1Init_ranap_CI (&pvalue->cI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_CGI (OSCTXT *pctxt, ranap_CGI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_SourceCellID (OSCTXT* pctxt, ranap_SourceCellID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceCellID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sourceUTRANCellID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceUTRANCellID");

            stat = asn1PE_ranap_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* sourceGERANCellID */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceGERANCellID");

            stat = asn1PE_ranap_CGI (pctxt, pvalue->u.sourceGERANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceCellID (OSCTXT* pctxt, ranap_SourceCellID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceCellID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceUTRANCellID */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceUTRANCellID");

            pvalue->u.sourceUTRANCellID = rtxMemAllocType (pctxt, 
               ranap_SourceUTRANCellID);

            if (pvalue->u.sourceUTRANCellID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_SourceUTRANCellID (pvalue->u.sourceUTRANCellID);

            stat = asn1PD_ranap_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sourceGERANCellID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceGERANCellID");

            pvalue->u.sourceGERANCellID = rtxMemAllocType (pctxt, ranap_CGI);

            if (pvalue->u.sourceGERANCellID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_CGI (pvalue->u.sourceGERANCellID);

            stat = asn1PD_ranap_CGI (pctxt, pvalue->u.sourceGERANCellID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceCellID (ranap_SourceCellID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_SourceCellID (OSCTXT *pctxt, ranap_SourceCellID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sourceUTRANCellID) {
            asn1Free_ranap_SourceUTRANCellID (pctxt, pvalue->u.sourceUTRANCellID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sourceUTRANCellID);
            pvalue->u.sourceUTRANCellID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.sourceGERANCellID) {
            asn1Free_ranap_CGI (pctxt, pvalue->u.sourceGERANCellID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sourceGERANCellID);
            pvalue->u.sourceGERANCellID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_CellLoadInformationGroup (OSCTXT* pctxt, ranap_CellLoadInformationGroup* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CellLoadInformationGroup");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uplinkCellLoadInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.downlinkCellLoadInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sourceCellID */

   RTXCTXTPUSHELEMNAME (pctxt, "sourceCellID");

   stat = asn1PE_ranap_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkCellLoadInformation");

      stat = asn1PE_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "downlinkCellLoadInformation");

      stat = asn1PE_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CellLoadInformationGroup (OSCTXT* pctxt, ranap_CellLoadInformationGroup* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "CellLoadInformationGroup");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sourceCellID */
   RTXCTXTPUSHELEMNAME (pctxt, "sourceCellID");

   stat = asn1PD_ranap_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uplinkCellLoadInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkCellLoadInformation");

      pvalue->m.uplinkCellLoadInformationPresent = 1;

      stat = asn1PD_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode downlinkCellLoadInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "downlinkCellLoadInformation");

      pvalue->m.downlinkCellLoadInformationPresent = 1;

      stat = asn1PD_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CellLoadInformationGroup (
   ranap_CellLoadInformationGroup* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_SourceCellID (&pvalue->sourceCellID);
   asn1Init_ranap_CellLoadInformation (&pvalue->uplinkCellLoadInformation);
   asn1Init_ranap_CellLoadInformation (&pvalue->downlinkCellLoadInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CellLoadInformationGroup (OSCTXT *pctxt, 
   ranap_CellLoadInformationGroup* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_SourceCellID (pctxt, &pvalue->sourceCellID);
   if (pvalue->m.uplinkCellLoadInformationPresent) {
      asn1Free_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
   }
   if (pvalue->m.downlinkCellLoadInformationPresent) {
      asn1Free_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, ranap_CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iECriticality */

   RTXCTXTPUSHELEMNAME (pctxt, "iECriticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PE_ranap_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionNumber");

      stat = asn1PE_ranap_RepetitionNumber0 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_CriticalityDiagnostics_IE_List_element (OSCTXT* pctxt, ranap_CriticalityDiagnostics_IE_List_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iECriticality */
   RTXCTXTPUSHELEMNAME (pctxt, "iECriticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->iECriticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PD_ranap_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionNumber */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionNumber");

      pvalue->m.repetitionNumberPresent = 1;

      stat = asn1PD_ranap_RepetitionNumber0 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_CriticalityDiagnostics_IE_List_element (
   ranap_CriticalityDiagnostics_IE_List_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CriticalityDiagnostics_IE_List_element (OSCTXT *pctxt, 
   ranap_CriticalityDiagnostics_IE_List_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, ranap_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_CriticalityDiagnostics_IE_List_element (pctxt, ((ranap_CriticalityDiagnostics_IE_List_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CriticalityDiagnostics_IE_List (OSCTXT* pctxt, ranap_CriticalityDiagnostics_IE_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics-IE-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_CriticalityDiagnostics_IE_List_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_CriticalityDiagnostics_IE_List_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_CriticalityDiagnostics_IE_List_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CriticalityDiagnostics_IE_List (
   ranap_CriticalityDiagnostics_IE_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_CriticalityDiagnostics_IE_List (OSCTXT *pctxt, 
   ranap_CriticalityDiagnostics_IE_List* pvalue)
{
   if (0 == pvalue) return;
   { ranap_CriticalityDiagnostics_IE_List_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_CriticalityDiagnostics_IE_List_element*)pnode->data;
      asn1Free_ranap_CriticalityDiagnostics_IE_List_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_CriticalityDiagnostics (OSCTXT* pctxt, ranap_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.procedureCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.triggeringMessagePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.procedureCriticalityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iEsCriticalityDiagnosticsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode procedureCode */

   if (pvalue->m.procedureCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

      stat = asn1PE_ranap_ProcedureCode (pctxt, pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode triggeringMessage */

   if (pvalue->m.triggeringMessagePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "triggeringMessage");

      stat = asn1PE_ranap_TriggeringMessage (pctxt, pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode procedureCriticality */

   if (pvalue->m.procedureCriticalityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCriticality");

      stat = asn1PE_ranap_Criticality (pctxt, pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iEsCriticalityDiagnostics */

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iEsCriticalityDiagnostics");

      stat = asn1PE_ranap_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CriticalityDiagnostics (OSCTXT* pctxt, ranap_CriticalityDiagnostics* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "CriticalityDiagnostics");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode procedureCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

      pvalue->m.procedureCodePresent = 1;

      stat = asn1PD_ranap_ProcedureCode (pctxt, &pvalue->procedureCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode triggeringMessage */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "triggeringMessage");

      pvalue->m.triggeringMessagePresent = 1;

      stat = asn1PD_ranap_TriggeringMessage (pctxt, &pvalue->triggeringMessage);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode procedureCriticality */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "procedureCriticality");

      pvalue->m.procedureCriticalityPresent = 1;

      stat = asn1PD_ranap_Criticality (pctxt, &pvalue->procedureCriticality);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iEsCriticalityDiagnostics */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iEsCriticalityDiagnostics");

      pvalue->m.iEsCriticalityDiagnosticsPresent = 1;

      stat = asn1PD_ranap_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CriticalityDiagnostics (
   ranap_CriticalityDiagnostics* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_CriticalityDiagnostics_IE_List (&pvalue->iEsCriticalityDiagnostics);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CriticalityDiagnostics (OSCTXT *pctxt, 
   ranap_CriticalityDiagnostics* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Free_ranap_CriticalityDiagnostics_IE_List (pctxt, &pvalue->iEsCriticalityDiagnostics);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MessageStructure_element (OSCTXT* pctxt, ranap_MessageStructure_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.repetitionNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iE_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PE_ranap_ProtocolIE_ID (pctxt, pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode repetitionNumber */

   if (pvalue->m.repetitionNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionNumber");

      stat = asn1PE_ranap_RepetitionNumber1 (pctxt, pvalue->repetitionNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_MessageStructure_element (OSCTXT* pctxt, ranap_MessageStructure_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "iE-ID");

   stat = asn1PD_ranap_ProtocolIE_ID (pctxt, &pvalue->iE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode repetitionNumber */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "repetitionNumber");

      pvalue->m.repetitionNumberPresent = 1;

      stat = asn1PD_ranap_RepetitionNumber1 (pctxt, &pvalue->repetitionNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_MessageStructure_element (
   ranap_MessageStructure_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MessageStructure_element (OSCTXT *pctxt, 
   ranap_MessageStructure_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MessageStructure (OSCTXT* pctxt, ranap_MessageStructure* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MessageStructure");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_MessageStructure_element (pctxt, ((ranap_MessageStructure_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MessageStructure (OSCTXT* pctxt, ranap_MessageStructure* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MessageStructure");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_MessageStructure_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_MessageStructure_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_MessageStructure_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_MessageStructure_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MessageStructure (ranap_MessageStructure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_MessageStructure (OSCTXT *pctxt, 
   ranap_MessageStructure* pvalue)
{
   if (0 == pvalue) return;
   { ranap_MessageStructure_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_MessageStructure_element*)pnode->data;
      asn1Free_ranap_MessageStructure_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_CSG_Id_List (OSCTXT* pctxt, ranap_CSG_Id_List* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Id-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CSG-Id", xx1);

      stat = asn1PE_ranap_CSG_Id (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CSG_Id_List (OSCTXT* pctxt, ranap_CSG_Id_List* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSG-Id-List");

   /* decode length determinant */

   if (pctxt->buffer.aligned)  {
      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 8);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 256){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CSG-Id", xx1);

      asn1Init_ranap_CSG_Id (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_CSG_Id (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CSG_Id_List (ranap_CSG_Id_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_NewRAListofIdleModeUEs (OSCTXT* pctxt, ranap_NewRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "NewRAListofIdleModeUEs");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         stat = asn1PE_ranap_RAC (pctxt, ((ranap_RAC*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NewRAListofIdleModeUEs (OSCTXT* pctxt, ranap_NewRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NewRAListofIdleModeUEs");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_RAC* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_RAC, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_RAC (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_RAC (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NewRAListofIdleModeUEs (
   ranap_NewRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_NewRAListofIdleModeUEs (OSCTXT *pctxt, 
   ranap_NewRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RAC* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RAC*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAListwithNoIdleModeUEsAnyMore (OSCTXT* pctxt, ranap_RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "RAListwithNoIdleModeUEsAnyMore");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         stat = asn1PE_ranap_RAC (pctxt, ((ranap_RAC*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAListwithNoIdleModeUEsAnyMore (OSCTXT* pctxt, ranap_RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAListwithNoIdleModeUEsAnyMore");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_RAC* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_RAC, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_RAC (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_RAC (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAListwithNoIdleModeUEsAnyMore (
   ranap_RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAListwithNoIdleModeUEsAnyMore (OSCTXT *pctxt, 
   ranap_RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RAC* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RAC*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_DeltaRAListofIdleModeUEs (OSCTXT* pctxt, ranap_DeltaRAListofIdleModeUEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaRAListofIdleModeUEs");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.newRAListofIdleModeUEsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode newRAListofIdleModeUEs */

   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "newRAListofIdleModeUEs");

      stat = asn1PE_ranap_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rAListwithNoIdleModeUEsAnyMore */

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAListwithNoIdleModeUEsAnyMore");

      stat = asn1PE_ranap_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DeltaRAListofIdleModeUEs (OSCTXT* pctxt, ranap_DeltaRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "DeltaRAListofIdleModeUEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode newRAListofIdleModeUEs */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "newRAListofIdleModeUEs");

      pvalue->m.newRAListofIdleModeUEsPresent = 1;

      stat = asn1PD_ranap_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAListwithNoIdleModeUEsAnyMore */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAListwithNoIdleModeUEsAnyMore");

      pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent = 1;

      stat = asn1PD_ranap_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DeltaRAListofIdleModeUEs (
   ranap_DeltaRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_NewRAListofIdleModeUEs (&pvalue->newRAListofIdleModeUEs);
   asn1Init_ranap_RAListwithNoIdleModeUEsAnyMore (&pvalue->rAListwithNoIdleModeUEsAnyMore);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_DeltaRAListofIdleModeUEs (OSCTXT *pctxt, 
   ranap_DeltaRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      asn1Free_ranap_NewRAListofIdleModeUEs (pctxt, &pvalue->newRAListofIdleModeUEs);
   }
   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      asn1Free_ranap_RAListwithNoIdleModeUEsAnyMore (pctxt, &pvalue->rAListwithNoIdleModeUEsAnyMore);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_ENB_ID (OSCTXT* pctxt, ranap_ENB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* macroENB_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "macroENB-ID");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.macroENB_ID, OSUINTCONST(20), OSUINTCONST(20));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* homeENB_ID */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "homeENB-ID");

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

            stat = pe_BitString32 (pctxt, pvalue->u.homeENB_ID, OSUINTCONST(28), OSUINTCONST(28));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ENB_ID (OSCTXT* pctxt, ranap_ENB_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "ENB-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* macroENB_ID */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "macroENB-ID");

            pvalue->u.macroENB_ID = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.macroENB_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.macroENB_ID->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(20), OSUINTCONST(20), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.macroENB_ID
               , OSUINTCONST(20), OSUINTCONST(20));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* homeENB_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "homeENB-ID");

            pvalue->u.homeENB_ID = rtxMemAllocType (pctxt, ASN1BitStr32);

            if (pvalue->u.homeENB_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            pvalue->u.homeENB_ID->numbits = 0;

            PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(28), OSUINTCONST(28), 0, 0);

            stat = pd_BitString32 (pctxt, pvalue->u.homeENB_ID
               , OSUINTCONST(28), OSUINTCONST(28));
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ENB_ID (ranap_ENB_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_ENB_ID (OSCTXT *pctxt, ranap_ENB_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.macroENB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.macroENB_ID);
            pvalue->u.macroENB_ID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.homeENB_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.homeENB_ID);
            pvalue->u.homeENB_ID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_PermittedEncryptionAlgorithms (OSCTXT* pctxt, ranap_PermittedEncryptionAlgorithms* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PermittedEncryptionAlgorithms");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EncryptionAlgorithm", xx1);

      stat = asn1PE_ranap_EncryptionAlgorithm (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PermittedEncryptionAlgorithms (OSCTXT* pctxt, ranap_PermittedEncryptionAlgorithms* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PermittedEncryptionAlgorithms");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "EncryptionAlgorithm", xx1);

      stat = asn1PD_ranap_EncryptionAlgorithm (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PermittedEncryptionAlgorithms (
   ranap_PermittedEncryptionAlgorithms* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_EncryptionInformation (OSCTXT* pctxt, ranap_EncryptionInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionInformation");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode permittedAlgorithms */

   RTXCTXTPUSHELEMNAME (pctxt, "permittedAlgorithms");

   stat = asn1PE_ranap_PermittedEncryptionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode key */

   RTXCTXTPUSHELEMNAME (pctxt, "key");

   stat = asn1PE_ranap_EncryptionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EncryptionInformation (OSCTXT* pctxt, ranap_EncryptionInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptionInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode permittedAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "permittedAlgorithms");

   stat = asn1PD_ranap_PermittedEncryptionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode key */
   RTXCTXTPUSHELEMNAME (pctxt, "key");

   stat = asn1PD_ranap_EncryptionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EncryptionInformation (ranap_EncryptionInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PermittedEncryptionAlgorithms (&pvalue->permittedAlgorithms);
   asn1Init_ranap_EncryptionKey (&pvalue->key);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_EncryptionInformation (OSCTXT *pctxt, 
   ranap_EncryptionInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_IMEIList (OSCTXT* pctxt, ranap_IMEIList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEIList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMEI", xx1);

      stat = asn1PE_ranap_IMEI (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEIList (OSCTXT* pctxt, ranap_IMEIList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEIList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 64){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMEI", xx1);

      asn1Init_ranap_IMEI (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_IMEI (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEIList (ranap_IMEIList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IMEISVList (OSCTXT* pctxt, ranap_IMEISVList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISVList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(64), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMEISV", xx1);

      stat = asn1PE_ranap_IMEISV (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEISVList (OSCTXT* pctxt, ranap_IMEISVList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISVList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 6);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 64){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IMEISV", xx1);

      asn1Init_ranap_IMEISV (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_IMEISV (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEISVList (ranap_IMEISVList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IMEIGroup (OSCTXT* pctxt, ranap_IMEIGroup* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEIGroup");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iMEI */

   RTXCTXTPUSHELEMNAME (pctxt, "iMEI");

   stat = asn1PE_ranap_IMEI (pctxt, &pvalue->iMEI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iMEIMask */

   RTXCTXTPUSHELEMNAME (pctxt, "iMEIMask");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->iMEIMask, OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEIGroup (OSCTXT* pctxt, ranap_IMEIGroup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "IMEIGroup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iMEI */
   RTXCTXTPUSHELEMNAME (pctxt, "iMEI");

   stat = asn1PD_ranap_IMEI (pctxt, &pvalue->iMEI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iMEIMask */
   RTXCTXTPUSHELEMNAME (pctxt, "iMEIMask");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->iMEIMask
      , OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEIGroup (ranap_IMEIGroup* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IMEI (&pvalue->iMEI);
   pvalue->iMEIMask.numbits = 0;
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_IMEIGroup (OSCTXT *pctxt, ranap_IMEIGroup* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_IMEISVGroup (OSCTXT* pctxt, ranap_IMEISVGroup* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISVGroup");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iMEISV */

   RTXCTXTPUSHELEMNAME (pctxt, "iMEISV");

   stat = asn1PE_ranap_IMEISV (pctxt, &pvalue->iMEISV);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iMEISVMask */

   RTXCTXTPUSHELEMNAME (pctxt, "iMEISVMask");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pe_BitString32 (pctxt, &pvalue->iMEISVMask, OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IMEISVGroup (OSCTXT* pctxt, ranap_IMEISVGroup* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "IMEISVGroup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iMEISV */
   RTXCTXTPUSHELEMNAME (pctxt, "iMEISV");

   stat = asn1PD_ranap_IMEISV (pctxt, &pvalue->iMEISV);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iMEISVMask */
   RTXCTXTPUSHELEMNAME (pctxt, "iMEISVMask");

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(7), OSUINTCONST(7), 0, 0);

   stat = pd_BitString32 (pctxt, &pvalue->iMEISVMask
      , OSUINTCONST(7), OSUINTCONST(7));
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IMEISVGroup (ranap_IMEISVGroup* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IMEISV (&pvalue->iMEISV);
   pvalue->iMEISVMask.numbits = 0;
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_IMEISVGroup (OSCTXT *pctxt, ranap_IMEISVGroup* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_EquipmentsToBeTraced (OSCTXT* pctxt, ranap_EquipmentsToBeTraced* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EquipmentsToBeTraced");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* iMEIlist */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEIlist");

            stat = asn1PE_ranap_IMEIList (pctxt, pvalue->u.iMEIlist);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* iMEISVlist */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEISVlist");

            stat = asn1PE_ranap_IMEISVList (pctxt, pvalue->u.iMEISVlist);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* iMEIgroup */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEIgroup");

            stat = asn1PE_ranap_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* iMEISVgroup */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEISVgroup");

            stat = asn1PE_ranap_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EquipmentsToBeTraced (OSCTXT* pctxt, ranap_EquipmentsToBeTraced* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "EquipmentsToBeTraced");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMEIlist */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEIlist");

            pvalue->u.iMEIlist = rtxMemAllocType (pctxt, ranap_IMEIList);

            if (pvalue->u.iMEIlist == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEIList (pvalue->u.iMEIlist);

            stat = asn1PD_ranap_IMEIList (pctxt, pvalue->u.iMEIlist);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* iMEISVlist */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEISVlist");

            pvalue->u.iMEISVlist = rtxMemAllocType (pctxt, ranap_IMEISVList);

            if (pvalue->u.iMEISVlist == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEISVList (pvalue->u.iMEISVlist);

            stat = asn1PD_ranap_IMEISVList (pctxt, pvalue->u.iMEISVlist);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* iMEIgroup */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEIgroup");

            pvalue->u.iMEIgroup = rtxMemAllocType (pctxt, ranap_IMEIGroup);

            if (pvalue->u.iMEIgroup == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEIGroup (pvalue->u.iMEIgroup);

            stat = asn1PD_ranap_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* iMEISVgroup */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "iMEISVgroup");

            pvalue->u.iMEISVgroup = rtxMemAllocType (pctxt, 
               ranap_IMEISVGroup);

            if (pvalue->u.iMEISVgroup == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEISVGroup (pvalue->u.iMEISVgroup);

            stat = asn1PD_ranap_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EquipmentsToBeTraced (ranap_EquipmentsToBeTraced* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_EquipmentsToBeTraced (OSCTXT *pctxt, 
   ranap_EquipmentsToBeTraced* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.iMEIlist) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMEIlist);
            pvalue->u.iMEIlist = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.iMEISVlist) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMEISVlist);
            pvalue->u.iMEISVlist = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.iMEIgroup) {
            asn1Free_ranap_IMEIGroup (pctxt, pvalue->u.iMEIgroup);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMEIgroup);
            pvalue->u.iMEIgroup = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.iMEISVgroup) {
            asn1Free_ranap_IMEISVGroup (pctxt, pvalue->u.iMEISVgroup);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMEISVgroup);
            pvalue->u.iMEISVgroup = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_Event1F_Parameters (OSCTXT* pctxt, ranap_Event1F_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event1F-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurementQuantity */

   RTXCTXTPUSHELEMNAME (pctxt, "measurementQuantity");

   stat = asn1PE_ranap_MeasurementQuantity (pctxt, pvalue->measurementQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "threshold");

   if ( pvalue->threshold >= -120 ) {
      stat = pe_ConsInteger (pctxt, pvalue->threshold, -120, 165);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->threshold);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Event1F_Parameters (OSCTXT* pctxt, ranap_Event1F_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event1F-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode measurementQuantity */
   RTXCTXTPUSHELEMNAME (pctxt, "measurementQuantity");

   stat = asn1PD_ranap_MeasurementQuantity (pctxt, &pvalue->measurementQuantity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "threshold");

   stat = pd_ConsInt16 (pctxt, &pvalue->threshold, -120, 165);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Event1F_Parameters (ranap_Event1F_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Event1F_Parameters (OSCTXT *pctxt, 
   ranap_Event1F_Parameters* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Event1I_Parameters (OSCTXT* pctxt, ranap_Event1I_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event1I-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode threshold */

   RTXCTXTPUSHELEMNAME (pctxt, "threshold");

   if ( (pvalue->threshold >= -120 && pvalue->threshold <= -25) ) {
      stat = pe_ConsInteger (pctxt, pvalue->threshold, -120, -25);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, pvalue->threshold);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Event1I_Parameters (OSCTXT* pctxt, ranap_Event1I_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Event1I-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode threshold */
   RTXCTXTPUSHELEMNAME (pctxt, "threshold");

   stat = pd_ConsInt8 (pctxt, &pvalue->threshold, -120, -25);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Event1I_Parameters (ranap_Event1I_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Event1I_Parameters (OSCTXT *pctxt, 
   ranap_Event1I_Parameters* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GANSS_PositioningDataSet (OSCTXT* pctxt, ranap_GANSS_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "GANSS-PositioningDataSet");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GANSS-PositioningMethodAndUsage", xx1);

      stat = asn1PE_ranap_GANSS_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GANSS_PositioningDataSet (OSCTXT* pctxt, ranap_GANSS_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GANSS-PositioningDataSet");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 9){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GANSS-PositioningMethodAndUsage", xx1);

      asn1Init_ranap_GANSS_PositioningMethodAndUsage (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_GANSS_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GANSS_PositioningDataSet (
   ranap_GANSS_PositioningDataSet* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_GERAN_Cell_ID (OSCTXT* pctxt, ranap_GERAN_Cell_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Cell-ID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAI */

   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PE_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAC */

   RTXCTXTPUSHELEMNAME (pctxt, "rAC");

   stat = asn1PE_ranap_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cI */

   RTXCTXTPUSHELEMNAME (pctxt, "cI");

   stat = asn1PE_ranap_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GERAN_Cell_ID (OSCTXT* pctxt, ranap_GERAN_Cell_ID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Cell-ID");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lAI */
   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PD_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAC */
   RTXCTXTPUSHELEMNAME (pctxt, "rAC");

   stat = asn1PD_ranap_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cI */
   RTXCTXTPUSHELEMNAME (pctxt, "cI");

   stat = asn1PD_ranap_CI (pctxt, &pvalue->cI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GERAN_Cell_ID (ranap_GERAN_Cell_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAI (&pvalue->lAI);
   asn1Init_ranap_RAC (&pvalue->rAC);
   asn1Init_ranap_CI (&pvalue->cI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_GERAN_Cell_ID (OSCTXT *pctxt, ranap_GERAN_Cell_ID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_LAI (pctxt, &pvalue->lAI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_GlobalCN_ID (OSCTXT* pctxt, ranap_GlobalCN_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalCN-ID");

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cN_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "cN-ID");

   stat = asn1PE_ranap_CN_ID (pctxt, pvalue->cN_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GlobalCN_ID (OSCTXT* pctxt, ranap_GlobalCN_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalCN-ID");

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cN_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "cN-ID");

   stat = asn1PD_ranap_CN_ID (pctxt, &pvalue->cN_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GlobalCN_ID (ranap_GlobalCN_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   return 0;
}

EXTERN int asn1PE_ranap_GlobalRNC_ID (OSCTXT* pctxt, ranap_GlobalRNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalRNC-ID");

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rNC_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PE_ranap_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GlobalRNC_ID (OSCTXT* pctxt, ranap_GlobalRNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GlobalRNC-ID");

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rNC_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PD_ranap_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GlobalRNC_ID (ranap_GlobalRNC_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   return 0;
}

EXTERN int asn1PE_ranap_MDT_Report_Parameters (OSCTXT* pctxt, ranap_MDT_Report_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Report-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reportInterval */

   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PE_ranap_ReportInterval (pctxt, pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportAmount */

   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PE_ranap_ReportAmount (pctxt, pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDT_Report_Parameters (OSCTXT* pctxt, ranap_MDT_Report_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Report-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode reportInterval */
   RTXCTXTPUSHELEMNAME (pctxt, "reportInterval");

   stat = asn1PD_ranap_ReportInterval (pctxt, &pvalue->reportInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportAmount */
   RTXCTXTPUSHELEMNAME (pctxt, "reportAmount");

   stat = asn1PD_ranap_ReportAmount (pctxt, &pvalue->reportAmount);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MDT_Report_Parameters (ranap_MDT_Report_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MDT_Report_Parameters (OSCTXT *pctxt, 
   ranap_MDT_Report_Parameters* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_M1Report (OSCTXT* pctxt, ranap_M1Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M1Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* periodic */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "periodic");

            stat = asn1PE_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* event1F */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "event1F");

            stat = asn1PE_ranap_Event1F_Parameters (pctxt, pvalue->u.event1F);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M1Report (OSCTXT* pctxt, ranap_M1Report* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "M1Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* periodic */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "periodic");

            pvalue->u.periodic = rtxMemAllocType (pctxt, 
               ranap_MDT_Report_Parameters);

            if (pvalue->u.periodic == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_MDT_Report_Parameters (pvalue->u.periodic);

            stat = asn1PD_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* event1F */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "event1F");

            pvalue->u.event1F = rtxMemAllocType (pctxt, 
               ranap_Event1F_Parameters);

            if (pvalue->u.event1F == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_Event1F_Parameters (pvalue->u.event1F);

            stat = asn1PD_ranap_Event1F_Parameters (pctxt, pvalue->u.event1F);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M1Report (ranap_M1Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_M1Report (OSCTXT *pctxt, ranap_M1Report* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.periodic) {
            asn1Free_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.periodic);
            pvalue->u.periodic = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.event1F) {
            asn1Free_ranap_Event1F_Parameters (pctxt, pvalue->u.event1F);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.event1F);
            pvalue->u.event1F = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_M2Report (OSCTXT* pctxt, ranap_M2Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M2Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* periodic */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "periodic");

            stat = asn1PE_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* event1I */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "event1I");

            stat = asn1PE_ranap_Event1I_Parameters (pctxt, pvalue->u.event1I);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M2Report (OSCTXT* pctxt, ranap_M2Report* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "M2Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* periodic */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "periodic");

            pvalue->u.periodic = rtxMemAllocType (pctxt, 
               ranap_MDT_Report_Parameters);

            if (pvalue->u.periodic == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_MDT_Report_Parameters (pvalue->u.periodic);

            stat = asn1PD_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* event1I */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "event1I");

            pvalue->u.event1I = rtxMemAllocType (pctxt, 
               ranap_Event1I_Parameters);

            if (pvalue->u.event1I == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_Event1I_Parameters (pvalue->u.event1I);

            stat = asn1PD_ranap_Event1I_Parameters (pctxt, pvalue->u.event1I);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M2Report (ranap_M2Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_M2Report (OSCTXT *pctxt, ranap_M2Report* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.periodic) {
            asn1Free_ranap_MDT_Report_Parameters (pctxt, pvalue->u.periodic);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.periodic);
            pvalue->u.periodic = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.event1I) {
            asn1Free_ranap_Event1I_Parameters (pctxt, pvalue->u.event1I);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.event1I);
            pvalue->u.event1I = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_ImmediateMDT (OSCTXT* pctxt, ranap_ImmediateMDT* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;
   OSUINT32 pos;
   void* pPerField;

   RTXCTXTPUSHTYPENAME (pctxt, "ImmediateMDT");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->m.iE_ExtensionsPresent ||
   pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.m1reportPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.m2reportPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurementsToActivate */

   RTXCTXTPUSHELEMNAME (pctxt, "measurementsToActivate");

   stat = asn1PE_ranap_MeasurementsToActivate (pctxt, pvalue->measurementsToActivate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode m1report */

   if (pvalue->m.m1reportPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "m1report");

      stat = asn1PE_ranap_M1Report (pctxt, &pvalue->m1report);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode m2report */

   if (pvalue->m.m2reportPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "m2report");

      stat = asn1PE_ranap_M2Report (pctxt, &pvalue->m2report);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count + 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->m.iE_ExtensionsPresent) {
         RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

         stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
      }

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ImmediateMDT (OSCTXT* pctxt, ranap_ImmediateMDT* pvalue)
{
   int stat = 0;
   OSCTXT lctxt2;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "ImmediateMDT");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measurementsToActivate */
   RTXCTXTPUSHELEMNAME (pctxt, "measurementsToActivate");

   stat = asn1PD_ranap_MeasurementsToActivate (pctxt, &pvalue->measurementsToActivate);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m1report */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "m1report");

      pvalue->m.m1reportPresent = 1;

      stat = asn1PD_ranap_M1Report (pctxt, &pvalue->m1report);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode m2report */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "m2report");

      pvalue->m.m2reportPresent = 1;

      stat = asn1PD_ranap_M2Report (pctxt, &pvalue->m2report);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            if (i_ < 1) {  /* known element */
               rtxCopyContext (&lctxt2, pctxt);
               rtxCtxtSetFlag (pctxt, OSDISSTRM);
               pctxt->buffer.data = (OSOCTET*)openType.data;
               pctxt->buffer.size = openType.numocts;
               pctxt->buffer.byteIndex = 0;
               pctxt->buffer.bitOffset = 8;

               if (openType.numocts > 0) {
                  switch (i_) {
                     case 0:
                        pvalue->m.iE_ExtensionsPresent = 1;
                        RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

                        stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);

                        if (stat != 0) {
                           rtxMemFreePtr (pctxt, openType.data);
                           break;
                        }

                        RTXCTXTPOPELEMNAME (pctxt);
                        break;

                  }
               }
               rtxCopyContext (pctxt, &lctxt2);
               RTXCTXTPOPELEMNAME (pctxt);
            }
            if (i_ >= 1 || openType.numocts == 0) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else if (!rtxCtxtTestFlag (pctxt, ASN1FASTCOPY)) {
               rtxMemFreePtr (pctxt, openType.data);
            }
         }
         else if (i_ >= 1) {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ImmediateMDT (ranap_ImmediateMDT* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_MeasurementsToActivate (&pvalue->measurementsToActivate);
   asn1Init_ranap_M1Report (&pvalue->m1report);
   asn1Init_ranap_M2Report (&pvalue->m2report);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ImmediateMDT (OSCTXT *pctxt, ranap_ImmediateMDT* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.m1reportPresent) {
      asn1Free_ranap_M1Report (pctxt, &pvalue->m1report);
   }
   if (pvalue->m.m2reportPresent) {
      asn1Free_ranap_M2Report (pctxt, &pvalue->m2report);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSIPMulticastAddressandAPNlist (OSCTXT* pctxt, ranap_MBMSIPMulticastAddressandAPNlist* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSIPMulticastAddressandAPNlist");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tMGI */

   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PE_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iPMulticastAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "iPMulticastAddress");

   stat = asn1PE_ranap_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode aPN */

   RTXCTXTPUSHELEMNAME (pctxt, "aPN");

   stat = asn1PE_ranap_APN (pctxt, &pvalue->aPN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSIPMulticastAddressandAPNlist (OSCTXT* pctxt, ranap_MBMSIPMulticastAddressandAPNlist* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSIPMulticastAddressandAPNlist");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tMGI */
   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PD_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iPMulticastAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "iPMulticastAddress");

   stat = asn1PD_ranap_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode aPN */
   RTXCTXTPUSHELEMNAME (pctxt, "aPN");

   stat = asn1PD_ranap_APN (pctxt, &pvalue->aPN);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSIPMulticastAddressandAPNlist (
   ranap_MBMSIPMulticastAddressandAPNlist* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TMGI (&pvalue->tMGI);
   asn1Init_ranap_IPMulticastAddress (&pvalue->iPMulticastAddress);
   asn1Init_ranap_APN (&pvalue->aPN);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSIPMulticastAddressandAPNlist (OSCTXT *pctxt, 
   ranap_MBMSIPMulticastAddressandAPNlist* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (OSCTXT* pctxt, ranap_RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedMBMSIPMulticastAddressandAPNRequest");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBMSIPMulticastAddressandAPNlist", xx1);

      stat = asn1PE_ranap_MBMSIPMulticastAddressandAPNlist (pctxt, ((ranap_MBMSIPMulticastAddressandAPNlist*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (OSCTXT* pctxt, ranap_RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedMBMSIPMulticastAddressandAPNRequest");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_MBMSIPMulticastAddressandAPNlist* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "MBMSIPMulticastAddressandAPNlist", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_MBMSIPMulticastAddressandAPNlist, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_MBMSIPMulticastAddressandAPNlist (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_MBMSIPMulticastAddressandAPNlist (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (
   ranap_RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (OSCTXT *pctxt, 
   ranap_RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   if (0 == pvalue) return;
   { ranap_MBMSIPMulticastAddressandAPNlist* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_MBMSIPMulticastAddressandAPNlist*)pnode->data;
      asn1Free_ranap_MBMSIPMulticastAddressandAPNlist (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RequestedMulticastServiceList (OSCTXT* pctxt, ranap_RequestedMulticastServiceList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedMulticastServiceList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TMGI", xx1);

      stat = asn1PE_ranap_TMGI (pctxt, ((ranap_TMGI*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestedMulticastServiceList (OSCTXT* pctxt, ranap_RequestedMulticastServiceList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestedMulticastServiceList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_TMGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TMGI", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_TMGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_TMGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RequestedMulticastServiceList (
   ranap_RequestedMulticastServiceList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RequestedMulticastServiceList (OSCTXT *pctxt, 
   ranap_RequestedMulticastServiceList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_TMGI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_TMGI*)pnode->data;
      asn1Free_ranap_TMGI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_InformationRequested (OSCTXT* pctxt, ranap_InformationRequested* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationRequested");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* requestedMBMSIPMulticastAddressandAPNRequest */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "requestedMBMSIPMulticastAddressandAPNRequest");

            stat = asn1PE_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* requestedMulticastServiceList */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "requestedMulticastServiceList");

            stat = asn1PE_ranap_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationRequested (OSCTXT* pctxt, ranap_InformationRequested* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationRequested");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* requestedMBMSIPMulticastAddressandAPNRequest */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "requestedMBMSIPMulticastAddressandAPNRequest");

            pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest
                = rtxMemAllocType (pctxt, 
               ranap_RequestedMBMSIPMulticastAddressandAPNRequest);

            if (pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);

            stat = asn1PD_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* requestedMulticastServiceList */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "requestedMulticastServiceList");

            pvalue->u.requestedMulticastServiceList = rtxMemAllocType (pctxt, 
               ranap_RequestedMulticastServiceList);

            if (pvalue->u.requestedMulticastServiceList == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RequestedMulticastServiceList (pvalue->u.requestedMulticastServiceList);

            stat = asn1PD_ranap_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationRequested (ranap_InformationRequested* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_InformationRequested (OSCTXT *pctxt, 
   ranap_InformationRequested* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest) {
            asn1Free_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest);
            pvalue->u.requestedMBMSIPMulticastAddressandAPNRequest = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.requestedMulticastServiceList) {
            asn1Free_ranap_RequestedMulticastServiceList (pctxt, pvalue->u.requestedMulticastServiceList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.requestedMulticastServiceList);
            pvalue->u.requestedMulticastServiceList = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_MBMSIPMulticastAddressandAPNRequest (OSCTXT* pctxt, ranap_MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSIPMulticastAddressandAPNRequest");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TMGI", xx1);

      stat = asn1PE_ranap_TMGI (pctxt, ((ranap_TMGI*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSIPMulticastAddressandAPNRequest (OSCTXT* pctxt, ranap_MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSIPMulticastAddressandAPNRequest");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(512), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_TMGI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TMGI", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_TMGI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_TMGI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_TMGI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSIPMulticastAddressandAPNRequest (
   ranap_MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_MBMSIPMulticastAddressandAPNRequest (OSCTXT *pctxt, 
   ranap_MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   if (0 == pvalue) return;
   { ranap_TMGI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_TMGI*)pnode->data;
      asn1Free_ranap_TMGI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_PermanentNAS_UE_ID (OSCTXT* pctxt, ranap_PermanentNAS_UE_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PermanentNAS-UE-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* iMSI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "iMSI");

            stat = asn1PE_ranap_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PermanentNAS_UE_ID (OSCTXT* pctxt, ranap_PermanentNAS_UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "PermanentNAS-UE-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* iMSI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "iMSI");

            pvalue->u.iMSI = rtxMemAllocType (pctxt, ranap_IMSI);

            if (pvalue->u.iMSI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMSI (pvalue->u.iMSI);

            stat = asn1PD_ranap_IMSI (pctxt, pvalue->u.iMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PermanentNAS_UE_ID (ranap_PermanentNAS_UE_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_PermanentNAS_UE_ID (OSCTXT *pctxt, 
   ranap_PermanentNAS_UE_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.iMSI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMSI);
            pvalue->u.iMSI = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_InformationRequestType (OSCTXT* pctxt, ranap_InformationRequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationRequestType");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* mBMSIPMulticastAddressandAPNRequest */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "mBMSIPMulticastAddressandAPNRequest");

            stat = asn1PE_ranap_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* permanentNAS_UE_ID */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

            stat = asn1PE_ranap_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationRequestType (OSCTXT* pctxt, ranap_InformationRequestType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationRequestType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* mBMSIPMulticastAddressandAPNRequest */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "mBMSIPMulticastAddressandAPNRequest");

            pvalue->u.mBMSIPMulticastAddressandAPNRequest
                = rtxMemAllocType (pctxt, 
               ranap_MBMSIPMulticastAddressandAPNRequest);

            if (pvalue->u.mBMSIPMulticastAddressandAPNRequest == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_MBMSIPMulticastAddressandAPNRequest (pvalue->u.mBMSIPMulticastAddressandAPNRequest);

            stat = asn1PD_ranap_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* permanentNAS_UE_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

            pvalue->u.permanentNAS_UE_ID = rtxMemAllocType (pctxt, 
               ranap_PermanentNAS_UE_ID);

            if (pvalue->u.permanentNAS_UE_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_PermanentNAS_UE_ID (pvalue->u.permanentNAS_UE_ID);

            stat = asn1PD_ranap_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationRequestType (
   ranap_InformationRequestType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_InformationRequestType (OSCTXT *pctxt, 
   ranap_InformationRequestType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mBMSIPMulticastAddressandAPNRequest) {
            asn1Free_ranap_MBMSIPMulticastAddressandAPNRequest (pctxt, pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mBMSIPMulticastAddressandAPNRequest);
            pvalue->u.mBMSIPMulticastAddressandAPNRequest = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.permanentNAS_UE_ID) {
            asn1Free_ranap_PermanentNAS_UE_ID (pctxt, pvalue->u.permanentNAS_UE_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.permanentNAS_UE_ID);
            pvalue->u.permanentNAS_UE_ID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_RNCTraceInformation (OSCTXT* pctxt, ranap_RNCTraceInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RNCTraceInformation");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.equipmentsToBeTracedPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode traceReference */

   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PE_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode traceActivationIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "traceActivationIndicator");

   stat = asn1PE_ranap_RNCTraceInformation_traceActivationIndicator (pctxt, pvalue->traceActivationIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode equipmentsToBeTraced */

   if (pvalue->m.equipmentsToBeTracedPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "equipmentsToBeTraced");

      stat = asn1PE_ranap_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RNCTraceInformation (OSCTXT* pctxt, ranap_RNCTraceInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RNCTraceInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode traceReference */
   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PD_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode traceActivationIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "traceActivationIndicator");

   stat = asn1PD_ranap_RNCTraceInformation_traceActivationIndicator (pctxt, &pvalue->traceActivationIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode equipmentsToBeTraced */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "equipmentsToBeTraced");

      pvalue->m.equipmentsToBeTracedPresent = 1;

      stat = asn1PD_ranap_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RNCTraceInformation (ranap_RNCTraceInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TraceReference (&pvalue->traceReference);
   asn1Init_ranap_EquipmentsToBeTraced (&pvalue->equipmentsToBeTraced);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_RNCTraceInformation (OSCTXT *pctxt, 
   ranap_RNCTraceInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.equipmentsToBeTracedPresent) {
      asn1Free_ranap_EquipmentsToBeTraced (pctxt, &pvalue->equipmentsToBeTraced);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_InformationTransferType (OSCTXT* pctxt, ranap_InformationTransferType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferType");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* rNCTraceInformation */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "rNCTraceInformation");

            stat = asn1PE_ranap_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationTransferType (OSCTXT* pctxt, ranap_InformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rNCTraceInformation */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "rNCTraceInformation");

            pvalue->u.rNCTraceInformation = rtxMemAllocType (pctxt, 
               ranap_RNCTraceInformation);

            if (pvalue->u.rNCTraceInformation == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RNCTraceInformation (pvalue->u.rNCTraceInformation);

            stat = asn1PD_ranap_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationTransferType (
   ranap_InformationTransferType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_InformationTransferType (OSCTXT *pctxt, 
   ranap_InformationTransferType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rNCTraceInformation) {
            asn1Free_ranap_RNCTraceInformation (pctxt, pvalue->u.rNCTraceInformation);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rNCTraceInformation);
            pvalue->u.rNCTraceInformation = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_PermittedIntegrityProtectionAlgorithms (OSCTXT* pctxt, ranap_PermittedIntegrityProtectionAlgorithms* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PermittedIntegrityProtectionAlgorithms");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IntegrityProtectionAlgorithm", xx1);

      stat = asn1PE_ranap_IntegrityProtectionAlgorithm (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PermittedIntegrityProtectionAlgorithms (OSCTXT* pctxt, ranap_PermittedIntegrityProtectionAlgorithms* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PermittedIntegrityProtectionAlgorithms");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "IntegrityProtectionAlgorithm", xx1);

      stat = asn1PD_ranap_IntegrityProtectionAlgorithm (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PermittedIntegrityProtectionAlgorithms (
   ranap_PermittedIntegrityProtectionAlgorithms* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_IntegrityProtectionInformation (OSCTXT* pctxt, ranap_IntegrityProtectionInformation* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionInformation");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode permittedAlgorithms */

   RTXCTXTPUSHELEMNAME (pctxt, "permittedAlgorithms");

   stat = asn1PE_ranap_PermittedIntegrityProtectionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode key */

   RTXCTXTPUSHELEMNAME (pctxt, "key");

   stat = asn1PE_ranap_IntegrityProtectionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IntegrityProtectionInformation (OSCTXT* pctxt, ranap_IntegrityProtectionInformation* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "IntegrityProtectionInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode permittedAlgorithms */
   RTXCTXTPUSHELEMNAME (pctxt, "permittedAlgorithms");

   stat = asn1PD_ranap_PermittedIntegrityProtectionAlgorithms (pctxt, &pvalue->permittedAlgorithms);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode key */
   RTXCTXTPUSHELEMNAME (pctxt, "key");

   stat = asn1PD_ranap_IntegrityProtectionKey (pctxt, &pvalue->key);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IntegrityProtectionInformation (
   ranap_IntegrityProtectionInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PermittedIntegrityProtectionAlgorithms (&pvalue->permittedAlgorithms);
   asn1Init_ranap_IntegrityProtectionKey (&pvalue->key);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_IntegrityProtectionInformation (OSCTXT *pctxt, 
   ranap_IntegrityProtectionInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_TargetRNC_ID (OSCTXT* pctxt, ranap_TargetRNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetRNC-ID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rACPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAI */

   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PE_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAC */

   if (pvalue->m.rACPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAC");

      stat = asn1PE_ranap_RAC (pctxt, &pvalue->rAC);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rNC_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PE_ranap_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetRNC_ID (OSCTXT* pctxt, ranap_TargetRNC_ID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "TargetRNC-ID");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lAI */
   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PD_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAC */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAC");

      pvalue->m.rACPresent = 1;

      stat = asn1PD_ranap_RAC (pctxt, &pvalue->rAC);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rNC_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PD_ranap_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargetRNC_ID (ranap_TargetRNC_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAI (&pvalue->lAI);
   asn1Init_ranap_RAC (&pvalue->rAC);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_TargetRNC_ID (OSCTXT *pctxt, ranap_TargetRNC_ID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_LAI (pctxt, &pvalue->lAI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_TAI (OSCTXT* pctxt, ranap_TAI* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TAI");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tAC */

   RTXCTXTPUSHELEMNAME (pctxt, "tAC");

   stat = asn1PE_ranap_TAC (pctxt, &pvalue->tAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TAI (OSCTXT* pctxt, ranap_TAI* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TAI");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tAC */
   RTXCTXTPUSHELEMNAME (pctxt, "tAC");

   stat = asn1PD_ranap_TAC (pctxt, &pvalue->tAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TAI (ranap_TAI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_TAC (&pvalue->tAC);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_TAI (OSCTXT *pctxt, ranap_TAI* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_TargetENB_ID (OSCTXT* pctxt, ranap_TargetENB_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetENB-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eNB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "eNB-ID");

   stat = asn1PE_ranap_ENB_ID (pctxt, &pvalue->eNB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode selectedTAI */

   RTXCTXTPUSHELEMNAME (pctxt, "selectedTAI");

   stat = asn1PE_ranap_TAI (pctxt, &pvalue->selectedTAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetENB_ID (OSCTXT* pctxt, ranap_TargetENB_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TargetENB-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eNB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "eNB-ID");

   stat = asn1PD_ranap_ENB_ID (pctxt, &pvalue->eNB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode selectedTAI */
   RTXCTXTPUSHELEMNAME (pctxt, "selectedTAI");

   stat = asn1PD_ranap_TAI (pctxt, &pvalue->selectedTAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargetENB_ID (ranap_TargetENB_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_ENB_ID (&pvalue->eNB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   asn1Init_ranap_TAI (&pvalue->selectedTAI);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TargetENB_ID (OSCTXT *pctxt, ranap_TargetENB_ID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ENB_ID (pctxt, &pvalue->eNB_ID);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   asn1Free_ranap_TAI (pctxt, &pvalue->selectedTAI);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RIMRoutingAddress (OSCTXT* pctxt, ranap_RIMRoutingAddress* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RIMRoutingAddress");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* targetRNC_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "targetRNC-ID");

            stat = asn1PE_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* gERAN_Cell_ID */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "gERAN-Cell-ID");

            stat = asn1PE_ranap_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* targeteNB_ID */
         case 3:
            stat = asn1PE_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RIMRoutingAddress (OSCTXT* pctxt, ranap_RIMRoutingAddress* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "RIMRoutingAddress");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* targetRNC_ID */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "targetRNC-ID");

            pvalue->u.targetRNC_ID = rtxMemAllocType (pctxt, 
               ranap_TargetRNC_ID);

            if (pvalue->u.targetRNC_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_TargetRNC_ID (pvalue->u.targetRNC_ID);

            stat = asn1PD_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* gERAN_Cell_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "gERAN-Cell-ID");

            pvalue->u.gERAN_Cell_ID = rtxMemAllocType (pctxt, 
               ranap_GERAN_Cell_ID);

            if (pvalue->u.gERAN_Cell_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_GERAN_Cell_ID (pvalue->u.gERAN_Cell_ID);

            stat = asn1PD_ranap_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 4) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* targeteNB_ID */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "targeteNB-ID");

            pvalue->u.targeteNB_ID = rtxMemAllocType (pctxt, 
               ranap_TargetENB_ID);

            if (pvalue->u.targeteNB_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_TargetENB_ID (pvalue->u.targeteNB_ID);

            stat = asn1PD_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 4) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RIMRoutingAddress (ranap_RIMRoutingAddress* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_RIMRoutingAddress (OSCTXT *pctxt, 
   ranap_RIMRoutingAddress* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.targetRNC_ID) {
            asn1Free_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targetRNC_ID);
            pvalue->u.targetRNC_ID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.gERAN_Cell_ID) {
            asn1Free_ranap_GERAN_Cell_ID (pctxt, pvalue->u.gERAN_Cell_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gERAN_Cell_ID);
            pvalue->u.gERAN_Cell_ID = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.targeteNB_ID) {
            asn1Free_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targeteNB_ID);
            pvalue->u.targeteNB_ID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_RIM_Transfer (OSCTXT* pctxt, ranap_RIM_Transfer* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RIM-Transfer");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rIMRoutingAddressPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rIMInformation */

   RTXCTXTPUSHELEMNAME (pctxt, "rIMInformation");

   stat = asn1PE_ranap_RIMInformation (pctxt, pvalue->rIMInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rIMRoutingAddress */

   if (pvalue->m.rIMRoutingAddressPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rIMRoutingAddress");

      stat = asn1PE_ranap_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RIM_Transfer (OSCTXT* pctxt, ranap_RIM_Transfer* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RIM-Transfer");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rIMInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "rIMInformation");

   stat = asn1PD_ranap_RIMInformation (pctxt, &pvalue->rIMInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rIMRoutingAddress */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rIMRoutingAddress");

      pvalue->m.rIMRoutingAddressPresent = 1;

      stat = asn1PD_ranap_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RIM_Transfer (ranap_RIM_Transfer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RIMInformation (&pvalue->rIMInformation);
   asn1Init_ranap_RIMRoutingAddress (&pvalue->rIMRoutingAddress);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_RIM_Transfer (OSCTXT *pctxt, ranap_RIM_Transfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RIMInformation (pctxt, &pvalue->rIMInformation);
   if (pvalue->m.rIMRoutingAddressPresent) {
      asn1Free_ranap_RIMRoutingAddress (pctxt, &pvalue->rIMRoutingAddress);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_InterSystemInformationTransferType (OSCTXT* pctxt, ranap_InterSystemInformationTransferType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterSystemInformationTransferType");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* rIM_Transfer */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "rIM-Transfer");

            stat = asn1PE_ranap_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InterSystemInformationTransferType (OSCTXT* pctxt, ranap_InterSystemInformationTransferType* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "InterSystemInformationTransferType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* rIM_Transfer */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "rIM-Transfer");

            pvalue->u.rIM_Transfer = rtxMemAllocType (pctxt, 
               ranap_RIM_Transfer);

            if (pvalue->u.rIM_Transfer == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RIM_Transfer (pvalue->u.rIM_Transfer);

            stat = asn1PD_ranap_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InterSystemInformationTransferType (
   ranap_InterSystemInformationTransferType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_InterSystemInformationTransferType (OSCTXT *pctxt, 
   ranap_InterSystemInformationTransferType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rIM_Transfer) {
            asn1Free_ranap_RIM_Transfer (pctxt, pvalue->u.rIM_Transfer);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rIM_Transfer);
            pvalue->u.rIM_Transfer = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_InterSystemInformation_TransparentContainer (OSCTXT* pctxt, ranap_InterSystemInformation_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterSystemInformation-TransparentContainer");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.downlinkCellLoadInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uplinkCellLoadInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode downlinkCellLoadInformation */

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "downlinkCellLoadInformation");

      stat = asn1PE_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uplinkCellLoadInformation */

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkCellLoadInformation");

      stat = asn1PE_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InterSystemInformation_TransparentContainer (OSCTXT* pctxt, ranap_InterSystemInformation_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "InterSystemInformation-TransparentContainer");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode downlinkCellLoadInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "downlinkCellLoadInformation");

      pvalue->m.downlinkCellLoadInformationPresent = 1;

      stat = asn1PD_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uplinkCellLoadInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uplinkCellLoadInformation");

      pvalue->m.uplinkCellLoadInformationPresent = 1;

      stat = asn1PD_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InterSystemInformation_TransparentContainer (
   ranap_InterSystemInformation_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_CellLoadInformation (&pvalue->downlinkCellLoadInformation);
   asn1Init_ranap_CellLoadInformation (&pvalue->uplinkCellLoadInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InterSystemInformation_TransparentContainer (OSCTXT *pctxt, 
   ranap_InterSystemInformation_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.downlinkCellLoadInformationPresent) {
      asn1Free_ranap_CellLoadInformation (pctxt, &pvalue->downlinkCellLoadInformation);
   }
   if (pvalue->m.uplinkCellLoadInformationPresent) {
      asn1Free_ranap_CellLoadInformation (pctxt, &pvalue->uplinkCellLoadInformation);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ListOF_SNAs (OSCTXT* pctxt, ranap_ListOF_SNAs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "ListOF-SNAs");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SNAC", xx1);

         stat = asn1PE_ranap_SNAC (pctxt, *((ranap_SNAC*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ListOF_SNAs (OSCTXT* pctxt, ranap_ListOF_SNAs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ListOF-SNAs");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_SNAC* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SNAC", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_SNAC, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_SNAC (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ListOF_SNAs (ranap_ListOF_SNAs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ListOF_SNAs (OSCTXT *pctxt, ranap_ListOF_SNAs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SNAC* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SNAC*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_LA_LIST_element (OSCTXT* pctxt, ranap_LA_LIST_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAC */

   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PE_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode listOF_SNAs */

   RTXCTXTPUSHELEMNAME (pctxt, "listOF-SNAs");

   stat = asn1PE_ranap_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_LA_LIST_element (OSCTXT* pctxt, ranap_LA_LIST_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lAC */
   RTXCTXTPUSHELEMNAME (pctxt, "lAC");

   stat = asn1PD_ranap_LAC (pctxt, &pvalue->lAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode listOF_SNAs */
   RTXCTXTPUSHELEMNAME (pctxt, "listOF-SNAs");

   stat = asn1PD_ranap_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_LA_LIST_element (ranap_LA_LIST_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAC (&pvalue->lAC);
   asn1Init_ranap_ListOF_SNAs (&pvalue->listOF_SNAs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LA_LIST_element (OSCTXT *pctxt, 
   ranap_LA_LIST_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ListOF_SNAs (pctxt, &pvalue->listOF_SNAs);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LA_LIST (OSCTXT* pctxt, ranap_LA_LIST* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "LA-LIST");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

         stat = asn1PE_ranap_LA_LIST_element (pctxt, ((ranap_LA_LIST_element*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LA_LIST (OSCTXT* pctxt, ranap_LA_LIST* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LA-LIST");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_LA_LIST_element* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_LA_LIST_element, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_LA_LIST_element (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_LA_LIST_element (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LA_LIST (ranap_LA_LIST* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_LA_LIST (OSCTXT *pctxt, ranap_LA_LIST* pvalue)
{
   if (0 == pvalue) return;
   { ranap_LA_LIST_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_LA_LIST_element*)pnode->data;
      asn1Free_ranap_LA_LIST_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_LastKnownServiceArea (OSCTXT* pctxt, ranap_LastKnownServiceArea* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LastKnownServiceArea");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sAI */

   RTXCTXTPUSHELEMNAME (pctxt, "sAI");

   stat = asn1PE_ranap_SAI (pctxt, &pvalue->sAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ageOfSAI */

   RTXCTXTPUSHELEMNAME (pctxt, "ageOfSAI");

   if ( pvalue->ageOfSAI <= 32767 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->ageOfSAI, 0, 32767);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->ageOfSAI);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LastKnownServiceArea (OSCTXT* pctxt, ranap_LastKnownServiceArea* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LastKnownServiceArea");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sAI */
   RTXCTXTPUSHELEMNAME (pctxt, "sAI");

   stat = asn1PD_ranap_SAI (pctxt, &pvalue->sAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ageOfSAI */
   RTXCTXTPUSHELEMNAME (pctxt, "ageOfSAI");

   stat = pd_ConsUInt16 (pctxt, &pvalue->ageOfSAI, 0, 32767);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LastKnownServiceArea (ranap_LastKnownServiceArea* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_SAI (&pvalue->sAI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LastKnownServiceArea (OSCTXT *pctxt, 
   ranap_LastKnownServiceArea* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_SAI (pctxt, &pvalue->sAI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UTRAN_CellID (OSCTXT* pctxt, ranap_UTRAN_CellID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UTRAN-CellID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellID */

   RTXCTXTPUSHELEMNAME (pctxt, "cellID");

   stat = asn1PE_ranap_TargetCellId (pctxt, pvalue->cellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UTRAN_CellID (OSCTXT* pctxt, ranap_UTRAN_CellID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UTRAN-CellID");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellID */
   RTXCTXTPUSHELEMNAME (pctxt, "cellID");

   stat = asn1PD_ranap_TargetCellId (pctxt, &pvalue->cellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UTRAN_CellID (ranap_UTRAN_CellID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_UTRAN_CellID (OSCTXT *pctxt, ranap_UTRAN_CellID* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_LastVisitedUTRANCell_Item (OSCTXT* pctxt, ranap_LastVisitedUTRANCell_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedUTRANCell-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uTRAN_CellID */

   RTXCTXTPUSHELEMNAME (pctxt, "uTRAN-CellID");

   stat = asn1PE_ranap_UTRAN_CellID (pctxt, &pvalue->uTRAN_CellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cellType */

   RTXCTXTPUSHELEMNAME (pctxt, "cellType");

   stat = asn1PE_ranap_CellType (pctxt, pvalue->cellType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode time_UE_StayedInCell */

   RTXCTXTPUSHELEMNAME (pctxt, "time-UE-StayedInCell");

   stat = asn1PE_ranap_Time_UE_StayedInCell (pctxt, pvalue->time_UE_StayedInCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LastVisitedUTRANCell_Item (OSCTXT* pctxt, ranap_LastVisitedUTRANCell_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LastVisitedUTRANCell-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode uTRAN_CellID */
   RTXCTXTPUSHELEMNAME (pctxt, "uTRAN-CellID");

   stat = asn1PD_ranap_UTRAN_CellID (pctxt, &pvalue->uTRAN_CellID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cellType */
   RTXCTXTPUSHELEMNAME (pctxt, "cellType");

   stat = asn1PD_ranap_CellType (pctxt, &pvalue->cellType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode time_UE_StayedInCell */
   RTXCTXTPUSHELEMNAME (pctxt, "time-UE-StayedInCell");

   stat = asn1PD_ranap_Time_UE_StayedInCell (pctxt, &pvalue->time_UE_StayedInCell);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LastVisitedUTRANCell_Item (
   ranap_LastVisitedUTRANCell_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_UTRAN_CellID (&pvalue->uTRAN_CellID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LastVisitedUTRANCell_Item (OSCTXT *pctxt, 
   ranap_LastVisitedUTRANCell_Item* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_UTRAN_CellID (pctxt, &pvalue->uTRAN_CellID);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_InterfacesToTraceItem (OSCTXT* pctxt, ranap_InterfacesToTraceItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InterfacesToTraceItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode interface_ */

   RTXCTXTPUSHELEMNAME (pctxt, "interface");

   stat = asn1PE_ranap_InterfacesToTraceItem_interface_ (pctxt, pvalue->interface_);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InterfacesToTraceItem (OSCTXT* pctxt, ranap_InterfacesToTraceItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InterfacesToTraceItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode interface_ */
   RTXCTXTPUSHELEMNAME (pctxt, "interface");

   stat = asn1PD_ranap_InterfacesToTraceItem_interface_ (pctxt, &pvalue->interface_);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InterfacesToTraceItem (ranap_InterfacesToTraceItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InterfacesToTraceItem (OSCTXT *pctxt, 
   ranap_InterfacesToTraceItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ListOfInterfacesToTrace (OSCTXT* pctxt, ranap_ListOfInterfacesToTrace* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ListOfInterfacesToTrace");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterfacesToTraceItem", xx1);

      stat = asn1PE_ranap_InterfacesToTraceItem (pctxt, ((ranap_InterfacesToTraceItem*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ListOfInterfacesToTrace (OSCTXT* pctxt, ranap_ListOfInterfacesToTrace* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ListOfInterfacesToTrace");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_InterfacesToTraceItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InterfacesToTraceItem", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_InterfacesToTraceItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_InterfacesToTraceItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_InterfacesToTraceItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ListOfInterfacesToTrace (
   ranap_ListOfInterfacesToTrace* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ListOfInterfacesToTrace (OSCTXT *pctxt, 
   ranap_ListOfInterfacesToTrace* pvalue)
{
   if (0 == pvalue) return;
   { ranap_InterfacesToTraceItem* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_InterfacesToTraceItem*)pnode->data;
      asn1Free_ranap_InterfacesToTraceItem (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_LocationRelatedDataRequestType (OSCTXT* pctxt, ranap_LocationRelatedDataRequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequestType");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.requestedGPSAssistanceDataPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode requestedLocationRelatedDataType */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedLocationRelatedDataType");

   stat = asn1PE_ranap_RequestedLocationRelatedDataType (pctxt, pvalue->requestedLocationRelatedDataType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode requestedGPSAssistanceData */

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedGPSAssistanceData");

      stat = asn1PE_ranap_RequestedGPSAssistanceData (pctxt, &pvalue->requestedGPSAssistanceData);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationRelatedDataRequestType (OSCTXT* pctxt, ranap_LocationRelatedDataRequestType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequestType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode requestedLocationRelatedDataType */
   RTXCTXTPUSHELEMNAME (pctxt, "requestedLocationRelatedDataType");

   stat = asn1PD_ranap_RequestedLocationRelatedDataType (pctxt, &pvalue->requestedLocationRelatedDataType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedGPSAssistanceData */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "requestedGPSAssistanceData");

      pvalue->m.requestedGPSAssistanceDataPresent = 1;

      stat = asn1PD_ranap_RequestedGPSAssistanceData (pctxt, &pvalue->requestedGPSAssistanceData);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationRelatedDataRequestType (
   ranap_LocationRelatedDataRequestType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RequestedGPSAssistanceData (&pvalue->requestedGPSAssistanceData);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationRelatedDataRequestType (OSCTXT *pctxt, 
   ranap_LocationRelatedDataRequestType* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_PeriodicLocationInfo (OSCTXT* pctxt, ranap_PeriodicLocationInfo* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PeriodicLocationInfo");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reportingAmount */

   RTXCTXTPUSHELEMNAME (pctxt, "reportingAmount");

   if ( (pvalue->reportingAmount >= 1 && pvalue->reportingAmount <= 8639999) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, pvalue->reportingAmount);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, pvalue->reportingAmount, 1, 8639999);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportingInterval */

   RTXCTXTPUSHELEMNAME (pctxt, "reportingInterval");

   if ( (pvalue->reportingInterval >= 1 && pvalue->reportingInterval <= 8639999) ) {
      extbit = 0;
   }
   else extbit = 1;

   /* extension bit */

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit) {
      stat = pe_UnconsUnsigned (pctxt, pvalue->reportingInterval);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pe_ConsUnsigned (pctxt, pvalue->reportingInterval, 1, 8639999);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PeriodicLocationInfo (OSCTXT* pctxt, ranap_PeriodicLocationInfo* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "PeriodicLocationInfo");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode reportingAmount */
   RTXCTXTPUSHELEMNAME (pctxt, "reportingAmount");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->reportingAmount, 1, 8639999);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->reportingAmount);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportingInterval */
   RTXCTXTPUSHELEMNAME (pctxt, "reportingInterval");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (extbit == 0) {
      stat = pd_ConsUnsigned (pctxt, &pvalue->reportingInterval, 1, 8639999);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      stat = pd_UnconsUnsigned (pctxt, &pvalue->reportingInterval);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PeriodicLocationInfo (ranap_PeriodicLocationInfo* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_PeriodicLocationInfo (OSCTXT *pctxt, 
   ranap_PeriodicLocationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationReportingTransferInformation (OSCTXT* pctxt, ranap_LocationReportingTransferInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingTransferInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.reportChangeOfSAIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.periodicReportingIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.directReportingIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.verticalAccuracyCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.positioningPriorityChangeSAIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.positioningPriorityDirectPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.clientTypePeriodicPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.clientTypeDirectPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.responseTimePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.includeVelocityPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.periodicLocationInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode reportChangeOfSAI */

   if (pvalue->m.reportChangeOfSAIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportChangeOfSAI");

      stat = asn1PE_ranap_ReportChangeOfSAI (pctxt, pvalue->reportChangeOfSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode periodicReportingIndicator */

   if (pvalue->m.periodicReportingIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicReportingIndicator");

      stat = asn1PE_ranap_PeriodicReportingIndicator (pctxt, pvalue->periodicReportingIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode directReportingIndicator */

   if (pvalue->m.directReportingIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "directReportingIndicator");

      stat = asn1PE_ranap_DirectReportingIndicator (pctxt, pvalue->directReportingIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode verticalAccuracyCode */

   if (pvalue->m.verticalAccuracyCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "verticalAccuracyCode");

      stat = asn1PE_ranap_VerticalAccuracyCode (pctxt, pvalue->verticalAccuracyCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode positioningPriorityChangeSAI */

   if (pvalue->m.positioningPriorityChangeSAIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningPriorityChangeSAI");

      stat = asn1PE_ranap_PositioningPriority (pctxt, pvalue->positioningPriorityChangeSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode positioningPriorityDirect */

   if (pvalue->m.positioningPriorityDirectPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningPriorityDirect");

      stat = asn1PE_ranap_PositioningPriority (pctxt, pvalue->positioningPriorityDirect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode clientTypePeriodic */

   if (pvalue->m.clientTypePeriodicPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "clientTypePeriodic");

      stat = asn1PE_ranap_ClientType (pctxt, pvalue->clientTypePeriodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode clientTypeDirect */

   if (pvalue->m.clientTypeDirectPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "clientTypeDirect");

      stat = asn1PE_ranap_ClientType (pctxt, pvalue->clientTypeDirect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode responseTime */

   if (pvalue->m.responseTimePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "responseTime");

      stat = asn1PE_ranap_ResponseTime (pctxt, pvalue->responseTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode includeVelocity */

   if (pvalue->m.includeVelocityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "includeVelocity");

      stat = asn1PE_ranap_IncludeVelocity (pctxt, pvalue->includeVelocity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode periodicLocationInfo */

   if (pvalue->m.periodicLocationInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicLocationInfo");

      stat = asn1PE_ranap_PeriodicLocationInfo (pctxt, &pvalue->periodicLocationInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationReportingTransferInformation (OSCTXT* pctxt, ranap_LocationReportingTransferInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[12];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingTransferInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 12; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode reportChangeOfSAI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "reportChangeOfSAI");

      pvalue->m.reportChangeOfSAIPresent = 1;

      stat = asn1PD_ranap_ReportChangeOfSAI (pctxt, &pvalue->reportChangeOfSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode periodicReportingIndicator */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicReportingIndicator");

      pvalue->m.periodicReportingIndicatorPresent = 1;

      stat = asn1PD_ranap_PeriodicReportingIndicator (pctxt, &pvalue->periodicReportingIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode directReportingIndicator */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "directReportingIndicator");

      pvalue->m.directReportingIndicatorPresent = 1;

      stat = asn1PD_ranap_DirectReportingIndicator (pctxt, &pvalue->directReportingIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode verticalAccuracyCode */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "verticalAccuracyCode");

      pvalue->m.verticalAccuracyCodePresent = 1;

      stat = asn1PD_ranap_VerticalAccuracyCode (pctxt, &pvalue->verticalAccuracyCode);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode positioningPriorityChangeSAI */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningPriorityChangeSAI");

      pvalue->m.positioningPriorityChangeSAIPresent = 1;

      stat = asn1PD_ranap_PositioningPriority (pctxt, &pvalue->positioningPriorityChangeSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode positioningPriorityDirect */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningPriorityDirect");

      pvalue->m.positioningPriorityDirectPresent = 1;

      stat = asn1PD_ranap_PositioningPriority (pctxt, &pvalue->positioningPriorityDirect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode clientTypePeriodic */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "clientTypePeriodic");

      pvalue->m.clientTypePeriodicPresent = 1;

      stat = asn1PD_ranap_ClientType (pctxt, &pvalue->clientTypePeriodic);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode clientTypeDirect */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "clientTypeDirect");

      pvalue->m.clientTypeDirectPresent = 1;

      stat = asn1PD_ranap_ClientType (pctxt, &pvalue->clientTypeDirect);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode responseTime */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "responseTime");

      pvalue->m.responseTimePresent = 1;

      stat = asn1PD_ranap_ResponseTime (pctxt, &pvalue->responseTime);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode includeVelocity */
   if (optbits[9]) {
      RTXCTXTPUSHELEMNAME (pctxt, "includeVelocity");

      pvalue->m.includeVelocityPresent = 1;

      stat = asn1PD_ranap_IncludeVelocity (pctxt, &pvalue->includeVelocity);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode periodicLocationInfo */
   if (optbits[10]) {
      RTXCTXTPUSHELEMNAME (pctxt, "periodicLocationInfo");

      pvalue->m.periodicLocationInfoPresent = 1;

      stat = asn1PD_ranap_PeriodicLocationInfo (pctxt, &pvalue->periodicLocationInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[11]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationReportingTransferInformation (
   ranap_LocationReportingTransferInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PeriodicLocationInfo (&pvalue->periodicLocationInfo);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationReportingTransferInformation (OSCTXT *pctxt, 
   ranap_LocationReportingTransferInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.periodicLocationInfoPresent) {
      asn1Free_ranap_PeriodicLocationInfo (pctxt, &pvalue->periodicLocationInfo);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_M4_Collection_Parameters (OSCTXT* pctxt, ranap_M4_Collection_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Collection-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.m4_thresholdPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode m4_period */

   RTXCTXTPUSHELEMNAME (pctxt, "m4-period");

   stat = asn1PE_ranap_M4_Period (pctxt, pvalue->m4_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode m4_threshold */

   if (pvalue->m.m4_thresholdPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "m4-threshold");

      stat = asn1PE_ranap_M4_Threshold (pctxt, pvalue->m4_threshold);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M4_Collection_Parameters (OSCTXT* pctxt, ranap_M4_Collection_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "M4-Collection-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode m4_period */
   RTXCTXTPUSHELEMNAME (pctxt, "m4-period");

   stat = asn1PD_ranap_M4_Period (pctxt, &pvalue->m4_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m4_threshold */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "m4-threshold");

      pvalue->m.m4_thresholdPresent = 1;

      stat = asn1PD_ranap_M4_Threshold (pctxt, &pvalue->m4_threshold);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M4_Collection_Parameters (
   ranap_M4_Collection_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_M4_Collection_Parameters (OSCTXT *pctxt, 
   ranap_M4_Collection_Parameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_M4Report (OSCTXT* pctxt, ranap_M4Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M4Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* all */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "all");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* m4_collection_parameters */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "m4-collection-parameters");

            stat = asn1PE_ranap_M4_Collection_Parameters (pctxt, pvalue->u.m4_collection_parameters);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M4Report (OSCTXT* pctxt, ranap_M4Report* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "M4Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* all */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "all");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* m4_collection_parameters */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "m4-collection-parameters");

            pvalue->u.m4_collection_parameters = rtxMemAllocType (pctxt, 
               ranap_M4_Collection_Parameters);

            if (pvalue->u.m4_collection_parameters == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_M4_Collection_Parameters (pvalue->u.m4_collection_parameters);

            stat = asn1PD_ranap_M4_Collection_Parameters (pctxt, pvalue->u.m4_collection_parameters);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M4Report (ranap_M4Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_M4Report (OSCTXT *pctxt, ranap_M4Report* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.m4_collection_parameters) {
            asn1Free_ranap_M4_Collection_Parameters (pctxt, pvalue->u.m4_collection_parameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.m4_collection_parameters);
            pvalue->u.m4_collection_parameters = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_M5Report (OSCTXT* pctxt, ranap_M5Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M5Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* when_available */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "when-available");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* m5_period */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "m5-period");

            stat = asn1PE_ranap_M5_Period (pctxt, pvalue->u.m5_period);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M5Report (OSCTXT* pctxt, ranap_M5Report* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "M5Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* when_available */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "when-available");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* m5_period */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "m5-period");

            stat = asn1PD_ranap_M5_Period (pctxt, &pvalue->u.m5_period);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M5Report (ranap_M5Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_M5Report (OSCTXT *pctxt, ranap_M5Report* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_M6Report (OSCTXT* pctxt, ranap_M6Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M6Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode m6_period */

   RTXCTXTPUSHELEMNAME (pctxt, "m6-period");

   stat = asn1PE_ranap_M6_Period (pctxt, pvalue->m6_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode m6_links_to_log */

   RTXCTXTPUSHELEMNAME (pctxt, "m6-links-to-log");

   stat = asn1PE_ranap_Links_to_log (pctxt, pvalue->m6_links_to_log);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M6Report (OSCTXT* pctxt, ranap_M6Report* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "M6Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode m6_period */
   RTXCTXTPUSHELEMNAME (pctxt, "m6-period");

   stat = asn1PD_ranap_M6_Period (pctxt, &pvalue->m6_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m6_links_to_log */
   RTXCTXTPUSHELEMNAME (pctxt, "m6-links-to-log");

   stat = asn1PD_ranap_Links_to_log (pctxt, &pvalue->m6_links_to_log);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M6Report (ranap_M6Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_M6Report (OSCTXT *pctxt, ranap_M6Report* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_M7Report (OSCTXT* pctxt, ranap_M7Report* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "M7Report");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode m7_period */

   RTXCTXTPUSHELEMNAME (pctxt, "m7-period");

   stat = asn1PE_ranap_M7_Period (pctxt, pvalue->m7_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode m7_links_to_log */

   RTXCTXTPUSHELEMNAME (pctxt, "m7-links-to-log");

   stat = asn1PE_ranap_Links_to_log (pctxt, pvalue->m7_links_to_log);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_M7Report (OSCTXT* pctxt, ranap_M7Report* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "M7Report");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode m7_period */
   RTXCTXTPUSHELEMNAME (pctxt, "m7-period");

   stat = asn1PD_ranap_M7_Period (pctxt, &pvalue->m7_period);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m7_links_to_log */
   RTXCTXTPUSHELEMNAME (pctxt, "m7-links-to-log");

   stat = asn1PD_ranap_Links_to_log (pctxt, &pvalue->m7_links_to_log);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_M7Report (ranap_M7Report* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_M7Report (OSCTXT *pctxt, ranap_M7Report* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LAI_List (OSCTXT* pctxt, ranap_LAI_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "LAI-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "LAI", xx1);

      stat = asn1PE_ranap_LAI (pctxt, ((ranap_LAI*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LAI_List (OSCTXT* pctxt, ranap_LAI_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LAI-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_LAI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "LAI", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_LAI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_LAI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_LAI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LAI_List (ranap_LAI_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_LAI_List (OSCTXT *pctxt, ranap_LAI_List* pvalue)
{
   if (0 == pvalue) return;
   { ranap_LAI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_LAI*)pnode->data;
      asn1Free_ranap_LAI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_LABased (OSCTXT* pctxt, ranap_LABased* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LABased");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode laiList */

   RTXCTXTPUSHELEMNAME (pctxt, "laiList");

   stat = asn1PE_ranap_LAI_List (pctxt, &pvalue->laiList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LABased (OSCTXT* pctxt, ranap_LABased* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LABased");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode laiList */
   RTXCTXTPUSHELEMNAME (pctxt, "laiList");

   stat = asn1PD_ranap_LAI_List (pctxt, &pvalue->laiList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LABased (ranap_LABased* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAI_List (&pvalue->laiList);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LABased (OSCTXT *pctxt, ranap_LABased* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_LAI_List (pctxt, &pvalue->laiList);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAI (OSCTXT* pctxt, ranap_RAI* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAI");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode lAI */

   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PE_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAC */

   RTXCTXTPUSHELEMNAME (pctxt, "rAC");

   stat = asn1PE_ranap_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAI (OSCTXT* pctxt, ranap_RAI* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAI");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode lAI */
   RTXCTXTPUSHELEMNAME (pctxt, "lAI");

   stat = asn1PD_ranap_LAI (pctxt, &pvalue->lAI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAC */
   RTXCTXTPUSHELEMNAME (pctxt, "rAC");

   stat = asn1PD_ranap_RAC (pctxt, &pvalue->rAC);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAI (ranap_RAI* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_LAI (&pvalue->lAI);
   asn1Init_ranap_RAC (&pvalue->rAC);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAI (OSCTXT *pctxt, ranap_RAI* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_LAI (pctxt, &pvalue->lAI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAI_List (OSCTXT* pctxt, ranap_RAI_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAI-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAI", xx1);

      stat = asn1PE_ranap_RAI (pctxt, ((ranap_RAI*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAI_List (OSCTXT* pctxt, ranap_RAI_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAI-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_RAI* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAI", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_RAI, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_RAI (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_RAI (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAI_List (ranap_RAI_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAI_List (OSCTXT *pctxt, ranap_RAI_List* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RAI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RAI*)pnode->data;
      asn1Free_ranap_RAI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RABased (OSCTXT* pctxt, ranap_RABased* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RABased");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode raiList */

   RTXCTXTPUSHELEMNAME (pctxt, "raiList");

   stat = asn1PE_ranap_RAI_List (pctxt, &pvalue->raiList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RABased (OSCTXT* pctxt, ranap_RABased* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RABased");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode raiList */
   RTXCTXTPUSHELEMNAME (pctxt, "raiList");

   stat = asn1PD_ranap_RAI_List (pctxt, &pvalue->raiList);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RABased (ranap_RABased* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAI_List (&pvalue->raiList);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RABased (OSCTXT *pctxt, ranap_RABased* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAI_List (pctxt, &pvalue->raiList);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MDTAreaScope (OSCTXT* pctxt, ranap_MDTAreaScope* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDTAreaScope");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* cellbased */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "cellbased");

            stat = asn1PE_ranap_CellBased (pctxt, pvalue->u.cellbased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* labased */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "labased");

            stat = asn1PE_ranap_LABased (pctxt, pvalue->u.labased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* rabased */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "rabased");

            stat = asn1PE_ranap_RABased (pctxt, pvalue->u.rabased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* plmn_area_based */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "plmn-area-based");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDTAreaScope (OSCTXT* pctxt, ranap_MDTAreaScope* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "MDTAreaScope");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* cellbased */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "cellbased");

            pvalue->u.cellbased = rtxMemAllocType (pctxt, ranap_CellBased);

            if (pvalue->u.cellbased == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_CellBased (pvalue->u.cellbased);

            stat = asn1PD_ranap_CellBased (pctxt, pvalue->u.cellbased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* labased */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "labased");

            pvalue->u.labased = rtxMemAllocType (pctxt, ranap_LABased);

            if (pvalue->u.labased == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_LABased (pvalue->u.labased);

            stat = asn1PD_ranap_LABased (pctxt, pvalue->u.labased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* rabased */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "rabased");

            pvalue->u.rabased = rtxMemAllocType (pctxt, ranap_RABased);

            if (pvalue->u.rabased == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RABased (pvalue->u.rabased);

            stat = asn1PD_ranap_RABased (pctxt, pvalue->u.rabased);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* plmn_area_based */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "plmn-area-based");

            /* NULL */

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MDTAreaScope (ranap_MDTAreaScope* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_MDTAreaScope (OSCTXT *pctxt, ranap_MDTAreaScope* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.cellbased) {
            asn1Free_ranap_CellBased (pctxt, pvalue->u.cellbased);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cellbased);
            pvalue->u.cellbased = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.labased) {
            asn1Free_ranap_LABased (pctxt, pvalue->u.labased);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.labased);
            pvalue->u.labased = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.rabased) {
            asn1Free_ranap_RABased (pctxt, pvalue->u.rabased);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rabased);
            pvalue->u.rabased = 0;
         }
         break;

      case 4:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_LoggedMDT (OSCTXT* pctxt, ranap_LoggedMDT* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LoggedMDT");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode loggingInterval */

   RTXCTXTPUSHELEMNAME (pctxt, "loggingInterval");

   stat = asn1PE_ranap_LoggingInterval (pctxt, pvalue->loggingInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode loggingDuration */

   RTXCTXTPUSHELEMNAME (pctxt, "loggingDuration");

   stat = asn1PE_ranap_LoggingDuration (pctxt, pvalue->loggingDuration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LoggedMDT (OSCTXT* pctxt, ranap_LoggedMDT* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LoggedMDT");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode loggingInterval */
   RTXCTXTPUSHELEMNAME (pctxt, "loggingInterval");

   stat = asn1PD_ranap_LoggingInterval (pctxt, &pvalue->loggingInterval);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode loggingDuration */
   RTXCTXTPUSHELEMNAME (pctxt, "loggingDuration");

   stat = asn1PD_ranap_LoggingDuration (pctxt, &pvalue->loggingDuration);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LoggedMDT (ranap_LoggedMDT* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LoggedMDT (OSCTXT *pctxt, ranap_LoggedMDT* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MDTMode (OSCTXT* pctxt, ranap_MDTMode* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDTMode");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* immediateMDT */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "immediateMDT");

            stat = asn1PE_ranap_ImmediateMDT (pctxt, pvalue->u.immediateMDT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* loggedMDT */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "loggedMDT");

            stat = asn1PE_ranap_LoggedMDT (pctxt, pvalue->u.loggedMDT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDTMode (OSCTXT* pctxt, ranap_MDTMode* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "MDTMode");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* immediateMDT */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "immediateMDT");

            pvalue->u.immediateMDT = rtxMemAllocType (pctxt, 
               ranap_ImmediateMDT);

            if (pvalue->u.immediateMDT == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_ImmediateMDT (pvalue->u.immediateMDT);

            stat = asn1PD_ranap_ImmediateMDT (pctxt, pvalue->u.immediateMDT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* loggedMDT */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "loggedMDT");

            pvalue->u.loggedMDT = rtxMemAllocType (pctxt, ranap_LoggedMDT);

            if (pvalue->u.loggedMDT == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_LoggedMDT (pvalue->u.loggedMDT);

            stat = asn1PD_ranap_LoggedMDT (pctxt, pvalue->u.loggedMDT);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MDTMode (ranap_MDTMode* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_MDTMode (OSCTXT *pctxt, ranap_MDTMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.immediateMDT) {
            asn1Free_ranap_ImmediateMDT (pctxt, pvalue->u.immediateMDT);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.immediateMDT);
            pvalue->u.immediateMDT = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.loggedMDT) {
            asn1Free_ranap_LoggedMDT (pctxt, pvalue->u.loggedMDT);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.loggedMDT);
            pvalue->u.loggedMDT = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_MDT_Configuration (OSCTXT* pctxt, ranap_MDT_Configuration* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Configuration");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mdtActivation */

   RTXCTXTPUSHELEMNAME (pctxt, "mdtActivation");

   stat = asn1PE_ranap_MDT_Activation (pctxt, pvalue->mdtActivation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mdtAreaScope */

   RTXCTXTPUSHELEMNAME (pctxt, "mdtAreaScope");

   stat = asn1PE_ranap_MDTAreaScope (pctxt, &pvalue->mdtAreaScope);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mdtMode */

   RTXCTXTPUSHELEMNAME (pctxt, "mdtMode");

   stat = asn1PE_ranap_MDTMode (pctxt, &pvalue->mdtMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDT_Configuration (OSCTXT* pctxt, ranap_MDT_Configuration* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-Configuration");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mdtActivation */
   RTXCTXTPUSHELEMNAME (pctxt, "mdtActivation");

   stat = asn1PD_ranap_MDT_Activation (pctxt, &pvalue->mdtActivation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mdtAreaScope */
   RTXCTXTPUSHELEMNAME (pctxt, "mdtAreaScope");

   stat = asn1PD_ranap_MDTAreaScope (pctxt, &pvalue->mdtAreaScope);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mdtMode */
   RTXCTXTPUSHELEMNAME (pctxt, "mdtMode");

   stat = asn1PD_ranap_MDTMode (pctxt, &pvalue->mdtMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MDT_Configuration (ranap_MDT_Configuration* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_MDTAreaScope (&pvalue->mdtAreaScope);
   asn1Init_ranap_MDTMode (&pvalue->mdtMode);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MDT_Configuration (OSCTXT *pctxt, 
   ranap_MDT_Configuration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_MDTAreaScope (pctxt, &pvalue->mdtAreaScope);
   asn1Free_ranap_MDTMode (pctxt, &pvalue->mdtMode);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MDT_PLMN_List (OSCTXT* pctxt, ranap_MDT_PLMN_List* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-PLMN-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(16), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMNidentity", xx1);

      stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MDT_PLMN_List (OSCTXT* pctxt, ranap_MDT_PLMN_List* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MDT-PLMN-List");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 16){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PLMNidentity", xx1);

      asn1Init_ranap_PLMNidentity (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MDT_PLMN_List (ranap_MDT_PLMN_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Offload_RAB_Parameters (OSCTXT* pctxt, ranap_Offload_RAB_Parameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode accessPointName */

   RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

   stat = asn1PE_ranap_Offload_RAB_Parameters_APN (pctxt, &pvalue->accessPointName);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode chargingCharacteristics */

   RTXCTXTPUSHELEMNAME (pctxt, "chargingCharacteristics");

   stat = asn1PE_ranap_Offload_RAB_Parameters_ChargingCharacteristics (pctxt, &pvalue->chargingCharacteristics);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Offload_RAB_Parameters (OSCTXT* pctxt, ranap_Offload_RAB_Parameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Offload-RAB-Parameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode accessPointName */
   RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

   stat = asn1PD_ranap_Offload_RAB_Parameters_APN (pctxt, &pvalue->accessPointName);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode chargingCharacteristics */
   RTXCTXTPUSHELEMNAME (pctxt, "chargingCharacteristics");

   stat = asn1PD_ranap_Offload_RAB_Parameters_ChargingCharacteristics (pctxt, &pvalue->chargingCharacteristics);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Offload_RAB_Parameters (
   ranap_Offload_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_Offload_RAB_Parameters_APN (&pvalue->accessPointName);
   asn1Init_ranap_Offload_RAB_Parameters_ChargingCharacteristics (&pvalue->chargingCharacteristics);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Offload_RAB_Parameters (OSCTXT *pctxt, 
   ranap_Offload_RAB_Parameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_PagingAreaID (OSCTXT* pctxt, ranap_PagingAreaID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingAreaID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* lAI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "lAI");

            stat = asn1PE_ranap_LAI (pctxt, pvalue->u.lAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* rAI */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "rAI");

            stat = asn1PE_ranap_RAI (pctxt, pvalue->u.rAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PagingAreaID (OSCTXT* pctxt, ranap_PagingAreaID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "PagingAreaID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* lAI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "lAI");

            pvalue->u.lAI = rtxMemAllocType (pctxt, ranap_LAI);

            if (pvalue->u.lAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_LAI (pvalue->u.lAI);

            stat = asn1PD_ranap_LAI (pctxt, pvalue->u.lAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* rAI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "rAI");

            pvalue->u.rAI = rtxMemAllocType (pctxt, ranap_RAI);

            if (pvalue->u.rAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_RAI (pvalue->u.rAI);

            stat = asn1PD_ranap_RAI (pctxt, pvalue->u.rAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PagingAreaID (ranap_PagingAreaID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_PagingAreaID (OSCTXT *pctxt, ranap_PagingAreaID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.lAI) {
            asn1Free_ranap_LAI (pctxt, pvalue->u.lAI);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.lAI);
            pvalue->u.lAI = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.rAI) {
            asn1Free_ranap_RAI (pctxt, pvalue->u.rAI);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rAI);
            pvalue->u.rAI = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_PDP_TypeInformation_extension (OSCTXT* pctxt, ranap_PDP_TypeInformation_extension* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-TypeInformation-extension");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDP-Type-extension", xx1);

      stat = asn1PE_ranap_PDP_Type_extension (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PDP_TypeInformation_extension (OSCTXT* pctxt, ranap_PDP_TypeInformation_extension* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDP-TypeInformation-extension");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PDP-Type-extension", xx1);

      stat = asn1PD_ranap_PDP_Type_extension (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PDP_TypeInformation_extension (
   ranap_PDP_TypeInformation_extension* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_PLMNs_in_shared_network_element (OSCTXT* pctxt, ranap_PLMNs_in_shared_network_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode lA_LIST */

   RTXCTXTPUSHELEMNAME (pctxt, "lA-LIST");

   stat = asn1PE_ranap_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_PLMNs_in_shared_network_element (OSCTXT* pctxt, ranap_PLMNs_in_shared_network_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode lA_LIST */
   RTXCTXTPUSHELEMNAME (pctxt, "lA-LIST");

   stat = asn1PD_ranap_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_PLMNs_in_shared_network_element (
   ranap_PLMNs_in_shared_network_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_LA_LIST (&pvalue->lA_LIST);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_PLMNs_in_shared_network_element (OSCTXT *pctxt, 
   ranap_PLMNs_in_shared_network_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_LA_LIST (pctxt, &pvalue->lA_LIST);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_PLMNs_in_shared_network (OSCTXT* pctxt, ranap_PLMNs_in_shared_network* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNs-in-shared-network");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_PLMNs_in_shared_network_element (pctxt, ((ranap_PLMNs_in_shared_network_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PLMNs_in_shared_network (OSCTXT* pctxt, ranap_PLMNs_in_shared_network* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PLMNs-in-shared-network");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(32), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_PLMNs_in_shared_network_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_PLMNs_in_shared_network_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_PLMNs_in_shared_network_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_PLMNs_in_shared_network_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PLMNs_in_shared_network (
   ranap_PLMNs_in_shared_network* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_PLMNs_in_shared_network (OSCTXT *pctxt, 
   ranap_PLMNs_in_shared_network* pvalue)
{
   if (0 == pvalue) return;
   { ranap_PLMNs_in_shared_network_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_PLMNs_in_shared_network_element*)pnode->data;
      asn1Free_ranap_PLMNs_in_shared_network_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_PositioningDataSet (OSCTXT* pctxt, ranap_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningDataSet");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(9), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PositioningMethodAndUsage", xx1);

      stat = asn1PE_ranap_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositioningDataSet (OSCTXT* pctxt, ranap_PositioningDataSet* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PositioningDataSet");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 4);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 9){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PositioningMethodAndUsage", xx1);

      asn1Init_ranap_PositioningMethodAndUsage (&pvalue->elem[xx1]);

      stat = asn1PD_ranap_PositioningMethodAndUsage (pctxt, &pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PositioningDataSet (ranap_PositioningDataSet* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_PositionData (OSCTXT* pctxt, ranap_PositionData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PositionData");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.positioningDataSetPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode positioningDataDiscriminator */

   RTXCTXTPUSHELEMNAME (pctxt, "positioningDataDiscriminator");

   stat = asn1PE_ranap_PositioningDataDiscriminator (pctxt, pvalue->positioningDataDiscriminator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode positioningDataSet */

   if (pvalue->m.positioningDataSetPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningDataSet");

      stat = asn1PE_ranap_PositioningDataSet (pctxt, &pvalue->positioningDataSet);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PositionData (OSCTXT* pctxt, ranap_PositionData* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "PositionData");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode positioningDataDiscriminator */
   RTXCTXTPUSHELEMNAME (pctxt, "positioningDataDiscriminator");

   stat = asn1PD_ranap_PositioningDataDiscriminator (pctxt, &pvalue->positioningDataDiscriminator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode positioningDataSet */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "positioningDataSet");

      pvalue->m.positioningDataSetPresent = 1;

      stat = asn1PD_ranap_PositioningDataSet (pctxt, &pvalue->positioningDataSet);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PositionData (ranap_PositionData* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PositioningDataDiscriminator (&pvalue->positioningDataDiscriminator);
   asn1Init_ranap_PositioningDataSet (&pvalue->positioningDataSet);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_PositionData (OSCTXT *pctxt, ranap_PositionData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Shared_Network_Information (OSCTXT* pctxt, ranap_Shared_Network_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Shared-Network-Information");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNs_in_shared_network */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNs-in-shared-network");

   stat = asn1PE_ranap_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Shared_Network_Information (OSCTXT* pctxt, ranap_Shared_Network_Information* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Shared-Network-Information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNs_in_shared_network */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNs-in-shared-network");

   stat = asn1PD_ranap_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Shared_Network_Information (
   ranap_Shared_Network_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNs_in_shared_network (&pvalue->pLMNs_in_shared_network);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Shared_Network_Information (OSCTXT *pctxt, 
   ranap_Shared_Network_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_PLMNs_in_shared_network (pctxt, &pvalue->pLMNs_in_shared_network);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ProvidedData (OSCTXT* pctxt, ranap_ProvidedData* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ProvidedData");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 1);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 0);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* shared_network_information */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "shared-network-information");

            stat = asn1PE_ranap_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 2);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProvidedData (OSCTXT* pctxt, ranap_ProvidedData* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "ProvidedData");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(0));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* shared_network_information */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "shared-network-information");

            pvalue->u.shared_network_information = rtxMemAllocType (pctxt, 
               ranap_Shared_Network_Information);

            if (pvalue->u.shared_network_information == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_Shared_Network_Information (pvalue->u.shared_network_information);

            stat = asn1PD_ranap_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 2;

      if (pvalue->t < 2) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProvidedData (ranap_ProvidedData* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_ProvidedData (OSCTXT *pctxt, ranap_ProvidedData* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.shared_network_information) {
            asn1Free_ranap_Shared_Network_Information (pctxt, pvalue->u.shared_network_information);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.shared_network_information);
            pvalue->u.shared_network_information = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_RABDataVolumeReport_element (OSCTXT* pctxt, ranap_RABDataVolumeReport_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataVolumeReferencePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_UnsuccessfullyTransmittedDataVolume */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

   stat = asn1PE_ranap_UnsuccessfullyTransmittedDataVolume (pctxt, pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataVolumeReference */

   if (pvalue->m.dataVolumeReferencePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReference");

      stat = asn1PE_ranap_DataVolumeReference (pctxt, pvalue->dataVolumeReference);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_RABDataVolumeReport_element (OSCTXT* pctxt, ranap_RABDataVolumeReport_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_UnsuccessfullyTransmittedDataVolume */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

   stat = asn1PD_ranap_UnsuccessfullyTransmittedDataVolume (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataVolumeReference */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReference");

      pvalue->m.dataVolumeReferencePresent = 1;

      stat = asn1PD_ranap_DataVolumeReference (pctxt, &pvalue->dataVolumeReference);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_RABDataVolumeReport_element (
   ranap_RABDataVolumeReport_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RABDataVolumeReport_element (OSCTXT *pctxt, 
   ranap_RABDataVolumeReport_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RABDataVolumeReport (OSCTXT* pctxt, ranap_RABDataVolumeReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RABDataVolumeReport");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_RABDataVolumeReport_element (pctxt, ((ranap_RABDataVolumeReport_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RABDataVolumeReport (OSCTXT* pctxt, ranap_RABDataVolumeReport* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RABDataVolumeReport");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_RABDataVolumeReport_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_RABDataVolumeReport_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_RABDataVolumeReport_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_RABDataVolumeReport_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RABDataVolumeReport (ranap_RABDataVolumeReport* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RABDataVolumeReport (OSCTXT *pctxt, 
   ranap_RABDataVolumeReport* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RABDataVolumeReport_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RABDataVolumeReport_element*)pnode->data;
      asn1Free_ranap_RABDataVolumeReport_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PE_ranap_ExtendedGuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PD_ranap_ExtendedGuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_Parameter_ExtendedGuaranteedBitrateList (
   ranap_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-ExtendedMaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PE_ranap_ExtendedMaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-Parameter-ExtendedMaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PD_ranap_ExtendedMaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_Parameter_ExtendedMaxBitrateList (
   ranap_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_UPInformation (OSCTXT* pctxt, ranap_UPInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UPInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode frameSeqNoUL */

   RTXCTXTPUSHELEMNAME (pctxt, "frameSeqNoUL");

   stat = asn1PE_ranap_FrameSequenceNumber (pctxt, pvalue->frameSeqNoUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode frameSeqNoDL */

   RTXCTXTPUSHELEMNAME (pctxt, "frameSeqNoDL");

   stat = asn1PE_ranap_FrameSequenceNumber (pctxt, pvalue->frameSeqNoDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdu14FrameSeqNoUL */

   RTXCTXTPUSHELEMNAME (pctxt, "pdu14FrameSeqNoUL");

   stat = asn1PE_ranap_PDUType14FrameSequenceNumber (pctxt, pvalue->pdu14FrameSeqNoUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pdu14FrameSeqNoDL */

   RTXCTXTPUSHELEMNAME (pctxt, "pdu14FrameSeqNoDL");

   stat = asn1PE_ranap_PDUType14FrameSequenceNumber (pctxt, pvalue->pdu14FrameSeqNoDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataPDUType */

   RTXCTXTPUSHELEMNAME (pctxt, "dataPDUType");

   stat = asn1PE_ranap_DataPDUType (pctxt, pvalue->dataPDUType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode upinitialisationFrame */

   RTXCTXTPUSHELEMNAME (pctxt, "upinitialisationFrame");

   stat = asn1PE_ranap_UPInitialisationFrame (pctxt, pvalue->upinitialisationFrame);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UPInformation (OSCTXT* pctxt, ranap_UPInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UPInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode frameSeqNoUL */
   RTXCTXTPUSHELEMNAME (pctxt, "frameSeqNoUL");

   stat = asn1PD_ranap_FrameSequenceNumber (pctxt, &pvalue->frameSeqNoUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode frameSeqNoDL */
   RTXCTXTPUSHELEMNAME (pctxt, "frameSeqNoDL");

   stat = asn1PD_ranap_FrameSequenceNumber (pctxt, &pvalue->frameSeqNoDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdu14FrameSeqNoUL */
   RTXCTXTPUSHELEMNAME (pctxt, "pdu14FrameSeqNoUL");

   stat = asn1PD_ranap_PDUType14FrameSequenceNumber (pctxt, &pvalue->pdu14FrameSeqNoUL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdu14FrameSeqNoDL */
   RTXCTXTPUSHELEMNAME (pctxt, "pdu14FrameSeqNoDL");

   stat = asn1PD_ranap_PDUType14FrameSequenceNumber (pctxt, &pvalue->pdu14FrameSeqNoDL);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataPDUType */
   RTXCTXTPUSHELEMNAME (pctxt, "dataPDUType");

   stat = asn1PD_ranap_DataPDUType (pctxt, &pvalue->dataPDUType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode upinitialisationFrame */
   RTXCTXTPUSHELEMNAME (pctxt, "upinitialisationFrame");

   stat = asn1PD_ranap_UPInitialisationFrame (pctxt, &pvalue->upinitialisationFrame);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UPInformation (ranap_UPInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_UPInitialisationFrame (&pvalue->upinitialisationFrame);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UPInformation (OSCTXT *pctxt, ranap_UPInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_UPInitialisationFrame (pctxt, &pvalue->upinitialisationFrame);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RABParametersList_element (OSCTXT* pctxt, ranap_RABParametersList_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rabDataVolumeReportPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.upInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rab_Id */

   RTXCTXTPUSHELEMNAME (pctxt, "rab-Id");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rab_Id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cn_domain */

   RTXCTXTPUSHELEMNAME (pctxt, "cn-domain");

   stat = asn1PE_ranap_CN_DomainIndicator (pctxt, pvalue->cn_domain);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rabDataVolumeReport */

   if (pvalue->m.rabDataVolumeReportPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rabDataVolumeReport");

      stat = asn1PE_ranap_RABDataVolumeReport (pctxt, &pvalue->rabDataVolumeReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode upInformation */

   if (pvalue->m.upInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "upInformation");

      stat = asn1PE_ranap_UPInformation (pctxt, &pvalue->upInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_RABParametersList_element (OSCTXT* pctxt, ranap_RABParametersList_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rab_Id */
   RTXCTXTPUSHELEMNAME (pctxt, "rab-Id");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rab_Id);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cn_domain */
   RTXCTXTPUSHELEMNAME (pctxt, "cn-domain");

   stat = asn1PD_ranap_CN_DomainIndicator (pctxt, &pvalue->cn_domain);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rabDataVolumeReport */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rabDataVolumeReport");

      pvalue->m.rabDataVolumeReportPresent = 1;

      stat = asn1PD_ranap_RABDataVolumeReport (pctxt, &pvalue->rabDataVolumeReport);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode upInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "upInformation");

      pvalue->m.upInformationPresent = 1;

      stat = asn1PD_ranap_UPInformation (pctxt, &pvalue->upInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_RABParametersList_element (
   ranap_RABParametersList_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rab_Id);
   asn1Init_ranap_RABDataVolumeReport (&pvalue->rabDataVolumeReport);
   asn1Init_ranap_UPInformation (&pvalue->upInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RABParametersList_element (OSCTXT *pctxt, 
   ranap_RABParametersList_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rabDataVolumeReportPresent) {
      asn1Free_ranap_RABDataVolumeReport (pctxt, &pvalue->rabDataVolumeReport);
   }
   if (pvalue->m.upInformationPresent) {
      asn1Free_ranap_UPInformation (pctxt, &pvalue->upInformation);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RABParametersList (OSCTXT* pctxt, ranap_RABParametersList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RABParametersList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_RABParametersList_element (pctxt, ((ranap_RABParametersList_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RABParametersList (OSCTXT* pctxt, ranap_RABParametersList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RABParametersList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_RABParametersList_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_RABParametersList_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_RABParametersList_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_RABParametersList_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RABParametersList (ranap_RABParametersList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RABParametersList (OSCTXT *pctxt, 
   ranap_RABParametersList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RABParametersList_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RABParametersList_element*)pnode->data;
      asn1Free_ranap_RABParametersList_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_TrCH_ID (OSCTXT* pctxt, ranap_TrCH_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TrCH-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dCH_IDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dSCH_IDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uSCH_IDPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dCH_ID */

   if (pvalue->m.dCH_IDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dCH-ID");

      stat = asn1PE_ranap_DCH_ID (pctxt, pvalue->dCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dSCH_ID */

   if (pvalue->m.dSCH_IDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dSCH-ID");

      stat = asn1PE_ranap_DSCH_ID (pctxt, pvalue->dSCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uSCH_ID */

   if (pvalue->m.uSCH_IDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uSCH-ID");

      stat = asn1PE_ranap_USCH_ID (pctxt, pvalue->uSCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TrCH_ID (OSCTXT* pctxt, ranap_TrCH_ID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "TrCH-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dCH_ID */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dCH-ID");

      pvalue->m.dCH_IDPresent = 1;

      stat = asn1PD_ranap_DCH_ID (pctxt, &pvalue->dCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dSCH_ID */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dSCH-ID");

      pvalue->m.dSCH_IDPresent = 1;

      stat = asn1PD_ranap_DSCH_ID (pctxt, &pvalue->dSCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uSCH_ID */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uSCH-ID");

      pvalue->m.uSCH_IDPresent = 1;

      stat = asn1PD_ranap_USCH_ID (pctxt, &pvalue->uSCH_ID);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TrCH_ID (ranap_TrCH_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TrCH_ID (OSCTXT *pctxt, ranap_TrCH_ID* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TrCH_ID_List (OSCTXT* pctxt, ranap_TrCH_ID_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "TrCH-ID-List");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(7), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TrCH-ID", xx1);

      stat = asn1PE_ranap_TrCH_ID (pctxt, ((ranap_TrCH_ID*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TrCH_ID_List (OSCTXT* pctxt, ranap_TrCH_ID_List* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrCH-ID-List");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(7), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_TrCH_ID* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TrCH-ID", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_TrCH_ID, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_TrCH_ID (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_TrCH_ID (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TrCH_ID_List (ranap_TrCH_ID_List* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_TrCH_ID_List (OSCTXT *pctxt, ranap_TrCH_ID_List* pvalue)
{
   if (0 == pvalue) return;
   { ranap_TrCH_ID* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_TrCH_ID*)pnode->data;
      asn1Free_ranap_TrCH_ID (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAB_TrCH_MappingItem (OSCTXT* pctxt, ranap_RAB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-TrCH-MappingItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode trCH_ID_List */

   RTXCTXTPUSHELEMNAME (pctxt, "trCH-ID-List");

   stat = asn1PE_ranap_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_TrCH_MappingItem (OSCTXT* pctxt, ranap_RAB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-TrCH-MappingItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trCH_ID_List */
   RTXCTXTPUSHELEMNAME (pctxt, "trCH-ID-List");

   stat = asn1PD_ranap_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_TrCH_MappingItem (ranap_RAB_TrCH_MappingItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TrCH_ID_List (&pvalue->trCH_ID_List);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_TrCH_MappingItem (OSCTXT *pctxt, 
   ranap_RAB_TrCH_MappingItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TrCH_ID_List (pctxt, &pvalue->trCH_ID_List);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_TrCH_Mapping (OSCTXT* pctxt, ranap_RAB_TrCH_Mapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-TrCH-Mapping");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-TrCH-MappingItem", xx1);

      stat = asn1PE_ranap_RAB_TrCH_MappingItem (pctxt, ((ranap_RAB_TrCH_MappingItem*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_TrCH_Mapping (OSCTXT* pctxt, ranap_RAB_TrCH_Mapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-TrCH-Mapping");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_RAB_TrCH_MappingItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAB-TrCH-MappingItem", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_RAB_TrCH_MappingItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_RAB_TrCH_MappingItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_RAB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_TrCH_Mapping (ranap_RAB_TrCH_Mapping* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_TrCH_Mapping (OSCTXT *pctxt, 
   ranap_RAB_TrCH_Mapping* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RAB_TrCH_MappingItem* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RAB_TrCH_MappingItem*)pnode->data;
      asn1Free_ranap_RAB_TrCH_MappingItem (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAofIdleModeUEs (OSCTXT* pctxt, ranap_RAofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "RAofIdleModeUEs");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         stat = asn1PE_ranap_RAC (pctxt, ((ranap_RAC*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAofIdleModeUEs (OSCTXT* pctxt, ranap_RAofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAofIdleModeUEs");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_RAC* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "RAC", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_RAC, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_RAC (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_RAC (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAofIdleModeUEs (ranap_RAofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAofIdleModeUEs (OSCTXT *pctxt, 
   ranap_RAofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_RAC* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_RAC*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_NotEmptyRAListofIdleModeUEs (OSCTXT* pctxt, ranap_NotEmptyRAListofIdleModeUEs* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NotEmptyRAListofIdleModeUEs");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAofIdleModeUEs */

   RTXCTXTPUSHELEMNAME (pctxt, "rAofIdleModeUEs");

   stat = asn1PE_ranap_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_NotEmptyRAListofIdleModeUEs (OSCTXT* pctxt, ranap_NotEmptyRAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "NotEmptyRAListofIdleModeUEs");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAofIdleModeUEs */
   RTXCTXTPUSHELEMNAME (pctxt, "rAofIdleModeUEs");

   stat = asn1PD_ranap_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_NotEmptyRAListofIdleModeUEs (
   ranap_NotEmptyRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAofIdleModeUEs (&pvalue->rAofIdleModeUEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_NotEmptyRAListofIdleModeUEs (OSCTXT *pctxt, 
   ranap_NotEmptyRAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAofIdleModeUEs (pctxt, &pvalue->rAofIdleModeUEs);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_RAListofIdleModeUEs (OSCTXT* pctxt, ranap_RAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAListofIdleModeUEs");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* notEmptyRAListofIdleModeUEs */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "notEmptyRAListofIdleModeUEs");

            stat = asn1PE_ranap_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* emptyFullRAListofIdleModeUEs */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "emptyFullRAListofIdleModeUEs");

            stat = asn1PE_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (pctxt, pvalue->u.emptyFullRAListofIdleModeUEs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAListofIdleModeUEs (OSCTXT* pctxt, ranap_RAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "RAListofIdleModeUEs");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* notEmptyRAListofIdleModeUEs */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "notEmptyRAListofIdleModeUEs");

            pvalue->u.notEmptyRAListofIdleModeUEs = rtxMemAllocType (pctxt, 
               ranap_NotEmptyRAListofIdleModeUEs);

            if (pvalue->u.notEmptyRAListofIdleModeUEs == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_NotEmptyRAListofIdleModeUEs (pvalue->u.notEmptyRAListofIdleModeUEs);

            stat = asn1PD_ranap_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* emptyFullRAListofIdleModeUEs */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "emptyFullRAListofIdleModeUEs");

            stat = asn1PD_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (pctxt, &pvalue->u.emptyFullRAListofIdleModeUEs);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAListofIdleModeUEs (ranap_RAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_RAListofIdleModeUEs (OSCTXT *pctxt, 
   ranap_RAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.notEmptyRAListofIdleModeUEs) {
            asn1Free_ranap_NotEmptyRAListofIdleModeUEs (pctxt, pvalue->u.notEmptyRAListofIdleModeUEs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.notEmptyRAListofIdleModeUEs);
            pvalue->u.notEmptyRAListofIdleModeUEs = 0;
         }
         break;

      case 2:
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_LAListofIdleModeUEs (OSCTXT* pctxt, ranap_LAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;
   OSUINT32 enclen, fraglen;

   RTXCTXTPUSHTYPENAME (pctxt, "LAListofIdleModeUEs");

   enclen = fraglen = xx1 = 0;
   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   pnode = pvalue->head;
   for (;;) {
      /* encode length determinant */

      stat = pe_Length (pctxt, (pvalue->count - enclen));
      if (stat < 0) return LOG_RTERR (pctxt, stat);

      fraglen = stat;
      enclen += fraglen;

      /* encode elements */

      for (; xx1 < enclen; xx1++) {
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "LAI", xx1);

         stat = asn1PE_ranap_LAI (pctxt, ((ranap_LAI*)pnode->data));
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         pnode = pnode->next;

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }
      if (pvalue->count == enclen && fraglen < 16384) {
         break;
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LAListofIdleModeUEs (OSCTXT* pctxt, ranap_LAListofIdleModeUEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;
   int lstat;
   OSSIZE total = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LAListofIdleModeUEs");

   rtxDListInit (pvalue);

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(65536), 0, 0);

   for (;;) {
      /* decode length determinant */

      lstat = pd_Length64 (pctxt, &count);
      if (lstat != 0 && lstat != ASN_OK_FRAG) {
         return LOG_RTERR (pctxt, lstat);
      }
      else if (count == 0) break;
      total += count;

      /* decode elements */

      for (; xx1 < total; xx1++) {
         ranap_LAI* pdata;
         RTXCTXTPUSHARRAYELEMNAME (pctxt, "LAI", xx1);

         rtxDListAllocNodeAndData (pctxt, ranap_LAI, &pnode, &pdata);

         if (pnode == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_LAI (pdata);

         rtxDListAppendNode (pvalue, pnode);
         stat = asn1PD_ranap_LAI (pctxt, pdata);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPARRAYELEMNAME (pctxt);
      }

      if (lstat == 0) break;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LAListofIdleModeUEs (ranap_LAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_LAListofIdleModeUEs (OSCTXT *pctxt, 
   ranap_LAListofIdleModeUEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_LAI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_LAI*)pnode->data;
      asn1Free_ranap_LAI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-ExtendedMaxBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PE_ranap_ExtendedMaxBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-ExtendedMaxBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedMaxBitrate", xx1);

      stat = asn1PD_ranap_ExtendedMaxBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList (
   ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->n);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PE_ranap_ExtendedGuaranteedBitrate (pctxt, pvalue->elem[xx1]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList (OSCTXT* pctxt, ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   int stat = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Requested-RAB-Parameter-ExtendedGuaranteedBitrateList");

   /* decode length determinant */

   stat = rtxDecBitsToSize (pctxt, &pvalue->n, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   pvalue->n += 1;

   if (pvalue->n < 1 || pvalue->n > 2){
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddSizeParm (pctxt, pvalue->n);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   /* decode elements */

   for (xx1 = 0; xx1 < pvalue->n; xx1++) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtendedGuaranteedBitrate", xx1);

      stat = asn1PD_ranap_ExtendedGuaranteedBitrate (pctxt, &pvalue->elem[xx1]);

      if (stat != 0) {
         pvalue->n = xx1 + 1;
         return LOG_RTERR (pctxt, stat);
      }

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList (
   ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->n = 0;
   return 0;
}

EXTERN int asn1PE_ranap_RequestType (OSCTXT* pctxt, ranap_RequestType* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestType");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.accuracyCodePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode event */

   RTXCTXTPUSHELEMNAME (pctxt, "event");

   stat = asn1PE_ranap_Event (pctxt, pvalue->event);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode reportArea */

   RTXCTXTPUSHELEMNAME (pctxt, "reportArea");

   stat = asn1PE_ranap_ReportArea (pctxt, pvalue->reportArea);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode accuracyCode */

   if (pvalue->m.accuracyCodePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "accuracyCode");

      if ( pvalue->accuracyCode <= 127 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->accuracyCode, 0, 127);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->accuracyCode);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RequestType (OSCTXT* pctxt, ranap_RequestType* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RequestType");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode event */
   RTXCTXTPUSHELEMNAME (pctxt, "event");

   stat = asn1PD_ranap_Event (pctxt, &pvalue->event);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode reportArea */
   RTXCTXTPUSHELEMNAME (pctxt, "reportArea");

   stat = asn1PD_ranap_ReportArea (pctxt, &pvalue->reportArea);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode accuracyCode */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "accuracyCode");

      pvalue->m.accuracyCodePresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->accuracyCode, 0, 127);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RequestType (ranap_RequestType* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RequestType (OSCTXT *pctxt, ranap_RequestType* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UE_ID (OSCTXT* pctxt, ranap_UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* imsi */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "imsi");

            stat = asn1PE_ranap_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* imei */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "imei");

            stat = asn1PE_ranap_IMEI (pctxt, pvalue->u.imei);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* imeisv */
         case 3:
            stat = asn1PE_ranap_IMEISV (pctxt, pvalue->u.imeisv);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_ID (OSCTXT* pctxt, ranap_UE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* imsi */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "imsi");

            pvalue->u.imsi = rtxMemAllocType (pctxt, ranap_IMSI);

            if (pvalue->u.imsi == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMSI (pvalue->u.imsi);

            stat = asn1PD_ranap_IMSI (pctxt, pvalue->u.imsi);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* imei */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "imei");

            pvalue->u.imei = rtxMemAllocType (pctxt, ranap_IMEI);

            if (pvalue->u.imei == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEI (pvalue->u.imei);

            stat = asn1PD_ranap_IMEI (pctxt, pvalue->u.imei);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 4) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* imeisv */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "imeisv");

            pvalue->u.imeisv = rtxMemAllocType (pctxt, ranap_IMEISV);

            if (pvalue->u.imeisv == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_IMEISV (pvalue->u.imeisv);

            stat = asn1PD_ranap_IMEISV (pctxt, pvalue->u.imeisv);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 4) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UE_ID (ranap_UE_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_UE_ID (OSCTXT *pctxt, ranap_UE_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.imsi) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.imsi);
            pvalue->u.imsi = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.imei) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.imei);
            pvalue->u.imei = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.imeisv) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.imeisv);
            pvalue->u.imeisv = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_TracePropagationParameters (OSCTXT* pctxt, ranap_TracePropagationParameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TracePropagationParameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.listOfInterfacesToTracePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode traceRecordingSessionReference */

   RTXCTXTPUSHELEMNAME (pctxt, "traceRecordingSessionReference");

   stat = asn1PE_ranap_TraceRecordingSessionReference (pctxt, pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode traceDepth */

   RTXCTXTPUSHELEMNAME (pctxt, "traceDepth");

   stat = asn1PE_ranap_TraceDepth (pctxt, pvalue->traceDepth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode listOfInterfacesToTrace */

   if (pvalue->m.listOfInterfacesToTracePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "listOfInterfacesToTrace");

      stat = asn1PE_ranap_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TracePropagationParameters (OSCTXT* pctxt, ranap_TracePropagationParameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "TracePropagationParameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode traceRecordingSessionReference */
   RTXCTXTPUSHELEMNAME (pctxt, "traceRecordingSessionReference");

   stat = asn1PD_ranap_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode traceDepth */
   RTXCTXTPUSHELEMNAME (pctxt, "traceDepth");

   stat = asn1PD_ranap_TraceDepth (pctxt, &pvalue->traceDepth);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode listOfInterfacesToTrace */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "listOfInterfacesToTrace");

      pvalue->m.listOfInterfacesToTracePresent = 1;

      stat = asn1PD_ranap_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TracePropagationParameters (
   ranap_TracePropagationParameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ListOfInterfacesToTrace (&pvalue->listOfInterfacesToTrace);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TracePropagationParameters (OSCTXT *pctxt, 
   ranap_TracePropagationParameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.listOfInterfacesToTracePresent) {
      asn1Free_ranap_ListOfInterfacesToTrace (pctxt, &pvalue->listOfInterfacesToTrace);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TraceInformation (OSCTXT* pctxt, ranap_TraceInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.tracePropagationParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode traceReference */

   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PE_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode ue_identity */

   RTXCTXTPUSHELEMNAME (pctxt, "ue-identity");

   stat = asn1PE_ranap_UE_ID (pctxt, &pvalue->ue_identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode tracePropagationParameters */

   if (pvalue->m.tracePropagationParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "tracePropagationParameters");

      stat = asn1PE_ranap_TracePropagationParameters (pctxt, &pvalue->tracePropagationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceInformation (OSCTXT* pctxt, ranap_TraceInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "TraceInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode traceReference */
   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PD_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ue_identity */
   RTXCTXTPUSHELEMNAME (pctxt, "ue-identity");

   stat = asn1PD_ranap_UE_ID (pctxt, &pvalue->ue_identity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tracePropagationParameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "tracePropagationParameters");

      pvalue->m.tracePropagationParametersPresent = 1;

      stat = asn1PD_ranap_TracePropagationParameters (pctxt, &pvalue->tracePropagationParameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TraceInformation (ranap_TraceInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TraceReference (&pvalue->traceReference);
   asn1Init_ranap_UE_ID (&pvalue->ue_identity);
   asn1Init_ranap_TracePropagationParameters (&pvalue->tracePropagationParameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TraceInformation (OSCTXT *pctxt, 
   ranap_TraceInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_UE_ID (pctxt, &pvalue->ue_identity);
   if (pvalue->m.tracePropagationParametersPresent) {
      asn1Free_ranap_TracePropagationParameters (pctxt, &pvalue->tracePropagationParameters);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RNSAPRelocationParameters (OSCTXT* pctxt, ranap_RNSAPRelocationParameters* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RNSAPRelocationParameters");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rabParmetersListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.locationReportingPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.traceInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourceSAIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rabParmetersList */

   if (pvalue->m.rabParmetersListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rabParmetersList");

      stat = asn1PE_ranap_RABParametersList (pctxt, &pvalue->rabParmetersList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode locationReporting */

   if (pvalue->m.locationReportingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "locationReporting");

      stat = asn1PE_ranap_LocationReportingTransferInformation (pctxt, &pvalue->locationReporting);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode traceInformation */

   if (pvalue->m.traceInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "traceInformation");

      stat = asn1PE_ranap_TraceInformation (pctxt, &pvalue->traceInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sourceSAI */

   if (pvalue->m.sourceSAIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceSAI");

      stat = asn1PE_ranap_SAI (pctxt, &pvalue->sourceSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RNSAPRelocationParameters (OSCTXT* pctxt, ranap_RNSAPRelocationParameters* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RNSAPRelocationParameters");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rabParmetersList */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rabParmetersList");

      pvalue->m.rabParmetersListPresent = 1;

      stat = asn1PD_ranap_RABParametersList (pctxt, &pvalue->rabParmetersList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode locationReporting */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "locationReporting");

      pvalue->m.locationReportingPresent = 1;

      stat = asn1PD_ranap_LocationReportingTransferInformation (pctxt, &pvalue->locationReporting);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode traceInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "traceInformation");

      pvalue->m.traceInformationPresent = 1;

      stat = asn1PD_ranap_TraceInformation (pctxt, &pvalue->traceInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sourceSAI */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceSAI");

      pvalue->m.sourceSAIPresent = 1;

      stat = asn1PD_ranap_SAI (pctxt, &pvalue->sourceSAI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RNSAPRelocationParameters (
   ranap_RNSAPRelocationParameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RABParametersList (&pvalue->rabParmetersList);
   asn1Init_ranap_LocationReportingTransferInformation (&pvalue->locationReporting);
   asn1Init_ranap_TraceInformation (&pvalue->traceInformation);
   asn1Init_ranap_SAI (&pvalue->sourceSAI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RNSAPRelocationParameters (OSCTXT *pctxt, 
   ranap_RNSAPRelocationParameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rabParmetersListPresent) {
      asn1Free_ranap_RABParametersList (pctxt, &pvalue->rabParmetersList);
   }
   if (pvalue->m.locationReportingPresent) {
      asn1Free_ranap_LocationReportingTransferInformation (pctxt, &pvalue->locationReporting);
   }
   if (pvalue->m.traceInformationPresent) {
      asn1Free_ranap_TraceInformation (pctxt, &pvalue->traceInformation);
   }
   if (pvalue->m.sourceSAIPresent) {
      asn1Free_ranap_SAI (pctxt, &pvalue->sourceSAI);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RSRVCC_Information (OSCTXT* pctxt, ranap_RSRVCC_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-Information");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonce */

   RTXCTXTPUSHELEMNAME (pctxt, "nonce");

   stat = asn1PE_ranap_RSRVCC_Information_nonce (pctxt, &pvalue->nonce);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iMSInformation */

   RTXCTXTPUSHELEMNAME (pctxt, "iMSInformation");

   stat = asn1PE_ranap_RSRVCC_Information_iMSInformation (pctxt, &pvalue->iMSInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRVCC_Information (OSCTXT* pctxt, ranap_RSRVCC_Information* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RSRVCC-Information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonce */
   RTXCTXTPUSHELEMNAME (pctxt, "nonce");

   stat = asn1PD_ranap_RSRVCC_Information_nonce (pctxt, &pvalue->nonce);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iMSInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "iMSInformation");

   stat = asn1PD_ranap_RSRVCC_Information_iMSInformation (pctxt, &pvalue->iMSInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RSRVCC_Information (ranap_RSRVCC_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RSRVCC_Information_nonce (&pvalue->nonce);
   asn1Init_ranap_RSRVCC_Information_iMSInformation (&pvalue->iMSInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RSRVCC_Information (OSCTXT *pctxt, 
   ranap_RSRVCC_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SGSN_Group_Identity (OSCTXT* pctxt, ranap_SGSN_Group_Identity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SGSN-Group-Identity");

   /* Encode choice index value */

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* null_NRI */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "null-NRI");

         stat = asn1PE_ranap_Null_NRI (pctxt, *pvalue->u.null_NRI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* sGSN_Group_ID */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sGSN-Group-ID");

         stat = asn1PE_ranap_SGSN_Group_ID (pctxt, pvalue->u.sGSN_Group_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SGSN_Group_Identity (OSCTXT* pctxt, ranap_SGSN_Group_Identity* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "SGSN-Group-Identity");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* null_NRI */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "null-NRI");

         pvalue->u.null_NRI = rtxMemAllocType (pctxt, ranap_Null_NRI);

         if (pvalue->u.null_NRI == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_Null_NRI (pvalue->u.null_NRI);

         stat = asn1PD_ranap_Null_NRI (pctxt, pvalue->u.null_NRI);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* sGSN_Group_ID */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "sGSN-Group-ID");

         pvalue->u.sGSN_Group_ID = rtxMemAllocType (pctxt, 
            ranap_SGSN_Group_ID);

         if (pvalue->u.sGSN_Group_ID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_SGSN_Group_ID (pvalue->u.sGSN_Group_ID);

         stat = asn1PD_ranap_SGSN_Group_ID (pctxt, pvalue->u.sGSN_Group_ID);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SGSN_Group_Identity (ranap_SGSN_Group_Identity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_SGSN_Group_Identity (OSCTXT *pctxt, 
   ranap_SGSN_Group_Identity* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.null_NRI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.null_NRI);
            pvalue->u.null_NRI = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.sGSN_Group_ID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sGSN_Group_ID);
            pvalue->u.sGSN_Group_ID = 0;
         }
         break;

   }
}

EXTERN int asn1PE_ranap_SNA_Access_Information (OSCTXT* pctxt, ranap_SNA_Access_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SNA-Access-Information");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode authorisedPLMNs */

   RTXCTXTPUSHELEMNAME (pctxt, "authorisedPLMNs");

   stat = asn1PE_ranap_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SNA_Access_Information (OSCTXT* pctxt, ranap_SNA_Access_Information* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SNA-Access-Information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode authorisedPLMNs */
   RTXCTXTPUSHELEMNAME (pctxt, "authorisedPLMNs");

   stat = asn1PD_ranap_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SNA_Access_Information (
   ranap_SNA_Access_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_AuthorisedPLMNs (&pvalue->authorisedPLMNs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SNA_Access_Information (OSCTXT *pctxt, 
   ranap_SNA_Access_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_AuthorisedPLMNs (pctxt, &pvalue->authorisedPLMNs);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SourceRNC_ID (OSCTXT* pctxt, ranap_SourceRNC_ID* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceRNC-ID");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rNC_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PE_ranap_RNC_ID (pctxt, pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceRNC_ID (OSCTXT* pctxt, ranap_SourceRNC_ID* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceRNC-ID");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rNC_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rNC-ID");

   stat = asn1PD_ranap_RNC_ID (pctxt, &pvalue->rNC_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceRNC_ID (ranap_SourceRNC_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_SourceRNC_ID (OSCTXT *pctxt, ranap_SourceRNC_ID* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_SourceID (OSCTXT* pctxt, ranap_SourceID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* sourceRNC_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceRNC-ID");

            stat = asn1PE_ranap_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* sAI */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "sAI");

            stat = asn1PE_ranap_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceID (OSCTXT* pctxt, ranap_SourceID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* sourceRNC_ID */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "sourceRNC-ID");

            pvalue->u.sourceRNC_ID = rtxMemAllocType (pctxt, 
               ranap_SourceRNC_ID);

            if (pvalue->u.sourceRNC_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_SourceRNC_ID (pvalue->u.sourceRNC_ID);

            stat = asn1PD_ranap_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* sAI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "sAI");

            pvalue->u.sAI = rtxMemAllocType (pctxt, ranap_SAI);

            if (pvalue->u.sAI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_SAI (pvalue->u.sAI);

            stat = asn1PD_ranap_SAI (pctxt, pvalue->u.sAI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceID (ranap_SourceID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_SourceID (OSCTXT *pctxt, ranap_SourceID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sourceRNC_ID) {
            asn1Free_ranap_SourceRNC_ID (pctxt, pvalue->u.sourceRNC_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sourceRNC_ID);
            pvalue->u.sourceRNC_ID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.sAI) {
            asn1Free_ranap_SAI (pctxt, pvalue->u.sAI);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sAI);
            pvalue->u.sAI = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_SourceRNC_ToTargetRNC_TransparentContainer (OSCTXT* pctxt, ranap_SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SourceRNC-ToTargetRNC-TransparentContainer");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.chosenIntegrityProtectionAlgorithmPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.integrityProtectionKeyPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForSignallingPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.cipheringKeyPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForCSPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.chosenEncryptionAlgorithForPSPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.d_RNTIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.targetCellIdPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rAB_TrCH_MappingPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rRC_Container */

   RTXCTXTPUSHELEMNAME (pctxt, "rRC-Container");

   stat = asn1PE_ranap_RRC_Container (pctxt, pvalue->rRC_Container);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode numberOfIuInstances */

   RTXCTXTPUSHELEMNAME (pctxt, "numberOfIuInstances");

   stat = asn1PE_ranap_NumberOfIuInstances (pctxt, pvalue->numberOfIuInstances);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode relocationType */

   RTXCTXTPUSHELEMNAME (pctxt, "relocationType");

   stat = asn1PE_ranap_RelocationType (pctxt, pvalue->relocationType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode chosenIntegrityProtectionAlgorithm */

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenIntegrityProtectionAlgorithm");

      stat = asn1PE_ranap_ChosenIntegrityProtectionAlgorithm (pctxt, pvalue->chosenIntegrityProtectionAlgorithm);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode integrityProtectionKey */

   if (pvalue->m.integrityProtectionKeyPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionKey");

      stat = asn1PE_ranap_IntegrityProtectionKey (pctxt, &pvalue->integrityProtectionKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode chosenEncryptionAlgorithForSignalling */

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForSignalling");

      stat = asn1PE_ranap_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForSignalling);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode cipheringKey */

   if (pvalue->m.cipheringKeyPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cipheringKey");

      stat = asn1PE_ranap_EncryptionKey (pctxt, &pvalue->cipheringKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode chosenEncryptionAlgorithForCS */

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForCS");

      stat = asn1PE_ranap_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode chosenEncryptionAlgorithForPS */

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForPS");

      stat = asn1PE_ranap_ChosenEncryptionAlgorithm (pctxt, pvalue->chosenEncryptionAlgorithForPS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "d-RNTI");

      stat = asn1PE_ranap_D_RNTI (pctxt, pvalue->d_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode targetCellId */

   if (pvalue->m.targetCellIdPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "targetCellId");

      stat = asn1PE_ranap_TargetCellId (pctxt, pvalue->targetCellId);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rAB_TrCH_Mapping */

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-TrCH-Mapping");

      stat = asn1PE_ranap_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SourceRNC_ToTargetRNC_TransparentContainer (OSCTXT* pctxt, ranap_SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[10];

   RTXCTXTPUSHTYPENAME (pctxt, "SourceRNC-ToTargetRNC-TransparentContainer");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 10; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rRC_Container */
   RTXCTXTPUSHELEMNAME (pctxt, "rRC-Container");

   stat = asn1PD_ranap_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode numberOfIuInstances */
   RTXCTXTPUSHELEMNAME (pctxt, "numberOfIuInstances");

   stat = asn1PD_ranap_NumberOfIuInstances (pctxt, &pvalue->numberOfIuInstances);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode relocationType */
   RTXCTXTPUSHELEMNAME (pctxt, "relocationType");

   stat = asn1PD_ranap_RelocationType (pctxt, &pvalue->relocationType);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode chosenIntegrityProtectionAlgorithm */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenIntegrityProtectionAlgorithm");

      pvalue->m.chosenIntegrityProtectionAlgorithmPresent = 1;

      stat = asn1PD_ranap_ChosenIntegrityProtectionAlgorithm (pctxt, &pvalue->chosenIntegrityProtectionAlgorithm);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode integrityProtectionKey */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "integrityProtectionKey");

      pvalue->m.integrityProtectionKeyPresent = 1;

      stat = asn1PD_ranap_IntegrityProtectionKey (pctxt, &pvalue->integrityProtectionKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode chosenEncryptionAlgorithForSignalling */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForSignalling");

      pvalue->m.chosenEncryptionAlgorithForSignallingPresent = 1;

      stat = asn1PD_ranap_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForSignalling);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode cipheringKey */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "cipheringKey");

      pvalue->m.cipheringKeyPresent = 1;

      stat = asn1PD_ranap_EncryptionKey (pctxt, &pvalue->cipheringKey);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode chosenEncryptionAlgorithForCS */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForCS");

      pvalue->m.chosenEncryptionAlgorithForCSPresent = 1;

      stat = asn1PD_ranap_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForCS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode chosenEncryptionAlgorithForPS */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "chosenEncryptionAlgorithForPS");

      pvalue->m.chosenEncryptionAlgorithForPSPresent = 1;

      stat = asn1PD_ranap_ChosenEncryptionAlgorithm (pctxt, &pvalue->chosenEncryptionAlgorithForPS);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode d_RNTI */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "d-RNTI");

      pvalue->m.d_RNTIPresent = 1;

      stat = asn1PD_ranap_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode targetCellId */
   if (optbits[7]) {
      RTXCTXTPUSHELEMNAME (pctxt, "targetCellId");

      pvalue->m.targetCellIdPresent = 1;

      stat = asn1PD_ranap_TargetCellId (pctxt, &pvalue->targetCellId);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAB_TrCH_Mapping */
   if (optbits[8]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-TrCH-Mapping");

      pvalue->m.rAB_TrCH_MappingPresent = 1;

      stat = asn1PD_ranap_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[9]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SourceRNC_ToTargetRNC_TransparentContainer (
   ranap_SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RRC_Container (&pvalue->rRC_Container);
   asn1Init_ranap_IntegrityProtectionKey (&pvalue->integrityProtectionKey);
   asn1Init_ranap_EncryptionKey (&pvalue->cipheringKey);
   asn1Init_ranap_RAB_TrCH_Mapping (&pvalue->rAB_TrCH_Mapping);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SourceRNC_ToTargetRNC_TransparentContainer (OSCTXT *pctxt, 
   ranap_SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (pvalue->m.rAB_TrCH_MappingPresent) {
      asn1Free_ranap_RAB_TrCH_Mapping (pctxt, &pvalue->rAB_TrCH_Mapping);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_EUTRANFrequencies_element (OSCTXT* pctxt, ranap_EUTRANFrequencies_element* pvalue)
{
   int stat = 0;

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.measBandPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode earfcn */

   RTXCTXTPUSHELEMNAME (pctxt, "earfcn");

   stat = pe_ConsUnsigned (pctxt, pvalue->earfcn, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode measBand */

   if (pvalue->m.measBandPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "measBand");

      stat = asn1PE_ranap_MeasBand (pctxt, pvalue->measBand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

EXTERN int asn1PD_ranap_EUTRANFrequencies_element (OSCTXT* pctxt, ranap_EUTRANFrequencies_element* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode earfcn */
   RTXCTXTPUSHELEMNAME (pctxt, "earfcn");

   stat = pd_ConsUInt16 (pctxt, &pvalue->earfcn, 0, 65535);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode measBand */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "measBand");

      pvalue->m.measBandPresent = 1;

      stat = asn1PD_ranap_MeasBand (pctxt, &pvalue->measBand);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   return (stat);
}

int asn1Init_ranap_EUTRANFrequencies_element (
   ranap_EUTRANFrequencies_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_EUTRANFrequencies_element (OSCTXT *pctxt, 
   ranap_EUTRANFrequencies_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_EUTRANFrequencies (OSCTXT* pctxt, ranap_EUTRANFrequencies* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRANFrequencies");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_EUTRANFrequencies_element (pctxt, ((ranap_EUTRANFrequencies_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EUTRANFrequencies (OSCTXT* pctxt, ranap_EUTRANFrequencies* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EUTRANFrequencies");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_EUTRANFrequencies_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_EUTRANFrequencies_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_EUTRANFrequencies_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_EUTRANFrequencies_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EUTRANFrequencies (ranap_EUTRANFrequencies* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_EUTRANFrequencies (OSCTXT *pctxt, 
   ranap_EUTRANFrequencies* pvalue)
{
   if (0 == pvalue) return;
   { ranap_EUTRANFrequencies_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_EUTRANFrequencies_element*)pnode->data;
      asn1Free_ranap_EUTRANFrequencies_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_IRATmeasurementParameters (OSCTXT* pctxt, ranap_IRATmeasurementParameters* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRATmeasurementParameters");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.eUTRANFrequenciesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode measurementDuration */

   RTXCTXTPUSHELEMNAME (pctxt, "measurementDuration");

   if ( (pvalue->measurementDuration >= 1 && pvalue->measurementDuration <= 100) ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->measurementDuration, 1, 100);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->measurementDuration);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode eUTRANFrequencies */

   if (pvalue->m.eUTRANFrequenciesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "eUTRANFrequencies");

      stat = asn1PE_ranap_EUTRANFrequencies (pctxt, &pvalue->eUTRANFrequencies);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IRATmeasurementParameters (OSCTXT* pctxt, ranap_IRATmeasurementParameters* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "IRATmeasurementParameters");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode measurementDuration */
   RTXCTXTPUSHELEMNAME (pctxt, "measurementDuration");

   stat = pd_ConsUInt8 (pctxt, &pvalue->measurementDuration, 1, 100);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode eUTRANFrequencies */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "eUTRANFrequencies");

      pvalue->m.eUTRANFrequenciesPresent = 1;

      stat = asn1PD_ranap_EUTRANFrequencies (pctxt, &pvalue->eUTRANFrequencies);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IRATmeasurementParameters (
   ranap_IRATmeasurementParameters* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_EUTRANFrequencies (&pvalue->eUTRANFrequencies);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_IRATmeasurementParameters (OSCTXT *pctxt, 
   ranap_IRATmeasurementParameters* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eUTRANFrequenciesPresent) {
      asn1Free_ranap_EUTRANFrequencies (pctxt, &pvalue->eUTRANFrequencies);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_IRAT_Measurement_Configuration (OSCTXT* pctxt, ranap_IRAT_Measurement_Configuration* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-Measurement-Configuration");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rSRPPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rSRQPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rSRP */

   if (pvalue->m.rSRPPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rSRP");

      if ( pvalue->rSRP <= 97 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->rSRP, 0, 97);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->rSRP);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rSRQ */

   if (pvalue->m.rSRQPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rSRQ");

      if ( pvalue->rSRQ <= 34 ) {
         stat = pe_ConsUnsigned (pctxt, pvalue->rSRQ, 0, 34);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
      else {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->rSRQ);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iRATmeasurementParameters */

   RTXCTXTPUSHELEMNAME (pctxt, "iRATmeasurementParameters");

   stat = asn1PE_ranap_IRATmeasurementParameters (pctxt, &pvalue->iRATmeasurementParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IRAT_Measurement_Configuration (OSCTXT* pctxt, ranap_IRAT_Measurement_Configuration* pvalue)
{
   int stat = 0;
   OSUINT32 i_;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "IRAT-Measurement-Configuration");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rSRP */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rSRP");

      pvalue->m.rSRPPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->rSRP, 0, 97);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rSRQ */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rSRQ");

      pvalue->m.rSRQPresent = 1;

      stat = pd_ConsUInt8 (pctxt, &pvalue->rSRQ, 0, 34);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iRATmeasurementParameters */
   RTXCTXTPUSHELEMNAME (pctxt, "iRATmeasurementParameters");

   stat = asn1PD_ranap_IRATmeasurementParameters (pctxt, &pvalue->iRATmeasurementParameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IRAT_Measurement_Configuration (
   ranap_IRAT_Measurement_Configuration* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IRATmeasurementParameters (&pvalue->iRATmeasurementParameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   return 0;
}

void asn1Free_ranap_IRAT_Measurement_Configuration (OSCTXT *pctxt, 
   ranap_IRAT_Measurement_Configuration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_IRATmeasurementParameters (pctxt, &pvalue->iRATmeasurementParameters);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
}

EXTERN int asn1PE_ranap_RSRQ_Type (OSCTXT* pctxt, ranap_RSRQ_Type* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Type");

   /* encode allSymbols */

   RTXCTXTPUSHELEMNAME (pctxt, "allSymbols");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->allSymbols);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode wideBand */

   RTXCTXTPUSHELEMNAME (pctxt, "wideBand");

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->wideBand);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RSRQ_Type (OSCTXT* pctxt, ranap_RSRQ_Type* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RSRQ-Type");

   /* decode root elements */
   /* decode allSymbols */
   RTXCTXTPUSHELEMNAME (pctxt, "allSymbols");

   stat = DEC_BIT (pctxt, &pvalue->allSymbols);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode wideBand */
   RTXCTXTPUSHELEMNAME (pctxt, "wideBand");

   stat = DEC_BIT (pctxt, &pvalue->wideBand);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_SRB_TrCH_MappingItem (OSCTXT* pctxt, ranap_SRB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-TrCH-MappingItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode sRB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "sRB-ID");

   stat = asn1PE_ranap_SRB_ID (pctxt, pvalue->sRB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode trCH_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "trCH-ID");

   stat = asn1PE_ranap_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRB_TrCH_MappingItem (OSCTXT* pctxt, ranap_SRB_TrCH_MappingItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-TrCH-MappingItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode sRB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "sRB-ID");

   stat = asn1PD_ranap_SRB_ID (pctxt, &pvalue->sRB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trCH_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "trCH-ID");

   stat = asn1PD_ranap_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRB_TrCH_MappingItem (ranap_SRB_TrCH_MappingItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TrCH_ID (&pvalue->trCH_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRB_TrCH_MappingItem (OSCTXT *pctxt, 
   ranap_SRB_TrCH_MappingItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TrCH_ID (pctxt, &pvalue->trCH_ID);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRB_TrCH_Mapping (OSCTXT* pctxt, ranap_SRB_TrCH_Mapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-TrCH-Mapping");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-TrCH-MappingItem", xx1);

      stat = asn1PE_ranap_SRB_TrCH_MappingItem (pctxt, ((ranap_SRB_TrCH_MappingItem*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRB_TrCH_Mapping (OSCTXT* pctxt, ranap_SRB_TrCH_Mapping* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SRB-TrCH-Mapping");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(8), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_SRB_TrCH_MappingItem* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SRB-TrCH-MappingItem", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_SRB_TrCH_MappingItem, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_SRB_TrCH_MappingItem (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_SRB_TrCH_MappingItem (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRB_TrCH_Mapping (ranap_SRB_TrCH_Mapping* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_SRB_TrCH_Mapping (OSCTXT *pctxt, 
   ranap_SRB_TrCH_Mapping* pvalue)
{
   if (0 == pvalue) return;
   { ranap_SRB_TrCH_MappingItem* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_SRB_TrCH_MappingItem*)pnode->data;
      asn1Free_ranap_SRB_TrCH_MappingItem (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_SRVCC_Information (OSCTXT* pctxt, ranap_SRVCC_Information* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-Information");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nonce */

   RTXCTXTPUSHELEMNAME (pctxt, "nonce");

   stat = asn1PE_ranap_SRVCC_Information_nonce (pctxt, &pvalue->nonce);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_Information (OSCTXT* pctxt, ranap_SRVCC_Information* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-Information");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nonce */
   RTXCTXTPUSHELEMNAME (pctxt, "nonce");

   stat = asn1PD_ranap_SRVCC_Information_nonce (pctxt, &pvalue->nonce);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRVCC_Information (ranap_SRVCC_Information* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_SRVCC_Information_nonce (&pvalue->nonce);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRVCC_Information (OSCTXT *pctxt, 
   ranap_SRVCC_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TargetID (OSCTXT* pctxt, ranap_TargetID* pvalue)
{
   int stat = 0;
   OSUINT32 pos;
   void* pPerField;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* targetRNC_ID */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "targetRNC-ID");

            stat = asn1PE_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* cGI */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "cGI");

            stat = asn1PE_ranap_CGI (pctxt, pvalue->u.cGI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      stat = pe_OpenTypeStart (pctxt, &pos, &pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      switch (pvalue->t)
      {
         /* targeteNB_ID */
         case 3:
            stat = asn1PE_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);
            break;

         default:
            stat = rtxEncBitsFromByteArray (pctxt, pvalue->u.extElem1->data, pvalue->u.extElem1->numocts * 8);
      }

      stat = pe_OpenTypeEnd (pctxt, pos, pPerField);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetID (OSCTXT* pctxt, ranap_TargetID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;
   OSINT16 savedBitOffset = 0;
   OSBOOL fragmented = FALSE;
   OSCTXT lctxt;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* targetRNC_ID */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "targetRNC-ID");

            pvalue->u.targetRNC_ID = rtxMemAllocType (pctxt, 
               ranap_TargetRNC_ID);

            if (pvalue->u.targetRNC_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_TargetRNC_ID (pvalue->u.targetRNC_ID);

            stat = asn1PD_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* cGI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "cGI");

            pvalue->u.cGI = rtxMemAllocType (pctxt, ranap_CGI);

            if (pvalue->u.cGI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_CGI (pvalue->u.cGI);

            stat = asn1PD_ranap_CGI (pctxt, pvalue->u.cGI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      if (pd_isFragmented (pctxt)) {
         fragmented = TRUE;
         RTXCTXTPUSHELEMNAME (pctxt, "...");

         stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         rtxCopyContext (&lctxt, pctxt);
         rtxCtxtSetFlag (pctxt, OSDISSTRM);
         stat = rtxInitContextBuffer (pctxt,
            (OSOCTET*)openType.data, openType.numocts);
      }
      else if (pvalue->t < 4) {
         stat = pd_Length64 (pctxt, &openType.numocts);
         if (stat != 0 && stat != ASN_OK_FRAG) return LOG_RTERR (pctxt, stat);

         pd_OpenTypeStart (pctxt, &openType.numocts, &savedBitOffset);
      }
      else openType.numocts = 0;

      switch (pvalue->t) {
         /* targeteNB_ID */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "targeteNB-ID");

            pvalue->u.targeteNB_ID = rtxMemAllocType (pctxt, 
               ranap_TargetENB_ID);

            if (pvalue->u.targeteNB_ID == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_TargetENB_ID (pvalue->u.targeteNB_ID);

            stat = asn1PD_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            RTXCTXTPUSHELEMNAME (pctxt, "...");

            pvalue->u.extElem1 = rtxMemAllocTypeZ (pctxt, ASN1OpenType);
            if (pvalue->u.extElem1 == NULL) return LOG_RTERR (pctxt, RTERR_NOMEM);
            if (fragmented) {
               openType.data = 0; /* protect from release */
            }
            else {
               stat = pd_OpenType (pctxt, &pvalue->u.extElem1->data, &pvalue->u.extElem1->numocts);
               if (stat != 0) return LOG_RTERR (pctxt, stat);
            }

            RTXCTXTPOPELEMNAME (pctxt);

      }

      if (fragmented) {
         rtxCopyContext (pctxt, &lctxt);
         rtxMemFreePtr (pctxt, openType.data);
      }
      else if (pvalue->t < 4) {
         stat = pd_OpenTypeEnd (pctxt, openType.numocts, savedBitOffset);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargetID (ranap_TargetID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_TargetID (OSCTXT *pctxt, ranap_TargetID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.targetRNC_ID) {
            asn1Free_ranap_TargetRNC_ID (pctxt, pvalue->u.targetRNC_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targetRNC_ID);
            pvalue->u.targetRNC_ID = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.cGI) {
            asn1Free_ranap_CGI (pctxt, pvalue->u.cGI);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cGI);
            pvalue->u.cGI = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.targeteNB_ID) {
            asn1Free_ranap_TargetENB_ID (pctxt, pvalue->u.targeteNB_ID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targeteNB_ID);
            pvalue->u.targeteNB_ID = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_TargetRNC_ToSourceRNC_TransparentContainer (OSCTXT* pctxt, ranap_TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetRNC-ToSourceRNC-TransparentContainer");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.d_RNTIPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rRC_Container */

   RTXCTXTPUSHELEMNAME (pctxt, "rRC-Container");

   stat = asn1PE_ranap_RRC_Container (pctxt, pvalue->rRC_Container);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode d_RNTI */

   if (pvalue->m.d_RNTIPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "d-RNTI");

      stat = asn1PE_ranap_D_RNTI (pctxt, pvalue->d_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TargetRNC_ToSourceRNC_TransparentContainer (OSCTXT* pctxt, ranap_TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "TargetRNC-ToSourceRNC-TransparentContainer");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rRC_Container */
   RTXCTXTPUSHELEMNAME (pctxt, "rRC-Container");

   stat = asn1PD_ranap_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode d_RNTI */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "d-RNTI");

      pvalue->m.d_RNTIPresent = 1;

      stat = asn1PD_ranap_D_RNTI (pctxt, &pvalue->d_RNTI);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TargetRNC_ToSourceRNC_TransparentContainer (
   ranap_TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RRC_Container (&pvalue->rRC_Container);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TargetRNC_ToSourceRNC_TransparentContainer (OSCTXT *pctxt, 
   ranap_TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RRC_Container (pctxt, &pvalue->rRC_Container);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TemporaryUE_ID (OSCTXT* pctxt, ranap_TemporaryUE_ID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TemporaryUE-ID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 2);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* tMSI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "tMSI");

            stat = asn1PE_ranap_TMSI (pctxt, pvalue->u.tMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* p_TMSI */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "p-TMSI");

            stat = asn1PE_ranap_P_TMSI (pctxt, pvalue->u.p_TMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TemporaryUE_ID (OSCTXT* pctxt, ranap_TemporaryUE_ID* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "TemporaryUE-ID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* tMSI */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "tMSI");

            pvalue->u.tMSI = rtxMemAllocType (pctxt, ranap_TMSI);

            if (pvalue->u.tMSI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_TMSI (pvalue->u.tMSI);

            stat = asn1PD_ranap_TMSI (pctxt, pvalue->u.tMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* p_TMSI */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "p-TMSI");

            pvalue->u.p_TMSI = rtxMemAllocType (pctxt, ranap_P_TMSI);

            if (pvalue->u.p_TMSI == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_P_TMSI (pvalue->u.p_TMSI);

            stat = asn1PD_ranap_P_TMSI (pctxt, pvalue->u.p_TMSI);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 3;

      if (pvalue->t < 3) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TemporaryUE_ID (ranap_TemporaryUE_ID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_TemporaryUE_ID (OSCTXT *pctxt, 
   ranap_TemporaryUE_ID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tMSI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tMSI);
            pvalue->u.tMSI = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.p_TMSI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.p_TMSI);
            pvalue->u.p_TMSI = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

EXTERN int asn1PE_ranap_TraceRecordingSessionInformation (OSCTXT* pctxt, ranap_TraceRecordingSessionInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TraceRecordingSessionInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode traceReference */

   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PE_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode traceRecordingSessionReference */

   RTXCTXTPUSHELEMNAME (pctxt, "traceRecordingSessionReference");

   stat = asn1PE_ranap_TraceRecordingSessionReference (pctxt, pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TraceRecordingSessionInformation (OSCTXT* pctxt, ranap_TraceRecordingSessionInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TraceRecordingSessionInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode traceReference */
   RTXCTXTPUSHELEMNAME (pctxt, "traceReference");

   stat = asn1PD_ranap_TraceReference (pctxt, &pvalue->traceReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode traceRecordingSessionReference */
   RTXCTXTPUSHELEMNAME (pctxt, "traceRecordingSessionReference");

   stat = asn1PD_ranap_TraceRecordingSessionReference (pctxt, &pvalue->traceRecordingSessionReference);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TraceRecordingSessionInformation (
   ranap_TraceRecordingSessionInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TraceReference (&pvalue->traceReference);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TraceRecordingSessionInformation (OSCTXT *pctxt, 
   ranap_TraceRecordingSessionInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TunnelInformation (OSCTXT* pctxt, ranap_TunnelInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TunnelInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uDP_Port_NumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode transportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uDP_Port_Number */

   if (pvalue->m.uDP_Port_NumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uDP-Port-Number");

      stat = asn1PE_ranap_Port_Number (pctxt, &pvalue->uDP_Port_Number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TunnelInformation (OSCTXT* pctxt, ranap_TunnelInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "TunnelInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uDP_Port_Number */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uDP-Port-Number");

      pvalue->m.uDP_Port_NumberPresent = 1;

      stat = asn1PD_ranap_Port_Number (pctxt, &pvalue->uDP_Port_Number);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TunnelInformation (ranap_TunnelInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_Port_Number (&pvalue->uDP_Port_Number);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TunnelInformation (OSCTXT *pctxt, 
   ranap_TunnelInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UE_AggregateMaximumBitRate (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRate");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uE_AggregateMaximumBitRateDownlinkPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uE_AggregateMaximumBitRateUplinkPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uE_AggregateMaximumBitRateDownlink */

   if (pvalue->m.uE_AggregateMaximumBitRateDownlinkPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-AggregateMaximumBitRateDownlink");

      stat = asn1PE_ranap_UE_AggregateMaximumBitRateDownlink (pctxt, pvalue->uE_AggregateMaximumBitRateDownlink);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uE_AggregateMaximumBitRateUplink */

   if (pvalue->m.uE_AggregateMaximumBitRateUplinkPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-AggregateMaximumBitRateUplink");

      stat = asn1PE_ranap_UE_AggregateMaximumBitRateUplink (pctxt, pvalue->uE_AggregateMaximumBitRateUplink);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_AggregateMaximumBitRate (OSCTXT* pctxt, ranap_UE_AggregateMaximumBitRate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-AggregateMaximumBitRate");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode uE_AggregateMaximumBitRateDownlink */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-AggregateMaximumBitRateDownlink");

      pvalue->m.uE_AggregateMaximumBitRateDownlinkPresent = 1;

      stat = asn1PD_ranap_UE_AggregateMaximumBitRateDownlink (pctxt, &pvalue->uE_AggregateMaximumBitRateDownlink);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uE_AggregateMaximumBitRateUplink */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uE-AggregateMaximumBitRateUplink");

      pvalue->m.uE_AggregateMaximumBitRateUplinkPresent = 1;

      stat = asn1PD_ranap_UE_AggregateMaximumBitRateUplink (pctxt, &pvalue->uE_AggregateMaximumBitRateUplink);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UE_AggregateMaximumBitRate (
   ranap_UE_AggregateMaximumBitRate* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UE_AggregateMaximumBitRate (OSCTXT *pctxt, 
   ranap_UE_AggregateMaximumBitRate* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UE_IsNotServed (OSCTXT* pctxt, ranap_UE_IsNotServed* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-IsNotServed");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode permanentNAS_UE_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

   stat = asn1PE_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_IsNotServed (OSCTXT* pctxt, ranap_UE_IsNotServed* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-IsNotServed");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode permanentNAS_UE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

   stat = asn1PD_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UE_IsNotServed (ranap_UE_IsNotServed* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PermanentNAS_UE_ID (&pvalue->permanentNAS_UE_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UE_IsNotServed (OSCTXT *pctxt, 
   ranap_UE_IsNotServed* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UE_IsServed (OSCTXT* pctxt, ranap_UE_IsServed* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UE-IsServed");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode permanentNAS_UE_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

   stat = asn1PE_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode pLMNidentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PE_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UE_IsServed (OSCTXT* pctxt, ranap_UE_IsServed* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UE-IsServed");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode permanentNAS_UE_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "permanentNAS-UE-ID");

   stat = asn1PD_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pLMNidentity */
   RTXCTXTPUSHELEMNAME (pctxt, "pLMNidentity");

   stat = asn1PD_ranap_PLMNidentity (pctxt, &pvalue->pLMNidentity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UE_IsServed (ranap_UE_IsServed* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PermanentNAS_UE_ID (&pvalue->permanentNAS_UE_ID);
   asn1Init_ranap_PLMNidentity (&pvalue->pLMNidentity);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UE_IsServed (OSCTXT *pctxt, ranap_UE_IsServed* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_PermanentNAS_UE_ID (pctxt, &pvalue->permanentNAS_UE_ID);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UERegistrationQueryResult (OSCTXT* pctxt, ranap_UERegistrationQueryResult* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UERegistrationQueryResult");

   /* Encode choice index value */

   RTXCTXTPUSHELEMNAME (pctxt, "t");

   stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 1);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* Encode root element data value */

   switch (pvalue->t)
   {
      /* uE_IsServed */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "uE-IsServed");

         stat = asn1PE_ranap_UE_IsServed (pctxt, pvalue->u.uE_IsServed);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* uE_IsNotServed */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "uE-IsNotServed");

         stat = asn1PE_ranap_UE_IsNotServed (pctxt, pvalue->u.uE_IsNotServed);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UERegistrationQueryResult (OSCTXT* pctxt, ranap_UERegistrationQueryResult* pvalue)
{
   int stat = 0;
   OSUINT32 ui;

   RTXCTXTPUSHTYPENAME (pctxt, "UERegistrationQueryResult");

   stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(1));
   if (stat != 0) return LOG_RTERR (pctxt, stat);
   else pvalue->t = ui + 1;

   switch (ui) {
      /* uE_IsServed */
      case 0:
         RTXCTXTPUSHELEMNAME (pctxt, "uE-IsServed");

         pvalue->u.uE_IsServed = rtxMemAllocType (pctxt, ranap_UE_IsServed);

         if (pvalue->u.uE_IsServed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_UE_IsServed (pvalue->u.uE_IsServed);

         stat = asn1PD_ranap_UE_IsServed (pctxt, pvalue->u.uE_IsServed);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      /* uE_IsNotServed */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "uE-IsNotServed");

         pvalue->u.uE_IsNotServed = rtxMemAllocType (pctxt, 
            ranap_UE_IsNotServed);

         if (pvalue->u.uE_IsNotServed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ranap_UE_IsNotServed (pvalue->u.uE_IsNotServed);

         stat = asn1PD_ranap_UE_IsNotServed (pctxt, pvalue->u.uE_IsNotServed);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UERegistrationQueryResult (
   ranap_UERegistrationQueryResult* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_UERegistrationQueryResult (OSCTXT *pctxt, 
   ranap_UERegistrationQueryResult* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.uE_IsServed) {
            asn1Free_ranap_UE_IsServed (pctxt, pvalue->u.uE_IsServed);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.uE_IsServed);
            pvalue->u.uE_IsServed = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.uE_IsNotServed) {
            asn1Free_ranap_UE_IsNotServed (pctxt, pvalue->u.uE_IsNotServed);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.uE_IsNotServed);
            pvalue->u.uE_IsNotServed = 0;
         }
         break;

   }
}

EXTERN int asn1PE_ranap_UESBI_Iu (OSCTXT* pctxt, ranap_UESBI_Iu* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-Iu");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uESBI_IuAPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uESBI_IuBPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode uESBI_IuA */

   if (pvalue->m.uESBI_IuAPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uESBI-IuA");

      stat = asn1PE_ranap_UESBI_IuA (pctxt, &pvalue->uESBI_IuA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uESBI_IuB */

   if (pvalue->m.uESBI_IuBPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uESBI-IuB");

      stat = asn1PE_ranap_UESBI_IuB (pctxt, &pvalue->uESBI_IuB);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UESBI_Iu (OSCTXT* pctxt, ranap_UESBI_Iu* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "UESBI-Iu");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode uESBI_IuA */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uESBI-IuA");

      pvalue->m.uESBI_IuAPresent = 1;

      stat = asn1PD_ranap_UESBI_IuA (pctxt, &pvalue->uESBI_IuA);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uESBI_IuB */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uESBI-IuB");

      pvalue->m.uESBI_IuBPresent = 1;

      stat = asn1PD_ranap_UESBI_IuB (pctxt, &pvalue->uESBI_IuB);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UESBI_Iu (ranap_UESBI_Iu* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_UESBI_IuA (&pvalue->uESBI_IuA);
   asn1Init_ranap_UESBI_IuB (&pvalue->uESBI_IuB);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UESBI_Iu (OSCTXT *pctxt, ranap_UESBI_Iu* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_HorizontalSpeedAndBearing (OSCTXT* pctxt, ranap_HorizontalSpeedAndBearing* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalSpeedAndBearing");

   /* encode bearing */

   RTXCTXTPUSHELEMNAME (pctxt, "bearing");

   if ( pvalue->bearing <= 359 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->bearing, 0, 359);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->bearing);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode horizontalSpeed */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeed");

   if ( pvalue->horizontalSpeed <= 2047 ) {
      stat = pe_ConsUnsigned (pctxt, pvalue->horizontalSpeed, 0, 2047);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }
   else {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, pvalue->horizontalSpeed);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HorizontalSpeedAndBearing (OSCTXT* pctxt, ranap_HorizontalSpeedAndBearing* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalSpeedAndBearing");

   /* decode root elements */
   /* decode bearing */
   RTXCTXTPUSHELEMNAME (pctxt, "bearing");

   stat = pd_ConsUInt16 (pctxt, &pvalue->bearing, 0, 359);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode horizontalSpeed */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeed");

   stat = pd_ConsUInt16 (pctxt, &pvalue->horizontalSpeed, 0, 2047);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_HorizontalVelocity (OSCTXT* pctxt, ranap_HorizontalVelocity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalVelocity");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode horizontalSpeedAndBearing */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PE_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HorizontalVelocity (OSCTXT* pctxt, ranap_HorizontalVelocity* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalVelocity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode horizontalSpeedAndBearing */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PD_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_HorizontalVelocity (ranap_HorizontalVelocity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_HorizontalVelocity (OSCTXT *pctxt, 
   ranap_HorizontalVelocity* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_VerticalVelocity (OSCTXT* pctxt, ranap_VerticalVelocity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalVelocity");

   /* encode veritcalSpeed */

   RTXCTXTPUSHELEMNAME (pctxt, "veritcalSpeed");

   stat = pe_ConsUnsigned (pctxt, pvalue->veritcalSpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode veritcalSpeedDirection */

   RTXCTXTPUSHELEMNAME (pctxt, "veritcalSpeedDirection");

   stat = asn1PE_ranap_VerticalSpeedDirection (pctxt, pvalue->veritcalSpeedDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_VerticalVelocity (OSCTXT* pctxt, ranap_VerticalVelocity* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "VerticalVelocity");

   /* decode root elements */
   /* decode veritcalSpeed */
   RTXCTXTPUSHELEMNAME (pctxt, "veritcalSpeed");

   stat = pd_ConsUInt8 (pctxt, &pvalue->veritcalSpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode veritcalSpeedDirection */
   RTXCTXTPUSHELEMNAME (pctxt, "veritcalSpeedDirection");

   stat = asn1PD_ranap_VerticalSpeedDirection (pctxt, &pvalue->veritcalSpeedDirection);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PE_ranap_HorizontalWithVerticalVelocity (OSCTXT* pctxt, ranap_HorizontalWithVerticalVelocity* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalWithVerticalVelocity");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode horizontalSpeedAndBearing */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PE_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode veritcalVelocity */

   RTXCTXTPUSHELEMNAME (pctxt, "veritcalVelocity");

   stat = asn1PE_ranap_VerticalVelocity (pctxt, &pvalue->veritcalVelocity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HorizontalWithVerticalVelocity (OSCTXT* pctxt, ranap_HorizontalWithVerticalVelocity* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalWithVerticalVelocity");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode horizontalSpeedAndBearing */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PD_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode veritcalVelocity */
   RTXCTXTPUSHELEMNAME (pctxt, "veritcalVelocity");

   stat = asn1PD_ranap_VerticalVelocity (pctxt, &pvalue->veritcalVelocity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_HorizontalWithVerticalVelocity (
   ranap_HorizontalWithVerticalVelocity* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_HorizontalWithVerticalVelocity (OSCTXT *pctxt, 
   ranap_HorizontalWithVerticalVelocity* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_HorizontalVelocityWithUncertainty (OSCTXT* pctxt, ranap_HorizontalVelocityWithUncertainty* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalVelocityWithUncertainty");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode horizontalSpeedAndBearing */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PE_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uncertaintySpeed */

   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySpeed");

   stat = pe_ConsUnsigned (pctxt, pvalue->uncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HorizontalVelocityWithUncertainty (OSCTXT* pctxt, ranap_HorizontalVelocityWithUncertainty* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalVelocityWithUncertainty");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode horizontalSpeedAndBearing */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PD_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uncertaintySpeed */
   RTXCTXTPUSHELEMNAME (pctxt, "uncertaintySpeed");

   stat = pd_ConsUInt8 (pctxt, &pvalue->uncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_HorizontalVelocityWithUncertainty (
   ranap_HorizontalVelocityWithUncertainty* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_HorizontalVelocityWithUncertainty (OSCTXT *pctxt, 
   ranap_HorizontalVelocityWithUncertainty* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_HorizontalWithVerticalVelocityAndUncertainty (OSCTXT* pctxt, ranap_HorizontalWithVerticalVelocityAndUncertainty* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalWithVerticalVelocityAndUncertainty");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode horizontalSpeedAndBearing */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PE_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode veritcalVelocity */

   RTXCTXTPUSHELEMNAME (pctxt, "veritcalVelocity");

   stat = asn1PE_ranap_VerticalVelocity (pctxt, &pvalue->veritcalVelocity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode horizontalUncertaintySpeed */

   RTXCTXTPUSHELEMNAME (pctxt, "horizontalUncertaintySpeed");

   stat = pe_ConsUnsigned (pctxt, pvalue->horizontalUncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode verticalUncertaintySpeed */

   RTXCTXTPUSHELEMNAME (pctxt, "verticalUncertaintySpeed");

   stat = pe_ConsUnsigned (pctxt, pvalue->verticalUncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_HorizontalWithVerticalVelocityAndUncertainty (OSCTXT* pctxt, ranap_HorizontalWithVerticalVelocityAndUncertainty* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "HorizontalWithVerticalVelocityAndUncertainty");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode horizontalSpeedAndBearing */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalSpeedAndBearing");

   stat = asn1PD_ranap_HorizontalSpeedAndBearing (pctxt, &pvalue->horizontalSpeedAndBearing);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode veritcalVelocity */
   RTXCTXTPUSHELEMNAME (pctxt, "veritcalVelocity");

   stat = asn1PD_ranap_VerticalVelocity (pctxt, &pvalue->veritcalVelocity);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode horizontalUncertaintySpeed */
   RTXCTXTPUSHELEMNAME (pctxt, "horizontalUncertaintySpeed");

   stat = pd_ConsUInt8 (pctxt, &pvalue->horizontalUncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode verticalUncertaintySpeed */
   RTXCTXTPUSHELEMNAME (pctxt, "verticalUncertaintySpeed");

   stat = pd_ConsUInt8 (pctxt, &pvalue->verticalUncertaintySpeed, 0, 255);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_HorizontalWithVerticalVelocityAndUncertainty (
   ranap_HorizontalWithVerticalVelocityAndUncertainty* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_HorizontalWithVerticalVelocityAndUncertainty (OSCTXT *pctxt, 
   ranap_HorizontalWithVerticalVelocityAndUncertainty* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_VelocityEstimate (OSCTXT* pctxt, ranap_VelocityEstimate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "VelocityEstimate");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* horizontalVelocity */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalVelocity");

            stat = asn1PE_ranap_HorizontalVelocity (pctxt, pvalue->u.horizontalVelocity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* horizontalWithVerticalVelocity */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalWithVerticalVelocity");

            stat = asn1PE_ranap_HorizontalWithVerticalVelocity (pctxt, pvalue->u.horizontalWithVerticalVelocity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* horizontalVelocityWithUncertainty */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalVelocityWithUncertainty");

            stat = asn1PE_ranap_HorizontalVelocityWithUncertainty (pctxt, pvalue->u.horizontalVelocityWithUncertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* horizontalWithVeritcalVelocityAndUncertainty */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalWithVeritcalVelocityAndUncertainty");

            stat = asn1PE_ranap_HorizontalWithVerticalVelocityAndUncertainty (pctxt, pvalue->u.horizontalWithVeritcalVelocityAndUncertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_VelocityEstimate (OSCTXT* pctxt, ranap_VelocityEstimate* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "VelocityEstimate");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* horizontalVelocity */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalVelocity");

            pvalue->u.horizontalVelocity = rtxMemAllocType (pctxt, 
               ranap_HorizontalVelocity);

            if (pvalue->u.horizontalVelocity == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_HorizontalVelocity (pvalue->u.horizontalVelocity);

            stat = asn1PD_ranap_HorizontalVelocity (pctxt, pvalue->u.horizontalVelocity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* horizontalWithVerticalVelocity */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalWithVerticalVelocity");

            pvalue->u.horizontalWithVerticalVelocity = rtxMemAllocType (pctxt, 
               ranap_HorizontalWithVerticalVelocity);

            if (pvalue->u.horizontalWithVerticalVelocity == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_HorizontalWithVerticalVelocity (pvalue->u.horizontalWithVerticalVelocity);

            stat = asn1PD_ranap_HorizontalWithVerticalVelocity (pctxt, pvalue->u.horizontalWithVerticalVelocity);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* horizontalVelocityWithUncertainty */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalVelocityWithUncertainty");

            pvalue->u.horizontalVelocityWithUncertainty
                = rtxMemAllocType (pctxt, 
               ranap_HorizontalVelocityWithUncertainty);

            if (pvalue->u.horizontalVelocityWithUncertainty == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_HorizontalVelocityWithUncertainty (pvalue->u.horizontalVelocityWithUncertainty);

            stat = asn1PD_ranap_HorizontalVelocityWithUncertainty (pctxt, pvalue->u.horizontalVelocityWithUncertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* horizontalWithVeritcalVelocityAndUncertainty */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "horizontalWithVeritcalVelocityAndUncertainty");

            pvalue->u.horizontalWithVeritcalVelocityAndUncertainty
                = rtxMemAllocType (pctxt, 
               ranap_HorizontalWithVerticalVelocityAndUncertainty);

            if (pvalue->u.horizontalWithVeritcalVelocityAndUncertainty == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_HorizontalWithVerticalVelocityAndUncertainty (pvalue->u.horizontalWithVeritcalVelocityAndUncertainty);

            stat = asn1PD_ranap_HorizontalWithVerticalVelocityAndUncertainty (pctxt, pvalue->u.horizontalWithVeritcalVelocityAndUncertainty);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_VelocityEstimate (ranap_VelocityEstimate* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_VelocityEstimate (OSCTXT *pctxt, 
   ranap_VelocityEstimate* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.horizontalVelocity) {
            asn1Free_ranap_HorizontalVelocity (pctxt, pvalue->u.horizontalVelocity);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.horizontalVelocity);
            pvalue->u.horizontalVelocity = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.horizontalWithVerticalVelocity) {
            asn1Free_ranap_HorizontalWithVerticalVelocity (pctxt, pvalue->u.horizontalWithVerticalVelocity);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.horizontalWithVerticalVelocity);
            pvalue->u.horizontalWithVerticalVelocity = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.horizontalVelocityWithUncertainty) {
            asn1Free_ranap_HorizontalVelocityWithUncertainty (pctxt, pvalue->u.horizontalVelocityWithUncertainty);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.horizontalVelocityWithUncertainty);
            pvalue->u.horizontalVelocityWithUncertainty = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.horizontalWithVeritcalVelocityAndUncertainty) {
            asn1Free_ranap_HorizontalWithVerticalVelocityAndUncertainty (pctxt, pvalue->u.horizontalWithVeritcalVelocityAndUncertainty);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.horizontalWithVeritcalVelocityAndUncertainty);
            pvalue->u.horizontalWithVeritcalVelocityAndUncertainty = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

void asn1Print_ranap_RAB_ID (const char* name, const ranap_RAB_ID* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_UnsuccessfullyTransmittedDataVolume 
   (const char* name, const ranap_UnsuccessfullyTransmittedDataVolume* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_DataVolumeReference 
   (const char* name, const ranap_DataVolumeReference* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_DL_GTP_PDU_SequenceNumber 
   (const char* name, const ranap_DL_GTP_PDU_SequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_UL_GTP_PDU_SequenceNumber 
   (const char* name, const ranap_UL_GTP_PDU_SequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_TransportLayerAddress 
   (const char* name, const ranap_TransportLayerAddress* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_GTP_TEI (const char* name, const ranap_GTP_TEI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_BindingID 
   (const char* name, const ranap_BindingID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_IuTransportAssociation 
   (const char* name, const ranap_IuTransportAssociation* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* gTP-TEI */
      case 1:
      {
         asn1Print_ranap_GTP_TEI ("gTP-TEI", pvalue->u.gTP_TEI);
         break;
      }
      /* bindingID */
      case 2:
      {
         asn1Print_ranap_BindingID ("bindingID", pvalue->u.bindingID);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_NAS_SynchronisationIndicator 
   (const char* name, const ranap_NAS_SynchronisationIndicator* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_TrafficClass 
   (const char* name, const ranap_TrafficClass* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("conversational\n"); break;
      case 1: printf ("streaming\n"); break;
      case 2: printf ("interactive\n"); break;
      case 3: printf ("background\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RAB_AsymmetryIndicator 
   (const char* name, const ranap_RAB_AsymmetryIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("symmetric-bidirectional\n"); break;
      case 1: printf ("asymmetric-unidirectional-downlink\n"); break;
      case 2: printf ("asymmetric-unidirectional-uplink\n"); break;
      case 3: printf ("asymmetric-bidirectional\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MaxBitrate 
   (const char* name, const ranap_MaxBitrate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RAB_Parameter_MaxBitrateList 
   (const char* name, const ranap_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_GuaranteedBitrate 
   (const char* name, const ranap_GuaranteedBitrate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RAB_Parameter_GuaranteedBitrateList 
   (const char* name, const ranap_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_DeliveryOrder 
   (const char* name, const ranap_DeliveryOrder* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("delivery-order-requested\n"); break;
      case 1: printf ("delivery-order-not-requested\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_MaxSDU_Size 
   (const char* name, const ranap_MaxSDU_Size* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_SDU_ErrorRatio 
   (const char* name, const ranap_SDU_ErrorRatio* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("mantissa", pvalue->mantissa);

   rtxPrintIndent ();
   rtxPrintUnsigned ("exponent", pvalue->exponent);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResidualBitErrorRatio 
   (const char* name, const ranap_ResidualBitErrorRatio* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("mantissa", pvalue->mantissa);

   rtxPrintIndent ();
   rtxPrintUnsigned ("exponent", pvalue->exponent);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DeliveryOfErroneousSDU 
   (const char* name, const ranap_DeliveryOfErroneousSDU* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("yes\n"); break;
      case 1: printf ("no\n"); break;
      case 2: printf ("no-error-detection-consideration\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_SubflowSDU_Size 
   (const char* name, const ranap_SubflowSDU_Size* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RAB_SubflowCombinationBitRate 
   (const char* name, const ranap_RAB_SubflowCombinationBitRate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_SDU_FormatInformationParameters_element 
   (const char* name, const ranap_SDU_FormatInformationParameters_element* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.subflowSDU_SizePresent) {
      asn1Print_ranap_SubflowSDU_Size ("subflowSDU_Size", &pvalue->
         subflowSDU_Size);
   }

   if (pvalue->m.rAB_SubflowCombinationBitRatePresent) {
      asn1Print_ranap_RAB_SubflowCombinationBitRate (
         "rAB_SubflowCombinationBitRate", &pvalue->
         rAB_SubflowCombinationBitRate);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SDU_FormatInformationParameters 
   (const char* name, const ranap_SDU_FormatInformationParameters* pvalue)
{
   ranap_SDU_FormatInformationParameters_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SDU_FormatInformationParameters_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SDU_FormatInformationParameters_element (namebuf, pdata0
         );
      xx1++;
   }
}

void asn1Print_ranap_SDU_Parameters_element 
   (const char* name, const ranap_SDU_Parameters_element* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.sDU_ErrorRatioPresent) {
      asn1Print_ranap_SDU_ErrorRatio ("sDU_ErrorRatio", &pvalue->sDU_ErrorRatio
         );
   }

   asn1Print_ranap_ResidualBitErrorRatio ("residualBitErrorRatio", &pvalue->
      residualBitErrorRatio);

   asn1Print_ranap_DeliveryOfErroneousSDU ("deliveryOfErroneousSDU", &pvalue->
      deliveryOfErroneousSDU);

   if (pvalue->m.sDU_FormatInformationParametersPresent) {
      asn1Print_ranap_SDU_FormatInformationParameters (
         "sDU_FormatInformationParameters", &pvalue->
         sDU_FormatInformationParameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SDU_Parameters 
   (const char* name, const ranap_SDU_Parameters* pvalue)
{
   ranap_SDU_Parameters_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SDU_Parameters_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SDU_Parameters_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_TransferDelay 
   (const char* name, const ranap_TransferDelay* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_TrafficHandlingPriority 
   (const char* name, const ranap_TrafficHandlingPriority* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = ranap_spare_1\n", name); break;
      case 1: printf ("%s = ranap_highest_1\n", name); break;
      case 14: printf ("%s = ranap_lowest_1\n", name); break;
      case 15: printf ("%s = ranap_no_priority_used\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_PriorityLevel 
   (const char* name, const ranap_PriorityLevel* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = ranap_spare\n", name); break;
      case 1: printf ("%s = ranap_highest\n", name); break;
      case 14: printf ("%s = ranap_lowest\n", name); break;
      case 15: printf ("%s = ranap_no_priority\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_Pre_emptionCapability 
   (const char* name, const ranap_Pre_emptionCapability* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("shall-not-trigger-pre-emption\n"); break;
      case 1: printf ("may-trigger-pre-emption\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_Pre_emptionVulnerability 
   (const char* name, const ranap_Pre_emptionVulnerability* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not-pre-emptable\n"); break;
      case 1: printf ("pre-emptable\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_QueuingAllowed 
   (const char* name, const ranap_QueuingAllowed* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("queueing-not-allowed\n"); break;
      case 1: printf ("queueing-allowed\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_AllocationOrRetentionPriority 
   (const char* name, const ranap_AllocationOrRetentionPriority* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PriorityLevel ("priorityLevel", &pvalue->priorityLevel);

   asn1Print_ranap_Pre_emptionCapability ("pre_emptionCapability", &pvalue->
      pre_emptionCapability);

   asn1Print_ranap_Pre_emptionVulnerability ("pre_emptionVulnerability", &
      pvalue->pre_emptionVulnerability);

   asn1Print_ranap_QueuingAllowed ("queuingAllowed", &pvalue->queuingAllowed);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceStatisticsDescriptor 
   (const char* name, const ranap_SourceStatisticsDescriptor* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("speech\n"); break;
      case 1: printf ("unknown\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RelocationRequirement 
   (const char* name, const ranap_RelocationRequirement* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("lossless\n"); break;
      case 1: printf ("none\n"); break;
      case 2: printf ("realtime\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RAB_Parameters 
   (const char* name, const ranap_RAB_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TrafficClass ("trafficClass", &pvalue->trafficClass);

   asn1Print_ranap_RAB_AsymmetryIndicator ("rAB_AsymmetryIndicator", &pvalue->
      rAB_AsymmetryIndicator);

   asn1Print_ranap_RAB_Parameter_MaxBitrateList ("maxBitrate", &pvalue->
      maxBitrate);

   if (pvalue->m.guaranteedBitRatePresent) {
      asn1Print_ranap_RAB_Parameter_GuaranteedBitrateList (
         "guaranteedBitRate", &pvalue->guaranteedBitRate);
   }

   asn1Print_ranap_DeliveryOrder ("deliveryOrder", &pvalue->deliveryOrder);

   asn1Print_ranap_MaxSDU_Size ("maxSDU_Size", &pvalue->maxSDU_Size);

   asn1Print_ranap_SDU_Parameters ("sDU_Parameters", &pvalue->sDU_Parameters);

   if (pvalue->m.transferDelayPresent) {
      asn1Print_ranap_TransferDelay ("transferDelay", &pvalue->transferDelay);
   }

   if (pvalue->m.trafficHandlingPriorityPresent) {
      asn1Print_ranap_TrafficHandlingPriority ("trafficHandlingPriority", &
         pvalue->trafficHandlingPriority);
   }

   if (pvalue->m.allocationOrRetentionPriorityPresent) {
      asn1Print_ranap_AllocationOrRetentionPriority (
         "allocationOrRetentionPriority", &pvalue->
         allocationOrRetentionPriority);
   }

   if (pvalue->m.sourceStatisticsDescriptorPresent) {
      asn1Print_ranap_SourceStatisticsDescriptor (
         "sourceStatisticsDescriptor", &pvalue->sourceStatisticsDescriptor);
   }

   if (pvalue->m.relocationRequirementPresent) {
      asn1Print_ranap_RelocationRequirement ("relocationRequirement", &pvalue->
         relocationRequirement);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DataVolumeReportingIndication 
   (const char* name, const ranap_DataVolumeReportingIndication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("do-report\n"); break;
      case 1: printf ("do-not-report\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_PDP_Type (const char* name, const ranap_PDP_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("empty\n"); break;
      case 1: printf ("ppp\n"); break;
      case 2: printf ("osp-ihoss\n"); break;
      case 3: printf ("ipv4\n"); break;
      case 4: printf ("ipv6\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PDP_TypeInformation 
   (const char* name, const ranap_PDP_TypeInformation* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PDP_Type (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_UserPlaneMode 
   (const char* name, const ranap_UserPlaneMode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("transparent-mode\n"); break;
      case 1: printf ("support-mode-for-predefined-SDU-sizes\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_UP_ModeVersions 
   (const char* name, const ranap_UP_ModeVersions* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_Service_Handover 
   (const char* name, const ranap_Service_Handover* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("handover-to-GSM-should-be-performed\n"); break;
      case 1: printf ("handover-to-GSM-should-not-be-performed\n"); break;
      case 2: printf ("handover-to-GSM-shall-not-be-performed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_TBCD_STRING 
   (const char* name, const ranap_TBCD_STRING* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_PLMNidentity 
   (const char* name, const ranap_PLMNidentity* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TMGI_serviceID 
   (const char* name, const ranap_TMGI_serviceID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TMGI (const char* name, const ranap_TMGI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_TMGI_serviceID ("serviceID", &pvalue->serviceID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMS_PTP_RAB_ID 
   (const char* name, const ranap_MBMS_PTP_RAB_ID* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_CauseRadioNetwork 
   (const char* name, const ranap_CauseRadioNetwork* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 1: printf ("%s = ranap_rab_pre_empted\n", name); break;
      case 2: printf ("%s = ranap_trelocoverall_expiry\n", name); break;
      case 3: printf ("%s = ranap_trelocprep_expiry\n", name); break;
      case 4: printf ("%s = ranap_treloccomplete_expiry\n", name); break;
      case 5: printf ("%s = ranap_tqueing_expiry\n", name); break;
      case 6: printf ("%s = ranap_relocation_triggered\n", name); break;
      case 7: printf ("%s = ranap_trellocalloc_expiry\n", name); break;
      case 8: printf ("%s = ranap_unable_to_establish_during_relocation\n", name); break;
      case 9: printf ("%s = ranap_unknown_target_rnc\n", name); break;
      case 10: printf ("%s = ranap_relocation_cancelled\n", name); break;
      case 11: printf ("%s = ranap_successful_relocation\n", name); break;
      case 12: printf ("%s = ranap_requested_ciphering_and_or_integrity_protection_algorithms_not_supported\n", name); break;
      case 13: printf ("%s = ranap_conflict_with_already_existing_integrity_protection_and_or_ciphering_information\n", name); break;
      case 14: printf ("%s = ranap_failure_in_the_radio_interface_procedure\n", name); break;
      case 15: printf ("%s = ranap_release_due_to_utran_generated_reason\n", name); break;
      case 16: printf ("%s = ranap_user_inactivity\n", name); break;
      case 17: printf ("%s = ranap_time_critical_relocation\n", name); break;
      case 18: printf ("%s = ranap_requested_traffic_class_not_available\n", name); break;
      case 19: printf ("%s = ranap_invalid_rab_parameters_value\n", name); break;
      case 20: printf ("%s = ranap_requested_maximum_bit_rate_not_available\n", name); break;
      case 21: printf ("%s = ranap_requested_guaranteed_bit_rate_not_available\n", name); break;
      case 22: printf ("%s = ranap_requested_transfer_delay_not_achievable\n", name); break;
      case 23: printf ("%s = ranap_invalid_rab_parameters_combination\n", name); break;
      case 24: printf ("%s = ranap_condition_violation_for_sdu_parameters\n", name); break;
      case 25: printf ("%s = ranap_condition_violation_for_traffic_handling_priority\n", name); break;
      case 26: printf ("%s = ranap_condition_violation_for_guaranteed_bit_rate\n", name); break;
      case 27: printf ("%s = ranap_user_plane_versions_not_supported\n", name); break;
      case 28: printf ("%s = ranap_iu_up_failure\n", name); break;
      case 29: printf ("%s = ranap_relocation_failure_in_target_CN_RNC_or_target_system\n", name); break;
      case 30: printf ("%s = ranap_invalid_RAB_ID\n", name); break;
      case 31: printf ("%s = ranap_no_remaining_rab\n", name); break;
      case 32: printf ("%s = ranap_interaction_with_other_procedure\n", name); break;
      case 33: printf ("%s = ranap_requested_maximum_bit_rate_for_dl_not_available\n", name); break;
      case 34: printf ("%s = ranap_requested_maximum_bit_rate_for_ul_not_available\n", name); break;
      case 35: printf ("%s = ranap_requested_guaranteed_bit_rate_for_dl_not_available\n", name); break;
      case 36: printf ("%s = ranap_requested_guaranteed_bit_rate_for_ul_not_available\n", name); break;
      case 37: printf ("%s = ranap_repeated_integrity_checking_failure\n", name); break;
      case 38: printf ("%s = ranap_requested_request_type_not_supported\n", name); break;
      case 39: printf ("%s = ranap_request_superseded\n", name); break;
      case 40: printf ("%s = ranap_release_due_to_UE_generated_signalling_connection_release\n", name); break;
      case 41: printf ("%s = ranap_resource_optimisation_relocation\n", name); break;
      case 42: printf ("%s = ranap_requested_information_not_available\n", name); break;
      case 43: printf ("%s = ranap_relocation_desirable_for_radio_reasons\n", name); break;
      case 44: printf ("%s = ranap_relocation_not_supported_in_target_RNC_or_target_system\n", name); break;
      case 45: printf ("%s = ranap_directed_retry\n", name); break;
      case 46: printf ("%s = ranap_radio_connection_with_UE_Lost\n", name); break;
      case 47: printf ("%s = ranap_rNC_unable_to_establish_all_RFCs\n", name); break;
      case 48: printf ("%s = ranap_deciphering_keys_not_available\n", name); break;
      case 49: printf ("%s = ranap_dedicated_assistance_data_not_available\n", name); break;
      case 50: printf ("%s = ranap_relocation_target_not_allowed\n", name); break;
      case 51: printf ("%s = ranap_location_reporting_congestion\n", name); break;
      case 52: printf ("%s = ranap_reduce_load_in_serving_cell\n", name); break;
      case 53: printf ("%s = ranap_no_radio_resources_available_in_target_cell\n", name); break;
      case 54: printf ("%s = ranap_gERAN_Iumode_failure\n", name); break;
      case 55: printf ("%s = ranap_access_restricted_due_to_shared_networks\n", name); break;
      case 56: printf ("%s = ranap_incoming_relocation_not_supported_due_to_PUESBINE_feature\n", name); break;
      case 57: printf ("%s = ranap_traffic_load_in_the_target_cell_higher_than_in_the_source_cell\n", name); break;
      case 58: printf ("%s = ranap_mBMS_no_multicast_service_for_this_UE\n", name); break;
      case 59: printf ("%s = ranap_mBMS_unknown_UE_ID\n", name); break;
      case 60: printf ("%s = ranap_successful_MBMS_session_start_no_data_bearer_necessary\n", name); break;
      case 61: printf ("%s = ranap_mBMS_superseded_due_to_NNSF\n", name); break;
      case 62: printf ("%s = ranap_mBMS_UE_linking_already_done\n", name); break;
      case 63: printf ("%s = ranap_mBMS_UE_de_linking_failure_no_existing_UE_linking\n", name); break;
      case 64: printf ("%s = ranap_tMGI_unknown\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_CauseTransmissionNetwork 
   (const char* name, const ranap_CauseTransmissionNetwork* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 65: printf ("%s = ranap_signalling_transport_resource_failure\n", name); break;
      case 66: printf ("%s = ranap_iu_transport_connection_failed_to_establish\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_CauseNAS (const char* name, const ranap_CauseNAS* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 81: printf ("%s = ranap_user_restriction_start_indication\n", name); break;
      case 82: printf ("%s = ranap_user_restriction_end_indication\n", name); break;
      case 83: printf ("%s = ranap_normal_release\n", name); break;
      case 84: printf ("%s = ranap_csg_subscription_expiry\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_CauseProtocol 
   (const char* name, const ranap_CauseProtocol* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 97: printf ("%s = ranap_transfer_syntax_error\n", name); break;
      case 98: printf ("%s = ranap_semantic_error\n", name); break;
      case 99: printf ("%s = ranap_message_not_compatible_with_receiver_state\n", name); break;
      case 100: printf ("%s = ranap_abstract_syntax_error_reject\n", name); break;
      case 101: printf ("%s = ranap_abstract_syntax_error_ignore_and_notify\n", name); break;
      case 102: printf ("%s = ranap_abstract_syntax_error_falsely_constructed_message\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_CauseMisc 
   (const char* name, const ranap_CauseMisc* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 113: printf ("%s = ranap_om_intervention\n", name); break;
      case 114: printf ("%s = ranap_no_resource_available\n", name); break;
      case 115: printf ("%s = ranap_unspecified_failure\n", name); break;
      case 116: printf ("%s = ranap_network_optimisation\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_CauseNon_Standard 
   (const char* name, const ranap_CauseNon_Standard* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_CauseRadioNetworkExtension 
   (const char* name, const ranap_CauseRadioNetworkExtension* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 257: printf ("%s = ranap_iP_multicast_address_and_APN_not_valid\n", name); break;
      case 258: printf ("%s = ranap_mBMS_de_registration_rejected_due_to_implicit_registration\n", name); break;
      case 259: printf ("%s = ranap_mBMS_request_superseded\n", name); break;
      case 260: printf ("%s = ranap_mBMS_de_registration_during_session_not_allowed\n", name); break;
      case 261: printf ("%s = ranap_mBMS_no_data_bearer_necessary\n", name); break;
      case 262: printf ("%s = ranap_periodicLocationInformationNotAvailable\n", name); break;
      case 263: printf ("%s = ranap_gTP_Resources_Unavailable\n", name); break;
      case 264: printf ("%s = ranap_tMGI_inUse_overlapping_MBMS_service_area\n", name); break;
      case 265: printf ("%s = ranap_mBMS_no_cell_in_MBMS_service_area\n", name); break;
      case 266: printf ("%s = ranap_no_Iu_CS_UP_relocation\n", name); break;
      case 267: printf ("%s = ranap_successful_MBMS_Session_Start_IP_Multicast_Bearer_established\n", name); break;
      case 268: printf ("%s = ranap_cS_fallback_triggered\n", name); break;
      case 269: printf ("%s = ranap_invalid_CSG_Id\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_Cause (const char* name, const ranap_Cause* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* radioNetwork */
      case 1:
      {
         asn1Print_ranap_CauseRadioNetwork ("radioNetwork", &pvalue->
            u.radioNetwork);
         break;
      }
      /* transmissionNetwork */
      case 2:
      {
         asn1Print_ranap_CauseTransmissionNetwork ("transmissionNetwork", &
            pvalue->u.transmissionNetwork);
         break;
      }
      /* nAS */
      case 3:
      {
         asn1Print_ranap_CauseNAS ("nAS", &pvalue->u.nAS);
         break;
      }
      /* protocol */
      case 4:
      {
         asn1Print_ranap_CauseProtocol ("protocol", &pvalue->u.protocol);
         break;
      }
      /* misc */
      case 5:
      {
         asn1Print_ranap_CauseMisc ("misc", &pvalue->u.misc);
         break;
      }
      /* non-Standard */
      case 6:
      {
         asn1Print_ranap_CauseNon_Standard ("non-Standard", &pvalue->
            u.non_Standard);
         break;
      }
      /* radioNetworkExtension */
      case 7:
      {
         asn1Print_ranap_CauseRadioNetworkExtension ("radioNetworkExtension", &
            pvalue->u.radioNetworkExtension);
         break;
      }
      /* extElem1 */
      case 8:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DL_N_PDU_SequenceNumber 
   (const char* name, const ranap_DL_N_PDU_SequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_UL_N_PDU_SequenceNumber 
   (const char* name, const ranap_UL_N_PDU_SequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_IuSignallingConnectionIdentifier 
   (const char* name, const ranap_IuSignallingConnectionIdentifier* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_Ass_RAB_Parameter_MaxBitrateList 
   (const char* name, const ranap_Ass_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Ass_RAB_Parameter_GuaranteedBitrateList 
   (const char* name, const ranap_Ass_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Ass_RAB_Parameters 
   (const char* name, const ranap_Ass_RAB_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.assMaxBitrateInfPresent) {
      asn1Print_ranap_Ass_RAB_Parameter_MaxBitrateList ("assMaxBitrateInf", &
         pvalue->assMaxBitrateInf);
   }

   if (pvalue->m.assGuaranteedBitRateInfPresent) {
      asn1Print_ranap_Ass_RAB_Parameter_GuaranteedBitrateList (
         "assGuaranteedBitRateInf", &pvalue->assGuaranteedBitRateInf);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GERAN_Classmark 
   (const char* name, const ranap_GERAN_Classmark* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_NAS_PDU (const char* name, const ranap_NAS_PDU* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_SAPI (const char* name, const ranap_SAPI* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("sapi-0\n"); break;
      case 1: printf ("sapi-3\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_CN_DomainIndicator 
   (const char* name, const ranap_CN_DomainIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cs-domain\n"); break;
      case 1: printf ("ps-domain\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateType 
   (const char* name, const ranap_Alt_RAB_Parameter_MaxBitrateType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified\n"); break;
      case 1: printf ("value-range\n"); break;
      case 2: printf ("discrete-values\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateList 
   (const char* name, const ranap_Alt_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_MaxBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_MaxBitrates* pvalue)
{
   ranap_Alt_RAB_Parameter_MaxBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_Alt_RAB_Parameter_MaxBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateList (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_MaxBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateType ("altMaxBitrateType", &
      pvalue->altMaxBitrateType);

   if (pvalue->m.altMaxBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_MaxBitrates ("altMaxBitrates", &pvalue
         ->altMaxBitrates);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateType 
   (const char* name, const ranap_Alt_RAB_Parameter_GuaranteedBitrateType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("unspecified\n"); break;
      case 1: printf ("value-range\n"); break;
      case 2: printf ("discrete-values\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateList 
   (const char* name, const ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_GuaranteedBitrates* pvalue)
{
   ranap_Alt_RAB_Parameter_GuaranteedBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_Alt_RAB_Parameter_GuaranteedBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateList (namebuf, pdata0
         );
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_GuaranteedBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (
      "altGuaranteedBitrateType", &pvalue->altGuaranteedBitrateType);

   if (pvalue->m.altGuaranteedBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrates (
         "altGuaranteedBitrates", &pvalue->altGuaranteedBitrates);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Alt_RAB_Parameters 
   (const char* name, const ranap_Alt_RAB_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.altMaxBitrateInfPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateInf ("altMaxBitrateInf", &
         pvalue->altMaxBitrateInf);
   }

   if (pvalue->m.altGuaranteedBitRateInfPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateInf (
         "altGuaranteedBitRateInf", &pvalue->altGuaranteedBitRateInf);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Requested_RAB_Parameter_MaxBitrateList 
   (const char* name, const ranap_Requested_RAB_Parameter_MaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Requested_RAB_Parameter_GuaranteedBitrateList 
   (const char* name, const ranap_Requested_RAB_Parameter_GuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Requested_RAB_Parameter_Values 
   (const char* name, const ranap_Requested_RAB_Parameter_Values* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.requestedMaxBitratesPresent) {
      asn1Print_ranap_Requested_RAB_Parameter_MaxBitrateList (
         "requestedMaxBitrates", &pvalue->requestedMaxBitrates);
   }

   if (pvalue->m.requestedGuaranteedBitratesPresent) {
      asn1Print_ranap_Requested_RAB_Parameter_GuaranteedBitrateList (
         "requestedGuaranteedBitrates", &pvalue->requestedGuaranteedBitrates);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSHCIndicator 
   (const char* name, const ranap_MBMSHCIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("uncompressed-header\n"); break;
      case 1: printf ("compressed-header\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_IPMulticastAddress 
   (const char* name, const ranap_IPMulticastAddress* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_AccuracyFulfilmentIndicator 
   (const char* name, const ranap_AccuracyFulfilmentIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("requested-Accuracy-Fulfilled\n"); break;
      case 1: printf ("requested-Accuracy-Not-Fulfilled\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Additional_PositioningMethodAndUsage 
   (const char* name, const ranap_Additional_PositioningMethodAndUsage* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_AlternativeRABConfigurationRequest 
   (const char* name, const ranap_AlternativeRABConfigurationRequest* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("alternative-RAB-configuration-Requested\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_APN (const char* name, const ranap_APN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_BarometricPressure 
   (const char* name, const ranap_BarometricPressure* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Cell_Access_Mode 
   (const char* name, const ranap_Cell_Access_Mode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("hybrid\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Cell_Id (const char* name, const ranap_Cell_Id* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Cell_Capacity_Class_Value 
   (const char* name, const ranap_Cell_Capacity_Class_Value* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_CellType (const char* name, const ranap_CellType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("macro\n"); break;
      case 1: printf ("micro\n"); break;
      case 2: printf ("pico\n"); break;
      case 3: printf ("femto\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_CivicAddress 
   (const char* name, const ranap_CivicAddress* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_ClientType 
   (const char* name, const ranap_ClientType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("emergency-Services\n"); break;
      case 1: printf ("value-Added-Services\n"); break;
      case 2: printf ("pLMN-Operator-Services\n"); break;
      case 3: printf ("lawful-Intercept-Services\n"); break;
      case 4: printf ("pLMN-Operator-Broadcast-Services\n"); break;
      case 5: printf ("pLMN-Operator-O-et-M\n"); break;
      case 6: printf ("pLMN-Operator-Anonymous-Statistics\n"); break;
      case 7: printf ("pLMN-Operator-Target-MS-Service-Support\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_EncryptionAlgorithm 
   (const char* name, const ranap_EncryptionAlgorithm* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = ranap_no_encryption\n", name); break;
      case 1: printf ("%s = ranap_standard_UMTS_encryption_algorith_UEA1\n", name); break;
      case 2: printf ("%s = ranap_standard_UMTS_encryption_algorithm_UEA2\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_ChosenEncryptionAlgorithm 
   (const char* name, const ranap_ChosenEncryptionAlgorithm* pvalue)
{
   asn1Print_ranap_EncryptionAlgorithm (name, pvalue);
}

void asn1Print_ranap_IntegrityProtectionAlgorithm 
   (const char* name, const ranap_IntegrityProtectionAlgorithm* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = ranap_standard_UMTS_integrity_algorithm_UIA1\n", name); break;
      case 1: printf ("%s = ranap_standard_UMTS_integrity_algorithm_UIA2\n", name); break;
      case 15: printf ("%s = ranap_no_value\n", name); break;
      default: rtxPrintUnsigned (name, *pvalue);
   }
}

void asn1Print_ranap_ChosenIntegrityProtectionAlgorithm 
   (const char* name, const ranap_ChosenIntegrityProtectionAlgorithm* pvalue)
{
   asn1Print_ranap_IntegrityProtectionAlgorithm (name, pvalue);
}

void asn1Print_ranap_CI (const char* name, const ranap_CI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_ClassmarkInformation2 
   (const char* name, const ranap_ClassmarkInformation2* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_ClassmarkInformation3 
   (const char* name, const ranap_ClassmarkInformation3* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_CN_ID (const char* name, const ranap_CN_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Correlation_ID 
   (const char* name, const ranap_Correlation_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_CSFB_Information 
   (const char* name, const ranap_CSFB_Information* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("csfb\n"); break;
      case 1: printf ("csfb-high-priority\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_CSG_Id (const char* name, const ranap_CSG_Id* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_CSG_Membership_Status 
   (const char* name, const ranap_CSG_Membership_Status* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("member\n"); break;
      case 1: printf ("non-member\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_DataPDUType 
   (const char* name, const ranap_DataPDUType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pDUtype0\n"); break;
      case 1: printf ("pDUtype1\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_DCH_ID (const char* name, const ranap_DCH_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_ForwardingIndication 
   (const char* name, const ranap_ForwardingIndication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("forwarding-admitted\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_D_RNTI (const char* name, const ranap_D_RNTI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_DRX_CycleLengthCoefficient 
   (const char* name, const ranap_DRX_CycleLengthCoefficient* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_DSCH_ID (const char* name, const ranap_DSCH_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_EARFCN_Extended 
   (const char* name, const ranap_EARFCN_Extended* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_E_DCH_MAC_d_Flow_ID 
   (const char* name, const ranap_E_DCH_MAC_d_Flow_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_EncryptionKey 
   (const char* name, const ranap_EncryptionKey* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_End_Of_CSFB 
   (const char* name, const ranap_End_Of_CSFB* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("end-of-CSFB\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_E_UTRAN_Service_Handover 
   (const char* name, const ranap_E_UTRAN_Service_Handover* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("handover-to-E-UTRAN-shall-not-be-performed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Event (const char* name, const ranap_Event* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("stop-change-of-service-area\n"); break;
      case 1: printf ("direct\n"); break;
      case 2: printf ("change-of-servicearea\n"); break;
      case 3: printf ("stop-direct\n"); break;
      case 4: printf ("periodic\n"); break;
      case 5: printf ("stop-periodic\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_ExtendedGuaranteedBitrate 
   (const char* name, const ranap_ExtendedGuaranteedBitrate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_ExtendedMaxBitrate 
   (const char* name, const ranap_ExtendedMaxBitrate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_ExtendedRNC_ID 
   (const char* name, const ranap_ExtendedRNC_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_FrameSequenceNumber 
   (const char* name, const ranap_FrameSequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_FrequenceLayerConvergenceFlag 
   (const char* name, const ranap_FrequenceLayerConvergenceFlag* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("no-FLC-flag\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_GANSS_PositioningMethodAndUsage 
   (const char* name, const ranap_GANSS_PositioningMethodAndUsage* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_GERAN_BSC_Container 
   (const char* name, const ranap_GERAN_BSC_Container* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_HigherBitratesThan16MbpsFlag 
   (const char* name, const ranap_HigherBitratesThan16MbpsFlag* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("allowed\n"); break;
      case 1: printf ("not-allowed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_HS_DSCH_MAC_d_Flow_ID 
   (const char* name, const ranap_HS_DSCH_MAC_d_Flow_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_IMEI (const char* name, const ranap_IMEI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_IMEISV (const char* name, const ranap_IMEISV* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_IMSI (const char* name, const ranap_IMSI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_IncludeVelocity 
   (const char* name, const ranap_IncludeVelocity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("requested\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_InformationExchangeID 
   (const char* name, const ranap_InformationExchangeID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_InformationExchangeType 
   (const char* name, const ranap_InformationExchangeType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("transfer\n"); break;
      case 1: printf ("request\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_InformationTransferID 
   (const char* name, const ranap_InformationTransferID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_IntegrityProtectionKey 
   (const char* name, const ranap_IntegrityProtectionKey* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_KeyStatus 
   (const char* name, const ranap_KeyStatus* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("old\n"); break;
      case 1: printf ("new\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_LAC (const char* name, const ranap_LAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_LHN_ID (const char* name, const ranap_LHN_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_Links_to_log 
   (const char* name, const ranap_Links_to_log* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("uplink\n"); break;
      case 1: printf ("downlink\n"); break;
      case 2: printf ("both-uplink-and-downlink\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_LoadValue 
   (const char* name, const ranap_LoadValue* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode 
   (const char* name, const ranap_LocationRelatedDataRequestTypeSpecificToGERANIuMode* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("decipheringKeysEOTD\n"); break;
      case 1: printf ("dedicatedMobileAssistedEOTDAssistanceData\n"); break;
      case 2: printf ("dedicatedMobileBasedEOTDAssistanceData\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_ReportChangeOfSAI 
   (const char* name, const ranap_ReportChangeOfSAI* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("requested\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PeriodicReportingIndicator 
   (const char* name, const ranap_PeriodicReportingIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("periodicSAI\n"); break;
      case 1: printf ("periodicGeo\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_DirectReportingIndicator 
   (const char* name, const ranap_DirectReportingIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("directSAI\n"); break;
      case 1: printf ("directGeo\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_L3_Information 
   (const char* name, const ranap_L3_Information* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_M4_Period 
   (const char* name, const ranap_M4_Period* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms250\n"); break;
      case 2: printf ("ms500\n"); break;
      case 3: printf ("ms1000\n"); break;
      case 4: printf ("ms2000\n"); break;
      case 5: printf ("ms3000\n"); break;
      case 6: printf ("ms4000\n"); break;
      case 7: printf ("ms6000\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_M4_Threshold 
   (const char* name, const ranap_M4_Threshold* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_M5_Period 
   (const char* name, const ranap_M5_Period* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms100\n"); break;
      case 1: printf ("ms250\n"); break;
      case 2: printf ("ms500\n"); break;
      case 3: printf ("ms1000\n"); break;
      case 4: printf ("ms2000\n"); break;
      case 5: printf ("ms3000\n"); break;
      case 6: printf ("ms4000\n"); break;
      case 7: printf ("ms6000\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_M6_Period 
   (const char* name, const ranap_M6_Period* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms1000\n"); break;
      case 1: printf ("ms2000\n"); break;
      case 2: printf ("ms3000\n"); break;
      case 3: printf ("ms4000\n"); break;
      case 4: printf ("ms6000\n"); break;
      case 5: printf ("ms8000\n"); break;
      case 6: printf ("ms12000\n"); break;
      case 7: printf ("ms16000\n"); break;
      case 8: printf ("ms20000\n"); break;
      case 9: printf ("ms24000\n"); break;
      case 10: printf ("ms28000\n"); break;
      case 11: printf ("ms32000\n"); break;
      case 12: printf ("ms64000\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_M7_Period 
   (const char* name, const ranap_M7_Period* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms1000\n"); break;
      case 1: printf ("ms2000\n"); break;
      case 2: printf ("ms3000\n"); break;
      case 3: printf ("ms4000\n"); break;
      case 4: printf ("ms6000\n"); break;
      case 5: printf ("ms8000\n"); break;
      case 6: printf ("ms12000\n"); break;
      case 7: printf ("ms16000\n"); break;
      case 8: printf ("ms20000\n"); break;
      case 9: printf ("ms24000\n"); break;
      case 10: printf ("ms28000\n"); break;
      case 11: printf ("ms32000\n"); break;
      case 12: printf ("ms64000\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Management_Based_MDT_Allowed 
   (const char* name, const ranap_Management_Based_MDT_Allowed* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("allowed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSBearerServiceType 
   (const char* name, const ranap_MBMSBearerServiceType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("multicast\n"); break;
      case 1: printf ("broadcast\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSCNDe_Registration 
   (const char* name, const ranap_MBMSCNDe_Registration* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("normalsessionstop\n"); break;
      case 1: printf ("deregister\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSCountingInformation 
   (const char* name, const ranap_MBMSCountingInformation* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("counting\n"); break;
      case 1: printf ("notcounting\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSLinkingInformation 
   (const char* name, const ranap_MBMSLinkingInformation* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("uE-has-joined-multicast-services\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSRegistrationRequestType 
   (const char* name, const ranap_MBMSRegistrationRequestType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("register\n"); break;
      case 1: printf ("deregister\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MBMSServiceArea 
   (const char* name, const ranap_MBMSServiceArea* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_MBMSSessionDuration 
   (const char* name, const ranap_MBMSSessionDuration* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_MBMSSessionIdentity 
   (const char* name, const ranap_MBMSSessionIdentity* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_MBMSSessionRepetitionNumber 
   (const char* name, const ranap_MBMSSessionRepetitionNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_MDT_Activation 
   (const char* name, const ranap_MDT_Activation* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("immediateMDTonly\n"); break;
      case 1: printf ("loggedMDTonly\n"); break;
      case 2: printf ("immediateMDTandTrace\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MeasurementQuantity 
   (const char* name, const ranap_MeasurementQuantity* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cpichEcNo\n"); break;
      case 1: printf ("cpichRSCP\n"); break;
      case 2: printf ("pathloss\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_MeasurementsToActivate 
   (const char* name, const ranap_MeasurementsToActivate* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_MSISDN (const char* name, const ranap_MSISDN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_NAS_SequenceNumber 
   (const char* name, const ranap_NAS_SequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_NewBSS_To_OldBSS_Information 
   (const char* name, const ranap_NewBSS_To_OldBSS_Information* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_NonSearchingIndication 
   (const char* name, const ranap_NonSearchingIndication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("non-searching\n"); break;
      case 1: printf ("searching\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_NRI (const char* name, const ranap_NRI* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_NRTLoadInformationValue 
   (const char* name, const ranap_NRTLoadInformationValue* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Null_NRI (const char* name, const ranap_Null_NRI* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_NumberOfIuInstances 
   (const char* name, const ranap_NumberOfIuInstances* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_NumberOfSteps 
   (const char* name, const ranap_NumberOfSteps* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Offload_RAB_Parameters_APN 
   (const char* name, const ranap_Offload_RAB_Parameters_APN* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_Offload_RAB_Parameters_ChargingCharacteristics 
   (const char* name, const ranap_Offload_RAB_Parameters_ChargingCharacteristics* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_OldBSS_ToNewBSS_Information 
   (const char* name, const ranap_OldBSS_ToNewBSS_Information* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_OMC_ID (const char* name, const ranap_OMC_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_Out_Of_UTRAN 
   (const char* name, const ranap_Out_Of_UTRAN* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("cell-reselection-to-EUTRAN\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PagingCause 
   (const char* name, const ranap_PagingCause* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("terminating-conversational-call\n"); break;
      case 1: printf ("terminating-streaming-call\n"); break;
      case 2: printf ("terminating-interactive-call\n"); break;
      case 3: printf ("terminating-background-call\n"); break;
      case 4: printf ("terminating-low-priority-signalling\n"); break;
      case 5: printf ("terminating-high-priority-signalling\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PDP_Type_extension 
   (const char* name, const ranap_PDP_Type_extension* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ipv4-and-ipv6\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PDUType14FrameSequenceNumber 
   (const char* name, const ranap_PDUType14FrameSequenceNumber* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_LoggingInterval 
   (const char* name, const ranap_LoggingInterval* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("s1d28\n"); break;
      case 1: printf ("s2d56\n"); break;
      case 2: printf ("s5d12\n"); break;
      case 3: printf ("s10d24\n"); break;
      case 4: printf ("s20d48\n"); break;
      case 5: printf ("s30d72\n"); break;
      case 6: printf ("s40d96\n"); break;
      case 7: printf ("s61d44\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_LoggingDuration 
   (const char* name, const ranap_LoggingDuration* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("min10\n"); break;
      case 1: printf ("min20\n"); break;
      case 2: printf ("min40\n"); break;
      case 3: printf ("min60\n"); break;
      case 4: printf ("min90\n"); break;
      case 5: printf ("min120\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_Port_Number 
   (const char* name, const ranap_Port_Number* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_PositioningDataDiscriminator 
   (const char* name, const ranap_PositioningDataDiscriminator* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_PositioningMethodAndUsage 
   (const char* name, const ranap_PositioningMethodAndUsage* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_PositioningPriority 
   (const char* name, const ranap_PositioningPriority* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("high-Priority\n"); break;
      case 1: printf ("normal-Priority\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_PositionDataSpecificToGERANIuMode 
   (const char* name, const ranap_PositionDataSpecificToGERANIuMode* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_Priority_Class_Indicator 
   (const char* name, const ranap_Priority_Class_Indicator* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_PowerSavingIndicator 
   (const char* name, const ranap_PowerSavingIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("psmConfigured\n"); break;
      case 1: printf ("eDRXConfigured\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_P_TMSI (const char* name, const ranap_P_TMSI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_RAC (const char* name, const ranap_RAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_RAT_Type (const char* name, const ranap_RAT_Type* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("utran\n"); break;
      case 1: printf ("geran\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RateControlAllowed 
   (const char* name, const ranap_RateControlAllowed* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not-allowed\n"); break;
      case 1: printf ("allowed\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_RedirectAttemptFlag_ 
   (const char* name, const void* pvalue)
{
   OS_UNUSED_ARG (pvalue);

   rtxPrintIndent();
   rtxPrintNull (name);
}

void asn1Print_ranap_RedirectionCompleted 
   (const char* name, const ranap_RedirectionCompleted* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("redirection-completed\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RejectCauseValue 
   (const char* name, const ranap_RejectCauseValue* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("pLMN-Not-Allowed\n"); break;
      case 1: printf ("location-Area-Not-Allowed\n"); break;
      case 2: printf ("roaming-Not-Allowed-In-This-Location-Area\n"); break;
      case 3: printf ("no-Suitable-Cell-In-Location-Area\n"); break;
      case 4: printf ("gPRS-Services-Not-Allowed-In-This-PLMN\n"); break;
      case 5: printf ("cS-PS-coordination-required\n"); break;
      case 6: printf ("network-failure\n"); break;
      case 7: printf ("not-authorized-for-this-CSG\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RelocationType 
   (const char* name, const ranap_RelocationType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ue-not-involved\n"); break;
      case 1: printf ("ue-involved\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RepetitionNumber0 
   (const char* name, const ranap_RepetitionNumber0* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RepetitionNumber1 
   (const char* name, const ranap_RepetitionNumber1* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_ReportArea 
   (const char* name, const ranap_ReportArea* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("service-area\n"); break;
      case 1: printf ("geographical-area\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_ReportInterval 
   (const char* name, const ranap_ReportInterval* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ms250\n"); break;
      case 1: printf ("ms500\n"); break;
      case 2: printf ("ms1000\n"); break;
      case 3: printf ("ms2000\n"); break;
      case 4: printf ("ms3000\n"); break;
      case 5: printf ("ms4000\n"); break;
      case 6: printf ("ms6000\n"); break;
      case 7: printf ("ms12000\n"); break;
      case 8: printf ("ms16000\n"); break;
      case 9: printf ("ms20000\n"); break;
      case 10: printf ("ms24000\n"); break;
      case 11: printf ("ms32000\n"); break;
      case 12: printf ("ms64000\n"); break;
      case 13: printf ("ms8000\n"); break;
      case 14: printf ("ms28000\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_ReportAmount 
   (const char* name, const ranap_ReportAmount* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("n1\n"); break;
      case 1: printf ("n2\n"); break;
      case 2: printf ("n4\n"); break;
      case 3: printf ("n8\n"); break;
      case 4: printf ("n16\n"); break;
      case 5: printf ("n32\n"); break;
      case 6: printf ("n64\n"); break;
      case 7: printf ("infinity\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RequestedGPSAssistanceData 
   (const char* name, const ranap_RequestedGPSAssistanceData* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_RequestedGANSSAssistanceData 
   (const char* name, const ranap_RequestedGANSSAssistanceData* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_RequestedLocationRelatedDataType 
   (const char* name, const ranap_RequestedLocationRelatedDataType* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("decipheringKeysUEBasedOTDOA\n"); break;
      case 1: printf ("decipheringKeysAssistedGPS\n"); break;
      case 2: printf ("dedicatedAssistanceDataUEBasedOTDOA\n"); break;
      case 3: printf ("dedicatedAssistanceDataAssistedGPS\n"); break;
      case 4: printf ("decipheringKeysAssistedGANSS\n"); break;
      case 5: printf ("dedicatedAssistanceDataAssistedGANSS\n"); break;
      case 6: printf ("decipheringKeysAssistedGPSandGANSS\n"); break;
      case 7: printf ("dedicatedAssistanceDataAssistedGPSandGANSS\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_ResponseTime 
   (const char* name, const ranap_ResponseTime* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("lowdelay\n"); break;
      case 1: printf ("delaytolerant\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RIMInformation 
   (const char* name, const ranap_RIMInformation* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_RNC_ID (const char* name, const ranap_RNC_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RRC_Container 
   (const char* name, const ranap_RRC_Container* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_RTLoadValue 
   (const char* name, const ranap_RTLoadValue* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_RSRVCC_HO_Indication 
   (const char* name, const ranap_RSRVCC_HO_Indication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ps-only\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RSRVCC_Operation_Possible 
   (const char* name, const ranap_RSRVCC_Operation_Possible* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("rsrvcc-possible\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_SAC (const char* name, const ranap_SAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_SessionUpdateID 
   (const char* name, const ranap_SessionUpdateID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Session_Re_establishment_Indicator 
   (const char* name, const ranap_Session_Re_establishment_Indicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("true\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_SignallingIndication 
   (const char* name, const ranap_SignallingIndication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("signalling\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_SGSN_Group_ID 
   (const char* name, const ranap_SGSN_Group_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_SNAC (const char* name, const ranap_SNAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Source_ToTarget_TransparentContainer 
   (const char* name, const ranap_Source_ToTarget_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer 
   (const char* name, const ranap_SourceeNodeB_ToTargeteNodeB_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_SourceBSS_ToTargetBSS_TransparentContainer 
   (const char* name, const ranap_SourceBSS_ToTargetBSS_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_RSRQ_Extension 
   (const char* name, const ranap_RSRQ_Extension* pvalue)
{
   rtxPrintIndent ();
   rtxPrintInteger (name, *pvalue);
}

void asn1Print_ranap_MeasBand (const char* name, const ranap_MeasBand* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("v6\n"); break;
      case 1: printf ("v15\n"); break;
      case 2: printf ("v25\n"); break;
      case 3: printf ("v50\n"); break;
      case 4: printf ("v75\n"); break;
      case 5: printf ("v100\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_SubscriberProfileIDforRFP 
   (const char* name, const ranap_SubscriberProfileIDforRFP* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_SupportedBitrate 
   (const char* name, const ranap_SupportedBitrate* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_SRB_ID (const char* name, const ranap_SRB_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_SRVCC_HO_Indication 
   (const char* name, const ranap_SRVCC_HO_Indication* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("ps-and-cs\n"); break;
      case 1: printf ("cs-only\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_SRVCC_Operation_Possible 
   (const char* name, const ranap_SRVCC_Operation_Possible* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("srvcc-possible\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_TAC (const char* name, const ranap_TAC* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_Target_ToSource_TransparentContainer 
   (const char* name, const ranap_Target_ToSource_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer 
   (const char* name, const ranap_TargeteNodeB_ToSourceeNodeB_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_TargetBSS_ToSourceBSS_TransparentContainer 
   (const char* name, const ranap_TargetBSS_ToSourceBSS_TransparentContainer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_TargetCellId 
   (const char* name, const ranap_TargetCellId* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Time_UE_StayedInCell 
   (const char* name, const ranap_Time_UE_StayedInCell* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_Time_UE_StayedInCell_EnhancedGranularity 
   (const char* name, const ranap_Time_UE_StayedInCell_EnhancedGranularity* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_TimeToMBMSDataTransfer 
   (const char* name, const ranap_TimeToMBMSDataTransfer* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TimingDifferenceULDL 
   (const char* name, const ranap_TimingDifferenceULDL* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TMSI (const char* name, const ranap_TMSI* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TraceDepth 
   (const char* name, const ranap_TraceDepth* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("minimum\n"); break;
      case 1: printf ("medium\n"); break;
      case 2: printf ("maximum\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_TraceRecordingSessionReference 
   (const char* name, const ranap_TraceRecordingSessionReference* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_TraceReference 
   (const char* name, const ranap_TraceReference* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TraceType 
   (const char* name, const ranap_TraceType* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TriggerID 
   (const char* name, const ranap_TriggerID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_TypeOfError 
   (const char* name, const ranap_TypeOfError* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("not-understood\n"); break;
      case 1: printf ("missing\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_UE_AggregateMaximumBitRateDownlink 
   (const char* name, const ranap_UE_AggregateMaximumBitRateDownlink* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_UE_AggregateMaximumBitRateUplink 
   (const char* name, const ranap_UE_AggregateMaximumBitRateUplink* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_UE_History_Information 
   (const char* name, const ranap_UE_History_Information* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_UE_Usage_Type 
   (const char* name, const ranap_UE_Usage_Type* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_UESBI_IuA 
   (const char* name, const ranap_UESBI_IuA* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_UESBI_IuB 
   (const char* name, const ranap_UESBI_IuB* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_UPInitialisationFrame 
   (const char* name, const ranap_UPInitialisationFrame* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_USCH_ID (const char* name, const ranap_USCH_ID* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_VerticalSpeedDirection 
   (const char* name, const ranap_VerticalSpeedDirection* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("upward\n"); break;
      case 1: printf ("downward\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_VerticalAccuracyCode 
   (const char* name, const ranap_VerticalAccuracyCode* pvalue)
{
   rtxPrintIndent ();
   rtxPrintUnsigned (name, *pvalue);
}

void asn1Print_ranap_VoiceSupportMatchIndicator 
   (const char* name, const ranap_VoiceSupportMatchIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("supported\n"); break;
      case 1: printf ("not-supported\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey 
   (const char* name, const ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey 
   (const char* name, const ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_GeographicalCoordinates_latitudeSign 
   (const char* name, const ranap_GeographicalCoordinates_latitudeSign* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("north\n"); break;
      case 1: printf ("south\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_GA_AltitudeAndDirection_directionOfAltitude 
   (const char* name, const ranap_GA_AltitudeAndDirection_directionOfAltitude* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("height\n"); break;
      case 1: printf ("depth\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_InterfacesToTraceItem_interface_ 
   (const char* name, const ranap_InterfacesToTraceItem_interface_* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("iu-cs\n"); break;
      case 1: printf ("iu-ps\n"); break;
      case 2: printf ("iur\n"); break;
      case 3: printf ("iub\n"); break;
      case 4: printf ("uu\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs 
   (const char* name, const ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("emptylist\n"); break;
      case 1: printf ("fulllist\n"); break;
      default: printf ("%u\n", *pvalue);
   }
}

void asn1Print_ranap_RNCTraceInformation_traceActivationIndicator 
   (const char* name, const ranap_RNCTraceInformation_traceActivationIndicator* pvalue)
{
   rtxPrintIndent ();
   printf ("%s = ", name);
   switch (*pvalue) {
      case 0: printf ("activated\n"); break;
      case 1: printf ("deactivated\n"); break;
      default: printf ("???\n");
   }
}

void asn1Print_ranap_RSRVCC_Information_nonce 
   (const char* name, const ranap_RSRVCC_Information_nonce* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_RSRVCC_Information_iMSInformation 
   (const char* name, const ranap_RSRVCC_Information_iMSInformation* pvalue)
{
   rtxPrintIndent ();
   rtxPrintHexStr (name, OSRTMIN(sizeof(pvalue->data), pvalue->numocts), pvalue->data);
}

void asn1Print_ranap_SRVCC_Information_nonce 
   (const char* name, const ranap_SRVCC_Information_nonce* pvalue)
{
   rtxPrintIndent ();
   rtPrintBitStrBraceText (name, pvalue->numbits, pvalue->data);
}

void asn1Print_ranap_LAI (const char* name, const ranap_LAI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_LAC ("lAC", &pvalue->lAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Additional_CSPS_coordination_information 
   (const char* name, const ranap_Additional_CSPS_coordination_information* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.old_LAIPresent) {
      asn1Print_ranap_LAI ("old_LAI", &pvalue->old_LAI);
   }

   if (pvalue->m.old_RACPresent) {
      asn1Print_ranap_RAC ("old_RAC", &pvalue->old_RAC);
   }

   if (pvalue->m.nRIPresent) {
      asn1Print_ranap_NRI ("nRI", &pvalue->nRI);
   }

   if (pvalue->m.uE_is_AttachingPresent) {
      rtxPrintIndent();
      rtxPrintNull ("uE_is_Attaching");
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Additional_PositioningDataSet 
   (const char* name, const ranap_Additional_PositioningDataSet* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Additional_PositioningMethodAndUsage (namebuf, &pvalue->
         elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedGuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates* pvalue)
{
   ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateList (
         namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (
      "altExtendedGuaranteedBitrateType", &pvalue->
      altExtendedGuaranteedBitrateType);

   if (pvalue->m.altExtendedGuaranteedBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_ExtendedGuaranteedBitrates (
         "altExtendedGuaranteedBitrates", &pvalue->
         altExtendedGuaranteedBitrates);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SupportedRAB_ParameterBitrateList 
   (const char* name, const ranap_SupportedRAB_ParameterBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SupportedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates* pvalue)
{
   ranap_SupportedRAB_ParameterBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SupportedRAB_ParameterBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SupportedRAB_ParameterBitrateList (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_GuaranteedBitrateType (
      "altSupportedGuaranteedBitrateType", &pvalue->
      altSupportedGuaranteedBitrateType);

   if (pvalue->m.altSupportedGuaranteedBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_SupportedGuaranteedBitrates (
         "altSupportedGuaranteedBitrates", &pvalue->
         altSupportedGuaranteedBitrates);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedMaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedMaxBitrates* pvalue)
{
   ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateList (namebuf, pdata0
         );
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_ExtendedMaxBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateType (
      "altExtendedMaxBitrateType", &pvalue->altExtendedMaxBitrateType);

   if (pvalue->m.altExtendedMaxBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_ExtendedMaxBitrates (
         "altExtendedMaxBitrates", &pvalue->altExtendedMaxBitrates);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Alt_RAB_Parameter_SupportedMaxBitrates 
   (const char* name, const ranap_Alt_RAB_Parameter_SupportedMaxBitrates* pvalue)
{
   ranap_SupportedRAB_ParameterBitrateList* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SupportedRAB_ParameterBitrateList*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SupportedRAB_ParameterBitrateList (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf 
   (const char* name, const ranap_Alt_RAB_Parameter_SupportedMaxBitrateInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Alt_RAB_Parameter_MaxBitrateType (
      "altSupportedMaxBitrateType", &pvalue->altSupportedMaxBitrateType);

   if (pvalue->m.altSupportedMaxBitratesPresent) {
      asn1Print_ranap_Alt_RAB_Parameter_SupportedMaxBitrates (
         "altSupportedMaxBitrates", &pvalue->altSupportedMaxBitrates);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SAI (const char* name, const ranap_SAI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_LAC ("lAC", &pvalue->lAC);

   asn1Print_ranap_SAC ("sAC", &pvalue->sAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GeographicalCoordinates 
   (const char* name, const ranap_GeographicalCoordinates* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates_latitudeSign ("latitudeSign", &
      pvalue->latitudeSign);

   rtxPrintIndent ();
   rtxPrintUnsigned ("latitude", pvalue->latitude);

   rtxPrintIndent ();
   rtxPrintInteger ("longitude", pvalue->longitude);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_Point (const char* name, const ranap_GA_Point* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_PointWithUnCertainty 
   (const char* name, const ranap_GA_PointWithUnCertainty* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintyCode", pvalue->uncertaintyCode);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_Polygon_element 
   (const char* name, const ranap_GA_Polygon_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_Polygon 
   (const char* name, const ranap_GA_Polygon* pvalue)
{
   ranap_GA_Polygon_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_GA_Polygon_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GA_Polygon_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_GA_UncertaintyEllipse 
   (const char* name, const ranap_GA_UncertaintyEllipse* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintySemi_major", pvalue->uncertaintySemi_major);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintySemi_minor", pvalue->uncertaintySemi_minor);

   rtxPrintIndent ();
   rtxPrintUnsigned ("orientationOfMajorAxis", pvalue->orientationOfMajorAxis);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_PointWithUnCertaintyEllipse 
   (const char* name, const ranap_GA_PointWithUnCertaintyEllipse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   asn1Print_ranap_GA_UncertaintyEllipse ("uncertaintyEllipse", &pvalue->
      uncertaintyEllipse);

   rtxPrintIndent ();
   rtxPrintUnsigned ("confidence", pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_AltitudeAndDirection 
   (const char* name, const ranap_GA_AltitudeAndDirection* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GA_AltitudeAndDirection_directionOfAltitude (
      "directionOfAltitude", &pvalue->directionOfAltitude);

   rtxPrintIndent ();
   rtxPrintUnsigned ("altitude", pvalue->altitude);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_PointWithAltitude 
   (const char* name, const ranap_GA_PointWithAltitude* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   asn1Print_ranap_GA_AltitudeAndDirection ("altitudeAndDirection", &pvalue->
      altitudeAndDirection);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid 
   (const char* name, const ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   asn1Print_ranap_GA_AltitudeAndDirection ("altitudeAndDirection", &pvalue->
      altitudeAndDirection);

   asn1Print_ranap_GA_UncertaintyEllipse ("uncertaintyEllipse", &pvalue->
      uncertaintyEllipse);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintyAltitude", pvalue->uncertaintyAltitude);

   rtxPrintIndent ();
   rtxPrintUnsigned ("confidence", pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GA_EllipsoidArc 
   (const char* name, const ranap_GA_EllipsoidArc* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_GeographicalCoordinates ("geographicalCoordinates", &pvalue
      ->geographicalCoordinates);

   rtxPrintIndent ();
   rtxPrintUnsigned ("innerRadius", pvalue->innerRadius);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintyRadius", pvalue->uncertaintyRadius);

   rtxPrintIndent ();
   rtxPrintUnsigned ("offsetAngle", pvalue->offsetAngle);

   rtxPrintIndent ();
   rtxPrintUnsigned ("includedAngle", pvalue->includedAngle);

   rtxPrintIndent ();
   rtxPrintUnsigned ("confidence", pvalue->confidence);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GeographicalArea 
   (const char* name, const ranap_GeographicalArea* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* point */
      case 1:
      {
         asn1Print_ranap_GA_Point ("point", pvalue->u.point);
         break;
      }
      /* pointWithUnCertainty */
      case 2:
      {
         asn1Print_ranap_GA_PointWithUnCertainty ("pointWithUnCertainty", 
            pvalue->u.pointWithUnCertainty);
         break;
      }
      /* polygon */
      case 3:
      {
         asn1Print_ranap_GA_Polygon ("polygon", pvalue->u.polygon);
         break;
      }
      /* pointWithUncertaintyEllipse */
      case 4:
      {
         asn1Print_ranap_GA_PointWithUnCertaintyEllipse (
            "pointWithUncertaintyEllipse", pvalue->
            u.pointWithUncertaintyEllipse);
         break;
      }
      /* pointWithAltitude */
      case 5:
      {
         asn1Print_ranap_GA_PointWithAltitude ("pointWithAltitude", pvalue->
            u.pointWithAltitude);
         break;
      }
      /* pointWithAltitudeAndUncertaintyEllipsoid */
      case 6:
      {
         asn1Print_ranap_GA_PointWithAltitudeAndUncertaintyEllipsoid (
            "pointWithAltitudeAndUncertaintyEllipsoid", pvalue->
            u.pointWithAltitudeAndUncertaintyEllipsoid);
         break;
      }
      /* ellipsoidArc */
      case 7:
      {
         asn1Print_ranap_GA_EllipsoidArc ("ellipsoidArc", pvalue->
            u.ellipsoidArc);
         break;
      }
      /* extElem1 */
      case 8:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_AreaIdentity 
   (const char* name, const ranap_AreaIdentity* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* sAI */
      case 1:
      {
         asn1Print_ranap_SAI ("sAI", pvalue->u.sAI);
         break;
      }
      /* geographicalArea */
      case 2:
      {
         asn1Print_ranap_GeographicalArea ("geographicalArea", pvalue->
            u.geographicalArea);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList 
   (const char* name, const ranap_Ass_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedGuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList 
   (const char* name, const ranap_Ass_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedMaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_AuthorisedSNAs 
   (const char* name, const ranap_AuthorisedSNAs* pvalue)
{
   ranap_SNAC* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SNAC*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SNAC (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_AuthorisedPLMNs_element 
   (const char* name, const ranap_AuthorisedPLMNs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   if (pvalue->m.authorisedSNAsListPresent) {
      asn1Print_ranap_AuthorisedSNAs ("authorisedSNAsList", &pvalue->
         authorisedSNAsList);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_AuthorisedPLMNs 
   (const char* name, const ranap_AuthorisedPLMNs* pvalue)
{
   ranap_AuthorisedPLMNs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_AuthorisedPLMNs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_AuthorisedPLMNs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_BroadcastAssistanceDataDecipheringKeys 
   (const char* name, const ranap_BroadcastAssistanceDataDecipheringKeys* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("cipheringKeyFlag", pvalue->cipheringKeyFlag.numbits, pvalue->cipheringKeyFlag.data);

   asn1Print_ranap_BroadcastAssistanceDataDecipheringKeys_currentDecipheringKey (
      "currentDecipheringKey", &pvalue->currentDecipheringKey);

   asn1Print_ranap_BroadcastAssistanceDataDecipheringKeys_nextDecipheringKey (
      "nextDecipheringKey", &pvalue->nextDecipheringKey);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CellIdList 
   (const char* name, const ranap_CellIdList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_Cell_Id (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_CellBased 
   (const char* name, const ranap_CellBased* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_CellIdList ("cellIdList", &pvalue->cellIdList);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CellLoadInformation 
   (const char* name, const ranap_CellLoadInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Cell_Capacity_Class_Value ("cell_Capacity_Class_Value", &
      pvalue->cell_Capacity_Class_Value);

   asn1Print_ranap_LoadValue ("loadValue", &pvalue->loadValue);

   if (pvalue->m.rTLoadValuePresent) {
      asn1Print_ranap_RTLoadValue ("rTLoadValue", &pvalue->rTLoadValue);
   }

   if (pvalue->m.nRTLoadInformationValuePresent) {
      asn1Print_ranap_NRTLoadInformationValue ("nRTLoadInformationValue", &
         pvalue->nRTLoadInformationValue);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceUTRANCellID 
   (const char* name, const ranap_SourceUTRANCellID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_TargetCellId ("uTRANcellID", &pvalue->uTRANcellID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CGI (const char* name, const ranap_CGI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_LAC ("lAC", &pvalue->lAC);

   asn1Print_ranap_CI ("cI", &pvalue->cI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceCellID 
   (const char* name, const ranap_SourceCellID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* sourceUTRANCellID */
      case 1:
      {
         asn1Print_ranap_SourceUTRANCellID ("sourceUTRANCellID", pvalue->
            u.sourceUTRANCellID);
         break;
      }
      /* sourceGERANCellID */
      case 2:
      {
         asn1Print_ranap_CGI ("sourceGERANCellID", pvalue->u.sourceGERANCellID
            );
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CellLoadInformationGroup 
   (const char* name, const ranap_CellLoadInformationGroup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_SourceCellID ("sourceCellID", &pvalue->sourceCellID);

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      asn1Print_ranap_CellLoadInformation ("uplinkCellLoadInformation", &pvalue
         ->uplinkCellLoadInformation);
   }

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      asn1Print_ranap_CellLoadInformation ("downlinkCellLoadInformation", &
         pvalue->downlinkCellLoadInformation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CriticalityDiagnostics_IE_List_element 
   (const char* name, const ranap_CriticalityDiagnostics_IE_List_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Criticality ("iECriticality", &pvalue->iECriticality);

   asn1Print_ranap_ProtocolIE_ID ("iE_ID", &pvalue->iE_ID);

   if (pvalue->m.repetitionNumberPresent) {
      asn1Print_ranap_RepetitionNumber0 ("repetitionNumber", &pvalue->
         repetitionNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CriticalityDiagnostics_IE_List 
   (const char* name, const ranap_CriticalityDiagnostics_IE_List* pvalue)
{
   ranap_CriticalityDiagnostics_IE_List_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_CriticalityDiagnostics_IE_List_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_CriticalityDiagnostics_IE_List_element (namebuf, pdata0
         );
      xx1++;
   }
}

void asn1Print_ranap_CriticalityDiagnostics 
   (const char* name, const ranap_CriticalityDiagnostics* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.procedureCodePresent) {
      asn1Print_ranap_ProcedureCode ("procedureCode", &pvalue->procedureCode);
   }

   if (pvalue->m.triggeringMessagePresent) {
      asn1Print_ranap_TriggeringMessage ("triggeringMessage", &pvalue->
         triggeringMessage);
   }

   if (pvalue->m.procedureCriticalityPresent) {
      asn1Print_ranap_Criticality ("procedureCriticality", &pvalue->
         procedureCriticality);
   }

   if (pvalue->m.iEsCriticalityDiagnosticsPresent) {
      asn1Print_ranap_CriticalityDiagnostics_IE_List (
         "iEsCriticalityDiagnostics", &pvalue->iEsCriticalityDiagnostics);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MessageStructure_element 
   (const char* name, const ranap_MessageStructure_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_ID ("iE_ID", &pvalue->iE_ID);

   if (pvalue->m.repetitionNumberPresent) {
      asn1Print_ranap_RepetitionNumber1 ("repetitionNumber", &pvalue->
         repetitionNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MessageStructure 
   (const char* name, const ranap_MessageStructure* pvalue)
{
   ranap_MessageStructure_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_MessageStructure_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MessageStructure_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_CSG_Id_List 
   (const char* name, const ranap_CSG_Id_List* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_CSG_Id (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_NewRAListofIdleModeUEs 
   (const char* name, const ranap_NewRAListofIdleModeUEs* pvalue)
{
   ranap_RAC* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RAC*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RAC (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAListwithNoIdleModeUEsAnyMore 
   (const char* name, const ranap_RAListwithNoIdleModeUEsAnyMore* pvalue)
{
   ranap_RAC* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RAC*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RAC (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_DeltaRAListofIdleModeUEs 
   (const char* name, const ranap_DeltaRAListofIdleModeUEs* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.newRAListofIdleModeUEsPresent) {
      asn1Print_ranap_NewRAListofIdleModeUEs ("newRAListofIdleModeUEs", &pvalue
         ->newRAListofIdleModeUEs);
   }

   if (pvalue->m.rAListwithNoIdleModeUEsAnyMorePresent) {
      asn1Print_ranap_RAListwithNoIdleModeUEsAnyMore (
         "rAListwithNoIdleModeUEsAnyMore", &pvalue->
         rAListwithNoIdleModeUEsAnyMore);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ENB_ID (const char* name, const ranap_ENB_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* macroENB-ID */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("macroENB-ID", pvalue->u.macroENB_ID->numbits, pvalue->u.macroENB_ID->data);
         break;
      }
      /* homeENB-ID */
      case 2:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("homeENB-ID", pvalue->u.homeENB_ID->numbits, pvalue->u.homeENB_ID->data);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PermittedEncryptionAlgorithms 
   (const char* name, const ranap_PermittedEncryptionAlgorithms* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_EncryptionAlgorithm (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_EncryptionInformation 
   (const char* name, const ranap_EncryptionInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PermittedEncryptionAlgorithms ("permittedAlgorithms", &
      pvalue->permittedAlgorithms);

   asn1Print_ranap_EncryptionKey ("key", &pvalue->key);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_IMEIList (const char* name, const ranap_IMEIList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_IMEI (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_IMEISVList 
   (const char* name, const ranap_IMEISVList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_IMEISV (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_IMEIGroup 
   (const char* name, const ranap_IMEIGroup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_IMEI ("iMEI", &pvalue->iMEI);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("iMEIMask", pvalue->iMEIMask.numbits, pvalue->iMEIMask.data);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_IMEISVGroup 
   (const char* name, const ranap_IMEISVGroup* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_IMEISV ("iMEISV", &pvalue->iMEISV);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("iMEISVMask", pvalue->iMEISVMask.numbits, pvalue->iMEISVMask.data);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EquipmentsToBeTraced 
   (const char* name, const ranap_EquipmentsToBeTraced* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* iMEIlist */
      case 1:
      {
         asn1Print_ranap_IMEIList ("iMEIlist", pvalue->u.iMEIlist);
         break;
      }
      /* iMEISVlist */
      case 2:
      {
         asn1Print_ranap_IMEISVList ("iMEISVlist", pvalue->u.iMEISVlist);
         break;
      }
      /* iMEIgroup */
      case 3:
      {
         asn1Print_ranap_IMEIGroup ("iMEIgroup", pvalue->u.iMEIgroup);
         break;
      }
      /* iMEISVgroup */
      case 4:
      {
         asn1Print_ranap_IMEISVGroup ("iMEISVgroup", pvalue->u.iMEISVgroup);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Event1F_Parameters 
   (const char* name, const ranap_Event1F_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_MeasurementQuantity ("measurementQuantity", &pvalue->
      measurementQuantity);

   rtxPrintIndent ();
   rtxPrintInteger ("threshold", pvalue->threshold);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Event1I_Parameters 
   (const char* name, const ranap_Event1I_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("threshold", pvalue->threshold);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GANSS_PositioningDataSet 
   (const char* name, const ranap_GANSS_PositioningDataSet* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_GANSS_PositioningMethodAndUsage (namebuf, &pvalue->elem
         [xx1]);
   }
}

void asn1Print_ranap_GERAN_Cell_ID 
   (const char* name, const ranap_GERAN_Cell_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LAI ("lAI", &pvalue->lAI);

   asn1Print_ranap_RAC ("rAC", &pvalue->rAC);

   asn1Print_ranap_CI ("cI", &pvalue->cI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GlobalCN_ID 
   (const char* name, const ranap_GlobalCN_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_CN_ID ("cN_ID", &pvalue->cN_ID);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GlobalRNC_ID 
   (const char* name, const ranap_GlobalRNC_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_RNC_ID ("rNC_ID", &pvalue->rNC_ID);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MDT_Report_Parameters 
   (const char* name, const ranap_MDT_Report_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ReportInterval ("reportInterval", &pvalue->reportInterval);

   asn1Print_ranap_ReportAmount ("reportAmount", &pvalue->reportAmount);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M1Report (const char* name, const ranap_M1Report* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* periodic */
      case 1:
      {
         asn1Print_ranap_MDT_Report_Parameters ("periodic", pvalue->u.periodic
            );
         break;
      }
      /* event1F */
      case 2:
      {
         asn1Print_ranap_Event1F_Parameters ("event1F", pvalue->u.event1F);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M2Report (const char* name, const ranap_M2Report* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* periodic */
      case 1:
      {
         asn1Print_ranap_MDT_Report_Parameters ("periodic", pvalue->u.periodic
            );
         break;
      }
      /* event1I */
      case 2:
      {
         asn1Print_ranap_Event1I_Parameters ("event1I", pvalue->u.event1I);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ImmediateMDT 
   (const char* name, const ranap_ImmediateMDT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_MeasurementsToActivate ("measurementsToActivate", &pvalue->
      measurementsToActivate);

   if (pvalue->m.m1reportPresent) {
      asn1Print_ranap_M1Report ("m1report", &pvalue->m1report);
   }

   if (pvalue->m.m2reportPresent) {
      asn1Print_ranap_M2Report ("m2report", &pvalue->m2report);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSIPMulticastAddressandAPNlist 
   (const char* name, const ranap_MBMSIPMulticastAddressandAPNlist* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TMGI ("tMGI", &pvalue->tMGI);

   asn1Print_ranap_IPMulticastAddress ("iPMulticastAddress", &pvalue->
      iPMulticastAddress);

   asn1Print_ranap_APN ("aPN", &pvalue->aPN);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RequestedMBMSIPMulticastAddressandAPNRequest 
   (const char* name, const ranap_RequestedMBMSIPMulticastAddressandAPNRequest* pvalue)
{
   ranap_MBMSIPMulticastAddressandAPNlist* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_MBMSIPMulticastAddressandAPNlist*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_MBMSIPMulticastAddressandAPNlist (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RequestedMulticastServiceList 
   (const char* name, const ranap_RequestedMulticastServiceList* pvalue)
{
   ranap_TMGI* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_TMGI*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_TMGI (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_InformationRequested 
   (const char* name, const ranap_InformationRequested* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* requestedMBMSIPMulticastAddressandAPNRequest */
      case 1:
      {
         asn1Print_ranap_RequestedMBMSIPMulticastAddressandAPNRequest (
            "requestedMBMSIPMulticastAddressandAPNRequest", pvalue->
            u.requestedMBMSIPMulticastAddressandAPNRequest);
         break;
      }
      /* requestedMulticastServiceList */
      case 2:
      {
         asn1Print_ranap_RequestedMulticastServiceList (
            "requestedMulticastServiceList", pvalue->
            u.requestedMulticastServiceList);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSIPMulticastAddressandAPNRequest 
   (const char* name, const ranap_MBMSIPMulticastAddressandAPNRequest* pvalue)
{
   ranap_TMGI* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_TMGI*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_TMGI (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_PermanentNAS_UE_ID 
   (const char* name, const ranap_PermanentNAS_UE_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* iMSI */
      case 1:
      {
         asn1Print_ranap_IMSI ("iMSI", pvalue->u.iMSI);
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InformationRequestType 
   (const char* name, const ranap_InformationRequestType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* mBMSIPMulticastAddressandAPNRequest */
      case 1:
      {
         asn1Print_ranap_MBMSIPMulticastAddressandAPNRequest (
            "mBMSIPMulticastAddressandAPNRequest", pvalue->
            u.mBMSIPMulticastAddressandAPNRequest);
         break;
      }
      /* permanentNAS-UE-ID */
      case 2:
      {
         asn1Print_ranap_PermanentNAS_UE_ID ("permanentNAS-UE-ID", pvalue->
            u.permanentNAS_UE_ID);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RNCTraceInformation 
   (const char* name, const ranap_RNCTraceInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TraceReference ("traceReference", &pvalue->traceReference);

   asn1Print_ranap_RNCTraceInformation_traceActivationIndicator (
      "traceActivationIndicator", &pvalue->traceActivationIndicator);

   if (pvalue->m.equipmentsToBeTracedPresent) {
      asn1Print_ranap_EquipmentsToBeTraced ("equipmentsToBeTraced", &pvalue->
         equipmentsToBeTraced);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InformationTransferType 
   (const char* name, const ranap_InformationTransferType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rNCTraceInformation */
      case 1:
      {
         asn1Print_ranap_RNCTraceInformation ("rNCTraceInformation", pvalue->
            u.rNCTraceInformation);
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PermittedIntegrityProtectionAlgorithms 
   (const char* name, const ranap_PermittedIntegrityProtectionAlgorithms* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_IntegrityProtectionAlgorithm (namebuf, &pvalue->elem[xx1]
         );
   }
}

void asn1Print_ranap_IntegrityProtectionInformation 
   (const char* name, const ranap_IntegrityProtectionInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PermittedIntegrityProtectionAlgorithms (
      "permittedAlgorithms", &pvalue->permittedAlgorithms);

   asn1Print_ranap_IntegrityProtectionKey ("key", &pvalue->key);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TargetRNC_ID 
   (const char* name, const ranap_TargetRNC_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LAI ("lAI", &pvalue->lAI);

   if (pvalue->m.rACPresent) {
      asn1Print_ranap_RAC ("rAC", &pvalue->rAC);
   }

   asn1Print_ranap_RNC_ID ("rNC_ID", &pvalue->rNC_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TAI (const char* name, const ranap_TAI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_TAC ("tAC", &pvalue->tAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TargetENB_ID 
   (const char* name, const ranap_TargetENB_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_ENB_ID ("eNB_ID", &pvalue->eNB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   asn1Print_ranap_TAI ("selectedTAI", &pvalue->selectedTAI);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RIMRoutingAddress 
   (const char* name, const ranap_RIMRoutingAddress* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* targetRNC-ID */
      case 1:
      {
         asn1Print_ranap_TargetRNC_ID ("targetRNC-ID", pvalue->u.targetRNC_ID
            );
         break;
      }
      /* gERAN-Cell-ID */
      case 2:
      {
         asn1Print_ranap_GERAN_Cell_ID ("gERAN-Cell-ID", pvalue->
            u.gERAN_Cell_ID);
         break;
      }
      /* targeteNB-ID */
      case 3:
      {
         asn1Print_ranap_TargetENB_ID ("targeteNB-ID", pvalue->u.targeteNB_ID
            );
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RIM_Transfer 
   (const char* name, const ranap_RIM_Transfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RIMInformation ("rIMInformation", &pvalue->rIMInformation);

   if (pvalue->m.rIMRoutingAddressPresent) {
      asn1Print_ranap_RIMRoutingAddress ("rIMRoutingAddress", &pvalue->
         rIMRoutingAddress);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InterSystemInformationTransferType 
   (const char* name, const ranap_InterSystemInformationTransferType* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* rIM-Transfer */
      case 1:
      {
         asn1Print_ranap_RIM_Transfer ("rIM-Transfer", pvalue->u.rIM_Transfer
            );
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InterSystemInformation_TransparentContainer 
   (const char* name, const ranap_InterSystemInformation_TransparentContainer* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.downlinkCellLoadInformationPresent) {
      asn1Print_ranap_CellLoadInformation ("downlinkCellLoadInformation", &
         pvalue->downlinkCellLoadInformation);
   }

   if (pvalue->m.uplinkCellLoadInformationPresent) {
      asn1Print_ranap_CellLoadInformation ("uplinkCellLoadInformation", &pvalue
         ->uplinkCellLoadInformation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ListOF_SNAs 
   (const char* name, const ranap_ListOF_SNAs* pvalue)
{
   ranap_SNAC* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SNAC*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SNAC (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_LA_LIST_element 
   (const char* name, const ranap_LA_LIST_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LAC ("lAC", &pvalue->lAC);

   asn1Print_ranap_ListOF_SNAs ("listOF_SNAs", &pvalue->listOF_SNAs);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LA_LIST (const char* name, const ranap_LA_LIST* pvalue)
{
   ranap_LA_LIST_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_LA_LIST_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_LA_LIST_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_LastKnownServiceArea 
   (const char* name, const ranap_LastKnownServiceArea* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_SAI ("sAI", &pvalue->sAI);

   rtxPrintIndent ();
   rtxPrintUnsigned ("ageOfSAI", pvalue->ageOfSAI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UTRAN_CellID 
   (const char* name, const ranap_UTRAN_CellID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_TargetCellId ("cellID", &pvalue->cellID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LastVisitedUTRANCell_Item 
   (const char* name, const ranap_LastVisitedUTRANCell_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_UTRAN_CellID ("uTRAN_CellID", &pvalue->uTRAN_CellID);

   asn1Print_ranap_CellType ("cellType", &pvalue->cellType);

   asn1Print_ranap_Time_UE_StayedInCell ("time_UE_StayedInCell", &pvalue->
      time_UE_StayedInCell);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InterfacesToTraceItem 
   (const char* name, const ranap_InterfacesToTraceItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_InterfacesToTraceItem_interface_ ("interface_", &pvalue->
      interface_);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ListOfInterfacesToTrace 
   (const char* name, const ranap_ListOfInterfacesToTrace* pvalue)
{
   ranap_InterfacesToTraceItem* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_InterfacesToTraceItem*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_InterfacesToTraceItem (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_LocationRelatedDataRequestType 
   (const char* name, const ranap_LocationRelatedDataRequestType* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RequestedLocationRelatedDataType (
      "requestedLocationRelatedDataType", &pvalue->
      requestedLocationRelatedDataType);

   if (pvalue->m.requestedGPSAssistanceDataPresent) {
      asn1Print_ranap_RequestedGPSAssistanceData (
         "requestedGPSAssistanceData", &pvalue->requestedGPSAssistanceData);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PeriodicLocationInfo 
   (const char* name, const ranap_PeriodicLocationInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("reportingAmount", pvalue->reportingAmount);

   rtxPrintIndent ();
   rtxPrintUnsigned ("reportingInterval", pvalue->reportingInterval);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationReportingTransferInformation 
   (const char* name, const ranap_LocationReportingTransferInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.reportChangeOfSAIPresent) {
      asn1Print_ranap_ReportChangeOfSAI ("reportChangeOfSAI", &pvalue->
         reportChangeOfSAI);
   }

   if (pvalue->m.periodicReportingIndicatorPresent) {
      asn1Print_ranap_PeriodicReportingIndicator (
         "periodicReportingIndicator", &pvalue->periodicReportingIndicator);
   }

   if (pvalue->m.directReportingIndicatorPresent) {
      asn1Print_ranap_DirectReportingIndicator ("directReportingIndicator", &
         pvalue->directReportingIndicator);
   }

   if (pvalue->m.verticalAccuracyCodePresent) {
      asn1Print_ranap_VerticalAccuracyCode ("verticalAccuracyCode", &pvalue->
         verticalAccuracyCode);
   }

   if (pvalue->m.positioningPriorityChangeSAIPresent) {
      asn1Print_ranap_PositioningPriority ("positioningPriorityChangeSAI", &
         pvalue->positioningPriorityChangeSAI);
   }

   if (pvalue->m.positioningPriorityDirectPresent) {
      asn1Print_ranap_PositioningPriority ("positioningPriorityDirect", &pvalue
         ->positioningPriorityDirect);
   }

   if (pvalue->m.clientTypePeriodicPresent) {
      asn1Print_ranap_ClientType ("clientTypePeriodic", &pvalue->
         clientTypePeriodic);
   }

   if (pvalue->m.clientTypeDirectPresent) {
      asn1Print_ranap_ClientType ("clientTypeDirect", &pvalue->clientTypeDirect
         );
   }

   if (pvalue->m.responseTimePresent) {
      asn1Print_ranap_ResponseTime ("responseTime", &pvalue->responseTime);
   }

   if (pvalue->m.includeVelocityPresent) {
      asn1Print_ranap_IncludeVelocity ("includeVelocity", &pvalue->
         includeVelocity);
   }

   if (pvalue->m.periodicLocationInfoPresent) {
      asn1Print_ranap_PeriodicLocationInfo ("periodicLocationInfo", &pvalue->
         periodicLocationInfo);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M4_Collection_Parameters 
   (const char* name, const ranap_M4_Collection_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_M4_Period ("m4_period", &pvalue->m4_period);

   if (pvalue->m.m4_thresholdPresent) {
      asn1Print_ranap_M4_Threshold ("m4_threshold", &pvalue->m4_threshold);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M4Report (const char* name, const ranap_M4Report* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* all */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("all");
         break;
      }
      /* m4-collection-parameters */
      case 2:
      {
         asn1Print_ranap_M4_Collection_Parameters ("m4-collection-parameters", 
            pvalue->u.m4_collection_parameters);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M5Report (const char* name, const ranap_M5Report* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* when-available */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("when-available");
         break;
      }
      /* m5-period */
      case 2:
      {
         asn1Print_ranap_M5_Period ("m5-period", &pvalue->u.m5_period);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M6Report (const char* name, const ranap_M6Report* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_M6_Period ("m6_period", &pvalue->m6_period);

   asn1Print_ranap_Links_to_log ("m6_links_to_log", &pvalue->m6_links_to_log);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_M7Report (const char* name, const ranap_M7Report* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_M7_Period ("m7_period", &pvalue->m7_period);

   asn1Print_ranap_Links_to_log ("m7_links_to_log", &pvalue->m7_links_to_log);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LAI_List (const char* name, const ranap_LAI_List* pvalue)
{
   ranap_LAI* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_LAI*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_LAI (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_LABased (const char* name, const ranap_LABased* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LAI_List ("laiList", &pvalue->laiList);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAI (const char* name, const ranap_RAI* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LAI ("lAI", &pvalue->lAI);

   asn1Print_ranap_RAC ("rAC", &pvalue->rAC);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAI_List (const char* name, const ranap_RAI_List* pvalue)
{
   ranap_RAI* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RAI*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RAI (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RABased (const char* name, const ranap_RABased* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAI_List ("raiList", &pvalue->raiList);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MDTAreaScope 
   (const char* name, const ranap_MDTAreaScope* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* cellbased */
      case 1:
      {
         asn1Print_ranap_CellBased ("cellbased", pvalue->u.cellbased);
         break;
      }
      /* labased */
      case 2:
      {
         asn1Print_ranap_LABased ("labased", pvalue->u.labased);
         break;
      }
      /* rabased */
      case 3:
      {
         asn1Print_ranap_RABased ("rabased", pvalue->u.rabased);
         break;
      }
      /* plmn-area-based */
      case 4:
      {
         rtxPrintIndent();
         rtxPrintNull ("plmn-area-based");
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LoggedMDT 
   (const char* name, const ranap_LoggedMDT* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_LoggingInterval ("loggingInterval", &pvalue->loggingInterval
      );

   asn1Print_ranap_LoggingDuration ("loggingDuration", &pvalue->loggingDuration
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MDTMode (const char* name, const ranap_MDTMode* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* immediateMDT */
      case 1:
      {
         asn1Print_ranap_ImmediateMDT ("immediateMDT", pvalue->u.immediateMDT
            );
         break;
      }
      /* loggedMDT */
      case 2:
      {
         asn1Print_ranap_LoggedMDT ("loggedMDT", pvalue->u.loggedMDT);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MDT_Configuration 
   (const char* name, const ranap_MDT_Configuration* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_MDT_Activation ("mdtActivation", &pvalue->mdtActivation);

   asn1Print_ranap_MDTAreaScope ("mdtAreaScope", &pvalue->mdtAreaScope);

   asn1Print_ranap_MDTMode ("mdtMode", &pvalue->mdtMode);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MDT_PLMN_List 
   (const char* name, const ranap_MDT_PLMN_List* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PLMNidentity (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Offload_RAB_Parameters 
   (const char* name, const ranap_Offload_RAB_Parameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Offload_RAB_Parameters_APN ("accessPointName", &pvalue->
      accessPointName);

   asn1Print_ranap_Offload_RAB_Parameters_ChargingCharacteristics (
      "chargingCharacteristics", &pvalue->chargingCharacteristics);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PagingAreaID 
   (const char* name, const ranap_PagingAreaID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* lAI */
      case 1:
      {
         asn1Print_ranap_LAI ("lAI", pvalue->u.lAI);
         break;
      }
      /* rAI */
      case 2:
      {
         asn1Print_ranap_RAI ("rAI", pvalue->u.rAI);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PDP_TypeInformation_extension 
   (const char* name, const ranap_PDP_TypeInformation_extension* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PDP_Type_extension (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_PLMNs_in_shared_network_element 
   (const char* name, const ranap_PLMNs_in_shared_network_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_LA_LIST ("lA_LIST", &pvalue->lA_LIST);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PLMNs_in_shared_network 
   (const char* name, const ranap_PLMNs_in_shared_network* pvalue)
{
   ranap_PLMNs_in_shared_network_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_PLMNs_in_shared_network_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PLMNs_in_shared_network_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_PositioningDataSet 
   (const char* name, const ranap_PositioningDataSet* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_PositioningMethodAndUsage (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_PositionData 
   (const char* name, const ranap_PositionData* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PositioningDataDiscriminator (
      "positioningDataDiscriminator", &pvalue->positioningDataDiscriminator);

   if (pvalue->m.positioningDataSetPresent) {
      asn1Print_ranap_PositioningDataSet ("positioningDataSet", &pvalue->
         positioningDataSet);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Shared_Network_Information 
   (const char* name, const ranap_Shared_Network_Information* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNs_in_shared_network ("pLMNs_in_shared_network", &pvalue
      ->pLMNs_in_shared_network);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ProvidedData 
   (const char* name, const ranap_ProvidedData* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* shared-network-information */
      case 1:
      {
         asn1Print_ranap_Shared_Network_Information (
            "shared-network-information", pvalue->u.shared_network_information
            );
         break;
      }
      /* extElem1 */
      case 2:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABDataVolumeReport_element 
   (const char* name, const ranap_RABDataVolumeReport_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_UnsuccessfullyTransmittedDataVolume (
      "dl_UnsuccessfullyTransmittedDataVolume", &pvalue->
      dl_UnsuccessfullyTransmittedDataVolume);

   if (pvalue->m.dataVolumeReferencePresent) {
      asn1Print_ranap_DataVolumeReference ("dataVolumeReference", &pvalue->
         dataVolumeReference);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABDataVolumeReport 
   (const char* name, const ranap_RABDataVolumeReport* pvalue)
{
   ranap_RABDataVolumeReport_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RABDataVolumeReport_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RABDataVolumeReport_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAB_Parameter_ExtendedGuaranteedBitrateList 
   (const char* name, const ranap_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedGuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_RAB_Parameter_ExtendedMaxBitrateList 
   (const char* name, const ranap_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedMaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_UPInformation 
   (const char* name, const ranap_UPInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_FrameSequenceNumber ("frameSeqNoUL", &pvalue->frameSeqNoUL
      );

   asn1Print_ranap_FrameSequenceNumber ("frameSeqNoDL", &pvalue->frameSeqNoDL
      );

   asn1Print_ranap_PDUType14FrameSequenceNumber ("pdu14FrameSeqNoUL", &pvalue->
      pdu14FrameSeqNoUL);

   asn1Print_ranap_PDUType14FrameSequenceNumber ("pdu14FrameSeqNoDL", &pvalue->
      pdu14FrameSeqNoDL);

   asn1Print_ranap_DataPDUType ("dataPDUType", &pvalue->dataPDUType);

   asn1Print_ranap_UPInitialisationFrame ("upinitialisationFrame", &pvalue->
      upinitialisationFrame);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABParametersList_element 
   (const char* name, const ranap_RABParametersList_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rab_Id", &pvalue->rab_Id);

   asn1Print_ranap_CN_DomainIndicator ("cn_domain", &pvalue->cn_domain);

   if (pvalue->m.rabDataVolumeReportPresent) {
      asn1Print_ranap_RABDataVolumeReport ("rabDataVolumeReport", &pvalue->
         rabDataVolumeReport);
   }

   if (pvalue->m.upInformationPresent) {
      asn1Print_ranap_UPInformation ("upInformation", &pvalue->upInformation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABParametersList 
   (const char* name, const ranap_RABParametersList* pvalue)
{
   ranap_RABParametersList_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RABParametersList_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RABParametersList_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_TrCH_ID (const char* name, const ranap_TrCH_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.dCH_IDPresent) {
      asn1Print_ranap_DCH_ID ("dCH_ID", &pvalue->dCH_ID);
   }

   if (pvalue->m.dSCH_IDPresent) {
      asn1Print_ranap_DSCH_ID ("dSCH_ID", &pvalue->dSCH_ID);
   }

   if (pvalue->m.uSCH_IDPresent) {
      asn1Print_ranap_USCH_ID ("uSCH_ID", &pvalue->uSCH_ID);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TrCH_ID_List 
   (const char* name, const ranap_TrCH_ID_List* pvalue)
{
   ranap_TrCH_ID* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_TrCH_ID*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_TrCH_ID (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAB_TrCH_MappingItem 
   (const char* name, const ranap_RAB_TrCH_MappingItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_TrCH_ID_List ("trCH_ID_List", &pvalue->trCH_ID_List);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_TrCH_Mapping 
   (const char* name, const ranap_RAB_TrCH_Mapping* pvalue)
{
   ranap_RAB_TrCH_MappingItem* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RAB_TrCH_MappingItem*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RAB_TrCH_MappingItem (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAofIdleModeUEs 
   (const char* name, const ranap_RAofIdleModeUEs* pvalue)
{
   ranap_RAC* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_RAC*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_RAC (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_NotEmptyRAListofIdleModeUEs 
   (const char* name, const ranap_NotEmptyRAListofIdleModeUEs* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAofIdleModeUEs ("rAofIdleModeUEs", &pvalue->rAofIdleModeUEs
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAListofIdleModeUEs 
   (const char* name, const ranap_RAListofIdleModeUEs* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* notEmptyRAListofIdleModeUEs */
      case 1:
      {
         asn1Print_ranap_NotEmptyRAListofIdleModeUEs (
            "notEmptyRAListofIdleModeUEs", pvalue->
            u.notEmptyRAListofIdleModeUEs);
         break;
      }
      /* emptyFullRAListofIdleModeUEs */
      case 2:
      {
         asn1Print_ranap_RAListofIdleModeUEs_emptyFullRAListofIdleModeUEs (
            "emptyFullRAListofIdleModeUEs", &pvalue->
            u.emptyFullRAListofIdleModeUEs);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LAListofIdleModeUEs 
   (const char* name, const ranap_LAListofIdleModeUEs* pvalue)
{
   ranap_LAI* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_LAI*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_LAI (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList 
   (const char* name, const ranap_Requested_RAB_Parameter_ExtendedMaxBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedMaxBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList 
   (const char* name, const ranap_Requested_RAB_Parameter_ExtendedGuaranteedBitrateList* pvalue)
{
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (; xx1 < pvalue->n; xx1++) {
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ExtendedGuaranteedBitrate (namebuf, &pvalue->elem[xx1]);
   }
}

void asn1Print_ranap_RequestType 
   (const char* name, const ranap_RequestType* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_Event ("event", &pvalue->event);

   asn1Print_ranap_ReportArea ("reportArea", &pvalue->reportArea);

   if (pvalue->m.accuracyCodePresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("accuracyCode", pvalue->accuracyCode);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UE_ID (const char* name, const ranap_UE_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* imsi */
      case 1:
      {
         asn1Print_ranap_IMSI ("imsi", pvalue->u.imsi);
         break;
      }
      /* imei */
      case 2:
      {
         asn1Print_ranap_IMEI ("imei", pvalue->u.imei);
         break;
      }
      /* imeisv */
      case 3:
      {
         asn1Print_ranap_IMEISV ("imeisv", pvalue->u.imeisv);
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TracePropagationParameters 
   (const char* name, const ranap_TracePropagationParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TraceRecordingSessionReference (
      "traceRecordingSessionReference", &pvalue->traceRecordingSessionReference
      );

   asn1Print_ranap_TraceDepth ("traceDepth", &pvalue->traceDepth);

   if (pvalue->m.listOfInterfacesToTracePresent) {
      asn1Print_ranap_ListOfInterfacesToTrace ("listOfInterfacesToTrace", &
         pvalue->listOfInterfacesToTrace);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TraceInformation 
   (const char* name, const ranap_TraceInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TraceReference ("traceReference", &pvalue->traceReference);

   asn1Print_ranap_UE_ID ("ue_identity", &pvalue->ue_identity);

   if (pvalue->m.tracePropagationParametersPresent) {
      asn1Print_ranap_TracePropagationParameters (
         "tracePropagationParameters", &pvalue->tracePropagationParameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RNSAPRelocationParameters 
   (const char* name, const ranap_RNSAPRelocationParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rabParmetersListPresent) {
      asn1Print_ranap_RABParametersList ("rabParmetersList", &pvalue->
         rabParmetersList);
   }

   if (pvalue->m.locationReportingPresent) {
      asn1Print_ranap_LocationReportingTransferInformation (
         "locationReporting", &pvalue->locationReporting);
   }

   if (pvalue->m.traceInformationPresent) {
      asn1Print_ranap_TraceInformation ("traceInformation", &pvalue->
         traceInformation);
   }

   if (pvalue->m.sourceSAIPresent) {
      asn1Print_ranap_SAI ("sourceSAI", &pvalue->sourceSAI);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RSRVCC_Information 
   (const char* name, const ranap_RSRVCC_Information* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RSRVCC_Information_nonce ("nonce", &pvalue->nonce);

   asn1Print_ranap_RSRVCC_Information_iMSInformation ("iMSInformation", &pvalue
      ->iMSInformation);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SGSN_Group_Identity 
   (const char* name, const ranap_SGSN_Group_Identity* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* null-NRI */
      case 1:
      {
         asn1Print_ranap_Null_NRI ("null-NRI", pvalue->u.null_NRI);
         break;
      }
      /* sGSN-Group-ID */
      case 2:
      {
         asn1Print_ranap_SGSN_Group_ID ("sGSN-Group-ID", pvalue->
            u.sGSN_Group_ID);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SNA_Access_Information 
   (const char* name, const ranap_SNA_Access_Information* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_AuthorisedPLMNs ("authorisedPLMNs", &pvalue->authorisedPLMNs
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceRNC_ID 
   (const char* name, const ranap_SourceRNC_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   asn1Print_ranap_RNC_ID ("rNC_ID", &pvalue->rNC_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceID (const char* name, const ranap_SourceID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* sourceRNC-ID */
      case 1:
      {
         asn1Print_ranap_SourceRNC_ID ("sourceRNC-ID", pvalue->u.sourceRNC_ID
            );
         break;
      }
      /* sAI */
      case 2:
      {
         asn1Print_ranap_SAI ("sAI", pvalue->u.sAI);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SourceRNC_ToTargetRNC_TransparentContainer 
   (const char* name, const ranap_SourceRNC_ToTargetRNC_TransparentContainer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RRC_Container ("rRC_Container", &pvalue->rRC_Container);

   asn1Print_ranap_NumberOfIuInstances ("numberOfIuInstances", &pvalue->
      numberOfIuInstances);

   asn1Print_ranap_RelocationType ("relocationType", &pvalue->relocationType);

   if (pvalue->m.chosenIntegrityProtectionAlgorithmPresent) {
      asn1Print_ranap_ChosenIntegrityProtectionAlgorithm (
         "chosenIntegrityProtectionAlgorithm", &pvalue->
         chosenIntegrityProtectionAlgorithm);
   }

   if (pvalue->m.integrityProtectionKeyPresent) {
      asn1Print_ranap_IntegrityProtectionKey ("integrityProtectionKey", &pvalue
         ->integrityProtectionKey);
   }

   if (pvalue->m.chosenEncryptionAlgorithForSignallingPresent) {
      asn1Print_ranap_ChosenEncryptionAlgorithm (
         "chosenEncryptionAlgorithForSignalling", &pvalue->
         chosenEncryptionAlgorithForSignalling);
   }

   if (pvalue->m.cipheringKeyPresent) {
      asn1Print_ranap_EncryptionKey ("cipheringKey", &pvalue->cipheringKey);
   }

   if (pvalue->m.chosenEncryptionAlgorithForCSPresent) {
      asn1Print_ranap_ChosenEncryptionAlgorithm (
         "chosenEncryptionAlgorithForCS", &pvalue->
         chosenEncryptionAlgorithForCS);
   }

   if (pvalue->m.chosenEncryptionAlgorithForPSPresent) {
      asn1Print_ranap_ChosenEncryptionAlgorithm (
         "chosenEncryptionAlgorithForPS", &pvalue->
         chosenEncryptionAlgorithForPS);
   }

   if (pvalue->m.d_RNTIPresent) {
      asn1Print_ranap_D_RNTI ("d_RNTI", &pvalue->d_RNTI);
   }

   if (pvalue->m.targetCellIdPresent) {
      asn1Print_ranap_TargetCellId ("targetCellId", &pvalue->targetCellId);
   }

   if (pvalue->m.rAB_TrCH_MappingPresent) {
      asn1Print_ranap_RAB_TrCH_Mapping ("rAB_TrCH_Mapping", &pvalue->
         rAB_TrCH_Mapping);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EUTRANFrequencies_element 
   (const char* name, const ranap_EUTRANFrequencies_element* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("earfcn", pvalue->earfcn);

   if (pvalue->m.measBandPresent) {
      asn1Print_ranap_MeasBand ("measBand", &pvalue->measBand);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EUTRANFrequencies 
   (const char* name, const ranap_EUTRANFrequencies* pvalue)
{
   ranap_EUTRANFrequencies_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_EUTRANFrequencies_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_EUTRANFrequencies_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_IRATmeasurementParameters 
   (const char* name, const ranap_IRATmeasurementParameters* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("measurementDuration", pvalue->measurementDuration);

   if (pvalue->m.eUTRANFrequenciesPresent) {
      asn1Print_ranap_EUTRANFrequencies ("eUTRANFrequencies", &pvalue->
         eUTRANFrequencies);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_IRAT_Measurement_Configuration 
   (const char* name, const ranap_IRAT_Measurement_Configuration* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.rSRPPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("rSRP", pvalue->rSRP);
   }

   if (pvalue->m.rSRQPresent) {
      rtxPrintIndent ();
      rtxPrintUnsigned ("rSRQ", pvalue->rSRQ);
   }

   asn1Print_ranap_IRATmeasurementParameters ("iRATmeasurementParameters", &
      pvalue->iRATmeasurementParameters);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RSRQ_Type 
   (const char* name, const ranap_RSRQ_Type* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintBoolean ("allSymbols", pvalue->allSymbols);

   rtxPrintIndent ();
   rtxPrintBoolean ("wideBand", pvalue->wideBand);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRB_TrCH_MappingItem 
   (const char* name, const ranap_SRB_TrCH_MappingItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_SRB_ID ("sRB_ID", &pvalue->sRB_ID);

   asn1Print_ranap_TrCH_ID ("trCH_ID", &pvalue->trCH_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRB_TrCH_Mapping 
   (const char* name, const ranap_SRB_TrCH_Mapping* pvalue)
{
   ranap_SRB_TrCH_MappingItem* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_SRB_TrCH_MappingItem*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_SRB_TrCH_MappingItem (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_SRVCC_Information 
   (const char* name, const ranap_SRVCC_Information* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_SRVCC_Information_nonce ("nonce", &pvalue->nonce);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TargetID (const char* name, const ranap_TargetID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* targetRNC-ID */
      case 1:
      {
         asn1Print_ranap_TargetRNC_ID ("targetRNC-ID", pvalue->u.targetRNC_ID
            );
         break;
      }
      /* cGI */
      case 2:
      {
         asn1Print_ranap_CGI ("cGI", pvalue->u.cGI);
         break;
      }
      /* targeteNB-ID */
      case 3:
      {
         asn1Print_ranap_TargetENB_ID ("targeteNB-ID", pvalue->u.targeteNB_ID
            );
         break;
      }
      /* extElem1 */
      case 4:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TargetRNC_ToSourceRNC_TransparentContainer 
   (const char* name, const ranap_TargetRNC_ToSourceRNC_TransparentContainer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RRC_Container ("rRC_Container", &pvalue->rRC_Container);

   if (pvalue->m.d_RNTIPresent) {
      asn1Print_ranap_D_RNTI ("d_RNTI", &pvalue->d_RNTI);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TemporaryUE_ID 
   (const char* name, const ranap_TemporaryUE_ID* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* tMSI */
      case 1:
      {
         asn1Print_ranap_TMSI ("tMSI", pvalue->u.tMSI);
         break;
      }
      /* p-TMSI */
      case 2:
      {
         asn1Print_ranap_P_TMSI ("p-TMSI", pvalue->u.p_TMSI);
         break;
      }
      /* extElem1 */
      case 3:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TraceRecordingSessionInformation 
   (const char* name, const ranap_TraceRecordingSessionInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TraceReference ("traceReference", &pvalue->traceReference);

   asn1Print_ranap_TraceRecordingSessionReference (
      "traceRecordingSessionReference", &pvalue->traceRecordingSessionReference
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TunnelInformation 
   (const char* name, const ranap_TunnelInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
      transportLayerAddress);

   if (pvalue->m.uDP_Port_NumberPresent) {
      asn1Print_ranap_Port_Number ("uDP_Port_Number", &pvalue->uDP_Port_Number
         );
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UE_AggregateMaximumBitRate 
   (const char* name, const ranap_UE_AggregateMaximumBitRate* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.uE_AggregateMaximumBitRateDownlinkPresent) {
      asn1Print_ranap_UE_AggregateMaximumBitRateDownlink (
         "uE_AggregateMaximumBitRateDownlink", &pvalue->
         uE_AggregateMaximumBitRateDownlink);
   }

   if (pvalue->m.uE_AggregateMaximumBitRateUplinkPresent) {
      asn1Print_ranap_UE_AggregateMaximumBitRateUplink (
         "uE_AggregateMaximumBitRateUplink", &pvalue->
         uE_AggregateMaximumBitRateUplink);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UE_IsNotServed 
   (const char* name, const ranap_UE_IsNotServed* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PermanentNAS_UE_ID ("permanentNAS_UE_ID", &pvalue->
      permanentNAS_UE_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UE_IsServed 
   (const char* name, const ranap_UE_IsServed* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PermanentNAS_UE_ID ("permanentNAS_UE_ID", &pvalue->
      permanentNAS_UE_ID);

   asn1Print_ranap_PLMNidentity ("pLMNidentity", &pvalue->pLMNidentity);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UERegistrationQueryResult 
   (const char* name, const ranap_UERegistrationQueryResult* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* uE-IsServed */
      case 1:
      {
         asn1Print_ranap_UE_IsServed ("uE-IsServed", pvalue->u.uE_IsServed);
         break;
      }
      /* uE-IsNotServed */
      case 2:
      {
         asn1Print_ranap_UE_IsNotServed ("uE-IsNotServed", pvalue->
            u.uE_IsNotServed);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UESBI_Iu (const char* name, const ranap_UESBI_Iu* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.uESBI_IuAPresent) {
      asn1Print_ranap_UESBI_IuA ("uESBI_IuA", &pvalue->uESBI_IuA);
   }

   if (pvalue->m.uESBI_IuBPresent) {
      asn1Print_ranap_UESBI_IuB ("uESBI_IuB", &pvalue->uESBI_IuB);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_HorizontalSpeedAndBearing 
   (const char* name, const ranap_HorizontalSpeedAndBearing* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("bearing", pvalue->bearing);

   rtxPrintIndent ();
   rtxPrintUnsigned ("horizontalSpeed", pvalue->horizontalSpeed);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_HorizontalVelocity 
   (const char* name, const ranap_HorizontalVelocity* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_HorizontalSpeedAndBearing ("horizontalSpeedAndBearing", &
      pvalue->horizontalSpeedAndBearing);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_VerticalVelocity 
   (const char* name, const ranap_VerticalVelocity* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintUnsigned ("veritcalSpeed", pvalue->veritcalSpeed);

   asn1Print_ranap_VerticalSpeedDirection ("veritcalSpeedDirection", &pvalue->
      veritcalSpeedDirection);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_HorizontalWithVerticalVelocity 
   (const char* name, const ranap_HorizontalWithVerticalVelocity* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_HorizontalSpeedAndBearing ("horizontalSpeedAndBearing", &
      pvalue->horizontalSpeedAndBearing);

   asn1Print_ranap_VerticalVelocity ("veritcalVelocity", &pvalue->
      veritcalVelocity);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_HorizontalVelocityWithUncertainty 
   (const char* name, const ranap_HorizontalVelocityWithUncertainty* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_HorizontalSpeedAndBearing ("horizontalSpeedAndBearing", &
      pvalue->horizontalSpeedAndBearing);

   rtxPrintIndent ();
   rtxPrintUnsigned ("uncertaintySpeed", pvalue->uncertaintySpeed);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_HorizontalWithVerticalVelocityAndUncertainty 
   (const char* name, const ranap_HorizontalWithVerticalVelocityAndUncertainty* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_HorizontalSpeedAndBearing ("horizontalSpeedAndBearing", &
      pvalue->horizontalSpeedAndBearing);

   asn1Print_ranap_VerticalVelocity ("veritcalVelocity", &pvalue->
      veritcalVelocity);

   rtxPrintIndent ();
   rtxPrintUnsigned ("horizontalUncertaintySpeed", pvalue->horizontalUncertaintySpeed);

   rtxPrintIndent ();
   rtxPrintUnsigned ("verticalUncertaintySpeed", pvalue->verticalUncertaintySpeed);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_VelocityEstimate 
   (const char* name, const ranap_VelocityEstimate* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* horizontalVelocity */
      case 1:
      {
         asn1Print_ranap_HorizontalVelocity ("horizontalVelocity", pvalue->
            u.horizontalVelocity);
         break;
      }
      /* horizontalWithVerticalVelocity */
      case 2:
      {
         asn1Print_ranap_HorizontalWithVerticalVelocity (
            "horizontalWithVerticalVelocity", pvalue->
            u.horizontalWithVerticalVelocity);
         break;
      }
      /* horizontalVelocityWithUncertainty */
      case 3:
      {
         asn1Print_ranap_HorizontalVelocityWithUncertainty (
            "horizontalVelocityWithUncertainty", pvalue->
            u.horizontalVelocityWithUncertainty);
         break;
      }
      /* horizontalWithVeritcalVelocityAndUncertainty */
      case 4:
      {
         asn1Print_ranap_HorizontalWithVerticalVelocityAndUncertainty (
            "horizontalWithVeritcalVelocityAndUncertainty", pvalue->
            u.horizontalWithVeritcalVelocityAndUncertainty);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

EXTERN int asn1PE_ranap_RAB_IE_ContainerList (OSCTXT* pctxt, ranap_RAB_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-IE-ContainerList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      stat = asn1PE_ranap_ProtocolIE_Container (pctxt, ((ranap_ProtocolIE_Container*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_IE_ContainerList (OSCTXT* pctxt, ranap_RAB_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-IE-ContainerList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_Container* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_Container, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_Container (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_Container (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_IE_ContainerList (ranap_RAB_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_IE_ContainerList (OSCTXT *pctxt, 
   ranap_RAB_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_Container* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_Container*)pnode->data;
      asn1Free_ranap_ProtocolIE_Container (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAB_DataVolumeReportList (OSCTXT* pctxt, ranap_RAB_DataVolumeReportList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataVolumeReportList (OSCTXT* pctxt, ranap_RAB_DataVolumeReportList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataVolumeReportList (
   ranap_RAB_DataVolumeReportList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_DataVolumeReportList (OSCTXT *pctxt, 
   ranap_RAB_DataVolumeReportList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ReleasedList_IuRelComp (OSCTXT* pctxt, ranap_RAB_ReleasedList_IuRelComp* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedList-IuRelComp");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleasedList_IuRelComp (OSCTXT* pctxt, ranap_RAB_ReleasedList_IuRelComp* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedList-IuRelComp");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleasedList_IuRelComp (
   ranap_RAB_ReleasedList_IuRelComp* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ReleasedList_IuRelComp (OSCTXT *pctxt, 
   ranap_RAB_ReleasedList_IuRelComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_RelocationReleaseList (OSCTXT* pctxt, ranap_RAB_RelocationReleaseList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-RelocationReleaseList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_RelocationReleaseList (OSCTXT* pctxt, ranap_RAB_RelocationReleaseList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-RelocationReleaseList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_RelocationReleaseList (
   ranap_RAB_RelocationReleaseList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_RelocationReleaseList (OSCTXT *pctxt, 
   ranap_RAB_RelocationReleaseList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_DataForwardingList (OSCTXT* pctxt, ranap_RAB_DataForwardingList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataForwardingList (OSCTXT* pctxt, ranap_RAB_DataForwardingList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataForwardingList (
   ranap_RAB_DataForwardingList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_DataForwardingList (OSCTXT *pctxt, 
   ranap_RAB_DataForwardingList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_RelocReq (OSCTXT* pctxt, ranap_RAB_SetupList_RelocReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-RelocReq");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_RelocReq (OSCTXT* pctxt, ranap_RAB_SetupList_RelocReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-RelocReq");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_RelocReq (
   ranap_RAB_SetupList_RelocReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_RelocReq (OSCTXT *pctxt, 
   ranap_RAB_SetupList_RelocReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_RelocReqAck (OSCTXT* pctxt, ranap_RAB_SetupList_RelocReqAck* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-RelocReqAck");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_RelocReqAck (OSCTXT* pctxt, ranap_RAB_SetupList_RelocReqAck* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-RelocReqAck");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_RelocReqAck (
   ranap_RAB_SetupList_RelocReqAck* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_RelocReqAck (OSCTXT *pctxt, 
   ranap_RAB_SetupList_RelocReqAck* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_FailedList (OSCTXT* pctxt, ranap_RAB_FailedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_FailedList (OSCTXT* pctxt, ranap_RAB_FailedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_FailedList (ranap_RAB_FailedList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_FailedList (OSCTXT *pctxt, 
   ranap_RAB_FailedList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_DataForwardingList_SRNS_CtxReq (OSCTXT* pctxt, ranap_RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingList-SRNS-CtxReq");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataForwardingList_SRNS_CtxReq (OSCTXT* pctxt, ranap_RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingList-SRNS-CtxReq");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataForwardingList_SRNS_CtxReq (
   ranap_RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_DataForwardingList_SRNS_CtxReq (OSCTXT *pctxt, 
   ranap_RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ContextList (OSCTXT* pctxt, ranap_RAB_ContextList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ContextList (OSCTXT* pctxt, ranap_RAB_ContextList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ContextList (ranap_RAB_ContextList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ContextList (OSCTXT *pctxt, 
   ranap_RAB_ContextList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ContextFailedtoTransferList (OSCTXT* pctxt, ranap_RAB_ContextFailedtoTransferList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextFailedtoTransferList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ContextFailedtoTransferList (OSCTXT* pctxt, ranap_RAB_ContextFailedtoTransferList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextFailedtoTransferList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ContextFailedtoTransferList (
   ranap_RAB_ContextFailedtoTransferList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ContextFailedtoTransferList (OSCTXT *pctxt, 
   ranap_RAB_ContextFailedtoTransferList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_DataVolumeReportRequestList (OSCTXT* pctxt, ranap_RAB_DataVolumeReportRequestList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportRequestList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataVolumeReportRequestList (OSCTXT* pctxt, ranap_RAB_DataVolumeReportRequestList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportRequestList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataVolumeReportRequestList (
   ranap_RAB_DataVolumeReportRequestList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_DataVolumeReportRequestList (OSCTXT *pctxt, 
   ranap_RAB_DataVolumeReportRequestList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_FailedtoReportList (OSCTXT* pctxt, ranap_RAB_FailedtoReportList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedtoReportList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_FailedtoReportList (OSCTXT* pctxt, ranap_RAB_FailedtoReportList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedtoReportList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_FailedtoReportList (
   ranap_RAB_FailedtoReportList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_FailedtoReportList (OSCTXT *pctxt, 
   ranap_RAB_FailedtoReportList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_IuSigConId_IE_ContainerList (OSCTXT* pctxt, ranap_IuSigConId_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "IuSigConId-IE-ContainerList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(250), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      stat = asn1PE_ranap_ProtocolIE_Container (pctxt, ((ranap_ProtocolIE_Container*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_IuSigConId_IE_ContainerList (OSCTXT* pctxt, ranap_IuSigConId_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IuSigConId-IE-ContainerList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(250), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_Container* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_Container, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_Container (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_Container (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_IuSigConId_IE_ContainerList (
   ranap_IuSigConId_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_IuSigConId_IE_ContainerList (OSCTXT *pctxt, 
   ranap_IuSigConId_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_Container* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_Container*)pnode->data;
      asn1Free_ranap_ProtocolIE_Container (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_ResetResourceList (OSCTXT* pctxt, ranap_ResetResourceList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceList");

   stat = asn1PE_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResourceList (OSCTXT* pctxt, ranap_ResetResourceList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceList");

   stat = asn1PD_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResourceList (ranap_ResetResourceList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_IuSigConId_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_ResetResourceList (OSCTXT *pctxt, 
   ranap_ResetResourceList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_ResetResourceAckList (OSCTXT* pctxt, ranap_ResetResourceAckList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAckList");

   stat = asn1PE_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResourceAckList (OSCTXT* pctxt, ranap_ResetResourceAckList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAckList");

   stat = asn1PD_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResourceAckList (ranap_ResetResourceAckList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_IuSigConId_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_ResetResourceAckList (OSCTXT *pctxt, 
   ranap_ResetResourceAckList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_IuSigConId_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ReleaseList (OSCTXT* pctxt, ranap_RAB_ReleaseList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleaseList (OSCTXT* pctxt, ranap_RAB_ReleaseList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleaseList (ranap_RAB_ReleaseList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ReleaseList (OSCTXT *pctxt, 
   ranap_RAB_ReleaseList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_EnhancedRelocCompleteReq (OSCTXT* pctxt, ranap_RAB_SetupList_EnhancedRelocCompleteReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhancedRelocCompleteReq");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_EnhancedRelocCompleteReq (OSCTXT* pctxt, ranap_RAB_SetupList_EnhancedRelocCompleteReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhancedRelocCompleteReq");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_EnhancedRelocCompleteReq (
   ranap_RAB_SetupList_EnhancedRelocCompleteReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_EnhancedRelocCompleteReq (OSCTXT *pctxt, 
   ranap_RAB_SetupList_EnhancedRelocCompleteReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_SetupList_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhancedRelocCompleteRes");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_SetupList_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhancedRelocCompleteRes");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_EnhancedRelocCompleteRes (
   ranap_RAB_SetupList_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_EnhancedRelocCompleteRes (OSCTXT *pctxt, 
   ranap_RAB_SetupList_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ToBeReleasedList-EnhancedRelocCompleteRes");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ToBeReleasedList-EnhancedRelocCompleteRes");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (
   ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (OSCTXT *pctxt, 
   ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RedirectionIndication (OSCTXT* pctxt, ranap_RedirectionIndication* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectionIndication");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RedirectionIndication (OSCTXT* pctxt, ranap_RedirectionIndication* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RedirectionIndication");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RedirectionIndication (ranap_RedirectionIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_ProtocolIE_Container (pvalue);
   return 0;
}

void asn1Free_ranap_RedirectionIndication (OSCTXT *pctxt, 
   ranap_RedirectionIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_IE_ContainerPairList (OSCTXT* pctxt, ranap_RAB_IE_ContainerPairList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-IE-ContainerPairList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-ContainerPair", xx1);

      stat = asn1PE_ranap_ProtocolIE_ContainerPair (pctxt, ((ranap_ProtocolIE_ContainerPair*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_IE_ContainerPairList (OSCTXT* pctxt, ranap_RAB_IE_ContainerPairList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-IE-ContainerPairList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_ContainerPair* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-ContainerPair", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_ContainerPair, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_ContainerPair (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_ContainerPair (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_IE_ContainerPairList (
   ranap_RAB_IE_ContainerPairList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_IE_ContainerPairList (OSCTXT *pctxt, 
   ranap_RAB_IE_ContainerPairList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_ContainerPair* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_ContainerPair*)pnode->data;
      asn1Free_ranap_ProtocolIE_ContainerPair (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAB_SetupOrModifyList (OSCTXT* pctxt, ranap_RAB_SetupOrModifyList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyList");

   stat = asn1PE_ranap_RAB_IE_ContainerPairList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupOrModifyList (OSCTXT* pctxt, ranap_RAB_SetupOrModifyList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyList");

   stat = asn1PD_ranap_RAB_IE_ContainerPairList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupOrModifyList (ranap_RAB_SetupOrModifyList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerPairList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupOrModifyList (OSCTXT *pctxt, 
   ranap_RAB_SetupOrModifyList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerPairList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupOrModifiedList (OSCTXT* pctxt, ranap_RAB_SetupOrModifiedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifiedList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupOrModifiedList (OSCTXT* pctxt, ranap_RAB_SetupOrModifiedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifiedList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupOrModifiedList (
   ranap_RAB_SetupOrModifiedList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupOrModifiedList (OSCTXT *pctxt, 
   ranap_RAB_SetupOrModifiedList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ReleasedList (OSCTXT* pctxt, ranap_RAB_ReleasedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleasedList (OSCTXT* pctxt, ranap_RAB_ReleasedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleasedList (ranap_RAB_ReleasedList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ReleasedList (OSCTXT *pctxt, 
   ranap_RAB_ReleasedList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_QueuedList (OSCTXT* pctxt, ranap_RAB_QueuedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-QueuedList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_QueuedList (OSCTXT* pctxt, ranap_RAB_QueuedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-QueuedList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_QueuedList (ranap_RAB_QueuedList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_QueuedList (OSCTXT *pctxt, 
   ranap_RAB_QueuedList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ReleaseFailedList (OSCTXT* pctxt, ranap_RAB_ReleaseFailedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseFailedList");

   stat = asn1PE_ranap_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleaseFailedList (OSCTXT* pctxt, ranap_RAB_ReleaseFailedList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseFailedList");

   stat = asn1PD_ranap_RAB_FailedList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleaseFailedList (ranap_RAB_ReleaseFailedList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_FailedList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ReleaseFailedList (OSCTXT *pctxt, 
   ranap_RAB_ReleaseFailedList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_FailedList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (OSCTXT* pctxt, ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Iumode-RAB-FailedList-RABAssgntResponse");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (OSCTXT* pctxt, ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Iumode-RAB-FailedList-RABAssgntResponse");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (
   ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse (OSCTXT *pctxt, 
   ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_DirectTransfer_IE_ContainerList (OSCTXT* pctxt, ranap_DirectTransfer_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransfer-IE-ContainerList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      stat = asn1PE_ranap_ProtocolIE_Container (pctxt, ((ranap_ProtocolIE_Container*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectTransfer_IE_ContainerList (OSCTXT* pctxt, ranap_DirectTransfer_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransfer-IE-ContainerList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(15), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_Container* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_Container, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_Container (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_Container (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DirectTransfer_IE_ContainerList (
   ranap_DirectTransfer_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_DirectTransfer_IE_ContainerList (OSCTXT *pctxt, 
   ranap_DirectTransfer_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_Container* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_Container*)pnode->data;
      asn1Free_ranap_ProtocolIE_Container (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_DirectTransferInformationList_RANAP_RelocInf (OSCTXT* pctxt, ranap_DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransferInformationList-RANAP-RelocInf");

   stat = asn1PE_ranap_DirectTransfer_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectTransferInformationList_RANAP_RelocInf (OSCTXT* pctxt, ranap_DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransferInformationList-RANAP-RelocInf");

   stat = asn1PD_ranap_DirectTransfer_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DirectTransferInformationList_RANAP_RelocInf (
   ranap_DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_DirectTransfer_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_DirectTransferInformationList_RANAP_RelocInf (OSCTXT *pctxt, 
   ranap_DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_DirectTransfer_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ContextList_RANAP_RelocInf (OSCTXT* pctxt, ranap_RAB_ContextList_RANAP_RelocInf* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextList-RANAP-RelocInf");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ContextList_RANAP_RelocInf (OSCTXT* pctxt, ranap_RAB_ContextList_RANAP_RelocInf* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextList-RANAP-RelocInf");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ContextList_RANAP_RelocInf (
   ranap_RAB_ContextList_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ContextList_RANAP_RelocInf (OSCTXT *pctxt, 
   ranap_RAB_ContextList_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_EnhRelocInfoReq (OSCTXT* pctxt, ranap_RAB_SetupList_EnhRelocInfoReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhRelocInfoReq");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_EnhRelocInfoReq (OSCTXT* pctxt, ranap_RAB_SetupList_EnhRelocInfoReq* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhRelocInfoReq");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_EnhRelocInfoReq (
   ranap_RAB_SetupList_EnhRelocInfoReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_EnhRelocInfoReq (OSCTXT *pctxt, 
   ranap_RAB_SetupList_EnhRelocInfoReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_SetupList_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_SetupList_EnhRelocInfoRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhRelocInfoRes");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupList_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_SetupList_EnhRelocInfoRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupList-EnhRelocInfoRes");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupList_EnhRelocInfoRes (
   ranap_RAB_SetupList_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_SetupList_EnhRelocInfoRes (OSCTXT *pctxt, 
   ranap_RAB_SetupList_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_FailedList_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_FailedList_EnhRelocInfoRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedList-EnhRelocInfoRes");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_FailedList_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_FailedList_EnhRelocInfoRes* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedList-EnhRelocInfoRes");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_FailedList_EnhRelocInfoRes (
   ranap_RAB_FailedList_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_FailedList_EnhRelocInfoRes (OSCTXT *pctxt, 
   ranap_RAB_FailedList_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap_RAB_ModifyList (OSCTXT* pctxt, ranap_RAB_ModifyList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyList");

   stat = asn1PE_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ModifyList (OSCTXT* pctxt, ranap_RAB_ModifyList* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyList");

   stat = asn1PD_ranap_RAB_IE_ContainerList (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ModifyList (ranap_RAB_ModifyList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_RAB_IE_ContainerList (pvalue);
   return 0;
}

void asn1Free_ranap_RAB_ModifyList (OSCTXT *pctxt, 
   ranap_RAB_ModifyList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_IE_ContainerList (pctxt, pvalue);
}

EXTERN int asn1PE_ranap__RerouteNASRequestIEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   ranap__RerouteNASRequestIEs_Value value = *((ranap__RerouteNASRequestIEs_Value*)pvalue_);
   stat = pe_OctetString (pctxt, value.numocts, value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1PD_ranap__RerouteNASRequestIEs_Value (OSCTXT* pctxt, void* pvalue_)
{
   int stat = 0;

   ranap__RerouteNASRequestIEs_Value *pvalue = (ranap__RerouteNASRequestIEs_Value*) pvalue_;

   stat = pd_DynOctetString (pctxt, pvalue);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

int asn1Init_ranap__RerouteNASRequestIEs_Value (void* pvalue_)
{
   ranap__RerouteNASRequestIEs_Value* pvalue = (ranap__RerouteNASRequestIEs_Value*)pvalue_;
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->numocts = 0;
   pvalue->data = 0;
   return 0;
}

void asn1Free_ranap__RerouteNASRequestIEs_Value (OSCTXT *pctxt, void* pvalue_)
{
   ranap__RerouteNASRequestIEs_Value* pvalue = (ranap__RerouteNASRequestIEs_Value*)pvalue_;
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

EXTERN int asn1PE_ranap_Iu_ReleaseCommand (OSCTXT* pctxt, ranap_Iu_ReleaseCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseCommand");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Iu_ReleaseCommand (OSCTXT* pctxt, ranap_Iu_ReleaseCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseCommand");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Iu_ReleaseCommand (ranap_Iu_ReleaseCommand* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Iu_ReleaseCommand (OSCTXT *pctxt, 
   ranap_Iu_ReleaseCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Iu_ReleaseComplete (OSCTXT* pctxt, ranap_Iu_ReleaseComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseComplete");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Iu_ReleaseComplete (OSCTXT* pctxt, ranap_Iu_ReleaseComplete* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseComplete");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Iu_ReleaseComplete (ranap_Iu_ReleaseComplete* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Iu_ReleaseComplete (OSCTXT *pctxt, 
   ranap_Iu_ReleaseComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DataVolumeList_element (OSCTXT* pctxt, ranap_DataVolumeList_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataVolumeReferencePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_UnsuccessfullyTransmittedDataVolume */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

   stat = asn1PE_ranap_UnsuccessfullyTransmittedDataVolume (pctxt, pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataVolumeReference */

   if (pvalue->m.dataVolumeReferencePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReference");

      stat = asn1PE_ranap_DataVolumeReference (pctxt, pvalue->dataVolumeReference);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeList_element (OSCTXT* pctxt, ranap_DataVolumeList_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_UnsuccessfullyTransmittedDataVolume */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

   stat = asn1PD_ranap_UnsuccessfullyTransmittedDataVolume (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataVolumeReference */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReference");

      pvalue->m.dataVolumeReferencePresent = 1;

      stat = asn1PD_ranap_DataVolumeReference (pctxt, &pvalue->dataVolumeReference);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_DataVolumeList_element (
   ranap_DataVolumeList_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DataVolumeList_element (OSCTXT *pctxt, 
   ranap_DataVolumeList_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DataVolumeList (OSCTXT* pctxt, ranap_DataVolumeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_DataVolumeList_element (pctxt, ((ranap_DataVolumeList_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeList (OSCTXT* pctxt, ranap_DataVolumeList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(2), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_DataVolumeList_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_DataVolumeList_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_DataVolumeList_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_DataVolumeList_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DataVolumeList (ranap_DataVolumeList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_DataVolumeList (OSCTXT *pctxt, 
   ranap_DataVolumeList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_DataVolumeList_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_DataVolumeList_element*)pnode->data;
      asn1Free_ranap_DataVolumeList_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_RAB_DataVolumeReportItem (OSCTXT* pctxt, ranap_RAB_DataVolumeReportItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_UnsuccessfullyTransmittedDataVolume */

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

      stat = asn1PE_ranap_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataVolumeReportItem (OSCTXT* pctxt, ranap_RAB_DataVolumeReportItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_UnsuccessfullyTransmittedDataVolume */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-UnsuccessfullyTransmittedDataVolume");

      pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent = 1;

      stat = asn1PD_ranap_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataVolumeReportItem (
   ranap_RAB_DataVolumeReportItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_DataVolumeList (&pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_DataVolumeReportItem (OSCTXT *pctxt, 
   ranap_RAB_DataVolumeReportItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      asn1Free_ranap_DataVolumeList (pctxt, &pvalue->dl_UnsuccessfullyTransmittedDataVolume);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ReleasedItem_IuRelComp (OSCTXT* pctxt, ranap_RAB_ReleasedItem_IuRelComp* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedItem-IuRelComp");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleasedItem_IuRelComp (OSCTXT* pctxt, ranap_RAB_ReleasedItem_IuRelComp* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedItem-IuRelComp");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dL_GTP_PDU_SequenceNumber */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-GTP-PDU-SequenceNumber");

      pvalue->m.dL_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uL_GTP_PDU_SequenceNumber */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-GTP-PDU-SequenceNumber");

      pvalue->m.uL_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleasedItem_IuRelComp (
   ranap_RAB_ReleasedItem_IuRelComp* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ReleasedItem_IuRelComp (OSCTXT *pctxt, 
   ranap_RAB_ReleasedItem_IuRelComp* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationRequired (OSCTXT* pctxt, ranap_RelocationRequired* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequired");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationRequired (OSCTXT* pctxt, ranap_RelocationRequired* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequired");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationRequired (ranap_RelocationRequired* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationRequired (OSCTXT *pctxt, 
   ranap_RelocationRequired* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationCommand (OSCTXT* pctxt, ranap_RelocationCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCommand");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationCommand (OSCTXT* pctxt, ranap_RelocationCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCommand");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationCommand (ranap_RelocationCommand* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationCommand (OSCTXT *pctxt, 
   ranap_RelocationCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_RelocationReleaseItem (OSCTXT* pctxt, ranap_RAB_RelocationReleaseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-RelocationReleaseItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_RelocationReleaseItem (OSCTXT* pctxt, ranap_RAB_RelocationReleaseItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-RelocationReleaseItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_RelocationReleaseItem (
   ranap_RAB_RelocationReleaseItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_RelocationReleaseItem (OSCTXT *pctxt, 
   ranap_RAB_RelocationReleaseItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_DataForwardingItem (OSCTXT* pctxt, ranap_RAB_DataForwardingItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iuTransportAssociation */

   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataForwardingItem (OSCTXT* pctxt, ranap_RAB_DataForwardingItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iuTransportAssociation */
   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataForwardingItem (
   ranap_RAB_DataForwardingItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_DataForwardingItem (OSCTXT *pctxt, 
   ranap_RAB_DataForwardingItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationPreparationFailure (OSCTXT* pctxt, ranap_RelocationPreparationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationPreparationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationPreparationFailure (OSCTXT* pctxt, ranap_RelocationPreparationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationPreparationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationPreparationFailure (
   ranap_RelocationPreparationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationPreparationFailure (OSCTXT *pctxt, 
   ranap_RelocationPreparationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationRequest (OSCTXT* pctxt, ranap_RelocationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationRequest (OSCTXT* pctxt, ranap_RelocationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationRequest (ranap_RelocationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationRequest (OSCTXT *pctxt, 
   ranap_RelocationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UserPlaneInformation (OSCTXT* pctxt, ranap_UserPlaneInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UserPlaneInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode userPlaneMode */

   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneMode");

   stat = asn1PE_ranap_UserPlaneMode (pctxt, pvalue->userPlaneMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode uP_ModeVersions */

   RTXCTXTPUSHELEMNAME (pctxt, "uP-ModeVersions");

   stat = asn1PE_ranap_UP_ModeVersions (pctxt, pvalue->uP_ModeVersions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UserPlaneInformation (OSCTXT* pctxt, ranap_UserPlaneInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UserPlaneInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode userPlaneMode */
   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneMode");

   stat = asn1PD_ranap_UserPlaneMode (pctxt, &pvalue->userPlaneMode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode uP_ModeVersions */
   RTXCTXTPUSHELEMNAME (pctxt, "uP-ModeVersions");

   stat = asn1PD_ranap_UP_ModeVersions (pctxt, &pvalue->uP_ModeVersions);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UserPlaneInformation (ranap_UserPlaneInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_UP_ModeVersions (&pvalue->uP_ModeVersions);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UserPlaneInformation (OSCTXT *pctxt, 
   ranap_UserPlaneInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_RelocReq (OSCTXT* pctxt, ranap_RAB_SetupItem_RelocReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-RelocReq");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nAS_SynchronisationIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataVolumeReportingIndicationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pDP_TypeInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.service_HandoverPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-SynchronisationIndicator");

      stat = asn1PE_ranap_NAS_SynchronisationIndicator (pctxt, pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rAB_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

   stat = asn1PE_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      stat = asn1PE_ranap_DataVolumeReportingIndication (pctxt, pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      stat = asn1PE_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode userPlaneInformation */

   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PE_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iuTransportAssociation */

   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      stat = asn1PE_ranap_Service_Handover (pctxt, pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_RelocReq (OSCTXT* pctxt, ranap_RAB_SetupItem_RelocReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-RelocReq");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nAS_SynchronisationIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-SynchronisationIndicator");

      pvalue->m.nAS_SynchronisationIndicatorPresent = 1;

      stat = asn1PD_ranap_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAB_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

   stat = asn1PD_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataVolumeReportingIndication */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      pvalue->m.dataVolumeReportingIndicationPresent = 1;

      stat = asn1PD_ranap_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pDP_TypeInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      pvalue->m.pDP_TypeInformationPresent = 1;

      stat = asn1PD_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode userPlaneInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PD_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iuTransportAssociation */
   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode service_Handover */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      pvalue->m.service_HandoverPresent = 1;

      stat = asn1PD_ranap_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_RelocReq (
   ranap_RAB_SetupItem_RelocReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_NAS_SynchronisationIndicator (&pvalue->nAS_SynchronisationIndicator);
   asn1Init_ranap_RAB_Parameters (&pvalue->rAB_Parameters);
   asn1Init_ranap_PDP_TypeInformation (&pvalue->pDP_TypeInformation);
   asn1Init_ranap_UserPlaneInformation (&pvalue->userPlaneInformation);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_RelocReq (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_RelocReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   asn1Free_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_JoinedMBMSBearerService_IEs_element (OSCTXT* pctxt, ranap_JoinedMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tMGI */

   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PE_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode mBMS_PTP_RAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "mBMS-PTP-RAB-ID");

   stat = asn1PE_ranap_MBMS_PTP_RAB_ID (pctxt, pvalue->mBMS_PTP_RAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_JoinedMBMSBearerService_IEs_element (OSCTXT* pctxt, ranap_JoinedMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tMGI */
   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PD_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mBMS_PTP_RAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "mBMS-PTP-RAB-ID");

   stat = asn1PD_ranap_MBMS_PTP_RAB_ID (pctxt, &pvalue->mBMS_PTP_RAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_JoinedMBMSBearerService_IEs_element (
   ranap_JoinedMBMSBearerService_IEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TMGI (&pvalue->tMGI);
   asn1Init_ranap_MBMS_PTP_RAB_ID (&pvalue->mBMS_PTP_RAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_JoinedMBMSBearerService_IEs_element (OSCTXT *pctxt, 
   ranap_JoinedMBMSBearerService_IEs_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_JoinedMBMSBearerService_IEs (OSCTXT* pctxt, ranap_JoinedMBMSBearerService_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "JoinedMBMSBearerService-IEs");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_JoinedMBMSBearerService_IEs_element (pctxt, ((ranap_JoinedMBMSBearerService_IEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_JoinedMBMSBearerService_IEs (OSCTXT* pctxt, ranap_JoinedMBMSBearerService_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "JoinedMBMSBearerService-IEs");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_JoinedMBMSBearerService_IEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_JoinedMBMSBearerService_IEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_JoinedMBMSBearerService_IEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_JoinedMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_JoinedMBMSBearerService_IEs (
   ranap_JoinedMBMSBearerService_IEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_JoinedMBMSBearerService_IEs (OSCTXT *pctxt, 
   ranap_JoinedMBMSBearerService_IEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_JoinedMBMSBearerService_IEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_JoinedMBMSBearerService_IEs_element*)pnode->data;
      asn1Free_ranap_JoinedMBMSBearerService_IEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_CNMBMSLinkingInformation (OSCTXT* pctxt, ranap_CNMBMSLinkingInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CNMBMSLinkingInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode joinedMBMSBearerService_IEs */

   RTXCTXTPUSHELEMNAME (pctxt, "joinedMBMSBearerService-IEs");

   stat = asn1PE_ranap_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CNMBMSLinkingInformation (OSCTXT* pctxt, ranap_CNMBMSLinkingInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CNMBMSLinkingInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode joinedMBMSBearerService_IEs */
   RTXCTXTPUSHELEMNAME (pctxt, "joinedMBMSBearerService-IEs");

   stat = asn1PD_ranap_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CNMBMSLinkingInformation (
   ranap_CNMBMSLinkingInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_JoinedMBMSBearerService_IEs (&pvalue->joinedMBMSBearerService_IEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CNMBMSLinkingInformation (OSCTXT *pctxt, 
   ranap_CNMBMSLinkingInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_JoinedMBMSBearerService_IEs (pctxt, &pvalue->joinedMBMSBearerService_IEs);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationRequestAcknowledge (OSCTXT* pctxt, ranap_RelocationRequestAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequestAcknowledge");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationRequestAcknowledge (OSCTXT* pctxt, ranap_RelocationRequestAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationRequestAcknowledge");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationRequestAcknowledge (
   ranap_RelocationRequestAcknowledge* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationRequestAcknowledge (OSCTXT *pctxt, 
   ranap_RelocationRequestAcknowledge* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_RelocReqAck (OSCTXT* pctxt, ranap_RAB_SetupItem_RelocReqAck* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-RelocReqAck");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

      stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_RelocReqAck (OSCTXT* pctxt, ranap_RAB_SetupItem_RelocReqAck* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-RelocReqAck");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddress */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

      pvalue->m.transportLayerAddressPresent = 1;

      stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iuTransportAssociation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

      pvalue->m.iuTransportAssociationPresent = 1;

      stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_RelocReqAck (
   ranap_RAB_SetupItem_RelocReqAck* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_RelocReqAck (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_RelocReqAck* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transportLayerAddressPresent) {
      asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   }
   if (pvalue->m.iuTransportAssociationPresent) {
      asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_FailedItem (OSCTXT* pctxt, ranap_RAB_FailedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_FailedItem (OSCTXT* pctxt, ranap_RAB_FailedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_FailedItem (ranap_RAB_FailedItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_FailedItem (OSCTXT *pctxt, 
   ranap_RAB_FailedItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationFailure (OSCTXT* pctxt, ranap_RelocationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationFailure (OSCTXT* pctxt, ranap_RelocationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationFailure (ranap_RelocationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationFailure (OSCTXT *pctxt, 
   ranap_RelocationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationCancel (OSCTXT* pctxt, ranap_RelocationCancel* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCancel");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationCancel (OSCTXT* pctxt, ranap_RelocationCancel* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCancel");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationCancel (ranap_RelocationCancel* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationCancel (OSCTXT *pctxt, 
   ranap_RelocationCancel* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationCancelAcknowledge (OSCTXT* pctxt, ranap_RelocationCancelAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCancelAcknowledge");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationCancelAcknowledge (OSCTXT* pctxt, ranap_RelocationCancelAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationCancelAcknowledge");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationCancelAcknowledge (
   ranap_RelocationCancelAcknowledge* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationCancelAcknowledge (OSCTXT *pctxt, 
   ranap_RelocationCancelAcknowledge* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRNS_ContextRequest (OSCTXT* pctxt, ranap_SRNS_ContextRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-ContextRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRNS_ContextRequest (OSCTXT* pctxt, ranap_SRNS_ContextRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-ContextRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRNS_ContextRequest (ranap_SRNS_ContextRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRNS_ContextRequest (OSCTXT *pctxt, 
   ranap_SRNS_ContextRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_DataForwardingItem_SRNS_CtxReq (OSCTXT* pctxt, ranap_RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingItem-SRNS-CtxReq");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataForwardingItem_SRNS_CtxReq (OSCTXT* pctxt, ranap_RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataForwardingItem-SRNS-CtxReq");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataForwardingItem_SRNS_CtxReq (
   ranap_RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_DataForwardingItem_SRNS_CtxReq (OSCTXT *pctxt, 
   ranap_RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRNS_ContextResponse (OSCTXT* pctxt, ranap_SRNS_ContextResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-ContextResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRNS_ContextResponse (OSCTXT* pctxt, ranap_SRNS_ContextResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-ContextResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRNS_ContextResponse (ranap_SRNS_ContextResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRNS_ContextResponse (OSCTXT *pctxt, 
   ranap_SRNS_ContextResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ContextItem (OSCTXT* pctxt, ranap_RAB_ContextItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ContextItem (OSCTXT* pctxt, ranap_RAB_ContextItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_GTP_PDU_SequenceNumber */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      pvalue->m.dl_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_GTP_PDU_SequenceNumber */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      pvalue->m.ul_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_N_PDU_SequenceNumber */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      pvalue->m.dl_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_N_PDU_SequenceNumber */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      pvalue->m.ul_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ContextItem (ranap_RAB_ContextItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ContextItem (OSCTXT *pctxt, 
   ranap_RAB_ContextItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RABs_ContextFailedtoTransferItem (OSCTXT* pctxt, ranap_RABs_ContextFailedtoTransferItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RABs-ContextFailedtoTransferItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RABs_ContextFailedtoTransferItem (OSCTXT* pctxt, ranap_RABs_ContextFailedtoTransferItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RABs-ContextFailedtoTransferItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RABs_ContextFailedtoTransferItem (
   ranap_RABs_ContextFailedtoTransferItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RABs_ContextFailedtoTransferItem (OSCTXT *pctxt, 
   ranap_RABs_ContextFailedtoTransferItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SecurityModeCommand (OSCTXT* pctxt, ranap_SecurityModeCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SecurityModeCommand (OSCTXT* pctxt, ranap_SecurityModeCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeCommand");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SecurityModeCommand (ranap_SecurityModeCommand* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SecurityModeCommand (OSCTXT *pctxt, 
   ranap_SecurityModeCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SecurityModeComplete (OSCTXT* pctxt, ranap_SecurityModeComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SecurityModeComplete (OSCTXT* pctxt, ranap_SecurityModeComplete* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeComplete");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SecurityModeComplete (ranap_SecurityModeComplete* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SecurityModeComplete (OSCTXT *pctxt, 
   ranap_SecurityModeComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SecurityModeReject (OSCTXT* pctxt, ranap_SecurityModeReject* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeReject");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SecurityModeReject (OSCTXT* pctxt, ranap_SecurityModeReject* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityModeReject");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SecurityModeReject (ranap_SecurityModeReject* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SecurityModeReject (OSCTXT *pctxt, 
   ranap_SecurityModeReject* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DataVolumeReportRequest (OSCTXT* pctxt, ranap_DataVolumeReportRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReportRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeReportRequest (OSCTXT* pctxt, ranap_DataVolumeReportRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReportRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DataVolumeReportRequest (
   ranap_DataVolumeReportRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DataVolumeReportRequest (OSCTXT *pctxt, 
   ranap_DataVolumeReportRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_DataVolumeReportRequestItem (OSCTXT* pctxt, ranap_RAB_DataVolumeReportRequestItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportRequestItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_DataVolumeReportRequestItem (OSCTXT* pctxt, ranap_RAB_DataVolumeReportRequestItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-DataVolumeReportRequestItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_DataVolumeReportRequestItem (
   ranap_RAB_DataVolumeReportRequestItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_DataVolumeReportRequestItem (OSCTXT *pctxt, 
   ranap_RAB_DataVolumeReportRequestItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DataVolumeReport (OSCTXT* pctxt, ranap_DataVolumeReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReport");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DataVolumeReport (OSCTXT* pctxt, ranap_DataVolumeReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DataVolumeReport");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DataVolumeReport (ranap_DataVolumeReport* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DataVolumeReport (OSCTXT *pctxt, 
   ranap_DataVolumeReport* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RABs_failed_to_reportItem (OSCTXT* pctxt, ranap_RABs_failed_to_reportItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RABs-failed-to-reportItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RABs_failed_to_reportItem (OSCTXT* pctxt, ranap_RABs_failed_to_reportItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RABs-failed-to-reportItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RABs_failed_to_reportItem (
   ranap_RABs_failed_to_reportItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RABs_failed_to_reportItem (OSCTXT *pctxt, 
   ranap_RABs_failed_to_reportItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Reset (OSCTXT* pctxt, ranap_Reset* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Reset");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Reset (OSCTXT* pctxt, ranap_Reset* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Reset");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Reset (ranap_Reset* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Reset (OSCTXT *pctxt, ranap_Reset* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ResetAcknowledge (OSCTXT* pctxt, ranap_ResetAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetAcknowledge");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetAcknowledge (OSCTXT* pctxt, ranap_ResetAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResetAcknowledge");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetAcknowledge (ranap_ResetAcknowledge* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ResetAcknowledge (OSCTXT *pctxt, 
   ranap_ResetAcknowledge* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ResetResource (OSCTXT* pctxt, ranap_ResetResource* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResource");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResource (OSCTXT* pctxt, ranap_ResetResource* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResource");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResource (ranap_ResetResource* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ResetResource (OSCTXT *pctxt, ranap_ResetResource* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ResetResourceItem (OSCTXT* pctxt, ranap_ResetResourceItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iuSigConId */

   RTXCTXTPUSHELEMNAME (pctxt, "iuSigConId");

   stat = asn1PE_ranap_IuSignallingConnectionIdentifier (pctxt, pvalue->iuSigConId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResourceItem (OSCTXT* pctxt, ranap_ResetResourceItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iuSigConId */
   RTXCTXTPUSHELEMNAME (pctxt, "iuSigConId");

   stat = asn1PD_ranap_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResourceItem (ranap_ResetResourceItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IuSignallingConnectionIdentifier (&pvalue->iuSigConId);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ResetResourceItem (OSCTXT *pctxt, 
   ranap_ResetResourceItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ResetResourceAcknowledge (OSCTXT* pctxt, ranap_ResetResourceAcknowledge* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAcknowledge");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResourceAcknowledge (OSCTXT* pctxt, ranap_ResetResourceAcknowledge* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAcknowledge");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResourceAcknowledge (
   ranap_ResetResourceAcknowledge* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ResetResourceAcknowledge (OSCTXT *pctxt, 
   ranap_ResetResourceAcknowledge* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ResetResourceAckItem (OSCTXT* pctxt, ranap_ResetResourceAckItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAckItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode iuSigConId */

   RTXCTXTPUSHELEMNAME (pctxt, "iuSigConId");

   stat = asn1PE_ranap_IuSignallingConnectionIdentifier (pctxt, pvalue->iuSigConId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ResetResourceAckItem (OSCTXT* pctxt, ranap_ResetResourceAckItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ResetResourceAckItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode iuSigConId */
   RTXCTXTPUSHELEMNAME (pctxt, "iuSigConId");

   stat = asn1PD_ranap_IuSignallingConnectionIdentifier (pctxt, &pvalue->iuSigConId);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ResetResourceAckItem (ranap_ResetResourceAckItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IuSignallingConnectionIdentifier (&pvalue->iuSigConId);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ResetResourceAckItem (OSCTXT *pctxt, 
   ranap_ResetResourceAckItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ReleaseRequest (OSCTXT* pctxt, ranap_RAB_ReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleaseRequest (OSCTXT* pctxt, ranap_RAB_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleaseRequest (ranap_RAB_ReleaseRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ReleaseRequest (OSCTXT *pctxt, 
   ranap_RAB_ReleaseRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ReleaseItem (OSCTXT* pctxt, ranap_RAB_ReleaseItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleaseItem (OSCTXT* pctxt, ranap_RAB_ReleaseItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleaseItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleaseItem (ranap_RAB_ReleaseItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ReleaseItem (OSCTXT *pctxt, 
   ranap_RAB_ReleaseItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Iu_ReleaseRequest (OSCTXT* pctxt, ranap_Iu_ReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Iu_ReleaseRequest (OSCTXT* pctxt, ranap_Iu_ReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Iu-ReleaseRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Iu_ReleaseRequest (ranap_Iu_ReleaseRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Iu_ReleaseRequest (OSCTXT *pctxt, 
   ranap_Iu_ReleaseRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationDetect (OSCTXT* pctxt, ranap_RelocationDetect* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationDetect");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationDetect (OSCTXT* pctxt, ranap_RelocationDetect* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationDetect");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationDetect (ranap_RelocationDetect* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationDetect (OSCTXT *pctxt, 
   ranap_RelocationDetect* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RelocationComplete (OSCTXT* pctxt, ranap_RelocationComplete* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationComplete");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RelocationComplete (OSCTXT* pctxt, ranap_RelocationComplete* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RelocationComplete");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RelocationComplete (ranap_RelocationComplete* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RelocationComplete (OSCTXT *pctxt, 
   ranap_RelocationComplete* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_EnhancedRelocationCompleteRequest (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EnhancedRelocationCompleteRequest (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EnhancedRelocationCompleteRequest (
   ranap_EnhancedRelocationCompleteRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_EnhancedRelocationCompleteRequest (OSCTXT *pctxt, 
   ranap_EnhancedRelocationCompleteRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_EnhancedRelocCompleteReq (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhancedRelocCompleteReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhancedRelocCompleteReq");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressReq1Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationReq1Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ass_RAB_ParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddressReq1 */

   if (pvalue->m.transportLayerAddressReq1Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddressReq1");

      stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddressReq1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iuTransportAssociationReq1 */

   if (pvalue->m.iuTransportAssociationReq1Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociationReq1");

      stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationReq1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ass_RAB_Parameters */

   if (pvalue->m.ass_RAB_ParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ass-RAB-Parameters");

      stat = asn1PE_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_EnhancedRelocCompleteReq (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhancedRelocCompleteReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhancedRelocCompleteReq");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddressReq1 */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddressReq1");

      pvalue->m.transportLayerAddressReq1Present = 1;

      stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddressReq1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iuTransportAssociationReq1 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociationReq1");

      pvalue->m.iuTransportAssociationReq1Present = 1;

      stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationReq1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ass_RAB_Parameters */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ass-RAB-Parameters");

      pvalue->m.ass_RAB_ParametersPresent = 1;

      stat = asn1PD_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_EnhancedRelocCompleteReq (
   ranap_RAB_SetupItem_EnhancedRelocCompleteReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddressReq1);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociationReq1);
   asn1Init_ranap_Ass_RAB_Parameters (&pvalue->ass_RAB_Parameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_EnhancedRelocCompleteReq (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_EnhancedRelocCompleteReq* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transportLayerAddressReq1Present) {
      asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddressReq1);
   }
   if (pvalue->m.iuTransportAssociationReq1Present) {
      asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationReq1);
   }
   if (pvalue->m.ass_RAB_ParametersPresent) {
      asn1Free_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_EnhancedRelocationCompleteResponse (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EnhancedRelocationCompleteResponse (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EnhancedRelocationCompleteResponse (
   ranap_EnhancedRelocationCompleteResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_EnhancedRelocationCompleteResponse (OSCTXT *pctxt, 
   ranap_EnhancedRelocationCompleteResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhancedRelocCompleteRes");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rAB_ParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressRes1Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationRes1Present);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rab2beReleasedListPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAB_Parameters */

   if (pvalue->m.rAB_ParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

      stat = asn1PE_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode userPlaneInformation */

   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PE_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddressRes1 */

   if (pvalue->m.transportLayerAddressRes1Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddressRes1");

      stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddressRes1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iuTransportAssociationRes1 */

   if (pvalue->m.iuTransportAssociationRes1Present) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociationRes1");

      stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationRes1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rab2beReleasedList */

   if (pvalue->m.rab2beReleasedListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rab2beReleasedList");

      stat = asn1PE_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (pctxt, &pvalue->rab2beReleasedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhancedRelocCompleteRes");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAB_Parameters */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

      pvalue->m.rAB_ParametersPresent = 1;

      stat = asn1PD_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode userPlaneInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PD_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddressRes1 */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddressRes1");

      pvalue->m.transportLayerAddressRes1Present = 1;

      stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddressRes1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iuTransportAssociationRes1 */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociationRes1");

      pvalue->m.iuTransportAssociationRes1Present = 1;

      stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationRes1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rab2beReleasedList */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rab2beReleasedList");

      pvalue->m.rab2beReleasedListPresent = 1;

      stat = asn1PD_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (pctxt, &pvalue->rab2beReleasedList);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_EnhancedRelocCompleteRes (
   ranap_RAB_SetupItem_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_RAB_Parameters (&pvalue->rAB_Parameters);
   asn1Init_ranap_UserPlaneInformation (&pvalue->userPlaneInformation);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddressRes1);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociationRes1);
   asn1Init_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (&pvalue->rab2beReleasedList);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_EnhancedRelocCompleteRes (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rAB_ParametersPresent) {
      asn1Free_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   }
   asn1Free_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (pvalue->m.transportLayerAddressRes1Present) {
      asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddressRes1);
   }
   if (pvalue->m.iuTransportAssociationRes1Present) {
      asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociationRes1);
   }
   if (pvalue->m.rab2beReleasedListPresent) {
      asn1Free_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (pctxt, &pvalue->rab2beReleasedList);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ToBeReleasedItem-EnhancedRelocCompleteRes");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes (OSCTXT* pctxt, ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ToBeReleasedItem-EnhancedRelocCompleteRes");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes (
   ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes (OSCTXT *pctxt, 
   ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_EnhancedRelocationCompleteFailure (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EnhancedRelocationCompleteFailure (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EnhancedRelocationCompleteFailure (
   ranap_EnhancedRelocationCompleteFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_EnhancedRelocationCompleteFailure (OSCTXT *pctxt, 
   ranap_EnhancedRelocationCompleteFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_EnhancedRelocationCompleteConfirm (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteConfirm* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteConfirm");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_EnhancedRelocationCompleteConfirm (OSCTXT* pctxt, ranap_EnhancedRelocationCompleteConfirm* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "EnhancedRelocationCompleteConfirm");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_EnhancedRelocationCompleteConfirm (
   ranap_EnhancedRelocationCompleteConfirm* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_EnhancedRelocationCompleteConfirm (OSCTXT *pctxt, 
   ranap_EnhancedRelocationCompleteConfirm* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Paging (OSCTXT* pctxt, ranap_Paging* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Paging (OSCTXT* pctxt, ranap_Paging* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Paging");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Paging (ranap_Paging* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Paging (OSCTXT *pctxt, ranap_Paging* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CommonID (OSCTXT* pctxt, ranap_CommonID* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonID");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CommonID (OSCTXT* pctxt, ranap_CommonID* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CommonID");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CommonID (ranap_CommonID* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CommonID (OSCTXT *pctxt, ranap_CommonID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CN_InvokeTrace (OSCTXT* pctxt, ranap_CN_InvokeTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-InvokeTrace");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CN_InvokeTrace (OSCTXT* pctxt, ranap_CN_InvokeTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CN-InvokeTrace");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CN_InvokeTrace (ranap_CN_InvokeTrace* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CN_InvokeTrace (OSCTXT *pctxt, 
   ranap_CN_InvokeTrace* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_CN_DeactivateTrace (OSCTXT* pctxt, ranap_CN_DeactivateTrace* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "CN-DeactivateTrace");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_CN_DeactivateTrace (OSCTXT* pctxt, ranap_CN_DeactivateTrace* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "CN-DeactivateTrace");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_CN_DeactivateTrace (ranap_CN_DeactivateTrace* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_CN_DeactivateTrace (OSCTXT *pctxt, 
   ranap_CN_DeactivateTrace* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationReportingControl (OSCTXT* pctxt, ranap_LocationReportingControl* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingControl");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationReportingControl (OSCTXT* pctxt, ranap_LocationReportingControl* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReportingControl");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationReportingControl (
   ranap_LocationReportingControl* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationReportingControl (OSCTXT *pctxt, 
   ranap_LocationReportingControl* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationReport (OSCTXT* pctxt, ranap_LocationReport* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReport");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationReport (OSCTXT* pctxt, ranap_LocationReport* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationReport");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationReport (ranap_LocationReport* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationReport (OSCTXT *pctxt, 
   ranap_LocationReport* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_InitialUE_Message (OSCTXT* pctxt, ranap_InitialUE_Message* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUE-Message");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InitialUE_Message (OSCTXT* pctxt, ranap_InitialUE_Message* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InitialUE-Message");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InitialUE_Message (ranap_InitialUE_Message* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InitialUE_Message (OSCTXT *pctxt, 
   ranap_InitialUE_Message* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DirectTransfer (OSCTXT* pctxt, ranap_DirectTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransfer");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectTransfer (OSCTXT* pctxt, ranap_DirectTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransfer");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DirectTransfer (ranap_DirectTransfer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DirectTransfer (OSCTXT *pctxt, 
   ranap_DirectTransfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_Overload (OSCTXT* pctxt, ranap_Overload* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "Overload");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Overload (OSCTXT* pctxt, ranap_Overload* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "Overload");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Overload (ranap_Overload* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_Overload (OSCTXT *pctxt, ranap_Overload* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ErrorIndication (OSCTXT* pctxt, ranap_ErrorIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ErrorIndication (OSCTXT* pctxt, ranap_ErrorIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ErrorIndication (ranap_ErrorIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ErrorIndication (OSCTXT *pctxt, 
   ranap_ErrorIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRNS_DataForwardCommand (OSCTXT* pctxt, ranap_SRNS_DataForwardCommand* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-DataForwardCommand");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRNS_DataForwardCommand (OSCTXT* pctxt, ranap_SRNS_DataForwardCommand* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRNS-DataForwardCommand");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRNS_DataForwardCommand (
   ranap_SRNS_DataForwardCommand* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRNS_DataForwardCommand (OSCTXT *pctxt, 
   ranap_SRNS_DataForwardCommand* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ForwardSRNS_Context (OSCTXT* pctxt, ranap_ForwardSRNS_Context* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "ForwardSRNS-Context");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ForwardSRNS_Context (OSCTXT* pctxt, ranap_ForwardSRNS_Context* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "ForwardSRNS-Context");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ForwardSRNS_Context (ranap_ForwardSRNS_Context* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_ForwardSRNS_Context (OSCTXT *pctxt, 
   ranap_ForwardSRNS_Context* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_AssignmentRequest (OSCTXT* pctxt, ranap_RAB_AssignmentRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AssignmentRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_AssignmentRequest (OSCTXT* pctxt, ranap_RAB_AssignmentRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AssignmentRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_AssignmentRequest (ranap_RAB_AssignmentRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_AssignmentRequest (OSCTXT *pctxt, 
   ranap_RAB_AssignmentRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TransportLayerInformation (OSCTXT* pctxt, ranap_TransportLayerInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TransportLayerInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode transportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iuTransportAssociation */

   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TransportLayerInformation (OSCTXT* pctxt, ranap_TransportLayerInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TransportLayerInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iuTransportAssociation */
   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TransportLayerInformation (
   ranap_TransportLayerInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TransportLayerInformation (OSCTXT *pctxt, 
   ranap_TransportLayerInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupOrModifyItemFirst (OSCTXT* pctxt, ranap_RAB_SetupOrModifyItemFirst* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyItemFirst");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.nAS_SynchronisationIndicatorPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.rAB_ParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.userPlaneInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transportLayerInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.service_HandoverPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nAS_SynchronisationIndicator */

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-SynchronisationIndicator");

      stat = asn1PE_ranap_NAS_SynchronisationIndicator (pctxt, pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode rAB_Parameters */

   if (pvalue->m.rAB_ParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

      stat = asn1PE_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode userPlaneInformation */

   if (pvalue->m.userPlaneInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

      stat = asn1PE_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode transportLayerInformation */

   if (pvalue->m.transportLayerInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerInformation");

      stat = asn1PE_ranap_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      stat = asn1PE_ranap_Service_Handover (pctxt, pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupOrModifyItemFirst (OSCTXT* pctxt, ranap_RAB_SetupOrModifyItemFirst* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[6];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyItemFirst");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 6; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nAS_SynchronisationIndicator */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "nAS-SynchronisationIndicator");

      pvalue->m.nAS_SynchronisationIndicatorPresent = 1;

      stat = asn1PD_ranap_NAS_SynchronisationIndicator (pctxt, &pvalue->nAS_SynchronisationIndicator);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode rAB_Parameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

      pvalue->m.rAB_ParametersPresent = 1;

      stat = asn1PD_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode userPlaneInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

      pvalue->m.userPlaneInformationPresent = 1;

      stat = asn1PD_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode transportLayerInformation */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerInformation");

      pvalue->m.transportLayerInformationPresent = 1;

      stat = asn1PD_ranap_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode service_Handover */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      pvalue->m.service_HandoverPresent = 1;

      stat = asn1PD_ranap_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupOrModifyItemFirst (
   ranap_RAB_SetupOrModifyItemFirst* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_NAS_SynchronisationIndicator (&pvalue->nAS_SynchronisationIndicator);
   asn1Init_ranap_RAB_Parameters (&pvalue->rAB_Parameters);
   asn1Init_ranap_UserPlaneInformation (&pvalue->userPlaneInformation);
   asn1Init_ranap_TransportLayerInformation (&pvalue->transportLayerInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupOrModifyItemFirst (OSCTXT *pctxt, 
   ranap_RAB_SetupOrModifyItemFirst* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rAB_ParametersPresent) {
      asn1Free_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   }
   if (pvalue->m.userPlaneInformationPresent) {
      asn1Free_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   }
   if (pvalue->m.transportLayerInformationPresent) {
      asn1Free_ranap_TransportLayerInformation (pctxt, &pvalue->transportLayerInformation);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupOrModifyItemSecond (OSCTXT* pctxt, ranap_RAB_SetupOrModifyItemSecond* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyItemSecond");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pDP_TypeInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataVolumeReportingIndicationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      stat = asn1PE_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      stat = asn1PE_ranap_DataVolumeReportingIndication (pctxt, pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupOrModifyItemSecond (OSCTXT* pctxt, ranap_RAB_SetupOrModifyItemSecond* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifyItemSecond");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode pDP_TypeInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      pvalue->m.pDP_TypeInformationPresent = 1;

      stat = asn1PD_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dataVolumeReportingIndication */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      pvalue->m.dataVolumeReportingIndicationPresent = 1;

      stat = asn1PD_ranap_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_GTP_PDU_SequenceNumber */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      pvalue->m.dl_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_GTP_PDU_SequenceNumber */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      pvalue->m.ul_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_N_PDU_SequenceNumber */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      pvalue->m.dl_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_N_PDU_SequenceNumber */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      pvalue->m.ul_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupOrModifyItemSecond (
   ranap_RAB_SetupOrModifyItemSecond* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_PDP_TypeInformation (&pvalue->pDP_TypeInformation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupOrModifyItemSecond (OSCTXT *pctxt, 
   ranap_RAB_SetupOrModifyItemSecond* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_AssignmentResponse (OSCTXT* pctxt, ranap_RAB_AssignmentResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AssignmentResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_AssignmentResponse (OSCTXT* pctxt, ranap_RAB_AssignmentResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-AssignmentResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_AssignmentResponse (
   ranap_RAB_AssignmentResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_AssignmentResponse (OSCTXT *pctxt, 
   ranap_RAB_AssignmentResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupOrModifiedItem (OSCTXT* pctxt, ranap_RAB_SetupOrModifiedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifiedItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.transportLayerAddressPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iuTransportAssociationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_dataVolumesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode transportLayerAddress */

   if (pvalue->m.transportLayerAddressPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

      stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iuTransportAssociation */

   if (pvalue->m.iuTransportAssociationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

      stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dataVolumes");

      stat = asn1PE_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupOrModifiedItem (OSCTXT* pctxt, ranap_RAB_SetupOrModifiedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupOrModifiedItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode transportLayerAddress */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

      pvalue->m.transportLayerAddressPresent = 1;

      stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iuTransportAssociation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

      pvalue->m.iuTransportAssociationPresent = 1;

      stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_dataVolumes */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dataVolumes");

      pvalue->m.dl_dataVolumesPresent = 1;

      stat = asn1PD_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupOrModifiedItem (
   ranap_RAB_SetupOrModifiedItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_DataVolumeList (&pvalue->dl_dataVolumes);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupOrModifiedItem (OSCTXT *pctxt, 
   ranap_RAB_SetupOrModifiedItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transportLayerAddressPresent) {
      asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   }
   if (pvalue->m.iuTransportAssociationPresent) {
      asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   }
   if (pvalue->m.dl_dataVolumesPresent) {
      asn1Free_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ReleasedItem (OSCTXT* pctxt, ranap_RAB_ReleasedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_dataVolumesPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.uL_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_dataVolumes */

   if (pvalue->m.dl_dataVolumesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dataVolumes");

      stat = asn1PE_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dL_GTP_PDU_SequenceNumber */

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode uL_GTP_PDU_SequenceNumber */

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ReleasedItem (OSCTXT* pctxt, ranap_RAB_ReleasedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[4];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ReleasedItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 4; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_dataVolumes */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-dataVolumes");

      pvalue->m.dl_dataVolumesPresent = 1;

      stat = asn1PD_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dL_GTP_PDU_SequenceNumber */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dL-GTP-PDU-SequenceNumber");

      pvalue->m.dL_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode uL_GTP_PDU_SequenceNumber */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "uL-GTP-PDU-SequenceNumber");

      pvalue->m.uL_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->uL_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ReleasedItem (ranap_RAB_ReleasedItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_DataVolumeList (&pvalue->dl_dataVolumes);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ReleasedItem (OSCTXT *pctxt, 
   ranap_RAB_ReleasedItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dataVolumesPresent) {
      asn1Free_ranap_DataVolumeList (pctxt, &pvalue->dl_dataVolumes);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_QueuedItem (OSCTXT* pctxt, ranap_RAB_QueuedItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-QueuedItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_QueuedItem (OSCTXT* pctxt, ranap_RAB_QueuedItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-QueuedItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_QueuedItem (ranap_RAB_QueuedItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_QueuedItem (OSCTXT *pctxt, 
   ranap_RAB_QueuedItem* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (OSCTXT* pctxt, ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Iumode-RAB-Failed-RABAssgntResponse-Item");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.gERAN_ClassmarkPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode gERAN_Classmark */

   if (pvalue->m.gERAN_ClassmarkPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "gERAN-Classmark");

      stat = asn1PE_ranap_GERAN_Classmark (pctxt, pvalue->gERAN_Classmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (OSCTXT* pctxt, ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[2];

   RTXCTXTPUSHTYPENAME (pctxt, "GERAN-Iumode-RAB-Failed-RABAssgntResponse-Item");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 2; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gERAN_Classmark */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "gERAN-Classmark");

      pvalue->m.gERAN_ClassmarkPresent = 1;

      stat = asn1PD_ranap_GERAN_Classmark (pctxt, &pvalue->gERAN_Classmark);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (
   ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_GERAN_Classmark (&pvalue->gERAN_Classmark);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item (OSCTXT *pctxt, 
   ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.gERAN_ClassmarkPresent) {
      asn1Free_ranap_GERAN_Classmark (pctxt, &pvalue->gERAN_Classmark);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_PrivateMessage (OSCTXT* pctxt, ranap_PrivateMessage* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode privateIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PE_ranap_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_PrivateMessage (OSCTXT* pctxt, ranap_PrivateMessage* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateMessage");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (&pvalue->extElem1);

   /* decode root elements */
   /* decode privateIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "privateIEs");

   stat = asn1PD_ranap_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_PrivateMessage (ranap_PrivateMessage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   asn1Init_ranap_PrivateIE_Container (&pvalue->privateIEs);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_PrivateMessage (OSCTXT *pctxt, 
   ranap_PrivateMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_PrivateIE_Container (pctxt, &pvalue->privateIEs);
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RANAP_RelocationInformation (OSCTXT* pctxt, ranap_RANAP_RelocationInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-RelocationInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RANAP_RelocationInformation (OSCTXT* pctxt, ranap_RANAP_RelocationInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-RelocationInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RANAP_RelocationInformation (
   ranap_RANAP_RelocationInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RANAP_RelocationInformation (OSCTXT *pctxt, 
   ranap_RANAP_RelocationInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DirectTransferInformationItem_RANAP_RelocInf (OSCTXT* pctxt, ranap_DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransferInformationItem-RANAP-RelocInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode nAS_PDU */

   RTXCTXTPUSHELEMNAME (pctxt, "nAS-PDU");

   stat = asn1PE_ranap_NAS_PDU (pctxt, pvalue->nAS_PDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode sAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "sAPI");

   stat = asn1PE_ranap_SAPI (pctxt, pvalue->sAPI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cN_DomainIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PE_ranap_CN_DomainIndicator (pctxt, pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectTransferInformationItem_RANAP_RelocInf (OSCTXT* pctxt, ranap_DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DirectTransferInformationItem-RANAP-RelocInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode nAS_PDU */
   RTXCTXTPUSHELEMNAME (pctxt, "nAS-PDU");

   stat = asn1PD_ranap_NAS_PDU (pctxt, &pvalue->nAS_PDU);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sAPI */
   RTXCTXTPUSHELEMNAME (pctxt, "sAPI");

   stat = asn1PD_ranap_SAPI (pctxt, &pvalue->sAPI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cN_DomainIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PD_ranap_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DirectTransferInformationItem_RANAP_RelocInf (
   ranap_DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_NAS_PDU (&pvalue->nAS_PDU);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DirectTransferInformationItem_RANAP_RelocInf (OSCTXT *pctxt, 
   ranap_DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_NAS_PDU (pctxt, &pvalue->nAS_PDU);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ContextItem_RANAP_RelocInf (OSCTXT* pctxt, ranap_RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextItem-RANAP-RelocInf");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_GTP_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dl_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ul_N_PDU_SequenceNumberPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_GTP_PDU_SequenceNumber */

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_GTP_PDU_SequenceNumber (pctxt, pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_GTP_PDU_SequenceNumber */

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_GTP_PDU_SequenceNumber (pctxt, pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode dl_N_PDU_SequenceNumber */

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_DL_N_PDU_SequenceNumber (pctxt, pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ul_N_PDU_SequenceNumber */

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      stat = asn1PE_ranap_UL_N_PDU_SequenceNumber (pctxt, pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ContextItem_RANAP_RelocInf (OSCTXT* pctxt, ranap_RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[5];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ContextItem-RANAP-RelocInf");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 5; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_GTP_PDU_SequenceNumber */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-GTP-PDU-SequenceNumber");

      pvalue->m.dl_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_GTP_PDU_SequenceNumber (pctxt, &pvalue->dl_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_GTP_PDU_SequenceNumber */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-GTP-PDU-SequenceNumber");

      pvalue->m.ul_GTP_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_GTP_PDU_SequenceNumber (pctxt, &pvalue->ul_GTP_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode dl_N_PDU_SequenceNumber */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dl-N-PDU-SequenceNumber");

      pvalue->m.dl_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_DL_N_PDU_SequenceNumber (pctxt, &pvalue->dl_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ul_N_PDU_SequenceNumber */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ul-N-PDU-SequenceNumber");

      pvalue->m.ul_N_PDU_SequenceNumberPresent = 1;

      stat = asn1PD_ranap_UL_N_PDU_SequenceNumber (pctxt, &pvalue->ul_N_PDU_SequenceNumber);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ContextItem_RANAP_RelocInf (
   ranap_RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ContextItem_RANAP_RelocInf (OSCTXT *pctxt, 
   ranap_RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RANAP_EnhancedRelocationInformationRequest (OSCTXT* pctxt, ranap_RANAP_EnhancedRelocationInformationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-EnhancedRelocationInformationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RANAP_EnhancedRelocationInformationRequest (OSCTXT* pctxt, ranap_RANAP_EnhancedRelocationInformationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-EnhancedRelocationInformationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RANAP_EnhancedRelocationInformationRequest (
   ranap_RANAP_EnhancedRelocationInformationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RANAP_EnhancedRelocationInformationRequest (OSCTXT *pctxt, 
   ranap_RANAP_EnhancedRelocationInformationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TNLInformationEnhRelInfoReq (OSCTXT* pctxt, ranap_TNLInformationEnhRelInfoReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLInformationEnhRelInfoReq");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode transportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iuTransportAssociation */

   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TNLInformationEnhRelInfoReq (OSCTXT* pctxt, ranap_TNLInformationEnhRelInfoReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TNLInformationEnhRelInfoReq");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode transportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "transportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iuTransportAssociation */
   RTXCTXTPUSHELEMNAME (pctxt, "iuTransportAssociation");

   stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TNLInformationEnhRelInfoReq (
   ranap_TNLInformationEnhRelInfoReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TransportLayerAddress (&pvalue->transportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->iuTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TNLInformationEnhRelInfoReq (OSCTXT *pctxt, 
   ranap_TNLInformationEnhRelInfoReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->transportLayerAddress);
   asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->iuTransportAssociation);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_EnhRelocInfoReq (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhRelocInfoReq* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhRelocInfoReq");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataVolumeReportingIndicationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.pDP_TypeInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataForwardingInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.sourceSideIuULTNLInfoPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.service_HandoverPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.alt_RAB_ParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cN_DomainIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PE_ranap_CN_DomainIndicator (pctxt, pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAB_Parameters */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

   stat = asn1PE_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataVolumeReportingIndication */

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      stat = asn1PE_ranap_DataVolumeReportingIndication (pctxt, pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode pDP_TypeInformation */

   if (pvalue->m.pDP_TypeInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      stat = asn1PE_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode userPlaneInformation */

   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PE_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataForwardingInformation */

   if (pvalue->m.dataForwardingInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingInformation");

      stat = asn1PE_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->dataForwardingInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode sourceSideIuULTNLInfo */

   if (pvalue->m.sourceSideIuULTNLInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceSideIuULTNLInfo");

      stat = asn1PE_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->sourceSideIuULTNLInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode service_Handover */

   if (pvalue->m.service_HandoverPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      stat = asn1PE_ranap_Service_Handover (pctxt, pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode alt_RAB_Parameters */

   if (pvalue->m.alt_RAB_ParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "alt-RAB-Parameters");

      stat = asn1PE_ranap_Alt_RAB_Parameters (pctxt, &pvalue->alt_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_EnhRelocInfoReq (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhRelocInfoReq* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[7];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhRelocInfoReq");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 7; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cN_DomainIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PD_ranap_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAB_Parameters */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-Parameters");

   stat = asn1PD_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataVolumeReportingIndication */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataVolumeReportingIndication");

      pvalue->m.dataVolumeReportingIndicationPresent = 1;

      stat = asn1PD_ranap_DataVolumeReportingIndication (pctxt, &pvalue->dataVolumeReportingIndication);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode pDP_TypeInformation */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "pDP-TypeInformation");

      pvalue->m.pDP_TypeInformationPresent = 1;

      stat = asn1PD_ranap_PDP_TypeInformation (pctxt, &pvalue->pDP_TypeInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode userPlaneInformation */
   RTXCTXTPUSHELEMNAME (pctxt, "userPlaneInformation");

   stat = asn1PD_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataForwardingInformation */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingInformation");

      pvalue->m.dataForwardingInformationPresent = 1;

      stat = asn1PD_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->dataForwardingInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode sourceSideIuULTNLInfo */
   if (optbits[3]) {
      RTXCTXTPUSHELEMNAME (pctxt, "sourceSideIuULTNLInfo");

      pvalue->m.sourceSideIuULTNLInfoPresent = 1;

      stat = asn1PD_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->sourceSideIuULTNLInfo);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode service_Handover */
   if (optbits[4]) {
      RTXCTXTPUSHELEMNAME (pctxt, "service-Handover");

      pvalue->m.service_HandoverPresent = 1;

      stat = asn1PD_ranap_Service_Handover (pctxt, &pvalue->service_Handover);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode alt_RAB_Parameters */
   if (optbits[5]) {
      RTXCTXTPUSHELEMNAME (pctxt, "alt-RAB-Parameters");

      pvalue->m.alt_RAB_ParametersPresent = 1;

      stat = asn1PD_ranap_Alt_RAB_Parameters (pctxt, &pvalue->alt_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[6]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_EnhRelocInfoReq (
   ranap_RAB_SetupItem_EnhRelocInfoReq* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_RAB_Parameters (&pvalue->rAB_Parameters);
   asn1Init_ranap_PDP_TypeInformation (&pvalue->pDP_TypeInformation);
   asn1Init_ranap_UserPlaneInformation (&pvalue->userPlaneInformation);
   asn1Init_ranap_TNLInformationEnhRelInfoReq (&pvalue->dataForwardingInformation);
   asn1Init_ranap_TNLInformationEnhRelInfoReq (&pvalue->sourceSideIuULTNLInfo);
   asn1Init_ranap_Alt_RAB_Parameters (&pvalue->alt_RAB_Parameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_EnhRelocInfoReq (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_EnhRelocInfoReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_RAB_Parameters (pctxt, &pvalue->rAB_Parameters);
   asn1Free_ranap_UserPlaneInformation (pctxt, &pvalue->userPlaneInformation);
   if (pvalue->m.dataForwardingInformationPresent) {
      asn1Free_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->dataForwardingInformation);
   }
   if (pvalue->m.sourceSideIuULTNLInfoPresent) {
      asn1Free_ranap_TNLInformationEnhRelInfoReq (pctxt, &pvalue->sourceSideIuULTNLInfo);
   }
   if (pvalue->m.alt_RAB_ParametersPresent) {
      asn1Free_ranap_Alt_RAB_Parameters (pctxt, &pvalue->alt_RAB_Parameters);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RANAP_EnhancedRelocationInformationResponse (OSCTXT* pctxt, ranap_RANAP_EnhancedRelocationInformationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-EnhancedRelocationInformationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RANAP_EnhancedRelocationInformationResponse (OSCTXT* pctxt, ranap_RANAP_EnhancedRelocationInformationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-EnhancedRelocationInformationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RANAP_EnhancedRelocationInformationResponse (
   ranap_RANAP_EnhancedRelocationInformationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RANAP_EnhancedRelocationInformationResponse (OSCTXT *pctxt, 
   ranap_RANAP_EnhancedRelocationInformationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_TNLInformationEnhRelInfoRes (OSCTXT* pctxt, ranap_TNLInformationEnhRelInfoRes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "TNLInformationEnhRelInfoRes");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode dl_forwardingTransportLayerAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-forwardingTransportLayerAddress");

   stat = asn1PE_ranap_TransportLayerAddress (pctxt, pvalue->dl_forwardingTransportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dl_forwardingTransportAssociation */

   RTXCTXTPUSHELEMNAME (pctxt, "dl-forwardingTransportAssociation");

   stat = asn1PE_ranap_IuTransportAssociation (pctxt, &pvalue->dl_forwardingTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_TNLInformationEnhRelInfoRes (OSCTXT* pctxt, ranap_TNLInformationEnhRelInfoRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "TNLInformationEnhRelInfoRes");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode dl_forwardingTransportLayerAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-forwardingTransportLayerAddress");

   stat = asn1PD_ranap_TransportLayerAddress (pctxt, &pvalue->dl_forwardingTransportLayerAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dl_forwardingTransportAssociation */
   RTXCTXTPUSHELEMNAME (pctxt, "dl-forwardingTransportAssociation");

   stat = asn1PD_ranap_IuTransportAssociation (pctxt, &pvalue->dl_forwardingTransportAssociation);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_TNLInformationEnhRelInfoRes (
   ranap_TNLInformationEnhRelInfoRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TransportLayerAddress (&pvalue->dl_forwardingTransportLayerAddress);
   asn1Init_ranap_IuTransportAssociation (&pvalue->dl_forwardingTransportAssociation);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_TNLInformationEnhRelInfoRes (OSCTXT *pctxt, 
   ranap_TNLInformationEnhRelInfoRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TransportLayerAddress (pctxt, &pvalue->dl_forwardingTransportLayerAddress);
   asn1Free_ranap_IuTransportAssociation (pctxt, &pvalue->dl_forwardingTransportAssociation);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_SetupItem_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhRelocInfoRes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhRelocInfoRes");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.dataForwardingInformationPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.ass_RAB_ParametersPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cN_DomainIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PE_ranap_CN_DomainIndicator (pctxt, pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode dataForwardingInformation */

   if (pvalue->m.dataForwardingInformationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingInformation");

      stat = asn1PE_ranap_TNLInformationEnhRelInfoRes (pctxt, &pvalue->dataForwardingInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode ass_RAB_Parameters */

   if (pvalue->m.ass_RAB_ParametersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "ass-RAB-Parameters");

      stat = asn1PE_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_SetupItem_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_SetupItem_EnhRelocInfoRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[3];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-SetupItem-EnhRelocInfoRes");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 3; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cN_DomainIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PD_ranap_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode dataForwardingInformation */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "dataForwardingInformation");

      pvalue->m.dataForwardingInformationPresent = 1;

      stat = asn1PD_ranap_TNLInformationEnhRelInfoRes (pctxt, &pvalue->dataForwardingInformation);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode ass_RAB_Parameters */
   if (optbits[1]) {
      RTXCTXTPUSHELEMNAME (pctxt, "ass-RAB-Parameters");

      pvalue->m.ass_RAB_ParametersPresent = 1;

      stat = asn1PD_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode iE_Extensions */
   if (optbits[2]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_SetupItem_EnhRelocInfoRes (
   ranap_RAB_SetupItem_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_TNLInformationEnhRelInfoRes (&pvalue->dataForwardingInformation);
   asn1Init_ranap_Ass_RAB_Parameters (&pvalue->ass_RAB_Parameters);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_SetupItem_EnhRelocInfoRes (OSCTXT *pctxt, 
   ranap_RAB_SetupItem_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dataForwardingInformationPresent) {
      asn1Free_ranap_TNLInformationEnhRelInfoRes (pctxt, &pvalue->dataForwardingInformation);
   }
   if (pvalue->m.ass_RAB_ParametersPresent) {
      asn1Free_ranap_Ass_RAB_Parameters (pctxt, &pvalue->ass_RAB_Parameters);
   }
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_FailedItem_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_FailedItem_EnhRelocInfoRes* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedItem-EnhRelocInfoRes");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode cN_DomainIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PE_ranap_CN_DomainIndicator (pctxt, pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_FailedItem_EnhRelocInfoRes (OSCTXT* pctxt, ranap_RAB_FailedItem_EnhRelocInfoRes* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-FailedItem-EnhRelocInfoRes");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode cN_DomainIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "cN-DomainIndicator");

   stat = asn1PD_ranap_CN_DomainIndicator (pctxt, &pvalue->cN_DomainIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_FailedItem_EnhRelocInfoRes (
   ranap_RAB_FailedItem_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_FailedItem_EnhRelocInfoRes (OSCTXT *pctxt, 
   ranap_RAB_FailedItem_EnhRelocInfoRes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ModifyRequest (OSCTXT* pctxt, ranap_RAB_ModifyRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ModifyRequest (OSCTXT* pctxt, ranap_RAB_ModifyRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ModifyRequest (ranap_RAB_ModifyRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ModifyRequest (OSCTXT *pctxt, 
   ranap_RAB_ModifyRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RAB_ModifyItem (OSCTXT* pctxt, ranap_RAB_ModifyItem* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyItem");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode rAB_ID */

   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PE_ranap_RAB_ID (pctxt, pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode requested_RAB_Parameter_Values */

   RTXCTXTPUSHELEMNAME (pctxt, "requested-RAB-Parameter-Values");

   stat = asn1PE_ranap_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RAB_ModifyItem (OSCTXT* pctxt, ranap_RAB_ModifyItem* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RAB-ModifyItem");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode rAB_ID */
   RTXCTXTPUSHELEMNAME (pctxt, "rAB-ID");

   stat = asn1PD_ranap_RAB_ID (pctxt, &pvalue->rAB_ID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requested_RAB_Parameter_Values */
   RTXCTXTPUSHELEMNAME (pctxt, "requested-RAB-Parameter-Values");

   stat = asn1PD_ranap_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RAB_ModifyItem (ranap_RAB_ModifyItem* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_RAB_ID (&pvalue->rAB_ID);
   asn1Init_ranap_Requested_RAB_Parameter_Values (&pvalue->requested_RAB_Parameter_Values);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RAB_ModifyItem (OSCTXT *pctxt, 
   ranap_RAB_ModifyItem* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_Requested_RAB_Parameter_Values (pctxt, &pvalue->requested_RAB_Parameter_Values);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationRelatedDataRequest (OSCTXT* pctxt, ranap_LocationRelatedDataRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationRelatedDataRequest (OSCTXT* pctxt, ranap_LocationRelatedDataRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationRelatedDataRequest (
   ranap_LocationRelatedDataRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationRelatedDataRequest (OSCTXT *pctxt, 
   ranap_LocationRelatedDataRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationRelatedDataResponse (OSCTXT* pctxt, ranap_LocationRelatedDataResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationRelatedDataResponse (OSCTXT* pctxt, ranap_LocationRelatedDataResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationRelatedDataResponse (
   ranap_LocationRelatedDataResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationRelatedDataResponse (OSCTXT *pctxt, 
   ranap_LocationRelatedDataResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LocationRelatedDataFailure (OSCTXT* pctxt, ranap_LocationRelatedDataFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LocationRelatedDataFailure (OSCTXT* pctxt, ranap_LocationRelatedDataFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "LocationRelatedDataFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LocationRelatedDataFailure (
   ranap_LocationRelatedDataFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LocationRelatedDataFailure (OSCTXT *pctxt, 
   ranap_LocationRelatedDataFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_InformationTransferIndication (OSCTXT* pctxt, ranap_InformationTransferIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationTransferIndication (OSCTXT* pctxt, ranap_InformationTransferIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationTransferIndication (
   ranap_InformationTransferIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InformationTransferIndication (OSCTXT *pctxt, 
   ranap_InformationTransferIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_InformationTransferConfirmation (OSCTXT* pctxt, ranap_InformationTransferConfirmation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferConfirmation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationTransferConfirmation (OSCTXT* pctxt, ranap_InformationTransferConfirmation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferConfirmation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationTransferConfirmation (
   ranap_InformationTransferConfirmation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InformationTransferConfirmation (OSCTXT *pctxt, 
   ranap_InformationTransferConfirmation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_InformationTransferFailure (OSCTXT* pctxt, ranap_InformationTransferFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InformationTransferFailure (OSCTXT* pctxt, ranap_InformationTransferFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "InformationTransferFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InformationTransferFailure (
   ranap_InformationTransferFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_InformationTransferFailure (OSCTXT *pctxt, 
   ranap_InformationTransferFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UESpecificInformationIndication (OSCTXT* pctxt, ranap_UESpecificInformationIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UESpecificInformationIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UESpecificInformationIndication (OSCTXT* pctxt, ranap_UESpecificInformationIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UESpecificInformationIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UESpecificInformationIndication (
   ranap_UESpecificInformationIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UESpecificInformationIndication (OSCTXT *pctxt, 
   ranap_UESpecificInformationIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_DirectInformationTransfer (OSCTXT* pctxt, ranap_DirectInformationTransfer* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectInformationTransfer");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_DirectInformationTransfer (OSCTXT* pctxt, ranap_DirectInformationTransfer* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "DirectInformationTransfer");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_DirectInformationTransfer (
   ranap_DirectInformationTransfer* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_DirectInformationTransfer (OSCTXT *pctxt, 
   ranap_DirectInformationTransfer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UplinkInformationExchangeRequest (OSCTXT* pctxt, ranap_UplinkInformationExchangeRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UplinkInformationExchangeRequest (OSCTXT* pctxt, ranap_UplinkInformationExchangeRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UplinkInformationExchangeRequest (
   ranap_UplinkInformationExchangeRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UplinkInformationExchangeRequest (OSCTXT *pctxt, 
   ranap_UplinkInformationExchangeRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UplinkInformationExchangeResponse (OSCTXT* pctxt, ranap_UplinkInformationExchangeResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UplinkInformationExchangeResponse (OSCTXT* pctxt, ranap_UplinkInformationExchangeResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UplinkInformationExchangeResponse (
   ranap_UplinkInformationExchangeResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UplinkInformationExchangeResponse (OSCTXT *pctxt, 
   ranap_UplinkInformationExchangeResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UplinkInformationExchangeFailure (OSCTXT* pctxt, ranap_UplinkInformationExchangeFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UplinkInformationExchangeFailure (OSCTXT* pctxt, ranap_UplinkInformationExchangeFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UplinkInformationExchangeFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UplinkInformationExchangeFailure (
   ranap_UplinkInformationExchangeFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UplinkInformationExchangeFailure (OSCTXT *pctxt, 
   ranap_UplinkInformationExchangeFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionStart (OSCTXT* pctxt, ranap_MBMSSessionStart* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStart");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionStart (OSCTXT* pctxt, ranap_MBMSSessionStart* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStart");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionStart (ranap_MBMSSessionStart* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionStart (OSCTXT *pctxt, 
   ranap_MBMSSessionStart* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSynchronisationInformation (OSCTXT* pctxt, ranap_MBMSSynchronisationInformation* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSynchronisationInformation");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode mBMSHCIndicator */

   RTXCTXTPUSHELEMNAME (pctxt, "mBMSHCIndicator");

   stat = asn1PE_ranap_MBMSHCIndicator (pctxt, pvalue->mBMSHCIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iPMulticastAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "iPMulticastAddress");

   stat = asn1PE_ranap_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode gTPDLTEID */

   RTXCTXTPUSHELEMNAME (pctxt, "gTPDLTEID");

   stat = asn1PE_ranap_GTP_TEI (pctxt, &pvalue->gTPDLTEID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSynchronisationInformation (OSCTXT* pctxt, ranap_MBMSSynchronisationInformation* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSynchronisationInformation");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode mBMSHCIndicator */
   RTXCTXTPUSHELEMNAME (pctxt, "mBMSHCIndicator");

   stat = asn1PD_ranap_MBMSHCIndicator (pctxt, &pvalue->mBMSHCIndicator);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iPMulticastAddress */
   RTXCTXTPUSHELEMNAME (pctxt, "iPMulticastAddress");

   stat = asn1PD_ranap_IPMulticastAddress (pctxt, &pvalue->iPMulticastAddress);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gTPDLTEID */
   RTXCTXTPUSHELEMNAME (pctxt, "gTPDLTEID");

   stat = asn1PD_ranap_GTP_TEI (pctxt, &pvalue->gTPDLTEID);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSynchronisationInformation (
   ranap_MBMSSynchronisationInformation* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_IPMulticastAddress (&pvalue->iPMulticastAddress);
   asn1Init_ranap_GTP_TEI (&pvalue->gTPDLTEID);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSynchronisationInformation (OSCTXT *pctxt, 
   ranap_MBMSSynchronisationInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionStartResponse (OSCTXT* pctxt, ranap_MBMSSessionStartResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStartResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionStartResponse (OSCTXT* pctxt, ranap_MBMSSessionStartResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStartResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionStartResponse (
   ranap_MBMSSessionStartResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionStartResponse (OSCTXT *pctxt, 
   ranap_MBMSSessionStartResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionStartFailure (OSCTXT* pctxt, ranap_MBMSSessionStartFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStartFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionStartFailure (OSCTXT* pctxt, ranap_MBMSSessionStartFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStartFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionStartFailure (
   ranap_MBMSSessionStartFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionStartFailure (OSCTXT *pctxt, 
   ranap_MBMSSessionStartFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionUpdate (OSCTXT* pctxt, ranap_MBMSSessionUpdate* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdate");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionUpdate (OSCTXT* pctxt, ranap_MBMSSessionUpdate* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdate");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionUpdate (ranap_MBMSSessionUpdate* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionUpdate (OSCTXT *pctxt, 
   ranap_MBMSSessionUpdate* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionUpdateResponse (OSCTXT* pctxt, ranap_MBMSSessionUpdateResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdateResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionUpdateResponse (OSCTXT* pctxt, ranap_MBMSSessionUpdateResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdateResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionUpdateResponse (
   ranap_MBMSSessionUpdateResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionUpdateResponse (OSCTXT *pctxt, 
   ranap_MBMSSessionUpdateResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionUpdateFailure (OSCTXT* pctxt, ranap_MBMSSessionUpdateFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdateFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionUpdateFailure (OSCTXT* pctxt, ranap_MBMSSessionUpdateFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionUpdateFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionUpdateFailure (
   ranap_MBMSSessionUpdateFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionUpdateFailure (OSCTXT *pctxt, 
   ranap_MBMSSessionUpdateFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionStop (OSCTXT* pctxt, ranap_MBMSSessionStop* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStop");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionStop (OSCTXT* pctxt, ranap_MBMSSessionStop* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStop");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionStop (ranap_MBMSSessionStop* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionStop (OSCTXT *pctxt, 
   ranap_MBMSSessionStop* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSSessionStopResponse (OSCTXT* pctxt, ranap_MBMSSessionStopResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStopResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSSessionStopResponse (OSCTXT* pctxt, ranap_MBMSSessionStopResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSSessionStopResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSSessionStopResponse (
   ranap_MBMSSessionStopResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSSessionStopResponse (OSCTXT *pctxt, 
   ranap_MBMSSessionStopResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSUELinkingRequest (OSCTXT* pctxt, ranap_MBMSUELinkingRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSUELinkingRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSUELinkingRequest (OSCTXT* pctxt, ranap_MBMSUELinkingRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSUELinkingRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSUELinkingRequest (ranap_MBMSUELinkingRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSUELinkingRequest (OSCTXT *pctxt, 
   ranap_MBMSUELinkingRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LeftMBMSBearerService_IEs_element (OSCTXT* pctxt, ranap_LeftMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tMGI */

   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PE_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_LeftMBMSBearerService_IEs_element (OSCTXT* pctxt, ranap_LeftMBMSBearerService_IEs_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tMGI */
   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PD_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_LeftMBMSBearerService_IEs_element (
   ranap_LeftMBMSBearerService_IEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TMGI (&pvalue->tMGI);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_LeftMBMSBearerService_IEs_element (OSCTXT *pctxt, 
   ranap_LeftMBMSBearerService_IEs_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_LeftMBMSBearerService_IEs (OSCTXT* pctxt, ranap_LeftMBMSBearerService_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "LeftMBMSBearerService-IEs");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_LeftMBMSBearerService_IEs_element (pctxt, ((ranap_LeftMBMSBearerService_IEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_LeftMBMSBearerService_IEs (OSCTXT* pctxt, ranap_LeftMBMSBearerService_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LeftMBMSBearerService-IEs");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_LeftMBMSBearerService_IEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_LeftMBMSBearerService_IEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_LeftMBMSBearerService_IEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_LeftMBMSBearerService_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_LeftMBMSBearerService_IEs (
   ranap_LeftMBMSBearerService_IEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_LeftMBMSBearerService_IEs (OSCTXT *pctxt, 
   ranap_LeftMBMSBearerService_IEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_LeftMBMSBearerService_IEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_LeftMBMSBearerService_IEs_element*)pnode->data;
      asn1Free_ranap_LeftMBMSBearerService_IEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_MBMSUELinkingResponse (OSCTXT* pctxt, ranap_MBMSUELinkingResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSUELinkingResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSUELinkingResponse (OSCTXT* pctxt, ranap_MBMSUELinkingResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSUELinkingResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSUELinkingResponse (ranap_MBMSUELinkingResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSUELinkingResponse (OSCTXT *pctxt, 
   ranap_MBMSUELinkingResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UnsuccessfulLinking_IEs_element (OSCTXT* pctxt, ranap_UnsuccessfulLinking_IEs_element* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.iE_ExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode tMGI */

   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PE_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PE_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode iE_Extensions */

   if (pvalue->m.iE_ExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   return (stat);
}

EXTERN int asn1PD_ranap_UnsuccessfulLinking_IEs_element (OSCTXT* pctxt, ranap_UnsuccessfulLinking_IEs_element* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode tMGI */
   RTXCTXTPUSHELEMNAME (pctxt, "tMGI");

   stat = asn1PD_ranap_TMGI (pctxt, &pvalue->tMGI);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */
   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   stat = asn1PD_ranap_Cause (pctxt, &pvalue->cause);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode iE_Extensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "iE-Extensions");

      pvalue->m.iE_ExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   return (stat);
}

int asn1Init_ranap_UnsuccessfulLinking_IEs_element (
   ranap_UnsuccessfulLinking_IEs_element* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_TMGI (&pvalue->tMGI);
   asn1Init_ranap_Cause (&pvalue->cause);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->iE_Extensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UnsuccessfulLinking_IEs_element (OSCTXT *pctxt, 
   ranap_UnsuccessfulLinking_IEs_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_TMGI (pctxt, &pvalue->tMGI);
   asn1Free_ranap_Cause (pctxt, &pvalue->cause);
   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->iE_Extensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UnsuccessfulLinking_IEs (OSCTXT* pctxt, ranap_UnsuccessfulLinking_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulLinking-IEs");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      stat = asn1PE_ranap_UnsuccessfulLinking_IEs_element (pctxt, ((ranap_UnsuccessfulLinking_IEs_element*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UnsuccessfulLinking_IEs (OSCTXT* pctxt, ranap_UnsuccessfulLinking_IEs* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulLinking-IEs");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(128), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_UnsuccessfulLinking_IEs_element* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_UnsuccessfulLinking_IEs_element, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_UnsuccessfulLinking_IEs_element (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_UnsuccessfulLinking_IEs_element (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UnsuccessfulLinking_IEs (
   ranap_UnsuccessfulLinking_IEs* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_UnsuccessfulLinking_IEs (OSCTXT *pctxt, 
   ranap_UnsuccessfulLinking_IEs* pvalue)
{
   if (0 == pvalue) return;
   { ranap_UnsuccessfulLinking_IEs_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_UnsuccessfulLinking_IEs_element*)pnode->data;
      asn1Free_ranap_UnsuccessfulLinking_IEs_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

EXTERN int asn1PE_ranap_MBMSRegistrationRequest (OSCTXT* pctxt, ranap_MBMSRegistrationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRegistrationRequest (OSCTXT* pctxt, ranap_MBMSRegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRegistrationRequest (
   ranap_MBMSRegistrationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRegistrationRequest (OSCTXT *pctxt, 
   ranap_MBMSRegistrationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRegistrationResponse (OSCTXT* pctxt, ranap_MBMSRegistrationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRegistrationResponse (OSCTXT* pctxt, ranap_MBMSRegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRegistrationResponse (
   ranap_MBMSRegistrationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRegistrationResponse (OSCTXT *pctxt, 
   ranap_MBMSRegistrationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRegistrationFailure (OSCTXT* pctxt, ranap_MBMSRegistrationFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRegistrationFailure (OSCTXT* pctxt, ranap_MBMSRegistrationFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRegistrationFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRegistrationFailure (
   ranap_MBMSRegistrationFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRegistrationFailure (OSCTXT *pctxt, 
   ranap_MBMSRegistrationFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSCNDe_RegistrationRequest (OSCTXT* pctxt, ranap_MBMSCNDe_RegistrationRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-RegistrationRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSCNDe_RegistrationRequest (OSCTXT* pctxt, ranap_MBMSCNDe_RegistrationRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-RegistrationRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSCNDe_RegistrationRequest (
   ranap_MBMSCNDe_RegistrationRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSCNDe_RegistrationRequest (OSCTXT *pctxt, 
   ranap_MBMSCNDe_RegistrationRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSCNDe_RegistrationResponse (OSCTXT* pctxt, ranap_MBMSCNDe_RegistrationResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-RegistrationResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSCNDe_RegistrationResponse (OSCTXT* pctxt, ranap_MBMSCNDe_RegistrationResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSCNDe-RegistrationResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSCNDe_RegistrationResponse (
   ranap_MBMSCNDe_RegistrationResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSCNDe_RegistrationResponse (OSCTXT *pctxt, 
   ranap_MBMSCNDe_RegistrationResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRABEstablishmentIndication (OSCTXT* pctxt, ranap_MBMSRABEstablishmentIndication* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABEstablishmentIndication");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRABEstablishmentIndication (OSCTXT* pctxt, ranap_MBMSRABEstablishmentIndication* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABEstablishmentIndication");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRABEstablishmentIndication (
   ranap_MBMSRABEstablishmentIndication* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRABEstablishmentIndication (OSCTXT *pctxt, 
   ranap_MBMSRABEstablishmentIndication* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRABReleaseRequest (OSCTXT* pctxt, ranap_MBMSRABReleaseRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABReleaseRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRABReleaseRequest (OSCTXT* pctxt, ranap_MBMSRABReleaseRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABReleaseRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRABReleaseRequest (ranap_MBMSRABReleaseRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRABReleaseRequest (OSCTXT *pctxt, 
   ranap_MBMSRABReleaseRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRABRelease (OSCTXT* pctxt, ranap_MBMSRABRelease* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABRelease");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRABRelease (OSCTXT* pctxt, ranap_MBMSRABRelease* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABRelease");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRABRelease (ranap_MBMSRABRelease* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRABRelease (OSCTXT *pctxt, 
   ranap_MBMSRABRelease* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_MBMSRABReleaseFailure (OSCTXT* pctxt, ranap_MBMSRABReleaseFailure* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABReleaseFailure");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_MBMSRABReleaseFailure (OSCTXT* pctxt, ranap_MBMSRABReleaseFailure* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "MBMSRABReleaseFailure");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_MBMSRABReleaseFailure (ranap_MBMSRABReleaseFailure* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_MBMSRABReleaseFailure (OSCTXT *pctxt, 
   ranap_MBMSRABReleaseFailure* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRVCC_CSKeysRequest (OSCTXT* pctxt, ranap_SRVCC_CSKeysRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-CSKeysRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_CSKeysRequest (OSCTXT* pctxt, ranap_SRVCC_CSKeysRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-CSKeysRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRVCC_CSKeysRequest (ranap_SRVCC_CSKeysRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRVCC_CSKeysRequest (OSCTXT *pctxt, 
   ranap_SRVCC_CSKeysRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_SRVCC_CSKeysResponse (OSCTXT* pctxt, ranap_SRVCC_CSKeysResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-CSKeysResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SRVCC_CSKeysResponse (OSCTXT* pctxt, ranap_SRVCC_CSKeysResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "SRVCC-CSKeysResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SRVCC_CSKeysResponse (ranap_SRVCC_CSKeysResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_SRVCC_CSKeysResponse (OSCTXT *pctxt, 
   ranap_SRVCC_CSKeysResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UeRadioCapabilityMatchRequest (OSCTXT* pctxt, ranap_UeRadioCapabilityMatchRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UeRadioCapabilityMatchRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UeRadioCapabilityMatchRequest (OSCTXT* pctxt, ranap_UeRadioCapabilityMatchRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UeRadioCapabilityMatchRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UeRadioCapabilityMatchRequest (
   ranap_UeRadioCapabilityMatchRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UeRadioCapabilityMatchRequest (OSCTXT *pctxt, 
   ranap_UeRadioCapabilityMatchRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UeRadioCapabilityMatchResponse (OSCTXT* pctxt, ranap_UeRadioCapabilityMatchResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UeRadioCapabilityMatchResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UeRadioCapabilityMatchResponse (OSCTXT* pctxt, ranap_UeRadioCapabilityMatchResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UeRadioCapabilityMatchResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UeRadioCapabilityMatchResponse (
   ranap_UeRadioCapabilityMatchResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UeRadioCapabilityMatchResponse (OSCTXT *pctxt, 
   ranap_UeRadioCapabilityMatchResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UeRegistrationQueryRequest (OSCTXT* pctxt, ranap_UeRegistrationQueryRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UeRegistrationQueryRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UeRegistrationQueryRequest (OSCTXT* pctxt, ranap_UeRegistrationQueryRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UeRegistrationQueryRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UeRegistrationQueryRequest (
   ranap_UeRegistrationQueryRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UeRegistrationQueryRequest (OSCTXT *pctxt, 
   ranap_UeRegistrationQueryRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_UeRegistrationQueryResponse (OSCTXT* pctxt, ranap_UeRegistrationQueryResponse* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "UeRegistrationQueryResponse");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UeRegistrationQueryResponse (OSCTXT* pctxt, ranap_UeRegistrationQueryResponse* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "UeRegistrationQueryResponse");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UeRegistrationQueryResponse (
   ranap_UeRegistrationQueryResponse* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_UeRegistrationQueryResponse (OSCTXT *pctxt, 
   ranap_UeRegistrationQueryResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_RerouteNASRequest (OSCTXT* pctxt, ranap_RerouteNASRequest* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RerouteNASRequest");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->extElem1.count > 0);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   stat = rtxEncBit (pctxt, (OSBOOL)pvalue->m.protocolExtensionsPresent);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* encode protocolIEs */

   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PE_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode protocolExtensions */

   if (pvalue->m.protocolExtensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      stat = asn1PE_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   if (extbit) {

      /* encode extension optional bits length */

      stat = pe_SmallLength (pctxt, pvalue->extElem1.count);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode optional bits */

      stat = pe_OpenTypeExtBits (pctxt, &pvalue->extElem1);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* encode extension elements */

      if (pvalue->extElem1.count > 0) {
         stat = pe_OpenTypeExt (pctxt, &pvalue->extElem1);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RerouteNASRequest (OSCTXT* pctxt, ranap_RerouteNASRequest* pvalue)
{
   int stat = 0;
   ASN1OpenType openType;
   ASN1OpenType* pOpenType;
   OSUINT32 bitcnt;
   OSUINT32 i_;
   OSBOOL extbit = FALSE;
   OSBOOL optbits[1];

   RTXCTXTPUSHTYPENAME (pctxt, "RerouteNASRequest");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   rtxDListInit (&pvalue->extElem1);

   /* optional bits */

   for (i_ = 0; i_ < 1; i_++) {
      stat = DEC_BIT (pctxt, &optbits[i_]);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode root elements */
   /* decode protocolIEs */
   RTXCTXTPUSHELEMNAME (pctxt, "protocolIEs");

   stat = asn1PD_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protocolExtensions */
   if (optbits[0]) {
      RTXCTXTPUSHELEMNAME (pctxt, "protocolExtensions");

      pvalue->m.protocolExtensionsPresent = 1;

      stat = asn1PD_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   /* decode extension elements */
   if (extbit) {
      OSOCTET* poptbits;

      /* decode extension optional bits length */

      stat = pd_SmallLength (pctxt, &bitcnt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      poptbits = (OSOCTET*) rtxMemAlloc (pctxt, bitcnt);
      if (0 == poptbits) return LOG_RTERR (pctxt, RTERR_NOMEM);

      for (i_ = 0; i_ < bitcnt; i_++) {
         stat = DEC_BIT (pctxt, &poptbits[i_]);
         if (stat != 0)  {
            rtxMemFreePtr (pctxt, poptbits);
            return LOG_RTERR (pctxt, stat);
         }
      }

      for (i_ = 0; i_ < bitcnt; i_++) {
         if (stat != 0) break;
         if (poptbits[i_]) {
            stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);

            if (0 == stat) {
               pOpenType = rtxMemAllocType (pctxt, ASN1OpenType);
               if (0 != pOpenType) {
                  pOpenType->numocts = openType.numocts;
                  pOpenType->data = openType.data;
                  rtxDListAppend (pctxt, &pvalue->extElem1, pOpenType);
               }
               else stat = RTERR_NOMEM;
            }
            else {
               LOG_RTERR (pctxt, stat);
               break;
            }
         }
         else {  /* unknown element */
            rtxDListAppend (pctxt, &pvalue->extElem1, 0);
         }
      }

      rtxMemFreePtr (pctxt, poptbits);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RerouteNASRequest (ranap_RerouteNASRequest* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_ranap_ProtocolIE_Container (&pvalue->protocolIEs);
   asn1Init_ranap_ProtocolExtensionContainer (&pvalue->protocolExtensions);
   rtxDListFastInit (&pvalue->extElem1);
   return 0;
}

void asn1Free_ranap_RerouteNASRequest (OSCTXT *pctxt, 
   ranap_RerouteNASRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ranap_ProtocolIE_Container (pctxt, &pvalue->protocolIEs);
   if (pvalue->m.protocolExtensionsPresent) {
      asn1Free_ranap_ProtocolExtensionContainer (pctxt, &pvalue->protocolExtensions);
   }
   rtxMemFreeOpenSeqExt (pctxt, &pvalue->extElem1);
}

EXTERN int asn1PE_ranap_ProtocolError_IE_ContainerList (OSCTXT* pctxt, ranap_ProtocolError_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSUINT32 xx1;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolError-IE-ContainerList");

   /* encode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pe_Length (pctxt, pvalue->count);
   if (stat < 0) return LOG_RTERR (pctxt, stat);

   /* encode elements */

   xx1 = 0;
   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      stat = asn1PE_ranap_ProtocolIE_Container (pctxt, ((ranap_ProtocolIE_Container*)pnode->data));
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      xx1++;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_ProtocolError_IE_ContainerList (OSCTXT* pctxt, ranap_ProtocolError_IE_ContainerList* pvalue)
{
   int stat = 0;
   OSRTDListNode* pnode;
   OSSIZE count = 0;
   OSSIZE xx1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtocolError-IE-ContainerList");

   /* decode length determinant */

   PU_SETSIZECONSTRAINT (pctxt, OSUINTCONST(1), OSUINTCONST(256), 0, 0);

   stat = pd_Length64 (pctxt, &count);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   /* decode elements */

   rtxDListInit (pvalue);

   for (xx1 = 0; xx1 < count; xx1++) {
      ranap_ProtocolIE_Container* pdata;
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ProtocolIE-Container", xx1);

      rtxDListAllocNodeAndData (pctxt, ranap_ProtocolIE_Container, &pnode, &pdata);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ranap_ProtocolIE_Container (pdata);

      rtxDListAppendNode (pvalue, pnode);
      stat = asn1PD_ranap_ProtocolIE_Container (pctxt, pdata);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_ProtocolError_IE_ContainerList (
   ranap_ProtocolError_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   rtxDListFastInit (pvalue);
   return 0;
}

void asn1Free_ranap_ProtocolError_IE_ContainerList (OSCTXT *pctxt, 
   ranap_ProtocolError_IE_ContainerList* pvalue)
{
   if (0 == pvalue) return;
   { ranap_ProtocolIE_Container* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ranap_ProtocolIE_Container*)pnode->data;
      asn1Free_ranap_ProtocolIE_Container (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Print_ranap_RAB_IE_ContainerList 
   (const char* name, const ranap_RAB_IE_ContainerList* pvalue)
{
   ranap_ProtocolIE_Container* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_Container*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_Container (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAB_DataVolumeReportList 
   (const char* name, const ranap_RAB_DataVolumeReportList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ReleasedList_IuRelComp 
   (const char* name, const ranap_RAB_ReleasedList_IuRelComp* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_RelocationReleaseList 
   (const char* name, const ranap_RAB_RelocationReleaseList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_DataForwardingList 
   (const char* name, const ranap_RAB_DataForwardingList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_RelocReq 
   (const char* name, const ranap_RAB_SetupList_RelocReq* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_RelocReqAck 
   (const char* name, const ranap_RAB_SetupList_RelocReqAck* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_FailedList 
   (const char* name, const ranap_RAB_FailedList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_DataForwardingList_SRNS_CtxReq 
   (const char* name, const ranap_RAB_DataForwardingList_SRNS_CtxReq* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ContextList 
   (const char* name, const ranap_RAB_ContextList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ContextFailedtoTransferList 
   (const char* name, const ranap_RAB_ContextFailedtoTransferList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_DataVolumeReportRequestList 
   (const char* name, const ranap_RAB_DataVolumeReportRequestList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_FailedtoReportList 
   (const char* name, const ranap_RAB_FailedtoReportList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_IuSigConId_IE_ContainerList 
   (const char* name, const ranap_IuSigConId_IE_ContainerList* pvalue)
{
   ranap_ProtocolIE_Container* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_Container*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_Container (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_ResetResourceList 
   (const char* name, const ranap_ResetResourceList* pvalue)
{
   asn1Print_ranap_IuSigConId_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_ResetResourceAckList 
   (const char* name, const ranap_ResetResourceAckList* pvalue)
{
   asn1Print_ranap_IuSigConId_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ReleaseList 
   (const char* name, const ranap_RAB_ReleaseList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_EnhancedRelocCompleteReq 
   (const char* name, const ranap_RAB_SetupList_EnhancedRelocCompleteReq* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_EnhancedRelocCompleteRes 
   (const char* name, const ranap_RAB_SetupList_EnhancedRelocCompleteRes* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes 
   (const char* name, const ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RedirectionIndication 
   (const char* name, const ranap_RedirectionIndication* pvalue)
{
   asn1Print_ranap_ProtocolIE_Container (name, pvalue);
}

void asn1Print_ranap_RAB_IE_ContainerPairList 
   (const char* name, const ranap_RAB_IE_ContainerPairList* pvalue)
{
   ranap_ProtocolIE_ContainerPair* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_ContainerPair*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_ContainerPair (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAB_SetupOrModifyList 
   (const char* name, const ranap_RAB_SetupOrModifyList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerPairList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupOrModifiedList 
   (const char* name, const ranap_RAB_SetupOrModifiedList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ReleasedList 
   (const char* name, const ranap_RAB_ReleasedList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_QueuedList 
   (const char* name, const ranap_RAB_QueuedList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ReleaseFailedList 
   (const char* name, const ranap_RAB_ReleaseFailedList* pvalue)
{
   asn1Print_ranap_RAB_FailedList (name, pvalue);
}

void asn1Print_ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse 
   (const char* name, const ranap_GERAN_Iumode_RAB_FailedList_RABAssgntResponse* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_DirectTransfer_IE_ContainerList 
   (const char* name, const ranap_DirectTransfer_IE_ContainerList* pvalue)
{
   ranap_ProtocolIE_Container* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_Container*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_Container (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_DirectTransferInformationList_RANAP_RelocInf 
   (const char* name, const ranap_DirectTransferInformationList_RANAP_RelocInf* pvalue)
{
   asn1Print_ranap_DirectTransfer_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ContextList_RANAP_RelocInf 
   (const char* name, const ranap_RAB_ContextList_RANAP_RelocInf* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_EnhRelocInfoReq 
   (const char* name, const ranap_RAB_SetupList_EnhRelocInfoReq* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_SetupList_EnhRelocInfoRes 
   (const char* name, const ranap_RAB_SetupList_EnhRelocInfoRes* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_FailedList_EnhRelocInfoRes 
   (const char* name, const ranap_RAB_FailedList_EnhRelocInfoRes* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap_RAB_ModifyList 
   (const char* name, const ranap_RAB_ModifyList* pvalue)
{
   asn1Print_ranap_RAB_IE_ContainerList (name, pvalue);
}

void asn1Print_ranap__RerouteNASRequestIEs_Value 
   (const char* name, const void* pvalue_)
{
   const ranap__RerouteNASRequestIEs_Value* pvalue = (const ranap__RerouteNASRequestIEs_Value*) pvalue_;
   rtxPrintIndent ();
   rtxPrintHexStr (name, pvalue->numocts, pvalue->data);
}

void asn1Print_ranap_Iu_ReleaseCommand 
   (const char* name, const ranap_Iu_ReleaseCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Iu_ReleaseComplete 
   (const char* name, const ranap_Iu_ReleaseComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DataVolumeList_element 
   (const char* name, const ranap_DataVolumeList_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_UnsuccessfullyTransmittedDataVolume (
      "dl_UnsuccessfullyTransmittedDataVolume", &pvalue->
      dl_UnsuccessfullyTransmittedDataVolume);

   if (pvalue->m.dataVolumeReferencePresent) {
      asn1Print_ranap_DataVolumeReference ("dataVolumeReference", &pvalue->
         dataVolumeReference);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DataVolumeList 
   (const char* name, const ranap_DataVolumeList* pvalue)
{
   ranap_DataVolumeList_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_DataVolumeList_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_DataVolumeList_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_RAB_DataVolumeReportItem 
   (const char* name, const ranap_RAB_DataVolumeReportItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dl_UnsuccessfullyTransmittedDataVolumePresent) {
      asn1Print_ranap_DataVolumeList (
         "dl_UnsuccessfullyTransmittedDataVolume", &pvalue->
         dl_UnsuccessfullyTransmittedDataVolume);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ReleasedItem_IuRelComp 
   (const char* name, const ranap_RAB_ReleasedItem_IuRelComp* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_GTP_PDU_SequenceNumber ("dL_GTP_PDU_SequenceNumber", &
         pvalue->dL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_GTP_PDU_SequenceNumber ("uL_GTP_PDU_SequenceNumber", &
         pvalue->uL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationRequired 
   (const char* name, const ranap_RelocationRequired* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationCommand 
   (const char* name, const ranap_RelocationCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_RelocationReleaseItem 
   (const char* name, const ranap_RAB_RelocationReleaseItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_DataForwardingItem 
   (const char* name, const ranap_RAB_DataForwardingItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
      transportLayerAddress);

   asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue->
      iuTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationPreparationFailure 
   (const char* name, const ranap_RelocationPreparationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationRequest 
   (const char* name, const ranap_RelocationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UserPlaneInformation 
   (const char* name, const ranap_UserPlaneInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_UserPlaneMode ("userPlaneMode", &pvalue->userPlaneMode);

   asn1Print_ranap_UP_ModeVersions ("uP_ModeVersions", &pvalue->uP_ModeVersions
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_RelocReq 
   (const char* name, const ranap_RAB_SetupItem_RelocReq* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      asn1Print_ranap_NAS_SynchronisationIndicator (
         "nAS_SynchronisationIndicator", &pvalue->nAS_SynchronisationIndicator
         );
   }

   asn1Print_ranap_RAB_Parameters ("rAB_Parameters", &pvalue->rAB_Parameters);

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      asn1Print_ranap_DataVolumeReportingIndication (
         "dataVolumeReportingIndication", &pvalue->
         dataVolumeReportingIndication);
   }

   if (pvalue->m.pDP_TypeInformationPresent) {
      asn1Print_ranap_PDP_TypeInformation ("pDP_TypeInformation", &pvalue->
         pDP_TypeInformation);
   }

   asn1Print_ranap_UserPlaneInformation ("userPlaneInformation", &pvalue->
      userPlaneInformation);

   asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
      transportLayerAddress);

   asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue->
      iuTransportAssociation);

   if (pvalue->m.service_HandoverPresent) {
      asn1Print_ranap_Service_Handover ("service_Handover", &pvalue->
         service_Handover);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_JoinedMBMSBearerService_IEs_element 
   (const char* name, const ranap_JoinedMBMSBearerService_IEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TMGI ("tMGI", &pvalue->tMGI);

   asn1Print_ranap_MBMS_PTP_RAB_ID ("mBMS_PTP_RAB_ID", &pvalue->mBMS_PTP_RAB_ID
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_JoinedMBMSBearerService_IEs 
   (const char* name, const ranap_JoinedMBMSBearerService_IEs* pvalue)
{
   ranap_JoinedMBMSBearerService_IEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_JoinedMBMSBearerService_IEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_JoinedMBMSBearerService_IEs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_CNMBMSLinkingInformation 
   (const char* name, const ranap_CNMBMSLinkingInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_JoinedMBMSBearerService_IEs ("joinedMBMSBearerService_IEs", 
      &pvalue->joinedMBMSBearerService_IEs);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationRequestAcknowledge 
   (const char* name, const ranap_RelocationRequestAcknowledge* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_RelocReqAck 
   (const char* name, const ranap_RAB_SetupItem_RelocReqAck* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.transportLayerAddressPresent) {
      asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
         transportLayerAddress);
   }

   if (pvalue->m.iuTransportAssociationPresent) {
      asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue
         ->iuTransportAssociation);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_FailedItem 
   (const char* name, const ranap_RAB_FailedItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationFailure 
   (const char* name, const ranap_RelocationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationCancel 
   (const char* name, const ranap_RelocationCancel* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationCancelAcknowledge 
   (const char* name, const ranap_RelocationCancelAcknowledge* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRNS_ContextRequest 
   (const char* name, const ranap_SRNS_ContextRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_DataForwardingItem_SRNS_CtxReq 
   (const char* name, const ranap_RAB_DataForwardingItem_SRNS_CtxReq* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRNS_ContextResponse 
   (const char* name, const ranap_SRNS_ContextResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ContextItem 
   (const char* name, const ranap_RAB_ContextItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_GTP_PDU_SequenceNumber ("dl_GTP_PDU_SequenceNumber", &
         pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_GTP_PDU_SequenceNumber ("ul_GTP_PDU_SequenceNumber", &
         pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_N_PDU_SequenceNumber ("dl_N_PDU_SequenceNumber", &
         pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_N_PDU_SequenceNumber ("ul_N_PDU_SequenceNumber", &
         pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABs_ContextFailedtoTransferItem 
   (const char* name, const ranap_RABs_ContextFailedtoTransferItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SecurityModeCommand 
   (const char* name, const ranap_SecurityModeCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SecurityModeComplete 
   (const char* name, const ranap_SecurityModeComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SecurityModeReject 
   (const char* name, const ranap_SecurityModeReject* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DataVolumeReportRequest 
   (const char* name, const ranap_DataVolumeReportRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_DataVolumeReportRequestItem 
   (const char* name, const ranap_RAB_DataVolumeReportRequestItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DataVolumeReport 
   (const char* name, const ranap_DataVolumeReport* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RABs_failed_to_reportItem 
   (const char* name, const ranap_RABs_failed_to_reportItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Reset (const char* name, const ranap_Reset* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResetAcknowledge 
   (const char* name, const ranap_ResetAcknowledge* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResetResource 
   (const char* name, const ranap_ResetResource* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResetResourceItem 
   (const char* name, const ranap_ResetResourceItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_IuSignallingConnectionIdentifier ("iuSigConId", &pvalue->
      iuSigConId);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResetResourceAcknowledge 
   (const char* name, const ranap_ResetResourceAcknowledge* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ResetResourceAckItem 
   (const char* name, const ranap_ResetResourceAckItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_IuSignallingConnectionIdentifier ("iuSigConId", &pvalue->
      iuSigConId);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ReleaseRequest 
   (const char* name, const ranap_RAB_ReleaseRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ReleaseItem 
   (const char* name, const ranap_RAB_ReleaseItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Iu_ReleaseRequest 
   (const char* name, const ranap_Iu_ReleaseRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationDetect 
   (const char* name, const ranap_RelocationDetect* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RelocationComplete 
   (const char* name, const ranap_RelocationComplete* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EnhancedRelocationCompleteRequest 
   (const char* name, const ranap_EnhancedRelocationCompleteRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_EnhancedRelocCompleteReq 
   (const char* name, const ranap_RAB_SetupItem_EnhancedRelocCompleteReq* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.transportLayerAddressReq1Present) {
      asn1Print_ranap_TransportLayerAddress ("transportLayerAddressReq1", &
         pvalue->transportLayerAddressReq1);
   }

   if (pvalue->m.iuTransportAssociationReq1Present) {
      asn1Print_ranap_IuTransportAssociation ("iuTransportAssociationReq1", &
         pvalue->iuTransportAssociationReq1);
   }

   if (pvalue->m.ass_RAB_ParametersPresent) {
      asn1Print_ranap_Ass_RAB_Parameters ("ass_RAB_Parameters", &pvalue->
         ass_RAB_Parameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EnhancedRelocationCompleteResponse 
   (const char* name, const ranap_EnhancedRelocationCompleteResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_EnhancedRelocCompleteRes 
   (const char* name, const ranap_RAB_SetupItem_EnhancedRelocCompleteRes* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.rAB_ParametersPresent) {
      asn1Print_ranap_RAB_Parameters ("rAB_Parameters", &pvalue->rAB_Parameters
         );
   }

   asn1Print_ranap_UserPlaneInformation ("userPlaneInformation", &pvalue->
      userPlaneInformation);

   if (pvalue->m.transportLayerAddressRes1Present) {
      asn1Print_ranap_TransportLayerAddress ("transportLayerAddressRes1", &
         pvalue->transportLayerAddressRes1);
   }

   if (pvalue->m.iuTransportAssociationRes1Present) {
      asn1Print_ranap_IuTransportAssociation ("iuTransportAssociationRes1", &
         pvalue->iuTransportAssociationRes1);
   }

   if (pvalue->m.rab2beReleasedListPresent) {
      asn1Print_ranap_RAB_ToBeReleasedList_EnhancedRelocCompleteRes (
         "rab2beReleasedList", &pvalue->rab2beReleasedList);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes 
   (const char* name, const ranap_RAB_ToBeReleasedItem_EnhancedRelocCompleteRes* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EnhancedRelocationCompleteFailure 
   (const char* name, const ranap_EnhancedRelocationCompleteFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_EnhancedRelocationCompleteConfirm 
   (const char* name, const ranap_EnhancedRelocationCompleteConfirm* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Paging (const char* name, const ranap_Paging* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CommonID (const char* name, const ranap_CommonID* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CN_InvokeTrace 
   (const char* name, const ranap_CN_InvokeTrace* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_CN_DeactivateTrace 
   (const char* name, const ranap_CN_DeactivateTrace* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationReportingControl 
   (const char* name, const ranap_LocationReportingControl* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationReport 
   (const char* name, const ranap_LocationReport* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InitialUE_Message 
   (const char* name, const ranap_InitialUE_Message* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DirectTransfer 
   (const char* name, const ranap_DirectTransfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Overload (const char* name, const ranap_Overload* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ErrorIndication 
   (const char* name, const ranap_ErrorIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRNS_DataForwardCommand 
   (const char* name, const ranap_SRNS_DataForwardCommand* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ForwardSRNS_Context 
   (const char* name, const ranap_ForwardSRNS_Context* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_AssignmentRequest 
   (const char* name, const ranap_RAB_AssignmentRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TransportLayerInformation 
   (const char* name, const ranap_TransportLayerInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
      transportLayerAddress);

   asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue->
      iuTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupOrModifyItemFirst 
   (const char* name, const ranap_RAB_SetupOrModifyItemFirst* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.nAS_SynchronisationIndicatorPresent) {
      asn1Print_ranap_NAS_SynchronisationIndicator (
         "nAS_SynchronisationIndicator", &pvalue->nAS_SynchronisationIndicator
         );
   }

   if (pvalue->m.rAB_ParametersPresent) {
      asn1Print_ranap_RAB_Parameters ("rAB_Parameters", &pvalue->rAB_Parameters
         );
   }

   if (pvalue->m.userPlaneInformationPresent) {
      asn1Print_ranap_UserPlaneInformation ("userPlaneInformation", &pvalue->
         userPlaneInformation);
   }

   if (pvalue->m.transportLayerInformationPresent) {
      asn1Print_ranap_TransportLayerInformation ("transportLayerInformation", &
         pvalue->transportLayerInformation);
   }

   if (pvalue->m.service_HandoverPresent) {
      asn1Print_ranap_Service_Handover ("service_Handover", &pvalue->
         service_Handover);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupOrModifyItemSecond 
   (const char* name, const ranap_RAB_SetupOrModifyItemSecond* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.pDP_TypeInformationPresent) {
      asn1Print_ranap_PDP_TypeInformation ("pDP_TypeInformation", &pvalue->
         pDP_TypeInformation);
   }

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      asn1Print_ranap_DataVolumeReportingIndication (
         "dataVolumeReportingIndication", &pvalue->
         dataVolumeReportingIndication);
   }

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_GTP_PDU_SequenceNumber ("dl_GTP_PDU_SequenceNumber", &
         pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_GTP_PDU_SequenceNumber ("ul_GTP_PDU_SequenceNumber", &
         pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_N_PDU_SequenceNumber ("dl_N_PDU_SequenceNumber", &
         pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_N_PDU_SequenceNumber ("ul_N_PDU_SequenceNumber", &
         pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_AssignmentResponse 
   (const char* name, const ranap_RAB_AssignmentResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupOrModifiedItem 
   (const char* name, const ranap_RAB_SetupOrModifiedItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.transportLayerAddressPresent) {
      asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
         transportLayerAddress);
   }

   if (pvalue->m.iuTransportAssociationPresent) {
      asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue
         ->iuTransportAssociation);
   }

   if (pvalue->m.dl_dataVolumesPresent) {
      asn1Print_ranap_DataVolumeList ("dl_dataVolumes", &pvalue->dl_dataVolumes
         );
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ReleasedItem 
   (const char* name, const ranap_RAB_ReleasedItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dl_dataVolumesPresent) {
      asn1Print_ranap_DataVolumeList ("dl_dataVolumes", &pvalue->dl_dataVolumes
         );
   }

   if (pvalue->m.dL_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_GTP_PDU_SequenceNumber ("dL_GTP_PDU_SequenceNumber", &
         pvalue->dL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.uL_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_GTP_PDU_SequenceNumber ("uL_GTP_PDU_SequenceNumber", &
         pvalue->uL_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_QueuedItem 
   (const char* name, const ranap_RAB_QueuedItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item 
   (const char* name, const ranap_GERAN_Iumode_RAB_Failed_RABAssgntResponse_Item* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.gERAN_ClassmarkPresent) {
      asn1Print_ranap_GERAN_Classmark ("gERAN_Classmark", &pvalue->
         gERAN_Classmark);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_PrivateMessage 
   (const char* name, const ranap_PrivateMessage* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_PrivateIE_Container ("privateIEs", &pvalue->privateIEs);

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RANAP_RelocationInformation 
   (const char* name, const ranap_RANAP_RelocationInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DirectTransferInformationItem_RANAP_RelocInf 
   (const char* name, const ranap_DirectTransferInformationItem_RANAP_RelocInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_NAS_PDU ("nAS_PDU", &pvalue->nAS_PDU);

   asn1Print_ranap_SAPI ("sAPI", &pvalue->sAPI);

   asn1Print_ranap_CN_DomainIndicator ("cN_DomainIndicator", &pvalue->
      cN_DomainIndicator);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ContextItem_RANAP_RelocInf 
   (const char* name, const ranap_RAB_ContextItem_RANAP_RelocInf* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dl_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_GTP_PDU_SequenceNumber ("dl_GTP_PDU_SequenceNumber", &
         pvalue->dl_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_GTP_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_GTP_PDU_SequenceNumber ("ul_GTP_PDU_SequenceNumber", &
         pvalue->ul_GTP_PDU_SequenceNumber);
   }

   if (pvalue->m.dl_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_DL_N_PDU_SequenceNumber ("dl_N_PDU_SequenceNumber", &
         pvalue->dl_N_PDU_SequenceNumber);
   }

   if (pvalue->m.ul_N_PDU_SequenceNumberPresent) {
      asn1Print_ranap_UL_N_PDU_SequenceNumber ("ul_N_PDU_SequenceNumber", &
         pvalue->ul_N_PDU_SequenceNumber);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RANAP_EnhancedRelocationInformationRequest 
   (const char* name, const ranap_RANAP_EnhancedRelocationInformationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TNLInformationEnhRelInfoReq 
   (const char* name, const ranap_TNLInformationEnhRelInfoReq* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TransportLayerAddress ("transportLayerAddress", &pvalue->
      transportLayerAddress);

   asn1Print_ranap_IuTransportAssociation ("iuTransportAssociation", &pvalue->
      iuTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_EnhRelocInfoReq 
   (const char* name, const ranap_RAB_SetupItem_EnhRelocInfoReq* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_CN_DomainIndicator ("cN_DomainIndicator", &pvalue->
      cN_DomainIndicator);

   asn1Print_ranap_RAB_Parameters ("rAB_Parameters", &pvalue->rAB_Parameters);

   if (pvalue->m.dataVolumeReportingIndicationPresent) {
      asn1Print_ranap_DataVolumeReportingIndication (
         "dataVolumeReportingIndication", &pvalue->
         dataVolumeReportingIndication);
   }

   if (pvalue->m.pDP_TypeInformationPresent) {
      asn1Print_ranap_PDP_TypeInformation ("pDP_TypeInformation", &pvalue->
         pDP_TypeInformation);
   }

   asn1Print_ranap_UserPlaneInformation ("userPlaneInformation", &pvalue->
      userPlaneInformation);

   if (pvalue->m.dataForwardingInformationPresent) {
      asn1Print_ranap_TNLInformationEnhRelInfoReq (
         "dataForwardingInformation", &pvalue->dataForwardingInformation);
   }

   if (pvalue->m.sourceSideIuULTNLInfoPresent) {
      asn1Print_ranap_TNLInformationEnhRelInfoReq ("sourceSideIuULTNLInfo", &
         pvalue->sourceSideIuULTNLInfo);
   }

   if (pvalue->m.service_HandoverPresent) {
      asn1Print_ranap_Service_Handover ("service_Handover", &pvalue->
         service_Handover);
   }

   if (pvalue->m.alt_RAB_ParametersPresent) {
      asn1Print_ranap_Alt_RAB_Parameters ("alt_RAB_Parameters", &pvalue->
         alt_RAB_Parameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RANAP_EnhancedRelocationInformationResponse 
   (const char* name, const ranap_RANAP_EnhancedRelocationInformationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_TNLInformationEnhRelInfoRes 
   (const char* name, const ranap_TNLInformationEnhRelInfoRes* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TransportLayerAddress (
      "dl_forwardingTransportLayerAddress", &pvalue->
      dl_forwardingTransportLayerAddress);

   asn1Print_ranap_IuTransportAssociation (
      "dl_forwardingTransportAssociation", &pvalue->
      dl_forwardingTransportAssociation);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_SetupItem_EnhRelocInfoRes 
   (const char* name, const ranap_RAB_SetupItem_EnhRelocInfoRes* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_CN_DomainIndicator ("cN_DomainIndicator", &pvalue->
      cN_DomainIndicator);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   if (pvalue->m.dataForwardingInformationPresent) {
      asn1Print_ranap_TNLInformationEnhRelInfoRes (
         "dataForwardingInformation", &pvalue->dataForwardingInformation);
   }

   if (pvalue->m.ass_RAB_ParametersPresent) {
      asn1Print_ranap_Ass_RAB_Parameters ("ass_RAB_Parameters", &pvalue->
         ass_RAB_Parameters);
   }

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_FailedItem_EnhRelocInfoRes 
   (const char* name, const ranap_RAB_FailedItem_EnhRelocInfoRes* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_CN_DomainIndicator ("cN_DomainIndicator", &pvalue->
      cN_DomainIndicator);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ModifyRequest 
   (const char* name, const ranap_RAB_ModifyRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RAB_ModifyItem 
   (const char* name, const ranap_RAB_ModifyItem* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_RAB_ID ("rAB_ID", &pvalue->rAB_ID);

   asn1Print_ranap_Requested_RAB_Parameter_Values (
      "requested_RAB_Parameter_Values", &pvalue->requested_RAB_Parameter_Values
      );

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationRelatedDataRequest 
   (const char* name, const ranap_LocationRelatedDataRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationRelatedDataResponse 
   (const char* name, const ranap_LocationRelatedDataResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LocationRelatedDataFailure 
   (const char* name, const ranap_LocationRelatedDataFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InformationTransferIndication 
   (const char* name, const ranap_InformationTransferIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InformationTransferConfirmation 
   (const char* name, const ranap_InformationTransferConfirmation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_InformationTransferFailure 
   (const char* name, const ranap_InformationTransferFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UESpecificInformationIndication 
   (const char* name, const ranap_UESpecificInformationIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_DirectInformationTransfer 
   (const char* name, const ranap_DirectInformationTransfer* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UplinkInformationExchangeRequest 
   (const char* name, const ranap_UplinkInformationExchangeRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UplinkInformationExchangeResponse 
   (const char* name, const ranap_UplinkInformationExchangeResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UplinkInformationExchangeFailure 
   (const char* name, const ranap_UplinkInformationExchangeFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionStart 
   (const char* name, const ranap_MBMSSessionStart* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSynchronisationInformation 
   (const char* name, const ranap_MBMSSynchronisationInformation* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_MBMSHCIndicator ("mBMSHCIndicator", &pvalue->mBMSHCIndicator
      );

   asn1Print_ranap_IPMulticastAddress ("iPMulticastAddress", &pvalue->
      iPMulticastAddress);

   asn1Print_ranap_GTP_TEI ("gTPDLTEID", &pvalue->gTPDLTEID);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionStartResponse 
   (const char* name, const ranap_MBMSSessionStartResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionStartFailure 
   (const char* name, const ranap_MBMSSessionStartFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionUpdate 
   (const char* name, const ranap_MBMSSessionUpdate* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionUpdateResponse 
   (const char* name, const ranap_MBMSSessionUpdateResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionUpdateFailure 
   (const char* name, const ranap_MBMSSessionUpdateFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionStop 
   (const char* name, const ranap_MBMSSessionStop* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSSessionStopResponse 
   (const char* name, const ranap_MBMSSessionStopResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSUELinkingRequest 
   (const char* name, const ranap_MBMSUELinkingRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LeftMBMSBearerService_IEs_element 
   (const char* name, const ranap_LeftMBMSBearerService_IEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TMGI ("tMGI", &pvalue->tMGI);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_LeftMBMSBearerService_IEs 
   (const char* name, const ranap_LeftMBMSBearerService_IEs* pvalue)
{
   ranap_LeftMBMSBearerService_IEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_LeftMBMSBearerService_IEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_LeftMBMSBearerService_IEs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_MBMSUELinkingResponse 
   (const char* name, const ranap_MBMSUELinkingResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UnsuccessfulLinking_IEs_element 
   (const char* name, const ranap_UnsuccessfulLinking_IEs_element* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_TMGI ("tMGI", &pvalue->tMGI);

   asn1Print_ranap_Cause ("cause", &pvalue->cause);

   if (pvalue->m.iE_ExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("iE_Extensions", &pvalue->
         iE_Extensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UnsuccessfulLinking_IEs 
   (const char* name, const ranap_UnsuccessfulLinking_IEs* pvalue)
{
   ranap_UnsuccessfulLinking_IEs_element* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_UnsuccessfulLinking_IEs_element*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_UnsuccessfulLinking_IEs_element (namebuf, pdata0);
      xx1++;
   }
}

void asn1Print_ranap_MBMSRegistrationRequest 
   (const char* name, const ranap_MBMSRegistrationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRegistrationResponse 
   (const char* name, const ranap_MBMSRegistrationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRegistrationFailure 
   (const char* name, const ranap_MBMSRegistrationFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSCNDe_RegistrationRequest 
   (const char* name, const ranap_MBMSCNDe_RegistrationRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSCNDe_RegistrationResponse 
   (const char* name, const ranap_MBMSCNDe_RegistrationResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRABEstablishmentIndication 
   (const char* name, const ranap_MBMSRABEstablishmentIndication* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRABReleaseRequest 
   (const char* name, const ranap_MBMSRABReleaseRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRABRelease 
   (const char* name, const ranap_MBMSRABRelease* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_MBMSRABReleaseFailure 
   (const char* name, const ranap_MBMSRABReleaseFailure* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRVCC_CSKeysRequest 
   (const char* name, const ranap_SRVCC_CSKeysRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SRVCC_CSKeysResponse 
   (const char* name, const ranap_SRVCC_CSKeysResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UeRadioCapabilityMatchRequest 
   (const char* name, const ranap_UeRadioCapabilityMatchRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UeRadioCapabilityMatchResponse 
   (const char* name, const ranap_UeRadioCapabilityMatchResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UeRegistrationQueryRequest 
   (const char* name, const ranap_UeRegistrationQueryRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UeRegistrationQueryResponse 
   (const char* name, const ranap_UeRegistrationQueryResponse* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RerouteNASRequest 
   (const char* name, const ranap_RerouteNASRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProtocolIE_Container ("protocolIEs", &pvalue->protocolIEs);

   if (pvalue->m.protocolExtensionsPresent) {
      asn1Print_ranap_ProtocolExtensionContainer ("protocolExtensions", &pvalue
         ->protocolExtensions);
   }

   rtPrintOpenTypeExtBraceText ("extElem1", &pvalue->extElem1);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_ProtocolError_IE_ContainerList 
   (const char* name, const ranap_ProtocolError_IE_ContainerList* pvalue)
{
   ranap_ProtocolIE_Container* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   char numbuf[32];
   OSUINT32 xx1 = 0;

   for (pnode = pvalue->head; pnode != 0 && xx1 < pvalue->count; pnode = pnode->next) {
      pdata0 = ((ranap_ProtocolIE_Container*)pnode->data);
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_ranap_ProtocolIE_Container (namebuf, pdata0);
      xx1++;
   }
}

EXTERN int asn1PE_ranap_InitiatingMessage (OSCTXT* pctxt, ranap_InitiatingMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InitiatingMessage");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_ranap_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_InitiatingMessage (OSCTXT* pctxt, ranap_InitiatingMessage* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InitiatingMessage");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_ranap_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_InitiatingMessage (ranap_InitiatingMessage* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_InitiatingMessage (OSCTXT *pctxt, 
   ranap_InitiatingMessage* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_SuccessfulOutcome (OSCTXT* pctxt, ranap_SuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SuccessfulOutcome");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_ranap_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_SuccessfulOutcome (OSCTXT* pctxt, ranap_SuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SuccessfulOutcome");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_ranap_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_SuccessfulOutcome (ranap_SuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_SuccessfulOutcome (OSCTXT *pctxt, 
   ranap_SuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_UnsuccessfulOutcome (OSCTXT* pctxt, ranap_UnsuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulOutcome");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_ranap_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_UnsuccessfulOutcome (OSCTXT* pctxt, ranap_UnsuccessfulOutcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UnsuccessfulOutcome");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_ranap_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_UnsuccessfulOutcome (ranap_UnsuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_UnsuccessfulOutcome (OSCTXT *pctxt, 
   ranap_UnsuccessfulOutcome* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_Outcome (OSCTXT* pctxt, ranap_Outcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Outcome");

   /* encode procedureCode */

   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PE_ranap_ProcedureCode (pctxt, pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode criticality */

   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PE_ranap_Criticality (pctxt, pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pe_OpenType (pctxt, pvalue->value.numocts, pvalue->value.data);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_Outcome (OSCTXT* pctxt, ranap_Outcome* pvalue)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Outcome");

   /* decode root elements */
   /* decode procedureCode */
   RTXCTXTPUSHELEMNAME (pctxt, "procedureCode");

   stat = asn1PD_ranap_ProcedureCode (pctxt, &pvalue->procedureCode);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode criticality */
   RTXCTXTPUSHELEMNAME (pctxt, "criticality");

   stat = asn1PD_ranap_Criticality (pctxt, &pvalue->criticality);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */
   RTXCTXTPUSHELEMNAME (pctxt, "value");

   stat = pd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_Outcome (ranap_Outcome* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->value.numocts = 0;
   pvalue->value.data = 0;
   return 0;
}

void asn1Free_ranap_Outcome (OSCTXT *pctxt, ranap_Outcome* pvalue)
{
   if (0 == pvalue) return;
   if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
   }
}

EXTERN int asn1PE_ranap_RANAP_PDU (OSCTXT* pctxt, ranap_RANAP_PDU* pvalue)
{
   int stat = 0;
   OSBOOL extbit = FALSE;

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-PDU");

   /* extension bit */

   extbit = (OSBOOL)(pvalue->t > 4);

   stat = rtxEncBit (pctxt, extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {

      /* Encode choice index value */

      RTXCTXTPUSHELEMNAME (pctxt, "t");

      stat = pe_ConsUnsigned (pctxt, pvalue->t - 1, 0, 3);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);

      /* Encode root element data value */

      switch (pvalue->t)
      {
         /* initiatingMessage */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "initiatingMessage");

            stat = asn1PE_ranap_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* successfulOutcome */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "successfulOutcome");

            stat = asn1PE_ranap_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* unsuccessfulOutcome */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "unsuccessfulOutcome");

            stat = asn1PE_ranap_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         /* outcome */
         case 4:
            RTXCTXTPUSHELEMNAME (pctxt, "outcome");

            stat = asn1PE_ranap_Outcome (pctxt, pvalue->u.outcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      /* Encode extension choice index value */

      stat = pe_SmallNonNegWholeNumber (pctxt, pvalue->t - 5);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      /* Encode extension element data value */

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pe_OpenType (pctxt, pvalue->u.extElem1->numocts, pvalue->u.extElem1->data);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPELEMNAME (pctxt);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1PD_ranap_RANAP_PDU (OSCTXT* pctxt, ranap_RANAP_PDU* pvalue)
{
   int stat = 0;
   OSUINT32 ui;
   OSBOOL extbit = FALSE;
   ASN1OpenType openType;

   RTXCTXTPUSHTYPENAME (pctxt, "RANAP-PDU");

   /* extension bit */

   stat = DEC_BIT (pctxt, &extbit);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!extbit) {
      stat = pd_ConsUnsigned (pctxt, &ui, 0, OSUINTCONST(3));
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 1;

      switch (ui) {
         /* initiatingMessage */
         case 0:
            RTXCTXTPUSHELEMNAME (pctxt, "initiatingMessage");

            pvalue->u.initiatingMessage = rtxMemAllocType (pctxt, 
               ranap_InitiatingMessage);

            if (pvalue->u.initiatingMessage == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_InitiatingMessage (pvalue->u.initiatingMessage);

            stat = asn1PD_ranap_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* successfulOutcome */
         case 1:
            RTXCTXTPUSHELEMNAME (pctxt, "successfulOutcome");

            pvalue->u.successfulOutcome = rtxMemAllocType (pctxt, 
               ranap_SuccessfulOutcome);

            if (pvalue->u.successfulOutcome == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_SuccessfulOutcome (pvalue->u.successfulOutcome);

            stat = asn1PD_ranap_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* unsuccessfulOutcome */
         case 2:
            RTXCTXTPUSHELEMNAME (pctxt, "unsuccessfulOutcome");

            pvalue->u.unsuccessfulOutcome = rtxMemAllocType (pctxt, 
               ranap_UnsuccessfulOutcome);

            if (pvalue->u.unsuccessfulOutcome == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_UnsuccessfulOutcome (pvalue->u.unsuccessfulOutcome);

            stat = asn1PD_ranap_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         /* outcome */
         case 3:
            RTXCTXTPUSHELEMNAME (pctxt, "outcome");

            pvalue->u.outcome = rtxMemAllocType (pctxt, ranap_Outcome);

            if (pvalue->u.outcome == NULL)
               return LOG_RTERR (pctxt, RTERR_NOMEM);

            asn1Init_ranap_Outcome (pvalue->u.outcome);

            stat = asn1PD_ranap_Outcome (pctxt, pvalue->u.outcome);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            break;

         default:
            return LOG_RTERR (pctxt, RTERR_INVOPT);
      }
   }
   else {
      stat = pd_SmallNonNegWholeNumber (pctxt, &ui);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else pvalue->t = ui + 5;

      if (pvalue->t < 5) return LOG_RTERR (pctxt, RTERR_INVOPT);

      stat = PD_BYTE_ALIGN (pctxt);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPUSHELEMNAME (pctxt, "...");

      stat = pd_OpenType (pctxt, &openType.data, &openType.numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      pvalue->u.extElem1 = rtxMemAllocType (pctxt, ASN1OpenType);

      if (pvalue->u.extElem1 == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pvalue->u.extElem1->data = openType.data;
      pvalue->u.extElem1->numocts = openType.numocts;

      RTXCTXTPOPELEMNAME (pctxt);

   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

int asn1Init_ranap_RANAP_PDU (ranap_RANAP_PDU* pvalue)
{
   if (0 == pvalue) return RTERR_NULLPTR;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
   return 0;
}

void asn1Free_ranap_RANAP_PDU (OSCTXT *pctxt, ranap_RANAP_PDU* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.initiatingMessage) {
            asn1Free_ranap_InitiatingMessage (pctxt, pvalue->u.initiatingMessage);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.initiatingMessage);
            pvalue->u.initiatingMessage = 0;
         }
         break;

      case 2:
         if (0 != pvalue->u.successfulOutcome) {
            asn1Free_ranap_SuccessfulOutcome (pctxt, pvalue->u.successfulOutcome);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.successfulOutcome);
            pvalue->u.successfulOutcome = 0;
         }
         break;

      case 3:
         if (0 != pvalue->u.unsuccessfulOutcome) {
            asn1Free_ranap_UnsuccessfulOutcome (pctxt, pvalue->u.unsuccessfulOutcome);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.unsuccessfulOutcome);
            pvalue->u.unsuccessfulOutcome = 0;
         }
         break;

      case 4:
         if (0 != pvalue->u.outcome) {
            asn1Free_ranap_Outcome (pctxt, pvalue->u.outcome);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.outcome);
            pvalue->u.outcome = 0;
         }
         break;

      default:
         if (0 != pvalue->u.extElem1) {
            if (! rtxCtxtTestFlag (pctxt, ASN1FASTCOPY))  {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1->data);
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extElem1);
         }
   }
}

void asn1Print_ranap_InitiatingMessage 
   (const char* name, const ranap_InitiatingMessage* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_SuccessfulOutcome 
   (const char* name, const ranap_SuccessfulOutcome* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_UnsuccessfulOutcome 
   (const char* name, const ranap_UnsuccessfulOutcome* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_Outcome (const char* name, const ranap_Outcome* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_ranap_ProcedureCode ("procedureCode", &pvalue->procedureCode);

   asn1Print_ranap_Criticality ("criticality", &pvalue->criticality);

   rtxPrintIndent ();
   rtxPrintHexStr ("value", pvalue->value.numocts,
   pvalue->value.data);

   rtxPrintCloseBrace ();
}

void asn1Print_ranap_RANAP_PDU 
   (const char* name, const ranap_RANAP_PDU* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* initiatingMessage */
      case 1:
      {
         asn1Print_ranap_InitiatingMessage ("initiatingMessage", pvalue->
            u.initiatingMessage);
         break;
      }
      /* successfulOutcome */
      case 2:
      {
         asn1Print_ranap_SuccessfulOutcome ("successfulOutcome", pvalue->
            u.successfulOutcome);
         break;
      }
      /* unsuccessfulOutcome */
      case 3:
      {
         asn1Print_ranap_UnsuccessfulOutcome ("unsuccessfulOutcome", pvalue->
            u.unsuccessfulOutcome);
         break;
      }
      /* outcome */
      case 4:
      {
         asn1Print_ranap_Outcome ("outcome", pvalue->u.outcome);
         break;
      }
      /* extElem1 */
      case 5:
      {
         rtxPrintIndent ();
         rtxPrintHexStr ("extElem1", pvalue->u.extElem1->numocts,
         pvalue->u.extElem1->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

