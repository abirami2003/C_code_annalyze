/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.5, Date: 06-May-2016.
 */
#include "InformationElements.h"
#include "Constant-definitions.h"
#include "rtxsrc/rtxCommon.h"

void asn1Init_utran_AdditionalMeasurementID_List_r9 (
   utran_AdditionalMeasurementID_List_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_ReleaseCause_ENUMTAB[] = {
   { OSUTF8("congestion"), 3, 10, 2 },
   { OSUTF8("directedsignallingconnectionre-establishment"), 5, 44, 6 },
   { OSUTF8("normalEvent"), 0, 11, 3 },
   { OSUTF8("pre-emptiveRelease"), 2, 18, 0 },
   { OSUTF8("re-establishmentReject"), 4, 22, 4 },
   { OSUTF8("spare"), 7, 5, 1 },
   { OSUTF8("unspecified"), 1, 11, 7 },
   { OSUTF8("userInactivity"), 6, 14, 5 }
} ;
#define utran_ReleaseCause_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ReleaseCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ReleaseCause_ENUMTABSIZE) {
      return utran_ReleaseCause_ENUMTAB
         [utran_ReleaseCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ReleaseCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ReleaseCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ReleaseCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ReleaseCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ReleaseCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_ReleaseCause_ENUMTAB, 
      utran_ReleaseCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ReleaseCause)utran_ReleaseCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_GSM_BA_Range_List (utran_GSM_BA_Range_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GSM_BA_Range_List (OSCTXT *pctxt, 
   utran_GSM_BA_Range_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_FrequencyInfoFDD (utran_FrequencyInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_FDD_UMTS_Frequency_List (
   utran_FDD_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_FDD_UMTS_Frequency_List (OSCTXT *pctxt, 
   utran_FDD_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_TDD_UMTS_Frequency_List (
   utran_TDD_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TDD_UMTS_Frequency_List (OSCTXT *pctxt, 
   utran_TDD_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_FrequencyInfoCDMA2000 (utran_FrequencyInfoCDMA2000* pvalue)
{
   if (0 == pvalue) return;
   pvalue->band_Class.numbits = 0;
   pvalue->cdma_Freq.numbits = 0;
}

void asn1Init_utran_CDMA2000_UMTS_Frequency_List (
   utran_CDMA2000_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CDMA2000_UMTS_Frequency_List (OSCTXT *pctxt, 
   utran_CDMA2000_UMTS_Frequency_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_Rplmn_Information_r4 (utran_Rplmn_Information_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GSM_BA_Range_List (&pvalue->gsm_BA_Range_List);
   asn1Init_utran_FDD_UMTS_Frequency_List (&pvalue->fdd_UMTS_Frequency_List);
   asn1Init_utran_TDD_UMTS_Frequency_List (&pvalue->tdd384_UMTS_Frequency_List);
   asn1Init_utran_TDD_UMTS_Frequency_List (&pvalue->tdd128_UMTS_Frequency_List);
   asn1Init_utran_CDMA2000_UMTS_Frequency_List (&pvalue->cdma2000_UMTS_Frequency_List);
}

void asn1Free_utran_Rplmn_Information_r4 (OSCTXT *pctxt, 
   utran_Rplmn_Information_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.gsm_BA_Range_ListPresent) {
      asn1Free_utran_GSM_BA_Range_List (pctxt, &pvalue->gsm_BA_Range_List);
   }
   if (pvalue->m.fdd_UMTS_Frequency_ListPresent) {
      asn1Free_utran_FDD_UMTS_Frequency_List (pctxt, &pvalue->fdd_UMTS_Frequency_List);
   }
   if (pvalue->m.tdd384_UMTS_Frequency_ListPresent) {
      asn1Free_utran_TDD_UMTS_Frequency_List (pctxt, &pvalue->tdd384_UMTS_Frequency_List);
   }
   if (pvalue->m.tdd128_UMTS_Frequency_ListPresent) {
      asn1Free_utran_TDD_UMTS_Frequency_List (pctxt, &pvalue->tdd128_UMTS_Frequency_List);
   }
   if (pvalue->m.cdma2000_UMTS_Frequency_ListPresent) {
      asn1Free_utran_CDMA2000_UMTS_Frequency_List (pctxt, &pvalue->cdma2000_UMTS_Frequency_List);
   }
}

void asn1Init_utran_FrequencyInfo_modeSpecificInfo (
   utran_FrequencyInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_FrequencyInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_FrequencyInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_FrequencyInfo (utran_FrequencyInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_FrequencyInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_FrequencyInfo (OSCTXT *pctxt, utran_FrequencyInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FrequencyInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_InterRATInfo_ENUMTAB[] = {
   { OSUTF8("gsm"), 0, 3, 0 }
} ;
#define utran_InterRATInfo_ENUMTABSIZE 1

const OSUTF8CHAR* utran_InterRATInfo_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, utran_InterRATInfo_ENUMTAB, 
      utran_InterRATInfo_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_InterRATInfo_ENUMTABSIZE) {
      return utran_InterRATInfo_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_InterRATInfo_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_InterRATInfo* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_InterRATInfo_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_InterRATInfo_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_InterRATInfo* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_InterRATInfo_ENUMTAB, 
      utran_InterRATInfo_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_InterRATInfo)utran_InterRATInfo_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Frequency_Band_ENUMTAB[] = {
   { OSUTF8("dcs1800BandUsed"), 0, 15, 0 },
   { OSUTF8("pcs1900BandUsed"), 1, 15, 1 }
} ;
#define utran_Frequency_Band_ENUMTABSIZE 2

const OSUTF8CHAR* utran_Frequency_Band_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Frequency_Band_ENUMTABSIZE) {
      return utran_Frequency_Band_ENUMTAB
         [utran_Frequency_Band_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Frequency_Band_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Frequency_Band* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Frequency_Band_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Frequency_Band_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Frequency_Band* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_Frequency_Band_ENUMTAB, 
      utran_Frequency_Band_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Frequency_Band)utran_Frequency_Band_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_GSM_TargetCellInfo (utran_GSM_TargetCellInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GSM_TargetCellInfoList (
   utran_GSM_TargetCellInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GSM_TargetCellInfoList (OSCTXT *pctxt, 
   utran_GSM_TargetCellInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_InterRATInfo_r6 (utran_InterRATInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GSM_TargetCellInfoList (&pvalue->gsm_TargetCellInfoList);
}

void asn1Free_utran_InterRATInfo_r6 (OSCTXT *pctxt, 
   utran_InterRATInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.gsm_TargetCellInfoListPresent) {
      asn1Free_utran_GSM_TargetCellInfoList (pctxt, &pvalue->gsm_TargetCellInfoList);
   }
}

void asn1Init_utran_RedirectionInfo_r6 (utran_RedirectionInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RedirectionInfo_r6 (OSCTXT *pctxt, 
   utran_RedirectionInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.frequencyInfo) {
            asn1Free_utran_FrequencyInfo (pctxt, pvalue->u.frequencyInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.frequencyInfo);
         }
         break;

      case 2:
         if (0 != pvalue->u.interRATInfo) {
            asn1Free_utran_InterRATInfo_r6 (pctxt, pvalue->u.interRATInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.interRATInfo);
         }
         break;

   }
}

void asn1Init_utran_EUTRA_BlacklistedCellPerFreqList (
   utran_EUTRA_BlacklistedCellPerFreqList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_EUTRA_BlacklistedCellPerFreqList (OSCTXT *pctxt, 
   utran_EUTRA_BlacklistedCellPerFreqList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_EUTRA_TargetFreqInfo (utran_EUTRA_TargetFreqInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_EUTRA_BlacklistedCellPerFreqList (&pvalue->eutraBlacklistedCellPerFreqList);
}

void asn1Free_utran_EUTRA_TargetFreqInfo (OSCTXT *pctxt, 
   utran_EUTRA_TargetFreqInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eutraBlacklistedCellPerFreqListPresent) {
      asn1Free_utran_EUTRA_BlacklistedCellPerFreqList (pctxt, &pvalue->eutraBlacklistedCellPerFreqList);
   }
}

void asn1Init_utran_EUTRA_TargetFreqInfoList (
   utran_EUTRA_TargetFreqInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_EUTRA_TargetFreqInfoList (OSCTXT *pctxt, 
   utran_EUTRA_TargetFreqInfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_EUTRA_TargetFreqInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_EUTRA_TargetFreqInfo*)pnode->data;
      asn1Free_utran_EUTRA_TargetFreqInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_InterRATInfo_v860ext_eutra (
   utran_InterRATInfo_v860ext_eutra* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_EUTRA_TargetFreqInfoList (&pvalue->eutra_TargetFreqInfoList);
}

void asn1Free_utran_InterRATInfo_v860ext_eutra (OSCTXT *pctxt, 
   utran_InterRATInfo_v860ext_eutra* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_EUTRA_TargetFreqInfoList (pctxt, &pvalue->eutra_TargetFreqInfoList);
}

void asn1Init_utran_InterRATInfo_v860ext (utran_InterRATInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_InterRATInfo_v860ext (OSCTXT *pctxt, 
   utran_InterRATInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.eutra) {
            asn1Free_utran_InterRATInfo_v860ext_eutra (pctxt, pvalue->u.eutra);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.eutra);
         }
         break;

   }
}

void asn1Init_utran_RedirectionInfo_v860ext (
   utran_RedirectionInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RedirectionInfo_v860ext (OSCTXT *pctxt, 
   utran_RedirectionInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.interRATInfo) {
            asn1Free_utran_InterRATInfo_v860ext (pctxt, pvalue->u.interRATInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.interRATInfo);
         }
         break;

   }
}

void asn1Init_utran_EUTRA_TargetFreqInfo_vb50ext (
   utran_EUTRA_TargetFreqInfo_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_EUTRA_TargetFreqInfoList_vb50ext (
   utran_EUTRA_TargetFreqInfoList_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_EUTRA_TargetFreqInfoList_vb50ext (OSCTXT *pctxt, 
   utran_EUTRA_TargetFreqInfoList_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_IntegrityProtInitNumber (
   utran_IntegrityProtInitNumber* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_IntegrityProtectionModeCommand_startIntegrityProtection (
   utran_IntegrityProtectionModeCommand_startIntegrityProtection* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IntegrityProtInitNumber (&pvalue->integrityProtInitNumber);
}

void asn1Init_utran_RRC_MessageSequenceNumberList (
   utran_RRC_MessageSequenceNumberList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_IntegrityProtActivationInfo (
   utran_IntegrityProtActivationInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RRC_MessageSequenceNumberList (&pvalue->rrc_MessageSequenceNumberList);
}

void asn1Init_utran_IntegrityProtectionModeCommand_modify (
   utran_IntegrityProtectionModeCommand_modify* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IntegrityProtActivationInfo (&pvalue->dl_IntegrityProtActivationInfo);
}

void asn1Init_utran_IntegrityProtectionModeCommand (
   utran_IntegrityProtectionModeCommand* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_IntegrityProtectionModeCommand (OSCTXT *pctxt, 
   utran_IntegrityProtectionModeCommand* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.startIntegrityProtection) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.startIntegrityProtection);
         }
         break;

      case 2:
         if (0 != pvalue->u.modify) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.modify);
         }
         break;

   }
}

static const OSEnumItem utran_IntegrityProtectionAlgorithm_ENUMTAB[] = {
   { OSUTF8("uia1"), 0, 4, 0 }
} ;
#define utran_IntegrityProtectionAlgorithm_ENUMTABSIZE 1

const OSUTF8CHAR* utran_IntegrityProtectionAlgorithm_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_IntegrityProtectionAlgorithm_ENUMTAB, 
      utran_IntegrityProtectionAlgorithm_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_IntegrityProtectionAlgorithm_ENUMTABSIZE) {
      return utran_IntegrityProtectionAlgorithm_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IntegrityProtectionAlgorithm_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_IntegrityProtectionAlgorithm* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IntegrityProtectionAlgorithm_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IntegrityProtectionAlgorithm_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_IntegrityProtectionAlgorithm* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_IntegrityProtectionAlgorithm_ENUMTAB, 
      utran_IntegrityProtectionAlgorithm_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IntegrityProtectionAlgorithm)
         utran_IntegrityProtectionAlgorithm_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_IntegrityProtectionModeInfo (
   utran_IntegrityProtectionModeInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IntegrityProtectionModeCommand (&pvalue->integrityProtectionModeCommand);
}

void asn1Free_utran_IntegrityProtectionModeInfo (OSCTXT *pctxt, 
   utran_IntegrityProtectionModeInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IntegrityProtectionModeCommand (pctxt, &pvalue->integrityProtectionModeCommand);
}

static const OSEnumItem utran_CipheringAlgorithm_ENUMTAB[] = {
   { OSUTF8("uea0"), 0, 4, 0 },
   { OSUTF8("uea1"), 1, 4, 1 }
} ;
#define utran_CipheringAlgorithm_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CipheringAlgorithm_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CipheringAlgorithm_ENUMTABSIZE) {
      return utran_CipheringAlgorithm_ENUMTAB
         [utran_CipheringAlgorithm_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CipheringAlgorithm_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CipheringAlgorithm* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CipheringAlgorithm_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CipheringAlgorithm_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CipheringAlgorithm* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CipheringAlgorithm_ENUMTAB, utran_CipheringAlgorithm_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CipheringAlgorithm)
         utran_CipheringAlgorithm_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CipheringModeCommand (utran_CipheringModeCommand* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_RB_ActivationTimeInfoList (
   utran_RB_ActivationTimeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_ActivationTimeInfoList (OSCTXT *pctxt, 
   utran_RB_ActivationTimeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_CipheringModeInfo (utran_CipheringModeInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CipheringModeCommand (&pvalue->cipheringModeCommand);
   asn1Init_utran_RB_ActivationTimeInfoList (&pvalue->rb_DL_CiphActivationTimeInfo);
}

void asn1Free_utran_CipheringModeInfo (OSCTXT *pctxt, 
   utran_CipheringModeInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rb_DL_CiphActivationTimeInfoPresent) {
      asn1Free_utran_RB_ActivationTimeInfoList (pctxt, &pvalue->rb_DL_CiphActivationTimeInfo);
   }
}

void asn1Init_utran_SRNC_Identity (utran_SRNC_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_S_RNTI (utran_S_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_U_RNTI (utran_U_RNTI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SRNC_Identity (&pvalue->srnc_Identity);
   asn1Init_utran_S_RNTI (&pvalue->s_RNTI);
}

void asn1Init_utran_MCC (utran_MCC* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_MNC (utran_MNC* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_PLMN_Identity (utran_PLMN_Identity* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MCC (&pvalue->mcc);
   asn1Init_utran_MNC (&pvalue->mnc);
}

void asn1Init_utran_NAS_SystemInformationGSM_MAP (
   utran_NAS_SystemInformationGSM_MAP* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

static const OSEnumItem utran_CN_DomainIdentity_ENUMTAB[] = {
   { OSUTF8("cs-domain"), 0, 9, 0 },
   { OSUTF8("ps-domain"), 1, 9, 1 }
} ;
#define utran_CN_DomainIdentity_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CN_DomainIdentity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CN_DomainIdentity_ENUMTABSIZE) {
      return utran_CN_DomainIdentity_ENUMTAB
         [utran_CN_DomainIdentity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CN_DomainIdentity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CN_DomainIdentity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CN_DomainIdentity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CN_DomainIdentity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CN_DomainIdentity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CN_DomainIdentity_ENUMTAB, utran_CN_DomainIdentity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CN_DomainIdentity)
         utran_CN_DomainIdentity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CN_DomainInformation (utran_CN_DomainInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_NAS_SystemInformationGSM_MAP (&pvalue->cn_DomainSpecificNAS_Info);
}

void asn1Init_utran_CN_DomainInformationList (
   utran_CN_DomainInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CN_DomainInformationList (OSCTXT *pctxt, 
   utran_CN_DomainInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_CN_InformationInfo (utran_CN_InformationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PLMN_Identity (&pvalue->plmn_Identity);
   asn1Init_utran_NAS_SystemInformationGSM_MAP (&pvalue->cn_CommonGSM_MAP_NAS_SysInfo);
   asn1Init_utran_CN_DomainInformationList (&pvalue->cn_DomainInformationList);
}

void asn1Free_utran_CN_InformationInfo (OSCTXT *pctxt, 
   utran_CN_InformationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.cn_DomainInformationListPresent) {
      asn1Free_utran_CN_DomainInformationList (pctxt, &pvalue->cn_DomainInformationList);
   }
}

void asn1Init_utran_RB_WithPDCP_InfoList (utran_RB_WithPDCP_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_WithPDCP_InfoList (OSCTXT *pctxt, 
   utran_RB_WithPDCP_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_CounterSynchronisationInfo (
   utran_DL_CounterSynchronisationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RB_WithPDCP_InfoList (&pvalue->rB_WithPDCP_InfoList);
}

void asn1Free_utran_DL_CounterSynchronisationInfo (OSCTXT *pctxt, 
   utran_DL_CounterSynchronisationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rB_WithPDCP_InfoListPresent) {
      asn1Free_utran_RB_WithPDCP_InfoList (pctxt, &pvalue->rB_WithPDCP_InfoList);
   }
}

static const OSEnumItem utran_PCPICH_UsageForChannelEst_ENUMTAB[] = {
   { OSUTF8("mayBeUsed"), 0, 9, 0 },
   { OSUTF8("shallNotBeUsed"), 1, 14, 1 }
} ;
#define utran_PCPICH_UsageForChannelEst_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PCPICH_UsageForChannelEst_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PCPICH_UsageForChannelEst_ENUMTABSIZE) {
      return utran_PCPICH_UsageForChannelEst_ENUMTAB
         [utran_PCPICH_UsageForChannelEst_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PCPICH_UsageForChannelEst_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PCPICH_UsageForChannelEst* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PCPICH_UsageForChannelEst_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PCPICH_UsageForChannelEst_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PCPICH_UsageForChannelEst* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PCPICH_UsageForChannelEst_ENUMTAB, 
      utran_PCPICH_UsageForChannelEst_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PCPICH_UsageForChannelEst)
         utran_PCPICH_UsageForChannelEst_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SecondaryCPICH_Info (utran_SecondaryCPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_SF512_AndCodeNumber (utran_SF512_AndCodeNumber* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_ScramblingCodeChange_ENUMTAB[] = {
   { OSUTF8("codeChange"), 0, 10, 0 },
   { OSUTF8("noCodeChange"), 1, 12, 1 }
} ;
#define utran_ScramblingCodeChange_ENUMTABSIZE 2

const OSUTF8CHAR* utran_ScramblingCodeChange_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ScramblingCodeChange_ENUMTABSIZE) {
      return utran_ScramblingCodeChange_ENUMTAB
         [utran_ScramblingCodeChange_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ScramblingCodeChange_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ScramblingCodeChange* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ScramblingCodeChange_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ScramblingCodeChange_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ScramblingCodeChange* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ScramblingCodeChange_ENUMTAB, 
      utran_ScramblingCodeChange_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ScramblingCodeChange)
         utran_ScramblingCodeChange_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_ChannelisationCode (utran_DL_ChannelisationCode* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SF512_AndCodeNumber (&pvalue->sf_AndCodeNumber);
}

void asn1Init_utran_DL_ChannelisationCodeList (
   utran_DL_ChannelisationCodeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_ChannelisationCodeList (OSCTXT *pctxt, 
   utran_DL_ChannelisationCodeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_SSDT_CellIdentity_ENUMTAB[] = {
   { OSUTF8("ssdt-id-a"), 0, 9, 0 },
   { OSUTF8("ssdt-id-b"), 1, 9, 1 },
   { OSUTF8("ssdt-id-c"), 2, 9, 2 },
   { OSUTF8("ssdt-id-d"), 3, 9, 3 },
   { OSUTF8("ssdt-id-e"), 4, 9, 4 },
   { OSUTF8("ssdt-id-f"), 5, 9, 5 },
   { OSUTF8("ssdt-id-g"), 6, 9, 6 },
   { OSUTF8("ssdt-id-h"), 7, 9, 7 }
} ;
#define utran_SSDT_CellIdentity_ENUMTABSIZE 8

const OSUTF8CHAR* utran_SSDT_CellIdentity_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SSDT_CellIdentity_ENUMTABSIZE) {
      return utran_SSDT_CellIdentity_ENUMTAB
         [utran_SSDT_CellIdentity_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SSDT_CellIdentity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SSDT_CellIdentity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SSDT_CellIdentity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SSDT_CellIdentity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SSDT_CellIdentity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SSDT_CellIdentity_ENUMTAB, utran_SSDT_CellIdentity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SSDT_CellIdentity)
         utran_SSDT_CellIdentity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_ClosedLoopTimingAdjMode_ENUMTAB[] = {
   { OSUTF8("slot1"), 0, 5, 0 },
   { OSUTF8("slot2"), 1, 5, 1 }
} ;
#define utran_ClosedLoopTimingAdjMode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_ClosedLoopTimingAdjMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ClosedLoopTimingAdjMode_ENUMTABSIZE) {
      return utran_ClosedLoopTimingAdjMode_ENUMTAB
         [utran_ClosedLoopTimingAdjMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ClosedLoopTimingAdjMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ClosedLoopTimingAdjMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ClosedLoopTimingAdjMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ClosedLoopTimingAdjMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ClosedLoopTimingAdjMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ClosedLoopTimingAdjMode_ENUMTAB, 
      utran_ClosedLoopTimingAdjMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ClosedLoopTimingAdjMode)
         utran_ClosedLoopTimingAdjMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_fdd (utran_DL_DPCH_InfoPerRL_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_TimeInfo (utran_TimeInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_SecondInterleavingMode_ENUMTAB[] = {
   { OSUTF8("frameRelated"), 0, 12, 0 },
   { OSUTF8("timeslotRelated"), 1, 15, 1 }
} ;
#define utran_SecondInterleavingMode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SecondInterleavingMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SecondInterleavingMode_ENUMTABSIZE) {
      return utran_SecondInterleavingMode_ENUMTAB
         [utran_SecondInterleavingMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondInterleavingMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SecondInterleavingMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondInterleavingMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondInterleavingMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondInterleavingMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondInterleavingMode_ENUMTAB, 
      utran_SecondInterleavingMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SecondInterleavingMode)
         utran_SecondInterleavingMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TFCI_Coding_ENUMTAB[] = {
   { OSUTF8("tfci-bits-16"), 2, 12, 2 },
   { OSUTF8("tfci-bits-32"), 3, 12, 3 },
   { OSUTF8("tfci-bits-4"), 0, 11, 0 },
   { OSUTF8("tfci-bits-8"), 1, 11, 1 }
} ;
#define utran_TFCI_Coding_ENUMTABSIZE 4

const OSUTF8CHAR* utran_TFCI_Coding_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TFCI_Coding_ENUMTABSIZE) {
      return utran_TFCI_Coding_ENUMTAB
         [utran_TFCI_Coding_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TFCI_Coding_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TFCI_Coding* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TFCI_Coding_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TFCI_Coding_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TFCI_Coding* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TFCI_Coding_ENUMTAB, 
      utran_TFCI_Coding_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TFCI_Coding)utran_TFCI_Coding_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PuncturingLimit_ENUMTAB[] = {
   { OSUTF8("pl0-40"), 0, 6, 0 },
   { OSUTF8("pl0-44"), 1, 6, 1 },
   { OSUTF8("pl0-48"), 2, 6, 2 },
   { OSUTF8("pl0-52"), 3, 6, 3 },
   { OSUTF8("pl0-56"), 4, 6, 4 },
   { OSUTF8("pl0-60"), 5, 6, 5 },
   { OSUTF8("pl0-64"), 6, 6, 6 },
   { OSUTF8("pl0-68"), 7, 6, 7 },
   { OSUTF8("pl0-72"), 8, 6, 8 },
   { OSUTF8("pl0-76"), 9, 6, 9 },
   { OSUTF8("pl0-80"), 10, 6, 10 },
   { OSUTF8("pl0-84"), 11, 6, 11 },
   { OSUTF8("pl0-88"), 12, 6, 12 },
   { OSUTF8("pl0-92"), 13, 6, 13 },
   { OSUTF8("pl0-96"), 14, 6, 14 },
   { OSUTF8("pl1"), 15, 3, 15 }
} ;
#define utran_PuncturingLimit_ENUMTABSIZE 16

const OSUTF8CHAR* utran_PuncturingLimit_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PuncturingLimit_ENUMTABSIZE) {
      return utran_PuncturingLimit_ENUMTAB
         [utran_PuncturingLimit_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PuncturingLimit_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PuncturingLimit* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PuncturingLimit_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PuncturingLimit_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PuncturingLimit* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PuncturingLimit_ENUMTAB, utran_PuncturingLimit_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PuncturingLimit)
         utran_PuncturingLimit_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RepetitionPeriodAndLength (
   utran_RepetitionPeriodAndLength* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_CommonTimeslotInfo (utran_CommonTimeslotInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RepetitionPeriodAndLength (&pvalue->repetitionPeriodAndLength);
}

static const OSEnumItem utran_MidambleConfigurationBurstType1and3_ENUMTAB[] = {
   { OSUTF8("ms16"), 2, 4, 1 },
   { OSUTF8("ms4"), 0, 3, 2 },
   { OSUTF8("ms8"), 1, 3, 0 }
} ;
#define utran_MidambleConfigurationBurstType1and3_ENUMTABSIZE 3

const OSUTF8CHAR* utran_MidambleConfigurationBurstType1and3_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MidambleConfigurationBurstType1and3_ENUMTABSIZE) {
      return utran_MidambleConfigurationBurstType1and3_ENUMTAB
         [utran_MidambleConfigurationBurstType1and3_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MidambleConfigurationBurstType1and3_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MidambleConfigurationBurstType1and3* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MidambleConfigurationBurstType1and3_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MidambleConfigurationBurstType1and3_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MidambleConfigurationBurstType1and3* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MidambleConfigurationBurstType1and3_ENUMTAB, 
      utran_MidambleConfigurationBurstType1and3_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MidambleConfigurationBurstType1and3)
         utran_MidambleConfigurationBurstType1and3_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type1 (
   utran_MidambleShiftAndBurstType_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

static const OSEnumItem utran_MidambleConfigurationBurstType2_ENUMTAB[] = {
   { OSUTF8("ms3"), 0, 3, 0 },
   { OSUTF8("ms6"), 1, 3, 1 }
} ;
#define utran_MidambleConfigurationBurstType2_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MidambleConfigurationBurstType2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MidambleConfigurationBurstType2_ENUMTABSIZE) {
      return utran_MidambleConfigurationBurstType2_ENUMTAB
         [utran_MidambleConfigurationBurstType2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MidambleConfigurationBurstType2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MidambleConfigurationBurstType2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MidambleConfigurationBurstType2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MidambleConfigurationBurstType2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MidambleConfigurationBurstType2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MidambleConfigurationBurstType2_ENUMTAB, 
      utran_MidambleConfigurationBurstType2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MidambleConfigurationBurstType2)
         utran_MidambleConfigurationBurstType2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type2 (
   utran_MidambleShiftAndBurstType_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType_type3 (
   utran_MidambleShiftAndBurstType_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType_type3 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_burstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_burstType (
   utran_MidambleShiftAndBurstType_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

      case 3:
         if (0 != pvalue->u.type3) {
            asn1Free_utran_MidambleShiftAndBurstType_burstType_type3 (pctxt, pvalue->u.type3);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type3);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType (
   utran_MidambleShiftAndBurstType* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_IndividualTimeslotInfo (
   utran_IndividualTimeslotInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_IndividualTimeslotInfo (OSCTXT *pctxt, 
   utran_IndividualTimeslotInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType (pctxt, &pvalue->midambleShiftAndBurstType);
}

static const OSEnumItem utran_DL_TS_ChannelisationCode_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-10"), 9, 7, 8 },
   { OSUTF8("cc16-11"), 10, 7, 9 },
   { OSUTF8("cc16-12"), 11, 7, 10 },
   { OSUTF8("cc16-13"), 12, 7, 11 },
   { OSUTF8("cc16-14"), 13, 7, 12 },
   { OSUTF8("cc16-15"), 14, 7, 13 },
   { OSUTF8("cc16-16"), 15, 7, 14 },
   { OSUTF8("cc16-2"), 1, 6, 15 },
   { OSUTF8("cc16-3"), 2, 6, 1 },
   { OSUTF8("cc16-4"), 3, 6, 2 },
   { OSUTF8("cc16-5"), 4, 6, 3 },
   { OSUTF8("cc16-6"), 5, 6, 4 },
   { OSUTF8("cc16-7"), 6, 6, 5 },
   { OSUTF8("cc16-8"), 7, 6, 6 },
   { OSUTF8("cc16-9"), 8, 6, 7 }
} ;
#define utran_DL_TS_ChannelisationCode_ENUMTABSIZE 16

const OSUTF8CHAR* utran_DL_TS_ChannelisationCode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_TS_ChannelisationCode_ENUMTABSIZE) {
      return utran_DL_TS_ChannelisationCode_ENUMTAB
         [utran_DL_TS_ChannelisationCode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_TS_ChannelisationCode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_TS_ChannelisationCode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_TS_ChannelisationCode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_TS_ChannelisationCode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_TS_ChannelisationCode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_TS_ChannelisationCode_ENUMTAB, 
      utran_DL_TS_ChannelisationCode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_TS_ChannelisationCode)
         utran_DL_TS_ChannelisationCode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort_codesRepresentation_bitmap (
   utran_DL_TS_ChannelisationCodesShort_codesRepresentation_bitmap* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort_codesRepresentation (
   utran_DL_TS_ChannelisationCodesShort_codesRepresentation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TS_ChannelisationCodesShort_codesRepresentation (OSCTXT *pctxt, 
   utran_DL_TS_ChannelisationCodesShort_codesRepresentation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.bitmap) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitmap);
         }
         break;

   }
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort (
   utran_DL_TS_ChannelisationCodesShort* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_TS_ChannelisationCodesShort_codesRepresentation (&pvalue->codesRepresentation);
}

void asn1Free_utran_DL_TS_ChannelisationCodesShort (OSCTXT *pctxt, 
   utran_DL_TS_ChannelisationCodesShort* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TS_ChannelisationCodesShort_codesRepresentation (pctxt, &pvalue->codesRepresentation);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_parameters_newParameters (
   utran_DownlinkAdditionalTimeslots_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->individualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_parameters_newParameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_parameters (
   utran_DownlinkAdditionalTimeslots_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkAdditionalTimeslots_parameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_DownlinkAdditionalTimeslots_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_DownlinkAdditionalTimeslots (
   utran_DownlinkAdditionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkAdditionalTimeslots_parameters (&pvalue->parameters);
}

void asn1Free_utran_DownlinkAdditionalTimeslots (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkAdditionalTimeslots_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (
   utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DownlinkAdditionalTimeslots* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DownlinkAdditionalTimeslots*)pnode->data;
      asn1Free_utran_DownlinkAdditionalTimeslots (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots (
   utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_moreTimeslots (
   utran_DownlinkTimeslotsCodes_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes (
   utran_DownlinkTimeslotsCodes* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
   asn1Init_utran_DownlinkTimeslotsCodes_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_DownlinkTimeslotsCodes (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   asn1Free_utran_DownlinkTimeslotsCodes_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_TFCS_Identity (utran_TFCS_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->tfcs_ID = 1;
}

void asn1Init_utran_UL_CCTrChTPCList (utran_UL_CCTrChTPCList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_CCTrChTPCList (OSCTXT *pctxt, 
   utran_UL_CCTrChTPCList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_CCTrCh (utran_DL_CCTrCh* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_DownlinkTimeslotsCodes (&pvalue->dl_CCTrCH_TimeslotsCodes);
   asn1Init_utran_UL_CCTrChTPCList (&pvalue->ul_CCTrChTPCList);
}

void asn1Free_utran_DL_CCTrCh (OSCTXT *pctxt, utran_DL_CCTrCh* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
   if (pvalue->m.ul_CCTrChTPCListPresent) {
      asn1Free_utran_UL_CCTrChTPCList (pctxt, &pvalue->ul_CCTrChTPCList);
   }
}

void asn1Init_utran_DL_CCTrChList (utran_DL_CCTrChList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_CCTrChList (OSCTXT *pctxt, utran_DL_CCTrChList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_CCTrCh* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_CCTrCh*)pnode->data;
      asn1Free_utran_DL_CCTrCh (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_CCTrChListToRemove (utran_DL_CCTrChListToRemove* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_DL_DPCH_InfoPerRL_tdd (utran_DL_DPCH_InfoPerRL_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL (utran_DL_DPCH_InfoPerRL* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_SF256_AndCodeNumber (utran_SF256_AndCodeNumber* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_PositionFixedOrFlexible_ENUMTAB[] = {
   { OSUTF8("fixed"), 0, 5, 0 },
   { OSUTF8("flexible"), 1, 8, 1 }
} ;
#define utran_PositionFixedOrFlexible_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PositionFixedOrFlexible_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PositionFixedOrFlexible_ENUMTABSIZE) {
      return utran_PositionFixedOrFlexible_ENUMTAB
         [utran_PositionFixedOrFlexible_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PositionFixedOrFlexible_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PositionFixedOrFlexible* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PositionFixedOrFlexible_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PositionFixedOrFlexible_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PositionFixedOrFlexible* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PositionFixedOrFlexible_ENUMTAB, 
      utran_PositionFixedOrFlexible_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PositionFixedOrFlexible)
         utran_PositionFixedOrFlexible_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SecondaryCCPCH_Info_modeSpecificInfo_fdd (
   utran_SecondaryCCPCH_Info_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->dummy2);
   asn1Init_utran_SF256_AndCodeNumber (&pvalue->sf_AndCodeNumber);
   pvalue->timingOffset = 0;
}

void asn1Init_utran_RepetitionPeriodLengthAndOffset (
   utran_RepetitionPeriodLengthAndOffset* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RepetitionPeriodLengthAndOffset (OSCTXT *pctxt, 
   utran_RepetitionPeriodLengthAndOffset* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.repetitionPeriod2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod2);
         }
         break;

      case 3:
         if (0 != pvalue->u.repetitionPeriod4) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod4);
         }
         break;

      case 4:
         if (0 != pvalue->u.repetitionPeriod8) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod8);
         }
         break;

      case 5:
         if (0 != pvalue->u.repetitionPeriod16) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod16);
         }
         break;

      case 6:
         if (0 != pvalue->u.repetitionPeriod32) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod32);
         }
         break;

      case 7:
         if (0 != pvalue->u.repetitionPeriod64) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.repetitionPeriod64);
         }
         break;

   }
}

void asn1Init_utran_CommonTimeslotInfoSCCPCH (
   utran_CommonTimeslotInfoSCCPCH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RepetitionPeriodLengthAndOffset (&pvalue->repetitionPeriodLengthAndOffset);
}

void asn1Free_utran_CommonTimeslotInfoSCCPCH (OSCTXT *pctxt, 
   utran_CommonTimeslotInfoSCCPCH* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.repetitionPeriodLengthAndOffsetPresent) {
      asn1Free_utran_RepetitionPeriodLengthAndOffset (pctxt, &pvalue->repetitionPeriodLengthAndOffset);
   }
}

static const OSEnumItem utran_SCCPCH_ChannelisationCode_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-10"), 9, 7, 8 },
   { OSUTF8("cc16-11"), 10, 7, 9 },
   { OSUTF8("cc16-12"), 11, 7, 10 },
   { OSUTF8("cc16-13"), 12, 7, 11 },
   { OSUTF8("cc16-14"), 13, 7, 12 },
   { OSUTF8("cc16-15"), 14, 7, 13 },
   { OSUTF8("cc16-16"), 15, 7, 14 },
   { OSUTF8("cc16-2"), 1, 6, 15 },
   { OSUTF8("cc16-3"), 2, 6, 1 },
   { OSUTF8("cc16-4"), 3, 6, 2 },
   { OSUTF8("cc16-5"), 4, 6, 3 },
   { OSUTF8("cc16-6"), 5, 6, 4 },
   { OSUTF8("cc16-7"), 6, 6, 5 },
   { OSUTF8("cc16-8"), 7, 6, 6 },
   { OSUTF8("cc16-9"), 8, 6, 7 }
} ;
#define utran_SCCPCH_ChannelisationCode_ENUMTABSIZE 16

const OSUTF8CHAR* utran_SCCPCH_ChannelisationCode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SCCPCH_ChannelisationCode_ENUMTABSIZE) {
      return utran_SCCPCH_ChannelisationCode_ENUMTAB
         [utran_SCCPCH_ChannelisationCode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SCCPCH_ChannelisationCode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SCCPCH_ChannelisationCode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SCCPCH_ChannelisationCode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SCCPCH_ChannelisationCode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SCCPCH_ChannelisationCode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SCCPCH_ChannelisationCode_ENUMTAB, 
      utran_SCCPCH_ChannelisationCode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SCCPCH_ChannelisationCode)
         utran_SCCPCH_ChannelisationCode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SCCPCH_ChannelisationCodeList (
   utran_SCCPCH_ChannelisationCodeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_SecondaryCCPCH_Info_modeSpecificInfo_tdd (
   utran_SecondaryCCPCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonTimeslotInfoSCCPCH (&pvalue->commonTimeslotInfo);
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->individualTimeslotInfo);
   asn1Init_utran_SCCPCH_ChannelisationCodeList (&pvalue->channelisationCode);
}

void asn1Free_utran_SecondaryCCPCH_Info_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonTimeslotInfoSCCPCH (pctxt, &pvalue->commonTimeslotInfo);
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_SecondaryCCPCH_Info_modeSpecificInfo (
   utran_SecondaryCCPCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCCPCH_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_SecondaryCCPCH_Info_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCCPCH_Info (utran_SecondaryCCPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCCPCH_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_SecondaryCCPCH_Info (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SecondaryCCPCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_SignalledGainFactors_modeSpecificInfo (
   utran_SignalledGainFactors_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SignalledGainFactors_modeSpecificInfo (OSCTXT *pctxt, 
   utran_SignalledGainFactors_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_SignalledGainFactors (utran_SignalledGainFactors* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SignalledGainFactors_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_SignalledGainFactors (OSCTXT *pctxt, 
   utran_SignalledGainFactors* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SignalledGainFactors_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_GainFactorInformation (utran_GainFactorInformation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_GainFactorInformation (OSCTXT *pctxt, 
   utran_GainFactorInformation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.signalledGainFactors) {
            asn1Free_utran_SignalledGainFactors (pctxt, pvalue->u.signalledGainFactors);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.signalledGainFactors);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_PowerOffsetInformation (
   utran_PowerOffsetInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GainFactorInformation (&pvalue->gainFactorInformation);
}

void asn1Free_utran_PowerOffsetInformation (OSCTXT *pctxt, 
   utran_PowerOffsetInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GainFactorInformation (pctxt, &pvalue->gainFactorInformation);
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit (
   utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_ctfcSize (
   utran_TFCS_ReconfAdd_ctfcSize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFCS_ReconfAdd_ctfcSize (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_ctfcSize* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ctfc2Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc2Bit (pctxt, pvalue->u.ctfc2Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc2Bit);
         }
         break;

      case 2:
         if (0 != pvalue->u.ctfc4Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc4Bit (pctxt, pvalue->u.ctfc4Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc4Bit);
         }
         break;

      case 3:
         if (0 != pvalue->u.ctfc6Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc6Bit (pctxt, pvalue->u.ctfc6Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc6Bit);
         }
         break;

      case 4:
         if (0 != pvalue->u.ctfc8Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc8Bit (pctxt, pvalue->u.ctfc8Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc8Bit);
         }
         break;

      case 5:
         if (0 != pvalue->u.ctfc12Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc12Bit (pctxt, pvalue->u.ctfc12Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc12Bit);
         }
         break;

      case 6:
         if (0 != pvalue->u.ctfc16Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc16Bit (pctxt, pvalue->u.ctfc16Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc16Bit);
         }
         break;

      case 7:
         if (0 != pvalue->u.ctfc24Bit) {
            asn1Free_utran_TFCS_ReconfAdd_ctfcSize_ctfc24Bit (pctxt, pvalue->u.ctfc24Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc24Bit);
         }
         break;

   }
}

void asn1Init_utran_TFCS_ReconfAdd (utran_TFCS_ReconfAdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_ReconfAdd_ctfcSize (&pvalue->ctfcSize);
}

void asn1Free_utran_TFCS_ReconfAdd (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS_ReconfAdd_ctfcSize (pctxt, &pvalue->ctfcSize);
}

void asn1Init_utran_TFCS_RemovalList (utran_TFCS_RemovalList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_RemovalList (OSCTXT *pctxt, 
   utran_TFCS_RemovalList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ExplicitTFCS_Configuration_replacement (
   utran_ExplicitTFCS_Configuration_replacement* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_RemovalList (&pvalue->tfcsRemoval);
   asn1Init_utran_TFCS_ReconfAdd (&pvalue->tfcsAdd);
}

void asn1Free_utran_ExplicitTFCS_Configuration_replacement (OSCTXT *pctxt, 
   utran_ExplicitTFCS_Configuration_replacement* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS_RemovalList (pctxt, &pvalue->tfcsRemoval);
   asn1Free_utran_TFCS_ReconfAdd (pctxt, &pvalue->tfcsAdd);
}

void asn1Init_utran_ExplicitTFCS_Configuration (
   utran_ExplicitTFCS_Configuration* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ExplicitTFCS_Configuration (OSCTXT *pctxt, 
   utran_ExplicitTFCS_Configuration* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.complete) {
            asn1Free_utran_TFCS_ReconfAdd (pctxt, pvalue->u.complete);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.complete);
         }
         break;

      case 2:
         if (0 != pvalue->u.addition) {
            asn1Free_utran_TFCS_ReconfAdd (pctxt, pvalue->u.addition);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.addition);
         }
         break;

      case 3:
         if (0 != pvalue->u.removal) {
            asn1Free_utran_TFCS_RemovalList (pctxt, pvalue->u.removal);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.removal);
         }
         break;

      case 4:
         if (0 != pvalue->u.replacement) {
            asn1Free_utran_ExplicitTFCS_Configuration_replacement (pctxt, pvalue->u.replacement);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.replacement);
         }
         break;

   }
}

static const OSEnumItem utran_SplitType_ENUMTAB[] = {
   { OSUTF8("hardSplit"), 0, 9, 0 },
   { OSUTF8("logicalSplit"), 1, 12, 1 }
} ;
#define utran_SplitType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SplitType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SplitType_ENUMTABSIZE) {
      return utran_SplitType_ENUMTAB
         [utran_SplitType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SplitType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SplitType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SplitType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SplitType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SplitType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SplitType_ENUMTAB, 
      utran_SplitType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SplitType)utran_SplitType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TFCS_InfoForDSCH (utran_TFCS_InfoForDSCH* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_TFCI_Range (utran_TFCI_Range* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_InfoForDSCH (&pvalue->tfcs_InfoForDSCH);
}

void asn1Init_utran_TFCI_RangeList (utran_TFCI_RangeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCI_RangeList (OSCTXT *pctxt, 
   utran_TFCI_RangeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_TFCI_Field2_Information (
   utran_TFCI_Field2_Information* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFCI_Field2_Information (OSCTXT *pctxt, 
   utran_TFCI_Field2_Information* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tfci_Range) {
            asn1Free_utran_TFCI_RangeList (pctxt, pvalue->u.tfci_Range);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tfci_Range);
         }
         break;

      case 2:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_ExplicitTFCS_Configuration (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

   }
}

void asn1Init_utran_SplitTFCI_Signalling (utran_SplitTFCI_Signalling* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_ExplicitTFCS_Configuration (&pvalue->tfci_Field1_Information);
   asn1Init_utran_TFCI_Field2_Information (&pvalue->tfci_Field2_Information);
}

void asn1Free_utran_SplitTFCI_Signalling (OSCTXT *pctxt, 
   utran_SplitTFCI_Signalling* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tfci_Field1_InformationPresent) {
      asn1Free_utran_ExplicitTFCS_Configuration (pctxt, &pvalue->tfci_Field1_Information);
   }
   if (pvalue->m.tfci_Field2_InformationPresent) {
      asn1Free_utran_TFCI_Field2_Information (pctxt, &pvalue->tfci_Field2_Information);
   }
}

void asn1Init_utran_TFCS (utran_TFCS* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFCS (OSCTXT *pctxt, utran_TFCS* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.normalTFCI_Signalling) {
            asn1Free_utran_ExplicitTFCS_Configuration (pctxt, pvalue->u.normalTFCI_Signalling);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.normalTFCI_Signalling);
         }
         break;

      case 2:
         if (0 != pvalue->u.dummy) {
            asn1Free_utran_SplitTFCI_Signalling (pctxt, pvalue->u.dummy);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dummy);
         }
         break;

   }
}

void asn1Init_utran_BitModeRLC_SizeInfo_sizeType2 (
   utran_BitModeRLC_SizeInfo_sizeType2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_BitModeRLC_SizeInfo_sizeType3 (
   utran_BitModeRLC_SizeInfo_sizeType3* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_BitModeRLC_SizeInfo_sizeType4 (
   utran_BitModeRLC_SizeInfo_sizeType4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_BitModeRLC_SizeInfo (utran_BitModeRLC_SizeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_BitModeRLC_SizeInfo (OSCTXT *pctxt, 
   utran_BitModeRLC_SizeInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.sizeType2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sizeType2);
         }
         break;

      case 3:
         if (0 != pvalue->u.sizeType3) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sizeType3);
         }
         break;

      case 4:
         if (0 != pvalue->u.sizeType4) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sizeType4);
         }
         break;

   }
}

void asn1Init_utran_OctetModeRLC_SizeInfoType1_sizeType2 (
   utran_OctetModeRLC_SizeInfoType1_sizeType2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_OctetModeRLC_SizeInfoType1_sizeType3 (
   utran_OctetModeRLC_SizeInfoType1_sizeType3* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_OctetModeRLC_SizeInfoType1 (
   utran_OctetModeRLC_SizeInfoType1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_OctetModeRLC_SizeInfoType1 (OSCTXT *pctxt, 
   utran_OctetModeRLC_SizeInfoType1* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.sizeType2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sizeType2);
         }
         break;

      case 3:
         if (0 != pvalue->u.sizeType3) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sizeType3);
         }
         break;

   }
}

void asn1Init_utran_DedicatedDynamicTF_Info_rlc_Size (
   utran_DedicatedDynamicTF_Info_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DedicatedDynamicTF_Info_rlc_Size (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_Info_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.bitMode) {
            asn1Free_utran_BitModeRLC_SizeInfo (pctxt, pvalue->u.bitMode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitMode);
         }
         break;

      case 2:
         if (0 != pvalue->u.octetModeType1) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.octetModeType1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.octetModeType1);
         }
         break;

   }
}

void asn1Init_utran_NumberOfTransportBlocks (
   utran_NumberOfTransportBlocks* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DedicatedDynamicTF_Info_numberOfTbSizeList (
   utran_DedicatedDynamicTF_Info_numberOfTbSizeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DedicatedDynamicTF_Info_numberOfTbSizeList (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_Info_numberOfTbSizeList* pvalue)
{
   if (0 == pvalue) return;
   { utran_NumberOfTransportBlocks* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_NumberOfTransportBlocks*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_LogicalChannelByRB (utran_LogicalChannelByRB* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_LogicalChannelList_explicitList (
   utran_LogicalChannelList_explicitList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_LogicalChannelList_explicitList (OSCTXT *pctxt, 
   utran_LogicalChannelList_explicitList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_LogicalChannelList (utran_LogicalChannelList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_LogicalChannelList (OSCTXT *pctxt, 
   utran_LogicalChannelList* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.explicitList) {
            asn1Free_utran_LogicalChannelList_explicitList (pctxt, pvalue->u.explicitList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicitList);
         }
         break;

   }
}

void asn1Init_utran_DedicatedDynamicTF_Info (
   utran_DedicatedDynamicTF_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DedicatedDynamicTF_Info_rlc_Size (&pvalue->rlc_Size);
   asn1Init_utran_DedicatedDynamicTF_Info_numberOfTbSizeList (&pvalue->numberOfTbSizeList);
   asn1Init_utran_LogicalChannelList (&pvalue->logicalChannelList);
}

void asn1Free_utran_DedicatedDynamicTF_Info (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DedicatedDynamicTF_Info_rlc_Size (pctxt, &pvalue->rlc_Size);
   asn1Free_utran_DedicatedDynamicTF_Info_numberOfTbSizeList (pctxt, &pvalue->numberOfTbSizeList);
   asn1Free_utran_LogicalChannelList (pctxt, &pvalue->logicalChannelList);
}

void asn1Init_utran_DedicatedDynamicTF_InfoList (
   utran_DedicatedDynamicTF_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DedicatedDynamicTF_InfoList (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_InfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DedicatedDynamicTF_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DedicatedDynamicTF_Info*)pnode->data;
      asn1Free_utran_DedicatedDynamicTF_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size (
   utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.bitMode) {
            asn1Free_utran_BitModeRLC_SizeInfo (pctxt, pvalue->u.bitMode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitMode);
         }
         break;

      case 2:
         if (0 != pvalue->u.octetModeType1) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.octetModeType1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.octetModeType1);
         }
         break;

   }
}

static const OSEnumItem utran_TransmissionTimeInterval_ENUMTAB[] = {
   { OSUTF8("tti10"), 0, 5, 0 },
   { OSUTF8("tti20"), 1, 5, 1 },
   { OSUTF8("tti40"), 2, 5, 2 },
   { OSUTF8("tti80"), 3, 5, 3 }
} ;
#define utran_TransmissionTimeInterval_ENUMTABSIZE 4

const OSUTF8CHAR* utran_TransmissionTimeInterval_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TransmissionTimeInterval_ENUMTABSIZE) {
      return utran_TransmissionTimeInterval_ENUMTAB
         [utran_TransmissionTimeInterval_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TransmissionTimeInterval_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TransmissionTimeInterval* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TransmissionTimeInterval_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TransmissionTimeInterval_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TransmissionTimeInterval* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TransmissionTimeInterval_ENUMTAB, 
      utran_TransmissionTimeInterval_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TransmissionTimeInterval)
         utran_TransmissionTimeInterval_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_NumberOfTbSizeAndTTIList_element (
   utran_NumberOfTbSizeAndTTIList_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_NumberOfTransportBlocks (&pvalue->numberOfTransportBlocks);
}

void asn1Init_utran_NumberOfTbSizeAndTTIList (
   utran_NumberOfTbSizeAndTTIList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_NumberOfTbSizeAndTTIList (OSCTXT *pctxt, 
   utran_NumberOfTbSizeAndTTIList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DedicatedDynamicTF_Info_DynamicTTI (
   utran_DedicatedDynamicTF_Info_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size (&pvalue->rlc_Size);
   asn1Init_utran_NumberOfTbSizeAndTTIList (&pvalue->numberOfTbSizeAndTTIList);
   asn1Init_utran_LogicalChannelList (&pvalue->logicalChannelList);
}

void asn1Free_utran_DedicatedDynamicTF_Info_DynamicTTI (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_Info_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DedicatedDynamicTF_Info_DynamicTTI_rlc_Size (pctxt, &pvalue->rlc_Size);
   asn1Free_utran_NumberOfTbSizeAndTTIList (pctxt, &pvalue->numberOfTbSizeAndTTIList);
   asn1Free_utran_LogicalChannelList (pctxt, &pvalue->logicalChannelList);
}

void asn1Init_utran_DedicatedDynamicTF_InfoList_DynamicTTI (
   utran_DedicatedDynamicTF_InfoList_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DedicatedDynamicTF_InfoList_DynamicTTI (OSCTXT *pctxt, 
   utran_DedicatedDynamicTF_InfoList_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   { utran_DedicatedDynamicTF_Info_DynamicTTI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DedicatedDynamicTF_Info_DynamicTTI*)pnode->data;
      asn1Free_utran_DedicatedDynamicTF_Info_DynamicTTI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DedicatedTransChTFS_tti (
   utran_DedicatedTransChTFS_tti* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DedicatedTransChTFS_tti (OSCTXT *pctxt, 
   utran_DedicatedTransChTFS_tti* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tti10) {
            asn1Free_utran_DedicatedDynamicTF_InfoList (pctxt, pvalue->u.tti10);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti10);
         }
         break;

      case 2:
         if (0 != pvalue->u.tti20) {
            asn1Free_utran_DedicatedDynamicTF_InfoList (pctxt, pvalue->u.tti20);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti20);
         }
         break;

      case 3:
         if (0 != pvalue->u.tti40) {
            asn1Free_utran_DedicatedDynamicTF_InfoList (pctxt, pvalue->u.tti40);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti40);
         }
         break;

      case 4:
         if (0 != pvalue->u.tti80) {
            asn1Free_utran_DedicatedDynamicTF_InfoList (pctxt, pvalue->u.tti80);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti80);
         }
         break;

      case 5:
         if (0 != pvalue->u.dynamic) {
            asn1Free_utran_DedicatedDynamicTF_InfoList_DynamicTTI (pctxt, pvalue->u.dynamic);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dynamic);
         }
         break;

   }
}

static const OSEnumItem utran_CodingRate_ENUMTAB[] = {
   { OSUTF8("half"), 0, 4, 0 },
   { OSUTF8("third"), 1, 5, 1 }
} ;
#define utran_CodingRate_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CodingRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CodingRate_ENUMTABSIZE) {
      return utran_CodingRate_ENUMTAB
         [utran_CodingRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CodingRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CodingRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CodingRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CodingRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CodingRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_CodingRate_ENUMTAB, 
      utran_CodingRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CodingRate)utran_CodingRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ChannelCodingType (utran_ChannelCodingType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_CRC_Size_ENUMTAB[] = {
   { OSUTF8("crc0"), 0, 4, 0 },
   { OSUTF8("crc12"), 2, 5, 4 },
   { OSUTF8("crc16"), 3, 5, 1 },
   { OSUTF8("crc24"), 4, 5, 2 },
   { OSUTF8("crc8"), 1, 4, 3 }
} ;
#define utran_CRC_Size_ENUMTABSIZE 5

const OSUTF8CHAR* utran_CRC_Size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CRC_Size_ENUMTABSIZE) {
      return utran_CRC_Size_ENUMTAB
         [utran_CRC_Size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CRC_Size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CRC_Size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CRC_Size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CRC_Size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CRC_Size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_CRC_Size_ENUMTAB, 
      utran_CRC_Size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CRC_Size)utran_CRC_Size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SemistaticTF_Information (
   utran_SemistaticTF_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_ChannelCodingType (&pvalue->channelCodingType);
}

void asn1Init_utran_DedicatedTransChTFS (utran_DedicatedTransChTFS* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DedicatedTransChTFS_tti (&pvalue->tti);
   asn1Init_utran_SemistaticTF_Information (&pvalue->semistaticTF_Information);
}

void asn1Free_utran_DedicatedTransChTFS (OSCTXT *pctxt, 
   utran_DedicatedTransChTFS* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DedicatedTransChTFS_tti (pctxt, &pvalue->tti);
}

void asn1Init_utran_OctetModeRLC_SizeInfoType2 (
   utran_OctetModeRLC_SizeInfoType2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_CommonDynamicTF_Info_rlc_Size_fdd (
   utran_CommonDynamicTF_Info_rlc_Size_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_OctetModeRLC_SizeInfoType2 (&pvalue->octetModeRLC_SizeInfoType2);
}

void asn1Init_utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice (
   utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.bitModeRLC_SizeInfo) {
            asn1Free_utran_BitModeRLC_SizeInfo (pctxt, pvalue->u.bitModeRLC_SizeInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitModeRLC_SizeInfo);
         }
         break;

      case 2:
         if (0 != pvalue->u.octetModeRLC_SizeInfoType1) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.octetModeRLC_SizeInfoType1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.octetModeRLC_SizeInfoType1);
         }
         break;

   }
}

void asn1Init_utran_CommonDynamicTF_Info_rlc_Size_tdd (
   utran_CommonDynamicTF_Info_rlc_Size_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice (&pvalue->commonTDD_Choice);
}

void asn1Free_utran_CommonDynamicTF_Info_rlc_Size_tdd (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_rlc_Size_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonDynamicTF_Info_rlc_Size_tdd_commonTDD_Choice (pctxt, &pvalue->commonTDD_Choice);
}

void asn1Init_utran_CommonDynamicTF_Info_rlc_Size (
   utran_CommonDynamicTF_Info_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_CommonDynamicTF_Info_rlc_Size (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_rlc_Size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_CommonDynamicTF_Info_rlc_Size_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_CommonDynamicTF_Info_numberOfTbSizeList (
   utran_CommonDynamicTF_Info_numberOfTbSizeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CommonDynamicTF_Info_numberOfTbSizeList (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_numberOfTbSizeList* pvalue)
{
   if (0 == pvalue) return;
   { utran_NumberOfTransportBlocks* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_NumberOfTransportBlocks*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_CommonDynamicTF_Info (utran_CommonDynamicTF_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonDynamicTF_Info_rlc_Size (&pvalue->rlc_Size);
   asn1Init_utran_CommonDynamicTF_Info_numberOfTbSizeList (&pvalue->numberOfTbSizeList);
   asn1Init_utran_LogicalChannelList (&pvalue->logicalChannelList);
}

void asn1Free_utran_CommonDynamicTF_Info (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonDynamicTF_Info_rlc_Size (pctxt, &pvalue->rlc_Size);
   asn1Free_utran_CommonDynamicTF_Info_numberOfTbSizeList (pctxt, &pvalue->numberOfTbSizeList);
   asn1Free_utran_LogicalChannelList (pctxt, &pvalue->logicalChannelList);
}

void asn1Init_utran_CommonDynamicTF_InfoList (
   utran_CommonDynamicTF_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CommonDynamicTF_InfoList (OSCTXT *pctxt, 
   utran_CommonDynamicTF_InfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_CommonDynamicTF_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_CommonDynamicTF_Info*)pnode->data;
      asn1Free_utran_CommonDynamicTF_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice (
   utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.bitModeRLC_SizeInfo) {
            asn1Free_utran_BitModeRLC_SizeInfo (pctxt, pvalue->u.bitModeRLC_SizeInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitModeRLC_SizeInfo);
         }
         break;

      case 2:
         if (0 != pvalue->u.octetModeRLC_SizeInfoType1) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.octetModeRLC_SizeInfoType1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.octetModeRLC_SizeInfoType1);
         }
         break;

   }
}

void asn1Init_utran_CommonDynamicTF_Info_DynamicTTI (
   utran_CommonDynamicTF_Info_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice (&pvalue->commonTDD_Choice);
   asn1Init_utran_NumberOfTbSizeAndTTIList (&pvalue->numberOfTbSizeAndTTIList);
   asn1Init_utran_LogicalChannelList (&pvalue->logicalChannelList);
}

void asn1Free_utran_CommonDynamicTF_Info_DynamicTTI (OSCTXT *pctxt, 
   utran_CommonDynamicTF_Info_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonDynamicTF_Info_DynamicTTI_commonTDD_Choice (pctxt, &pvalue->commonTDD_Choice);
   asn1Free_utran_NumberOfTbSizeAndTTIList (pctxt, &pvalue->numberOfTbSizeAndTTIList);
   asn1Free_utran_LogicalChannelList (pctxt, &pvalue->logicalChannelList);
}

void asn1Init_utran_CommonDynamicTF_InfoList_DynamicTTI (
   utran_CommonDynamicTF_InfoList_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CommonDynamicTF_InfoList_DynamicTTI (OSCTXT *pctxt, 
   utran_CommonDynamicTF_InfoList_DynamicTTI* pvalue)
{
   if (0 == pvalue) return;
   { utran_CommonDynamicTF_Info_DynamicTTI* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_CommonDynamicTF_Info_DynamicTTI*)pnode->data;
      asn1Free_utran_CommonDynamicTF_Info_DynamicTTI (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_CommonTransChTFS_tti (utran_CommonTransChTFS_tti* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_CommonTransChTFS_tti (OSCTXT *pctxt, 
   utran_CommonTransChTFS_tti* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tti10) {
            asn1Free_utran_CommonDynamicTF_InfoList (pctxt, pvalue->u.tti10);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti10);
         }
         break;

      case 2:
         if (0 != pvalue->u.tti20) {
            asn1Free_utran_CommonDynamicTF_InfoList (pctxt, pvalue->u.tti20);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti20);
         }
         break;

      case 3:
         if (0 != pvalue->u.tti40) {
            asn1Free_utran_CommonDynamicTF_InfoList (pctxt, pvalue->u.tti40);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti40);
         }
         break;

      case 4:
         if (0 != pvalue->u.tti80) {
            asn1Free_utran_CommonDynamicTF_InfoList (pctxt, pvalue->u.tti80);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tti80);
         }
         break;

      case 5:
         if (0 != pvalue->u.dynamic) {
            asn1Free_utran_CommonDynamicTF_InfoList_DynamicTTI (pctxt, pvalue->u.dynamic);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dynamic);
         }
         break;

   }
}

void asn1Init_utran_CommonTransChTFS (utran_CommonTransChTFS* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonTransChTFS_tti (&pvalue->tti);
   asn1Init_utran_SemistaticTF_Information (&pvalue->semistaticTF_Information);
}

void asn1Free_utran_CommonTransChTFS (OSCTXT *pctxt, 
   utran_CommonTransChTFS* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonTransChTFS_tti (pctxt, &pvalue->tti);
}

void asn1Init_utran_TransportFormatSet (utran_TransportFormatSet* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TransportFormatSet (OSCTXT *pctxt, 
   utran_TransportFormatSet* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dedicatedTransChTFS) {
            asn1Free_utran_DedicatedTransChTFS (pctxt, pvalue->u.dedicatedTransChTFS);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dedicatedTransChTFS);
         }
         break;

      case 2:
         if (0 != pvalue->u.commonTransChTFS) {
            asn1Free_utran_CommonTransChTFS (pctxt, pvalue->u.commonTransChTFS);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.commonTransChTFS);
         }
         break;

   }
}

void asn1Init_utran_FACH_PCH_Information (utran_FACH_PCH_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
}

void asn1Free_utran_FACH_PCH_Information (OSCTXT *pctxt, 
   utran_FACH_PCH_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
}

void asn1Init_utran_FACH_PCH_InformationList (
   utran_FACH_PCH_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_FACH_PCH_InformationList (OSCTXT *pctxt, 
   utran_FACH_PCH_InformationList* pvalue)
{
   if (0 == pvalue) return;
   { utran_FACH_PCH_Information* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_FACH_PCH_Information*)pnode->data;
      asn1Free_utran_FACH_PCH_Information (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_SIB_TypeAndTag (utran_SIB_TypeAndTag* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SIB_TypeAndTag (OSCTXT *pctxt, 
   utran_SIB_TypeAndTag* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         break;

      case 9:
         break;

      case 10:
         break;

      case 11:
         break;

      case 12:
         break;

      case 13:
         break;

      case 14:
         break;

      case 15:
         break;

      case 16:
         break;

      case 17:
         break;

      case 18:
         break;

      case 19:
         break;

      case 20:
         if (0 != pvalue->u.sysInfoType16) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sysInfoType16);
         }
         break;

      case 21:
         break;

      case 22:
         break;

      case 23:
         if (0 != pvalue->u.sysInfoType15_2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sysInfoType15_2);
         }
         break;

      case 24:
         if (0 != pvalue->u.sysInfoType15_3) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sysInfoType15_3);
         }
         break;

      case 25:
         break;

      case 26:
         break;

      case 27:
         break;

      case 28:
         break;

      case 29:
         break;

      case 30:
         break;

      case 31:
         break;

      case 32:
         break;

   }
}

void asn1Init_utran_SchedulingInformation_scheduling_sib_Pos (
   utran_SchedulingInformation_scheduling_sib_Pos* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_SibOFF_ENUMTAB[] = {
   { OSUTF8("so10"), 4, 4, 5 },
   { OSUTF8("so12"), 5, 4, 13 },
   { OSUTF8("so14"), 6, 4, 14 },
   { OSUTF8("so16"), 7, 4, 15 },
   { OSUTF8("so18"), 8, 4, 0 },
   { OSUTF8("so2"), 0, 3, 1 },
   { OSUTF8("so20"), 9, 4, 2 },
   { OSUTF8("so22"), 10, 4, 3 },
   { OSUTF8("so24"), 11, 4, 4 },
   { OSUTF8("so26"), 12, 4, 6 },
   { OSUTF8("so28"), 13, 4, 7 },
   { OSUTF8("so30"), 14, 4, 8 },
   { OSUTF8("so32"), 15, 4, 9 },
   { OSUTF8("so4"), 1, 3, 10 },
   { OSUTF8("so6"), 2, 3, 11 },
   { OSUTF8("so8"), 3, 3, 12 }
} ;
#define utran_SibOFF_ENUMTABSIZE 16

const OSUTF8CHAR* utran_SibOFF_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SibOFF_ENUMTABSIZE) {
      return utran_SibOFF_ENUMTAB[utran_SibOFF_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SibOFF_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SibOFF* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SibOFF_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SibOFF_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SibOFF* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SibOFF_ENUMTAB, 
      utran_SibOFF_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SibOFF)utran_SibOFF_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SibOFF_List (utran_SibOFF_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_SchedulingInformation_scheduling (
   utran_SchedulingInformation_scheduling* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->segCount = 1;
   asn1Init_utran_SchedulingInformation_scheduling_sib_Pos (&pvalue->sib_Pos);
   asn1Init_utran_SibOFF_List (&pvalue->sib_PosOffsetInfo);
}

void asn1Init_utran_SchedulingInformation (utran_SchedulingInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SchedulingInformation_scheduling (&pvalue->scheduling);
}

void asn1Init_utran_SchedulingInformationSIB (
   utran_SchedulingInformationSIB* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SIB_TypeAndTag (&pvalue->sib_Type);
   asn1Init_utran_SchedulingInformation (&pvalue->scheduling);
}

void asn1Free_utran_SchedulingInformationSIB (OSCTXT *pctxt, 
   utran_SchedulingInformationSIB* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SIB_TypeAndTag (pctxt, &pvalue->sib_Type);
}

void asn1Init_utran_SIB_ReferenceListFACH (utran_SIB_ReferenceListFACH* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SIB_ReferenceListFACH (OSCTXT *pctxt, 
   utran_SIB_ReferenceListFACH* pvalue)
{
   if (0 == pvalue) return;
   { utran_SchedulingInformationSIB* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SchedulingInformationSIB*)pnode->data;
      asn1Free_utran_SchedulingInformationSIB (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_SCCPCH_InfoForFACH_modeSpecificInfo_fdd (
   utran_SCCPCH_InfoForFACH_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_FACH_PCH_InformationList (&pvalue->fach_PCH_InformationList);
   asn1Init_utran_SIB_ReferenceListFACH (&pvalue->sib_ReferenceListFACH);
}

void asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FACH_PCH_InformationList (pctxt, &pvalue->fach_PCH_InformationList);
   asn1Free_utran_SIB_ReferenceListFACH (pctxt, &pvalue->sib_ReferenceListFACH);
}

void asn1Init_utran_SCCPCH_InfoForFACH_modeSpecificInfo_tdd (
   utran_SCCPCH_InfoForFACH_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_FACH_PCH_InformationList (&pvalue->fach_PCH_InformationList);
}

void asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FACH_PCH_InformationList (pctxt, &pvalue->fach_PCH_InformationList);
}

void asn1Init_utran_SCCPCH_InfoForFACH_modeSpecificInfo (
   utran_SCCPCH_InfoForFACH_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_SCCPCH_InfoForFACH (utran_SCCPCH_InfoForFACH* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCCPCH_Info (&pvalue->secondaryCCPCH_Info);
   asn1Init_utran_TFCS (&pvalue->tfcs);
   asn1Init_utran_SCCPCH_InfoForFACH_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_SCCPCH_InfoForFACH (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SecondaryCCPCH_Info (pctxt, &pvalue->secondaryCCPCH_Info);
   asn1Free_utran_TFCS (pctxt, &pvalue->tfcs);
   asn1Free_utran_SCCPCH_InfoForFACH_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_RL_AdditionInformation (
   utran_RL_AdditionInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoPerRL (&pvalue->dl_DPCH_InfoPerRL);
   asn1Init_utran_SCCPCH_InfoForFACH (&pvalue->dummy2);
}

void asn1Free_utran_RL_AdditionInformation (OSCTXT *pctxt, 
   utran_RL_AdditionInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoPerRL (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   if (pvalue->m.dummy2Present) {
      asn1Free_utran_SCCPCH_InfoForFACH (pctxt, &pvalue->dummy2);
   }
}

void asn1Init_utran_RL_AdditionInformationList (
   utran_RL_AdditionInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation*)pnode->data;
      asn1Free_utran_RL_AdditionInformation (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RL_RemovalInformationList (
   utran_RL_RemovalInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_RemovalInformationList (OSCTXT *pctxt, 
   utran_RL_RemovalInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_TX_DiversityMode_ENUMTAB[] = {
   { OSUTF8("closedLoopMode1"), 2, 15, 2 },
   { OSUTF8("dummy"), 3, 5, 3 },
   { OSUTF8("noDiversity"), 0, 11, 0 },
   { OSUTF8("sttd"), 1, 4, 1 }
} ;
#define utran_TX_DiversityMode_ENUMTABSIZE 4

const OSUTF8CHAR* utran_TX_DiversityMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TX_DiversityMode_ENUMTABSIZE) {
      return utran_TX_DiversityMode_ENUMTAB
         [utran_TX_DiversityMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TX_DiversityMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TX_DiversityMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TX_DiversityMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TX_DiversityMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TX_DiversityMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TX_DiversityMode_ENUMTAB, utran_TX_DiversityMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TX_DiversityMode)
         utran_TX_DiversityMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_S_Field_ENUMTAB[] = {
   { OSUTF8("e1bit"), 0, 5, 0 },
   { OSUTF8("e2bits"), 1, 6, 1 }
} ;
#define utran_S_Field_ENUMTABSIZE 2

const OSUTF8CHAR* utran_S_Field_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_S_Field_ENUMTABSIZE) {
      return utran_S_Field_ENUMTAB[utran_S_Field_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_S_Field_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_S_Field* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_S_Field_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_S_Field_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_S_Field* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_S_Field_ENUMTAB, 
      utran_S_Field_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_S_Field)utran_S_Field_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_CodeWordSet_ENUMTAB[] = {
   { OSUTF8("longCWS"), 0, 7, 0 },
   { OSUTF8("mediumCWS"), 1, 9, 1 },
   { OSUTF8("shortCWS"), 2, 8, 2 },
   { OSUTF8("ssdtOff"), 3, 7, 3 }
} ;
#define utran_CodeWordSet_ENUMTABSIZE 4

const OSUTF8CHAR* utran_CodeWordSet_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CodeWordSet_ENUMTABSIZE) {
      return utran_CodeWordSet_ENUMTAB
         [utran_CodeWordSet_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CodeWordSet_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CodeWordSet* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CodeWordSet_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CodeWordSet_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CodeWordSet* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_CodeWordSet_ENUMTAB, 
      utran_CodeWordSet_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CodeWordSet)utran_CodeWordSet_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_SSDT_UL_ENUMTAB[] = {
   { OSUTF8("ul"), 0, 2, 0 },
   { OSUTF8("ul-AndDL"), 1, 8, 1 }
} ;
#define utran_SSDT_UL_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SSDT_UL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SSDT_UL_ENUMTABSIZE) {
      return utran_SSDT_UL_ENUMTAB[utran_SSDT_UL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SSDT_UL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SSDT_UL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SSDT_UL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SSDT_UL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SSDT_UL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SSDT_UL_ENUMTAB, 
      utran_SSDT_UL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SSDT_UL)utran_SSDT_UL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CellIdentity (utran_CellIdentity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_CellIdentity_PerRL_List (
   utran_CellIdentity_PerRL_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_DPC_Mode_ENUMTAB[] = {
   { OSUTF8("singleTPC"), 0, 9, 0 },
   { OSUTF8("tpcTripletInSoft"), 1, 16, 1 }
} ;
#define utran_DPC_Mode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DPC_Mode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DPC_Mode_ENUMTABSIZE) {
      return utran_DPC_Mode_ENUMTAB
         [utran_DPC_Mode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DPC_Mode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DPC_Mode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DPC_Mode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DPC_Mode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DPC_Mode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_DPC_Mode_ENUMTAB, 
      utran_DPC_Mode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DPC_Mode)utran_DPC_Mode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_TPC_PowerOffsetPerRL (
   utran_DL_TPC_PowerOffsetPerRL* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_TPC_PowerOffsetPerRL_List (
   utran_DL_TPC_PowerOffsetPerRL_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_TPC_PowerOffsetPerRL_List (OSCTXT *pctxt, 
   utran_DL_TPC_PowerOffsetPerRL_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_H_RNTI (utran_H_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_E_RNTI (utran_E_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_CN_InformationInfo_r6 (utran_CN_InformationInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PLMN_Identity (&pvalue->plmn_Identity);
   asn1Init_utran_NAS_SystemInformationGSM_MAP (&pvalue->cn_CommonGSM_MAP_NAS_SysInfo);
   asn1Init_utran_CN_DomainInformationList (&pvalue->cn_DomainInformationList);
   asn1Init_utran_PLMN_Identity (&pvalue->primary_plmn_Identity);
}

void asn1Free_utran_CN_InformationInfo_r6 (OSCTXT *pctxt, 
   utran_CN_InformationInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.cn_DomainInformationListPresent) {
      asn1Free_utran_CN_DomainInformationList (pctxt, &pvalue->cn_DomainInformationList);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r5_fdd (
   utran_DL_DPCH_InfoPerRL_r5_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r5_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r5_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_DL_CCTrCh_r4_tddOption_tdd384 (
   utran_DL_CCTrCh_r4_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DownlinkTimeslotsCodes (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_CCTrCh_r4_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r4_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_LCR_r4 (
   utran_MidambleShiftAndBurstType_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_LCR_r4 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_LCR_r4_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

static const OSEnumItem utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTAB[] = {
   { OSUTF8("mod-8PSK"), 1, 8, 1 },
   { OSUTF8("mod-QPSK"), 0, 8, 0 }
} ;
#define utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTABSIZE 2

const OSUTF8CHAR* utran_IndividualTimeslotInfo_LCR_r4_modulation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTABSIZE) {
      return utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTAB
         [utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IndividualTimeslotInfo_LCR_r4_modulation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_IndividualTimeslotInfo_LCR_r4_modulation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IndividualTimeslotInfo_LCR_r4_modulation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IndividualTimeslotInfo_LCR_r4_modulation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_IndividualTimeslotInfo_LCR_r4_modulation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTAB, 
      utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IndividualTimeslotInfo_LCR_r4_modulation)
         utran_IndividualTimeslotInfo_LCR_r4_modulation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTAB[] = {
   { OSUTF8("one"), 1, 3, 2 },
   { OSUTF8("sixteenOverSF"), 2, 13, 0 },
   { OSUTF8("zero"), 0, 4, 1 }
} ;
#define utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTABSIZE 3

const OSUTF8CHAR* utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTABSIZE) {
      return utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTAB
         [utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTAB, 
      utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols)
         utran_IndividualTimeslotInfo_LCR_r4_ss_TPC_Symbols_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (
   utran_IndividualTimeslotInfo_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MidambleShiftAndBurstType_LCR_r4 (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (OSCTXT *pctxt, 
   utran_IndividualTimeslotInfo_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_LCR_r4 (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters (
   utran_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->individualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters (
   utran_DownlinkAdditionalTimeslots_LCR_r4_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_LCR_r4_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_DownlinkAdditionalTimeslots_LCR_r4 (
   utran_DownlinkAdditionalTimeslots_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters (&pvalue->parameters);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4 (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DownlinkAdditionalTimeslots_LCR_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DownlinkAdditionalTimeslots_LCR_r4*)pnode->data;
      asn1Free_utran_DownlinkAdditionalTimeslots_LCR_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots (
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4 (
   utran_DownlinkTimeslotsCodes_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
   asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4 (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_DL_CCTrCh_r4_tddOption_tdd128 (
   utran_DL_CCTrCh_r4_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4 (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_CCTrCh_r4_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r4_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_DL_CCTrCh_r4_tddOption (
   utran_DL_CCTrCh_r4_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CCTrCh_r4_tddOption (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r4_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_CCTrCh_r4_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_CCTrCh_r4_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CCTrCh_r4 (utran_DL_CCTrCh_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_DL_CCTrCh_r4_tddOption (&pvalue->tddOption);
   asn1Init_utran_UL_CCTrChTPCList (&pvalue->ul_CCTrChTPCList);
}

void asn1Free_utran_DL_CCTrCh_r4 (OSCTXT *pctxt, utran_DL_CCTrCh_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CCTrCh_r4_tddOption (pctxt, &pvalue->tddOption);
   if (pvalue->m.ul_CCTrChTPCListPresent) {
      asn1Free_utran_UL_CCTrChTPCList (pctxt, &pvalue->ul_CCTrChTPCList);
   }
}

void asn1Init_utran_DL_CCTrChList_r4 (utran_DL_CCTrChList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_CCTrChList_r4 (OSCTXT *pctxt, 
   utran_DL_CCTrChList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_CCTrCh_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_CCTrCh_r4*)pnode->data;
      asn1Free_utran_DL_CCTrCh_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r5_tdd (
   utran_DL_DPCH_InfoPerRL_r5_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r4 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r5_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r5_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r5 (utran_DL_DPCH_InfoPerRL_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r5 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_FDPCH_InfoPerRL_r6 (utran_DL_FDPCH_InfoPerRL_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
}

void asn1Init_utran_RL_AdditionInformation_r6_dl_dpchInfo (
   utran_RL_AdditionInformation_r6_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r6_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r6_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_RL_AdditionInformation_r6 (
   utran_RL_AdditionInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r6_dl_dpchInfo (&pvalue->dl_dpchInfo);
}

void asn1Free_utran_RL_AdditionInformation_r6 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r6_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
}

void asn1Init_utran_RL_AdditionInformationList_r6 (
   utran_RL_AdditionInformationList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r6 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r6*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (
   utran_HS_SCCH_Info_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_fdd (
   utran_HS_SCCH_Info_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_HS_SCCH_TDD384_midambleAllocationMode (
   utran_HS_SCCH_TDD384_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_TDD384_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD384_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD384_midambleAllocationMode (
   utran_HS_SICH_Configuration_TDD384_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SICH_Configuration_TDD384_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD384_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD384 (
   utran_HS_SICH_Configuration_TDD384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SICH_Configuration_TDD384_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_HS_SICH_Configuration_TDD384 (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD384_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_HS_SCCH_TDD384 (utran_HS_SCCH_TDD384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD384_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD384 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD384 (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_TDD384_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   asn1Free_utran_HS_SICH_Configuration_TDD384 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD384* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD384*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD384 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384 (
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

static const OSEnumItem utran_HS_ChannelisationCode_LCR_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-10"), 9, 7, 8 },
   { OSUTF8("cc16-11"), 10, 7, 9 },
   { OSUTF8("cc16-12"), 11, 7, 10 },
   { OSUTF8("cc16-13"), 12, 7, 11 },
   { OSUTF8("cc16-14"), 13, 7, 12 },
   { OSUTF8("cc16-15"), 14, 7, 13 },
   { OSUTF8("cc16-16"), 15, 7, 14 },
   { OSUTF8("cc16-2"), 1, 6, 15 },
   { OSUTF8("cc16-3"), 2, 6, 1 },
   { OSUTF8("cc16-4"), 3, 6, 2 },
   { OSUTF8("cc16-5"), 4, 6, 3 },
   { OSUTF8("cc16-6"), 5, 6, 4 },
   { OSUTF8("cc16-7"), 6, 6, 5 },
   { OSUTF8("cc16-8"), 7, 6, 6 },
   { OSUTF8("cc16-9"), 8, 6, 7 }
} ;
#define utran_HS_ChannelisationCode_LCR_ENUMTABSIZE 16

const OSUTF8CHAR* utran_HS_ChannelisationCode_LCR_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_ChannelisationCode_LCR_ENUMTABSIZE) {
      return utran_HS_ChannelisationCode_LCR_ENUMTAB
         [utran_HS_ChannelisationCode_LCR_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_ChannelisationCode_LCR_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HS_ChannelisationCode_LCR* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_ChannelisationCode_LCR_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_ChannelisationCode_LCR_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_ChannelisationCode_LCR* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_ChannelisationCode_LCR_ENUMTAB, 
      utran_HS_ChannelisationCode_LCR_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HS_ChannelisationCode_LCR)
         utran_HS_ChannelisationCode_LCR_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_TDD128_midambleAllocationMode (
   utran_HS_SCCH_TDD128_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_HS_SICH_Configuration_TDD128_midambleAllocationMode (
   utran_HS_SICH_Configuration_TDD128_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SICH_Configuration_TDD128_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD128_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

static const OSEnumItem utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SICH_Configuration_TDD128_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTAB
         [utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SICH_Configuration_TDD128_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SICH_Configuration_TDD128_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SICH_Configuration_TDD128_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SICH_Configuration_TDD128_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SICH_Configuration_TDD128_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTAB, 
      utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HS_SICH_Configuration_TDD128_tpc_step_size)
         utran_HS_SICH_Configuration_TDD128_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD128 (
   utran_HS_SICH_Configuration_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SICH_Configuration_TDD128_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_HS_SICH_Configuration_TDD128 (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_HS_SCCH_TDD128 (utran_HS_SCCH_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD128_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD128 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD128 (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd128 (
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD128* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD128*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD128 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo_tdd (
   utran_HS_SCCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_modeSpecificInfo (
   utran_HS_SCCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_HS_SCCH_Info_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info (utran_HS_SCCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_HS_SCCH_Info (OSCTXT *pctxt, utran_HS_SCCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_Feedback_cycle_ENUMTAB[] = {
   { OSUTF8("fc0"), 0, 3, 0 },
   { OSUTF8("fc10"), 4, 4, 3 },
   { OSUTF8("fc160"), 8, 5, 5 },
   { OSUTF8("fc2"), 1, 3, 7 },
   { OSUTF8("fc20"), 5, 4, 1 },
   { OSUTF8("fc4"), 2, 3, 4 },
   { OSUTF8("fc40"), 6, 4, 6 },
   { OSUTF8("fc8"), 3, 3, 8 },
   { OSUTF8("fc80"), 7, 4, 2 }
} ;
#define utran_Feedback_cycle_ENUMTABSIZE 9

const OSUTF8CHAR* utran_Feedback_cycle_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Feedback_cycle_ENUMTABSIZE) {
      return utran_Feedback_cycle_ENUMTAB
         [utran_Feedback_cycle_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Feedback_cycle_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Feedback_cycle* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Feedback_cycle_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Feedback_cycle_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Feedback_cycle* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_Feedback_cycle_ENUMTAB, 
      utran_Feedback_cycle_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Feedback_cycle)utran_Feedback_cycle_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Measurement_Feedback_Info_modeSpecificInfo (
   utran_Measurement_Feedback_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Measurement_Feedback_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_Measurement_Feedback_Info (
   utran_Measurement_Feedback_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Measurement_Feedback_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_Measurement_Feedback_Info (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Measurement_Feedback_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type1 (
   utran_MidambleShiftAndBurstType_DL_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type2 (
   utran_MidambleShiftAndBurstType_DL_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_burstType (
   utran_MidambleShiftAndBurstType_DL_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_DL_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL (
   utran_MidambleShiftAndBurstType_DL* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_DL_HSPDSCH_TS_Configuration_element (
   utran_DL_HSPDSCH_TS_Configuration_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_DL_HSPDSCH_TS_Configuration_element (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_TS_Configuration_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_DL_HSPDSCH_TS_Configuration (
   utran_DL_HSPDSCH_TS_Configuration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_HSPDSCH_TS_Configuration (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_TS_Configuration* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_HSPDSCH_TS_Configuration_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_HSPDSCH_TS_Configuration_element*)pnode->data;
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode (
   utran_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (
   utran_HS_PDSCH_Midamble_Configuration_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
}

void asn1Init_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information (
   utran_DL_HSPDSCH_Information* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_HARQMemorySize_ENUMTAB[] = {
   { OSUTF8("hms10400"), 12, 8, 54 },
   { OSUTF8("hms104000"), 44, 9, 14 },
   { OSUTF8("hms11200"), 13, 8, 25 },
   { OSUTF8("hms112000"), 45, 9, 36 },
   { OSUTF8("hms12000"), 14, 8, 39 },
   { OSUTF8("hms120000"), 46, 9, 42 },
   { OSUTF8("hms12800"), 15, 8, 45 },
   { OSUTF8("hms128000"), 47, 9, 48 },
   { OSUTF8("hms13600"), 16, 8, 51 },
   { OSUTF8("hms136000"), 48, 9, 55 },
   { OSUTF8("hms14400"), 17, 8, 57 },
   { OSUTF8("hms144000"), 49, 9, 59 },
   { OSUTF8("hms15200"), 18, 8, 0 },
   { OSUTF8("hms152000"), 50, 9, 2 },
   { OSUTF8("hms1600"), 1, 7, 4 },
   { OSUTF8("hms16000"), 19, 8, 6 },
   { OSUTF8("hms160000"), 51, 9, 8 },
   { OSUTF8("hms17600"), 20, 8, 10 },
   { OSUTF8("hms176000"), 52, 9, 12 },
   { OSUTF8("hms19200"), 21, 8, 15 },
   { OSUTF8("hms192000"), 53, 9, 17 },
   { OSUTF8("hms20800"), 22, 8, 19 },
   { OSUTF8("hms208000"), 54, 9, 21 },
   { OSUTF8("hms22400"), 23, 8, 23 },
   { OSUTF8("hms224000"), 55, 9, 26 },
   { OSUTF8("hms2400"), 2, 7, 28 },
   { OSUTF8("hms24000"), 24, 8, 30 },
   { OSUTF8("hms240000"), 56, 9, 32 },
   { OSUTF8("hms25600"), 25, 8, 34 },
   { OSUTF8("hms256000"), 57, 9, 37 },
   { OSUTF8("hms27200"), 26, 8, 38 },
   { OSUTF8("hms272000"), 58, 9, 40 },
   { OSUTF8("hms28800"), 27, 8, 41 },
   { OSUTF8("hms288000"), 59, 9, 43 },
   { OSUTF8("hms30400"), 28, 8, 44 },
   { OSUTF8("hms304000"), 60, 9, 46 },
   { OSUTF8("hms3200"), 3, 7, 47 },
   { OSUTF8("hms32000"), 29, 8, 49 },
   { OSUTF8("hms36000"), 30, 8, 50 },
   { OSUTF8("hms4000"), 4, 7, 52 },
   { OSUTF8("hms40000"), 31, 8, 53 },
   { OSUTF8("hms44000"), 32, 8, 56 },
   { OSUTF8("hms4800"), 5, 7, 58 },
   { OSUTF8("hms48000"), 33, 8, 60 },
   { OSUTF8("hms52000"), 34, 8, 1 },
   { OSUTF8("hms5600"), 6, 7, 3 },
   { OSUTF8("hms56000"), 35, 8, 5 },
   { OSUTF8("hms60000"), 36, 8, 7 },
   { OSUTF8("hms6400"), 7, 7, 9 },
   { OSUTF8("hms64000"), 37, 8, 11 },
   { OSUTF8("hms68000"), 38, 8, 13 },
   { OSUTF8("hms7200"), 8, 7, 16 },
   { OSUTF8("hms72000"), 39, 8, 18 },
   { OSUTF8("hms76000"), 40, 8, 20 },
   { OSUTF8("hms800"), 0, 6, 22 },
   { OSUTF8("hms8000"), 9, 7, 24 },
   { OSUTF8("hms80000"), 41, 8, 27 },
   { OSUTF8("hms8800"), 10, 7, 29 },
   { OSUTF8("hms88000"), 42, 8, 31 },
   { OSUTF8("hms9600"), 11, 7, 33 },
   { OSUTF8("hms96000"), 43, 8, 35 }
} ;
#define utran_HARQMemorySize_ENUMTABSIZE 61

const OSUTF8CHAR* utran_HARQMemorySize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HARQMemorySize_ENUMTABSIZE) {
      return utran_HARQMemorySize_ENUMTAB
         [utran_HARQMemorySize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HARQMemorySize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HARQMemorySize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HARQMemorySize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HARQMemorySize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_HARQMemorySize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_HARQMemorySize_ENUMTAB, 
      utran_HARQMemorySize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HARQMemorySize)utran_HARQMemorySize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HARQ_Info_memoryPartitioning_explicit_ (
   utran_HARQ_Info_memoryPartitioning_explicit_* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_memoryPartitioning (
   utran_HARQ_Info_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HARQ_Info_memoryPartitioning (OSCTXT *pctxt, 
   utran_HARQ_Info_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

void asn1Init_utran_HARQ_Info (utran_HARQ_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HARQ_Info_memoryPartitioning (&pvalue->memoryPartitioning);
}

void asn1Free_utran_HARQ_Info (OSCTXT *pctxt, utran_HARQ_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HARQ_Info_memoryPartitioning (pctxt, &pvalue->memoryPartitioning);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation (
   utran_Serving_HSDSCH_CellInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info (pctxt, &pvalue->harqInfo);
   }
}

static const OSEnumItem utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector)
         utran_E_DCH_RL_InfoNewServingCell_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_servingGrant (
   utran_E_DCH_RL_InfoNewServingCell_servingGrant* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_DPDCH_Reference_E_TFCIList (
   utran_E_DPDCH_Reference_E_TFCIList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DPDCH_Reference_E_TFCIList (OSCTXT *pctxt, 
   utran_E_DPDCH_Reference_E_TFCIList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info (
   utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell (
   utran_E_DCH_RL_InfoNewServingCell* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_servingGrant (&pvalue->servingGrant);
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.reference_E_TFCIsPresent) {
      asn1Free_utran_E_DPDCH_Reference_E_TFCIList (pctxt, &pvalue->reference_E_TFCIs);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_e_HICH_Info (
   utran_E_DCH_RL_InfoOtherCell_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_e_HICH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info (
   utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell (
   utran_E_DCH_RL_InfoOtherCell* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoOtherCell_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoOtherCell_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoOtherCell_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList (
   utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_RL_InfoOtherCell* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_RL_InfoOtherCell*)pnode->data;
      asn1Free_utran_E_DCH_RL_InfoOtherCell (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo (
   utran_E_DCH_ReconfigurationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewServingCell (&pvalue->e_DCH_RL_InfoNewServingCell);
   asn1Init_utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList (&pvalue->e_DCH_RL_InfoOtherCellList);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DCH_RL_InfoNewServingCellPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell (pctxt, &pvalue->e_DCH_RL_InfoNewServingCell);
   }
   if (pvalue->m.e_DCH_RL_InfoOtherCellListPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_e_DCH_RL_InfoOtherCellList (pctxt, &pvalue->e_DCH_RL_InfoOtherCellList);
   }
}

static const OSEnumItem utran_STTDIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_STTDIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_STTDIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, utran_STTDIndication_ENUMTAB, 
      utran_STTDIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_STTDIndication_ENUMTABSIZE) {
      return utran_STTDIndication_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_STTDIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_STTDIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_STTDIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_STTDIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_STTDIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_STTDIndication_ENUMTAB, 
      utran_STTDIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_STTDIndication)utran_STTDIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RL_AdditionInformation_v6b0ext (
   utran_RL_AdditionInformation_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_RL_AdditionInformation_list_v6b0ext (
   utran_RL_AdditionInformation_list_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformation_list_v6b0ext (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_list_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_EnablingDelay_ENUMTAB[] = {
   { OSUTF8("radio-frames-0"), 0, 14, 0 },
   { OSUTF8("radio-frames-1"), 1, 14, 1 },
   { OSUTF8("radio-frames-128"), 8, 16, 4 },
   { OSUTF8("radio-frames-16"), 5, 15, 6 },
   { OSUTF8("radio-frames-2"), 2, 14, 8 },
   { OSUTF8("radio-frames-32"), 6, 15, 3 },
   { OSUTF8("radio-frames-4"), 3, 14, 5 },
   { OSUTF8("radio-frames-64"), 7, 15, 7 },
   { OSUTF8("radio-frames-8"), 4, 14, 2 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 9 }
} ;
#define utran_EnablingDelay_ENUMTABSIZE 16

const OSUTF8CHAR* utran_EnablingDelay_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EnablingDelay_ENUMTABSIZE) {
      return utran_EnablingDelay_ENUMTAB
         [utran_EnablingDelay_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EnablingDelay_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_EnablingDelay* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EnablingDelay_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EnablingDelay_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_EnablingDelay* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_EnablingDelay_ENUMTAB, 
      utran_EnablingDelay_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EnablingDelay)utran_EnablingDelay_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DTX_DRX_TimingInfo_r7_timing (
   utran_DTX_DRX_TimingInfo_r7_timing* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DTX_DRX_TimingInfo_r7_timing (OSCTXT *pctxt, 
   utran_DTX_DRX_TimingInfo_r7_timing* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newTiming) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newTiming);
         }
         break;

   }
}

void asn1Init_utran_DTX_DRX_TimingInfo_r7 (utran_DTX_DRX_TimingInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DTX_DRX_TimingInfo_r7_timing (&pvalue->timing);
}

void asn1Free_utran_DTX_DRX_TimingInfo_r7 (OSCTXT *pctxt, 
   utran_DTX_DRX_TimingInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DTX_DRX_TimingInfo_r7_timing (pctxt, &pvalue->timing);
}

static const OSEnumItem utran_UE_DTX_Cycle1_10ms_ENUMTAB[] = {
   { OSUTF8("sub-frames-1"), 0, 12, 0 },
   { OSUTF8("sub-frames-10"), 2, 13, 3 },
   { OSUTF8("sub-frames-20"), 3, 13, 1 },
   { OSUTF8("sub-frames-5"), 1, 12, 2 }
} ;
#define utran_UE_DTX_Cycle1_10ms_ENUMTABSIZE 4

const OSUTF8CHAR* utran_UE_DTX_Cycle1_10ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle1_10ms_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle1_10ms_ENUMTAB
         [utran_UE_DTX_Cycle1_10ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle1_10ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle1_10ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle1_10ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle1_10ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DTX_Cycle1_10ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle1_10ms_ENUMTAB, utran_UE_DTX_Cycle1_10ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle1_10ms)
         utran_UE_DTX_Cycle1_10ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DTX_Cycle2_10ms_ENUMTAB[] = {
   { OSUTF8("spare1"), 7, 6, 6 },
   { OSUTF8("spare2"), 6, 6, 2 },
   { OSUTF8("sub-frames-10"), 1, 13, 4 },
   { OSUTF8("sub-frames-160"), 5, 14, 5 },
   { OSUTF8("sub-frames-20"), 2, 13, 7 },
   { OSUTF8("sub-frames-40"), 3, 13, 3 },
   { OSUTF8("sub-frames-5"), 0, 12, 1 },
   { OSUTF8("sub-frames-80"), 4, 13, 0 }
} ;
#define utran_UE_DTX_Cycle2_10ms_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_DTX_Cycle2_10ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle2_10ms_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle2_10ms_ENUMTAB
         [utran_UE_DTX_Cycle2_10ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle2_10ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle2_10ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle2_10ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle2_10ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DTX_Cycle2_10ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle2_10ms_ENUMTAB, utran_UE_DTX_Cycle2_10ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle2_10ms)
         utran_UE_DTX_Cycle2_10ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MAC_DTX_Cycle_10ms_ENUMTAB[] = {
   { OSUTF8("spare1"), 3, 6, 3 },
   { OSUTF8("sub-frames-10"), 1, 13, 1 },
   { OSUTF8("sub-frames-20"), 2, 13, 2 },
   { OSUTF8("sub-frames-5"), 0, 12, 0 }
} ;
#define utran_MAC_DTX_Cycle_10ms_ENUMTABSIZE 4

const OSUTF8CHAR* utran_MAC_DTX_Cycle_10ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_DTX_Cycle_10ms_ENUMTABSIZE) {
      return utran_MAC_DTX_Cycle_10ms_ENUMTAB
         [utran_MAC_DTX_Cycle_10ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_DTX_Cycle_10ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_DTX_Cycle_10ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_DTX_Cycle_10ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_DTX_Cycle_10ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MAC_DTX_Cycle_10ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_DTX_Cycle_10ms_ENUMTAB, utran_MAC_DTX_Cycle_10ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_DTX_Cycle_10ms)
         utran_MAC_DTX_Cycle_10ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DTX_Cycle1_2ms_ENUMTAB[] = {
   { OSUTF8("spare1"), 7, 6, 1 },
   { OSUTF8("sub-frames-1"), 0, 12, 5 },
   { OSUTF8("sub-frames-10"), 4, 13, 6 },
   { OSUTF8("sub-frames-16"), 5, 13, 7 },
   { OSUTF8("sub-frames-20"), 6, 13, 2 },
   { OSUTF8("sub-frames-4"), 1, 12, 3 },
   { OSUTF8("sub-frames-5"), 2, 12, 4 },
   { OSUTF8("sub-frames-8"), 3, 12, 0 }
} ;
#define utran_UE_DTX_Cycle1_2ms_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_DTX_Cycle1_2ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle1_2ms_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle1_2ms_ENUMTAB
         [utran_UE_DTX_Cycle1_2ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle1_2ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle1_2ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle1_2ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle1_2ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DTX_Cycle1_2ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle1_2ms_ENUMTAB, utran_UE_DTX_Cycle1_2ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle1_2ms)
         utran_UE_DTX_Cycle1_2ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DTX_Cycle2_2ms_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 10 },
   { OSUTF8("spare2"), 14, 6, 12 },
   { OSUTF8("spare3"), 13, 6, 14 },
   { OSUTF8("spare4"), 12, 6, 4 },
   { OSUTF8("sub-frames-10"), 3, 13, 6 },
   { OSUTF8("sub-frames-128"), 10, 14, 8 },
   { OSUTF8("sub-frames-16"), 4, 13, 9 },
   { OSUTF8("sub-frames-160"), 11, 14, 11 },
   { OSUTF8("sub-frames-20"), 5, 13, 13 },
   { OSUTF8("sub-frames-32"), 6, 13, 15 },
   { OSUTF8("sub-frames-4"), 0, 12, 5 },
   { OSUTF8("sub-frames-40"), 7, 13, 7 },
   { OSUTF8("sub-frames-5"), 1, 12, 3 },
   { OSUTF8("sub-frames-64"), 8, 13, 2 },
   { OSUTF8("sub-frames-8"), 2, 12, 1 },
   { OSUTF8("sub-frames-80"), 9, 13, 0 }
} ;
#define utran_UE_DTX_Cycle2_2ms_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_DTX_Cycle2_2ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle2_2ms_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle2_2ms_ENUMTAB
         [utran_UE_DTX_Cycle2_2ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle2_2ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle2_2ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle2_2ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle2_2ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DTX_Cycle2_2ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle2_2ms_ENUMTAB, utran_UE_DTX_Cycle2_2ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle2_2ms)
         utran_UE_DTX_Cycle2_2ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MAC_DTX_Cycle_2ms_ENUMTAB[] = {
   { OSUTF8("spare1"), 7, 6, 1 },
   { OSUTF8("sub-frames-1"), 0, 12, 5 },
   { OSUTF8("sub-frames-10"), 4, 13, 6 },
   { OSUTF8("sub-frames-16"), 5, 13, 7 },
   { OSUTF8("sub-frames-20"), 6, 13, 2 },
   { OSUTF8("sub-frames-4"), 1, 12, 3 },
   { OSUTF8("sub-frames-5"), 2, 12, 4 },
   { OSUTF8("sub-frames-8"), 3, 12, 0 }
} ;
#define utran_MAC_DTX_Cycle_2ms_ENUMTABSIZE 8

const OSUTF8CHAR* utran_MAC_DTX_Cycle_2ms_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_DTX_Cycle_2ms_ENUMTABSIZE) {
      return utran_MAC_DTX_Cycle_2ms_ENUMTAB
         [utran_MAC_DTX_Cycle_2ms_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_DTX_Cycle_2ms_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_DTX_Cycle_2ms* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_DTX_Cycle_2ms_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_DTX_Cycle_2ms_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MAC_DTX_Cycle_2ms* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_DTX_Cycle_2ms_ENUMTAB, utran_MAC_DTX_Cycle_2ms_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_DTX_Cycle_2ms)
         utran_MAC_DTX_Cycle_2ms_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DTX_Info_e_dch_TTI_Length (
   utran_DTX_Info_e_dch_TTI_Length* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DTX_Info_e_dch_TTI_Length (OSCTXT *pctxt, 
   utran_DTX_Info_e_dch_TTI_Length* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dtx_e_dch_TTI_10ms) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dtx_e_dch_TTI_10ms);
         }
         break;

      case 2:
         if (0 != pvalue->u.dtx_e_dch_TTI_2ms) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dtx_e_dch_TTI_2ms);
         }
         break;

   }
}

static const OSEnumItem utran_UE_DTX_Cycle2InactivityThreshold_ENUMTAB[] = {
   { OSUTF8("e-dch-tti-1"), 0, 11, 0 },
   { OSUTF8("e-dch-tti-128"), 6, 13, 5 },
   { OSUTF8("e-dch-tti-16"), 3, 12, 7 },
   { OSUTF8("e-dch-tti-256"), 7, 13, 2 },
   { OSUTF8("e-dch-tti-32"), 4, 12, 4 },
   { OSUTF8("e-dch-tti-4"), 1, 11, 6 },
   { OSUTF8("e-dch-tti-64"), 5, 12, 1 },
   { OSUTF8("e-dch-tti-8"), 2, 11, 3 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 9 },
   { OSUTF8("spare8"), 8, 6, 8 }
} ;
#define utran_UE_DTX_Cycle2InactivityThreshold_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_DTX_Cycle2InactivityThreshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle2InactivityThreshold_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle2InactivityThreshold_ENUMTAB
         [utran_UE_DTX_Cycle2InactivityThreshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle2InactivityThreshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle2InactivityThreshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle2InactivityThreshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle2InactivityThreshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_DTX_Cycle2InactivityThreshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle2InactivityThreshold_ENUMTAB, 
      utran_UE_DTX_Cycle2InactivityThreshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle2InactivityThreshold)
         utran_UE_DTX_Cycle2InactivityThreshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DTX_long_preamble_length_ENUMTAB[] = {
   { OSUTF8("slots-15"), 1, 8, 1 },
   { OSUTF8("slots-4"), 0, 7, 0 }
} ;
#define utran_UE_DTX_long_preamble_length_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UE_DTX_long_preamble_length_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_long_preamble_length_ENUMTABSIZE) {
      return utran_UE_DTX_long_preamble_length_ENUMTAB
         [utran_UE_DTX_long_preamble_length_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_long_preamble_length_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_long_preamble_length* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_long_preamble_length_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_long_preamble_length_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_DTX_long_preamble_length* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_long_preamble_length_ENUMTAB, 
      utran_UE_DTX_long_preamble_length_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_long_preamble_length)
         utran_UE_DTX_long_preamble_length_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MAC_InactivityThreshold_ENUMTAB[] = {
   { OSUTF8("e-dch-tti-1"), 0, 11, 0 },
   { OSUTF8("e-dch-tti-128"), 7, 13, 3 },
   { OSUTF8("e-dch-tti-16"), 4, 12, 6 },
   { OSUTF8("e-dch-tti-2"), 1, 11, 9 },
   { OSUTF8("e-dch-tti-256"), 8, 13, 2 },
   { OSUTF8("e-dch-tti-32"), 5, 12, 5 },
   { OSUTF8("e-dch-tti-4"), 2, 11, 8 },
   { OSUTF8("e-dch-tti-512"), 9, 13, 1 },
   { OSUTF8("e-dch-tti-64"), 6, 12, 4 },
   { OSUTF8("e-dch-tti-8"), 3, 11, 7 },
   { OSUTF8("e-dch-tti-Infinity"), 10, 18, 10 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 }
} ;
#define utran_MAC_InactivityThreshold_ENUMTABSIZE 16

const OSUTF8CHAR* utran_MAC_InactivityThreshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_InactivityThreshold_ENUMTABSIZE) {
      return utran_MAC_InactivityThreshold_ENUMTAB
         [utran_MAC_InactivityThreshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_InactivityThreshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_InactivityThreshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_InactivityThreshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_InactivityThreshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MAC_InactivityThreshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_InactivityThreshold_ENUMTAB, 
      utran_MAC_InactivityThreshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_InactivityThreshold)
         utran_MAC_InactivityThreshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_CQI_DTX_Timer_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 4 },
   { OSUTF8("spare2"), 14, 6, 5 },
   { OSUTF8("spare3"), 13, 6, 8 },
   { OSUTF8("spare4"), 12, 6, 11 },
   { OSUTF8("sub-frames-0"), 0, 12, 14 },
   { OSUTF8("sub-frames-1"), 1, 12, 7 },
   { OSUTF8("sub-frames-128"), 8, 14, 10 },
   { OSUTF8("sub-frames-16"), 5, 13, 13 },
   { OSUTF8("sub-frames-2"), 2, 12, 6 },
   { OSUTF8("sub-frames-256"), 9, 14, 9 },
   { OSUTF8("sub-frames-32"), 6, 13, 12 },
   { OSUTF8("sub-frames-4"), 3, 12, 15 },
   { OSUTF8("sub-frames-512"), 10, 14, 3 },
   { OSUTF8("sub-frames-64"), 7, 13, 2 },
   { OSUTF8("sub-frames-8"), 4, 12, 1 },
   { OSUTF8("sub-frames-Infinity"), 11, 19, 0 }
} ;
#define utran_CQI_DTX_Timer_ENUMTABSIZE 16

const OSUTF8CHAR* utran_CQI_DTX_Timer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CQI_DTX_Timer_ENUMTABSIZE) {
      return utran_CQI_DTX_Timer_ENUMTAB
         [utran_CQI_DTX_Timer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CQI_DTX_Timer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CQI_DTX_Timer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CQI_DTX_Timer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CQI_DTX_Timer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CQI_DTX_Timer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_CQI_DTX_Timer_ENUMTAB, 
      utran_CQI_DTX_Timer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CQI_DTX_Timer)utran_CQI_DTX_Timer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DPCCH_Burst_ENUMTAB[] = {
   { OSUTF8("spare1"), 3, 6, 1 },
   { OSUTF8("sub-frames-1"), 0, 12, 2 },
   { OSUTF8("sub-frames-2"), 1, 12, 3 },
   { OSUTF8("sub-frames-5"), 2, 12, 0 }
} ;
#define utran_UE_DPCCH_Burst_ENUMTABSIZE 4

const OSUTF8CHAR* utran_UE_DPCCH_Burst_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DPCCH_Burst_ENUMTABSIZE) {
      return utran_UE_DPCCH_Burst_ENUMTAB
         [utran_UE_DPCCH_Burst_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DPCCH_Burst_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DPCCH_Burst* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DPCCH_Burst_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DPCCH_Burst_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DPCCH_Burst* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UE_DPCCH_Burst_ENUMTAB, 
      utran_UE_DPCCH_Burst_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DPCCH_Burst)utran_UE_DPCCH_Burst_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DTX_Info (utran_DTX_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DTX_Info_e_dch_TTI_Length (&pvalue->e_dch_TTI_Length);
}

void asn1Free_utran_DTX_Info (OSCTXT *pctxt, utran_DTX_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DTX_Info_e_dch_TTI_Length (pctxt, &pvalue->e_dch_TTI_Length);
}

static const OSEnumItem utran_UE_DRX_Cycle_ENUMTAB[] = {
   { OSUTF8("spare1"), 7, 6, 5 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("sub-frames-10"), 3, 13, 7 },
   { OSUTF8("sub-frames-16"), 4, 13, 2 },
   { OSUTF8("sub-frames-20"), 5, 13, 3 },
   { OSUTF8("sub-frames-4"), 0, 12, 4 },
   { OSUTF8("sub-frames-5"), 1, 12, 1 },
   { OSUTF8("sub-frames-8"), 2, 12, 0 }
} ;
#define utran_UE_DRX_Cycle_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_DRX_Cycle_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DRX_Cycle_ENUMTABSIZE) {
      return utran_UE_DRX_Cycle_ENUMTAB
         [utran_UE_DRX_Cycle_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DRX_Cycle_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DRX_Cycle* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DRX_Cycle_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DRX_Cycle_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DRX_Cycle* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UE_DRX_Cycle_ENUMTAB, 
      utran_UE_DRX_Cycle_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DRX_Cycle)utran_UE_DRX_Cycle_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DRX_Cycle_InactivityThreshold_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 5 },
   { OSUTF8("spare2"), 14, 6, 6 },
   { OSUTF8("spare3"), 13, 6, 9 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 15 },
   { OSUTF8("sub-frames-0"), 0, 12, 8 },
   { OSUTF8("sub-frames-1"), 1, 12, 11 },
   { OSUTF8("sub-frames-128"), 8, 14, 14 },
   { OSUTF8("sub-frames-16"), 5, 13, 7 },
   { OSUTF8("sub-frames-2"), 2, 12, 10 },
   { OSUTF8("sub-frames-256"), 9, 14, 13 },
   { OSUTF8("sub-frames-32"), 6, 13, 4 },
   { OSUTF8("sub-frames-4"), 3, 12, 3 },
   { OSUTF8("sub-frames-512"), 10, 14, 2 },
   { OSUTF8("sub-frames-64"), 7, 13, 1 },
   { OSUTF8("sub-frames-8"), 4, 12, 0 }
} ;
#define utran_UE_DRX_Cycle_InactivityThreshold_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_DRX_Cycle_InactivityThreshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DRX_Cycle_InactivityThreshold_ENUMTABSIZE) {
      return utran_UE_DRX_Cycle_InactivityThreshold_ENUMTAB
         [utran_UE_DRX_Cycle_InactivityThreshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DRX_Cycle_InactivityThreshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DRX_Cycle_InactivityThreshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DRX_Cycle_InactivityThreshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DRX_Cycle_InactivityThreshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_DRX_Cycle_InactivityThreshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DRX_Cycle_InactivityThreshold_ENUMTAB, 
      utran_UE_DRX_Cycle_InactivityThreshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DRX_Cycle_InactivityThreshold)
         utran_UE_DRX_Cycle_InactivityThreshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_GrantMonitoring_InactivityThreshold_ENUMTAB[] = {
   { OSUTF8("e-dch-tti-0"), 0, 11, 0 },
   { OSUTF8("e-dch-tti-1"), 1, 11, 1 },
   { OSUTF8("e-dch-tti-128"), 8, 13, 4 },
   { OSUTF8("e-dch-tti-16"), 5, 12, 7 },
   { OSUTF8("e-dch-tti-2"), 2, 11, 9 },
   { OSUTF8("e-dch-tti-256"), 9, 13, 3 },
   { OSUTF8("e-dch-tti-32"), 6, 12, 6 },
   { OSUTF8("e-dch-tti-4"), 3, 11, 8 },
   { OSUTF8("e-dch-tti-64"), 7, 12, 2 },
   { OSUTF8("e-dch-tti-8"), 4, 11, 5 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define utran_UE_GrantMonitoring_InactivityThreshold_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_GrantMonitoring_InactivityThreshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_GrantMonitoring_InactivityThreshold_ENUMTABSIZE) {
      return utran_UE_GrantMonitoring_InactivityThreshold_ENUMTAB
         [utran_UE_GrantMonitoring_InactivityThreshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_GrantMonitoring_InactivityThreshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_GrantMonitoring_InactivityThreshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_GrantMonitoring_InactivityThreshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_GrantMonitoring_InactivityThreshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_GrantMonitoring_InactivityThreshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_GrantMonitoring_InactivityThreshold_ENUMTAB, 
      utran_UE_GrantMonitoring_InactivityThreshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_GrantMonitoring_InactivityThreshold)
         utran_UE_GrantMonitoring_InactivityThreshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Uplink_DPCCH_Slot_Format_Information_ENUMTAB[] = {
   { OSUTF8("dummy"), 1, 5, 1 },
   { OSUTF8("slot-format-1"), 0, 13, 0 },
   { OSUTF8("slot-format-4"), 2, 13, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_Uplink_DPCCH_Slot_Format_Information_ENUMTABSIZE 4

const OSUTF8CHAR* utran_Uplink_DPCCH_Slot_Format_Information_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Uplink_DPCCH_Slot_Format_Information_ENUMTABSIZE) {
      return utran_Uplink_DPCCH_Slot_Format_Information_ENUMTAB
         [utran_Uplink_DPCCH_Slot_Format_Information_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Uplink_DPCCH_Slot_Format_Information_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Uplink_DPCCH_Slot_Format_Information* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Uplink_DPCCH_Slot_Format_Information_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Uplink_DPCCH_Slot_Format_Information_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Uplink_DPCCH_Slot_Format_Information* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Uplink_DPCCH_Slot_Format_Information_ENUMTAB, 
      utran_Uplink_DPCCH_Slot_Format_Information_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Uplink_DPCCH_Slot_Format_Information)
         utran_Uplink_DPCCH_Slot_Format_Information_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DTX_DRX_Info_r7 (utran_DTX_DRX_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DTX_Info (&pvalue->dtx_Info);
}

void asn1Free_utran_DTX_DRX_Info_r7 (OSCTXT *pctxt, 
   utran_DTX_DRX_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dtx_InfoPresent) {
      asn1Free_utran_DTX_Info (pctxt, &pvalue->dtx_Info);
   }
}

void asn1Init_utran_HS_SCCH_LessTFSList (utran_HS_SCCH_LessTFSList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_LessTFSList (OSCTXT *pctxt, 
   utran_HS_SCCH_LessTFSList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_HS_SCCH_Less_NewOperation (
   utran_HS_SCCH_Less_NewOperation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_LessTFSList (&pvalue->hs_scch_LessTFS);
}

void asn1Free_utran_HS_SCCH_Less_NewOperation (OSCTXT *pctxt, 
   utran_HS_SCCH_Less_NewOperation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_LessTFSList (pctxt, &pvalue->hs_scch_LessTFS);
}

void asn1Init_utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation (
   utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation (OSCTXT *pctxt, 
   utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newOperation) {
            asn1Free_utran_HS_SCCH_Less_NewOperation (pctxt, pvalue->u.newOperation);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newOperation);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_LessInfo_r7 (utran_HS_SCCH_LessInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation (&pvalue->hs_scchLessOperation);
}

void asn1Free_utran_HS_SCCH_LessInfo_r7 (OSCTXT *pctxt, 
   utran_HS_SCCH_LessInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_LessInfo_r7_hs_scchLessOperation (pctxt, &pvalue->hs_scchLessOperation);
}

static const OSEnumItem utran_MIMO_Operation_ENUMTAB[] = {
   { OSUTF8("continue"), 1, 8, 1 },
   { OSUTF8("start"), 0, 5, 0 }
} ;
#define utran_MIMO_Operation_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MIMO_Operation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MIMO_Operation_ENUMTABSIZE) {
      return utran_MIMO_Operation_ENUMTAB
         [utran_MIMO_Operation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_Operation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MIMO_Operation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_Operation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_Operation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MIMO_Operation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MIMO_Operation_ENUMTAB, 
      utran_MIMO_Operation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MIMO_Operation)utran_MIMO_Operation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MIMO_N_M_Ratio_ENUMTAB[] = {
   { OSUTF8("mnm1-1"), 9, 6, 1 },
   { OSUTF8("mnm1-2"), 0, 6, 2 },
   { OSUTF8("mnm2-3"), 1, 6, 3 },
   { OSUTF8("mnm3-4"), 2, 6, 4 },
   { OSUTF8("mnm4-5"), 3, 6, 5 },
   { OSUTF8("mnm5-6"), 4, 6, 6 },
   { OSUTF8("mnm6-7"), 5, 6, 7 },
   { OSUTF8("mnm7-8"), 6, 6, 8 },
   { OSUTF8("mnm8-9"), 7, 6, 9 },
   { OSUTF8("mnm9-10"), 8, 7, 0 }
} ;
#define utran_MIMO_N_M_Ratio_ENUMTABSIZE 10

const OSUTF8CHAR* utran_MIMO_N_M_Ratio_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MIMO_N_M_Ratio_ENUMTABSIZE) {
      return utran_MIMO_N_M_Ratio_ENUMTAB
         [utran_MIMO_N_M_Ratio_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_N_M_Ratio_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MIMO_N_M_Ratio* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_N_M_Ratio_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_N_M_Ratio_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MIMO_N_M_Ratio* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MIMO_N_M_Ratio_ENUMTAB, 
      utran_MIMO_N_M_Ratio_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MIMO_N_M_Ratio)utran_MIMO_N_M_Ratio_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MIMO_PilotConfiguration_secondCPICH_Pattern (
   utran_MIMO_PilotConfiguration_secondCPICH_Pattern* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_PilotConfiguration_secondCPICH_Pattern (OSCTXT *pctxt, 
   utran_MIMO_PilotConfiguration_secondCPICH_Pattern* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.diversityPattern) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.diversityPattern);
         }
         break;

   }
}

void asn1Init_utran_MIMO_PilotConfiguration (
   utran_MIMO_PilotConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_PilotConfiguration_secondCPICH_Pattern (&pvalue->secondCPICH_Pattern);
}

void asn1Free_utran_MIMO_PilotConfiguration (OSCTXT *pctxt, 
   utran_MIMO_PilotConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MIMO_PilotConfiguration_secondCPICH_Pattern (pctxt, &pvalue->secondCPICH_Pattern);
}

void asn1Init_utran_MIMO_Parameters_r7 (utran_MIMO_Parameters_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration (&pvalue->mimoPilotConfiguration);
}

void asn1Free_utran_MIMO_Parameters_r7 (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO_PilotConfiguration (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

void asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (utran_DL_FDPCH_InfoPerRL_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
}

void asn1Init_utran_RL_AdditionInformation_r7_dl_dpchInfo (
   utran_RL_AdditionInformation_r7_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r7_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r7_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_RL_AdditionInformation_r7 (
   utran_RL_AdditionInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r7_dl_dpchInfo (&pvalue->dl_dpchInfo);
}

void asn1Free_utran_RL_AdditionInformation_r7 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r7_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
}

void asn1Init_utran_RL_AdditionInformationList_r7 (
   utran_RL_AdditionInformationList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r7 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r7*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_fdd (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_HS_SCCH_TDD384_r6_midambleAllocationMode (
   utran_HS_SCCH_TDD384_r6_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_TDD384_r6_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD384_r6_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_TDD384_r6 (utran_HS_SCCH_TDD384_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD384_r6_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD384 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD384_r6 (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD384_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_TDD384_r6_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   asn1Free_utran_HS_SICH_Configuration_TDD384 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD384_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD384_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD384_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384 (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

static const OSEnumItem utran_DL_TS_ChannelisationCode_VHCR_ENUMTAB[] = {
   { OSUTF8("cc132-5"), 4, 7, 1 },
   { OSUTF8("cc32-1"), 0, 6, 12 },
   { OSUTF8("cc32-10"), 9, 7, 23 },
   { OSUTF8("cc32-11"), 10, 7, 27 },
   { OSUTF8("cc32-12"), 11, 7, 0 },
   { OSUTF8("cc32-13"), 12, 7, 28 },
   { OSUTF8("cc32-14"), 13, 7, 29 },
   { OSUTF8("cc32-15"), 14, 7, 30 },
   { OSUTF8("cc32-16"), 15, 7, 31 },
   { OSUTF8("cc32-17"), 16, 7, 2 },
   { OSUTF8("cc32-18"), 17, 7, 3 },
   { OSUTF8("cc32-19"), 18, 7, 4 },
   { OSUTF8("cc32-2"), 1, 6, 5 },
   { OSUTF8("cc32-20"), 19, 7, 6 },
   { OSUTF8("cc32-21"), 20, 7, 7 },
   { OSUTF8("cc32-22"), 21, 7, 8 },
   { OSUTF8("cc32-23"), 22, 7, 9 },
   { OSUTF8("cc32-24"), 23, 7, 10 },
   { OSUTF8("cc32-25"), 24, 7, 11 },
   { OSUTF8("cc32-26"), 25, 7, 13 },
   { OSUTF8("cc32-27"), 26, 7, 14 },
   { OSUTF8("cc32-28"), 27, 7, 15 },
   { OSUTF8("cc32-29"), 28, 7, 16 },
   { OSUTF8("cc32-3"), 2, 6, 17 },
   { OSUTF8("cc32-30"), 29, 7, 18 },
   { OSUTF8("cc32-31"), 30, 7, 19 },
   { OSUTF8("cc32-32"), 31, 7, 20 },
   { OSUTF8("cc32-4"), 3, 6, 21 },
   { OSUTF8("cc32-6"), 5, 6, 22 },
   { OSUTF8("cc32-7"), 6, 6, 24 },
   { OSUTF8("cc32-8"), 7, 6, 25 },
   { OSUTF8("cc32-9"), 8, 6, 26 }
} ;
#define utran_DL_TS_ChannelisationCode_VHCR_ENUMTABSIZE 32

const OSUTF8CHAR* utran_DL_TS_ChannelisationCode_VHCR_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_TS_ChannelisationCode_VHCR_ENUMTABSIZE) {
      return utran_DL_TS_ChannelisationCode_VHCR_ENUMTAB
         [utran_DL_TS_ChannelisationCode_VHCR_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_TS_ChannelisationCode_VHCR_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_TS_ChannelisationCode_VHCR* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_TS_ChannelisationCode_VHCR_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_TS_ChannelisationCode_VHCR_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_TS_ChannelisationCode_VHCR* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_TS_ChannelisationCode_VHCR_ENUMTAB, 
      utran_DL_TS_ChannelisationCode_VHCR_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_TS_ChannelisationCode_VHCR)
         utran_DL_TS_ChannelisationCode_VHCR_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_TDD768_midambleAllocationMode (
   utran_HS_SCCH_TDD768_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_TDD768_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD768_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD768_midambleAllocationMode (
   utran_HS_SICH_Configuration_TDD768_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SICH_Configuration_TDD768_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD768_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD768 (
   utran_HS_SICH_Configuration_TDD768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SICH_Configuration_TDD768_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_HS_SICH_Configuration_TDD768 (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD768_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_HS_SCCH_TDD768 (utran_HS_SCCH_TDD768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD768_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD768 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD768 (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_TDD768_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
   asn1Free_utran_HS_SICH_Configuration_TDD768 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD768* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD768*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD768 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768 (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

static const OSEnumItem utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB
         [utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB, 
      utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size)
         utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_TDD128_r6_midambleAllocationMode (
   utran_HS_SCCH_TDD128_r6_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode (
   utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_Configuration_TDD128_r6 (
   utran_HS_SICH_Configuration_TDD128_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_HS_SICH_Configuration_TDD128_r6 (OSCTXT *pctxt, 
   utran_HS_SICH_Configuration_TDD128_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128_r6_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_HS_SCCH_TDD128_r6 (utran_HS_SCCH_TDD128_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD128_r6_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD128_r6 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD128_r6 (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD128_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128_r6 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD128_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD128_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD128_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128 (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd (
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo (
   utran_HS_SCCH_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r7 (utran_HS_SCCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_HS_SCCH_Info_r7 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_Feedback_cycle_r7_ENUMTAB[] = {
   { OSUTF8("fc0"), 0, 3, 0 },
   { OSUTF8("fc10"), 4, 4, 4 },
   { OSUTF8("fc16"), 9, 4, 7 },
   { OSUTF8("fc160"), 8, 5, 10 },
   { OSUTF8("fc2"), 1, 3, 1 },
   { OSUTF8("fc20"), 5, 4, 5 },
   { OSUTF8("fc32"), 10, 4, 8 },
   { OSUTF8("fc4"), 2, 3, 11 },
   { OSUTF8("fc40"), 6, 4, 3 },
   { OSUTF8("fc64"), 11, 4, 2 },
   { OSUTF8("fc8"), 3, 3, 6 },
   { OSUTF8("fc80"), 7, 4, 9 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 }
} ;
#define utran_Feedback_cycle_r7_ENUMTABSIZE 16

const OSUTF8CHAR* utran_Feedback_cycle_r7_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Feedback_cycle_r7_ENUMTABSIZE) {
      return utran_Feedback_cycle_r7_ENUMTAB
         [utran_Feedback_cycle_r7_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Feedback_cycle_r7_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Feedback_cycle_r7* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Feedback_cycle_r7_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Feedback_cycle_r7_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Feedback_cycle_r7* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Feedback_cycle_r7_ENUMTAB, utran_Feedback_cycle_r7_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Feedback_cycle_r7)
         utran_Feedback_cycle_r7_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Measurement_Feedback_Info_r7_modeSpecificInfo (
   utran_Measurement_Feedback_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Measurement_Feedback_Info_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_Measurement_Feedback_Info_r7 (
   utran_Measurement_Feedback_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Measurement_Feedback_Info_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_Measurement_Feedback_Info_r7 (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Measurement_Feedback_Info_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1 (
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

static const OSEnumItem utran_MidambleConfigurationBurstType2_VHCR_ENUMTAB[] = {
   { OSUTF8("ms4"), 0, 3, 0 },
   { OSUTF8("ms8"), 1, 3, 1 }
} ;
#define utran_MidambleConfigurationBurstType2_VHCR_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MidambleConfigurationBurstType2_VHCR_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MidambleConfigurationBurstType2_VHCR_ENUMTABSIZE) {
      return utran_MidambleConfigurationBurstType2_VHCR_ENUMTAB
         [utran_MidambleConfigurationBurstType2_VHCR_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MidambleConfigurationBurstType2_VHCR_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MidambleConfigurationBurstType2_VHCR* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MidambleConfigurationBurstType2_VHCR_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MidambleConfigurationBurstType2_VHCR_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MidambleConfigurationBurstType2_VHCR* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MidambleConfigurationBurstType2_VHCR_ENUMTAB, 
      utran_MidambleConfigurationBurstType2_VHCR_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MidambleConfigurationBurstType2_VHCR)
         utran_MidambleConfigurationBurstType2_VHCR_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2 (
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType (
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR (
   utran_MidambleShiftAndBurstType_DL_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_DL_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR_element (
   utran_DL_HSPDSCH_TS_Configuration_VHCR_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_DL_VHCR (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR_element (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_TS_Configuration_VHCR_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_DL_VHCR (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (
   utran_DL_HSPDSCH_TS_Configuration_VHCR* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_TS_Configuration_VHCR* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_HSPDSCH_TS_Configuration_VHCR_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_HSPDSCH_TS_Configuration_VHCR_element*)pnode->data;
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd768 (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

static const OSEnumItem utran_DL_MultiCarrier_Information_tsn_Length_ENUMTAB[] = {
   { OSUTF8("tsn-6bits"), 0, 9, 0 },
   { OSUTF8("tsn-9bits"), 1, 9, 1 }
} ;
#define utran_DL_MultiCarrier_Information_tsn_Length_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_MultiCarrier_Information_tsn_Length_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_MultiCarrier_Information_tsn_Length_ENUMTABSIZE) {
      return utran_DL_MultiCarrier_Information_tsn_Length_ENUMTAB
         [utran_DL_MultiCarrier_Information_tsn_Length_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_MultiCarrier_Information_tsn_Length_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_MultiCarrier_Information_tsn_Length* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_MultiCarrier_Information_tsn_Length_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_MultiCarrier_Information_tsn_Length_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_MultiCarrier_Information_tsn_Length* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_MultiCarrier_Information_tsn_Length_ENUMTAB, 
      utran_DL_MultiCarrier_Information_tsn_Length_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_MultiCarrier_Information_tsn_Length)
         utran_DL_MultiCarrier_Information_tsn_Length_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_TDD128_MultiCarrier_midambleAllocationMode (
   utran_HS_SCCH_TDD128_MultiCarrier_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_HS_SCCH_TDD128_MultiCarrier (
   utran_HS_SCCH_TDD128_MultiCarrier* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_TDD128_MultiCarrier_midambleAllocationMode (&pvalue->midambleAllocationMode);
   asn1Init_utran_HS_SICH_Configuration_TDD128 (&pvalue->hs_sich_configuration);
}

void asn1Free_utran_HS_SCCH_TDD128_MultiCarrier (OSCTXT *pctxt, 
   utran_HS_SCCH_TDD128_MultiCarrier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128 (pctxt, &pvalue->hs_sich_configuration);
}

void asn1Init_utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier (
   utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD128_MultiCarrier* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD128_MultiCarrier*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD128_MultiCarrier (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_HSPDSCH_MultiCarrier_Information_element (
   utran_DL_HSPDSCH_MultiCarrier_Information_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info (&pvalue->harqInfo);
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration);
   asn1Init_utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier (&pvalue->hs_SCCH_TDD128_MultiCarrier);
}

void asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information_element (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_MultiCarrier_Information_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.hs_SCCH_TDD128_MultiCarrierPresent) {
      asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information_element_hs_SCCH_TDD128_MultiCarrier (pctxt, &pvalue->hs_SCCH_TDD128_MultiCarrier);
   }
}

void asn1Init_utran_DL_HSPDSCH_MultiCarrier_Information (
   utran_DL_HSPDSCH_MultiCarrier_Information* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_MultiCarrier_Information* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_HSPDSCH_MultiCarrier_Information_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_HSPDSCH_MultiCarrier_Information_element*)pnode->data;
      asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_MultiCarrier_Information (
   utran_DL_MultiCarrier_Information* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_MultiCarrier_Information (&pvalue->dl_HSPDSCH_MultiCarrier_Information);
}

void asn1Free_utran_DL_MultiCarrier_Information (OSCTXT *pctxt, 
   utran_DL_MultiCarrier_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_MultiCarrier_Information (pctxt, &pvalue->dl_HSPDSCH_MultiCarrier_Information);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
   asn1Init_utran_DL_MultiCarrier_Information (&pvalue->dl_MultiCarrier_Information);
}

void asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_MultiCarrier_Information (pctxt, &pvalue->dl_MultiCarrier_Information);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured)
         utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r7 (
   utran_DL_HSPDSCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info_r7 (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r7 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r7 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info_r7 (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_HARQ_Info_r7_numberOfProcesses_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n12"), 8, 3, 4 },
   { OSUTF8("n14"), 9, 3, 5 },
   { OSUTF8("n16"), 10, 3, 6 },
   { OSUTF8("n2"), 1, 2, 7 },
   { OSUTF8("n3"), 2, 2, 8 },
   { OSUTF8("n4"), 3, 2, 9 },
   { OSUTF8("n5"), 4, 2, 10 },
   { OSUTF8("n6"), 5, 2, 1 },
   { OSUTF8("n7"), 6, 2, 2 },
   { OSUTF8("n8"), 7, 2, 3 }
} ;
#define utran_HARQ_Info_r7_numberOfProcesses_ENUMTABSIZE 11

const OSUTF8CHAR* utran_HARQ_Info_r7_numberOfProcesses_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HARQ_Info_r7_numberOfProcesses_ENUMTABSIZE) {
      return utran_HARQ_Info_r7_numberOfProcesses_ENUMTAB
         [utran_HARQ_Info_r7_numberOfProcesses_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HARQ_Info_r7_numberOfProcesses_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HARQ_Info_r7_numberOfProcesses* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HARQ_Info_r7_numberOfProcesses_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HARQ_Info_r7_numberOfProcesses_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HARQ_Info_r7_numberOfProcesses* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HARQ_Info_r7_numberOfProcesses_ENUMTAB, 
      utran_HARQ_Info_r7_numberOfProcesses_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HARQ_Info_r7_numberOfProcesses)
         utran_HARQ_Info_r7_numberOfProcesses_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HARQ_Info_r7_memoryPartitioning_explicit__memorySize (
   utran_HARQ_Info_r7_memoryPartitioning_explicit__memorySize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r7_memoryPartitioning_explicit__additionalMemorySizesForMIMO (
   utran_HARQ_Info_r7_memoryPartitioning_explicit__additionalMemorySizesForMIMO* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r7_memoryPartitioning_explicit_ (
   utran_HARQ_Info_r7_memoryPartitioning_explicit_* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r7_memoryPartitioning_explicit__memorySize (&pvalue->memorySize);
   asn1Init_utran_HARQ_Info_r7_memoryPartitioning_explicit__additionalMemorySizesForMIMO (&pvalue->additionalMemorySizesForMIMO);
}

void asn1Init_utran_HARQ_Info_r7_memoryPartitioning (
   utran_HARQ_Info_r7_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HARQ_Info_r7_memoryPartitioning (OSCTXT *pctxt, 
   utran_HARQ_Info_r7_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

void asn1Init_utran_HARQ_Info_r7 (utran_HARQ_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HARQ_Info_r7_memoryPartitioning (&pvalue->memoryPartitioning);
}

void asn1Free_utran_HARQ_Info_r7 (OSCTXT *pctxt, utran_HARQ_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HARQ_Info_r7_memoryPartitioning (pctxt, &pvalue->memoryPartitioning);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_r7_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation_r7 (
   utran_Serving_HSDSCH_CellInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information_r7 (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info_r7 (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation_r7 (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r7 (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
   }
}

static const OSEnumItem utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector)
         utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant (
   utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (
   utran_E_DPDCH_Reference_E_TFCIList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (OSCTXT *pctxt, 
   utran_E_DPDCH_Reference_E_TFCIList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info (
   utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7 (
   utran_E_DCH_RL_InfoNewServingCell_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7_servingGrant (&pvalue->servingGrant);
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell_r7 (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.reference_E_TFCIsPresent) {
      asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell_r7_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList (
   utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_RL_InfoOtherCell* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_RL_InfoOtherCell*)pnode->data;
      asn1Free_utran_E_DCH_RL_InfoOtherCell (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_r7 (
   utran_E_DCH_ReconfigurationInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r7 (&pvalue->e_DCH_RL_InfoNewServingCell);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList (&pvalue->e_DCH_RL_InfoOtherCellList);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_r7 (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DCH_RL_InfoNewServingCellPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell_r7 (pctxt, &pvalue->e_DCH_RL_InfoNewServingCell);
   }
   if (pvalue->m.e_DCH_RL_InfoOtherCellListPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_r7_e_DCH_RL_InfoOtherCellList (pctxt, &pvalue->e_DCH_RL_InfoOtherCellList);
   }
}

static const OSEnumItem utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_16QAM_Config_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_16QAM_Config_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_16QAM_Config_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_16QAM_Config_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_16QAM_Config_mac_es_e_resetIndicator)
         utran_UL_16QAM_Config_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_16QAM_Config (utran_UL_16QAM_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_DCH_RL_InfoSameServingCell (
   utran_E_DCH_RL_InfoSameServingCell* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (&pvalue->reference_E_TFCIs);
}

void asn1Free_utran_E_DCH_RL_InfoSameServingCell (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoSameServingCell* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.reference_E_TFCIsPresent) {
      asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
   }
}

void asn1Init_utran_E_TFC_Boost_Info_r7 (utran_E_TFC_Boost_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_HS_DSCH_TBSizeTable_ENUMTAB[] = {
   { OSUTF8("octetAligned"), 0, 12, 0 }
} ;
#define utran_HS_DSCH_TBSizeTable_ENUMTABSIZE 1

const OSUTF8CHAR* utran_HS_DSCH_TBSizeTable_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_HS_DSCH_TBSizeTable_ENUMTAB, 
      utran_HS_DSCH_TBSizeTable_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_HS_DSCH_TBSizeTable_ENUMTABSIZE) {
      return utran_HS_DSCH_TBSizeTable_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_DSCH_TBSizeTable_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HS_DSCH_TBSizeTable* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_DSCH_TBSizeTable_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_DSCH_TBSizeTable_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_HS_DSCH_TBSizeTable* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_DSCH_TBSizeTable_ENUMTAB, 
      utran_HS_DSCH_TBSizeTable_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HS_DSCH_TBSizeTable)
         utran_HS_DSCH_TBSizeTable_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MIMO_PilotConfiguration_v7f0ext (
   utran_MIMO_PilotConfiguration_v7f0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MIMO_Parameters_v7f0ext (
   utran_MIMO_Parameters_v7f0ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_PilotConfiguration_v7f0ext (pvalue);
}

static const OSEnumItem utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTABSIZE 1

const OSUTF8CHAR* utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTAB, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTABSIZE) {
      return utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTAB, 
      utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction)
         utran_MIMO_Parameters_v7g0ext_precodingWeightSetRestriction_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MIMO_Parameters_v7g0ext (
   utran_MIMO_Parameters_v7g0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MIMO_Parameters_r8_modeSpecificInfo_fdd (
   utran_MIMO_Parameters_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration (&pvalue->mimoPilotConfiguration);
}

void asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO_PilotConfiguration (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

static const OSEnumItem utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[] = {
   { OSUTF8("sf1"), 0, 3, 0 },
   { OSUTF8("sf1sf16"), 1, 7, 1 }
} ;
#define utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE) {
      return utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB
         [utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB, 
      utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream)
         utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SICH_ReferenceSignalInfoList (
   utran_HS_SICH_ReferenceSignalInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SICH_ReferenceSignalInfoList (OSCTXT *pctxt, 
   utran_HS_SICH_ReferenceSignalInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128 (
   utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SICH_ReferenceSignalInfoList (&pvalue->hs_sich_ReferenceSignalInfoList);
}

void asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_sich_ReferenceSignalInfoListPresent) {
      asn1Free_utran_HS_SICH_ReferenceSignalInfoList (pctxt, &pvalue->hs_sich_ReferenceSignalInfoList);
   }
}

void asn1Init_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd (
   utran_MIMO_Parameters_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_MIMO_Parameters_r8_modeSpecificInfo (
   utran_MIMO_Parameters_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_MIMO_Parameters_r8 (utran_MIMO_Parameters_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_Parameters_r8_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_MIMO_Parameters_r8 (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MIMO_Parameters_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_RL_AdditionInformation_r8_dl_dpchInfo (
   utran_RL_AdditionInformation_r8_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r8_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r8_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd768 (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
   asn1Init_utran_DL_MultiCarrier_Information (&pvalue->dl_MultiCarrier_Information);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_MultiCarrier_Information (pctxt, &pvalue->dl_MultiCarrier_Information);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured)
         utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8 (
   utran_DL_HSPDSCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r7 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info_r7 (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r7 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info_r7 (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_r8_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation_r8 (
   utran_Serving_HSDSCH_CellInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information_r8 (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info_r7 (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation_r8 (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r8 (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
   }
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured)
         utran_DL_SecondaryCellInfoFDD_newConfiguration_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_newConfiguration_hS_SCCHChannelisationCodeInfo (
   utran_DL_SecondaryCellInfoFDD_newConfiguration_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_newConfiguration (
   utran_DL_SecondaryCellInfoFDD_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_DL_SecondaryCellInfoFDD_newConfiguration_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD (
   utran_DL_SecondaryCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_SecondaryCellInfoFDD (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_TargetCellPreconfigInfo (
   utran_TargetCellPreconfigInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r8 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r7 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r7 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r8 (&pvalue->mimoParameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD (&pvalue->dl_SecondaryCellInfoFDD);
}

void asn1Free_utran_TargetCellPreconfigInfo (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r8 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r7 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r7 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r8 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
}

void asn1Init_utran_RL_AdditionInformation_r8 (
   utran_RL_AdditionInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r8_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_TargetCellPreconfigInfo (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r8 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r8_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r8 (
   utran_RL_AdditionInformationList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r8 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r8*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_ServingCellChangeMsgType_ENUMTAB[] = {
   { OSUTF8("physicalChannelReconfiguration"), 3, 30, 2 },
   { OSUTF8("radioBearerReconfiguration"), 1, 26, 1 },
   { OSUTF8("radioBearerSetup"), 0, 16, 3 },
   { OSUTF8("transportChannelReconfiguration"), 2, 31, 0 }
} ;
#define utran_ServingCellChangeMsgType_ENUMTABSIZE 4

const OSUTF8CHAR* utran_ServingCellChangeMsgType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ServingCellChangeMsgType_ENUMTABSIZE) {
      return utran_ServingCellChangeMsgType_ENUMTAB
         [utran_ServingCellChangeMsgType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ServingCellChangeMsgType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ServingCellChangeMsgType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ServingCellChangeMsgType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ServingCellChangeMsgType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ServingCellChangeMsgType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ServingCellChangeMsgType_ENUMTAB, 
      utran_ServingCellChangeMsgType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ServingCellChangeMsgType)
         utran_ServingCellChangeMsgType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTAB[] = {
   { OSUTF8("different"), 0, 9, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell)
         utran_DL_SecondaryCellInfoFDD_v890ext_differentTxModeFromServingHS_DSCHCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_v890ext (
   utran_DL_SecondaryCellInfoFDD_v890ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_TargetCellPreconfigInfo_v890ext (
   utran_TargetCellPreconfigInfo_v890ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_Parameters_v7f0ext (pvalue);
}

void asn1Init_utran_RL_AdditionInformation_v890ext (
   utran_RL_AdditionInformation_v890ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TargetCellPreconfigInfo_v890ext (&pvalue->targetCellPreconfigInfo);
}

void asn1Init_utran_RL_AdditionInformationList_v890ext (
   utran_RL_AdditionInformationList_v890ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_v890ext (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_v890ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern_diversityPattern (
   utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern_diversityPattern* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern (
   utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern (OSCTXT *pctxt, 
   utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.diversityPattern) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.diversityPattern);
         }
         break;

   }
}

void asn1Init_utran_MIMO_PilotConfiguration_r9 (
   utran_MIMO_PilotConfiguration_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern (&pvalue->secondCPICH_Pattern);
}

void asn1Free_utran_MIMO_PilotConfiguration_r9 (OSCTXT *pctxt, 
   utran_MIMO_PilotConfiguration_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MIMO_PilotConfiguration_r9_secondCPICH_Pattern (pctxt, &pvalue->secondCPICH_Pattern);
}

static const OSEnumItem utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTABSIZE 1

const OSUTF8CHAR* utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTAB, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTABSIZE) {
      return utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTAB, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction)
         utran_MIMO_Parameters_r9_modeSpecificInfo_fdd_precodingWeightSetRestriction_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MIMO_Parameters_r9_modeSpecificInfo_fdd (
   utran_MIMO_Parameters_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration_r9 (&pvalue->mimoPilotConfiguration);
}

void asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO_PilotConfiguration_r9 (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

static const OSEnumItem utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[] = {
   { OSUTF8("sf1"), 0, 3, 0 },
   { OSUTF8("sf1sf16"), 1, 7, 1 }
} ;
#define utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE) {
      return utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB
         [utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB, 
      utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream)
         utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128_mimoSFModeForHSPDSCHDualStream_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128 (
   utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SICH_ReferenceSignalInfoList (&pvalue->hs_sich_ReferenceSignalInfoList);
}

void asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_sich_ReferenceSignalInfoListPresent) {
      asn1Free_utran_HS_SICH_ReferenceSignalInfoList (pctxt, &pvalue->hs_sich_ReferenceSignalInfoList);
   }
}

void asn1Init_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd (
   utran_MIMO_Parameters_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_MIMO_Parameters_r9_modeSpecificInfo (
   utran_MIMO_Parameters_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_MIMO_Parameters_r9 (utran_MIMO_Parameters_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO_Parameters_r9_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_MIMO_Parameters_r9 (OSCTXT *pctxt, 
   utran_MIMO_Parameters_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MIMO_Parameters_r9_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_SecondaryServingEDCHCell_Info (
   utran_SecondaryServingEDCHCell_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RNTI (&pvalue->primary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->secondary_E_RNTI);
}

static const OSEnumItem utran_ScramblingCodeType_ENUMTAB[] = {
   { OSUTF8("longSC"), 1, 6, 1 },
   { OSUTF8("shortSC"), 0, 7, 0 }
} ;
#define utran_ScramblingCodeType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_ScramblingCodeType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ScramblingCodeType_ENUMTABSIZE) {
      return utran_ScramblingCodeType_ENUMTAB
         [utran_ScramblingCodeType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ScramblingCodeType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ScramblingCodeType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ScramblingCodeType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ScramblingCodeType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ScramblingCodeType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ScramblingCodeType_ENUMTAB, utran_ScramblingCodeType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ScramblingCodeType)
         utran_ScramblingCodeType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector)
         utran_SecondaryEDCH_Info_Common_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MinReduced_E_DPDCH_GainFactor_ENUMTAB[] = {
   { OSUTF8("m11-15"), 1, 6, 6 },
   { OSUTF8("m15-15"), 2, 6, 0 },
   { OSUTF8("m21-15"), 3, 6, 1 },
   { OSUTF8("m30-15"), 4, 6, 2 },
   { OSUTF8("m42-15"), 5, 6, 3 },
   { OSUTF8("m60-15"), 6, 6, 4 },
   { OSUTF8("m8-15"), 0, 5, 5 },
   { OSUTF8("m84-15"), 7, 6, 7 }
} ;
#define utran_MinReduced_E_DPDCH_GainFactor_ENUMTABSIZE 8

const OSUTF8CHAR* utran_MinReduced_E_DPDCH_GainFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MinReduced_E_DPDCH_GainFactor_ENUMTABSIZE) {
      return utran_MinReduced_E_DPDCH_GainFactor_ENUMTAB
         [utran_MinReduced_E_DPDCH_GainFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MinReduced_E_DPDCH_GainFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MinReduced_E_DPDCH_GainFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MinReduced_E_DPDCH_GainFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MinReduced_E_DPDCH_GainFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MinReduced_E_DPDCH_GainFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MinReduced_E_DPDCH_GainFactor_ENUMTAB, 
      utran_MinReduced_E_DPDCH_GainFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MinReduced_E_DPDCH_GainFactor)
         utran_MinReduced_E_DPDCH_GainFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SecondaryEDCH_Info_Common (
   utran_SecondaryEDCH_Info_Common* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_FrequencyInfo (&pvalue->frequencyInfo);
   pvalue->ms2_SchedTransmGrantHARQAlloc.numbits = 0;
}

void asn1Free_utran_SecondaryEDCH_Info_Common (OSCTXT *pctxt, 
   utran_SecondaryEDCH_Info_Common* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FrequencyInfo (pctxt, &pvalue->frequencyInfo);
}

void asn1Init_utran_DL_InformationPerSecondaryRL_e_RGCH_Info (
   utran_DL_InformationPerSecondaryRL_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerSecondaryRL_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL (
   utran_DL_InformationPerSecondaryRL* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (&pvalue->dl_FDPCHInfoPerRL_SecULFreq);
   asn1Init_utran_DL_InformationPerSecondaryRL_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_DL_InformationPerSecondaryRL (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL_List (
   utran_DL_InformationPerSecondaryRL_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerSecondaryRL_List (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerSecondaryRL* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerSecondaryRL*)pnode->data;
      asn1Free_utran_DL_InformationPerSecondaryRL (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD_newConfiguration (
   utran_UL_SecondaryCellInfoFDD_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryServingEDCHCell_Info (&pvalue->secondaryServingEDCHCell_Info);
   asn1Init_utran_SecondaryEDCH_Info_Common (&pvalue->secondaryEDCH_Info_Common);
   asn1Init_utran_DL_InformationPerSecondaryRL_List (&pvalue->dl_InformationPerSecondaryRL_List);
}

void asn1Free_utran_UL_SecondaryCellInfoFDD_newConfiguration (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.secondaryEDCH_Info_CommonPresent) {
      asn1Free_utran_SecondaryEDCH_Info_Common (pctxt, &pvalue->secondaryEDCH_Info_Common);
   }
   if (pvalue->m.dl_InformationPerSecondaryRL_ListPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_List (pctxt, &pvalue->dl_InformationPerSecondaryRL_List);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD (
   utran_UL_SecondaryCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_SecondaryCellInfoFDD (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_UL_SecondaryCellInfoFDD_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info (
   utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoNewSecServingCell (
   utran_E_DCH_RL_InfoNewSecServingCell* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoNewSecServingCell (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewSecServingCell* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewSecServingCell_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info (
   utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_SecULFreq (
   utran_E_DCH_RL_InfoOtherCell_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_SecULFreq (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoOtherCell_SecULFreq_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq (
   utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_RL_InfoOtherCell_SecULFreq* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_RL_InfoOtherCell_SecULFreq*)pnode->data;
      asn1Free_utran_E_DCH_RL_InfoOtherCell_SecULFreq (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (
   utran_E_DCH_ReconfigurationInfo_SecULFrequency* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewSecServingCell (&pvalue->e_DCH_RL_InfoNewSecServingCell);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq (&pvalue->e_DCH_RL_InfoOtherCellList_SecULFreq);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_SecULFrequency* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DCH_RL_InfoNewSecServingCellPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewSecServingCell (pctxt, &pvalue->e_DCH_RL_InfoNewSecServingCell);
   }
   if (pvalue->m.e_DCH_RL_InfoOtherCellList_SecULFreqPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency_e_DCH_RL_InfoOtherCellList_SecULFreq (pctxt, &pvalue->e_DCH_RL_InfoOtherCellList_SecULFreq);
   }
}

void asn1Init_utran_RL_AdditionInformation_r9_dl_dpchInfo (
   utran_RL_AdditionInformation_r9_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r9_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r9_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_fdd (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD384_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD384_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD384_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384 (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD768* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD768*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD768 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768 (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

static const OSEnumItem utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB
         [utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size)
         utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB
         [utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB, 
      utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size)
         utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD128_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD128_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD128_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128 (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd (
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo (
   utran_HS_SCCH_Info_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r9 (utran_HS_SCCH_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_r9_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_HS_SCCH_Info_r9 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r9_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd768 (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator)
         utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_OutofSyncWindow_ENUMTAB[] = {
   { OSUTF8("ms160"), 2, 5, 2 },
   { OSUTF8("ms320"), 3, 5, 4 },
   { OSUTF8("ms40"), 0, 4, 0 },
   { OSUTF8("ms640"), 4, 5, 1 },
   { OSUTF8("ms80"), 1, 4, 3 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define utran_OutofSyncWindow_ENUMTABSIZE 8

const OSUTF8CHAR* utran_OutofSyncWindow_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_OutofSyncWindow_ENUMTABSIZE) {
      return utran_OutofSyncWindow_ENUMTAB
         [utran_OutofSyncWindow_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_OutofSyncWindow_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_OutofSyncWindow* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_OutofSyncWindow_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_OutofSyncWindow_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_OutofSyncWindow* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_OutofSyncWindow_ENUMTAB, utran_OutofSyncWindow_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_OutofSyncWindow)
         utran_OutofSyncWindow_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
   asn1Init_utran_DL_MultiCarrier_Information (&pvalue->dl_MultiCarrier_Information);
}

void asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_MultiCarrier_Information (pctxt, &pvalue->dl_MultiCarrier_Information);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured)
         utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r9 (
   utran_DL_HSPDSCH_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info_r7 (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r9 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r9 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info_r7 (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r9_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_r9_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation_r9 (
   utran_Serving_HSDSCH_CellInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information_r9 (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info_r7 (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation_r9 (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r9 (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
   }
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured)
         utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (
   utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[] = {
   { OSUTF8("different"), 0, 9, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell)
         utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration (
   utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo (
   utran_DL_SecondaryCellInfoFDD_r9_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r9_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCellMIMOparametersFDD_newConfiguration (
   utran_SecondaryCellMIMOparametersFDD_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration_r9 (&pvalue->mimoPilotConfiguration);
}

void asn1Free_utran_SecondaryCellMIMOparametersFDD_newConfiguration (OSCTXT *pctxt, 
   utran_SecondaryCellMIMOparametersFDD_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO_PilotConfiguration_r9 (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

void asn1Init_utran_SecondaryCellMIMOparametersFDD (
   utran_SecondaryCellMIMOparametersFDD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCellMIMOparametersFDD (OSCTXT *pctxt, 
   utran_SecondaryCellMIMOparametersFDD* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_SecondaryCellMIMOparametersFDD_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r9 (
   utran_DL_SecondaryCellInfoFDD_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo (&pvalue->configurationInfo);
   asn1Init_utran_SecondaryCellMIMOparametersFDD (&pvalue->secondaryCellMIMOparameters);
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r9 (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_SecondaryCellInfoFDD_r9_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (pvalue->m.secondaryCellMIMOparametersPresent) {
      asn1Free_utran_SecondaryCellMIMOparametersFDD (pctxt, &pvalue->secondaryCellMIMOparameters);
   }
}

void asn1Init_utran_TargetCellPreconfigInfo_r9 (
   utran_TargetCellPreconfigInfo_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r9 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r7 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r7 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r9 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_UL_SecondaryCellInfoFDD (&pvalue->ul_SecondaryCellInfoFDD);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (&pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
}

void asn1Free_utran_TargetCellPreconfigInfo_r9 (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r9 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r7 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r7 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r9 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.ul_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_UL_SecondaryCellInfoFDD (pctxt, &pvalue->ul_SecondaryCellInfoFDD);
   }
   if (pvalue->m.e_dch_ReconfigurationInfo_SecULFrequencyPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (pctxt, &pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   }
}

void asn1Init_utran_RL_AdditionInformation_r9 (
   utran_RL_AdditionInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r9_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_TargetCellPreconfigInfo_r9 (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r9 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r9_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo_r9 (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r9 (
   utran_RL_AdditionInformationList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r9 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r9* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r9* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r9*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r9 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RL_AdditionInformation_SecULFreq (
   utran_RL_AdditionInformation_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (&pvalue->dl_FDPCH_InfoPerRL);
}

void asn1Init_utran_RL_AdditionInformationList_SecULFreq (
   utran_RL_AdditionInformationList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_SecULFreq (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_RL_RemovalInformationList_SecULFreq (
   utran_RL_RemovalInformationList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_RemovalInformationList_SecULFreq (OSCTXT *pctxt, 
   utran_RL_RemovalInformationList_SecULFreq* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTABSIZE 1

const OSUTF8CHAR* utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTAB, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTABSIZE) {
      return utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTAB, 
      utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction)
         utran_SecondaryCellMIMOparametersFDD_v950ext_precodingWeightSetRestriction_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SecondaryCellMIMOparametersFDD_v950ext (
   utran_SecondaryCellMIMOparametersFDD_v950ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_TargetCellPreconfigInfo_v950ext (
   utran_TargetCellPreconfigInfo_v950ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCellMIMOparametersFDD_v950ext (pvalue);
}

void asn1Init_utran_RL_AdditionInformation_v950ext (
   utran_RL_AdditionInformation_v950ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TargetCellPreconfigInfo_v950ext (&pvalue->targetCellPreconfigInfo);
}

void asn1Init_utran_RL_AdditionInformationList_v950ext (
   utran_RL_AdditionInformationList_v950ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_v950ext (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_v950ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_RL_AdditionInformation_r10_dl_dpchInfo (
   utran_RL_AdditionInformation_r10_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r10_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r10_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured)
         utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (
   utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[] = {
   { OSUTF8("different"), 0, 9, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell)
         utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration (
   utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo (
   utran_DL_SecondaryCellInfoFDD_r10_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r10_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

static const OSEnumItem utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTABSIZE 1

const OSUTF8CHAR* utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTAB, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTABSIZE) {
      return utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTAB, 
      utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction)
         utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration_precodingWeightSetRestriction_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration (
   utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration_r9 (&pvalue->mimoPilotConfiguration);
}

void asn1Free_utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration (OSCTXT *pctxt, 
   utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO_PilotConfiguration_r9 (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

void asn1Init_utran_SecondaryCellMIMOparametersFDD_r10 (
   utran_SecondaryCellMIMOparametersFDD_r10* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCellMIMOparametersFDD_r10 (OSCTXT *pctxt, 
   utran_SecondaryCellMIMOparametersFDD_r10* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_SecondaryCellMIMOparametersFDD_r10_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r10 (
   utran_DL_SecondaryCellInfoFDD_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo (&pvalue->configurationInfo);
   asn1Init_utran_SecondaryCellMIMOparametersFDD_r10 (&pvalue->secondaryCellMIMOparameters);
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r10 (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_SecondaryCellInfoFDD_r10_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (pvalue->m.secondaryCellMIMOparametersPresent) {
      asn1Free_utran_SecondaryCellMIMOparametersFDD_r10 (pctxt, &pvalue->secondaryCellMIMOparameters);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoFDD (
   utran_AdditionalDLSecCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_r10 (&pvalue->dl_SecondaryCellInfoFDD);
}

void asn1Free_utran_AdditionalDLSecCellInfoFDD (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r10 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoListFDD (
   utran_AdditionalDLSecCellInfoListFDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AdditionalDLSecCellInfoListFDD (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoListFDD* pvalue)
{
   if (0 == pvalue) return;
   { utran_AdditionalDLSecCellInfoFDD* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_AdditionalDLSecCellInfoFDD*)pnode->data;
      asn1Free_utran_AdditionalDLSecCellInfoFDD (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TargetCellPreconfigInfo_r10 (
   utran_TargetCellPreconfigInfo_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r9 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r7 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r7 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r10 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD (&pvalue->additionalDLSecCellInfoListFDD);
   asn1Init_utran_UL_SecondaryCellInfoFDD (&pvalue->ul_SecondaryCellInfoFDD);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (&pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
}

void asn1Free_utran_TargetCellPreconfigInfo_r10 (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r9 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r7 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r7 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r10 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDDPresent) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
   }
   if (pvalue->m.ul_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_UL_SecondaryCellInfoFDD (pctxt, &pvalue->ul_SecondaryCellInfoFDD);
   }
   if (pvalue->m.e_dch_ReconfigurationInfo_SecULFrequencyPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (pctxt, &pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   }
}

void asn1Init_utran_RL_AdditionInformation_r10 (
   utran_RL_AdditionInformation_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r10_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_TargetCellPreconfigInfo_r10 (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r10 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r10_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo_r10 (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r10 (
   utran_RL_AdditionInformationList_r10* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r10 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r10* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r10* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r10*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r10 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_OLTD_InfoFDD_ulOLTDActivation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTAB, 
      utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTABSIZE) {
      return utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_OLTD_InfoFDD_ulOLTDActivation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_OLTD_InfoFDD_ulOLTDActivation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_OLTD_InfoFDD_ulOLTDActivation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_OLTD_InfoFDD_ulOLTDActivation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_OLTD_InfoFDD_ulOLTDActivation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTAB, 
      utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_OLTD_InfoFDD_ulOLTDActivation)
         utran_UL_OLTD_InfoFDD_ulOLTDActivation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TargetCellPreconfigInfo_vb50ext (
   utran_TargetCellPreconfigInfo_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_RL_AdditionInformation_vb50ext (
   utran_RL_AdditionInformation_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TargetCellPreconfigInfo_vb50ext (&pvalue->targetCellPreconfigInfo);
}

void asn1Init_utran_RL_AdditionInformationList_vb50ext (
   utran_RL_AdditionInformationList_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_vb50ext (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_vb50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_Antenna3And4_S_CPICH (utran_Antenna3And4_S_CPICH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTAB[] = {
   { OSUTF8("activated"), 0, 9, 0 }
} ;
#define utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTAB, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTABSIZE) {
      return utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTAB, 
      utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Antenna3And4_D_CPICH_initialD_CPICHStatus)
         utran_Antenna3And4_D_CPICH_initialD_CPICHStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Antenna3And4_D_CPICH (utran_Antenna3And4_D_CPICH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_Antenna3And4 (utran_Antenna3And4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_Antenna3And4_S_CPICH (&pvalue->antenna3And4_S_CPICH);
   asn1Init_utran_Antenna3And4_D_CPICH (&pvalue->antenna3And4_D_CPICH);
}

void asn1Init_utran_MIMO4x4_PilotConfiguration (
   utran_MIMO4x4_PilotConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO_PilotConfiguration_r9 (&pvalue->antenna2);
   asn1Init_utran_Antenna3And4 (&pvalue->antenna3And4);
}

void asn1Free_utran_MIMO4x4_PilotConfiguration (OSCTXT *pctxt, 
   utran_MIMO4x4_PilotConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.antenna2Present) {
      asn1Free_utran_MIMO_PilotConfiguration_r9 (pctxt, &pvalue->antenna2);
   }
}

void asn1Init_utran_MIMO4x4_Parameters_configurationInfo_newConfiguration_precodingWeightSetRestriction (
   utran_MIMO4x4_Parameters_configurationInfo_newConfiguration_precodingWeightSetRestriction* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_MIMO4x4_Parameters_configurationInfo_newConfiguration (
   utran_MIMO4x4_Parameters_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO4x4_PilotConfiguration (&pvalue->mimo4x4PilotConfiguration);
   asn1Init_utran_MIMO4x4_Parameters_configurationInfo_newConfiguration_precodingWeightSetRestriction (&pvalue->precodingWeightSetRestriction);
}

void asn1Free_utran_MIMO4x4_Parameters_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_MIMO4x4_Parameters_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimo4x4PilotConfigurationPresent) {
      asn1Free_utran_MIMO4x4_PilotConfiguration (pctxt, &pvalue->mimo4x4PilotConfiguration);
   }
}

void asn1Init_utran_MIMO4x4_Parameters_configurationInfo (
   utran_MIMO4x4_Parameters_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MIMO4x4_Parameters_configurationInfo (OSCTXT *pctxt, 
   utran_MIMO4x4_Parameters_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_MIMO4x4_Parameters_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_MIMO4x4_Parameters (utran_MIMO4x4_Parameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MIMO4x4_Parameters_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_MIMO4x4_Parameters (OSCTXT *pctxt, 
   utran_MIMO4x4_Parameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MIMO4x4_Parameters_configurationInfo (pctxt, &pvalue->configurationInfo);
}

static const OSEnumItem utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTAB[] = {
   { OSUTF8("first-state"), 0, 11, 0 },
   { OSUTF8("second-state"), 1, 12, 1 }
} ;
#define utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTABSIZE) {
      return utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTAB
         [utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTAB, 
      utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState)
         utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration_initial_CLTD_ActivationState_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration (
   utran_UL_CLTD_InfoFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_CLTD_InfoFDD_configurationInfo (
   utran_UL_CLTD_InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CLTD_InfoFDD_configurationInfo (OSCTXT *pctxt, 
   utran_UL_CLTD_InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_UL_CLTD_InfoFDD (utran_UL_CLTD_InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_CLTD_InfoFDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_UL_CLTD_InfoFDD (OSCTXT *pctxt, 
   utran_UL_CLTD_InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_CLTD_InfoFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_F_TPICH_InfoOtherCell_f_tpich_Info (
   utran_F_TPICH_InfoOtherCell_f_tpich_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_F_TPICH_InfoOtherCell_f_tpich_Info (OSCTXT *pctxt, 
   utran_F_TPICH_InfoOtherCell_f_tpich_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.f_tpich_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.f_tpich_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_F_TPICH_InfoOtherCell (utran_F_TPICH_InfoOtherCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_F_TPICH_InfoOtherCell_f_tpich_Info (&pvalue->f_tpich_Info);
}

void asn1Free_utran_F_TPICH_InfoOtherCell (OSCTXT *pctxt, 
   utran_F_TPICH_InfoOtherCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_F_TPICH_InfoOtherCell_f_tpich_Info (pctxt, &pvalue->f_tpich_Info);
}

void asn1Init_utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList (
   utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList (OSCTXT *pctxt, 
   utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   { utran_F_TPICH_InfoOtherCell* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_F_TPICH_InfoOtherCell*)pnode->data;
      asn1Free_utran_F_TPICH_InfoOtherCell (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_F_TPICH_ReconfigurationInfo (
   utran_F_TPICH_ReconfigurationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList (&pvalue->f_tpich_InfoOtherCellList);
}

void asn1Free_utran_F_TPICH_ReconfigurationInfo (OSCTXT *pctxt, 
   utran_F_TPICH_ReconfigurationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.f_tpich_InfoOtherCellListPresent) {
      asn1Free_utran_F_TPICH_ReconfigurationInfo_f_tpich_InfoOtherCellList (pctxt, &pvalue->f_tpich_InfoOtherCellList);
   }
}

void asn1Init_utran_RL_AdditionInformation_r11_dl_dpchInfo (
   utran_RL_AdditionInformation_r11_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r11_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r11_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_E_HICH_Information_r11 (
   utran_E_HICH_Information_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_Measurement_Feedback_Info_r11_modeSpecificInfo_fdd (
   utran_Measurement_Feedback_Info_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_Measurement_Feedback_Info_r11_modeSpecificInfo (
   utran_Measurement_Feedback_Info_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Measurement_Feedback_Info_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_Measurement_Feedback_Info_r11 (
   utran_Measurement_Feedback_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Measurement_Feedback_Info_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_Measurement_Feedback_Info_r11 (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Measurement_Feedback_Info_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd768 (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator)
         utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
   asn1Init_utran_DL_MultiCarrier_Information (&pvalue->dl_MultiCarrier_Information);
}

void asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_MultiCarrier_Information (pctxt, &pvalue->dl_MultiCarrier_Information);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured)
         utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r11 (
   utran_DL_HSPDSCH_Information_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info_r11 (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r11 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r9 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info_r11 (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_HARQ_Info_r11_numberOfProcesses_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n12"), 8, 3, 4 },
   { OSUTF8("n14"), 9, 3, 7 },
   { OSUTF8("n16"), 10, 3, 9 },
   { OSUTF8("n2"), 1, 2, 10 },
   { OSUTF8("n24"), 11, 3, 11 },
   { OSUTF8("n28"), 12, 3, 12 },
   { OSUTF8("n3"), 2, 2, 13 },
   { OSUTF8("n32"), 13, 3, 1 },
   { OSUTF8("n4"), 3, 2, 2 },
   { OSUTF8("n5"), 4, 2, 3 },
   { OSUTF8("n6"), 5, 2, 5 },
   { OSUTF8("n7"), 6, 2, 6 },
   { OSUTF8("n8"), 7, 2, 8 }
} ;
#define utran_HARQ_Info_r11_numberOfProcesses_ENUMTABSIZE 14

const OSUTF8CHAR* utran_HARQ_Info_r11_numberOfProcesses_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HARQ_Info_r11_numberOfProcesses_ENUMTABSIZE) {
      return utran_HARQ_Info_r11_numberOfProcesses_ENUMTAB
         [utran_HARQ_Info_r11_numberOfProcesses_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HARQ_Info_r11_numberOfProcesses_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HARQ_Info_r11_numberOfProcesses* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HARQ_Info_r11_numberOfProcesses_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HARQ_Info_r11_numberOfProcesses_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HARQ_Info_r11_numberOfProcesses* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HARQ_Info_r11_numberOfProcesses_ENUMTAB, 
      utran_HARQ_Info_r11_numberOfProcesses_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HARQ_Info_r11_numberOfProcesses)
         utran_HARQ_Info_r11_numberOfProcesses_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__memorySize (
   utran_HARQ_Info_r11_memoryPartitioning_explicit__memorySize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesForMIMO (
   utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesForMIMO* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (
   utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (
   utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit_ (
   utran_HARQ_Info_r11_memoryPartitioning_explicit_* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__memorySize (&pvalue->memorySize);
   asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesForMIMO (&pvalue->additionalMemorySizesForMIMO);
   asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (&pvalue->additionalMemorySizesThirdMIMOStream);
   asn1Init_utran_HARQ_Info_r11_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (&pvalue->additionalMemorySizesFourthMIMOStream);
}

void asn1Init_utran_HARQ_Info_r11_memoryPartitioning (
   utran_HARQ_Info_r11_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HARQ_Info_r11_memoryPartitioning (OSCTXT *pctxt, 
   utran_HARQ_Info_r11_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

void asn1Init_utran_HARQ_Info_r11 (utran_HARQ_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HARQ_Info_r11_memoryPartitioning (&pvalue->memoryPartitioning);
}

void asn1Free_utran_HARQ_Info_r11 (OSCTXT *pctxt, utran_HARQ_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HARQ_Info_r11_memoryPartitioning (pctxt, &pvalue->memoryPartitioning);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting)
         utran_Serving_HSDSCH_CellInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation_r11 (
   utran_Serving_HSDSCH_CellInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information_r11 (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info_r11 (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation_r11 (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r11 (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r11 (pctxt, &pvalue->harqInfo);
   }
}

void asn1Init_utran_E_ROCH_Information (utran_E_ROCH_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_RNTI (&pvalue->e_roch_e_rnti);
}

static const OSEnumItem utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector)
         utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant (
   utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info (
   utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11 (
   utran_E_DCH_RL_InfoNewServingCell_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_ROCH_Information (&pvalue->e_ROCH_Information);
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11_servingGrant (&pvalue->servingGrant);
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_HICH_Information_r11 (&pvalue->e_HICH_Information);
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoNewServingCell_r11 (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoNewServingCell_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.reference_E_TFCIsPresent) {
      asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell_r11_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info (
   utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

      case 3:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info (
   utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_RL_InfoOtherCell_r11 (
   utran_E_DCH_RL_InfoOtherCell_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_E_DCH_RL_InfoOtherCell_r11 (OSCTXT *pctxt, 
   utran_E_DCH_RL_InfoOtherCell_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoOtherCell_r11_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_E_DCH_RL_InfoOtherCell_r11_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList (
   utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_RL_InfoOtherCell_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_RL_InfoOtherCell_r11*)pnode->data;
      asn1Free_utran_E_DCH_RL_InfoOtherCell_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_DCH_ReconfigurationInfo_r11 (
   utran_E_DCH_ReconfigurationInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_RL_InfoNewServingCell_r11 (&pvalue->e_DCH_RL_InfoNewServingCell);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList (&pvalue->e_DCH_RL_InfoOtherCellList);
}

void asn1Free_utran_E_DCH_ReconfigurationInfo_r11 (OSCTXT *pctxt, 
   utran_E_DCH_ReconfigurationInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DCH_RL_InfoNewServingCellPresent) {
      asn1Free_utran_E_DCH_RL_InfoNewServingCell_r11 (pctxt, &pvalue->e_DCH_RL_InfoNewServingCell);
   }
   if (pvalue->m.e_DCH_RL_InfoOtherCellListPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_r11_e_DCH_RL_InfoOtherCellList (pctxt, &pvalue->e_DCH_RL_InfoOtherCellList);
   }
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured)
         utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (
   utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[] = {
   { OSUTF8("different"), 0, 9, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell)
         utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MultiflowCellType_ENUMTAB[] = {
   { OSUTF8("inter-nodeB"), 1, 11, 1 },
   { OSUTF8("intra-nodeB"), 0, 11, 0 }
} ;
#define utran_MultiflowCellType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MultiflowCellType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MultiflowCellType_ENUMTABSIZE) {
      return utran_MultiflowCellType_ENUMTAB
         [utran_MultiflowCellType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MultiflowCellType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MultiflowCellType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MultiflowCellType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MultiflowCellType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MultiflowCellType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MultiflowCellType_ENUMTAB, utran_MultiflowCellType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MultiflowCellType)
         utran_MultiflowCellType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_MultiflowConfigurationInfo_timeReferenceCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTAB, 
      utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTABSIZE) {
      return utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MultiflowConfigurationInfo_timeReferenceCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_MultiflowConfigurationInfo_timeReferenceCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MultiflowConfigurationInfo_timeReferenceCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MultiflowConfigurationInfo_timeReferenceCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MultiflowConfigurationInfo_timeReferenceCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTAB, 
      utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MultiflowConfigurationInfo_timeReferenceCell)
         utran_MultiflowConfigurationInfo_timeReferenceCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MultiflowConfigurationInfo (
   utran_MultiflowConfigurationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration (
   utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
   asn1Init_utran_MultiflowConfigurationInfo (&pvalue->multiflowConfigurationInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo (
   utran_DL_SecondaryCellInfoFDD_r11_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r11_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration_precodingWeightSetRestriction (
   utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration_precodingWeightSetRestriction* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration (
   utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MIMO4x4_PilotConfiguration (&pvalue->mimoPilotConfiguration);
   asn1Init_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration_precodingWeightSetRestriction (&pvalue->precodingWeightSetRestriction);
}

void asn1Free_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mimoPilotConfigurationPresent) {
      asn1Free_utran_MIMO4x4_PilotConfiguration (pctxt, &pvalue->mimoPilotConfiguration);
   }
}

void asn1Init_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo (
   utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo (OSCTXT *pctxt, 
   utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCell4x4MIMOparametersFDD (
   utran_SecondaryCell4x4MIMOparametersFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_SecondaryCell4x4MIMOparametersFDD (OSCTXT *pctxt, 
   utran_SecondaryCell4x4MIMOparametersFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SecondaryCell4x4MIMOparametersFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (
   utran_DL_SecondaryCellInfoFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo (&pvalue->configurationInfo);
   asn1Init_utran_SecondaryCellMIMOparametersFDD_r10 (&pvalue->secondaryCellMIMOparameters);
   asn1Init_utran_SecondaryCell4x4MIMOparametersFDD (&pvalue->secondaryCell4x4MIMOparameters);
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_SecondaryCellInfoFDD_r11_configurationInfo (pctxt, &pvalue->configurationInfo);
   if (pvalue->m.secondaryCellMIMOparametersPresent) {
      asn1Free_utran_SecondaryCellMIMOparametersFDD_r10 (pctxt, &pvalue->secondaryCellMIMOparameters);
   }
   if (pvalue->m.secondaryCell4x4MIMOparametersPresent) {
      asn1Free_utran_SecondaryCell4x4MIMOparametersFDD (pctxt, &pvalue->secondaryCell4x4MIMOparameters);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoFDD_r11 (
   utran_AdditionalDLSecCellInfoFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (&pvalue->dl_SecondaryCellInfoFDD);
}

void asn1Free_utran_AdditionalDLSecCellInfoFDD_r11 (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoListFDD_r11 (
   utran_AdditionalDLSecCellInfoListFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AdditionalDLSecCellInfoListFDD_r11 (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoListFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_AdditionalDLSecCellInfoFDD_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_AdditionalDLSecCellInfoFDD_r11*)pnode->data;
      asn1Free_utran_AdditionalDLSecCellInfoFDD_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoListFDD2 (
   utran_AdditionalDLSecCellInfoListFDD2* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AdditionalDLSecCellInfoListFDD2 (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoListFDD2* pvalue)
{
   if (0 == pvalue) return;
   { utran_AdditionalDLSecCellInfoFDD_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_AdditionalDLSecCellInfoFDD_r11*)pnode->data;
      asn1Free_utran_AdditionalDLSecCellInfoFDD_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_64QAM_Config_mac_is_i_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTAB, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTABSIZE) {
      return utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_64QAM_Config_mac_is_i_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_64QAM_Config_mac_is_i_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_64QAM_Config_mac_is_i_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTAB, 
      utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_64QAM_Config_mac_is_i_resetIndicator)
         utran_UL_64QAM_Config_mac_is_i_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_64QAM_Config (utran_UL_64QAM_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_MIMO_InfoFDD_configurationInfo_newConfiguration (
   utran_UL_MIMO_InfoFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_MIMO_InfoFDD_configurationInfo (
   utran_UL_MIMO_InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_MIMO_InfoFDD_configurationInfo (OSCTXT *pctxt, 
   utran_UL_MIMO_InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_UL_MIMO_InfoFDD (utran_UL_MIMO_InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_MIMO_InfoFDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_UL_MIMO_InfoFDD (OSCTXT *pctxt, 
   utran_UL_MIMO_InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_MIMO_InfoFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_TargetCellPreconfigInfo_r11 (
   utran_TargetCellPreconfigInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r11 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r11 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r7 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_MIMO4x4_Parameters (&pvalue->mimo4x4Parameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD_r11 (&pvalue->additionalDLSecCellInfoListFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD2 (&pvalue->additionalDLSecCellInfoListFDD2);
   asn1Init_utran_UL_SecondaryCellInfoFDD (&pvalue->ul_SecondaryCellInfoFDD);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (&pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   asn1Init_utran_UL_CLTD_InfoFDD (&pvalue->ul_CLTD_InfoFDD);
   asn1Init_utran_F_TPICH_ReconfigurationInfo (&pvalue->f_tpich_ReconfigurationInfo);
   asn1Init_utran_UL_16QAM_Config (&pvalue->ul_16QAM_Config);
   asn1Init_utran_UL_64QAM_Config (&pvalue->ul_64QAM_Config);
   asn1Init_utran_UL_MIMO_InfoFDD (&pvalue->ul_MIMO_Info);
}

void asn1Free_utran_TargetCellPreconfigInfo_r11 (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r11 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r11 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r7 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.mimo4x4ParametersPresent) {
      asn1Free_utran_MIMO4x4_Parameters (pctxt, &pvalue->mimo4x4Parameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDDPresent) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD_r11 (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDD2Present) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD2 (pctxt, &pvalue->additionalDLSecCellInfoListFDD2);
   }
   if (pvalue->m.ul_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_UL_SecondaryCellInfoFDD (pctxt, &pvalue->ul_SecondaryCellInfoFDD);
   }
   if (pvalue->m.e_dch_ReconfigurationInfo_SecULFrequencyPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (pctxt, &pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   }
   if (pvalue->m.ul_CLTD_InfoFDDPresent) {
      asn1Free_utran_UL_CLTD_InfoFDD (pctxt, &pvalue->ul_CLTD_InfoFDD);
   }
   if (pvalue->m.f_tpich_ReconfigurationInfoPresent) {
      asn1Free_utran_F_TPICH_ReconfigurationInfo (pctxt, &pvalue->f_tpich_ReconfigurationInfo);
   }
   if (pvalue->m.ul_MIMO_InfoPresent) {
      asn1Free_utran_UL_MIMO_InfoFDD (pctxt, &pvalue->ul_MIMO_Info);
   }
}

void asn1Init_utran_RL_AdditionInformation_r11 (
   utran_RL_AdditionInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r11_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_HICH_Information_r11 (&pvalue->e_HICH_Information);
   asn1Init_utran_TargetCellPreconfigInfo_r11 (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r11 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r11_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo_r11 (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r11 (
   utran_RL_AdditionInformationList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r11 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r11*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTAB[] = {
   { OSUTF8("spare1"), 31, 6, 24 },
   { OSUTF8("spare10"), 22, 7, 26 },
   { OSUTF8("spare11"), 21, 7, 30 },
   { OSUTF8("spare12"), 20, 7, 14 },
   { OSUTF8("spare13"), 19, 7, 18 },
   { OSUTF8("spare14"), 18, 7, 20 },
   { OSUTF8("spare2"), 30, 6, 22 },
   { OSUTF8("spare3"), 29, 6, 25 },
   { OSUTF8("spare4"), 28, 6, 28 },
   { OSUTF8("spare5"), 27, 6, 31 },
   { OSUTF8("spare6"), 26, 6, 16 },
   { OSUTF8("spare7"), 25, 6, 19 },
   { OSUTF8("spare8"), 24, 6, 21 },
   { OSUTF8("spare9"), 23, 6, 23 },
   { OSUTF8("sub-frames-10"), 3, 13, 27 },
   { OSUTF8("sub-frames-1024"), 16, 15, 29 },
   { OSUTF8("sub-frames-128"), 10, 14, 15 },
   { OSUTF8("sub-frames-1280"), 17, 15, 17 },
   { OSUTF8("sub-frames-16"), 4, 13, 5 },
   { OSUTF8("sub-frames-160"), 11, 14, 4 },
   { OSUTF8("sub-frames-20"), 5, 13, 3 },
   { OSUTF8("sub-frames-256"), 12, 14, 2 },
   { OSUTF8("sub-frames-32"), 6, 13, 1 },
   { OSUTF8("sub-frames-320"), 13, 14, 13 },
   { OSUTF8("sub-frames-4"), 0, 12, 12 },
   { OSUTF8("sub-frames-40"), 7, 13, 11 },
   { OSUTF8("sub-frames-5"), 1, 12, 10 },
   { OSUTF8("sub-frames-512"), 14, 14, 9 },
   { OSUTF8("sub-frames-64"), 8, 13, 8 },
   { OSUTF8("sub-frames-640"), 15, 14, 7 },
   { OSUTF8("sub-frames-8"), 2, 12, 6 },
   { OSUTF8("sub-frames-80"), 9, 13, 0 }
} ;
#define utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTABSIZE 32

const OSUTF8CHAR* utran_UE_DTX_Cycle2_2ms_Secondary_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTABSIZE) {
      return utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTAB
         [utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DTX_Cycle2_2ms_Secondary_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DTX_Cycle2_2ms_Secondary* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DTX_Cycle2_2ms_Secondary_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DTX_Cycle2_2ms_Secondary_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_DTX_Cycle2_2ms_Secondary* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTAB, 
      utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DTX_Cycle2_2ms_Secondary)
         utran_UE_DTX_Cycle2_2ms_Secondary_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length_dtx_e_dch_TTI_2ms (
   utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length_dtx_e_dch_TTI_2ms* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length (
   utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length (OSCTXT *pctxt, 
   utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.dtx_e_dch_TTI_2ms) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dtx_e_dch_TTI_2ms);
         }
         break;

   }
}

void asn1Init_utran_DTX_Info_SecondaryUplinkFrequency (
   utran_DTX_Info_SecondaryUplinkFrequency* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length (&pvalue->e_dch_TTI_Length);
}

void asn1Free_utran_DTX_Info_SecondaryUplinkFrequency (OSCTXT *pctxt, 
   utran_DTX_Info_SecondaryUplinkFrequency* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DTX_Info_SecondaryUplinkFrequency_e_dch_TTI_Length (pctxt, &pvalue->e_dch_TTI_Length);
}

static const OSEnumItem utran_UE_DRX_Cycle2_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 10 },
   { OSUTF8("spare2"), 14, 6, 12 },
   { OSUTF8("spare3"), 13, 6, 14 },
   { OSUTF8("spare4"), 12, 6, 6 },
   { OSUTF8("spare5"), 11, 6, 7 },
   { OSUTF8("spare6"), 10, 6, 8 },
   { OSUTF8("sub-frames-10"), 3, 13, 9 },
   { OSUTF8("sub-frames-16"), 4, 13, 11 },
   { OSUTF8("sub-frames-20"), 5, 13, 13 },
   { OSUTF8("sub-frames-32"), 6, 13, 15 },
   { OSUTF8("sub-frames-4"), 0, 12, 5 },
   { OSUTF8("sub-frames-40"), 7, 13, 4 },
   { OSUTF8("sub-frames-5"), 1, 12, 3 },
   { OSUTF8("sub-frames-64"), 8, 13, 2 },
   { OSUTF8("sub-frames-8"), 2, 12, 1 },
   { OSUTF8("sub-frames-80"), 9, 13, 0 }
} ;
#define utran_UE_DRX_Cycle2_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_DRX_Cycle2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DRX_Cycle2_ENUMTABSIZE) {
      return utran_UE_DRX_Cycle2_ENUMTAB
         [utran_UE_DRX_Cycle2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DRX_Cycle2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_DRX_Cycle2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DRX_Cycle2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DRX_Cycle2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UE_DRX_Cycle2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UE_DRX_Cycle2_ENUMTAB, 
      utran_UE_DRX_Cycle2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_DRX_Cycle2)utran_UE_DRX_Cycle2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DRX_Info_r12 (utran_DRX_Info_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DTX_DRX_Info_r12 (utran_DTX_DRX_Info_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DTX_Info (&pvalue->dtx_Info);
   asn1Init_utran_DTX_Info_SecondaryUplinkFrequency (&pvalue->dtx_Info_SecondaryUplinkFrequency);
   asn1Init_utran_DRX_Info_r12 (&pvalue->drx_Info);
}

void asn1Free_utran_DTX_DRX_Info_r12 (OSCTXT *pctxt, 
   utran_DTX_DRX_Info_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dtx_InfoPresent) {
      asn1Free_utran_DTX_Info (pctxt, &pvalue->dtx_Info);
   }
   if (pvalue->m.dtx_Info_SecondaryUplinkFrequencyPresent) {
      asn1Free_utran_DTX_Info_SecondaryUplinkFrequency (pctxt, &pvalue->dtx_Info_SecondaryUplinkFrequency);
   }
}

void asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode (
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode (OSCTXT *pctxt, 
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tenORtwentyMS) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tenORtwentyMS);
         }
         break;

   }
}

void asn1Init_utran_TransportChannelConcatInfo (
   utran_TransportChannelConcatInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode_full (
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode_full* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportChannelConcatInfo (&pvalue->trChConcatInfo);
}

void asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode (
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode (OSCTXT *pctxt, 
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.full) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.full);
         }
         break;

   }
}

void asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration (
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode (&pvalue->ulTransmissionMode);
   asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode (&pvalue->dlFETMode);
}

void asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_ulTransmissionMode (pctxt, &pvalue->ulTransmissionMode);
   asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration_dlFETMode (pctxt, &pvalue->dlFETMode);
}

void asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo (
   utran_DCH_Enhancements_Info_FDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo (OSCTXT *pctxt, 
   utran_DCH_Enhancements_Info_FDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DCH_Enhancements_Info_FDD (
   utran_DCH_Enhancements_Info_FDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DCH_Enhancements_Info_FDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_DCH_Enhancements_Info_FDD (OSCTXT *pctxt, 
   utran_DCH_Enhancements_Info_FDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DCH_Enhancements_Info_FDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

static const OSEnumItem utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector)
         utran_SecondaryEDCH_Info_Common_r12_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MinimumTEBS_threshold_ENUMTAB[] = {
   { OSUTF8("pl1024"), 9, 6, 6 },
   { OSUTF8("pl1024k"), 19, 7, 12 },
   { OSUTF8("pl128"), 6, 5, 18 },
   { OSUTF8("pl128k"), 16, 6, 4 },
   { OSUTF8("pl16"), 3, 4, 10 },
   { OSUTF8("pl16k"), 13, 5, 16 },
   { OSUTF8("pl2"), 0, 3, 2 },
   { OSUTF8("pl256"), 7, 5, 7 },
   { OSUTF8("pl256k"), 17, 6, 14 },
   { OSUTF8("pl2k"), 10, 4, 0 },
   { OSUTF8("pl32"), 4, 4, 9 },
   { OSUTF8("pl32k"), 14, 5, 13 },
   { OSUTF8("pl4"), 1, 3, 19 },
   { OSUTF8("pl4k"), 11, 4, 5 },
   { OSUTF8("pl512"), 8, 5, 11 },
   { OSUTF8("pl512k"), 18, 6, 17 },
   { OSUTF8("pl64"), 5, 4, 3 },
   { OSUTF8("pl64k"), 15, 5, 8 },
   { OSUTF8("pl8"), 2, 3, 15 },
   { OSUTF8("pl8k"), 12, 4, 1 },
   { OSUTF8("spare1"), 31, 6, 23 },
   { OSUTF8("spare10"), 22, 7, 22 },
   { OSUTF8("spare11"), 21, 7, 21 },
   { OSUTF8("spare12"), 20, 7, 31 },
   { OSUTF8("spare2"), 30, 6, 30 },
   { OSUTF8("spare3"), 29, 6, 29 },
   { OSUTF8("spare4"), 28, 6, 28 },
   { OSUTF8("spare5"), 27, 6, 27 },
   { OSUTF8("spare6"), 26, 6, 26 },
   { OSUTF8("spare7"), 25, 6, 25 },
   { OSUTF8("spare8"), 24, 6, 24 },
   { OSUTF8("spare9"), 23, 6, 20 }
} ;
#define utran_MinimumTEBS_threshold_ENUMTABSIZE 32

const OSUTF8CHAR* utran_MinimumTEBS_threshold_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MinimumTEBS_threshold_ENUMTABSIZE) {
      return utran_MinimumTEBS_threshold_ENUMTAB
         [utran_MinimumTEBS_threshold_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MinimumTEBS_threshold_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MinimumTEBS_threshold* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MinimumTEBS_threshold_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MinimumTEBS_threshold_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MinimumTEBS_threshold* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MinimumTEBS_threshold_ENUMTAB, 
      utran_MinimumTEBS_threshold_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MinimumTEBS_threshold)
         utran_MinimumTEBS_threshold_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTABSIZE 1

const OSUTF8CHAR* utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTAB, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTABSIZE) {
      return utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTAB, 
      utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling)
         utran_SecondaryEDCH_Info_Common_r12_implicitGrantHandling_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTAB[] = {
   { OSUTF8("ms10"), 0, 4, 0 },
   { OSUTF8("ms120"), 7, 5, 2 },
   { OSUTF8("ms20"), 1, 4, 3 },
   { OSUTF8("ms30"), 2, 4, 4 },
   { OSUTF8("ms40"), 3, 4, 5 },
   { OSUTF8("ms50"), 4, 4, 6 },
   { OSUTF8("ms60"), 5, 4, 7 },
   { OSUTF8("ms80"), 6, 4, 1 }
} ;
#define utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTABSIZE) {
      return utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTAB
         [utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTAB, 
      utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower)
         utran_UE_DPCCHPowerResetAfterDTXOnSecUplink_inactivityThresholdForResetPower_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_DPCCHPowerResetAfterDTXOnSecUplink (
   utran_UE_DPCCHPowerResetAfterDTXOnSecUplink* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_SecondaryEDCH_Info_Common_r12 (
   utran_SecondaryEDCH_Info_Common_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_FrequencyInfo (&pvalue->frequencyInfo);
   pvalue->ms2_SchedTransmGrantHARQAlloc.numbits = 0;
   asn1Init_utran_UE_DPCCHPowerResetAfterDTXOnSecUplink (&pvalue->ue_DPCCHPowerResetAfterDTXOnSecUplink);
}

void asn1Free_utran_SecondaryEDCH_Info_Common_r12 (OSCTXT *pctxt, 
   utran_SecondaryEDCH_Info_Common_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FrequencyInfo (pctxt, &pvalue->frequencyInfo);
}

void asn1Init_utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info (
   utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTAB, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE) {
      return utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTAB, 
      utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator)
         utran_DL_InformationPerSecondaryRL_r12_secondary_Serving_E_DCHRL_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL_r12 (
   utran_DL_InformationPerSecondaryRL_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (&pvalue->dl_FDPCHInfoPerRL_SecULFreq);
   asn1Init_utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_DL_InformationPerSecondaryRL_r12 (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_r12_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL_List_r12 (
   utran_DL_InformationPerSecondaryRL_List_r12* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerSecondaryRL_List_r12 (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_List_r12* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerSecondaryRL_r12* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerSecondaryRL_r12*)pnode->data;
      asn1Free_utran_DL_InformationPerSecondaryRL_r12 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD_r12_newConfiguration (
   utran_UL_SecondaryCellInfoFDD_r12_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryServingEDCHCell_Info (&pvalue->secondaryServingEDCHCell_Info);
   asn1Init_utran_SecondaryEDCH_Info_Common_r12 (&pvalue->secondaryEDCH_Info_Common);
   asn1Init_utran_DL_InformationPerSecondaryRL_List_r12 (&pvalue->dl_InformationPerSecondaryRL_List);
}

void asn1Free_utran_UL_SecondaryCellInfoFDD_r12_newConfiguration (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD_r12_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.secondaryEDCH_Info_CommonPresent) {
      asn1Free_utran_SecondaryEDCH_Info_Common_r12 (pctxt, &pvalue->secondaryEDCH_Info_Common);
   }
   if (pvalue->m.dl_InformationPerSecondaryRL_ListPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_List_r12 (pctxt, &pvalue->dl_InformationPerSecondaryRL_List);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD_r12 (
   utran_UL_SecondaryCellInfoFDD_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_SecondaryCellInfoFDD_r12 (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD_r12* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_UL_SecondaryCellInfoFDD_r12_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_ASU_fdd (
   utran_DL_DPCH_InfoPerRL_ASU_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_ASU_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_ASU_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_ASU_tdd (
   utran_DL_DPCH_InfoPerRL_ASU_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r4 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_ASU_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_ASU_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_ASU (utran_DL_DPCH_InfoPerRL_ASU* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_ASU (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_ASU* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_ASU_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_ASU_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_RL_AdditionInformation_r12_dl_dpchInfo (
   utran_RL_AdditionInformation_r12_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r12_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r12_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_ASU (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

      case 3:
         if (0 != pvalue->u.radioLinkswithoutDPCHFDPCHInfo) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         }
         break;

   }
}

static const OSEnumItem utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTAB[] = {
   { OSUTF8("reductionType1"), 0, 14, 0 },
   { OSUTF8("reductionType2"), 1, 14, 1 }
} ;
#define utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTABSIZE) {
      return utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTAB
         [utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTAB, 
      utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType)
         utran_HS_DPCCHOverheadReduction_hs_dpcch_ReductionType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Feedback_cycle2_ENUMTAB[] = {
   { OSUTF8("f32"), 5, 3, 2 },
   { OSUTF8("f64"), 7, 3, 8 },
   { OSUTF8("fc0"), 0, 3, 3 },
   { OSUTF8("fc10"), 2, 4, 4 },
   { OSUTF8("fc16"), 3, 4, 6 },
   { OSUTF8("fc160"), 9, 5, 0 },
   { OSUTF8("fc20"), 4, 4, 7 },
   { OSUTF8("fc40"), 6, 4, 1 },
   { OSUTF8("fc8"), 1, 3, 9 },
   { OSUTF8("fc80"), 8, 4, 5 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define utran_Feedback_cycle2_ENUMTABSIZE 16

const OSUTF8CHAR* utran_Feedback_cycle2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Feedback_cycle2_ENUMTABSIZE) {
      return utran_Feedback_cycle2_ENUMTAB
         [utran_Feedback_cycle2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Feedback_cycle2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Feedback_cycle2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Feedback_cycle2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Feedback_cycle2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Feedback_cycle2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Feedback_cycle2_ENUMTAB, utran_Feedback_cycle2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Feedback_cycle2)
         utran_Feedback_cycle2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_CQI_CycleSwitchTimer_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 11 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 8 },
   { OSUTF8("spare4"), 12, 6, 10 },
   { OSUTF8("spare5"), 11, 6, 13 },
   { OSUTF8("spare6"), 10, 6, 7 },
   { OSUTF8("spare7"), 9, 6, 9 },
   { OSUTF8("sub-frames-128"), 5, 14, 12 },
   { OSUTF8("sub-frames-16"), 2, 13, 15 },
   { OSUTF8("sub-frames-256"), 6, 14, 6 },
   { OSUTF8("sub-frames-32"), 3, 13, 5 },
   { OSUTF8("sub-frames-4"), 0, 12, 4 },
   { OSUTF8("sub-frames-512"), 7, 14, 3 },
   { OSUTF8("sub-frames-64"), 4, 13, 2 },
   { OSUTF8("sub-frames-8"), 1, 12, 1 },
   { OSUTF8("sub-frames-Infinity"), 8, 19, 0 }
} ;
#define utran_CQI_CycleSwitchTimer_ENUMTABSIZE 16

const OSUTF8CHAR* utran_CQI_CycleSwitchTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CQI_CycleSwitchTimer_ENUMTABSIZE) {
      return utran_CQI_CycleSwitchTimer_ENUMTAB
         [utran_CQI_CycleSwitchTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CQI_CycleSwitchTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CQI_CycleSwitchTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CQI_CycleSwitchTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CQI_CycleSwitchTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CQI_CycleSwitchTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CQI_CycleSwitchTimer_ENUMTAB, 
      utran_CQI_CycleSwitchTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CQI_CycleSwitchTimer)
         utran_CQI_CycleSwitchTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_DPCCHOverheadReduction (
   utran_HS_DPCCHOverheadReduction* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_Measurement_Feedback_Info_r12_modeSpecificInfo_fdd (
   utran_Measurement_Feedback_Info_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_DPCCHOverheadReduction (&pvalue->hs_DPCCHOverheadReduction);
}

void asn1Init_utran_Measurement_Feedback_Info_r12_modeSpecificInfo (
   utran_Measurement_Feedback_Info_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Measurement_Feedback_Info_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_Measurement_Feedback_Info_r12 (
   utran_Measurement_Feedback_Info_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Measurement_Feedback_Info_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_Measurement_Feedback_Info_r12 (OSCTXT *pctxt, 
   utran_Measurement_Feedback_Info_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Measurement_Feedback_Info_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd768 (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration_VHCR (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd768 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration_VHCR (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator)
         utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128_tS0_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
   asn1Init_utran_DL_MultiCarrier_Information (&pvalue->dl_MultiCarrier_Information);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->ts0ChannelizationCodes);
}

void asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_MultiCarrier_InformationPresent) {
      asn1Free_utran_DL_MultiCarrier_Information (pctxt, &pvalue->dl_MultiCarrier_Information);
   }
   if (pvalue->m.ts0ChannelizationCodesPresent) {
      asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->ts0ChannelizationCodes);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

static const OSEnumItem utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE) {
      return utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB, 
      utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured)
         utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd_dl_64QAM_Configured_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r12 (
   utran_DL_HSPDSCH_Information_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r9 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info_r12 (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r12 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r9 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info_r12 (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator)
         utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE) {
      return utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting)
         utran_Serving_HSDSCH_CellInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Serving_HSDSCH_CellInformation_r12 (
   utran_Serving_HSDSCH_CellInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_Information_r12 (&pvalue->dl_hspdsch_Information);
   asn1Init_utran_HARQ_Info_r11 (&pvalue->harqInfo);
}

void asn1Free_utran_Serving_HSDSCH_CellInformation_r12 (OSCTXT *pctxt, 
   utran_Serving_HSDSCH_CellInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_hspdsch_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r12 (pctxt, &pvalue->dl_hspdsch_Information);
   }
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r11 (pctxt, &pvalue->harqInfo);
   }
}

void asn1Init_utran_F_DPCHInfo (utran_F_DPCHInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DPCCH2InfoFDD_configurationInfo_newConfiguration (
   utran_DPCCH2InfoFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_F_DPCHInfo (&pvalue->f_dpchInfo);
}

void asn1Init_utran_DPCCH2InfoFDD_configurationInfo (
   utran_DPCCH2InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DPCCH2InfoFDD_configurationInfo (OSCTXT *pctxt, 
   utran_DPCCH2InfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DPCCH2InfoFDD (utran_DPCCH2InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DPCCH2InfoFDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_DPCCH2InfoFDD (OSCTXT *pctxt, utran_DPCCH2InfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DPCCH2InfoFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_TargetCellPreconfigInfo_r12 (
   utran_TargetCellPreconfigInfo_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r12 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r11 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r12 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_MIMO4x4_Parameters (&pvalue->mimo4x4Parameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD_r11 (&pvalue->additionalDLSecCellInfoListFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD2 (&pvalue->additionalDLSecCellInfoListFDD2);
   asn1Init_utran_UL_SecondaryCellInfoFDD_r12 (&pvalue->ul_SecondaryCellInfoFDD);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (&pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   asn1Init_utran_UL_CLTD_InfoFDD (&pvalue->ul_CLTD_InfoFDD);
   asn1Init_utran_F_TPICH_ReconfigurationInfo (&pvalue->f_tpich_ReconfigurationInfo);
   asn1Init_utran_UL_16QAM_Config (&pvalue->ul_16QAM_Config);
   asn1Init_utran_UL_64QAM_Config (&pvalue->ul_64QAM_Config);
   asn1Init_utran_UL_MIMO_InfoFDD (&pvalue->ul_MIMO_Info);
   asn1Init_utran_DPCCH2InfoFDD (&pvalue->dPCCH2InfoFDD);
}

void asn1Free_utran_TargetCellPreconfigInfo_r12 (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r12 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r11 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.mimo4x4ParametersPresent) {
      asn1Free_utran_MIMO4x4_Parameters (pctxt, &pvalue->mimo4x4Parameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDDPresent) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD_r11 (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDD2Present) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD2 (pctxt, &pvalue->additionalDLSecCellInfoListFDD2);
   }
   if (pvalue->m.ul_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_UL_SecondaryCellInfoFDD_r12 (pctxt, &pvalue->ul_SecondaryCellInfoFDD);
   }
   if (pvalue->m.e_dch_ReconfigurationInfo_SecULFrequencyPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (pctxt, &pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   }
   if (pvalue->m.ul_CLTD_InfoFDDPresent) {
      asn1Free_utran_UL_CLTD_InfoFDD (pctxt, &pvalue->ul_CLTD_InfoFDD);
   }
   if (pvalue->m.f_tpich_ReconfigurationInfoPresent) {
      asn1Free_utran_F_TPICH_ReconfigurationInfo (pctxt, &pvalue->f_tpich_ReconfigurationInfo);
   }
   if (pvalue->m.ul_MIMO_InfoPresent) {
      asn1Free_utran_UL_MIMO_InfoFDD (pctxt, &pvalue->ul_MIMO_Info);
   }
   if (pvalue->m.dPCCH2InfoFDDPresent) {
      asn1Free_utran_DPCCH2InfoFDD (pctxt, &pvalue->dPCCH2InfoFDD);
   }
}

void asn1Init_utran_RL_AdditionInformation_r12 (
   utran_RL_AdditionInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r12_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_HICH_Information_r11 (&pvalue->e_HICH_Information);
   asn1Init_utran_TargetCellPreconfigInfo_r12 (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r12 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r12_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo_r12 (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r12 (
   utran_RL_AdditionInformationList_r12* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r12 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r12* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r12* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r12*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r12 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RL_AdditionInformation_SecULFreq_r12 (
   utran_RL_AdditionInformation_SecULFreq_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r7 (&pvalue->dl_FDPCH_InfoPerRL);
}

void asn1Init_utran_RL_AdditionInformationList_SecULFreq_r12 (
   utran_RL_AdditionInformationList_SecULFreq_r12* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_SecULFreq_r12 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_SecULFreq_r12* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTAB, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTABSIZE) {
      return utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTAB, 
      utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator)
         utran_ServingCellChangeParameters_r12_enhancedServingCellChangeforEvent1CsupportIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ServingCellChangeParameters_r12 (
   utran_ServingCellChangeParameters_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DynamicActivationTime (utran_DynamicActivationTime* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTAB[] = {
   { OSUTF8("slots3"), 0, 6, 0 },
   { OSUTF8("slots5"), 1, 6, 1 }
} ;
#define utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PowerControlAlgorithm3_Config_decimationFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTABSIZE) {
      return utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTAB
         [utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PowerControlAlgorithm3_Config_decimationFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_PowerControlAlgorithm3_Config_decimationFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PowerControlAlgorithm3_Config_decimationFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PowerControlAlgorithm3_Config_decimationFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PowerControlAlgorithm3_Config_decimationFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTAB, 
      utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PowerControlAlgorithm3_Config_decimationFactor)
         utran_PowerControlAlgorithm3_Config_decimationFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PowerControlAlgorithm3_Config (
   utran_PowerControlAlgorithm3_Config* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_FDPCH_InfoPerRL_r13 (
   utran_DL_FDPCH_InfoPerRL_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_PowerControlAlgorithm3_Config (&pvalue->powerControlAlgorithm3_Config);
}

void asn1Init_utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info (
   utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTAB, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE) {
      return utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTAB, 
      utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator)
         utran_DL_InformationPerSecondaryRL_r13_secondary_Serving_E_DCHRL_Indicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL_r13 (
   utran_DL_InformationPerSecondaryRL_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r13 (&pvalue->dl_FDPCHInfoPerRL_SecULFreq);
   asn1Init_utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_DL_InformationPerSecondaryRL_r13 (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_r13* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_r13_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_DL_InformationPerSecondaryRL_List_r13 (
   utran_DL_InformationPerSecondaryRL_List_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerSecondaryRL_List_r13 (OSCTXT *pctxt, 
   utran_DL_InformationPerSecondaryRL_List_r13* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerSecondaryRL_r13* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerSecondaryRL_r13*)pnode->data;
      asn1Free_utran_DL_InformationPerSecondaryRL_r13 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD_r13_newConfiguration (
   utran_UL_SecondaryCellInfoFDD_r13_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryServingEDCHCell_Info (&pvalue->secondaryServingEDCHCell_Info);
   asn1Init_utran_SecondaryEDCH_Info_Common_r12 (&pvalue->secondaryEDCH_Info_Common);
   asn1Init_utran_DL_InformationPerSecondaryRL_List_r13 (&pvalue->dl_InformationPerSecondaryRL_List);
}

void asn1Free_utran_UL_SecondaryCellInfoFDD_r13_newConfiguration (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD_r13_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.secondaryEDCH_Info_CommonPresent) {
      asn1Free_utran_SecondaryEDCH_Info_Common_r12 (pctxt, &pvalue->secondaryEDCH_Info_Common);
   }
   if (pvalue->m.dl_InformationPerSecondaryRL_ListPresent) {
      asn1Free_utran_DL_InformationPerSecondaryRL_List_r13 (pctxt, &pvalue->dl_InformationPerSecondaryRL_List);
   }
}

void asn1Init_utran_UL_SecondaryCellInfoFDD_r13 (
   utran_UL_SecondaryCellInfoFDD_r13* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_SecondaryCellInfoFDD_r13 (OSCTXT *pctxt, 
   utran_UL_SecondaryCellInfoFDD_r13* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_UL_SecondaryCellInfoFDD_r13_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_RL_AdditionInformation_r13_dl_dpchInfo (
   utran_RL_AdditionInformation_r13_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RL_AdditionInformation_r13_dl_dpchInfo (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r13_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_ASU (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

      case 3:
         if (0 != pvalue->u.radioLinkswithoutDPCHFDPCHInfo) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         }
         break;

   }
}

void asn1Init_utran_TargetCellPreconfigInfo_r13 (
   utran_TargetCellPreconfigInfo_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
   asn1Init_utran_Serving_HSDSCH_CellInformation_r12 (&pvalue->serving_HSDSCH_CellInformation);
   asn1Init_utran_E_DCH_ReconfigurationInfo_r11 (&pvalue->e_dch_ReconfigurationInfo);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r12 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_MIMO4x4_Parameters (&pvalue->mimo4x4Parameters);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD_r11 (&pvalue->additionalDLSecCellInfoListFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD2 (&pvalue->additionalDLSecCellInfoListFDD2);
   asn1Init_utran_UL_SecondaryCellInfoFDD_r13 (&pvalue->ul_SecondaryCellInfoFDD);
   asn1Init_utran_E_DCH_ReconfigurationInfo_SecULFrequency (&pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   asn1Init_utran_UL_CLTD_InfoFDD (&pvalue->ul_CLTD_InfoFDD);
   asn1Init_utran_F_TPICH_ReconfigurationInfo (&pvalue->f_tpich_ReconfigurationInfo);
   asn1Init_utran_UL_16QAM_Config (&pvalue->ul_16QAM_Config);
   asn1Init_utran_UL_64QAM_Config (&pvalue->ul_64QAM_Config);
   asn1Init_utran_UL_MIMO_InfoFDD (&pvalue->ul_MIMO_Info);
   asn1Init_utran_DPCCH2InfoFDD (&pvalue->dPCCH2InfoFDD);
}

void asn1Free_utran_TargetCellPreconfigInfo_r13 (OSCTXT *pctxt, 
   utran_TargetCellPreconfigInfo_r13* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Serving_HSDSCH_CellInformation_r12 (pctxt, &pvalue->serving_HSDSCH_CellInformation);
   asn1Free_utran_E_DCH_ReconfigurationInfo_r11 (pctxt, &pvalue->e_dch_ReconfigurationInfo);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.mimo4x4ParametersPresent) {
      asn1Free_utran_MIMO4x4_Parameters (pctxt, &pvalue->mimo4x4Parameters);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDDPresent) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD_r11 (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDD2Present) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD2 (pctxt, &pvalue->additionalDLSecCellInfoListFDD2);
   }
   if (pvalue->m.ul_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_UL_SecondaryCellInfoFDD_r13 (pctxt, &pvalue->ul_SecondaryCellInfoFDD);
   }
   if (pvalue->m.e_dch_ReconfigurationInfo_SecULFrequencyPresent) {
      asn1Free_utran_E_DCH_ReconfigurationInfo_SecULFrequency (pctxt, &pvalue->e_dch_ReconfigurationInfo_SecULFrequency);
   }
   if (pvalue->m.ul_CLTD_InfoFDDPresent) {
      asn1Free_utran_UL_CLTD_InfoFDD (pctxt, &pvalue->ul_CLTD_InfoFDD);
   }
   if (pvalue->m.f_tpich_ReconfigurationInfoPresent) {
      asn1Free_utran_F_TPICH_ReconfigurationInfo (pctxt, &pvalue->f_tpich_ReconfigurationInfo);
   }
   if (pvalue->m.ul_MIMO_InfoPresent) {
      asn1Free_utran_UL_MIMO_InfoFDD (pctxt, &pvalue->ul_MIMO_Info);
   }
   if (pvalue->m.dPCCH2InfoFDDPresent) {
      asn1Free_utran_DPCCH2InfoFDD (pctxt, &pvalue->dPCCH2InfoFDD);
   }
}

void asn1Init_utran_RL_AdditionInformation_r13 (
   utran_RL_AdditionInformation_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_Id);
   asn1Init_utran_RL_AdditionInformation_r13_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_HICH_Information_r11 (&pvalue->e_HICH_Information);
   asn1Init_utran_TargetCellPreconfigInfo_r13 (&pvalue->targetCellPreconfigInfo);
}

void asn1Free_utran_RL_AdditionInformation_r13 (OSCTXT *pctxt, 
   utran_RL_AdditionInformation_r13* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RL_AdditionInformation_r13_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   if (pvalue->m.targetCellPreconfigInfoPresent) {
      asn1Free_utran_TargetCellPreconfigInfo_r13 (pctxt, &pvalue->targetCellPreconfigInfo);
   }
}

void asn1Init_utran_RL_AdditionInformationList_r13 (
   utran_RL_AdditionInformationList_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_r13 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_r13* pvalue)
{
   if (0 == pvalue) return;
   { utran_RL_AdditionInformation_r13* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RL_AdditionInformation_r13*)pnode->data;
      asn1Free_utran_RL_AdditionInformation_r13 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RL_AdditionInformation_SecULFreq_r13 (
   utran_RL_AdditionInformation_SecULFreq_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
   asn1Init_utran_DL_FDPCH_InfoPerRL_r13 (&pvalue->dl_FDPCH_InfoPerRL);
}

void asn1Init_utran_RL_AdditionInformationList_SecULFreq_r13 (
   utran_RL_AdditionInformationList_SecULFreq_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_AdditionInformationList_SecULFreq_r13 (OSCTXT *pctxt, 
   utran_RL_AdditionInformationList_SecULFreq_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_START_Value (utran_START_Value* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_STARTSingle (utran_STARTSingle* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_START_Value (&pvalue->start_Value);
}

void asn1Init_utran_STARTList (utran_STARTList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_STARTList (OSCTXT *pctxt, utran_STARTList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UL_CounterSynchronisationInfo (
   utran_UL_CounterSynchronisationInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RB_WithPDCP_InfoList (&pvalue->rB_WithPDCP_InfoList);
   asn1Init_utran_STARTList (&pvalue->startList);
}

void asn1Free_utran_UL_CounterSynchronisationInfo (OSCTXT *pctxt, 
   utran_UL_CounterSynchronisationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rB_WithPDCP_InfoListPresent) {
      asn1Free_utran_RB_WithPDCP_InfoList (pctxt, &pvalue->rB_WithPDCP_InfoList);
   }
   asn1Free_utran_STARTList (pctxt, &pvalue->startList);
}

static const OSEnumItem utran_ProtocolErrorCause_ENUMTAB[] = {
   { OSUTF8("asn1-ViolationOrEncodingError"), 0, 29, 0 },
   { OSUTF8("ie-ValueNotComprehended"), 3, 23, 5 },
   { OSUTF8("informationElementMissing"), 4, 25, 4 },
   { OSUTF8("messageExtensionNotComprehended"), 5, 31, 1 },
   { OSUTF8("messageNotCompatibleWithReceiverState"), 2, 37, 2 },
   { OSUTF8("messageTypeNonexistent"), 1, 22, 3 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 }
} ;
#define utran_ProtocolErrorCause_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ProtocolErrorCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ProtocolErrorCause_ENUMTABSIZE) {
      return utran_ProtocolErrorCause_ENUMTAB
         [utran_ProtocolErrorCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ProtocolErrorCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ProtocolErrorCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ProtocolErrorCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ProtocolErrorCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ProtocolErrorCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ProtocolErrorCause_ENUMTAB, utran_ProtocolErrorCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ProtocolErrorCause)
         utran_ProtocolErrorCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ProtocolErrorInformation_diagnosticsType (
   utran_ProtocolErrorInformation_diagnosticsType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ProtocolErrorInformation_diagnosticsType (OSCTXT *pctxt, 
   utran_ProtocolErrorInformation_diagnosticsType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_ProtocolErrorInformation (
   utran_ProtocolErrorInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_ProtocolErrorInformation_diagnosticsType (&pvalue->diagnosticsType);
}

void asn1Free_utran_ProtocolErrorInformation (OSCTXT *pctxt, 
   utran_ProtocolErrorInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_ProtocolErrorInformation_diagnosticsType (pctxt, &pvalue->diagnosticsType);
}

void asn1Init_utran_FailureCauseWithProtErr (
   utran_FailureCauseWithProtErr* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_FailureCauseWithProtErr (OSCTXT *pctxt, 
   utran_FailureCauseWithProtErr* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

      case 5:
         if (0 != pvalue->u.protocolError) {
            asn1Free_utran_ProtocolErrorInformation (pctxt, pvalue->u.protocolError);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.protocolError);
         }
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         break;

      case 9:
         break;

      case 10:
         break;

      case 11:
         break;

      case 12:
         break;

      case 13:
         break;

      case 14:
         break;

      case 15:
         break;

      case 16:
         break;

   }
}

void asn1Init_utran_UTRAN_GPSReferenceTime_modeSpecificInfo (
   utran_UTRAN_GPSReferenceTime_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UTRAN_GPSReferenceTime_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UTRAN_GPSReferenceTime_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UTRAN_GPSReferenceTime (
   utran_UTRAN_GPSReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UTRAN_GPSReferenceTime_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UTRAN_GPSReferenceTime (OSCTXT *pctxt, 
   utran_UTRAN_GPSReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.modeSpecificInfoPresent) {
      asn1Free_utran_UTRAN_GPSReferenceTime_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   }
}

static const OSEnumItem utran_SFN_TOW_Uncertainty_ENUMTAB[] = {
   { OSUTF8("lessThan10"), 0, 10, 0 },
   { OSUTF8("moreThan10"), 1, 10, 1 }
} ;
#define utran_SFN_TOW_Uncertainty_ENUMTABSIZE 2

const OSUTF8CHAR* utran_SFN_TOW_Uncertainty_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SFN_TOW_Uncertainty_ENUMTABSIZE) {
      return utran_SFN_TOW_Uncertainty_ENUMTAB
         [utran_SFN_TOW_Uncertainty_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SFN_TOW_Uncertainty_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SFN_TOW_Uncertainty* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SFN_TOW_Uncertainty_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SFN_TOW_Uncertainty_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SFN_TOW_Uncertainty* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SFN_TOW_Uncertainty_ENUMTAB, 
      utran_SFN_TOW_Uncertainty_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SFN_TOW_Uncertainty)
         utran_SFN_TOW_Uncertainty_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UTRAN_GPS_DriftRate_ENUMTAB[] = {
   { OSUTF8("utran-GPSDrift-1"), 8, 16, 7 },
   { OSUTF8("utran-GPSDrift-10"), 11, 17, 8 },
   { OSUTF8("utran-GPSDrift-15"), 12, 17, 11 },
   { OSUTF8("utran-GPSDrift-2"), 9, 16, 13 },
   { OSUTF8("utran-GPSDrift-25"), 13, 17, 9 },
   { OSUTF8("utran-GPSDrift-5"), 10, 16, 10 },
   { OSUTF8("utran-GPSDrift-50"), 14, 17, 12 },
   { OSUTF8("utran-GPSDrift0"), 0, 15, 14 },
   { OSUTF8("utran-GPSDrift1"), 1, 15, 0 },
   { OSUTF8("utran-GPSDrift10"), 4, 16, 3 },
   { OSUTF8("utran-GPSDrift15"), 5, 16, 5 },
   { OSUTF8("utran-GPSDrift2"), 2, 15, 1 },
   { OSUTF8("utran-GPSDrift25"), 6, 16, 2 },
   { OSUTF8("utran-GPSDrift5"), 3, 15, 4 },
   { OSUTF8("utran-GPSDrift50"), 7, 16, 6 }
} ;
#define utran_UTRAN_GPS_DriftRate_ENUMTABSIZE 15

const OSUTF8CHAR* utran_UTRAN_GPS_DriftRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UTRAN_GPS_DriftRate_ENUMTABSIZE) {
      return utran_UTRAN_GPS_DriftRate_ENUMTAB
         [utran_UTRAN_GPS_DriftRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UTRAN_GPS_DriftRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UTRAN_GPS_DriftRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UTRAN_GPS_DriftRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UTRAN_GPS_DriftRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UTRAN_GPS_DriftRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UTRAN_GPS_DriftRate_ENUMTAB, 
      utran_UTRAN_GPS_DriftRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UTRAN_GPS_DriftRate)
         utran_UTRAN_GPS_DriftRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_GPS_TOW_Assist (utran_GPS_TOW_Assist* pvalue)
{
   if (0 == pvalue) return;
   pvalue->tlm_Message.numbits = 0;
   pvalue->tlm_Reserved.numbits = 0;
}

void asn1Init_utran_GPS_TOW_AssistList (utran_GPS_TOW_AssistList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GPS_TOW_AssistList (OSCTXT *pctxt, 
   utran_GPS_TOW_AssistList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_ReferenceTime (
   utran_UE_Positioning_GPS_ReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UTRAN_GPSReferenceTime (&pvalue->utran_GPSReferenceTime);
   asn1Init_utran_GPS_TOW_AssistList (&pvalue->gps_TOW_AssistList);
}

void asn1Free_utran_UE_Positioning_GPS_ReferenceTime (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_ReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.utran_GPSReferenceTimePresent) {
      asn1Free_utran_UTRAN_GPSReferenceTime (pctxt, &pvalue->utran_GPSReferenceTime);
   }
   if (pvalue->m.gps_TOW_AssistListPresent) {
      asn1Free_utran_GPS_TOW_AssistList (pctxt, &pvalue->gps_TOW_AssistList);
   }
}

static const OSEnumItem utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTAB[] = {
   { OSUTF8("north"), 0, 5, 0 },
   { OSUTF8("south"), 1, 5, 1 }
} ;
#define utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTABSIZE 2

const OSUTF8CHAR* utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTABSIZE) {
      return utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTAB
         [utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_EllipsoidPointAltitudeEllipsoide_latitudeSign* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EllipsoidPointAltitudeEllipsoide_latitudeSign* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTAB, 
      utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EllipsoidPointAltitudeEllipsoide_latitudeSign)
         utran_EllipsoidPointAltitudeEllipsoide_latitudeSign_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTAB[] = {
   { OSUTF8("depth"), 1, 5, 1 },
   { OSUTF8("height"), 0, 6, 0 }
} ;
#define utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTABSIZE 2

const OSUTF8CHAR* utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTABSIZE) {
      return utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTAB
         [utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTAB, 
      utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection)
         utran_EllipsoidPointAltitudeEllipsoide_altitudeDirection_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DiffCorrectionStatus_ENUMTAB[] = {
   { OSUTF8("invalidData"), 7, 11, 7 },
   { OSUTF8("noData"), 6, 6, 6 },
   { OSUTF8("udre-0-1"), 5, 8, 5 },
   { OSUTF8("udre-0-2"), 4, 8, 4 },
   { OSUTF8("udre-0-3"), 3, 8, 3 },
   { OSUTF8("udre-0-5"), 2, 8, 2 },
   { OSUTF8("udre-0-75"), 1, 9, 1 },
   { OSUTF8("udre-1-0"), 0, 8, 0 }
} ;
#define utran_DiffCorrectionStatus_ENUMTABSIZE 8

const OSUTF8CHAR* utran_DiffCorrectionStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DiffCorrectionStatus_ENUMTABSIZE) {
      return utran_DiffCorrectionStatus_ENUMTAB
         [utran_DiffCorrectionStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DiffCorrectionStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DiffCorrectionStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DiffCorrectionStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DiffCorrectionStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DiffCorrectionStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DiffCorrectionStatus_ENUMTAB, 
      utran_DiffCorrectionStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DiffCorrectionStatus)
         utran_DiffCorrectionStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UDRE_ENUMTAB[] = {
   { OSUTF8("between1-and-4"), 1, 14, 2 },
   { OSUTF8("between4-and-8"), 2, 14, 0 },
   { OSUTF8("lessThan1"), 0, 9, 1 },
   { OSUTF8("over8"), 3, 5, 3 }
} ;
#define utran_UDRE_ENUMTABSIZE 4

const OSUTF8CHAR* utran_UDRE_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UDRE_ENUMTABSIZE) {
      return utran_UDRE_ENUMTAB[utran_UDRE_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UDRE_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UDRE* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UDRE_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UDRE_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UDRE* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UDRE_ENUMTAB, 
      utran_UDRE_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UDRE)utran_UDRE_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DGPS_CorrectionSatInfo (
   utran_DGPS_CorrectionSatInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DGPS_CorrectionSatInfoList (
   utran_DGPS_CorrectionSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGPS_CorrectionSatInfoList (OSCTXT *pctxt, 
   utran_DGPS_CorrectionSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_DGPS_Corrections (
   utran_UE_Positioning_GPS_DGPS_Corrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DGPS_CorrectionSatInfoList (&pvalue->dgps_CorrectionSatInfoList);
}

void asn1Free_utran_UE_Positioning_GPS_DGPS_Corrections (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_DGPS_Corrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DGPS_CorrectionSatInfoList (pctxt, &pvalue->dgps_CorrectionSatInfoList);
}

static const OSEnumItem utran_SatelliteStatus_ENUMTAB[] = {
   { OSUTF8("es-NN-U"), 2, 7, 2 },
   { OSUTF8("es-SN"), 1, 5, 1 },
   { OSUTF8("ns-NN-U"), 0, 7, 0 },
   { OSUTF8("rev"), 4, 3, 4 },
   { OSUTF8("rev2"), 3, 4, 3 }
} ;
#define utran_SatelliteStatus_ENUMTABSIZE 5

const OSUTF8CHAR* utran_SatelliteStatus_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SatelliteStatus_ENUMTABSIZE) {
      return utran_SatelliteStatus_ENUMTAB
         [utran_SatelliteStatus_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SatelliteStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SatelliteStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SatelliteStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SatelliteStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SatelliteStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SatelliteStatus_ENUMTAB, utran_SatelliteStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SatelliteStatus)
         utran_SatelliteStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SubFrame1Reserved (utran_SubFrame1Reserved* pvalue)
{
   if (0 == pvalue) return;
   pvalue->reserved1.numbits = 0;
   pvalue->reserved2.numbits = 0;
   pvalue->reserved3.numbits = 0;
   pvalue->reserved4.numbits = 0;
}

void asn1Init_utran_EphemerisParameter (utran_EphemerisParameter* pvalue)
{
   if (0 == pvalue) return;
   pvalue->codeOnL2.numbits = 0;
   pvalue->uraIndex.numbits = 0;
   pvalue->satHealth.numbits = 0;
   pvalue->iodc.numbits = 0;
   pvalue->l2Pflag.numbits = 0;
   asn1Init_utran_SubFrame1Reserved (&pvalue->sf1Revd);
   pvalue->t_GD.numbits = 0;
   pvalue->t_oc.numbits = 0;
   pvalue->af2.numbits = 0;
   pvalue->af1.numbits = 0;
   pvalue->af0.numbits = 0;
   pvalue->c_rs.numbits = 0;
   pvalue->delta_n.numbits = 0;
   pvalue->m0.numbits = 0;
   pvalue->c_uc.numbits = 0;
   pvalue->e.numbits = 0;
   pvalue->c_us.numbits = 0;
   pvalue->a_Sqrt.numbits = 0;
   pvalue->t_oe.numbits = 0;
   pvalue->fitInterval.numbits = 0;
   pvalue->aodo.numbits = 0;
   pvalue->c_ic.numbits = 0;
   pvalue->omega0.numbits = 0;
   pvalue->c_is.numbits = 0;
   pvalue->i0.numbits = 0;
   pvalue->c_rc.numbits = 0;
   pvalue->omega.numbits = 0;
   pvalue->omegaDot.numbits = 0;
   pvalue->iDot.numbits = 0;
}

void asn1Init_utran_NavigationModelSatInfo (
   utran_NavigationModelSatInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_EphemerisParameter (&pvalue->ephemerisParameter);
}

void asn1Init_utran_NavigationModelSatInfoList (
   utran_NavigationModelSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_NavigationModelSatInfoList (OSCTXT *pctxt, 
   utran_NavigationModelSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_NavigationModel (
   utran_UE_Positioning_GPS_NavigationModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_NavigationModelSatInfoList (&pvalue->navigationModelSatInfoList);
}

void asn1Free_utran_UE_Positioning_GPS_NavigationModel (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_NavigationModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_NavigationModelSatInfoList (pctxt, &pvalue->navigationModelSatInfoList);
}

void asn1Init_utran_UE_Positioning_GPS_IonosphericModel (
   utran_UE_Positioning_GPS_IonosphericModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->alpha0.numbits = 0;
   pvalue->alpha1.numbits = 0;
   pvalue->alpha2.numbits = 0;
   pvalue->alpha3.numbits = 0;
   pvalue->beta0.numbits = 0;
   pvalue->beta1.numbits = 0;
   pvalue->beta2.numbits = 0;
   pvalue->beta3.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GPS_UTC_Model (
   utran_UE_Positioning_GPS_UTC_Model* pvalue)
{
   if (0 == pvalue) return;
   pvalue->a1.numbits = 0;
   pvalue->a0.numbits = 0;
   pvalue->t_ot.numbits = 0;
   pvalue->wn_t.numbits = 0;
   pvalue->delta_t_LS.numbits = 0;
   pvalue->wn_lsf.numbits = 0;
   pvalue->dn.numbits = 0;
   pvalue->delta_t_LSF.numbits = 0;
}

void asn1Init_utran_AlmanacSatInfo (utran_AlmanacSatInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->e.numbits = 0;
   pvalue->t_oa.numbits = 0;
   pvalue->deltaI.numbits = 0;
   pvalue->omegaDot.numbits = 0;
   pvalue->satHealth.numbits = 0;
   pvalue->a_Sqrt.numbits = 0;
   pvalue->omega0.numbits = 0;
   pvalue->m0.numbits = 0;
   pvalue->omega.numbits = 0;
   pvalue->af0.numbits = 0;
   pvalue->af1.numbits = 0;
}

void asn1Init_utran_AlmanacSatInfoList (utran_AlmanacSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AlmanacSatInfoList (OSCTXT *pctxt, 
   utran_AlmanacSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_Almanac_sv_GlobalHealth (
   utran_UE_Positioning_GPS_Almanac_sv_GlobalHealth* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_UE_Positioning_GPS_Almanac (
   utran_UE_Positioning_GPS_Almanac* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->wn_a.numbits = 0;
   asn1Init_utran_AlmanacSatInfoList (&pvalue->almanacSatInfoList);
   asn1Init_utran_UE_Positioning_GPS_Almanac_sv_GlobalHealth (&pvalue->sv_GlobalHealth);
}

void asn1Free_utran_UE_Positioning_GPS_Almanac (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_Almanac* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AlmanacSatInfoList (pctxt, &pvalue->almanacSatInfoList);
}

static const OSEnumItem utran_DopplerUncertainty_ENUMTAB[] = {
   { OSUTF8("hz100"), 3, 5, 1 },
   { OSUTF8("hz12-5"), 0, 6, 3 },
   { OSUTF8("hz200"), 4, 5, 4 },
   { OSUTF8("hz25"), 1, 4, 0 },
   { OSUTF8("hz50"), 2, 4, 2 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define utran_DopplerUncertainty_ENUMTABSIZE 8

const OSUTF8CHAR* utran_DopplerUncertainty_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DopplerUncertainty_ENUMTABSIZE) {
      return utran_DopplerUncertainty_ENUMTAB
         [utran_DopplerUncertainty_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DopplerUncertainty_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DopplerUncertainty* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DopplerUncertainty_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DopplerUncertainty_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DopplerUncertainty* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DopplerUncertainty_ENUMTAB, utran_DopplerUncertainty_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DopplerUncertainty)
         utran_DopplerUncertainty_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_CodePhaseSearchWindow_ENUMTAB[] = {
   { OSUTF8("w1"), 1, 2, 1 },
   { OSUTF8("w1023"), 0, 5, 0 },
   { OSUTF8("w12"), 7, 3, 6 },
   { OSUTF8("w128"), 14, 4, 8 },
   { OSUTF8("w16"), 8, 3, 10 },
   { OSUTF8("w192"), 15, 4, 12 },
   { OSUTF8("w2"), 2, 2, 14 },
   { OSUTF8("w24"), 9, 3, 2 },
   { OSUTF8("w3"), 3, 2, 4 },
   { OSUTF8("w32"), 10, 3, 7 },
   { OSUTF8("w4"), 4, 2, 9 },
   { OSUTF8("w48"), 11, 3, 11 },
   { OSUTF8("w6"), 5, 2, 13 },
   { OSUTF8("w64"), 12, 3, 15 },
   { OSUTF8("w8"), 6, 2, 3 },
   { OSUTF8("w96"), 13, 3, 5 }
} ;
#define utran_CodePhaseSearchWindow_ENUMTABSIZE 16

const OSUTF8CHAR* utran_CodePhaseSearchWindow_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CodePhaseSearchWindow_ENUMTABSIZE) {
      return utran_CodePhaseSearchWindow_ENUMTAB
         [utran_CodePhaseSearchWindow_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CodePhaseSearchWindow_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CodePhaseSearchWindow* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CodePhaseSearchWindow_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CodePhaseSearchWindow_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CodePhaseSearchWindow* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CodePhaseSearchWindow_ENUMTAB, 
      utran_CodePhaseSearchWindow_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CodePhaseSearchWindow)
         utran_CodePhaseSearchWindow_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AcquisitionSatInfo (utran_AcquisitionSatInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_AcquisitionSatInfoList (
   utran_AcquisitionSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AcquisitionSatInfoList (OSCTXT *pctxt, 
   utran_AcquisitionSatInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance (
   utran_UE_Positioning_GPS_AcquisitionAssistance* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UTRAN_GPSReferenceTime (&pvalue->utran_GPSReferenceTime);
   asn1Init_utran_AcquisitionSatInfoList (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AcquisitionAssistance* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.utran_GPSReferenceTimePresent) {
      asn1Free_utran_UTRAN_GPSReferenceTime (pctxt, &pvalue->utran_GPSReferenceTime);
   }
   asn1Free_utran_AcquisitionSatInfoList (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_BadSatList (utran_BadSatList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo (
   utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UE_Positioning_GPS_ReferenceCellInfo (
   utran_UE_Positioning_GPS_ReferenceCellInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UE_Positioning_GPS_ReferenceCellInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_ReferenceCellInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_Positioning_GPS_ReferenceCellInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_UE_Positioning_GPS_AssistanceData (
   utran_UE_Positioning_GPS_AssistanceData* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GPS_ReferenceTime (&pvalue->ue_positioning_GPS_ReferenceTime);
   asn1Init_utran_UE_Positioning_GPS_DGPS_Corrections (&pvalue->ue_positioning_GPS_DGPS_Corrections);
   asn1Init_utran_UE_Positioning_GPS_NavigationModel (&pvalue->ue_positioning_GPS_NavigationModel);
   asn1Init_utran_UE_Positioning_GPS_IonosphericModel (&pvalue->ue_positioning_GPS_IonosphericModel);
   asn1Init_utran_UE_Positioning_GPS_UTC_Model (&pvalue->ue_positioning_GPS_UTC_Model);
   asn1Init_utran_UE_Positioning_GPS_Almanac (&pvalue->ue_positioning_GPS_Almanac);
   asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance (&pvalue->ue_positioning_GPS_AcquisitionAssistance);
   asn1Init_utran_BadSatList (&pvalue->ue_positioning_GPS_Real_timeIntegrity);
   asn1Init_utran_UE_Positioning_GPS_ReferenceCellInfo (&pvalue->dummy);
}

void asn1Free_utran_UE_Positioning_GPS_AssistanceData (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AssistanceData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_GPS_ReferenceTimePresent) {
      asn1Free_utran_UE_Positioning_GPS_ReferenceTime (pctxt, &pvalue->ue_positioning_GPS_ReferenceTime);
   }
   if (pvalue->m.ue_positioning_GPS_DGPS_CorrectionsPresent) {
      asn1Free_utran_UE_Positioning_GPS_DGPS_Corrections (pctxt, &pvalue->ue_positioning_GPS_DGPS_Corrections);
   }
   if (pvalue->m.ue_positioning_GPS_NavigationModelPresent) {
      asn1Free_utran_UE_Positioning_GPS_NavigationModel (pctxt, &pvalue->ue_positioning_GPS_NavigationModel);
   }
   if (pvalue->m.ue_positioning_GPS_AlmanacPresent) {
      asn1Free_utran_UE_Positioning_GPS_Almanac (pctxt, &pvalue->ue_positioning_GPS_Almanac);
   }
   if (pvalue->m.ue_positioning_GPS_AcquisitionAssistancePresent) {
      asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance (pctxt, &pvalue->ue_positioning_GPS_AcquisitionAssistance);
   }
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_UE_Positioning_GPS_ReferenceCellInfo (pctxt, &pvalue->dummy);
   }
}

static const OSEnumItem utran_BurstType_ENUMTAB[] = {
   { OSUTF8("type1"), 0, 5, 0 },
   { OSUTF8("type2"), 1, 5, 1 }
} ;
#define utran_BurstType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_BurstType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_BurstType_ENUMTABSIZE) {
      return utran_BurstType_ENUMTAB
         [utran_BurstType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_BurstType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_BurstType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_BurstType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_BurstType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_BurstType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_BurstType_ENUMTAB, 
      utran_BurstType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_BurstType)utran_BurstType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo (
   utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_EllipsoidPoint_latitudeSign_ENUMTAB[] = {
   { OSUTF8("north"), 0, 5, 0 },
   { OSUTF8("south"), 1, 5, 1 }
} ;
#define utran_EllipsoidPoint_latitudeSign_ENUMTABSIZE 2

const OSUTF8CHAR* utran_EllipsoidPoint_latitudeSign_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EllipsoidPoint_latitudeSign_ENUMTABSIZE) {
      return utran_EllipsoidPoint_latitudeSign_ENUMTAB
         [utran_EllipsoidPoint_latitudeSign_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EllipsoidPoint_latitudeSign_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_EllipsoidPoint_latitudeSign* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EllipsoidPoint_latitudeSign_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EllipsoidPoint_latitudeSign_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EllipsoidPoint_latitudeSign* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EllipsoidPoint_latitudeSign_ENUMTAB, 
      utran_EllipsoidPoint_latitudeSign_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EllipsoidPoint_latitudeSign)
         utran_EllipsoidPoint_latitudeSign_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_EllipsoidPointAltitude_latitudeSign_ENUMTAB[] = {
   { OSUTF8("north"), 0, 5, 0 },
   { OSUTF8("south"), 1, 5, 1 }
} ;
#define utran_EllipsoidPointAltitude_latitudeSign_ENUMTABSIZE 2

const OSUTF8CHAR* utran_EllipsoidPointAltitude_latitudeSign_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EllipsoidPointAltitude_latitudeSign_ENUMTABSIZE) {
      return utran_EllipsoidPointAltitude_latitudeSign_ENUMTAB
         [utran_EllipsoidPointAltitude_latitudeSign_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EllipsoidPointAltitude_latitudeSign_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_EllipsoidPointAltitude_latitudeSign* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EllipsoidPointAltitude_latitudeSign_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EllipsoidPointAltitude_latitudeSign_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EllipsoidPointAltitude_latitudeSign* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EllipsoidPointAltitude_latitudeSign_ENUMTAB, 
      utran_EllipsoidPointAltitude_latitudeSign_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EllipsoidPointAltitude_latitudeSign)
         utran_EllipsoidPointAltitude_latitudeSign_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_EllipsoidPointAltitude_altitudeDirection_ENUMTAB[] = {
   { OSUTF8("depth"), 1, 5, 1 },
   { OSUTF8("height"), 0, 6, 0 }
} ;
#define utran_EllipsoidPointAltitude_altitudeDirection_ENUMTABSIZE 2

const OSUTF8CHAR* utran_EllipsoidPointAltitude_altitudeDirection_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EllipsoidPointAltitude_altitudeDirection_ENUMTABSIZE) {
      return utran_EllipsoidPointAltitude_altitudeDirection_ENUMTAB
         [utran_EllipsoidPointAltitude_altitudeDirection_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EllipsoidPointAltitude_altitudeDirection_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_EllipsoidPointAltitude_altitudeDirection* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EllipsoidPointAltitude_altitudeDirection_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EllipsoidPointAltitude_altitudeDirection_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EllipsoidPointAltitude_altitudeDirection* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EllipsoidPointAltitude_altitudeDirection_ENUMTAB, 
      utran_EllipsoidPointAltitude_altitudeDirection_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EllipsoidPointAltitude_altitudeDirection)
         utran_EllipsoidPointAltitude_altitudeDirection_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ReferenceCellPosition (utran_ReferenceCellPosition* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ReferenceCellPosition (OSCTXT *pctxt, 
   utran_ReferenceCellPosition* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ellipsoidPoint) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ellipsoidPoint);
         }
         break;

      case 2:
         if (0 != pvalue->u.ellipsoidPointWithAltitude) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ellipsoidPointWithAltitude);
         }
         break;

   }
}

static const OSEnumItem utran_IP_Spacing_ENUMTAB[] = {
   { OSUTF8("e10"), 2, 3, 5 },
   { OSUTF8("e15"), 3, 3, 7 },
   { OSUTF8("e20"), 4, 3, 0 },
   { OSUTF8("e30"), 5, 3, 1 },
   { OSUTF8("e40"), 6, 3, 2 },
   { OSUTF8("e5"), 0, 2, 3 },
   { OSUTF8("e50"), 7, 3, 4 },
   { OSUTF8("e7"), 1, 2, 6 }
} ;
#define utran_IP_Spacing_ENUMTABSIZE 8

const OSUTF8CHAR* utran_IP_Spacing_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IP_Spacing_ENUMTABSIZE) {
      return utran_IP_Spacing_ENUMTAB
         [utran_IP_Spacing_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IP_Spacing_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_IP_Spacing* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IP_Spacing_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IP_Spacing_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_IP_Spacing* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_IP_Spacing_ENUMTAB, 
      utran_IP_Spacing_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IP_Spacing)utran_IP_Spacing_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_IP_Length_ENUMTAB[] = {
   { OSUTF8("ipl10"), 1, 5, 1 },
   { OSUTF8("ipl5"), 0, 4, 0 }
} ;
#define utran_IP_Length_ENUMTABSIZE 2

const OSUTF8CHAR* utran_IP_Length_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IP_Length_ENUMTABSIZE) {
      return utran_IP_Length_ENUMTAB
         [utran_IP_Length_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IP_Length_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_IP_Length* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IP_Length_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IP_Length_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_IP_Length* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_IP_Length_ENUMTAB, 
      utran_IP_Length_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IP_Length)utran_IP_Length_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_IPDL_Parameters (
   utran_UE_Positioning_IPDL_Parameters* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB (
   utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_FrequencyInfo (&pvalue->frequencyInfo);
   asn1Init_utran_ReferenceCellPosition (&pvalue->cellPosition);
   asn1Init_utran_UE_Positioning_IPDL_Parameters (&pvalue->ue_positioning_IPDL_Paremeters);
}

void asn1Free_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.frequencyInfoPresent) {
      asn1Free_utran_FrequencyInfo (pctxt, &pvalue->frequencyInfo);
   }
   if (pvalue->m.cellPositionPresent) {
      asn1Free_utran_ReferenceCellPosition (pctxt, &pvalue->cellPosition);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo (
   utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_SFN_SFN_Drift_ENUMTAB[] = {
   { OSUTF8("sfnsfndrift-1"), 15, 13, 14 },
   { OSUTF8("sfnsfndrift-10"), 21, 14, 15 },
   { OSUTF8("sfnsfndrift-100"), 28, 15, 19 },
   { OSUTF8("sfnsfndrift-15"), 22, 14, 21 },
   { OSUTF8("sfnsfndrift-2"), 16, 13, 23 },
   { OSUTF8("sfnsfndrift-25"), 23, 14, 24 },
   { OSUTF8("sfnsfndrift-3"), 17, 13, 27 },
   { OSUTF8("sfnsfndrift-35"), 24, 14, 16 },
   { OSUTF8("sfnsfndrift-4"), 18, 13, 18 },
   { OSUTF8("sfnsfndrift-5"), 19, 13, 20 },
   { OSUTF8("sfnsfndrift-50"), 25, 14, 22 },
   { OSUTF8("sfnsfndrift-65"), 26, 14, 25 },
   { OSUTF8("sfnsfndrift-8"), 20, 13, 26 },
   { OSUTF8("sfnsfndrift-80"), 27, 14, 28 },
   { OSUTF8("sfnsfndrift0"), 0, 12, 17 },
   { OSUTF8("sfnsfndrift1"), 1, 12, 0 },
   { OSUTF8("sfnsfndrift10"), 7, 13, 4 },
   { OSUTF8("sfnsfndrift100"), 14, 14, 6 },
   { OSUTF8("sfnsfndrift15"), 8, 13, 8 },
   { OSUTF8("sfnsfndrift2"), 2, 12, 9 },
   { OSUTF8("sfnsfndrift25"), 9, 13, 12 },
   { OSUTF8("sfnsfndrift3"), 3, 12, 1 },
   { OSUTF8("sfnsfndrift35"), 10, 13, 3 },
   { OSUTF8("sfnsfndrift4"), 4, 12, 5 },
   { OSUTF8("sfnsfndrift5"), 5, 12, 7 },
   { OSUTF8("sfnsfndrift50"), 11, 13, 10 },
   { OSUTF8("sfnsfndrift65"), 12, 13, 11 },
   { OSUTF8("sfnsfndrift8"), 6, 12, 13 },
   { OSUTF8("sfnsfndrift80"), 13, 13, 2 }
} ;
#define utran_SFN_SFN_Drift_ENUMTABSIZE 29

const OSUTF8CHAR* utran_SFN_SFN_Drift_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SFN_SFN_Drift_ENUMTABSIZE) {
      return utran_SFN_SFN_Drift_ENUMTAB
         [utran_SFN_SFN_Drift_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SFN_SFN_Drift_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SFN_SFN_Drift* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SFN_SFN_Drift_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SFN_SFN_Drift_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SFN_SFN_Drift* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SFN_SFN_Drift_ENUMTAB, 
      utran_SFN_SFN_Drift_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SFN_SFN_Drift)utran_SFN_SFN_Drift_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_OTDOA_SearchWindowSize_ENUMTAB[] = {
   { OSUTF8("c1280"), 6, 5, 2 },
   { OSUTF8("c160"), 3, 4, 4 },
   { OSUTF8("c20"), 0, 3, 6 },
   { OSUTF8("c320"), 4, 4, 1 },
   { OSUTF8("c40"), 1, 3, 3 },
   { OSUTF8("c640"), 5, 4, 5 },
   { OSUTF8("c80"), 2, 3, 0 },
   { OSUTF8("moreThan1280"), 7, 12, 7 }
} ;
#define utran_OTDOA_SearchWindowSize_ENUMTABSIZE 8

const OSUTF8CHAR* utran_OTDOA_SearchWindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_OTDOA_SearchWindowSize_ENUMTABSIZE) {
      return utran_OTDOA_SearchWindowSize_ENUMTAB
         [utran_OTDOA_SearchWindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_OTDOA_SearchWindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_OTDOA_SearchWindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_OTDOA_SearchWindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_OTDOA_SearchWindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_OTDOA_SearchWindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_OTDOA_SearchWindowSize_ENUMTAB, 
      utran_OTDOA_SearchWindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_OTDOA_SearchWindowSize)
         utran_OTDOA_SearchWindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB (
   utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_FrequencyInfo (&pvalue->frequencyInfo);
   asn1Init_utran_UE_Positioning_IPDL_Parameters (&pvalue->ue_positioning_IPDL_Paremeters);
}

void asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.frequencyInfoPresent) {
      asn1Free_utran_FrequencyInfo (pctxt, &pvalue->frequencyInfo);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB (
   utran_UE_Positioning_OTDOA_NeighbourCellList_UEB* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_NeighbourCellList_UEB* pvalue)
{
   if (0 == pvalue) return;
   { utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB*)pnode->data;
      asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_AssistanceData_UEB (
   utran_UE_Positioning_OTDOA_AssistanceData_UEB* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB (&pvalue->ue_positioning_OTDOA_ReferenceCellInfo_UEB);
   asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB (&pvalue->ue_positioning_OTDOA_NeighbourCellList_UEB);
}

void asn1Free_utran_UE_Positioning_OTDOA_AssistanceData_UEB (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_AssistanceData_UEB* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_OTDOA_ReferenceCellInfo_UEBPresent) {
      asn1Free_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB (pctxt, &pvalue->ue_positioning_OTDOA_ReferenceCellInfo_UEB);
   }
   if (pvalue->m.ue_positioning_OTDOA_NeighbourCellList_UEBPresent) {
      asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB (pctxt, &pvalue->ue_positioning_OTDOA_NeighbourCellList_UEB);
   }
}

static const OSEnumItem utran_SFN_Offset_Validity_ENUMTAB[] = {
   { OSUTF8("false"), 0, 5, 0 }
} ;
#define utran_SFN_Offset_Validity_ENUMTABSIZE 1

const OSUTF8CHAR* utran_SFN_Offset_Validity_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_SFN_Offset_Validity_ENUMTAB, 
      utran_SFN_Offset_Validity_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_SFN_Offset_Validity_ENUMTABSIZE) {
      return utran_SFN_Offset_Validity_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SFN_Offset_Validity_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SFN_Offset_Validity* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SFN_Offset_Validity_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SFN_Offset_Validity_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SFN_Offset_Validity* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SFN_Offset_Validity_ENUMTAB, 
      utran_SFN_Offset_Validity_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SFN_Offset_Validity)
         utran_SFN_Offset_Validity_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_IP_Spacing_TDD_ENUMTAB[] = {
   { OSUTF8("e100"), 4, 4, 1 },
   { OSUTF8("e30"), 0, 3, 2 },
   { OSUTF8("e40"), 1, 3, 3 },
   { OSUTF8("e50"), 2, 3, 4 },
   { OSUTF8("e70"), 3, 3, 0 }
} ;
#define utran_IP_Spacing_TDD_ENUMTABSIZE 5

const OSUTF8CHAR* utran_IP_Spacing_TDD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IP_Spacing_TDD_ENUMTABSIZE) {
      return utran_IP_Spacing_TDD_ENUMTAB
         [utran_IP_Spacing_TDD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IP_Spacing_TDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_IP_Spacing_TDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IP_Spacing_TDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IP_Spacing_TDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_IP_Spacing_TDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_IP_Spacing_TDD_ENUMTAB, 
      utran_IP_Spacing_TDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IP_Spacing_TDD)utran_IP_Spacing_TDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_IPDL_Parameters_TDD_r4_ext (
   utran_UE_Positioning_IPDL_Parameters_TDD_r4_ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext (
   utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext (OSCTXT *pctxt, 
   utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_OTDOA_AssistanceData_r4ext (
   utran_UE_Positioning_OTDOA_AssistanceData_r4ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_IPDL_Parameters_TDD_r4_ext (&pvalue->ue_Positioning_IPDL_Parameters_TDD_r4_ext);
   asn1Init_utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext (&pvalue->ue_Positioning_IPDL_Parameters_TDDList_r4_ext);
}

void asn1Free_utran_UE_Positioning_OTDOA_AssistanceData_r4ext (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_AssistanceData_r4ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_Positioning_IPDL_Parameters_TDDList_r4_extPresent) {
      asn1Free_utran_UE_Positioning_IPDL_Parameters_TDDList_r4_ext (pctxt, &pvalue->ue_Positioning_IPDL_Parameters_TDDList_r4_ext);
   }
}

void asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_ext (
   utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_ext (
   utran_UE_Positioning_OTDOA_NeighbourCellInfo_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext (
   utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_OTDOA_AssistanceData_UEB_ext (
   utran_UE_Positioning_OTDOA_AssistanceData_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_OTDOA_ReferenceCellInfo_UEB_ext (&pvalue->ue_positioning_OTDOA_ReferenceCellInfo_UEB_ext);
   asn1Init_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext (&pvalue->ue_positioning_OTDOA_NeighbourCellList_UEB_ext);
}

void asn1Free_utran_UE_Positioning_OTDOA_AssistanceData_UEB_ext (OSCTXT *pctxt, 
   utran_UE_Positioning_OTDOA_AssistanceData_UEB_ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_OTDOA_NeighbourCellList_UEB_extPresent) {
      asn1Free_utran_UE_Positioning_OTDOA_NeighbourCellList_UEB_ext (pctxt, &pvalue->ue_positioning_OTDOA_NeighbourCellList_UEB_ext);
   }
}

void asn1Init_utran_UE_Positioning_GPS_ReferenceTime_v770ext (
   utran_UE_Positioning_GPS_ReferenceTime_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_v770ext (
   utran_UE_Positioning_GPS_AcquisitionAssistance_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_GPS_AssistanceData_v770ext (
   utran_UE_Positioning_GPS_AssistanceData_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GPS_ReferenceTime_v770ext (&pvalue->ue_positioning_GPS_ReferenceTime);
   asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_v770ext (&pvalue->ue_positioning_GPS_AcquisitionAssistance);
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode (
   utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime (
   utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode (&pvalue->mode);
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime_mode (pctxt, &pvalue->mode);
}

static const OSEnumItem utran_Tutran_Ganss_DriftRate_ENUMTAB[] = {
   { OSUTF8("spare"), 15, 5, 8 },
   { OSUTF8("ugdr-1"), 8, 6, 9 },
   { OSUTF8("ugdr-10"), 11, 7, 12 },
   { OSUTF8("ugdr-15"), 12, 7, 14 },
   { OSUTF8("ugdr-2"), 9, 6, 10 },
   { OSUTF8("ugdr-25"), 13, 7, 11 },
   { OSUTF8("ugdr-5"), 10, 6, 13 },
   { OSUTF8("ugdr-50"), 14, 7, 15 },
   { OSUTF8("ugdr0"), 0, 5, 1 },
   { OSUTF8("ugdr1"), 1, 5, 4 },
   { OSUTF8("ugdr10"), 4, 6, 6 },
   { OSUTF8("ugdr15"), 5, 6, 2 },
   { OSUTF8("ugdr2"), 2, 5, 3 },
   { OSUTF8("ugdr25"), 6, 6, 5 },
   { OSUTF8("ugdr5"), 3, 5, 7 },
   { OSUTF8("ugdr50"), 7, 6, 0 }
} ;
#define utran_Tutran_Ganss_DriftRate_ENUMTABSIZE 16

const OSUTF8CHAR* utran_Tutran_Ganss_DriftRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Tutran_Ganss_DriftRate_ENUMTABSIZE) {
      return utran_Tutran_Ganss_DriftRate_ENUMTAB
         [utran_Tutran_Ganss_DriftRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Tutran_Ganss_DriftRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Tutran_Ganss_DriftRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Tutran_Ganss_DriftRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Tutran_Ganss_DriftRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Tutran_Ganss_DriftRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Tutran_Ganss_DriftRate_ENUMTAB, 
      utran_Tutran_Ganss_DriftRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Tutran_Ganss_DriftRate)
         utran_Tutran_Ganss_DriftRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceTime (
   utran_UE_Positioning_GANSS_ReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime (&pvalue->utran_ganssreferenceTime);
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceTime (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceTime* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.utran_ganssreferenceTimePresent) {
      asn1Free_utran_UE_Positioning_GANSS_ReferenceTime_utran_ganssreferenceTime (pctxt, &pvalue->utran_ganssreferenceTime);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_IonosphericModel (
   utran_UE_Positioning_GANSS_IonosphericModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->alpha_zero_ionos.numbits = 0;
   pvalue->alpha_one_ionos.numbits = 0;
   pvalue->alpha_two_ionos.numbits = 0;
}

static const OSEnumItem utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTAB[] = {
   { OSUTF8("galileo"), 1, 7, 2 },
   { OSUTF8("glonass"), 3, 7, 0 },
   { OSUTF8("gps"), 0, 3, 3 },
   { OSUTF8("qzss"), 2, 4, 1 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 }
} ;
#define utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTABSIZE) {
      return utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTAB
         [utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_Positioning_GANSS_TimeModel_gnss_to_id* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_Positioning_GANSS_TimeModel_gnss_to_id* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTAB, 
      utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_Positioning_GANSS_TimeModel_gnss_to_id)
         utran_UE_Positioning_GANSS_TimeModel_gnss_to_id_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_TimeModel (
   utran_UE_Positioning_GANSS_TimeModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GANSSTimeModelsList (utran_GANSSTimeModelsList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSTimeModelsList (OSCTXT *pctxt, 
   utran_GANSSTimeModelsList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_GANSS_Status_Health_ENUMTAB[] = {
   { OSUTF8("invalid-data"), 7, 12, 7 },
   { OSUTF8("no-data"), 6, 7, 6 },
   { OSUTF8("udre-scale-0dot1"), 5, 16, 5 },
   { OSUTF8("udre-scale-0dot2"), 4, 16, 4 },
   { OSUTF8("udre-scale-0dot3"), 3, 16, 3 },
   { OSUTF8("udre-scale-0dot5"), 2, 16, 2 },
   { OSUTF8("udre-scale-0dot75"), 1, 17, 1 },
   { OSUTF8("udre-scale-1dot0"), 0, 16, 0 }
} ;
#define utran_GANSS_Status_Health_ENUMTABSIZE 8

const OSUTF8CHAR* utran_GANSS_Status_Health_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_GANSS_Status_Health_ENUMTABSIZE) {
      return utran_GANSS_Status_Health_ENUMTAB
         [utran_GANSS_Status_Health_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_GANSS_Status_Health_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_GANSS_Status_Health* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_GANSS_Status_Health_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_GANSS_Status_Health_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_GANSS_Status_Health* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_GANSS_Status_Health_ENUMTAB, 
      utran_GANSS_Status_Health_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_GANSS_Status_Health)
         utran_GANSS_Status_Health_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DGANSSSignalInformation (
   utran_DGANSSSignalInformation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->iode_dganss.numbits = 0;
}

void asn1Init_utran_DGANSSSignalInformationList (
   utran_DGANSSSignalInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGANSSSignalInformationList (OSCTXT *pctxt, 
   utran_DGANSSSignalInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DGANSSInfo (utran_DGANSSInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DGANSSSignalInformationList (&pvalue->dgansssignalInformationList);
}

void asn1Free_utran_DGANSSInfo (OSCTXT *pctxt, utran_DGANSSInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dgansssignalInformationListPresent) {
      asn1Free_utran_DGANSSSignalInformationList (pctxt, &pvalue->dgansssignalInformationList);
   }
}

void asn1Init_utran_DGANSSInfoList (utran_DGANSSInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGANSSInfoList (OSCTXT *pctxt, 
   utran_DGANSSInfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DGANSSInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DGANSSInfo*)pnode->data;
      asn1Free_utran_DGANSSInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_DGANSSCorrections (
   utran_UE_Positioning_DGANSSCorrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DGANSSInfoList (&pvalue->dganssInfoList);
}

void asn1Free_utran_UE_Positioning_DGANSSCorrections (OSCTXT *pctxt, 
   utran_UE_Positioning_DGANSSCorrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DGANSSInfoList (pctxt, &pvalue->dganssInfoList);
}

static const OSEnumItem utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTAB, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTABSIZE) {
      return utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTAB, 
      utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication)
         utran_UE_Positioning_GANSS_NavigationModel_non_broadcastIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Satellite_clock_model (utran_Satellite_clock_model* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->t_oc.numbits = 0;
   pvalue->af2.numbits = 0;
   pvalue->af1.numbits = 0;
   pvalue->af0.numbits = 0;
   pvalue->tgd.numbits = 0;
   pvalue->sisa.numbits = 0;
}

void asn1Init_utran_Satellite_clock_modelList (
   utran_Satellite_clock_modelList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_Satellite_clock_modelList (OSCTXT *pctxt, 
   utran_Satellite_clock_modelList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_ClockModel (
   utran_UE_Positioning_GANSS_ClockModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Satellite_clock_modelList (&pvalue->satellite_clock_modelList);
}

void asn1Free_utran_UE_Positioning_GANSS_ClockModel (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ClockModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Satellite_clock_modelList (pctxt, &pvalue->satellite_clock_modelList);
}

void asn1Init_utran_KeplerianParameters (utran_KeplerianParameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->toe_nav.numbits = 0;
   pvalue->ganss_omega_nav.numbits = 0;
   pvalue->delta_n_nav.numbits = 0;
   pvalue->m_zero_nav.numbits = 0;
   pvalue->omegadot_nav.numbits = 0;
   pvalue->ganss_e_nav.numbits = 0;
   pvalue->idot_nav.numbits = 0;
   pvalue->a_sqrt_nav.numbits = 0;
   pvalue->i_zero_nav.numbits = 0;
   pvalue->omega_zero_nav.numbits = 0;
   pvalue->c_rs_nav.numbits = 0;
   pvalue->c_is_nav.numbits = 0;
   pvalue->c_us_nav.numbits = 0;
   pvalue->c_rc_nav.numbits = 0;
   pvalue->c_ic_nav.numbits = 0;
   pvalue->c_uc_nav.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_OrbitModel (
   utran_UE_Positioning_GANSS_OrbitModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_KeplerianParameters (&pvalue->keplerianParameters);
}

void asn1Init_utran_Ganss_Sat_Info_Nav (utran_Ganss_Sat_Info_Nav* pvalue)
{
   if (0 == pvalue) return;
   pvalue->svHealth.numbits = 0;
   pvalue->iod.numbits = 0;
   asn1Init_utran_UE_Positioning_GANSS_ClockModel (&pvalue->ganssClockModel);
   asn1Init_utran_UE_Positioning_GANSS_OrbitModel (&pvalue->ganssOrbitModel);
}

void asn1Free_utran_Ganss_Sat_Info_Nav (OSCTXT *pctxt, 
   utran_Ganss_Sat_Info_Nav* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_Positioning_GANSS_ClockModel (pctxt, &pvalue->ganssClockModel);
}

void asn1Init_utran_Ganss_Sat_Info_NavList (
   utran_Ganss_Sat_Info_NavList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_Ganss_Sat_Info_NavList (OSCTXT *pctxt, 
   utran_Ganss_Sat_Info_NavList* pvalue)
{
   if (0 == pvalue) return;
   { utran_Ganss_Sat_Info_Nav* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_Ganss_Sat_Info_Nav*)pnode->data;
      asn1Free_utran_Ganss_Sat_Info_Nav (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_NavigationModel (
   utran_UE_Positioning_GANSS_NavigationModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_Ganss_Sat_Info_NavList (&pvalue->ganssSatInfoNavList);
}

void asn1Free_utran_UE_Positioning_GANSS_NavigationModel (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_NavigationModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Ganss_Sat_Info_NavList (pctxt, &pvalue->ganssSatInfoNavList);
}

void asn1Init_utran_UE_Positioning_GANSS_RealTimeIntegrity_element (
   utran_UE_Positioning_GANSS_RealTimeIntegrity_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->bad_ganss_signalId.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_RealTimeIntegrity (
   utran_UE_Positioning_GANSS_RealTimeIntegrity* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UE_Positioning_GANSS_RealTimeIntegrity (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_RealTimeIntegrity* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DataBitAssistance_data_bits (
   utran_DataBitAssistance_data_bits* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_DataBitAssistance (utran_DataBitAssistance* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DataBitAssistance_data_bits (&pvalue->data_bits);
}

void asn1Init_utran_DataBitAssistanceSgnList (
   utran_DataBitAssistanceSgnList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DataBitAssistanceSgnList (OSCTXT *pctxt, 
   utran_DataBitAssistanceSgnList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DataBitAssistanceSat (utran_DataBitAssistanceSat* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DataBitAssistanceSgnList (&pvalue->dataBitAssistanceSgnList);
}

void asn1Free_utran_DataBitAssistanceSat (OSCTXT *pctxt, 
   utran_DataBitAssistanceSat* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DataBitAssistanceSgnList (pctxt, &pvalue->dataBitAssistanceSgnList);
}

void asn1Init_utran_DataBitAssistanceList (utran_DataBitAssistanceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DataBitAssistanceList (OSCTXT *pctxt, 
   utran_DataBitAssistanceList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DataBitAssistanceSat* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DataBitAssistanceSat*)pnode->data;
      asn1Free_utran_DataBitAssistanceSat (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_Data_Bit_Assistance (
   utran_UE_Positioning_GANSS_Data_Bit_Assistance* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DataBitAssistanceList (&pvalue->dataBitAssistanceList);
}

void asn1Free_utran_UE_Positioning_GANSS_Data_Bit_Assistance (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_Data_Bit_Assistance* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DataBitAssistanceList (pctxt, &pvalue->dataBitAssistanceList);
}

static const OSEnumItem utran_ExtraDoppler_dopplerUncertainty_ENUMTAB[] = {
   { OSUTF8("dopU10"), 2, 6, 3 },
   { OSUTF8("dopU2-5"), 4, 7, 2 },
   { OSUTF8("dopU20"), 1, 6, 0 },
   { OSUTF8("dopU40"), 0, 6, 4 },
   { OSUTF8("dopU5"), 3, 5, 1 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define utran_ExtraDoppler_dopplerUncertainty_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ExtraDoppler_dopplerUncertainty_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ExtraDoppler_dopplerUncertainty_ENUMTABSIZE) {
      return utran_ExtraDoppler_dopplerUncertainty_ENUMTAB
         [utran_ExtraDoppler_dopplerUncertainty_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ExtraDoppler_dopplerUncertainty_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ExtraDoppler_dopplerUncertainty* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ExtraDoppler_dopplerUncertainty_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ExtraDoppler_dopplerUncertainty_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ExtraDoppler_dopplerUncertainty* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ExtraDoppler_dopplerUncertainty_ENUMTAB, 
      utran_ExtraDoppler_dopplerUncertainty_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ExtraDoppler_dopplerUncertainty)
         utran_ExtraDoppler_dopplerUncertainty_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_GANSSSatelliteInformation (
   utran_GANSSSatelliteInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->codePhaseSearchWindow.numbits = 0;
}

void asn1Init_utran_GANSSSatelliteInformationList (
   utran_GANSSSatelliteInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSSatelliteInformationList (OSCTXT *pctxt, 
   utran_GANSSSatelliteInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo (
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSSatelliteInformationList (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSSSatelliteInformationList (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_Kp (
   utran_GANSS_SAT_Info_Almanac_Kp* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ganss_alm_e.numbits = 0;
   pvalue->ganss_delta_I_alm.numbits = 0;
   pvalue->ganss_omegadot_alm.numbits = 0;
   pvalue->ganss_svstatusINAV_alm.numbits = 0;
   pvalue->ganss_svstatusFNAV_alm.numbits = 0;
   pvalue->ganss_delta_a_sqrt_alm.numbits = 0;
   pvalue->ganss_omegazero_alm.numbits = 0;
   pvalue->ganss_m_zero_alm.numbits = 0;
   pvalue->ganss_omega_alm.numbits = 0;
   pvalue->ganss_af_zero_alm.numbits = 0;
   pvalue->ganss_af_one_alm.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_KpList (
   utran_GANSS_SAT_Info_Almanac_KpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_KpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_KpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_keplerianParameters (
   utran_ALM_keplerianParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_KpList (&pvalue->sat_info_kpList);
}

void asn1Free_utran_ALM_keplerianParameters (OSCTXT *pctxt, 
   utran_ALM_keplerianParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_KpList (pctxt, &pvalue->sat_info_kpList);
}

void asn1Init_utran_UE_Positioning_GANSS_Almanac (
   utran_UE_Positioning_GANSS_Almanac* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_ALM_keplerianParameters (&pvalue->alm_keplerianParameters);
}

void asn1Free_utran_UE_Positioning_GANSS_Almanac (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_Almanac* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.alm_keplerianParametersPresent) {
      asn1Free_utran_ALM_keplerianParameters (pctxt, &pvalue->alm_keplerianParameters);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_UTCModel (
   utran_UE_Positioning_GANSS_UTCModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->a_one_utc.numbits = 0;
   pvalue->a_zero_utc.numbits = 0;
   pvalue->t_ot_utc.numbits = 0;
   pvalue->delta_t_ls_utc.numbits = 0;
   pvalue->w_n_t_utc.numbits = 0;
   pvalue->w_n_lsf_utc.numbits = 0;
   pvalue->dn_utc.numbits = 0;
   pvalue->delta_t_lsf_utc.numbits = 0;
}

void asn1Init_utran_GANSSGenericData (utran_GANSSGenericData* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSTimeModelsList (&pvalue->ganssTimeModelsList);
   asn1Init_utran_UE_Positioning_DGANSSCorrections (&pvalue->uePositioningDGANSSCorrections);
   asn1Init_utran_UE_Positioning_GANSS_NavigationModel (&pvalue->uePositioningGANSSNavigationModel);
   asn1Init_utran_UE_Positioning_GANSS_RealTimeIntegrity (&pvalue->uePositioningGANSSRealTimeIntegrity);
   asn1Init_utran_UE_Positioning_GANSS_Data_Bit_Assistance (&pvalue->uePositioningGANSSDataBitAssistance);
   asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo (&pvalue->uePositioningGANSSReferenceMeasurementInfo);
   asn1Init_utran_UE_Positioning_GANSS_Almanac (&pvalue->uePositioningGANSSAlmanac);
   asn1Init_utran_UE_Positioning_GANSS_UTCModel (&pvalue->uePositioningGANSSUTCModel);
}

void asn1Free_utran_GANSSGenericData (OSCTXT *pctxt, 
   utran_GANSSGenericData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssTimeModelsListPresent) {
      asn1Free_utran_GANSSTimeModelsList (pctxt, &pvalue->ganssTimeModelsList);
   }
   if (pvalue->m.uePositioningDGANSSCorrectionsPresent) {
      asn1Free_utran_UE_Positioning_DGANSSCorrections (pctxt, &pvalue->uePositioningDGANSSCorrections);
   }
   if (pvalue->m.uePositioningGANSSNavigationModelPresent) {
      asn1Free_utran_UE_Positioning_GANSS_NavigationModel (pctxt, &pvalue->uePositioningGANSSNavigationModel);
   }
   if (pvalue->m.uePositioningGANSSRealTimeIntegrityPresent) {
      asn1Free_utran_UE_Positioning_GANSS_RealTimeIntegrity (pctxt, &pvalue->uePositioningGANSSRealTimeIntegrity);
   }
   if (pvalue->m.uePositioningGANSSDataBitAssistancePresent) {
      asn1Free_utran_UE_Positioning_GANSS_Data_Bit_Assistance (pctxt, &pvalue->uePositioningGANSSDataBitAssistance);
   }
   if (pvalue->m.uePositioningGANSSReferenceMeasurementInfoPresent) {
      asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo (pctxt, &pvalue->uePositioningGANSSReferenceMeasurementInfo);
   }
   if (pvalue->m.uePositioningGANSSAlmanacPresent) {
      asn1Free_utran_UE_Positioning_GANSS_Almanac (pctxt, &pvalue->uePositioningGANSSAlmanac);
   }
}

void asn1Init_utran_GANSSGenericDataList (utran_GANSSGenericDataList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSGenericDataList (OSCTXT *pctxt, 
   utran_GANSSGenericDataList* pvalue)
{
   if (0 == pvalue) return;
   { utran_GANSSGenericData* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_GANSSGenericData*)pnode->data;
      asn1Free_utran_GANSSGenericData (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AssistanceData (
   utran_UE_Positioning_GANSS_AssistanceData* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GANSS_ReferenceTime (&pvalue->ue_positioning_GANSS_ReferenceTime);
   asn1Init_utran_UE_Positioning_GANSS_IonosphericModel (&pvalue->uePositioningGanssIonosphericModel);
   asn1Init_utran_GANSSGenericDataList (&pvalue->ganssGenericDataList);
}

void asn1Free_utran_UE_Positioning_GANSS_AssistanceData (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AssistanceData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_GANSS_ReferenceTimePresent) {
      asn1Free_utran_UE_Positioning_GANSS_ReferenceTime (pctxt, &pvalue->ue_positioning_GANSS_ReferenceTime);
   }
   if (pvalue->m.ganssGenericDataListPresent) {
      asn1Free_utran_GANSSGenericDataList (pctxt, &pvalue->ganssGenericDataList);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AddIonoModel (
   utran_UE_Positioning_GANSS_AddIonoModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->dataID.numbits = 0;
   asn1Init_utran_UE_Positioning_GPS_IonosphericModel (&pvalue->alpha_beta_parameters);
}

void asn1Init_utran_UE_Positioning_GANSS_EarthOrientPara (
   utran_UE_Positioning_GANSS_EarthOrientPara* pvalue)
{
   if (0 == pvalue) return;
   pvalue->teop.numbits = 0;
   pvalue->pmX.numbits = 0;
   pvalue->pmXdot.numbits = 0;
   pvalue->pmY.numbits = 0;
   pvalue->pmYdot.numbits = 0;
   pvalue->deltaUT1.numbits = 0;
   pvalue->deltaUT1dot.numbits = 0;
}

static const OSEnumItem utran_UE_Positioning_GANSS_SBAS_ID_ENUMTAB[] = {
   { OSUTF8("egnos"), 1, 5, 7 },
   { OSUTF8("gagan"), 3, 5, 0 },
   { OSUTF8("msas"), 2, 4, 2 },
   { OSUTF8("spare1"), 7, 6, 1 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 },
   { OSUTF8("spare4"), 4, 6, 4 },
   { OSUTF8("waas"), 0, 4, 3 }
} ;
#define utran_UE_Positioning_GANSS_SBAS_ID_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UE_Positioning_GANSS_SBAS_ID_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_Positioning_GANSS_SBAS_ID_ENUMTABSIZE) {
      return utran_UE_Positioning_GANSS_SBAS_ID_ENUMTAB
         [utran_UE_Positioning_GANSS_SBAS_ID_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_Positioning_GANSS_SBAS_ID_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UE_Positioning_GANSS_SBAS_ID* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_Positioning_GANSS_SBAS_ID_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_Positioning_GANSS_SBAS_ID_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_Positioning_GANSS_SBAS_ID* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_Positioning_GANSS_SBAS_ID_ENUMTAB, 
      utran_UE_Positioning_GANSS_SBAS_ID_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_Positioning_GANSS_SBAS_ID)
         utran_UE_Positioning_GANSS_SBAS_ID_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTAB, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTABSIZE) {
      return utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTAB, 
      utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication)
         utran_UE_Positioning_GANSS_AddNavigationModels_non_broadcastIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_NAVclockModel (utran_NAVclockModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->navToc.numbits = 0;
   pvalue->navaf2.numbits = 0;
   pvalue->navaf1.numbits = 0;
   pvalue->navaf0.numbits = 0;
   pvalue->navTgd.numbits = 0;
}

void asn1Init_utran_CNAVclockModel (utran_CNAVclockModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->cnavToc.numbits = 0;
   pvalue->cnavTop.numbits = 0;
   pvalue->cnavURA0.numbits = 0;
   pvalue->cnavURA1.numbits = 0;
   pvalue->cnavURA2.numbits = 0;
   pvalue->cnavAf2.numbits = 0;
   pvalue->cnavAf1.numbits = 0;
   pvalue->cnavAf0.numbits = 0;
   pvalue->cnavTgd.numbits = 0;
   pvalue->cnavISCl1cp.numbits = 0;
   pvalue->cnavISCl1cd.numbits = 0;
   pvalue->cnavISCl1ca.numbits = 0;
   pvalue->cnavISCl2c.numbits = 0;
   pvalue->cnavISCl5i5.numbits = 0;
   pvalue->cnavISCl5q5.numbits = 0;
}

void asn1Init_utran_GLONASSclockModel (utran_GLONASSclockModel* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->gloTau.numbits = 0;
   pvalue->gloGamma.numbits = 0;
   pvalue->gloDeltaTau.numbits = 0;
}

void asn1Init_utran_SBASclockModel (utran_SBASclockModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->sbasTo.numbits = 0;
   pvalue->sbasAgfo.numbits = 0;
   pvalue->sbasAgf1.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddClockModels (
   utran_UE_Positioning_GANSS_AddClockModels* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_NAVclockModel (&pvalue->navClockModel);
   asn1Init_utran_CNAVclockModel (&pvalue->cnavClockModel);
   asn1Init_utran_GLONASSclockModel (&pvalue->glonassClockModel);
   asn1Init_utran_SBASclockModel (&pvalue->sbasClockModel);
}

void asn1Init_utran_NavModel_NAVKeplerianSet (
   utran_NavModel_NAVKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   pvalue->navURA.numbits = 0;
   pvalue->navFitFlag.numbits = 0;
   pvalue->navToe.numbits = 0;
   pvalue->navOmega.numbits = 0;
   pvalue->navDeltaN.numbits = 0;
   pvalue->navM0.numbits = 0;
   pvalue->navOmegaADot.numbits = 0;
   pvalue->navE.numbits = 0;
   pvalue->navIDot.numbits = 0;
   pvalue->navAPowerHalf.numbits = 0;
   pvalue->navI0.numbits = 0;
   pvalue->navOmegaA0.numbits = 0;
   pvalue->navCrs.numbits = 0;
   pvalue->navCis.numbits = 0;
   pvalue->navCus.numbits = 0;
   pvalue->navCrc.numbits = 0;
   pvalue->navCic.numbits = 0;
   pvalue->navCuc.numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet_cnavMo (
   utran_NavModel_CNAVKeplerianSet_cnavMo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet_cnavE (
   utran_NavModel_CNAVKeplerianSet_cnavE* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet_cnavOmega (
   utran_NavModel_CNAVKeplerianSet_cnavOmega* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet_cnavOMEGA0 (
   utran_NavModel_CNAVKeplerianSet_cnavOMEGA0* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet_cnavIo (
   utran_NavModel_CNAVKeplerianSet_cnavIo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_NavModel_CNAVKeplerianSet (
   utran_NavModel_CNAVKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   pvalue->cnavTop.numbits = 0;
   pvalue->cnavURAindex.numbits = 0;
   pvalue->cnavDeltaA.numbits = 0;
   pvalue->cnavAdot.numbits = 0;
   pvalue->cnavDeltaNo.numbits = 0;
   pvalue->cnavDeltaNoDot.numbits = 0;
   asn1Init_utran_NavModel_CNAVKeplerianSet_cnavMo (&pvalue->cnavMo);
   asn1Init_utran_NavModel_CNAVKeplerianSet_cnavE (&pvalue->cnavE);
   asn1Init_utran_NavModel_CNAVKeplerianSet_cnavOmega (&pvalue->cnavOmega);
   asn1Init_utran_NavModel_CNAVKeplerianSet_cnavOMEGA0 (&pvalue->cnavOMEGA0);
   pvalue->cnavDeltaOmegaDot.numbits = 0;
   asn1Init_utran_NavModel_CNAVKeplerianSet_cnavIo (&pvalue->cnavIo);
   pvalue->cnavIoDot.numbits = 0;
   pvalue->cnavCis.numbits = 0;
   pvalue->cnavCic.numbits = 0;
   pvalue->cnavCrs.numbits = 0;
   pvalue->cnavCrc.numbits = 0;
   pvalue->cnavCus.numbits = 0;
   pvalue->cnavCuc.numbits = 0;
}

void asn1Init_utran_NavModel_GLONASSecef (utran_NavModel_GLONASSecef* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->gloEn.numbits = 0;
   pvalue->gloP1.numbits = 0;
   pvalue->gloP2.numbits = 0;
   pvalue->gloM.numbits = 0;
   pvalue->gloX.numbits = 0;
   pvalue->gloXdot.numbits = 0;
   pvalue->gloXdotdot.numbits = 0;
   pvalue->gloY.numbits = 0;
   pvalue->gloYdot.numbits = 0;
   pvalue->gloYdotdot.numbits = 0;
   pvalue->gloZ.numbits = 0;
   pvalue->gloZdot.numbits = 0;
   pvalue->gloZdotdot.numbits = 0;
}

void asn1Init_utran_NavModel_SBASecef (utran_NavModel_SBASecef* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->sbasTo.numbits = 0;
   pvalue->sbasAccuracy.numbits = 0;
   pvalue->sbasXg.numbits = 0;
   pvalue->sbasYg.numbits = 0;
   pvalue->sbasZg.numbits = 0;
   pvalue->sbasXgDot.numbits = 0;
   pvalue->sbasYgDot.numbits = 0;
   pvalue->sbasZgDot.numbits = 0;
   pvalue->sbasXgDotDot.numbits = 0;
   pvalue->sbagYgDotDot.numbits = 0;
   pvalue->sbasZgDotDot.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddOrbitModels (
   utran_UE_Positioning_GANSS_AddOrbitModels* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_NavModel_NAVKeplerianSet (&pvalue->navKeplerianSet);
   asn1Init_utran_NavModel_CNAVKeplerianSet (&pvalue->cnavKeplerianSet);
   asn1Init_utran_NavModel_GLONASSecef (&pvalue->glonassECEF);
   asn1Init_utran_NavModel_SBASecef (&pvalue->sbasECEF);
}

void asn1Init_utran_Ganss_Sat_Info_AddNav (utran_Ganss_Sat_Info_AddNav* pvalue)
{
   if (0 == pvalue) return;
   pvalue->svHealth.numbits = 0;
   pvalue->iod.numbits = 0;
   asn1Init_utran_UE_Positioning_GANSS_AddClockModels (&pvalue->ganssClockModel);
   asn1Init_utran_UE_Positioning_GANSS_AddOrbitModels (&pvalue->ganssOrbitModel);
}

void asn1Init_utran_Ganss_Sat_Info_AddNavList (
   utran_Ganss_Sat_Info_AddNavList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_Ganss_Sat_Info_AddNavList (OSCTXT *pctxt, 
   utran_Ganss_Sat_Info_AddNavList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_AddNavigationModels (
   utran_UE_Positioning_GANSS_AddNavigationModels* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_Ganss_Sat_Info_AddNavList (&pvalue->ganssSatInfoNavList);
}

void asn1Free_utran_UE_Positioning_GANSS_AddNavigationModels (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AddNavigationModels* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Ganss_Sat_Info_AddNavList (pctxt, &pvalue->ganssSatInfoNavList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_NAVkp (
   utran_GANSS_SAT_Info_Almanac_NAVkp* pvalue)
{
   if (0 == pvalue) return;
   pvalue->navAlmE.numbits = 0;
   pvalue->navAlmDeltaI.numbits = 0;
   pvalue->navAlmOMEGADOT.numbits = 0;
   pvalue->navAlmSVHealth.numbits = 0;
   pvalue->navAlmSqrtA.numbits = 0;
   pvalue->navAlmOMEGAo.numbits = 0;
   pvalue->navAlmOmega.numbits = 0;
   pvalue->navAlmMo.numbits = 0;
   pvalue->navAlmaf0.numbits = 0;
   pvalue->navAlmaf1.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_NAVkpList (
   utran_GANSS_SAT_Info_Almanac_NAVkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_NAVkpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_NAVkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_NAVKeplerianSet (utran_ALM_NAVKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_NAVkpList (&pvalue->sat_info_NAVkpList);
}

void asn1Free_utran_ALM_NAVKeplerianSet (OSCTXT *pctxt, 
   utran_ALM_NAVKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_NAVkpList (pctxt, &pvalue->sat_info_NAVkpList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_REDkp (
   utran_GANSS_SAT_Info_Almanac_REDkp* pvalue)
{
   if (0 == pvalue) return;
   pvalue->redAlmDeltaA.numbits = 0;
   pvalue->redAlmOmega0.numbits = 0;
   pvalue->redAlmPhi0.numbits = 0;
   pvalue->redAlmL1Health.numbits = 0;
   pvalue->redAlmL2Health.numbits = 0;
   pvalue->redAlmL5Health.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_REDkpList (
   utran_GANSS_SAT_Info_Almanac_REDkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_REDkpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_REDkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_ReducedKeplerianSet (
   utran_ALM_ReducedKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_REDkpList (&pvalue->sat_info_REDkpList);
}

void asn1Free_utran_ALM_ReducedKeplerianSet (OSCTXT *pctxt, 
   utran_ALM_ReducedKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_REDkpList (pctxt, &pvalue->sat_info_REDkpList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_MIDIkp (
   utran_GANSS_SAT_Info_Almanac_MIDIkp* pvalue)
{
   if (0 == pvalue) return;
   pvalue->midiAlmE.numbits = 0;
   pvalue->midiAlmDeltaI.numbits = 0;
   pvalue->midiAlmOmegaDot.numbits = 0;
   pvalue->midiAlmSqrtA.numbits = 0;
   pvalue->midiAlmOmega0.numbits = 0;
   pvalue->midiAlmOmega.numbits = 0;
   pvalue->midiAlmMo.numbits = 0;
   pvalue->midiAlmaf0.numbits = 0;
   pvalue->midiAlmaf1.numbits = 0;
   pvalue->midiAlmL1Health.numbits = 0;
   pvalue->midiAlmL2Health.numbits = 0;
   pvalue->midiAlmL5Health.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_MIDIkpList (
   utran_GANSS_SAT_Info_Almanac_MIDIkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_MIDIkpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_MIDIkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_MidiAlmanacSet (utran_ALM_MidiAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_MIDIkpList (&pvalue->sat_info_MIDIkpList);
}

void asn1Free_utran_ALM_MidiAlmanacSet (OSCTXT *pctxt, 
   utran_ALM_MidiAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_MIDIkpList (pctxt, &pvalue->sat_info_MIDIkpList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_GLOkp (
   utran_GANSS_SAT_Info_Almanac_GLOkp* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->gloAlmNA.numbits = 0;
   pvalue->gloAlmnA.numbits = 0;
   pvalue->gloAlmHA.numbits = 0;
   pvalue->gloAlmLambdaA.numbits = 0;
   pvalue->gloAlmTlambdaA.numbits = 0;
   pvalue->gloAlmDeltaIA.numbits = 0;
   pvalue->gloAkmDeltaTA.numbits = 0;
   pvalue->gloAlmDeltaTdotA.numbits = 0;
   pvalue->gloAlmEpsilonA.numbits = 0;
   pvalue->gloAlmOmegaA.numbits = 0;
   pvalue->gloAlmTauA.numbits = 0;
   pvalue->gloAlmCA.numbits = 0;
   pvalue->gloAlmMA.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_GLOkpList (
   utran_GANSS_SAT_Info_Almanac_GLOkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_GLOkpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_GLOkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_GlonassAlmanacSet (utran_ALM_GlonassAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_GLOkpList (&pvalue->sat_info_GLOkpList);
}

void asn1Free_utran_ALM_GlonassAlmanacSet (OSCTXT *pctxt, 
   utran_ALM_GlonassAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_GLOkpList (pctxt, &pvalue->sat_info_GLOkpList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_SBASecef (
   utran_GANSS_SAT_Info_Almanac_SBASecef* pvalue)
{
   if (0 == pvalue) return;
   pvalue->sbasAlmDataID.numbits = 0;
   pvalue->sbasAlmHealth.numbits = 0;
   pvalue->sbasAlmXg.numbits = 0;
   pvalue->sbasAlmYg.numbits = 0;
   pvalue->sbasAlmZg.numbits = 0;
   pvalue->sbasAlmXgdot.numbits = 0;
   pvalue->sbasAlmYgDot.numbits = 0;
   pvalue->sbasAlmZgDot.numbits = 0;
   pvalue->sbasAlmTo.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_SBASecefList (
   utran_GANSS_SAT_Info_Almanac_SBASecefList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_SBASecefList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_SBASecefList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_ECEFsbasAlmanacSet (
   utran_ALM_ECEFsbasAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_SBASecefList (&pvalue->sat_info_SBASecefList);
}

void asn1Free_utran_ALM_ECEFsbasAlmanacSet (OSCTXT *pctxt, 
   utran_ALM_ECEFsbasAlmanacSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_SBASecefList (pctxt, &pvalue->sat_info_SBASecefList);
}

void asn1Init_utran_UE_Positioning_GANSS_Almanac_v860ext (
   utran_UE_Positioning_GANSS_Almanac_v860ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_ALM_NAVKeplerianSet (&pvalue->alm_keplerianNAVAlmanac);
   asn1Init_utran_ALM_ReducedKeplerianSet (&pvalue->alm_keplerianReducedAlmanac);
   asn1Init_utran_ALM_MidiAlmanacSet (&pvalue->alm_keplerianMidiAlmanac);
   asn1Init_utran_ALM_GlonassAlmanacSet (&pvalue->alm_keplerianGLONASS);
   asn1Init_utran_ALM_ECEFsbasAlmanacSet (&pvalue->alm_ecefSBASAlmanac);
}

void asn1Free_utran_UE_Positioning_GANSS_Almanac_v860ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_Almanac_v860ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.alm_keplerianNAVAlmanacPresent) {
      asn1Free_utran_ALM_NAVKeplerianSet (pctxt, &pvalue->alm_keplerianNAVAlmanac);
   }
   if (pvalue->m.alm_keplerianReducedAlmanacPresent) {
      asn1Free_utran_ALM_ReducedKeplerianSet (pctxt, &pvalue->alm_keplerianReducedAlmanac);
   }
   if (pvalue->m.alm_keplerianMidiAlmanacPresent) {
      asn1Free_utran_ALM_MidiAlmanacSet (pctxt, &pvalue->alm_keplerianMidiAlmanac);
   }
   if (pvalue->m.alm_keplerianGLONASSPresent) {
      asn1Free_utran_ALM_GlonassAlmanacSet (pctxt, &pvalue->alm_keplerianGLONASS);
   }
   if (pvalue->m.alm_ecefSBASAlmanacPresent) {
      asn1Free_utran_ALM_ECEFsbasAlmanacSet (pctxt, &pvalue->alm_ecefSBASAlmanac);
   }
}

void asn1Init_utran_UTCmodelSet1 (utran_UTCmodelSet1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->utcA0.numbits = 0;
   pvalue->utcA1.numbits = 0;
   pvalue->utcA2.numbits = 0;
   pvalue->utcDeltaTls.numbits = 0;
   pvalue->utcTot.numbits = 0;
   pvalue->utcWNot.numbits = 0;
   pvalue->utcWNlsf.numbits = 0;
   pvalue->utcDN.numbits = 0;
   pvalue->utcDeltaTlsf.numbits = 0;
}

void asn1Init_utran_DeltaUT1 (utran_DeltaUT1* pvalue)
{
   if (0 == pvalue) return;
   pvalue->b1.numbits = 0;
   pvalue->b2.numbits = 0;
}

void asn1Init_utran_UTCmodelSet2 (utran_UTCmodelSet2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->nA.numbits = 0;
   pvalue->tauC.numbits = 0;
   asn1Init_utran_DeltaUT1 (&pvalue->deltaUT1);
   pvalue->kp.numbits = 0;
}

void asn1Init_utran_UTCmodelSet3 (utran_UTCmodelSet3* pvalue)
{
   if (0 == pvalue) return;
   pvalue->utcA1wnt.numbits = 0;
   pvalue->utcA0wnt.numbits = 0;
   pvalue->utcTot.numbits = 0;
   pvalue->utcWNt.numbits = 0;
   pvalue->utcDeltaTls.numbits = 0;
   pvalue->utcWNlsf.numbits = 0;
   pvalue->utcDN.numbits = 0;
   pvalue->utcDeltaTlsf.numbits = 0;
   pvalue->utcStandardID.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddUTCModels (
   utran_UE_Positioning_GANSS_AddUTCModels* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UTCmodelSet1 (&pvalue->utcModel1);
   asn1Init_utran_UTCmodelSet2 (&pvalue->utcModel2);
   asn1Init_utran_UTCmodelSet3 (&pvalue->utcModel3);
}

void asn1Init_utran_AuxInfoGANSS_ID1_element (
   utran_AuxInfoGANSS_ID1_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->signalsAvailable.numbits = 0;
}

void asn1Init_utran_AuxInfoGANSS_ID1 (utran_AuxInfoGANSS_ID1* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AuxInfoGANSS_ID1 (OSCTXT *pctxt, 
   utran_AuxInfoGANSS_ID1* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AuxInfoGANSS_ID3_element (
   utran_AuxInfoGANSS_ID3_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->signalsAvailable.numbits = 0;
}

void asn1Init_utran_AuxInfoGANSS_ID3 (utran_AuxInfoGANSS_ID3* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AuxInfoGANSS_ID3 (OSCTXT *pctxt, 
   utran_AuxInfoGANSS_ID3* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_AuxiliaryInfo (
   utran_UE_Positioning_GANSS_AuxiliaryInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UE_Positioning_GANSS_AuxiliaryInfo (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AuxiliaryInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ganssID1) {
            asn1Free_utran_AuxInfoGANSS_ID1 (pctxt, pvalue->u.ganssID1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ganssID1);
         }
         break;

      case 2:
         if (0 != pvalue->u.ganssID3) {
            asn1Free_utran_AuxInfoGANSS_ID3 (pctxt, pvalue->u.ganssID3);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ganssID3);
         }
         break;

   }
}

void asn1Init_utran_GANSSGenericData_v860ext (
   utran_GANSSGenericData_v860ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GANSS_AddNavigationModels (&pvalue->uePositioningGANSSAddNavigationModels);
   asn1Init_utran_UE_Positioning_GANSS_Almanac_v860ext (&pvalue->uePositioningGANSSAlmanac);
   asn1Init_utran_UE_Positioning_GANSS_AddUTCModels (&pvalue->uePositioningGANSSAddUTCModels);
   asn1Init_utran_UE_Positioning_GANSS_AuxiliaryInfo (&pvalue->uePositioningGANSSAuxiliaryInfo);
}

void asn1Free_utran_GANSSGenericData_v860ext (OSCTXT *pctxt, 
   utran_GANSSGenericData_v860ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.uePositioningGANSSAddNavigationModelsPresent) {
      asn1Free_utran_UE_Positioning_GANSS_AddNavigationModels (pctxt, &pvalue->uePositioningGANSSAddNavigationModels);
   }
   if (pvalue->m.uePositioningGANSSAlmanacPresent) {
      asn1Free_utran_UE_Positioning_GANSS_Almanac_v860ext (pctxt, &pvalue->uePositioningGANSSAlmanac);
   }
   if (pvalue->m.uePositioningGANSSAuxiliaryInfoPresent) {
      asn1Free_utran_UE_Positioning_GANSS_AuxiliaryInfo (pctxt, &pvalue->uePositioningGANSSAuxiliaryInfo);
   }
}

void asn1Init_utran_GANSSGenericDataList_v860ext (
   utran_GANSSGenericDataList_v860ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSGenericDataList_v860ext (OSCTXT *pctxt, 
   utran_GANSSGenericDataList_v860ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_GANSSGenericData_v860ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_GANSSGenericData_v860ext*)pnode->data;
      asn1Free_utran_GANSSGenericData_v860ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AssistanceData_v860ext (
   utran_UE_Positioning_GANSS_AssistanceData_v860ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GANSS_AddIonoModel (&pvalue->uePositioningGanssAddIonoModel);
   asn1Init_utran_UE_Positioning_GANSS_EarthOrientPara (&pvalue->uePositioningGanssEarthOrientationPara);
   asn1Init_utran_GANSSGenericDataList_v860ext (&pvalue->ganssGenericDataList);
}

void asn1Free_utran_UE_Positioning_GANSS_AssistanceData_v860ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AssistanceData_v860ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssGenericDataListPresent) {
      asn1Free_utran_GANSSGenericDataList_v860ext (pctxt, &pvalue->ganssGenericDataList);
   }
}

static const OSEnumItem utran_UDREGrowthRate_ENUMTAB[] = {
   { OSUTF8("growth-1-5"), 0, 10, 0 },
   { OSUTF8("growth-10"), 5, 9, 4 },
   { OSUTF8("growth-12"), 6, 9, 5 },
   { OSUTF8("growth-16"), 7, 9, 6 },
   { OSUTF8("growth-2"), 1, 8, 7 },
   { OSUTF8("growth-4"), 2, 8, 1 },
   { OSUTF8("growth-6"), 3, 8, 2 },
   { OSUTF8("growth-8"), 4, 8, 3 }
} ;
#define utran_UDREGrowthRate_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UDREGrowthRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UDREGrowthRate_ENUMTABSIZE) {
      return utran_UDREGrowthRate_ENUMTAB
         [utran_UDREGrowthRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UDREGrowthRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UDREGrowthRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UDREGrowthRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UDREGrowthRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UDREGrowthRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UDREGrowthRate_ENUMTAB, 
      utran_UDREGrowthRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UDREGrowthRate)utran_UDREGrowthRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UDREValidityTime_ENUMTAB[] = {
   { OSUTF8("val-1280sec"), 6, 11, 2 },
   { OSUTF8("val-160sec"), 3, 10, 5 },
   { OSUTF8("val-20sec"), 0, 9, 7 },
   { OSUTF8("val-2560sec"), 7, 11, 1 },
   { OSUTF8("val-320sec"), 4, 10, 4 },
   { OSUTF8("val-40sec"), 1, 9, 6 },
   { OSUTF8("val-640sec"), 5, 10, 0 },
   { OSUTF8("val-80sec"), 2, 9, 3 }
} ;
#define utran_UDREValidityTime_ENUMTABSIZE 8

const OSUTF8CHAR* utran_UDREValidityTime_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UDREValidityTime_ENUMTABSIZE) {
      return utran_UDREValidityTime_ENUMTAB
         [utran_UDREValidityTime_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UDREValidityTime_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UDREValidityTime* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UDREValidityTime_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UDREValidityTime_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UDREValidityTime* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UDREValidityTime_ENUMTAB, utran_UDREValidityTime_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UDREValidityTime)
         utran_UDREValidityTime_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DGPS_CorrectionSatInfo_v920ext (
   utran_DGPS_CorrectionSatInfo_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DGPS_CorrectionSatInfoList_v920ext (
   utran_DGPS_CorrectionSatInfoList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGPS_CorrectionSatInfoList_v920ext (OSCTXT *pctxt, 
   utran_DGPS_CorrectionSatInfoList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_DGPS_Corrections_v920ext (
   utran_UE_Positioning_GPS_DGPS_Corrections_v920ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DGPS_CorrectionSatInfoList_v920ext (&pvalue->dgps_CorrectionSatInfoList);
}

void asn1Free_utran_UE_Positioning_GPS_DGPS_Corrections_v920ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_DGPS_Corrections_v920ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DGPS_CorrectionSatInfoList_v920ext (pctxt, &pvalue->dgps_CorrectionSatInfoList);
}

void asn1Init_utran_UE_Positioning_GPS_AssistanceData_v920ext (
   utran_UE_Positioning_GPS_AssistanceData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GPS_DGPS_Corrections_v920ext (&pvalue->ue_positioning_GPS_DGPS_Corrections);
}

void asn1Free_utran_UE_Positioning_GPS_AssistanceData_v920ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AssistanceData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_GPS_DGPS_CorrectionsPresent) {
      asn1Free_utran_UE_Positioning_GPS_DGPS_Corrections_v920ext (pctxt, &pvalue->ue_positioning_GPS_DGPS_Corrections);
   }
}

void asn1Init_utran_DGANSSSignalInformation_v920ext (
   utran_DGANSSSignalInformation_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DGANSSSignalInformationList_v920ext (
   utran_DGANSSSignalInformationList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGANSSSignalInformationList_v920ext (OSCTXT *pctxt, 
   utran_DGANSSSignalInformationList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DGANSSInfo_v920ext (utran_DGANSSInfo_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DGANSSSignalInformationList_v920ext (&pvalue->dgansssignalInformationList);
}

void asn1Free_utran_DGANSSInfo_v920ext (OSCTXT *pctxt, 
   utran_DGANSSInfo_v920ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dgansssignalInformationListPresent) {
      asn1Free_utran_DGANSSSignalInformationList_v920ext (pctxt, &pvalue->dgansssignalInformationList);
   }
}

void asn1Init_utran_DGANSSInfoList_v920ext (
   utran_DGANSSInfoList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DGANSSInfoList_v920ext (OSCTXT *pctxt, 
   utran_DGANSSInfoList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_DGANSSInfo_v920ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DGANSSInfo_v920ext*)pnode->data;
      asn1Free_utran_DGANSSInfo_v920ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_DGANSSCorrections_v920ext (
   utran_UE_Positioning_DGANSSCorrections_v920ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DGANSSInfoList_v920ext (&pvalue->dganssInfoList);
}

void asn1Free_utran_UE_Positioning_DGANSSCorrections_v920ext (OSCTXT *pctxt, 
   utran_UE_Positioning_DGANSSCorrections_v920ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DGANSSInfoList_v920ext (pctxt, &pvalue->dganssInfoList);
}

void asn1Init_utran_GANSSGenericData_v920ext (
   utran_GANSSGenericData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_DGANSSCorrections_v920ext (&pvalue->uePositioningDGANSSCorrections);
}

void asn1Free_utran_GANSSGenericData_v920ext (OSCTXT *pctxt, 
   utran_GANSSGenericData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.uePositioningDGANSSCorrectionsPresent) {
      asn1Free_utran_UE_Positioning_DGANSSCorrections_v920ext (pctxt, &pvalue->uePositioningDGANSSCorrections);
   }
}

void asn1Init_utran_GANSSGenericDataList_v920ext (
   utran_GANSSGenericDataList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSGenericDataList_v920ext (OSCTXT *pctxt, 
   utran_GANSSGenericDataList_v920ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_GANSSGenericData_v920ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_GANSSGenericData_v920ext*)pnode->data;
      asn1Free_utran_GANSSGenericData_v920ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AssistanceData_v920ext (
   utran_UE_Positioning_GANSS_AssistanceData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSGenericDataList_v920ext (&pvalue->ganssGenericDataList);
}

void asn1Free_utran_UE_Positioning_GANSS_AssistanceData_v920ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AssistanceData_v920ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssGenericDataListPresent) {
      asn1Free_utran_GANSSGenericDataList_v920ext (pctxt, &pvalue->ganssGenericDataList);
   }
}

void asn1Init_utran_UE_Positioning_GPS_ReferenceTime_va40ext (
   utran_UE_Positioning_GPS_ReferenceTime_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_GPS_Almanac_va40ext (
   utran_UE_Positioning_GPS_Almanac_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_AcquisitionSatInfo_va40ext (
   utran_AcquisitionSatInfo_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_AcquisitionSatInfoList_va40ext (
   utran_AcquisitionSatInfoList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AcquisitionSatInfoList_va40ext (OSCTXT *pctxt, 
   utran_AcquisitionSatInfoList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext (
   utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_AcquisitionSatInfoList_va40ext (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AcquisitionSatInfoList_va40ext (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_UE_Positioning_GPS_AssistanceData_va40ext (
   utran_UE_Positioning_GPS_AssistanceData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GPS_ReferenceTime_va40ext (&pvalue->ue_positioning_GPS_ReferenceTime);
   asn1Init_utran_UE_Positioning_GPS_Almanac_va40ext (&pvalue->ue_positioning_GPS_Almanac);
   asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext (&pvalue->ue_positioning_GPS_AcquisitionAssistance);
}

void asn1Free_utran_UE_Positioning_GPS_AssistanceData_va40ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AssistanceData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_GPS_AcquisitionAssistancePresent) {
      asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance_va40ext (pctxt, &pvalue->ue_positioning_GPS_AcquisitionAssistance);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_va40ext (
   utran_UE_Positioning_GANSS_ReferenceTime_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_Positioning_GANSS_TimeModel_va40ext (
   utran_UE_Positioning_GANSS_TimeModel_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GANSSTimeModelsList_va40ext (
   utran_GANSSTimeModelsList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSTimeModelsList_va40ext (OSCTXT *pctxt, 
   utran_GANSSTimeModelsList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_GANSSSatelliteInformation_va40ext (
   utran_GANSSSatelliteInformation_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GANSSSatelliteInformationList_va40ext (
   utran_GANSSSatelliteInformationList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSSatelliteInformationList_va40ext (OSCTXT *pctxt, 
   utran_GANSSSatelliteInformationList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext (
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSSSatelliteInformationList_va40ext (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSSSatelliteInformationList_va40ext (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_UE_Positioning_GANSS_Almanac_va40ext (
   utran_UE_Positioning_GANSS_Almanac_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GANSSGenericData_va40ext (
   utran_GANSSGenericData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSTimeModelsList_va40ext (&pvalue->ganssTimeModelsList);
   asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext (&pvalue->uePositioningGANSSReferenceMeasurementInfo);
   asn1Init_utran_UE_Positioning_GANSS_Almanac_va40ext (&pvalue->uePositioningGANSSAlmanac);
}

void asn1Free_utran_GANSSGenericData_va40ext (OSCTXT *pctxt, 
   utran_GANSSGenericData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssTimeModelsListPresent) {
      asn1Free_utran_GANSSTimeModelsList_va40ext (pctxt, &pvalue->ganssTimeModelsList);
   }
   if (pvalue->m.uePositioningGANSSReferenceMeasurementInfoPresent) {
      asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_va40ext (pctxt, &pvalue->uePositioningGANSSReferenceMeasurementInfo);
   }
}

void asn1Init_utran_GANSSGenericDataList_va40ext (
   utran_GANSSGenericDataList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSGenericDataList_va40ext (OSCTXT *pctxt, 
   utran_GANSSGenericDataList_va40ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_GANSSGenericData_va40ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_GANSSGenericData_va40ext*)pnode->data;
      asn1Free_utran_GANSSGenericData_va40ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AssistanceData_va40ext (
   utran_UE_Positioning_GANSS_AssistanceData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GANSS_ReferenceTime_va40ext (&pvalue->ue_positioning_GANSS_ReferenceTime);
   asn1Init_utran_GANSSGenericDataList_va40ext (&pvalue->ganssGenericDataList);
}

void asn1Free_utran_UE_Positioning_GANSS_AssistanceData_va40ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AssistanceData_va40ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssGenericDataListPresent) {
      asn1Free_utran_GANSSGenericDataList_va40ext (pctxt, &pvalue->ganssGenericDataList);
   }
}

static const OSEnumItem utran_DopplerUncertaintyExt_ENUMTAB[] = {
   { OSUTF8("hz300"), 0, 5, 0 },
   { OSUTF8("hz400"), 1, 5, 1 },
   { OSUTF8("hz500"), 2, 5, 2 },
   { OSUTF8("hz600"), 3, 5, 3 },
   { OSUTF8("noInformation"), 4, 13, 4 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define utran_DopplerUncertaintyExt_ENUMTABSIZE 8

const OSUTF8CHAR* utran_DopplerUncertaintyExt_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DopplerUncertaintyExt_ENUMTABSIZE) {
      return utran_DopplerUncertaintyExt_ENUMTAB
         [utran_DopplerUncertaintyExt_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DopplerUncertaintyExt_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DopplerUncertaintyExt* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DopplerUncertaintyExt_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DopplerUncertaintyExt_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DopplerUncertaintyExt* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DopplerUncertaintyExt_ENUMTAB, 
      utran_DopplerUncertaintyExt_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DopplerUncertaintyExt)
         utran_DopplerUncertaintyExt_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AcquisitionSatInfo_vc50ext (
   utran_AcquisitionSatInfo_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_AcquisitionSatInfoList_vc50ext (
   utran_AcquisitionSatInfoList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AcquisitionSatInfoList_vc50ext (OSCTXT *pctxt, 
   utran_AcquisitionSatInfoList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext (
   utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AcquisitionSatInfoList_vc50ext (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AcquisitionSatInfoList_vc50ext (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_UE_Positioning_GPS_AssistanceData_vc50ext (
   utran_UE_Positioning_GPS_AssistanceData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext (&pvalue->ue_positioning_GPS_AcquisitionAssistance);
}

void asn1Free_utran_UE_Positioning_GPS_AssistanceData_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GPS_AssistanceData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ue_positioning_GPS_AcquisitionAssistancePresent) {
      asn1Free_utran_UE_Positioning_GPS_AcquisitionAssistance_vc50ext (pctxt, &pvalue->ue_positioning_GPS_AcquisitionAssistance);
   }
}

void asn1Init_utran_DBDS_SignalInfo (utran_DBDS_SignalInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->bds_ECC_DeltaT.numbits = 0;
}

void asn1Init_utran_DBDS_SignalInfoList (utran_DBDS_SignalInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DBDS_SignalInfoList (OSCTXT *pctxt, 
   utran_DBDS_SignalInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DBDS_Info (utran_DBDS_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DBDS_SignalInfoList (&pvalue->dbds_SignalInfoList);
}

void asn1Free_utran_DBDS_Info (OSCTXT *pctxt, utran_DBDS_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DBDS_SignalInfoList (pctxt, &pvalue->dbds_SignalInfoList);
}

void asn1Init_utran_DBDS_InfoList (utran_DBDS_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DBDS_InfoList (OSCTXT *pctxt, utran_DBDS_InfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DBDS_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DBDS_Info*)pnode->data;
      asn1Free_utran_DBDS_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_DBDSCorrections (
   utran_UE_Positioning_DBDSCorrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DBDS_InfoList (&pvalue->bds_DBDS_InfoList);
}

void asn1Free_utran_UE_Positioning_DBDSCorrections (OSCTXT *pctxt, 
   utran_UE_Positioning_DBDSCorrections* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DBDS_InfoList (pctxt, &pvalue->bds_DBDS_InfoList);
}

void asn1Init_utran_BDS_IGPInfoList_element (
   utran_BDS_IGPInfoList_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->bds_VerticalDelay.numbits = 0;
   pvalue->bds_GIVEI.numbits = 0;
}

void asn1Init_utran_BDS_IGPInfoList (utran_BDS_IGPInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_BDS_IGPInfoList (OSCTXT *pctxt, 
   utran_BDS_IGPInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_BDS_IonoGridModel (
   utran_UE_Positioning_BDS_IonoGridModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_BDS_IGPInfoList (&pvalue->bds_IGPInfoList);
}

void asn1Free_utran_UE_Positioning_BDS_IonoGridModel (OSCTXT *pctxt, 
   utran_UE_Positioning_BDS_IonoGridModel* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_BDS_IGPInfoList (pctxt, &pvalue->bds_IGPInfoList);
}

void asn1Init_utran_BDSclockModel (utran_BDSclockModel* pvalue)
{
   if (0 == pvalue) return;
   pvalue->bdsAODC.numbits = 0;
   pvalue->bdsToc.numbits = 0;
   pvalue->bdsa0.numbits = 0;
   pvalue->bdsa1.numbits = 0;
   pvalue->bdsa2.numbits = 0;
   pvalue->bdsTgd1.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddClockModels_vc50ext (
   utran_UE_Positioning_GANSS_AddClockModels_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_BDSclockModel (&pvalue->bdsClockModel);
}

void asn1Init_utran_NavModel_BDSKeplerianSet (
   utran_NavModel_BDSKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   pvalue->bdsAODE.numbits = 0;
   pvalue->bdsURAI.numbits = 0;
   pvalue->bdsToe.numbits = 0;
   pvalue->bdsAPowerHalf.numbits = 0;
   pvalue->bdsE.numbits = 0;
   pvalue->bdsW.numbits = 0;
   pvalue->bdsDeltaN.numbits = 0;
   pvalue->bdsM0.numbits = 0;
   pvalue->bdsOmega0.numbits = 0;
   pvalue->bdsOmegaDot.numbits = 0;
   pvalue->bdsI0.numbits = 0;
   pvalue->bdsIDot.numbits = 0;
   pvalue->bdsCuc.numbits = 0;
   pvalue->bdsCus.numbits = 0;
   pvalue->bdsCrc.numbits = 0;
   pvalue->bdsCrs.numbits = 0;
   pvalue->bdsCic.numbits = 0;
   pvalue->bdsCis.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddOrbitModels_vc50ext (
   utran_UE_Positioning_GANSS_AddOrbitModels_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_NavModel_BDSKeplerianSet (&pvalue->bdsKeplerianSet);
}

void asn1Init_utran_Ganss_Sat_Info_AddNav_vc50ext (
   utran_Ganss_Sat_Info_AddNav_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UE_Positioning_GANSS_AddClockModels_vc50ext (&pvalue->ganssClockModel);
   asn1Init_utran_UE_Positioning_GANSS_AddOrbitModels_vc50ext (&pvalue->ganssOrbitModel);
}

void asn1Init_utran_Ganss_Sat_Info_AddNavList_vc50ext (
   utran_Ganss_Sat_Info_AddNavList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_Ganss_Sat_Info_AddNavList_vc50ext (OSCTXT *pctxt, 
   utran_Ganss_Sat_Info_AddNavList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext (
   utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Ganss_Sat_Info_AddNavList_vc50ext (&pvalue->ganssSatInfoNavList);
}

void asn1Free_utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Ganss_Sat_Info_AddNavList_vc50ext (pctxt, &pvalue->ganssSatInfoNavList);
}

static const OSEnumItem utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTAB[] = {
   { OSUTF8("dopU100"), 2, 7, 2 },
   { OSUTF8("dopU120"), 3, 7, 3 },
   { OSUTF8("dopU60"), 0, 6, 0 },
   { OSUTF8("dopU80"), 1, 6, 1 },
   { OSUTF8("noInformation"), 4, 13, 4 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 },
   { OSUTF8("spare3"), 5, 6, 5 }
} ;
#define utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ExtraDopplerExtension_dopplerUncertaintyExt_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTABSIZE) {
      return utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTAB
         [utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ExtraDopplerExtension_dopplerUncertaintyExt_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_ExtraDopplerExtension_dopplerUncertaintyExt* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ExtraDopplerExtension_dopplerUncertaintyExt_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ExtraDopplerExtension_dopplerUncertaintyExt_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ExtraDopplerExtension_dopplerUncertaintyExt* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTAB, 
      utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ExtraDopplerExtension_dopplerUncertaintyExt)
         utran_ExtraDopplerExtension_dopplerUncertaintyExt_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_GANSSSatelliteInformation_vc50ext (
   utran_GANSSSatelliteInformation_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GANSSSatelliteInformationList_vc50ext (
   utran_GANSSSatelliteInformationList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSSatelliteInformationList_vc50ext (OSCTXT *pctxt, 
   utran_GANSSSatelliteInformationList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext (
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSSatelliteInformationList_vc50ext (&pvalue->satelliteInformationList);
}

void asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSSSatelliteInformationList_vc50ext (pctxt, &pvalue->satelliteInformationList);
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_BDSkp (
   utran_GANSS_SAT_Info_Almanac_BDSkp* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->bdsAlmToa.numbits = 0;
   pvalue->bdsAlmSqrtA.numbits = 0;
   pvalue->bdsAlmE.numbits = 0;
   pvalue->bdsAlmW.numbits = 0;
   pvalue->bdsAlmM0.numbits = 0;
   pvalue->bdsAlmOmega0.numbits = 0;
   pvalue->bdsAlmOmegaDot.numbits = 0;
   pvalue->bdsAlmDeltaI.numbits = 0;
   pvalue->bdsAlmA0.numbits = 0;
   pvalue->bdsAlmA1.numbits = 0;
   pvalue->bdsSvHealth.numbits = 0;
}

void asn1Init_utran_GANSS_SAT_Info_Almanac_BDSkpList (
   utran_GANSS_SAT_Info_Almanac_BDSkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSS_SAT_Info_Almanac_BDSkpList (OSCTXT *pctxt, 
   utran_GANSS_SAT_Info_Almanac_BDSkpList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ALM_BDSKeplerianSet (utran_ALM_BDSKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GANSS_SAT_Info_Almanac_BDSkpList (&pvalue->sat_info_BDSkpList);
}

void asn1Free_utran_ALM_BDSKeplerianSet (OSCTXT *pctxt, 
   utran_ALM_BDSKeplerianSet* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GANSS_SAT_Info_Almanac_BDSkpList (pctxt, &pvalue->sat_info_BDSkpList);
}

void asn1Init_utran_UE_Positioning_GANSS_Almanac_vc50ext (
   utran_UE_Positioning_GANSS_Almanac_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_ALM_BDSKeplerianSet (&pvalue->alm_keplerianBDSAlmanac);
}

void asn1Free_utran_UE_Positioning_GANSS_Almanac_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_Almanac_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.alm_keplerianBDSAlmanacPresent) {
      asn1Free_utran_ALM_BDSKeplerianSet (pctxt, &pvalue->alm_keplerianBDSAlmanac);
   }
}

void asn1Init_utran_UTCmodelSet4 (utran_UTCmodelSet4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->utcA0.numbits = 0;
   pvalue->utcA1.numbits = 0;
   pvalue->utcDeltaTls.numbits = 0;
   pvalue->utcWNlsf.numbits = 0;
   pvalue->utcDN.numbits = 0;
   pvalue->utcDeltaTlsf.numbits = 0;
}

void asn1Init_utran_UE_Positioning_GANSS_AddUTCModels_vc50ext (
   utran_UE_Positioning_GANSS_AddUTCModels_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UTCmodelSet4 (&pvalue->utcModel4);
}

void asn1Init_utran_GANSSGenericData_vc50ext (
   utran_GANSSGenericData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_Positioning_DBDSCorrections (&pvalue->uePositioningDBDSCorrections);
   asn1Init_utran_UE_Positioning_BDS_IonoGridModel (&pvalue->uePositioningBDSIonoGridModel);
   asn1Init_utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext (&pvalue->ue_positioning_GANSS_AddNavigationModels);
   asn1Init_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext (&pvalue->uePositioningGANSSReferenceMeasurementInfo);
   asn1Init_utran_UE_Positioning_GANSS_Almanac_vc50ext (&pvalue->ue_Positioning_GANSS_Almanac);
   asn1Init_utran_UE_Positioning_GANSS_AddUTCModels_vc50ext (&pvalue->ue_Positioning_GANSS_AddUTCModels);
}

void asn1Free_utran_GANSSGenericData_vc50ext (OSCTXT *pctxt, 
   utran_GANSSGenericData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.uePositioningDBDSCorrectionsPresent) {
      asn1Free_utran_UE_Positioning_DBDSCorrections (pctxt, &pvalue->uePositioningDBDSCorrections);
   }
   if (pvalue->m.uePositioningBDSIonoGridModelPresent) {
      asn1Free_utran_UE_Positioning_BDS_IonoGridModel (pctxt, &pvalue->uePositioningBDSIonoGridModel);
   }
   if (pvalue->m.ue_positioning_GANSS_AddNavigationModelsPresent) {
      asn1Free_utran_UE_Positioning_GANSS_AddNavigationModels_vc50ext (pctxt, &pvalue->ue_positioning_GANSS_AddNavigationModels);
   }
   if (pvalue->m.uePositioningGANSSReferenceMeasurementInfoPresent) {
      asn1Free_utran_UE_Positioning_GANSS_ReferenceMeasurementInfo_vc50ext (pctxt, &pvalue->uePositioningGANSSReferenceMeasurementInfo);
   }
   if (pvalue->m.ue_Positioning_GANSS_AlmanacPresent) {
      asn1Free_utran_UE_Positioning_GANSS_Almanac_vc50ext (pctxt, &pvalue->ue_Positioning_GANSS_Almanac);
   }
}

void asn1Init_utran_GANSSGenericDataList_vc50ext (
   utran_GANSSGenericDataList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_GANSSGenericDataList_vc50ext (OSCTXT *pctxt, 
   utran_GANSSGenericDataList_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_GANSSGenericData_vc50ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_GANSSGenericData_vc50ext*)pnode->data;
      asn1Free_utran_GANSSGenericData_vc50ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_Positioning_GANSS_AssistanceData_vc50ext (
   utran_UE_Positioning_GANSS_AssistanceData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_GANSSGenericDataList_vc50ext (&pvalue->ganssGenericDataList);
}

void asn1Free_utran_UE_Positioning_GANSS_AssistanceData_vc50ext (OSCTXT *pctxt, 
   utran_UE_Positioning_GANSS_AssistanceData_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ganssGenericDataListPresent) {
      asn1Free_utran_GANSSGenericDataList_vc50ext (pctxt, &pvalue->ganssGenericDataList);
   }
}

void asn1Init_utran_RAB_Identity (utran_RAB_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RAB_Identity (OSCTXT *pctxt, utran_RAB_Identity* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.gsm_MAP_RAB_Identity) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gsm_MAP_RAB_Identity);
         }
         break;

      case 2:
         if (0 != pvalue->u.ansi_41_RAB_Identity) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ansi_41_RAB_Identity);
         }
         break;

   }
}

void asn1Init_utran_NAS_Synchronisation_Indicator (
   utran_NAS_Synchronisation_Indicator* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem utran_Re_EstablishmentTimer_ENUMTAB[] = {
   { OSUTF8("useT314"), 0, 7, 0 },
   { OSUTF8("useT315"), 1, 7, 1 }
} ;
#define utran_Re_EstablishmentTimer_ENUMTABSIZE 2

const OSUTF8CHAR* utran_Re_EstablishmentTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Re_EstablishmentTimer_ENUMTABSIZE) {
      return utran_Re_EstablishmentTimer_ENUMTAB
         [utran_Re_EstablishmentTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Re_EstablishmentTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Re_EstablishmentTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Re_EstablishmentTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Re_EstablishmentTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Re_EstablishmentTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Re_EstablishmentTimer_ENUMTAB, 
      utran_Re_EstablishmentTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Re_EstablishmentTimer)
         utran_Re_EstablishmentTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RAB_Info (utran_RAB_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Identity (&pvalue->rab_Identity);
   asn1Init_utran_NAS_Synchronisation_Indicator (&pvalue->nas_Synchronisation_Indicator);
}

void asn1Free_utran_RAB_Info (OSCTXT *pctxt, utran_RAB_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
}

void asn1Init_utran_RAB_InformationList (utran_RAB_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationList (OSCTXT *pctxt, 
   utran_RAB_InformationList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_Info*)pnode->data;
      asn1Free_utran_RAB_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_NC_Mode (utran_NC_Mode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_InterRAT_TargetCellDescription_technologySpecificInfo_gsm (
   utran_InterRAT_TargetCellDescription_technologySpecificInfo_gsm* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_NC_Mode (&pvalue->ncMode);
}

void asn1Init_utran_InterRAT_TargetCellDescription_technologySpecificInfo (
   utran_InterRAT_TargetCellDescription_technologySpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_InterRAT_TargetCellDescription_technologySpecificInfo (OSCTXT *pctxt, 
   utran_InterRAT_TargetCellDescription_technologySpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.gsm) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gsm);
         }
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         break;

   }
}

void asn1Init_utran_InterRAT_TargetCellDescription (
   utran_InterRAT_TargetCellDescription* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_InterRAT_TargetCellDescription_technologySpecificInfo (&pvalue->technologySpecificInfo);
}

void asn1Free_utran_InterRAT_TargetCellDescription (OSCTXT *pctxt, 
   utran_InterRAT_TargetCellDescription* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_InterRAT_TargetCellDescription_technologySpecificInfo (pctxt, &pvalue->technologySpecificInfo);
}

void asn1Init_utran_GERAN_SystemInfoBlock (utran_GERAN_SystemInfoBlock* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_GERAN_SystemInformation (
   utran_GERAN_SystemInformation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_InterRAT_ChangeFailureCause (
   utran_InterRAT_ChangeFailureCause* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_InterRAT_ChangeFailureCause (OSCTXT *pctxt, 
   utran_InterRAT_ChangeFailureCause* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.protocolError) {
            asn1Free_utran_ProtocolErrorInformation (pctxt, pvalue->u.protocolError);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.protocolError);
         }
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         break;

   }
}

static const OSEnumItem utran_CellUpdateCause_ENUMTAB[] = {
   { OSUTF8("cellReselection"), 0, 15, 0 },
   { OSUTF8("cellUpdateCause-ext"), 7, 19, 2 },
   { OSUTF8("periodicalCellUpdate"), 1, 20, 6 },
   { OSUTF8("radiolinkFailure"), 5, 16, 7 },
   { OSUTF8("re-enteredServiceArea"), 4, 21, 4 },
   { OSUTF8("rlc-unrecoverableError"), 6, 22, 3 },
   { OSUTF8("uplinkDataTransmission"), 2, 22, 5 },
   { OSUTF8("utran-pagingResponse"), 3, 20, 1 }
} ;
#define utran_CellUpdateCause_ENUMTABSIZE 8

const OSUTF8CHAR* utran_CellUpdateCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CellUpdateCause_ENUMTABSIZE) {
      return utran_CellUpdateCause_ENUMTAB
         [utran_CellUpdateCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CellUpdateCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CellUpdateCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CellUpdateCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CellUpdateCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CellUpdateCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CellUpdateCause_ENUMTAB, utran_CellUpdateCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CellUpdateCause)
         utran_CellUpdateCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_FailureCauseWithProtErrTrId (
   utran_FailureCauseWithProtErrTrId* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_FailureCauseWithProtErr (&pvalue->failureCause);
}

void asn1Free_utran_FailureCauseWithProtErrTrId (OSCTXT *pctxt, 
   utran_FailureCauseWithProtErrTrId* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FailureCauseWithProtErr (pctxt, &pvalue->failureCause);
}

void asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity (
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.cpich_Ec_N0_RSCP) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cpich_Ec_N0_RSCP);
         }
         break;

   }
}

void asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd (
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity (&pvalue->measurementQuantity);
}

void asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd_measurementQuantity (pctxt, &pvalue->measurementQuantity);
}

void asn1Init_utran_TimeslotISCP_List (utran_TimeslotISCP_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_tdd (
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TimeslotISCP_List (&pvalue->timeslotISCP);
}

void asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo (
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_MeasuredResultsOnRACH_currentCell (
   utran_MeasuredResultsOnRACH_currentCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_MeasuredResultsOnRACH_currentCell (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH_currentCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasuredResultsOnRACH_currentCell_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_SFN_SFN_ObsTimeDifference (
   utran_SFN_SFN_ObsTimeDifference* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_MonitoredCellRACH_Result_modeSpecificInfo_fdd_measurementQuantity (
   utran_MonitoredCellRACH_Result_modeSpecificInfo_fdd_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_MonitoredCellRACH_Result_modeSpecificInfo_fdd (
   utran_MonitoredCellRACH_Result_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MonitoredCellRACH_Result_modeSpecificInfo_fdd_measurementQuantity (&pvalue->measurementQuantity);
}

void asn1Init_utran_MonitoredCellRACH_Result_modeSpecificInfo (
   utran_MonitoredCellRACH_Result_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MonitoredCellRACH_Result_modeSpecificInfo (OSCTXT *pctxt, 
   utran_MonitoredCellRACH_Result_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_MonitoredCellRACH_Result (
   utran_MonitoredCellRACH_Result* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SFN_SFN_ObsTimeDifference (&pvalue->sfn_SFN_ObsTimeDifference);
   asn1Init_utran_MonitoredCellRACH_Result_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_MonitoredCellRACH_Result (OSCTXT *pctxt, 
   utran_MonitoredCellRACH_Result* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MonitoredCellRACH_Result_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_MonitoredCellRACH_List (
   utran_MonitoredCellRACH_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MonitoredCellRACH_List (OSCTXT *pctxt, 
   utran_MonitoredCellRACH_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_MonitoredCellRACH_Result* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_MonitoredCellRACH_Result*)pnode->data;
      asn1Free_utran_MonitoredCellRACH_Result (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_MeasuredResultsOnRACH (utran_MeasuredResultsOnRACH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MeasuredResultsOnRACH_currentCell (&pvalue->currentCell);
   asn1Init_utran_MonitoredCellRACH_List (&pvalue->monitoredCells);
}

void asn1Free_utran_MeasuredResultsOnRACH (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasuredResultsOnRACH_currentCell (pctxt, &pvalue->currentCell);
   if (pvalue->m.monitoredCellsPresent) {
      asn1Free_utran_MonitoredCellRACH_List (pctxt, &pvalue->monitoredCells);
   }
}

static const OSEnumItem utran_EstablishmentCause_ENUMTAB[] = {
   { OSUTF8("callRe-establishment"), 16, 20, 9 },
   { OSUTF8("delayTolerantAccess"), 22, 19, 13 },
   { OSUTF8("detach"), 13, 6, 11 },
   { OSUTF8("emergencyCall"), 9, 13, 8 },
   { OSUTF8("interRAT-CellChangeOrder"), 11, 24, 14 },
   { OSUTF8("interRAT-CellReselection"), 10, 24, 27 },
   { OSUTF8("mbms-PTP-RB-Request"), 21, 19, 31 },
   { OSUTF8("mbms-Reception"), 20, 14, 29 },
   { OSUTF8("originatingBackgroundCall"), 3, 25, 25 },
   { OSUTF8("originatingConversationalCall"), 0, 29, 3 },
   { OSUTF8("originatingHighPrioritySignalling"), 14, 33, 5 },
   { OSUTF8("originatingInteractiveCall"), 2, 26, 4 },
   { OSUTF8("originatingLowPrioritySignalling"), 15, 32, 15 },
   { OSUTF8("originatingStreamingCall"), 1, 24, 2 },
   { OSUTF8("originatingSubscribedTrafficCall"), 4, 32, 10 },
   { OSUTF8("registration"), 12, 12, 12 },
   { OSUTF8("spare1"), 31, 6, 0 },
   { OSUTF8("spare2"), 30, 6, 28 },
   { OSUTF8("spare3"), 29, 6, 30 },
   { OSUTF8("spare4"), 28, 6, 26 },
   { OSUTF8("spare5"), 27, 6, 7 },
   { OSUTF8("spare6"), 26, 6, 6 },
   { OSUTF8("spare7"), 25, 6, 1 },
   { OSUTF8("spare8"), 24, 6, 24 },
   { OSUTF8("spare9"), 23, 6, 23 },
   { OSUTF8("terminatingBackgroundCall"), 8, 25, 22 },
   { OSUTF8("terminatingCauseUnknown"), 19, 23, 21 },
   { OSUTF8("terminatingConversationalCall"), 5, 29, 20 },
   { OSUTF8("terminatingHighPrioritySignalling"), 17, 33, 19 },
   { OSUTF8("terminatingInteractiveCall"), 7, 26, 18 },
   { OSUTF8("terminatingLowPrioritySignalling"), 18, 32, 17 },
   { OSUTF8("terminatingStreamingCall"), 6, 24, 16 }
} ;
#define utran_EstablishmentCause_ENUMTABSIZE 32

const OSUTF8CHAR* utran_EstablishmentCause_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EstablishmentCause_ENUMTABSIZE) {
      return utran_EstablishmentCause_ENUMTAB
         [utran_EstablishmentCause_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EstablishmentCause_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_EstablishmentCause* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EstablishmentCause_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EstablishmentCause_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_EstablishmentCause* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EstablishmentCause_ENUMTAB, utran_EstablishmentCause_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EstablishmentCause)
         utran_EstablishmentCause_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_CellUpdateCause_ext_ENUMTAB[] = {
   { OSUTF8("dummy"), 2, 5, 2 },
   { OSUTF8("mbms-PTP-RB-Request"), 1, 19, 1 },
   { OSUTF8("mbms-Reception"), 0, 14, 0 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_CellUpdateCause_ext_ENUMTABSIZE 4

const OSUTF8CHAR* utran_CellUpdateCause_ext_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CellUpdateCause_ext_ENUMTABSIZE) {
      return utran_CellUpdateCause_ext_ENUMTAB
         [utran_CellUpdateCause_ext_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CellUpdateCause_ext_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CellUpdateCause_ext* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CellUpdateCause_ext_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CellUpdateCause_ext_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_CellUpdateCause_ext* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CellUpdateCause_ext_ENUMTAB, 
      utran_CellUpdateCause_ext_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CellUpdateCause_ext)
         utran_CellUpdateCause_ext_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_InterFreqRACHRepCellsList (
   utran_InterFreqRACHRepCellsList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_MeasuredResultsOnRACHinterFreq (
   utran_MeasuredResultsOnRACHinterFreq* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_InterFreqRACHRepCellsList (&pvalue->interFreqRACHRepCellsList);
}

void asn1Init_utran_MBMS_SelectedServicesListShort (
   utran_MBMS_SelectedServicesListShort* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_MBMS_SelectedServicesShort (
   utran_MBMS_SelectedServicesShort* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MBMS_SelectedServicesListShort (&pvalue->mbms_SelectedServicesList);
}

static const OSEnumItem utran_High_MobilityDetected_ENUMTAB[] = {
   { OSUTF8("high-MobilityDetected"), 0, 21, 0 }
} ;
#define utran_High_MobilityDetected_ENUMTABSIZE 1

const OSUTF8CHAR* utran_High_MobilityDetected_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_High_MobilityDetected_ENUMTAB, 
      utran_High_MobilityDetected_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_High_MobilityDetected_ENUMTABSIZE) {
      return utran_High_MobilityDetected_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_High_MobilityDetected_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_High_MobilityDetected* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_High_MobilityDetected_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_High_MobilityDetected_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_High_MobilityDetected* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_High_MobilityDetected_ENUMTAB, 
      utran_High_MobilityDetected_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_High_MobilityDetected)
         utran_High_MobilityDetected_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MeasuredResultsOnRACH_EUTRAFreq (
   utran_MeasuredResultsOnRACH_EUTRAFreq* pvalue)
{
   if (0 == pvalue) return;
   pvalue->eutraFrequencyIndicator.numbits = 0;
}

void asn1Init_utran_InterFreqRACHRepCellsList_r12 (
   utran_InterFreqRACHRepCellsList_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_MeasuredResultsOnRACHinterFreq_vc50ext (
   utran_MeasuredResultsOnRACHinterFreq_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_InterFreqRACHRepCellsList_r12 (&pvalue->interFreqRACHRepCellsList);
}

void asn1Init_utran_MeasuredResultsOnRACH_EUTRAFreq_vc50ext (
   utran_MeasuredResultsOnRACH_EUTRAFreq_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->eutraFrequencyIndicator.numbits = 0;
}

void asn1Init_utran_MeasuredResultsOnRACH_vc50ext (
   utran_MeasuredResultsOnRACH_vc50ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MeasuredResultsOnRACHinterFreq_vc50ext (&pvalue->measuredResultsNonUsedFreq);
   asn1Init_utran_MeasuredResultsOnRACH_EUTRAFreq_vc50ext (&pvalue->measuredResultsEUTRAFreq);
}

void asn1Init_utran_DeltaRSCPPerCell (utran_DeltaRSCPPerCell* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MonitoredCellRACH_List_v7g0ext (
   utran_MonitoredCellRACH_List_v7g0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MonitoredCellRACH_List_v7g0ext (OSCTXT *pctxt, 
   utran_MonitoredCellRACH_List_v7g0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MeasuredResultsOnRACH_v7g0ext (
   utran_MeasuredResultsOnRACH_v7g0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DeltaRSCPPerCell (&pvalue->currentCell_DeltaRSCP);
   asn1Init_utran_MonitoredCellRACH_List_v7g0ext (&pvalue->monitoredCellRACH_List_v7g0ext);
}

void asn1Free_utran_MeasuredResultsOnRACH_v7g0ext (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACH_v7g0ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.monitoredCellRACH_List_v7g0extPresent) {
      asn1Free_utran_MonitoredCellRACH_List_v7g0ext (pctxt, &pvalue->monitoredCellRACH_List_v7g0ext);
   }
}

void asn1Init_utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity (
   utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.cpich_Ec_N0_RSCP) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cpich_Ec_N0_RSCP);
         }
         break;

   }
}

void asn1Init_utran_MeasuredResultsOnRACHFDD_r11_currentCell (
   utran_MeasuredResultsOnRACHFDD_r11_currentCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity (&pvalue->measurementQuantity);
}

void asn1Free_utran_MeasuredResultsOnRACHFDD_r11_currentCell (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACHFDD_r11_currentCell* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasuredResultsOnRACHFDD_r11_currentCell_measurementQuantity (pctxt, &pvalue->measurementQuantity);
}

void asn1Init_utran_MonitoredCellRACH_ResultFDD_r11_measurementQuantity (
   utran_MonitoredCellRACH_ResultFDD_r11_measurementQuantity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_MonitoredCellRACH_ResultFDD_r11 (
   utran_MonitoredCellRACH_ResultFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SFN_SFN_ObsTimeDifference (&pvalue->sfn_SFN_ObsTimeDifference);
   asn1Init_utran_MonitoredCellRACH_ResultFDD_r11_measurementQuantity (&pvalue->measurementQuantity);
}

void asn1Init_utran_MonitoredCellRACH_ListFDD_r11 (
   utran_MonitoredCellRACH_ListFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MonitoredCellRACH_ListFDD_r11 (OSCTXT *pctxt, 
   utran_MonitoredCellRACH_ListFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MeasuredResultsOnRACHFDD_r11 (
   utran_MeasuredResultsOnRACHFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MeasuredResultsOnRACHFDD_r11_currentCell (&pvalue->currentCell);
   asn1Init_utran_MonitoredCellRACH_ListFDD_r11 (&pvalue->measuredResultsUsedFreq);
   asn1Init_utran_MeasuredResultsOnRACHinterFreq (&pvalue->measuredResultsNonUsedFreq);
   asn1Init_utran_MeasuredResultsOnRACH_EUTRAFreq (&pvalue->measuredResultsEUTRAFreq);
}

void asn1Free_utran_MeasuredResultsOnRACHFDD_r11 (OSCTXT *pctxt, 
   utran_MeasuredResultsOnRACHFDD_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasuredResultsOnRACHFDD_r11_currentCell (pctxt, &pvalue->currentCell);
   if (pvalue->m.measuredResultsUsedFreqPresent) {
      asn1Free_utran_MonitoredCellRACH_ListFDD_r11 (pctxt, &pvalue->measuredResultsUsedFreq);
   }
}

void asn1Init_utran_C_RNTI (utran_C_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem utran_RRC_StateIndicator_ENUMTAB[] = {
   { OSUTF8("cell-DCH"), 0, 8, 0 },
   { OSUTF8("cell-FACH"), 1, 9, 1 },
   { OSUTF8("cell-PCH"), 2, 8, 2 },
   { OSUTF8("ura-PCH"), 3, 7, 3 }
} ;
#define utran_RRC_StateIndicator_ENUMTABSIZE 4

const OSUTF8CHAR* utran_RRC_StateIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RRC_StateIndicator_ENUMTABSIZE) {
      return utran_RRC_StateIndicator_ENUMTAB
         [utran_RRC_StateIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RRC_StateIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RRC_StateIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RRC_StateIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RRC_StateIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_RRC_StateIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RRC_StateIndicator_ENUMTAB, utran_RRC_StateIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RRC_StateIndicator)
         utran_RRC_StateIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_URA_Identity (utran_URA_Identity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_RB_InformationReleaseList (
   utran_RB_InformationReleaseList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_MaxPDCP_SN_WindowSize_ENUMTAB[] = {
   { OSUTF8("sn255"), 0, 5, 0 },
   { OSUTF8("sn65535"), 1, 7, 1 }
} ;
#define utran_MaxPDCP_SN_WindowSize_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MaxPDCP_SN_WindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MaxPDCP_SN_WindowSize_ENUMTABSIZE) {
      return utran_MaxPDCP_SN_WindowSize_ENUMTAB
         [utran_MaxPDCP_SN_WindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MaxPDCP_SN_WindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MaxPDCP_SN_WindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MaxPDCP_SN_WindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MaxPDCP_SN_WindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MaxPDCP_SN_WindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MaxPDCP_SN_WindowSize_ENUMTAB, 
      utran_MaxPDCP_SN_WindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MaxPDCP_SN_WindowSize)
         utran_MaxPDCP_SN_WindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_LosslessSRNS_RelocSupport (
   utran_LosslessSRNS_RelocSupport* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_PDCP_PDU_Header_ENUMTAB[] = {
   { OSUTF8("absent"), 1, 6, 1 },
   { OSUTF8("present"), 0, 7, 0 }
} ;
#define utran_PDCP_PDU_Header_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PDCP_PDU_Header_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PDCP_PDU_Header_ENUMTABSIZE) {
      return utran_PDCP_PDU_Header_ENUMTAB
         [utran_PDCP_PDU_Header_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PDCP_PDU_Header_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PDCP_PDU_Header* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PDCP_PDU_Header_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PDCP_PDU_Header_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PDCP_PDU_Header* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PDCP_PDU_Header_ENUMTAB, utran_PDCP_PDU_Header_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PDCP_PDU_Header)
         utran_PDCP_PDU_Header_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_ExpectReordering_ENUMTAB[] = {
   { OSUTF8("reorderingExpected"), 1, 18, 1 },
   { OSUTF8("reorderingNotExpected"), 0, 21, 0 }
} ;
#define utran_ExpectReordering_ENUMTABSIZE 2

const OSUTF8CHAR* utran_ExpectReordering_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ExpectReordering_ENUMTABSIZE) {
      return utran_ExpectReordering_ENUMTAB
         [utran_ExpectReordering_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ExpectReordering_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ExpectReordering* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ExpectReordering_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ExpectReordering_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ExpectReordering* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ExpectReordering_ENUMTAB, utran_ExpectReordering_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ExpectReordering)
         utran_ExpectReordering_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RFC2507_Info (utran_RFC2507_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->f_MAX_PERIOD = 256;
   pvalue->f_MAX_TIME = 5;
   pvalue->max_HEADER = 168;
   pvalue->tcp_SPACE = 15;
   pvalue->non_TCP_SPACE = 15;
}

void asn1Init_utran_AlgorithmSpecificInfo (utran_AlgorithmSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_AlgorithmSpecificInfo (OSCTXT *pctxt, 
   utran_AlgorithmSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rfc2507_Info) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rfc2507_Info);
         }
         break;

   }
}

void asn1Init_utran_HeaderCompressionInfo (utran_HeaderCompressionInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_AlgorithmSpecificInfo (&pvalue->algorithmSpecificInfo);
}

void asn1Free_utran_HeaderCompressionInfo (OSCTXT *pctxt, 
   utran_HeaderCompressionInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AlgorithmSpecificInfo (pctxt, &pvalue->algorithmSpecificInfo);
}

void asn1Init_utran_HeaderCompressionInfoList (
   utran_HeaderCompressionInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HeaderCompressionInfoList (OSCTXT *pctxt, 
   utran_HeaderCompressionInfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_HeaderCompressionInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HeaderCompressionInfo*)pnode->data;
      asn1Free_utran_HeaderCompressionInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_PDCP_Info (utran_PDCP_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_LosslessSRNS_RelocSupport (&pvalue->losslessSRNS_RelocSupport);
   asn1Init_utran_HeaderCompressionInfoList (&pvalue->headerCompressionInfoList);
}

void asn1Free_utran_PDCP_Info (OSCTXT *pctxt, utran_PDCP_Info* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerCompressionInfoListPresent) {
      asn1Free_utran_HeaderCompressionInfoList (pctxt, &pvalue->headerCompressionInfoList);
   }
}

void asn1Init_utran_PDCP_InfoReconfig (utran_PDCP_InfoReconfig* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PDCP_Info (&pvalue->pdcp_Info);
}

void asn1Free_utran_PDCP_InfoReconfig (OSCTXT *pctxt, 
   utran_PDCP_InfoReconfig* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PDCP_Info (pctxt, &pvalue->pdcp_Info);
}

static const OSEnumItem utran_TimerMRW_ENUMTAB[] = {
   { OSUTF8("te100"), 5, 5, 8 },
   { OSUTF8("te120"), 6, 5, 10 },
   { OSUTF8("te140"), 7, 5, 11 },
   { OSUTF8("te160"), 8, 5, 13 },
   { OSUTF8("te180"), 9, 5, 14 },
   { OSUTF8("te200"), 10, 5, 0 },
   { OSUTF8("te300"), 11, 5, 1 },
   { OSUTF8("te400"), 12, 5, 2 },
   { OSUTF8("te50"), 0, 4, 3 },
   { OSUTF8("te500"), 13, 5, 4 },
   { OSUTF8("te60"), 1, 4, 5 },
   { OSUTF8("te70"), 2, 4, 6 },
   { OSUTF8("te700"), 14, 5, 7 },
   { OSUTF8("te80"), 3, 4, 9 },
   { OSUTF8("te90"), 4, 4, 12 },
   { OSUTF8("te900"), 15, 5, 15 }
} ;
#define utran_TimerMRW_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TimerMRW_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerMRW_ENUMTABSIZE) {
      return utran_TimerMRW_ENUMTAB
         [utran_TimerMRW_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerMRW_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerMRW* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerMRW_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerMRW_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerMRW* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimerMRW_ENUMTAB, 
      utran_TimerMRW_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerMRW)utran_TimerMRW_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerDiscard_ENUMTAB[] = {
   { OSUTF8("td0-1"), 0, 5, 0 },
   { OSUTF8("td0-25"), 1, 6, 1 },
   { OSUTF8("td0-5"), 2, 5, 2 },
   { OSUTF8("td0-75"), 3, 6, 3 },
   { OSUTF8("td1"), 4, 3, 4 },
   { OSUTF8("td1-25"), 5, 6, 5 },
   { OSUTF8("td1-5"), 6, 5, 6 },
   { OSUTF8("td1-75"), 7, 6, 7 },
   { OSUTF8("td2"), 8, 3, 8 },
   { OSUTF8("td2-5"), 9, 5, 9 },
   { OSUTF8("td3"), 10, 3, 10 },
   { OSUTF8("td3-5"), 11, 5, 11 },
   { OSUTF8("td4"), 12, 3, 12 },
   { OSUTF8("td4-5"), 13, 5, 13 },
   { OSUTF8("td5"), 14, 3, 14 },
   { OSUTF8("td7-5"), 15, 5, 15 }
} ;
#define utran_TimerDiscard_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TimerDiscard_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerDiscard_ENUMTABSIZE) {
      return utran_TimerDiscard_ENUMTAB
         [utran_TimerDiscard_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerDiscard_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerDiscard* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerDiscard_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerDiscard_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerDiscard* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimerDiscard_ENUMTAB, 
      utran_TimerDiscard_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerDiscard)utran_TimerDiscard_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MaxMRW_ENUMTAB[] = {
   { OSUTF8("mm1"), 0, 3, 0 },
   { OSUTF8("mm12"), 4, 4, 5 },
   { OSUTF8("mm16"), 5, 4, 6 },
   { OSUTF8("mm24"), 6, 4, 7 },
   { OSUTF8("mm32"), 7, 4, 1 },
   { OSUTF8("mm4"), 1, 3, 2 },
   { OSUTF8("mm6"), 2, 3, 3 },
   { OSUTF8("mm8"), 3, 3, 4 }
} ;
#define utran_MaxMRW_ENUMTABSIZE 8

const OSUTF8CHAR* utran_MaxMRW_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MaxMRW_ENUMTABSIZE) {
      return utran_MaxMRW_ENUMTAB[utran_MaxMRW_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MaxMRW_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MaxMRW* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MaxMRW_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MaxMRW_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MaxMRW* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MaxMRW_ENUMTAB, 
      utran_MaxMRW_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MaxMRW)utran_MaxMRW_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_NoExplicitDiscard_ENUMTAB[] = {
   { OSUTF8("dt10"), 0, 4, 0 },
   { OSUTF8("dt100"), 9, 5, 2 },
   { OSUTF8("dt20"), 1, 4, 3 },
   { OSUTF8("dt30"), 2, 4, 4 },
   { OSUTF8("dt40"), 3, 4, 5 },
   { OSUTF8("dt50"), 4, 4, 6 },
   { OSUTF8("dt60"), 5, 4, 7 },
   { OSUTF8("dt70"), 6, 4, 8 },
   { OSUTF8("dt80"), 7, 4, 9 },
   { OSUTF8("dt90"), 8, 4, 1 }
} ;
#define utran_NoExplicitDiscard_ENUMTABSIZE 10

const OSUTF8CHAR* utran_NoExplicitDiscard_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_NoExplicitDiscard_ENUMTABSIZE) {
      return utran_NoExplicitDiscard_ENUMTAB
         [utran_NoExplicitDiscard_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_NoExplicitDiscard_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_NoExplicitDiscard* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_NoExplicitDiscard_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_NoExplicitDiscard_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_NoExplicitDiscard* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_NoExplicitDiscard_ENUMTAB, utran_NoExplicitDiscard_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_NoExplicitDiscard)
         utran_NoExplicitDiscard_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MaxDAT_ENUMTAB[] = {
   { OSUTF8("dat1"), 0, 4, 0 },
   { OSUTF8("dat10"), 9, 5, 3 },
   { OSUTF8("dat15"), 10, 5, 6 },
   { OSUTF8("dat2"), 1, 4, 9 },
   { OSUTF8("dat20"), 11, 5, 11 },
   { OSUTF8("dat25"), 12, 5, 12 },
   { OSUTF8("dat3"), 2, 4, 13 },
   { OSUTF8("dat30"), 13, 5, 14 },
   { OSUTF8("dat35"), 14, 5, 15 },
   { OSUTF8("dat4"), 3, 4, 1 },
   { OSUTF8("dat40"), 15, 5, 2 },
   { OSUTF8("dat5"), 4, 4, 4 },
   { OSUTF8("dat6"), 5, 4, 5 },
   { OSUTF8("dat7"), 6, 4, 7 },
   { OSUTF8("dat8"), 7, 4, 8 },
   { OSUTF8("dat9"), 8, 4, 10 }
} ;
#define utran_MaxDAT_ENUMTABSIZE 16

const OSUTF8CHAR* utran_MaxDAT_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MaxDAT_ENUMTABSIZE) {
      return utran_MaxDAT_ENUMTAB[utran_MaxDAT_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MaxDAT_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MaxDAT* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MaxDAT_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MaxDAT_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MaxDAT* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MaxDAT_ENUMTAB, 
      utran_MaxDAT_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MaxDAT)utran_MaxDAT_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TransmissionRLC_Discard (
   utran_TransmissionRLC_Discard* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TransmissionRLC_Discard (OSCTXT *pctxt, 
   utran_TransmissionRLC_Discard* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.timerBasedExplicit) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timerBasedExplicit);
         }
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.maxDAT_Retransmissions) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.maxDAT_Retransmissions);
         }
         break;

      case 4:
         break;

   }
}

static const OSEnumItem utran_TransmissionWindowSize_ENUMTAB[] = {
   { OSUTF8("tw1"), 0, 3, 0 },
   { OSUTF8("tw1024"), 9, 6, 15 },
   { OSUTF8("tw128"), 5, 5, 4 },
   { OSUTF8("tw1536"), 10, 6, 9 },
   { OSUTF8("tw16"), 2, 4, 13 },
   { OSUTF8("tw2047"), 11, 6, 2 },
   { OSUTF8("tw256"), 6, 5, 6 },
   { OSUTF8("tw2560"), 12, 6, 12 },
   { OSUTF8("tw3072"), 13, 6, 14 },
   { OSUTF8("tw32"), 3, 4, 1 },
   { OSUTF8("tw3584"), 14, 6, 3 },
   { OSUTF8("tw4095"), 15, 6, 5 },
   { OSUTF8("tw512"), 7, 5, 7 },
   { OSUTF8("tw64"), 4, 4, 8 },
   { OSUTF8("tw768"), 8, 5, 10 },
   { OSUTF8("tw8"), 1, 3, 11 }
} ;
#define utran_TransmissionWindowSize_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TransmissionWindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TransmissionWindowSize_ENUMTABSIZE) {
      return utran_TransmissionWindowSize_ENUMTAB
         [utran_TransmissionWindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TransmissionWindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TransmissionWindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TransmissionWindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TransmissionWindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TransmissionWindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TransmissionWindowSize_ENUMTAB, 
      utran_TransmissionWindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TransmissionWindowSize)
         utran_TransmissionWindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerRST_ENUMTAB[] = {
   { OSUTF8("tr100"), 1, 5, 9 },
   { OSUTF8("tr1000"), 15, 6, 0 },
   { OSUTF8("tr150"), 2, 5, 2 },
   { OSUTF8("tr200"), 3, 5, 3 },
   { OSUTF8("tr250"), 4, 5, 4 },
   { OSUTF8("tr300"), 5, 5, 5 },
   { OSUTF8("tr350"), 6, 5, 6 },
   { OSUTF8("tr400"), 7, 5, 7 },
   { OSUTF8("tr450"), 8, 5, 8 },
   { OSUTF8("tr50"), 0, 4, 10 },
   { OSUTF8("tr500"), 9, 5, 11 },
   { OSUTF8("tr550"), 10, 5, 12 },
   { OSUTF8("tr600"), 11, 5, 13 },
   { OSUTF8("tr700"), 12, 5, 14 },
   { OSUTF8("tr800"), 13, 5, 15 },
   { OSUTF8("tr900"), 14, 5, 1 }
} ;
#define utran_TimerRST_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TimerRST_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerRST_ENUMTABSIZE) {
      return utran_TimerRST_ENUMTAB
         [utran_TimerRST_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerRST_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerRST* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerRST_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerRST_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerRST* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimerRST_ENUMTAB, 
      utran_TimerRST_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerRST)utran_TimerRST_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MaxRST_ENUMTAB[] = {
   { OSUTF8("rst1"), 0, 4, 0 },
   { OSUTF8("rst12"), 4, 5, 5 },
   { OSUTF8("rst16"), 5, 5, 6 },
   { OSUTF8("rst24"), 6, 5, 7 },
   { OSUTF8("rst32"), 7, 5, 1 },
   { OSUTF8("rst4"), 1, 4, 2 },
   { OSUTF8("rst6"), 2, 4, 3 },
   { OSUTF8("rst8"), 3, 4, 4 }
} ;
#define utran_MaxRST_ENUMTABSIZE 8

const OSUTF8CHAR* utran_MaxRST_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MaxRST_ENUMTABSIZE) {
      return utran_MaxRST_ENUMTAB[utran_MaxRST_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MaxRST_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MaxRST* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MaxRST_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MaxRST_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MaxRST* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MaxRST_ENUMTAB, 
      utran_MaxRST_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MaxRST)utran_MaxRST_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerPollProhibit_ENUMTAB[] = {
   { OSUTF8("tpp10"), 0, 5, 0 },
   { OSUTF8("tpp100"), 9, 6, 12 },
   { OSUTF8("tpp1000"), 63, 7, 23 },
   { OSUTF8("tpp110"), 10, 6, 34 },
   { OSUTF8("tpp120"), 11, 6, 45 },
   { OSUTF8("tpp130"), 12, 6, 52 },
   { OSUTF8("tpp140"), 13, 6, 55 },
   { OSUTF8("tpp150"), 14, 6, 58 },
   { OSUTF8("tpp160"), 15, 6, 61 },
   { OSUTF8("tpp170"), 16, 6, 1 },
   { OSUTF8("tpp180"), 17, 6, 3 },
   { OSUTF8("tpp190"), 18, 6, 4 },
   { OSUTF8("tpp20"), 1, 5, 5 },
   { OSUTF8("tpp200"), 19, 6, 6 },
   { OSUTF8("tpp210"), 20, 6, 7 },
   { OSUTF8("tpp220"), 21, 6, 8 },
   { OSUTF8("tpp230"), 22, 6, 9 },
   { OSUTF8("tpp240"), 23, 6, 10 },
   { OSUTF8("tpp250"), 24, 6, 11 },
   { OSUTF8("tpp260"), 25, 6, 13 },
   { OSUTF8("tpp270"), 26, 6, 14 },
   { OSUTF8("tpp280"), 27, 6, 15 },
   { OSUTF8("tpp290"), 28, 6, 16 },
   { OSUTF8("tpp30"), 2, 5, 17 },
   { OSUTF8("tpp300"), 29, 6, 18 },
   { OSUTF8("tpp310"), 30, 6, 19 },
   { OSUTF8("tpp320"), 31, 6, 20 },
   { OSUTF8("tpp330"), 32, 6, 21 },
   { OSUTF8("tpp340"), 33, 6, 22 },
   { OSUTF8("tpp350"), 34, 6, 24 },
   { OSUTF8("tpp360"), 35, 6, 25 },
   { OSUTF8("tpp370"), 36, 6, 26 },
   { OSUTF8("tpp380"), 37, 6, 27 },
   { OSUTF8("tpp390"), 38, 6, 28 },
   { OSUTF8("tpp40"), 3, 5, 29 },
   { OSUTF8("tpp400"), 39, 6, 30 },
   { OSUTF8("tpp410"), 40, 6, 31 },
   { OSUTF8("tpp420"), 41, 6, 32 },
   { OSUTF8("tpp430"), 42, 6, 33 },
   { OSUTF8("tpp440"), 43, 6, 35 },
   { OSUTF8("tpp450"), 44, 6, 36 },
   { OSUTF8("tpp460"), 45, 6, 37 },
   { OSUTF8("tpp470"), 46, 6, 38 },
   { OSUTF8("tpp480"), 47, 6, 39 },
   { OSUTF8("tpp490"), 48, 6, 40 },
   { OSUTF8("tpp50"), 4, 5, 41 },
   { OSUTF8("tpp500"), 49, 6, 42 },
   { OSUTF8("tpp510"), 50, 6, 43 },
   { OSUTF8("tpp520"), 51, 6, 44 },
   { OSUTF8("tpp530"), 52, 6, 46 },
   { OSUTF8("tpp540"), 53, 6, 47 },
   { OSUTF8("tpp550"), 54, 6, 48 },
   { OSUTF8("tpp60"), 5, 5, 49 },
   { OSUTF8("tpp600"), 55, 6, 50 },
   { OSUTF8("tpp650"), 56, 6, 51 },
   { OSUTF8("tpp70"), 6, 5, 53 },
   { OSUTF8("tpp700"), 57, 6, 54 },
   { OSUTF8("tpp750"), 58, 6, 56 },
   { OSUTF8("tpp80"), 7, 5, 57 },
   { OSUTF8("tpp800"), 59, 6, 59 },
   { OSUTF8("tpp850"), 60, 6, 60 },
   { OSUTF8("tpp90"), 8, 5, 62 },
   { OSUTF8("tpp900"), 61, 6, 63 },
   { OSUTF8("tpp950"), 62, 6, 2 }
} ;
#define utran_TimerPollProhibit_ENUMTABSIZE 64

const OSUTF8CHAR* utran_TimerPollProhibit_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerPollProhibit_ENUMTABSIZE) {
      return utran_TimerPollProhibit_ENUMTAB
         [utran_TimerPollProhibit_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerPollProhibit_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerPollProhibit* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerPollProhibit_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerPollProhibit_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerPollProhibit* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimerPollProhibit_ENUMTAB, utran_TimerPollProhibit_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerPollProhibit)
         utran_TimerPollProhibit_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerPoll_ENUMTAB[] = {
   { OSUTF8("tp10"), 0, 4, 0 },
   { OSUTF8("tp100"), 9, 5, 12 },
   { OSUTF8("tp1000"), 63, 6, 23 },
   { OSUTF8("tp110"), 10, 5, 34 },
   { OSUTF8("tp120"), 11, 5, 45 },
   { OSUTF8("tp130"), 12, 5, 52 },
   { OSUTF8("tp140"), 13, 5, 55 },
   { OSUTF8("tp150"), 14, 5, 58 },
   { OSUTF8("tp160"), 15, 5, 61 },
   { OSUTF8("tp170"), 16, 5, 1 },
   { OSUTF8("tp180"), 17, 5, 3 },
   { OSUTF8("tp190"), 18, 5, 4 },
   { OSUTF8("tp20"), 1, 4, 5 },
   { OSUTF8("tp200"), 19, 5, 6 },
   { OSUTF8("tp210"), 20, 5, 7 },
   { OSUTF8("tp220"), 21, 5, 8 },
   { OSUTF8("tp230"), 22, 5, 9 },
   { OSUTF8("tp240"), 23, 5, 10 },
   { OSUTF8("tp250"), 24, 5, 11 },
   { OSUTF8("tp260"), 25, 5, 13 },
   { OSUTF8("tp270"), 26, 5, 14 },
   { OSUTF8("tp280"), 27, 5, 15 },
   { OSUTF8("tp290"), 28, 5, 16 },
   { OSUTF8("tp30"), 2, 4, 17 },
   { OSUTF8("tp300"), 29, 5, 18 },
   { OSUTF8("tp310"), 30, 5, 19 },
   { OSUTF8("tp320"), 31, 5, 20 },
   { OSUTF8("tp330"), 32, 5, 21 },
   { OSUTF8("tp340"), 33, 5, 22 },
   { OSUTF8("tp350"), 34, 5, 24 },
   { OSUTF8("tp360"), 35, 5, 25 },
   { OSUTF8("tp370"), 36, 5, 26 },
   { OSUTF8("tp380"), 37, 5, 27 },
   { OSUTF8("tp390"), 38, 5, 28 },
   { OSUTF8("tp40"), 3, 4, 29 },
   { OSUTF8("tp400"), 39, 5, 30 },
   { OSUTF8("tp410"), 40, 5, 31 },
   { OSUTF8("tp420"), 41, 5, 32 },
   { OSUTF8("tp430"), 42, 5, 33 },
   { OSUTF8("tp440"), 43, 5, 35 },
   { OSUTF8("tp450"), 44, 5, 36 },
   { OSUTF8("tp460"), 45, 5, 37 },
   { OSUTF8("tp470"), 46, 5, 38 },
   { OSUTF8("tp480"), 47, 5, 39 },
   { OSUTF8("tp490"), 48, 5, 40 },
   { OSUTF8("tp50"), 4, 4, 41 },
   { OSUTF8("tp500"), 49, 5, 42 },
   { OSUTF8("tp510"), 50, 5, 43 },
   { OSUTF8("tp520"), 51, 5, 44 },
   { OSUTF8("tp530"), 52, 5, 46 },
   { OSUTF8("tp540"), 53, 5, 47 },
   { OSUTF8("tp550"), 54, 5, 48 },
   { OSUTF8("tp60"), 5, 4, 49 },
   { OSUTF8("tp600"), 55, 5, 50 },
   { OSUTF8("tp650"), 56, 5, 51 },
   { OSUTF8("tp70"), 6, 4, 53 },
   { OSUTF8("tp700"), 57, 5, 54 },
   { OSUTF8("tp750"), 58, 5, 56 },
   { OSUTF8("tp80"), 7, 4, 57 },
   { OSUTF8("tp800"), 59, 5, 59 },
   { OSUTF8("tp850"), 60, 5, 60 },
   { OSUTF8("tp90"), 8, 4, 62 },
   { OSUTF8("tp900"), 61, 5, 63 },
   { OSUTF8("tp950"), 62, 5, 2 }
} ;
#define utran_TimerPoll_ENUMTABSIZE 64

const OSUTF8CHAR* utran_TimerPoll_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerPoll_ENUMTABSIZE) {
      return utran_TimerPoll_ENUMTAB
         [utran_TimerPoll_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerPoll_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerPoll* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerPoll_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerPoll_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerPoll* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimerPoll_ENUMTAB, 
      utran_TimerPoll_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerPoll)utran_TimerPoll_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Poll_PDU_ENUMTAB[] = {
   { OSUTF8("pdu1"), 0, 4, 0 },
   { OSUTF8("pdu128"), 7, 6, 3 },
   { OSUTF8("pdu16"), 4, 5, 5 },
   { OSUTF8("pdu2"), 1, 4, 7 },
   { OSUTF8("pdu32"), 5, 5, 2 },
   { OSUTF8("pdu4"), 2, 4, 4 },
   { OSUTF8("pdu64"), 6, 5, 6 },
   { OSUTF8("pdu8"), 3, 4, 1 }
} ;
#define utran_Poll_PDU_ENUMTABSIZE 8

const OSUTF8CHAR* utran_Poll_PDU_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Poll_PDU_ENUMTABSIZE) {
      return utran_Poll_PDU_ENUMTAB
         [utran_Poll_PDU_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Poll_PDU_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Poll_PDU* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Poll_PDU_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Poll_PDU_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Poll_PDU* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_Poll_PDU_ENUMTAB, 
      utran_Poll_PDU_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Poll_PDU)utran_Poll_PDU_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_Poll_SDU_ENUMTAB[] = {
   { OSUTF8("sdu1"), 0, 4, 0 },
   { OSUTF8("sdu16"), 2, 5, 2 },
   { OSUTF8("sdu4"), 1, 4, 1 },
   { OSUTF8("sdu64"), 3, 5, 3 }
} ;
#define utran_Poll_SDU_ENUMTABSIZE 4

const OSUTF8CHAR* utran_Poll_SDU_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Poll_SDU_ENUMTABSIZE) {
      return utran_Poll_SDU_ENUMTAB
         [utran_Poll_SDU_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Poll_SDU_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Poll_SDU* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Poll_SDU_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Poll_SDU_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Poll_SDU* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_Poll_SDU_ENUMTAB, 
      utran_Poll_SDU_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Poll_SDU)utran_Poll_SDU_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PollWindow_ENUMTAB[] = {
   { OSUTF8("pw50"), 0, 4, 0 },
   { OSUTF8("pw60"), 1, 4, 1 },
   { OSUTF8("pw70"), 2, 4, 2 },
   { OSUTF8("pw80"), 3, 4, 3 },
   { OSUTF8("pw85"), 4, 4, 4 },
   { OSUTF8("pw90"), 5, 4, 5 },
   { OSUTF8("pw95"), 6, 4, 6 },
   { OSUTF8("pw99"), 7, 4, 7 }
} ;
#define utran_PollWindow_ENUMTABSIZE 8

const OSUTF8CHAR* utran_PollWindow_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PollWindow_ENUMTABSIZE) {
      return utran_PollWindow_ENUMTAB
         [utran_PollWindow_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PollWindow_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PollWindow* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PollWindow_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PollWindow_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PollWindow* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_PollWindow_ENUMTAB, 
      utran_PollWindow_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PollWindow)utran_PollWindow_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerPollPeriodic_ENUMTAB[] = {
   { OSUTF8("tper100"), 0, 7, 0 },
   { OSUTF8("tper1000"), 6, 8, 2 },
   { OSUTF8("tper200"), 1, 7, 4 },
   { OSUTF8("tper2000"), 7, 8, 5 },
   { OSUTF8("tper300"), 2, 7, 6 },
   { OSUTF8("tper400"), 3, 7, 7 },
   { OSUTF8("tper500"), 4, 7, 1 },
   { OSUTF8("tper750"), 5, 7, 3 }
} ;
#define utran_TimerPollPeriodic_ENUMTABSIZE 8

const OSUTF8CHAR* utran_TimerPollPeriodic_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerPollPeriodic_ENUMTABSIZE) {
      return utran_TimerPollPeriodic_ENUMTAB
         [utran_TimerPollPeriodic_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerPollPeriodic_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerPollPeriodic* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerPollPeriodic_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerPollPeriodic_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerPollPeriodic* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimerPollPeriodic_ENUMTAB, utran_TimerPollPeriodic_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerPollPeriodic)
         utran_TimerPollPeriodic_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PollingInfo (utran_PollingInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_AM_RLC_Mode (utran_UL_AM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TransmissionRLC_Discard (&pvalue->transmissionRLC_Discard);
   asn1Init_utran_PollingInfo (&pvalue->pollingInfo);
}

void asn1Free_utran_UL_AM_RLC_Mode (OSCTXT *pctxt, 
   utran_UL_AM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransmissionRLC_Discard (pctxt, &pvalue->transmissionRLC_Discard);
}

void asn1Init_utran_UL_UM_RLC_Mode (utran_UL_UM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TransmissionRLC_Discard (&pvalue->transmissionRLC_Discard);
}

void asn1Free_utran_UL_UM_RLC_Mode (OSCTXT *pctxt, 
   utran_UL_UM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transmissionRLC_DiscardPresent) {
      asn1Free_utran_TransmissionRLC_Discard (pctxt, &pvalue->transmissionRLC_Discard);
   }
}

void asn1Init_utran_UL_TM_RLC_Mode (utran_UL_TM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TransmissionRLC_Discard (&pvalue->transmissionRLC_Discard);
}

void asn1Free_utran_UL_TM_RLC_Mode (OSCTXT *pctxt, 
   utran_UL_TM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transmissionRLC_DiscardPresent) {
      asn1Free_utran_TransmissionRLC_Discard (pctxt, &pvalue->transmissionRLC_Discard);
   }
}

void asn1Init_utran_UL_RLC_Mode (utran_UL_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_RLC_Mode (OSCTXT *pctxt, utran_UL_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ul_AM_RLC_Mode) {
            asn1Free_utran_UL_AM_RLC_Mode (pctxt, pvalue->u.ul_AM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_AM_RLC_Mode);
         }
         break;

      case 2:
         if (0 != pvalue->u.ul_UM_RLC_Mode) {
            asn1Free_utran_UL_UM_RLC_Mode (pctxt, pvalue->u.ul_UM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_UM_RLC_Mode);
         }
         break;

      case 3:
         if (0 != pvalue->u.ul_TM_RLC_Mode) {
            asn1Free_utran_UL_TM_RLC_Mode (pctxt, pvalue->u.ul_TM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_TM_RLC_Mode);
         }
         break;

      case 4:
         break;

   }
}

static const OSEnumItem utran_ReceivingWindowSize_ENUMTAB[] = {
   { OSUTF8("rw1"), 0, 3, 0 },
   { OSUTF8("rw1024"), 9, 6, 15 },
   { OSUTF8("rw128"), 5, 5, 4 },
   { OSUTF8("rw1536"), 10, 6, 9 },
   { OSUTF8("rw16"), 2, 4, 13 },
   { OSUTF8("rw2047"), 11, 6, 2 },
   { OSUTF8("rw256"), 6, 5, 6 },
   { OSUTF8("rw2560"), 12, 6, 12 },
   { OSUTF8("rw3072"), 13, 6, 14 },
   { OSUTF8("rw32"), 3, 4, 1 },
   { OSUTF8("rw3584"), 14, 6, 3 },
   { OSUTF8("rw4095"), 15, 6, 5 },
   { OSUTF8("rw512"), 7, 5, 7 },
   { OSUTF8("rw64"), 4, 4, 8 },
   { OSUTF8("rw768"), 8, 5, 10 },
   { OSUTF8("rw8"), 1, 3, 11 }
} ;
#define utran_ReceivingWindowSize_ENUMTABSIZE 16

const OSUTF8CHAR* utran_ReceivingWindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ReceivingWindowSize_ENUMTABSIZE) {
      return utran_ReceivingWindowSize_ENUMTAB
         [utran_ReceivingWindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ReceivingWindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ReceivingWindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ReceivingWindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ReceivingWindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ReceivingWindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ReceivingWindowSize_ENUMTAB, 
      utran_ReceivingWindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ReceivingWindowSize)
         utran_ReceivingWindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerStatusProhibit_ENUMTAB[] = {
   { OSUTF8("tsp10"), 0, 5, 0 },
   { OSUTF8("tsp100"), 9, 6, 12 },
   { OSUTF8("tsp1000"), 63, 7, 23 },
   { OSUTF8("tsp110"), 10, 6, 34 },
   { OSUTF8("tsp120"), 11, 6, 45 },
   { OSUTF8("tsp130"), 12, 6, 52 },
   { OSUTF8("tsp140"), 13, 6, 55 },
   { OSUTF8("tsp150"), 14, 6, 58 },
   { OSUTF8("tsp160"), 15, 6, 61 },
   { OSUTF8("tsp170"), 16, 6, 1 },
   { OSUTF8("tsp180"), 17, 6, 3 },
   { OSUTF8("tsp190"), 18, 6, 4 },
   { OSUTF8("tsp20"), 1, 5, 5 },
   { OSUTF8("tsp200"), 19, 6, 6 },
   { OSUTF8("tsp210"), 20, 6, 7 },
   { OSUTF8("tsp220"), 21, 6, 8 },
   { OSUTF8("tsp230"), 22, 6, 9 },
   { OSUTF8("tsp240"), 23, 6, 10 },
   { OSUTF8("tsp250"), 24, 6, 11 },
   { OSUTF8("tsp260"), 25, 6, 13 },
   { OSUTF8("tsp270"), 26, 6, 14 },
   { OSUTF8("tsp280"), 27, 6, 15 },
   { OSUTF8("tsp290"), 28, 6, 16 },
   { OSUTF8("tsp30"), 2, 5, 17 },
   { OSUTF8("tsp300"), 29, 6, 18 },
   { OSUTF8("tsp310"), 30, 6, 19 },
   { OSUTF8("tsp320"), 31, 6, 20 },
   { OSUTF8("tsp330"), 32, 6, 21 },
   { OSUTF8("tsp340"), 33, 6, 22 },
   { OSUTF8("tsp350"), 34, 6, 24 },
   { OSUTF8("tsp360"), 35, 6, 25 },
   { OSUTF8("tsp370"), 36, 6, 26 },
   { OSUTF8("tsp380"), 37, 6, 27 },
   { OSUTF8("tsp390"), 38, 6, 28 },
   { OSUTF8("tsp40"), 3, 5, 29 },
   { OSUTF8("tsp400"), 39, 6, 30 },
   { OSUTF8("tsp410"), 40, 6, 31 },
   { OSUTF8("tsp420"), 41, 6, 32 },
   { OSUTF8("tsp430"), 42, 6, 33 },
   { OSUTF8("tsp440"), 43, 6, 35 },
   { OSUTF8("tsp450"), 44, 6, 36 },
   { OSUTF8("tsp460"), 45, 6, 37 },
   { OSUTF8("tsp470"), 46, 6, 38 },
   { OSUTF8("tsp480"), 47, 6, 39 },
   { OSUTF8("tsp490"), 48, 6, 40 },
   { OSUTF8("tsp50"), 4, 5, 41 },
   { OSUTF8("tsp500"), 49, 6, 42 },
   { OSUTF8("tsp510"), 50, 6, 43 },
   { OSUTF8("tsp520"), 51, 6, 44 },
   { OSUTF8("tsp530"), 52, 6, 46 },
   { OSUTF8("tsp540"), 53, 6, 47 },
   { OSUTF8("tsp550"), 54, 6, 48 },
   { OSUTF8("tsp60"), 5, 5, 49 },
   { OSUTF8("tsp600"), 55, 6, 50 },
   { OSUTF8("tsp650"), 56, 6, 51 },
   { OSUTF8("tsp70"), 6, 5, 53 },
   { OSUTF8("tsp700"), 57, 6, 54 },
   { OSUTF8("tsp750"), 58, 6, 56 },
   { OSUTF8("tsp80"), 7, 5, 57 },
   { OSUTF8("tsp800"), 59, 6, 59 },
   { OSUTF8("tsp850"), 60, 6, 60 },
   { OSUTF8("tsp90"), 8, 5, 62 },
   { OSUTF8("tsp900"), 61, 6, 63 },
   { OSUTF8("tsp950"), 62, 6, 2 }
} ;
#define utran_TimerStatusProhibit_ENUMTABSIZE 64

const OSUTF8CHAR* utran_TimerStatusProhibit_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerStatusProhibit_ENUMTABSIZE) {
      return utran_TimerStatusProhibit_ENUMTAB
         [utran_TimerStatusProhibit_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerStatusProhibit_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerStatusProhibit* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerStatusProhibit_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerStatusProhibit_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerStatusProhibit* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimerStatusProhibit_ENUMTAB, 
      utran_TimerStatusProhibit_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerStatusProhibit)
         utran_TimerStatusProhibit_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerEPC_ENUMTAB[] = {
   { OSUTF8("te100"), 5, 5, 8 },
   { OSUTF8("te120"), 6, 5, 10 },
   { OSUTF8("te140"), 7, 5, 11 },
   { OSUTF8("te160"), 8, 5, 13 },
   { OSUTF8("te180"), 9, 5, 14 },
   { OSUTF8("te200"), 10, 5, 0 },
   { OSUTF8("te300"), 11, 5, 1 },
   { OSUTF8("te400"), 12, 5, 2 },
   { OSUTF8("te50"), 0, 4, 3 },
   { OSUTF8("te500"), 13, 5, 4 },
   { OSUTF8("te60"), 1, 4, 5 },
   { OSUTF8("te70"), 2, 4, 6 },
   { OSUTF8("te700"), 14, 5, 7 },
   { OSUTF8("te80"), 3, 4, 9 },
   { OSUTF8("te90"), 4, 4, 12 },
   { OSUTF8("te900"), 15, 5, 15 }
} ;
#define utran_TimerEPC_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TimerEPC_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerEPC_ENUMTABSIZE) {
      return utran_TimerEPC_ENUMTAB
         [utran_TimerEPC_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerEPC_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerEPC* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerEPC_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerEPC_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerEPC* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimerEPC_ENUMTAB, 
      utran_TimerEPC_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerEPC)utran_TimerEPC_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_TimerStatusPeriodic_ENUMTAB[] = {
   { OSUTF8("tsp100"), 0, 6, 0 },
   { OSUTF8("tsp1000"), 6, 7, 2 },
   { OSUTF8("tsp200"), 1, 6, 4 },
   { OSUTF8("tsp2000"), 7, 7, 5 },
   { OSUTF8("tsp300"), 2, 6, 6 },
   { OSUTF8("tsp400"), 3, 6, 7 },
   { OSUTF8("tsp500"), 4, 6, 1 },
   { OSUTF8("tsp750"), 5, 6, 3 }
} ;
#define utran_TimerStatusPeriodic_ENUMTABSIZE 8

const OSUTF8CHAR* utran_TimerStatusPeriodic_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerStatusPeriodic_ENUMTABSIZE) {
      return utran_TimerStatusPeriodic_ENUMTAB
         [utran_TimerStatusPeriodic_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerStatusPeriodic_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerStatusPeriodic* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerStatusPeriodic_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerStatusPeriodic_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerStatusPeriodic* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimerStatusPeriodic_ENUMTAB, 
      utran_TimerStatusPeriodic_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerStatusPeriodic)
         utran_TimerStatusPeriodic_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_RLC_StatusInfo (utran_DL_RLC_StatusInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_AM_RLC_Mode (utran_DL_AM_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_RLC_StatusInfo (&pvalue->dl_RLC_StatusInfo);
}

void asn1Init_utran_DL_RLC_Mode (utran_DL_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_RLC_Mode (OSCTXT *pctxt, utran_DL_RLC_Mode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_AM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_AM_RLC_Mode);
         }
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.dl_TM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_TM_RLC_Mode);
         }
         break;

   }
}

void asn1Init_utran_RLC_Info (utran_RLC_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_RLC_Mode (&pvalue->ul_RLC_Mode);
   asn1Init_utran_DL_RLC_Mode (&pvalue->dl_RLC_Mode);
}

void asn1Free_utran_RLC_Info (OSCTXT *pctxt, utran_RLC_Info* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_RLC_ModePresent) {
      asn1Free_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
   }
   if (pvalue->m.dl_RLC_ModePresent) {
      asn1Free_utran_DL_RLC_Mode (pctxt, &pvalue->dl_RLC_Mode);
   }
}

void asn1Init_utran_UL_TransportChannelType (
   utran_UL_TransportChannelType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_RLC_SizeExplicitList (utran_RLC_SizeExplicitList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RLC_SizeExplicitList (OSCTXT *pctxt, 
   utran_RLC_SizeExplicitList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UL_LogicalChannelMapping_rlc_SizeList (
   utran_UL_LogicalChannelMapping_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_rlc_SizeList (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.explicitList) {
            asn1Free_utran_RLC_SizeExplicitList (pctxt, pvalue->u.explicitList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicitList);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping (
   utran_UL_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TransportChannelType (&pvalue->ul_TransportChannelType);
   asn1Init_utran_UL_LogicalChannelMapping_rlc_SizeList (&pvalue->rlc_SizeList);
}

void asn1Free_utran_UL_LogicalChannelMapping (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_rlc_SizeList (pctxt, &pvalue->rlc_SizeList);
}

void asn1Init_utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping (
   utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_LogicalChannelMapping* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_LogicalChannelMapping*)pnode->data;
      asn1Free_utran_UL_LogicalChannelMapping (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_LogicalChannelMappingList (
   utran_UL_LogicalChannelMappingList* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping (&pvalue->ul_LogicalChannelMapping);
}

void asn1Free_utran_UL_LogicalChannelMappingList (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMappingList_ul_LogicalChannelMapping (pctxt, &pvalue->ul_LogicalChannelMapping);
}

void asn1Init_utran_UL_LogicalChannelMappings (
   utran_UL_LogicalChannelMappings* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMappings (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappings* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.oneLogicalChannel) {
            asn1Free_utran_UL_LogicalChannelMapping (pctxt, pvalue->u.oneLogicalChannel);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.oneLogicalChannel);
         }
         break;

      case 2:
         if (0 != pvalue->u.twoLogicalChannels) {
            asn1Free_utran_UL_LogicalChannelMappingList (pctxt, pvalue->u.twoLogicalChannels);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.twoLogicalChannels);
         }
         break;

   }
}

void asn1Init_utran_DL_TransportChannelType (
   utran_DL_TransportChannelType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TransportChannelType (OSCTXT *pctxt, 
   utran_DL_TransportChannelType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.dch_and_dsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_and_dsch);
         }
         break;

   }
}

void asn1Init_utran_DL_LogicalChannelMapping (
   utran_DL_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TransportChannelType (&pvalue->dl_TransportChannelType);
}

void asn1Free_utran_DL_LogicalChannelMapping (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TransportChannelType (pctxt, &pvalue->dl_TransportChannelType);
}

void asn1Init_utran_DL_LogicalChannelMappingList (
   utran_DL_LogicalChannelMappingList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_LogicalChannelMappingList (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMappingList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_LogicalChannelMapping* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_LogicalChannelMapping*)pnode->data;
      asn1Free_utran_DL_LogicalChannelMapping (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_MappingOption (utran_RB_MappingOption* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_LogicalChannelMappings (&pvalue->ul_LogicalChannelMappings);
   asn1Init_utran_DL_LogicalChannelMappingList (&pvalue->dl_LogicalChannelMappingList);
}

void asn1Free_utran_RB_MappingOption (OSCTXT *pctxt, 
   utran_RB_MappingOption* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_LogicalChannelMappingsPresent) {
      asn1Free_utran_UL_LogicalChannelMappings (pctxt, &pvalue->ul_LogicalChannelMappings);
   }
   if (pvalue->m.dl_LogicalChannelMappingListPresent) {
      asn1Free_utran_DL_LogicalChannelMappingList (pctxt, &pvalue->dl_LogicalChannelMappingList);
   }
}

void asn1Init_utran_RB_MappingInfo (utran_RB_MappingInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_MappingInfo (OSCTXT *pctxt, 
   utran_RB_MappingInfo* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_MappingOption* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_MappingOption*)pnode->data;
      asn1Free_utran_RB_MappingOption (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_RB_StopContinue_ENUMTAB[] = {
   { OSUTF8("continueRB"), 1, 10, 1 },
   { OSUTF8("stopRB"), 0, 6, 0 }
} ;
#define utran_RB_StopContinue_ENUMTABSIZE 2

const OSUTF8CHAR* utran_RB_StopContinue_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RB_StopContinue_ENUMTABSIZE) {
      return utran_RB_StopContinue_ENUMTAB
         [utran_RB_StopContinue_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RB_StopContinue_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RB_StopContinue* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RB_StopContinue_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RB_StopContinue_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_RB_StopContinue* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RB_StopContinue_ENUMTAB, utran_RB_StopContinue_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RB_StopContinue)
         utran_RB_StopContinue_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RB_InformationReconfig (
   utran_RB_InformationReconfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig (OSCTXT *pctxt, 
   utran_RB_InformationReconfig* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList (
   utran_RB_InformationReconfigList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig*)pnode->data;
      asn1Free_utran_RB_InformationReconfig (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationAffected (
   utran_RB_InformationAffected* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationAffected (OSCTXT *pctxt, 
   utran_RB_InformationAffected* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationAffectedList (
   utran_RB_InformationAffectedList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationAffectedList (OSCTXT *pctxt, 
   utran_RB_InformationAffectedList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationAffected* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationAffected*)pnode->data;
      asn1Free_utran_RB_InformationAffected (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_AllowedTFC_List (utran_AllowedTFC_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_Non_allowedTFC_List (utran_Non_allowedTFC_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_UL_TrCH_Type_ENUMTAB[] = {
   { OSUTF8("dch"), 0, 3, 0 },
   { OSUTF8("usch"), 1, 4, 1 }
} ;
#define utran_UL_TrCH_Type_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_TrCH_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_TrCH_Type_ENUMTABSIZE) {
      return utran_UL_TrCH_Type_ENUMTAB
         [utran_UL_TrCH_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_TrCH_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_TrCH_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_TrCH_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_TrCH_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UL_TrCH_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UL_TrCH_Type_ENUMTAB, 
      utran_UL_TrCH_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_TrCH_Type)utran_UL_TrCH_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AllowedTFI_List (utran_AllowedTFI_List* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_RestrictedTrChInfo (utran_RestrictedTrChInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AllowedTFI_List (&pvalue->allowedTFI_List);
}

void asn1Init_utran_RestrictedTrChInfoList (
   utran_RestrictedTrChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RestrictedTrChInfoList (OSCTXT *pctxt, 
   utran_RestrictedTrChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_TFC_Subset (utran_TFC_Subset* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFC_Subset (OSCTXT *pctxt, utran_TFC_Subset* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.allowedTFC_List) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.allowedTFC_List);
         }
         break;

      case 3:
         if (0 != pvalue->u.non_allowedTFC_List) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.non_allowedTFC_List);
         }
         break;

      case 4:
         if (0 != pvalue->u.restrictedTrChInfoList) {
            asn1Free_utran_RestrictedTrChInfoList (pctxt, pvalue->u.restrictedTrChInfoList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.restrictedTrChInfoList);
         }
         break;

      case 5:
         break;

   }
}

void asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (
   utran_UL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS (&pvalue->ul_TFCS);
}

void asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS (pctxt, &pvalue->ul_TFCS);
}

void asn1Init_utran_IndividualUL_CCTrCH_Info (
   utran_IndividualUL_CCTrCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_Identity (&pvalue->ul_TFCS_Identity);
   asn1Init_utran_TFCS (&pvalue->ul_TFCS);
   asn1Init_utran_TFC_Subset (&pvalue->tfc_Subset);
}

void asn1Free_utran_IndividualUL_CCTrCH_Info (OSCTXT *pctxt, 
   utran_IndividualUL_CCTrCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS (pctxt, &pvalue->ul_TFCS);
   asn1Free_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
}

void asn1Init_utran_IndividualUL_CCTrCH_InfoList (
   utran_IndividualUL_CCTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_IndividualUL_CCTrCH_InfoList (OSCTXT *pctxt, 
   utran_IndividualUL_CCTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_IndividualUL_CCTrCH_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_IndividualUL_CCTrCH_Info*)pnode->data;
      asn1Free_utran_IndividualUL_CCTrCH_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (
   utran_UL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IndividualUL_CCTrCH_InfoList (&pvalue->individualUL_CCTrCH_InfoList);
}

void asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.individualUL_CCTrCH_InfoListPresent) {
      asn1Free_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo (
   utran_UL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_CommonTransChInfo (utran_UL_CommonTransChInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFC_Subset (&pvalue->tfc_Subset);
   asn1Init_utran_TFCS (&pvalue->prach_TFCS);
   asn1Init_utran_UL_CommonTransChInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_CommonTransChInfo (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tfc_SubsetPresent) {
      asn1Free_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
   }
   if (pvalue->m.prach_TFCSPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->prach_TFCS);
   }
   if (pvalue->m.modeSpecificInfoPresent) {
      asn1Free_utran_UL_CommonTransChInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   }
}

void asn1Init_utran_UL_DeletedTransChInfoList (
   utran_UL_DeletedTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_DeletedTransChInfoList (OSCTXT *pctxt, 
   utran_UL_DeletedTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UL_AddReconfTransChInformation (
   utran_UL_AddReconfTransChInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
}

void asn1Free_utran_UL_AddReconfTransChInformation (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
}

void asn1Init_utran_UL_AddReconfTransChInfoList (
   utran_UL_AddReconfTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_AddReconfTransChInfoList (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_AddReconfTransChInformation* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_AddReconfTransChInformation*)pnode->data;
      asn1Free_utran_UL_AddReconfTransChInformation (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DRAC_StaticInformationList (
   utran_DRAC_StaticInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DRAC_StaticInformationList (OSCTXT *pctxt, 
   utran_DRAC_StaticInformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (
   utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DCH_TFCS) {
            asn1Free_utran_TFCS (pctxt, pvalue->u.dl_DCH_TFCS);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DCH_TFCS);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (
   utran_DL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (&pvalue->dl_Parameters);
}

void asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_ParametersPresent) {
      asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd_dl_Parameters (pctxt, &pvalue->dl_Parameters);
   }
}

void asn1Init_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (
   utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (OSCTXT *pctxt, 
   utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TFCS (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsUL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsUL);
         }
         break;

   }
}

void asn1Init_utran_IndividualDL_CCTrCH_Info (
   utran_IndividualDL_CCTrCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_Identity (&pvalue->dl_TFCS_Identity);
   asn1Init_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (&pvalue->tfcs_SignallingMode);
}

void asn1Free_utran_IndividualDL_CCTrCH_Info (OSCTXT *pctxt, 
   utran_IndividualDL_CCTrCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualDL_CCTrCH_Info_tfcs_SignallingMode (pctxt, &pvalue->tfcs_SignallingMode);
}

void asn1Init_utran_IndividualDL_CCTrCH_InfoList (
   utran_IndividualDL_CCTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_IndividualDL_CCTrCH_InfoList (OSCTXT *pctxt, 
   utran_IndividualDL_CCTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_IndividualDL_CCTrCH_Info* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_IndividualDL_CCTrCH_Info*)pnode->data;
      asn1Free_utran_IndividualDL_CCTrCH_Info (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (
   utran_DL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IndividualDL_CCTrCH_InfoList (&pvalue->individualDL_CCTrCH_InfoList);
}

void asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.individualDL_CCTrCH_InfoListPresent) {
      asn1Free_utran_IndividualDL_CCTrCH_InfoList (pctxt, &pvalue->individualDL_CCTrCH_InfoList);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo (
   utran_DL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonTransChInfo (utran_DL_CommonTransChInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFCS (&pvalue->sccpch_TFCS);
   asn1Init_utran_DL_CommonTransChInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonTransChInfo (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.sccpch_TFCSPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->sccpch_TFCS);
   }
   asn1Free_utran_DL_CommonTransChInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_DL_TrCH_Type_ENUMTAB[] = {
   { OSUTF8("dch"), 0, 3, 0 },
   { OSUTF8("dsch"), 1, 4, 1 }
} ;
#define utran_DL_TrCH_Type_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_TrCH_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_TrCH_Type_ENUMTABSIZE) {
      return utran_DL_TrCH_Type_ENUMTAB
         [utran_DL_TrCH_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_TrCH_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_TrCH_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_TrCH_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_TrCH_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DL_TrCH_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_DL_TrCH_Type_ENUMTAB, 
      utran_DL_TrCH_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_TrCH_Type)utran_DL_TrCH_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_DeletedTransChInfoList (
   utran_DL_DeletedTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_DeletedTransChInfoList (OSCTXT *pctxt, 
   utran_DL_DeletedTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

   }
}

static const OSEnumItem utran_MessType_ENUMTAB[] = {
   { OSUTF8("transportFormatCombinationControl"), 0, 33, 0 }
} ;
#define utran_MessType_ENUMTABSIZE 1

const OSUTF8CHAR* utran_MessType_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, utran_MessType_ENUMTAB, 
      utran_MessType_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_MessType_ENUMTABSIZE) {
      return utran_MessType_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MessType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MessType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MessType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MessType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MessType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MessType_ENUMTAB, 
      utran_MessType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MessType)utran_MessType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_ControlledTrChList (utran_UL_ControlledTrChList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_TM_SignallingInfo_tm_SignallingMode_mode2 (
   utran_TM_SignallingInfo_tm_SignallingMode_mode2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_ControlledTrChList (&pvalue->ul_controlledTrChList);
}

void asn1Init_utran_TM_SignallingInfo_tm_SignallingMode (
   utran_TM_SignallingInfo_tm_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TM_SignallingInfo_tm_SignallingMode (OSCTXT *pctxt, 
   utran_TM_SignallingInfo_tm_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.mode2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mode2);
         }
         break;

   }
}

void asn1Init_utran_TM_SignallingInfo (utran_TM_SignallingInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TM_SignallingInfo_tm_SignallingMode (&pvalue->tm_SignallingMode);
}

void asn1Free_utran_TM_SignallingInfo (OSCTXT *pctxt, 
   utran_TM_SignallingInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TM_SignallingInfo_tm_SignallingMode (pctxt, &pvalue->tm_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInformation (
   utran_DL_AddReconfTransChInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
   asn1Init_utran_TM_SignallingInfo (&pvalue->dummy);
}

void asn1Free_utran_DL_AddReconfTransChInformation (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_TM_SignallingInfo (pctxt, &pvalue->dummy);
   }
}

void asn1Init_utran_DL_AddReconfTransChInfoList (
   utran_DL_AddReconfTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_PowerControlAlgorithm (utran_PowerControlAlgorithm* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_fdd (
   utran_UL_DPCH_PowerControlInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_IndividualTS_InterferenceList (
   utran_IndividualTS_InterferenceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_IndividualTS_InterferenceList (OSCTXT *pctxt, 
   utran_IndividualTS_InterferenceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_tdd (
   utran_UL_DPCH_PowerControlInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_OL_PC_SignallingPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo (
   utran_UL_DPCH_PowerControlInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_SpreadingFactor_ENUMTAB[] = {
   { OSUTF8("sf128"), 5, 5, 4 },
   { OSUTF8("sf16"), 2, 4, 6 },
   { OSUTF8("sf256"), 6, 5, 1 },
   { OSUTF8("sf32"), 3, 4, 3 },
   { OSUTF8("sf4"), 0, 3, 5 },
   { OSUTF8("sf64"), 4, 4, 0 },
   { OSUTF8("sf8"), 1, 3, 2 }
} ;
#define utran_SpreadingFactor_ENUMTABSIZE 7

const OSUTF8CHAR* utran_SpreadingFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SpreadingFactor_ENUMTABSIZE) {
      return utran_SpreadingFactor_ENUMTAB
         [utran_SpreadingFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SpreadingFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SpreadingFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SpreadingFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SpreadingFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SpreadingFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SpreadingFactor_ENUMTAB, utran_SpreadingFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SpreadingFactor)
         utran_SpreadingFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_DPCH_Info_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_TimingAdvanceControl_enabled (
   utran_UL_TimingAdvanceControl_enabled* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_TimingAdvanceControl (
   utran_UL_TimingAdvanceControl* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.enabled) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enabled);
         }
         break;

   }
}

static const OSEnumItem utran_UL_TS_ChannelisationCode_ENUMTAB[] = {
   { OSUTF8("cc1-1"), 0, 5, 0 },
   { OSUTF8("cc16-1"), 15, 6, 17 },
   { OSUTF8("cc16-10"), 24, 7, 18 },
   { OSUTF8("cc16-11"), 25, 7, 19 },
   { OSUTF8("cc16-12"), 26, 7, 20 },
   { OSUTF8("cc16-13"), 27, 7, 21 },
   { OSUTF8("cc16-14"), 28, 7, 22 },
   { OSUTF8("cc16-15"), 29, 7, 23 },
   { OSUTF8("cc16-16"), 30, 7, 24 },
   { OSUTF8("cc16-2"), 16, 6, 25 },
   { OSUTF8("cc16-3"), 17, 6, 26 },
   { OSUTF8("cc16-4"), 18, 6, 27 },
   { OSUTF8("cc16-5"), 19, 6, 28 },
   { OSUTF8("cc16-6"), 20, 6, 29 },
   { OSUTF8("cc16-7"), 21, 6, 30 },
   { OSUTF8("cc16-8"), 22, 6, 1 },
   { OSUTF8("cc16-9"), 23, 6, 9 },
   { OSUTF8("cc2-1"), 1, 5, 10 },
   { OSUTF8("cc2-2"), 2, 5, 11 },
   { OSUTF8("cc4-1"), 3, 5, 12 },
   { OSUTF8("cc4-2"), 4, 5, 13 },
   { OSUTF8("cc4-3"), 5, 5, 14 },
   { OSUTF8("cc4-4"), 6, 5, 15 },
   { OSUTF8("cc8-1"), 7, 5, 16 },
   { OSUTF8("cc8-2"), 8, 5, 2 },
   { OSUTF8("cc8-3"), 9, 5, 3 },
   { OSUTF8("cc8-4"), 10, 5, 4 },
   { OSUTF8("cc8-5"), 11, 5, 5 },
   { OSUTF8("cc8-6"), 12, 5, 6 },
   { OSUTF8("cc8-7"), 13, 5, 7 },
   { OSUTF8("cc8-8"), 14, 5, 8 }
} ;
#define utran_UL_TS_ChannelisationCode_ENUMTABSIZE 31

const OSUTF8CHAR* utran_UL_TS_ChannelisationCode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_TS_ChannelisationCode_ENUMTABSIZE) {
      return utran_UL_TS_ChannelisationCode_ENUMTAB
         [utran_UL_TS_ChannelisationCode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_TS_ChannelisationCode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_TS_ChannelisationCode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_TS_ChannelisationCode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_TS_ChannelisationCode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_TS_ChannelisationCode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_TS_ChannelisationCode_ENUMTAB, 
      utran_UL_TS_ChannelisationCode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_TS_ChannelisationCode)
         utran_UL_TS_ChannelisationCode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_TS_ChannelisationCodeList (
   utran_UL_TS_ChannelisationCodeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UplinkAdditionalTimeslots_parameters_newParameters (
   utran_UplinkAdditionalTimeslots_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->individualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList (&pvalue->ul_TS_ChannelisationCodeList);
}

void asn1Free_utran_UplinkAdditionalTimeslots_parameters_newParameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_UplinkAdditionalTimeslots_parameters (
   utran_UplinkAdditionalTimeslots_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkAdditionalTimeslots_parameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_UplinkAdditionalTimeslots_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_UplinkAdditionalTimeslots (
   utran_UplinkAdditionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UplinkAdditionalTimeslots_parameters (&pvalue->parameters);
}

void asn1Free_utran_UplinkAdditionalTimeslots (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UplinkAdditionalTimeslots_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (
   utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UplinkAdditionalTimeslots* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UplinkAdditionalTimeslots*)pnode->data;
      asn1Free_utran_UplinkAdditionalTimeslots (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (
   utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots (
   utran_UplinkTimeslotsCodes_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes (utran_UplinkTimeslotsCodes* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList (&pvalue->ul_TS_ChannelisationCodeList);
   asn1Init_utran_UplinkTimeslotsCodes_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_UplinkTimeslotsCodes (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_UplinkTimeslotsCodes_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_UL_CCTrCH (utran_UL_CCTrCH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_UplinkTimeslotsCodes (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH (OSCTXT *pctxt, utran_UL_CCTrCH* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_UL_CCTrCHList (utran_UL_CCTrCHList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_CCTrCHList (OSCTXT *pctxt, utran_UL_CCTrCHList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_CCTrCH* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_CCTrCH*)pnode->data;
      asn1Free_utran_UL_CCTrCH (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_CCTrCHListToRemove (utran_UL_CCTrCHListToRemove* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UL_DPCH_Info_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_modeSpecificInfo (
   utran_UL_DPCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info (utran_UL_DPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info (OSCTXT *pctxt, utran_UL_DPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_CD_AccessSlotSubchannelList (
   utran_CD_AccessSlotSubchannelList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_CD_SignatureCodeList (utran_CD_SignatureCodeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_UL_DPCCH_SlotFormat_ENUMTAB[] = {
   { OSUTF8("slf0"), 0, 4, 0 },
   { OSUTF8("slf1"), 1, 4, 1 },
   { OSUTF8("slf2"), 2, 4, 2 }
} ;
#define utran_UL_DPCCH_SlotFormat_ENUMTABSIZE 3

const OSUTF8CHAR* utran_UL_DPCCH_SlotFormat_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_DPCCH_SlotFormat_ENUMTABSIZE) {
      return utran_UL_DPCCH_SlotFormat_ENUMTAB
         [utran_UL_DPCCH_SlotFormat_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_DPCCH_SlotFormat_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_DPCCH_SlotFormat* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_DPCCH_SlotFormat_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_DPCCH_SlotFormat_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UL_DPCCH_SlotFormat* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_DPCCH_SlotFormat_ENUMTAB, 
      utran_UL_DPCCH_SlotFormat_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_DPCCH_SlotFormat)
         utran_UL_DPCCH_SlotFormat_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MinimumSpreadingFactor_ENUMTAB[] = {
   { OSUTF8("sf128"), 5, 5, 4 },
   { OSUTF8("sf16"), 2, 4, 6 },
   { OSUTF8("sf256"), 6, 5, 1 },
   { OSUTF8("sf32"), 3, 4, 3 },
   { OSUTF8("sf4"), 0, 3, 5 },
   { OSUTF8("sf64"), 4, 4, 0 },
   { OSUTF8("sf8"), 1, 3, 2 }
} ;
#define utran_MinimumSpreadingFactor_ENUMTABSIZE 7

const OSUTF8CHAR* utran_MinimumSpreadingFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MinimumSpreadingFactor_ENUMTABSIZE) {
      return utran_MinimumSpreadingFactor_ENUMTAB
         [utran_MinimumSpreadingFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MinimumSpreadingFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MinimumSpreadingFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MinimumSpreadingFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MinimumSpreadingFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MinimumSpreadingFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MinimumSpreadingFactor_ENUMTAB, 
      utran_MinimumSpreadingFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MinimumSpreadingFactor)
         utran_MinimumSpreadingFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AvailableAP_SubchannelList (
   utran_AvailableAP_SubchannelList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_AP_Signature_VCAM (utran_AP_Signature_VCAM* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AvailableAP_SubchannelList (&pvalue->availableAP_SubchannelList);
}

void asn1Init_utran_AvailableAP_Signature_VCAMList (
   utran_AvailableAP_Signature_VCAMList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AvailableAP_Signature_VCAMList (OSCTXT *pctxt, 
   utran_AvailableAP_Signature_VCAMList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AvailableMinimumSF_VCAM (
   utran_AvailableMinimumSF_VCAM* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_AvailableAP_Signature_VCAMList (&pvalue->availableAP_Signature_VCAMList);
}

void asn1Free_utran_AvailableMinimumSF_VCAM (OSCTXT *pctxt, 
   utran_AvailableMinimumSF_VCAM* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AvailableAP_Signature_VCAMList (pctxt, &pvalue->availableAP_Signature_VCAMList);
}

void asn1Init_utran_AvailableMinimumSF_ListVCAM (
   utran_AvailableMinimumSF_ListVCAM* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AvailableMinimumSF_ListVCAM (OSCTXT *pctxt, 
   utran_AvailableMinimumSF_ListVCAM* pvalue)
{
   if (0 == pvalue) return;
   { utran_AvailableMinimumSF_VCAM* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_AvailableMinimumSF_VCAM*)pnode->data;
      asn1Free_utran_AvailableMinimumSF_VCAM (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_ChannelAssignmentActive (
   utran_ChannelAssignmentActive* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ChannelAssignmentActive (OSCTXT *pctxt, 
   utran_ChannelAssignmentActive* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.isActive) {
            asn1Free_utran_AvailableMinimumSF_ListVCAM (pctxt, pvalue->u.isActive);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.isActive);
         }
         break;

   }
}

static const OSEnumItem utran_CPCH_StatusIndicationMode_ENUMTAB[] = {
   { OSUTF8("pa-mode"), 0, 7, 0 },
   { OSUTF8("pamsf-mode"), 1, 10, 1 }
} ;
#define utran_CPCH_StatusIndicationMode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CPCH_StatusIndicationMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CPCH_StatusIndicationMode_ENUMTABSIZE) {
      return utran_CPCH_StatusIndicationMode_ENUMTAB
         [utran_CPCH_StatusIndicationMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CPCH_StatusIndicationMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CPCH_StatusIndicationMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CPCH_StatusIndicationMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CPCH_StatusIndicationMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CPCH_StatusIndicationMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CPCH_StatusIndicationMode_ENUMTAB, 
      utran_CPCH_StatusIndicationMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CPCH_StatusIndicationMode)
         utran_CPCH_StatusIndicationMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PCP_Length_ENUMTAB[] = {
   { OSUTF8("as0"), 0, 3, 0 },
   { OSUTF8("as8"), 1, 3, 1 }
} ;
#define utran_PCP_Length_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PCP_Length_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PCP_Length_ENUMTABSIZE) {
      return utran_PCP_Length_ENUMTAB
         [utran_PCP_Length_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PCP_Length_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PCP_Length* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PCP_Length_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PCP_Length_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PCP_Length* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_PCP_Length_ENUMTAB, 
      utran_PCP_Length_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PCP_Length)utran_PCP_Length_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AvailableAP_SignatureList (
   utran_AvailableAP_SignatureList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_ChannelReqParamsForUCSM (
   utran_ChannelReqParamsForUCSM* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AvailableAP_SignatureList (&pvalue->availableAP_SignatureList);
   asn1Init_utran_AvailableAP_SubchannelList (&pvalue->availableAP_SubchannelList);
}

void asn1Init_utran_UCSM_Info (utran_UCSM_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_ChannelReqParamsForUCSM (&pvalue->channelReqParamsForUCSM);
}

void asn1Init_utran_PCPCH_ChannelInfo (utran_PCPCH_ChannelInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UCSM_Info (&pvalue->ucsm_Info);
}

void asn1Init_utran_PCPCH_ChannelInfoList (utran_PCPCH_ChannelInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PCPCH_ChannelInfoList (OSCTXT *pctxt, 
   utran_PCPCH_ChannelInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_CPCH_SetInfo (utran_CPCH_SetInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
   asn1Init_utran_TFCS (&pvalue->tfcs);
   asn1Init_utran_CD_AccessSlotSubchannelList (&pvalue->cd_AccessSlotSubchannelList);
   asn1Init_utran_CD_SignatureCodeList (&pvalue->cd_SignatureCodeList);
   asn1Init_utran_ChannelAssignmentActive (&pvalue->channelAssignmentActive);
   asn1Init_utran_PCPCH_ChannelInfoList (&pvalue->pcpch_ChannelInfoList);
}

void asn1Free_utran_CPCH_SetInfo (OSCTXT *pctxt, utran_CPCH_SetInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
   asn1Free_utran_TFCS (pctxt, &pvalue->tfcs);
   asn1Free_utran_ChannelAssignmentActive (pctxt, &pvalue->channelAssignmentActive);
   asn1Free_utran_PCPCH_ChannelInfoList (pctxt, &pvalue->pcpch_ChannelInfoList);
}

void asn1Init_utran_UL_ChannelRequirement (utran_UL_ChannelRequirement* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_ChannelRequirement (OSCTXT *pctxt, 
   utran_UL_ChannelRequirement* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ul_DPCH_Info) {
            asn1Free_utran_UL_DPCH_Info (pctxt, pvalue->u.ul_DPCH_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_DPCH_Info);
         }
         break;

      case 2:
         if (0 != pvalue->u.dummy) {
            asn1Free_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dummy);
         }
         break;

   }
}

void asn1Init_utran_RL_IdentifierList (utran_RL_IdentifierList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RL_IdentifierList (OSCTXT *pctxt, 
   utran_RL_IdentifierList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_PDSCH_SHO_DCH_Info (utran_PDSCH_SHO_DCH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RL_IdentifierList (&pvalue->rl_IdentifierList);
}

void asn1Free_utran_PDSCH_SHO_DCH_Info (OSCTXT *pctxt, 
   utran_PDSCH_SHO_DCH_Info* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rl_IdentifierListPresent) {
      asn1Free_utran_RL_IdentifierList (pctxt, &pvalue->rl_IdentifierList);
   }
}

static const OSEnumItem utran_SF_PDSCH_ENUMTAB[] = {
   { OSUTF8("sfp128"), 5, 6, 4 },
   { OSUTF8("sfp16"), 2, 5, 6 },
   { OSUTF8("sfp256"), 6, 6, 1 },
   { OSUTF8("sfp32"), 3, 5, 3 },
   { OSUTF8("sfp4"), 0, 4, 5 },
   { OSUTF8("sfp64"), 4, 5, 0 },
   { OSUTF8("sfp8"), 1, 4, 2 }
} ;
#define utran_SF_PDSCH_ENUMTABSIZE 7

const OSUTF8CHAR* utran_SF_PDSCH_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SF_PDSCH_ENUMTABSIZE) {
      return utran_SF_PDSCH_ENUMTAB
         [utran_SF_PDSCH_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SF_PDSCH_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SF_PDSCH* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SF_PDSCH_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SF_PDSCH_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SF_PDSCH* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SF_PDSCH_ENUMTAB, 
      utran_SF_PDSCH_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SF_PDSCH)utran_SF_PDSCH_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PDSCH_CodeMapList (utran_PDSCH_CodeMapList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PDSCH_CodeMapList (OSCTXT *pctxt, 
   utran_PDSCH_CodeMapList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_CodeRange (utran_CodeRange* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PDSCH_CodeMapList (&pvalue->pdsch_CodeMapList);
}

void asn1Free_utran_CodeRange (OSCTXT *pctxt, utran_CodeRange* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PDSCH_CodeMapList (pctxt, &pvalue->pdsch_CodeMapList);
}

void asn1Init_utran_DSCH_MappingList (utran_DSCH_MappingList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DSCH_MappingList (OSCTXT *pctxt, 
   utran_DSCH_MappingList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_PDSCH_CodeInfoList (utran_PDSCH_CodeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PDSCH_CodeInfoList (OSCTXT *pctxt, 
   utran_PDSCH_CodeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_ReplacedPDSCH_CodeInfoList (
   utran_ReplacedPDSCH_CodeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_ReplacedPDSCH_CodeInfoList (OSCTXT *pctxt, 
   utran_ReplacedPDSCH_CodeInfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_PDSCH_CodeMapping_signallingMethod (
   utran_PDSCH_CodeMapping_signallingMethod* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PDSCH_CodeMapping_signallingMethod (OSCTXT *pctxt, 
   utran_PDSCH_CodeMapping_signallingMethod* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.codeRange) {
            asn1Free_utran_CodeRange (pctxt, pvalue->u.codeRange);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.codeRange);
         }
         break;

      case 2:
         if (0 != pvalue->u.tfci_Range) {
            asn1Free_utran_DSCH_MappingList (pctxt, pvalue->u.tfci_Range);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tfci_Range);
         }
         break;

      case 3:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_PDSCH_CodeInfoList (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 4:
         if (0 != pvalue->u.replace) {
            asn1Free_utran_ReplacedPDSCH_CodeInfoList (pctxt, pvalue->u.replace);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.replace);
         }
         break;

   }
}

void asn1Init_utran_PDSCH_CodeMapping (utran_PDSCH_CodeMapping* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDSCH_CodeMapping_signallingMethod (&pvalue->signallingMethod);
}

void asn1Free_utran_PDSCH_CodeMapping (OSCTXT *pctxt, 
   utran_PDSCH_CodeMapping* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PDSCH_CodeMapping_signallingMethod (pctxt, &pvalue->signallingMethod);
}

void asn1Init_utran_DL_PDSCH_Information (utran_DL_PDSCH_Information* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDSCH_SHO_DCH_Info (&pvalue->dummy1);
   asn1Init_utran_PDSCH_CodeMapping (&pvalue->dummy2);
}

void asn1Free_utran_DL_PDSCH_Information (OSCTXT *pctxt, 
   utran_DL_PDSCH_Information* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dummy1Present) {
      asn1Free_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
   }
   if (pvalue->m.dummy2Present) {
      asn1Free_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_cfnHandling_initialise (
   utran_DL_DPCH_InfoCommon_cfnHandling_initialise* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_InfoCommon_cfnHandling (
   utran_DL_DPCH_InfoCommon_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_cfnHandling (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.initialise) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.initialise);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd (
   utran_DL_DPCH_PowerControlInfo_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (
   utran_DL_DPCH_PowerControlInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_PowerControlInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_PowerControlInfo (
   utran_DL_DPCH_PowerControlInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_DPCH_PowerControlInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_PowerControlInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_PowerControlInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_RestrictedTrCH (utran_RestrictedTrCH* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_AllowedTFI_List (&pvalue->allowedTFIList);
}

void asn1Init_utran_RestrictedTrCH_InfoList (
   utran_RestrictedTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RestrictedTrCH_InfoList (OSCTXT *pctxt, 
   utran_RestrictedTrCH_InfoList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_Dl_rate_matching_restriction (
   utran_Dl_rate_matching_restriction* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RestrictedTrCH_InfoList (&pvalue->restrictedTrCH_InfoList);
}

void asn1Free_utran_Dl_rate_matching_restriction (OSCTXT *pctxt, 
   utran_Dl_rate_matching_restriction* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.restrictedTrCH_InfoListPresent) {
      asn1Free_utran_RestrictedTrCH_InfoList (pctxt, &pvalue->restrictedTrCH_InfoList);
   }
}

static const OSEnumItem utran_PilotBits128_ENUMTAB[] = {
   { OSUTF8("pb4"), 0, 3, 0 },
   { OSUTF8("pb8"), 1, 3, 1 }
} ;
#define utran_PilotBits128_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PilotBits128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PilotBits128_ENUMTABSIZE) {
      return utran_PilotBits128_ENUMTAB
         [utran_PilotBits128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PilotBits128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PilotBits128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PilotBits128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PilotBits128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PilotBits128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_PilotBits128_ENUMTAB, 
      utran_PilotBits128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PilotBits128)utran_PilotBits128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PilotBits256_ENUMTAB[] = {
   { OSUTF8("pb2"), 0, 3, 0 },
   { OSUTF8("pb4"), 1, 3, 1 },
   { OSUTF8("pb8"), 2, 3, 2 }
} ;
#define utran_PilotBits256_ENUMTABSIZE 3

const OSUTF8CHAR* utran_PilotBits256_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PilotBits256_ENUMTABSIZE) {
      return utran_PilotBits256_ENUMTAB
         [utran_PilotBits256_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PilotBits256_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PilotBits256* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PilotBits256_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PilotBits256_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PilotBits256* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_PilotBits256_ENUMTAB, 
      utran_PilotBits256_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PilotBits256)utran_PilotBits256_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SF512_AndPilot (utran_SF512_AndPilot* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (
   utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
   asn1Init_utran_Dl_rate_matching_restriction (&pvalue->dl_rate_matching_restriction);
   asn1Init_utran_SF512_AndPilot (&pvalue->spreadingFactorAndPilot);
}

void asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
   if (pvalue->m.dl_rate_matching_restrictionPresent) {
      asn1Free_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (
   utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo (
   utran_DL_DPCH_InfoCommon_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon (utran_DL_DPCH_InfoCommon* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_DPCH_InfoCommon_cfnHandling (&pvalue->cfnHandling);
   asn1Init_utran_DL_DPCH_InfoCommon_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommon (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoCommon_cfnHandling (pctxt, &pvalue->cfnHandling);
   asn1Free_utran_DL_DPCH_InfoCommon_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_TGP_Sequence_tgps_Status (
   utran_TGP_Sequence_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TGP_Sequence_tgps_Status (OSCTXT *pctxt, 
   utran_TGP_Sequence_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.activate) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.activate);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_TGMP_ENUMTAB[] = {
   { OSUTF8("fdd-Measurement"), 1, 15, 5 },
   { OSUTF8("gsm-CarrierRSSIMeasurement"), 2, 26, 0 },
   { OSUTF8("gsm-initialBSICIdentification"), 3, 29, 1 },
   { OSUTF8("gsmBSICReconfirmation"), 4, 21, 2 },
   { OSUTF8("multi-carrier"), 5, 13, 3 },
   { OSUTF8("tdd-Measurement"), 0, 15, 4 }
} ;
#define utran_TGMP_ENUMTABSIZE 6

const OSUTF8CHAR* utran_TGMP_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TGMP_ENUMTABSIZE) {
      return utran_TGMP_ENUMTAB[utran_TGMP_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TGMP_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TGMP* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TGMP_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TGMP_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TGMP* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TGMP_ENUMTAB, 
      utran_TGMP_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TGMP)utran_TGMP_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_RPP_ENUMTAB[] = {
   { OSUTF8("mode0"), 0, 5, 0 },
   { OSUTF8("mode1"), 1, 5, 1 }
} ;
#define utran_RPP_ENUMTABSIZE 2

const OSUTF8CHAR* utran_RPP_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RPP_ENUMTABSIZE) {
      return utran_RPP_ENUMTAB[utran_RPP_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RPP_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RPP* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RPP_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RPP_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_RPP* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_RPP_ENUMTAB, 
      utran_RPP_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RPP)utran_RPP_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_ITP_ENUMTAB[] = {
   { OSUTF8("mode0"), 0, 5, 0 },
   { OSUTF8("mode1"), 1, 5, 1 }
} ;
#define utran_ITP_ENUMTABSIZE 2

const OSUTF8CHAR* utran_ITP_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ITP_ENUMTABSIZE) {
      return utran_ITP_ENUMTAB[utran_ITP_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ITP_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ITP* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ITP_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ITP_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ITP* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_ITP_ENUMTAB, 
      utran_ITP_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ITP)utran_ITP_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UL_CompressedModeMethod_ENUMTAB[] = {
   { OSUTF8("higherLayerScheduling"), 1, 21, 1 },
   { OSUTF8("sf-2"), 0, 4, 0 }
} ;
#define utran_UL_CompressedModeMethod_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_CompressedModeMethod_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_CompressedModeMethod_ENUMTABSIZE) {
      return utran_UL_CompressedModeMethod_ENUMTAB
         [utran_UL_CompressedModeMethod_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_CompressedModeMethod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_CompressedModeMethod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_CompressedModeMethod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_CompressedModeMethod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_CompressedModeMethod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_CompressedModeMethod_ENUMTAB, 
      utran_UL_CompressedModeMethod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_CompressedModeMethod)
         utran_UL_CompressedModeMethod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CompressedModeMethod_ENUMTAB[] = {
   { OSUTF8("dummy"), 0, 5, 0 },
   { OSUTF8("higherLayerScheduling"), 2, 21, 2 },
   { OSUTF8("sf-2"), 1, 4, 1 }
} ;
#define utran_DL_CompressedModeMethod_ENUMTABSIZE 3

const OSUTF8CHAR* utran_DL_CompressedModeMethod_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_CompressedModeMethod_ENUMTABSIZE) {
      return utran_DL_CompressedModeMethod_ENUMTAB
         [utran_DL_CompressedModeMethod_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CompressedModeMethod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_CompressedModeMethod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CompressedModeMethod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CompressedModeMethod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CompressedModeMethod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CompressedModeMethod_ENUMTAB, 
      utran_DL_CompressedModeMethod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CompressedModeMethod)
         utran_DL_CompressedModeMethod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_DL_Mode (utran_UL_DL_Mode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DL_Mode (OSCTXT *pctxt, utran_UL_DL_Mode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ul_and_dl) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_and_dl);
         }
         break;

   }
}

static const OSEnumItem utran_DL_FrameType_ENUMTAB[] = {
   { OSUTF8("dl-FrameTypeA"), 0, 13, 0 },
   { OSUTF8("dl-FrameTypeB"), 1, 13, 1 }
} ;
#define utran_DL_FrameType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_FrameType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_FrameType_ENUMTABSIZE) {
      return utran_DL_FrameType_ENUMTAB
         [utran_DL_FrameType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_FrameType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_FrameType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_FrameType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_FrameType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DL_FrameType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_DL_FrameType_ENUMTAB, 
      utran_DL_FrameType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_FrameType)utran_DL_FrameType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TGPS_ConfigurationParams (
   utran_TGPS_ConfigurationParams* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DL_Mode (&pvalue->ul_DL_Mode);
}

void asn1Free_utran_TGPS_ConfigurationParams (OSCTXT *pctxt, 
   utran_TGPS_ConfigurationParams* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
}

void asn1Init_utran_TGP_Sequence (utran_TGP_Sequence* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TGP_Sequence_tgps_Status (&pvalue->tgps_Status);
   asn1Init_utran_TGPS_ConfigurationParams (&pvalue->tgps_ConfigurationParams);
}

void asn1Free_utran_TGP_Sequence (OSCTXT *pctxt, utran_TGP_Sequence* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_Sequence_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (pvalue->m.tgps_ConfigurationParamsPresent) {
      asn1Free_utran_TGPS_ConfigurationParams (pctxt, &pvalue->tgps_ConfigurationParams);
   }
}

void asn1Init_utran_TGP_SequenceList (utran_TGP_SequenceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TGP_SequenceList (OSCTXT *pctxt, 
   utran_TGP_SequenceList* pvalue)
{
   if (0 == pvalue) return;
   { utran_TGP_Sequence* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TGP_Sequence*)pnode->data;
      asn1Free_utran_TGP_Sequence (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DPCH_CompressedModeInfo (
   utran_DPCH_CompressedModeInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TGP_SequenceList (&pvalue->tgp_SequenceList);
}

void asn1Free_utran_DPCH_CompressedModeInfo (OSCTXT *pctxt, 
   utran_DPCH_CompressedModeInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_SequenceList (pctxt, &pvalue->tgp_SequenceList);
}

void asn1Init_utran_DL_CommonInformation_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_CommonInformation_modeSpecificInfo (
   utran_DL_CommonInformation_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation (utran_DL_CommonInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon (&pvalue->dl_DPCH_InfoCommon);
   asn1Init_utran_DL_CommonInformation_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation (OSCTXT *pctxt, 
   utran_DL_CommonInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_InfoCommonPresent) {
      asn1Free_utran_DL_DPCH_InfoCommon (pctxt, &pvalue->dl_DPCH_InfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_modeSpecificInfo_fdd (
   utran_DL_InformationPerRL_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDSCH_SHO_DCH_Info (&pvalue->dummy1);
   asn1Init_utran_PDSCH_CodeMapping (&pvalue->dummy2);
}

void asn1Free_utran_DL_InformationPerRL_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dummy1Present) {
      asn1Free_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
   }
   if (pvalue->m.dummy2Present) {
      asn1Free_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
   }
}

void asn1Init_utran_PrimaryCCPCH_Info_tdd_syncCase (
   utran_PrimaryCCPCH_Info_tdd_syncCase* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_Info_tdd_syncCase (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_tdd_syncCase* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.syncCase1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase1);
         }
         break;

      case 2:
         if (0 != pvalue->u.syncCase2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase2);
         }
         break;

   }
}

void asn1Init_utran_PrimaryCCPCH_Info_tdd (utran_PrimaryCCPCH_Info_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PrimaryCCPCH_Info_tdd_syncCase (&pvalue->syncCase);
}

void asn1Free_utran_PrimaryCCPCH_Info_tdd (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.syncCasePresent) {
      asn1Free_utran_PrimaryCCPCH_Info_tdd_syncCase (pctxt, &pvalue->syncCase);
   }
}

void asn1Init_utran_PrimaryCCPCH_Info (utran_PrimaryCCPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_Info (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_modeSpecificInfo (
   utran_DL_InformationPerRL_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL (utran_DL_InformationPerRL* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_DPCH_InfoPerRL (&pvalue->dl_DPCH_InfoPerRL);
   asn1Init_utran_SCCPCH_InfoForFACH (&pvalue->dummy);
}

void asn1Free_utran_DL_InformationPerRL (OSCTXT *pctxt, 
   utran_DL_InformationPerRL* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_DPCH_InfoPerRLPresent) {
      asn1Free_utran_DL_DPCH_InfoPerRL (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   }
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_SCCPCH_InfoForFACH (pctxt, &pvalue->dummy);
   }
}

void asn1Init_utran_DL_InformationPerRL_List (
   utran_DL_InformationPerRL_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL*)pnode->data;
      asn1Free_utran_DL_InformationPerRL (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DSCH_RNTI (utran_DSCH_RNTI* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem utran_PDCP_ROHC_TargetMode_ENUMTAB[] = {
   { OSUTF8("o-Mode"), 0, 6, 0 },
   { OSUTF8("r-Mode"), 1, 6, 1 }
} ;
#define utran_PDCP_ROHC_TargetMode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_PDCP_ROHC_TargetMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PDCP_ROHC_TargetMode_ENUMTABSIZE) {
      return utran_PDCP_ROHC_TargetMode_ENUMTAB
         [utran_PDCP_ROHC_TargetMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PDCP_ROHC_TargetMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PDCP_ROHC_TargetMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PDCP_ROHC_TargetMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PDCP_ROHC_TargetMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PDCP_ROHC_TargetMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PDCP_ROHC_TargetMode_ENUMTAB, 
      utran_PDCP_ROHC_TargetMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PDCP_ROHC_TargetMode)
         utran_PDCP_ROHC_TargetMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_BEACON_PL_Est_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_BEACON_PL_Est_ENUMTABSIZE 1

const OSUTF8CHAR* utran_BEACON_PL_Est_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, utran_BEACON_PL_Est_ENUMTAB, 
      utran_BEACON_PL_Est_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_BEACON_PL_Est_ENUMTABSIZE) {
      return utran_BEACON_PL_Est_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_BEACON_PL_Est_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_BEACON_PL_Est* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_BEACON_PL_Est_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_BEACON_PL_Est_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_BEACON_PL_Est* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_BEACON_PL_Est_ENUMTAB, 
      utran_BEACON_PL_Est_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_BEACON_PL_Est)utran_BEACON_PL_Est_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTABSIZE 1

const OSUTF8CHAR* utran_MBMS_PL_ServiceRestrictInfo_r6_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTAB, 
      utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTABSIZE) {
      return utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MBMS_PL_ServiceRestrictInfo_r6_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MBMS_PL_ServiceRestrictInfo_r6* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MBMS_PL_ServiceRestrictInfo_r6_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MBMS_PL_ServiceRestrictInfo_r6_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MBMS_PL_ServiceRestrictInfo_r6* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTAB, 
      utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MBMS_PL_ServiceRestrictInfo_r6)
         utran_MBMS_PL_ServiceRestrictInfo_r6_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ROHC_ProfileList_r4 (utran_ROHC_ProfileList_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_CID_InclusionInfo_r4_ENUMTAB[] = {
   { OSUTF8("pdcp-Header"), 0, 11, 0 },
   { OSUTF8("rfc3095-PacketFormat"), 1, 20, 1 }
} ;
#define utran_CID_InclusionInfo_r4_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CID_InclusionInfo_r4_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CID_InclusionInfo_r4_ENUMTABSIZE) {
      return utran_CID_InclusionInfo_r4_ENUMTAB
         [utran_CID_InclusionInfo_r4_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CID_InclusionInfo_r4_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CID_InclusionInfo_r4* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CID_InclusionInfo_r4_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CID_InclusionInfo_r4_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CID_InclusionInfo_r4* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CID_InclusionInfo_r4_ENUMTAB, 
      utran_CID_InclusionInfo_r4_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CID_InclusionInfo_r4)
         utran_CID_InclusionInfo_r4_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ROHC_PacketSizeList_r4 (
   utran_ROHC_PacketSizeList_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UL_RFC3095_r4 (utran_UL_RFC3095_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->max_CID = 15;
   asn1Init_utran_ROHC_PacketSizeList_r4 (&pvalue->dummy);
}

void asn1Init_utran_DL_RFC3095_r4 (utran_DL_RFC3095_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->max_CID = 15;
   pvalue->reverseDecompressionDepth = 0;
}

void asn1Init_utran_RFC3095_Info_r4 (utran_RFC3095_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_ROHC_ProfileList_r4 (&pvalue->rohcProfileList);
   asn1Init_utran_UL_RFC3095_r4 (&pvalue->ul_RFC3095);
   asn1Init_utran_DL_RFC3095_r4 (&pvalue->dl_RFC3095);
}

void asn1Init_utran_AlgorithmSpecificInfo_r4 (
   utran_AlgorithmSpecificInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_AlgorithmSpecificInfo_r4 (OSCTXT *pctxt, 
   utran_AlgorithmSpecificInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rfc2507_Info) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rfc2507_Info);
         }
         break;

      case 2:
         if (0 != pvalue->u.rfc3095_Info) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rfc3095_Info);
         }
         break;

   }
}

void asn1Init_utran_HeaderCompressionInfo_r4 (
   utran_HeaderCompressionInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_AlgorithmSpecificInfo_r4 (&pvalue->algorithmSpecificInfo);
}

void asn1Free_utran_HeaderCompressionInfo_r4 (OSCTXT *pctxt, 
   utran_HeaderCompressionInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AlgorithmSpecificInfo_r4 (pctxt, &pvalue->algorithmSpecificInfo);
}

void asn1Init_utran_HeaderCompressionInfoList_r4 (
   utran_HeaderCompressionInfoList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HeaderCompressionInfoList_r4 (OSCTXT *pctxt, 
   utran_HeaderCompressionInfoList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_HeaderCompressionInfo_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HeaderCompressionInfo_r4*)pnode->data;
      asn1Free_utran_HeaderCompressionInfo_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_PDCP_Info_r4 (utran_PDCP_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_LosslessSRNS_RelocSupport (&pvalue->losslessSRNS_RelocSupport);
   asn1Init_utran_HeaderCompressionInfoList_r4 (&pvalue->headerCompressionInfoList);
}

void asn1Free_utran_PDCP_Info_r4 (OSCTXT *pctxt, utran_PDCP_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.headerCompressionInfoListPresent) {
      asn1Free_utran_HeaderCompressionInfoList_r4 (pctxt, &pvalue->headerCompressionInfoList);
   }
}

void asn1Init_utran_PDCP_InfoReconfig_r4 (utran_PDCP_InfoReconfig_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
}

void asn1Free_utran_PDCP_InfoReconfig_r4 (OSCTXT *pctxt, 
   utran_PDCP_InfoReconfig_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
}

void asn1Init_utran_RB_InformationReconfig_r4 (
   utran_RB_InformationReconfig_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r4 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r4 (
   utran_RB_InformationReconfigList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r4 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r4*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS (&pvalue->ul_TFCS);
}

void asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS (pctxt, &pvalue->ul_TFCS);
}

void asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IndividualUL_CCTrCH_InfoList (&pvalue->individualUL_CCTrCH_InfoList);
}

void asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.individualUL_CCTrCH_InfoListPresent) {
      asn1Free_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_TFC_SubsetList_element_modeSpecificInfo_tdd (
   utran_TFC_SubsetList_element_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFCS_Identity (&pvalue->tfcs_ID);
}

void asn1Init_utran_TFC_SubsetList_element_modeSpecificInfo (
   utran_TFC_SubsetList_element_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFC_SubsetList_element_modeSpecificInfo (OSCTXT *pctxt, 
   utran_TFC_SubsetList_element_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_TFC_SubsetList_element (
   utran_TFC_SubsetList_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFC_SubsetList_element_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_TFC_Subset (&pvalue->tfc_Subset);
}

void asn1Free_utran_TFC_SubsetList_element (OSCTXT *pctxt, 
   utran_TFC_SubsetList_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFC_SubsetList_element_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   asn1Free_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
}

void asn1Init_utran_TFC_SubsetList (utran_TFC_SubsetList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFC_SubsetList (OSCTXT *pctxt, 
   utran_TFC_SubsetList* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFC_SubsetList_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFC_SubsetList_element*)pnode->data;
      asn1Free_utran_TFC_SubsetList_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_r4 (
   utran_UL_CommonTransChInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFC_Subset (&pvalue->tfc_Subset);
   asn1Init_utran_TFCS (&pvalue->prach_TFCS);
   asn1Init_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_TFC_SubsetList (&pvalue->tfc_SubsetList);
}

void asn1Free_utran_UL_CommonTransChInfo_r4 (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tfc_SubsetPresent) {
      asn1Free_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
   }
   if (pvalue->m.prach_TFCSPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->prach_TFCS);
   }
   if (pvalue->m.modeSpecificInfoPresent) {
      asn1Free_utran_UL_CommonTransChInfo_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   }
   if (pvalue->m.tfc_SubsetListPresent) {
      asn1Free_utran_TFC_SubsetList (pctxt, &pvalue->tfc_SubsetList);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFCS (&pvalue->tfcs);
}

void asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tfcsPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->tfcs);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DCH_TFCS) {
            asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters_dl_DCH_TFCS (pctxt, pvalue->u.dl_DCH_TFCS);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DCH_TFCS);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (&pvalue->dl_Parameters);
}

void asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_ParametersPresent) {
      asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd_dl_Parameters (pctxt, &pvalue->dl_Parameters);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IndividualDL_CCTrCH_InfoList (&pvalue->individualDL_CCTrCH_InfoList);
}

void asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.individualDL_CCTrCH_InfoListPresent) {
      asn1Free_utran_IndividualDL_CCTrCH_InfoList (pctxt, &pvalue->individualDL_CCTrCH_InfoList);
   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonTransChInfo_r4 (
   utran_DL_CommonTransChInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFCS (&pvalue->sccpch_TFCS);
   asn1Init_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonTransChInfo_r4 (OSCTXT *pctxt, 
   utran_DL_CommonTransChInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.sccpch_TFCSPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->sccpch_TFCS);
   }
   if (pvalue->m.modeSpecificInfoPresent) {
      asn1Free_utran_DL_CommonTransChInfo_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r4 (
   utran_DL_AddReconfTransChInformation_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r4 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r4_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r4 (
   utran_DL_AddReconfTransChInfoList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r4 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r4*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_fdd (
   utran_UL_DPCH_PowerControlInfo_r4_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd (
   utran_UL_DPCH_PowerControlInfo_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r4 (
   utran_UL_DPCH_PowerControlInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r4 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r4_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384 (
   utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_SynchronisationParameters_r4_sync_UL_CodesBitmap (
   utran_SynchronisationParameters_r4_sync_UL_CodesBitmap* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

static const OSEnumItem utran_TDD_FPACH_CCode16_r4_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-10"), 9, 7, 8 },
   { OSUTF8("cc16-11"), 10, 7, 9 },
   { OSUTF8("cc16-12"), 11, 7, 10 },
   { OSUTF8("cc16-13"), 12, 7, 11 },
   { OSUTF8("cc16-14"), 13, 7, 12 },
   { OSUTF8("cc16-15"), 14, 7, 13 },
   { OSUTF8("cc16-16"), 15, 7, 14 },
   { OSUTF8("cc16-2"), 1, 6, 15 },
   { OSUTF8("cc16-3"), 2, 6, 1 },
   { OSUTF8("cc16-4"), 3, 6, 2 },
   { OSUTF8("cc16-5"), 4, 6, 3 },
   { OSUTF8("cc16-6"), 5, 6, 4 },
   { OSUTF8("cc16-7"), 6, 6, 5 },
   { OSUTF8("cc16-8"), 7, 6, 6 },
   { OSUTF8("cc16-9"), 8, 6, 7 }
} ;
#define utran_TDD_FPACH_CCode16_r4_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TDD_FPACH_CCode16_r4_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TDD_FPACH_CCode16_r4_ENUMTABSIZE) {
      return utran_TDD_FPACH_CCode16_r4_ENUMTAB
         [utran_TDD_FPACH_CCode16_r4_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TDD_FPACH_CCode16_r4_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TDD_FPACH_CCode16_r4* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TDD_FPACH_CCode16_r4_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TDD_FPACH_CCode16_r4_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TDD_FPACH_CCode16_r4* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TDD_FPACH_CCode16_r4_ENUMTAB, 
      utran_TDD_FPACH_CCode16_r4_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TDD_FPACH_CCode16_r4)
         utran_TDD_FPACH_CCode16_r4_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_FPACH_Info_r4 (utran_FPACH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_LCR_r4 (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_FPACH_Info_r4 (OSCTXT *pctxt, utran_FPACH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_LCR_r4 (pctxt, &pvalue->midambleShiftAndBurstType);
}

static const OSEnumItem utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTAB[] = {
   { OSUTF8("tr1"), 0, 3, 0 },
   { OSUTF8("tr2"), 1, 3, 1 },
   { OSUTF8("tr4"), 2, 3, 2 },
   { OSUTF8("tr8"), 3, 3, 3 }
} ;
#define utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTABSIZE 4

const OSUTF8CHAR* utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTABSIZE) {
      return utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTAB
         [utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTAB, 
      utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions)
         utran_SYNC_UL_Procedure_r4_max_SYNC_UL_Transmissions_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SynchronisationParameters_r4 (
   utran_SynchronisationParameters_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SynchronisationParameters_r4_sync_UL_CodesBitmap (&pvalue->sync_UL_CodesBitmap);
   asn1Init_utran_FPACH_Info_r4 (&pvalue->fpach_Info);
}

void asn1Free_utran_SynchronisationParameters_r4 (OSCTXT *pctxt, 
   utran_SynchronisationParameters_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_FPACH_Info_r4 (pctxt, &pvalue->fpach_Info);
}

void asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (
   utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SynchronisationParameters_r4 (&pvalue->synchronisationParameters);
}

void asn1Free_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.synchronisationParametersPresent) {
      asn1Free_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (
   utran_UL_TimingAdvanceControl_r4_enabled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r4_enabled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_UL_TimingAdvanceControl_r4_enabled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r4_enabled (
   utran_UL_TimingAdvanceControl_r4_enabled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_TimingAdvanceControl_r4_enabled (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r4_enabled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_TimingAdvanceControl_r4_enabled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_TimingAdvanceControl_r4 (
   utran_UL_TimingAdvanceControl_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl_r4 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.enabled) {
            asn1Free_utran_UL_TimingAdvanceControl_r4_enabled (pctxt, pvalue->u.enabled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enabled);
         }
         break;

   }
}

void asn1Init_utran_UL_CCTrCH_r4_tddOption_tdd384 (
   utran_UL_CCTrCH_r4_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UplinkTimeslotsCodes (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH_r4_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r4_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (
   utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->individualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList (&pvalue->ul_TS_ChannelisationCodeList);
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (
   utran_UplinkAdditionalTimeslots_LCR_r4_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r4_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4 (
   utran_UplinkAdditionalTimeslots_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (&pvalue->parameters);
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4 (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UplinkAdditionalTimeslots_LCR_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UplinkAdditionalTimeslots_LCR_r4*)pnode->data;
      asn1Free_utran_UplinkAdditionalTimeslots_LCR_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r4 (
   utran_UplinkTimeslotsCodes_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList (&pvalue->ul_TS_ChannelisationCodeList);
   asn1Init_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r4 (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_UplinkTimeslotsCodes_LCR_r4_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_UL_CCTrCH_r4_tddOption_tdd128 (
   utran_UL_CCTrCH_r4_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UplinkTimeslotsCodes_LCR_r4 (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH_r4_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r4_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_UL_CCTrCH_r4_tddOption (
   utran_UL_CCTrCH_r4_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CCTrCH_r4_tddOption (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r4_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_CCTrCH_r4_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_UL_CCTrCH_r4_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_CCTrCH_r4 (utran_UL_CCTrCH_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_UL_CCTrCH_r4_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_CCTrCH_r4 (OSCTXT *pctxt, utran_UL_CCTrCH_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_CCTrCH_r4_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_CCTrCHList_r4 (utran_UL_CCTrCHList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_CCTrCHList_r4 (OSCTXT *pctxt, 
   utran_UL_CCTrCHList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_CCTrCH_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_CCTrCH_r4*)pnode->data;
      asn1Free_utran_UL_CCTrCH_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_r4 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList_r4 (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo (
   utran_UL_DPCH_Info_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r4 (utran_UL_DPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r4 (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info_r4 (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_r4 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_UL_ChannelRequirement_r4 (
   utran_UL_ChannelRequirement_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_ChannelRequirement_r4 (OSCTXT *pctxt, 
   utran_UL_ChannelRequirement_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ul_DPCH_Info) {
            asn1Free_utran_UL_DPCH_Info_r4 (pctxt, pvalue->u.ul_DPCH_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_DPCH_Info);
         }
         break;

      case 2:
         if (0 != pvalue->u.dummy) {
            asn1Free_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dummy);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise (
   utran_DL_DPCH_InfoCommon_r4_cfnHandling_initialise* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4_cfnHandling (
   utran_DL_DPCH_InfoCommon_r4_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r4_cfnHandling (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r4_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.initialise) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.initialise);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
   asn1Init_utran_Dl_rate_matching_restriction (&pvalue->dl_rate_matching_restriction);
   asn1Init_utran_SF512_AndPilot (&pvalue->spreadingFactorAndPilot);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
   if (pvalue->m.dl_rate_matching_restrictionPresent) {
      asn1Free_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_MAC_d_HFN_initial_value (
   utran_MAC_d_HFN_initial_value* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_DL_DPCH_InfoCommon_r4 (utran_DL_DPCH_InfoCommon_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon_r4_cfnHandling (&pvalue->cfnHandling);
   asn1Init_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_MAC_d_HFN_initial_value (&pvalue->mac_d_HFN_initial_value);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r4 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoCommon_r4_cfnHandling (pctxt, &pvalue->cfnHandling);
   asn1Free_utran_DL_DPCH_InfoCommon_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_SSDT_Information_r4 (utran_SSDT_Information_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo (&pvalue->dpch_CompressedModeInfo);
   asn1Init_utran_SSDT_Information_r4 (&pvalue->dummy);
}

void asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo (
   utran_DL_CommonInformation_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r4 (
   utran_DL_CommonInformation_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon_r4 (&pvalue->dl_DPCH_InfoCommon);
   asn1Init_utran_DL_CommonInformation_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r4 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_InfoCommonPresent) {
      asn1Free_utran_DL_DPCH_InfoCommon_r4 (pctxt, &pvalue->dl_DPCH_InfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (
   utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDSCH_SHO_DCH_Info (&pvalue->dummy1);
   asn1Init_utran_PDSCH_CodeMapping (&pvalue->dummy2);
}

void asn1Free_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dummy1Present) {
      asn1Free_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
   }
   if (pvalue->m.dummy2Present) {
      asn1Free_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
   }
}

void asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.syncCase1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase1);
         }
         break;

      case 2:
         if (0 != pvalue->u.syncCase2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase2);
         }
         break;

   }
}

void asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (&pvalue->syncCase);
}

void asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.syncCasePresent) {
      asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768_syncCase (pctxt, &pvalue->syncCase);
   }
}

void asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_r4_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_PrimaryCCPCH_Info_r4_tdd (
   utran_PrimaryCCPCH_Info_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_PrimaryCCPCH_Info_r4_tdd (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PrimaryCCPCH_Info_r4_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_PrimaryCCPCH_Info_r4 (utran_PrimaryCCPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_Info_r4 (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r4_modeSpecificInfo (
   utran_DL_InformationPerRL_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r4_fdd (
   utran_DL_DPCH_InfoPerRL_r4_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r4_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r4_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r4_tdd (
   utran_DL_DPCH_InfoPerRL_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r4 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r4_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r4_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r4 (utran_DL_DPCH_InfoPerRL_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r4 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r4_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r4_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SF256_AndCodeNumber (&pvalue->sf_AndCodeNumber);
   pvalue->timingOffset = 0;
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo (&pvalue->individualTimeslotInfo);
}

void asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->individualTimeslotInfo);
}

void asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonTimeslotInfoSCCPCH (&pvalue->commonTimeslotInfo);
   asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
   asn1Init_utran_SCCPCH_ChannelisationCodeList (&pvalue->channelisationCode);
}

void asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonTimeslotInfoSCCPCH (pctxt, &pvalue->commonTimeslotInfo);
   asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_SecondaryCCPCH_Info_r4 (
   utran_SecondaryCCPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_SecondaryCCPCH_Info_r4 (OSCTXT *pctxt, 
   utran_SecondaryCCPCH_Info_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SecondaryCCPCH_Info_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (
   utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SIB_ReferenceListFACH (&pvalue->sib_ReferenceListFACH);
}

void asn1Free_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SIB_ReferenceListFACH (pctxt, &pvalue->sib_ReferenceListFACH);
}

void asn1Init_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (
   utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_SCCPCH_InfoForFACH_r4 (utran_SCCPCH_InfoForFACH_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SecondaryCCPCH_Info_r4 (&pvalue->secondaryCCPCH_Info);
   asn1Init_utran_TFCS (&pvalue->tfcs);
   asn1Init_utran_FACH_PCH_InformationList (&pvalue->fach_PCH_InformationList);
   asn1Init_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_SCCPCH_InfoForFACH_r4 (OSCTXT *pctxt, 
   utran_SCCPCH_InfoForFACH_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_SecondaryCCPCH_Info_r4 (pctxt, &pvalue->secondaryCCPCH_Info);
   asn1Free_utran_TFCS (pctxt, &pvalue->tfcs);
   asn1Free_utran_FACH_PCH_InformationList (pctxt, &pvalue->fach_PCH_InformationList);
   asn1Free_utran_SCCPCH_InfoForFACH_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r4 (
   utran_DL_InformationPerRL_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r4_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_DPCH_InfoPerRL_r4 (&pvalue->dl_DPCH_InfoPerRL);
   asn1Init_utran_SCCPCH_InfoForFACH_r4 (&pvalue->dummy);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r4 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r4_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_DPCH_InfoPerRLPresent) {
      asn1Free_utran_DL_DPCH_InfoPerRL_r4 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   }
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_SCCPCH_InfoForFACH_r4 (pctxt, &pvalue->dummy);
   }
}

void asn1Init_utran_DL_InformationPerRL_List_r4 (
   utran_DL_InformationPerRL_List_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r4 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r4*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_AM_RLC_Mode_r5 (utran_DL_AM_RLC_Mode_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_OctetModeRLC_SizeInfoType1 (&pvalue->dl_RLC_PDU_size);
   asn1Init_utran_DL_RLC_StatusInfo (&pvalue->dl_RLC_StatusInfo);
}

void asn1Free_utran_DL_AM_RLC_Mode_r5 (OSCTXT *pctxt, 
   utran_DL_AM_RLC_Mode_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, &pvalue->dl_RLC_PDU_size);
}

static const OSEnumItem utran_DL_UM_RLC_LI_size_ENUMTAB[] = {
   { OSUTF8("size15"), 1, 6, 1 },
   { OSUTF8("size7"), 0, 5, 0 }
} ;
#define utran_DL_UM_RLC_LI_size_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_UM_RLC_LI_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_UM_RLC_LI_size_ENUMTABSIZE) {
      return utran_DL_UM_RLC_LI_size_ENUMTAB
         [utran_DL_UM_RLC_LI_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_UM_RLC_LI_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_UM_RLC_LI_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_UM_RLC_LI_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_UM_RLC_LI_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DL_UM_RLC_LI_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_UM_RLC_LI_size_ENUMTAB, utran_DL_UM_RLC_LI_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_UM_RLC_LI_size)
         utran_DL_UM_RLC_LI_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_RLC_Mode_r5 (utran_DL_RLC_Mode_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_RLC_Mode_r5 (OSCTXT *pctxt, 
   utran_DL_RLC_Mode_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_AM_RLC_Mode) {
            asn1Free_utran_DL_AM_RLC_Mode_r5 (pctxt, pvalue->u.dl_AM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_AM_RLC_Mode);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_UM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_UM_RLC_Mode);
         }
         break;

      case 3:
         if (0 != pvalue->u.dl_TM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_TM_RLC_Mode);
         }
         break;

   }
}

void asn1Init_utran_RLC_Info_r5 (utran_RLC_Info_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_RLC_Mode (&pvalue->ul_RLC_Mode);
   asn1Init_utran_DL_RLC_Mode_r5 (&pvalue->dl_RLC_Mode);
}

void asn1Free_utran_RLC_Info_r5 (OSCTXT *pctxt, utran_RLC_Info_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_RLC_ModePresent) {
      asn1Free_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
   }
   if (pvalue->m.dl_RLC_ModePresent) {
      asn1Free_utran_DL_RLC_Mode_r5 (pctxt, &pvalue->dl_RLC_Mode);
   }
}

void asn1Init_utran_DL_TransportChannelType_r5 (
   utran_DL_TransportChannelType_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TransportChannelType_r5 (OSCTXT *pctxt, 
   utran_DL_TransportChannelType_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.dch_and_dsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_and_dsch);
         }
         break;

      case 5:
         break;

      case 6:
         if (0 != pvalue->u.dch_and_hsdsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_and_hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_LogicalChannelMapping_r5 (
   utran_DL_LogicalChannelMapping_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TransportChannelType_r5 (&pvalue->dl_TransportChannelType);
}

void asn1Free_utran_DL_LogicalChannelMapping_r5 (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMapping_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TransportChannelType_r5 (pctxt, &pvalue->dl_TransportChannelType);
}

void asn1Init_utran_DL_LogicalChannelMappingList_r5 (
   utran_DL_LogicalChannelMappingList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_LogicalChannelMappingList_r5 (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMappingList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_LogicalChannelMapping_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_LogicalChannelMapping_r5*)pnode->data;
      asn1Free_utran_DL_LogicalChannelMapping_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_MappingOption_r5 (utran_RB_MappingOption_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_LogicalChannelMappings (&pvalue->ul_LogicalChannelMappings);
   asn1Init_utran_DL_LogicalChannelMappingList_r5 (&pvalue->dl_LogicalChannelMappingList);
}

void asn1Free_utran_RB_MappingOption_r5 (OSCTXT *pctxt, 
   utran_RB_MappingOption_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_LogicalChannelMappingsPresent) {
      asn1Free_utran_UL_LogicalChannelMappings (pctxt, &pvalue->ul_LogicalChannelMappings);
   }
   if (pvalue->m.dl_LogicalChannelMappingListPresent) {
      asn1Free_utran_DL_LogicalChannelMappingList_r5 (pctxt, &pvalue->dl_LogicalChannelMappingList);
   }
}

void asn1Init_utran_RB_MappingInfo_r5 (utran_RB_MappingInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_MappingInfo_r5 (OSCTXT *pctxt, 
   utran_RB_MappingInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_MappingOption_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_MappingOption_r5*)pnode->data;
      asn1Free_utran_RB_MappingOption_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationReconfig_r5 (
   utran_RB_InformationReconfig_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info_r5 (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo_r5 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r5 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info_r5 (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r5 (
   utran_RB_InformationReconfigList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r5 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r5*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationAffected_r5 (
   utran_RB_InformationAffected_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RB_MappingInfo_r5 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationAffected_r5 (OSCTXT *pctxt, 
   utran_RB_InformationAffected_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationAffectedList_r5 (
   utran_RB_InformationAffectedList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationAffectedList_r5 (OSCTXT *pctxt, 
   utran_RB_InformationAffectedList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationAffected_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationAffected_r5*)pnode->data;
      asn1Free_utran_RB_InformationAffected_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_PDCPContextRelocationList (
   utran_RB_PDCPContextRelocationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_PDCPContextRelocationList (OSCTXT *pctxt, 
   utran_RB_PDCPContextRelocationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_CounterSynchronisationInfo_r5 (
   utran_DL_CounterSynchronisationInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RB_WithPDCP_InfoList (&pvalue->rb_WithPDCP_InfoList);
   asn1Init_utran_RB_PDCPContextRelocationList (&pvalue->rb_PDCPContextRelocationList);
}

void asn1Free_utran_DL_CounterSynchronisationInfo_r5 (OSCTXT *pctxt, 
   utran_DL_CounterSynchronisationInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rb_WithPDCP_InfoListPresent) {
      asn1Free_utran_RB_WithPDCP_InfoList (pctxt, &pvalue->rb_WithPDCP_InfoList);
   }
   if (pvalue->m.rb_PDCPContextRelocationListPresent) {
      asn1Free_utran_RB_PDCPContextRelocationList (pctxt, &pvalue->rb_PDCPContextRelocationList);
   }
}

void asn1Init_utran_DL_TrCH_TypeId2_r5 (utran_DL_TrCH_TypeId2_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DL_TransportChannelIdentity_r5 (
   utran_DL_TransportChannelIdentity_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_TrCH_TypeId2_r5 (&pvalue->dl_TransportChannelType);
}

void asn1Init_utran_DL_DeletedTransChInfoList_r5 (
   utran_DL_DeletedTransChInfoList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_DeletedTransChInfoList_r5 (OSCTXT *pctxt, 
   utran_DL_DeletedTransChInfoList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_DL_TrCH_TypeId1_r5 (utran_DL_TrCH_TypeId1_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_T1_ReleaseTimer_ENUMTAB[] = {
   { OSUTF8("rt10"), 0, 4, 0 },
   { OSUTF8("rt100"), 9, 5, 5 },
   { OSUTF8("rt120"), 10, 5, 7 },
   { OSUTF8("rt140"), 11, 5, 9 },
   { OSUTF8("rt160"), 12, 5, 11 },
   { OSUTF8("rt20"), 1, 4, 12 },
   { OSUTF8("rt200"), 13, 5, 13 },
   { OSUTF8("rt30"), 2, 4, 14 },
   { OSUTF8("rt300"), 14, 5, 15 },
   { OSUTF8("rt40"), 3, 4, 1 },
   { OSUTF8("rt400"), 15, 5, 2 },
   { OSUTF8("rt50"), 4, 4, 3 },
   { OSUTF8("rt60"), 5, 4, 4 },
   { OSUTF8("rt70"), 6, 4, 6 },
   { OSUTF8("rt80"), 7, 4, 8 },
   { OSUTF8("rt90"), 8, 4, 10 }
} ;
#define utran_T1_ReleaseTimer_ENUMTABSIZE 16

const OSUTF8CHAR* utran_T1_ReleaseTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_T1_ReleaseTimer_ENUMTABSIZE) {
      return utran_T1_ReleaseTimer_ENUMTAB
         [utran_T1_ReleaseTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_T1_ReleaseTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_T1_ReleaseTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_T1_ReleaseTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_T1_ReleaseTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_T1_ReleaseTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_T1_ReleaseTimer_ENUMTAB, utran_T1_ReleaseTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_T1_ReleaseTimer)
         utran_T1_ReleaseTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MAC_hs_WindowSize_ENUMTAB[] = {
   { OSUTF8("mws12"), 3, 5, 4 },
   { OSUTF8("mws16"), 4, 5, 5 },
   { OSUTF8("mws24"), 5, 5, 6 },
   { OSUTF8("mws32"), 6, 5, 0 },
   { OSUTF8("mws4"), 0, 4, 1 },
   { OSUTF8("mws6"), 1, 4, 2 },
   { OSUTF8("mws8"), 2, 4, 3 }
} ;
#define utran_MAC_hs_WindowSize_ENUMTABSIZE 7

const OSUTF8CHAR* utran_MAC_hs_WindowSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_hs_WindowSize_ENUMTABSIZE) {
      return utran_MAC_hs_WindowSize_ENUMTAB
         [utran_MAC_hs_WindowSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_hs_WindowSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_hs_WindowSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_hs_WindowSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_hs_WindowSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MAC_hs_WindowSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_hs_WindowSize_ENUMTAB, utran_MAC_hs_WindowSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_hs_WindowSize)
         utran_MAC_hs_WindowSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MAC_d_PDU_SizeInfo_List (
   utran_MAC_d_PDU_SizeInfo_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_d_PDU_SizeInfo_List (OSCTXT *pctxt, 
   utran_MAC_d_PDU_SizeInfo_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MAC_hs_AddReconfQueue (utran_MAC_hs_AddReconfQueue* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_d_PDU_SizeInfo_List (&pvalue->mac_d_PDU_SizeInfo_List);
}

void asn1Free_utran_MAC_hs_AddReconfQueue (OSCTXT *pctxt, 
   utran_MAC_hs_AddReconfQueue* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_d_PDU_SizeInfo_ListPresent) {
      asn1Free_utran_MAC_d_PDU_SizeInfo_List (pctxt, &pvalue->mac_d_PDU_SizeInfo_List);
   }
}

void asn1Init_utran_MAC_hs_AddReconfQueue_List (
   utran_MAC_hs_AddReconfQueue_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_hs_AddReconfQueue_List (OSCTXT *pctxt, 
   utran_MAC_hs_AddReconfQueue_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_MAC_hs_AddReconfQueue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_MAC_hs_AddReconfQueue*)pnode->data;
      asn1Free_utran_MAC_hs_AddReconfQueue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_MAC_hs_DelQueue_List (utran_MAC_hs_DelQueue_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_hs_DelQueue_List (OSCTXT *pctxt, 
   utran_MAC_hs_DelQueue_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AddOrReconfMAC_dFlow (utran_AddOrReconfMAC_dFlow* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_hs_AddReconfQueue_List (&pvalue->mac_hs_AddReconfQueue_List);
   asn1Init_utran_MAC_hs_DelQueue_List (&pvalue->mac_hs_DelQueue_List);
}

void asn1Free_utran_AddOrReconfMAC_dFlow (OSCTXT *pctxt, 
   utran_AddOrReconfMAC_dFlow* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_hs_AddReconfQueue_ListPresent) {
      asn1Free_utran_MAC_hs_AddReconfQueue_List (pctxt, &pvalue->mac_hs_AddReconfQueue_List);
   }
   if (pvalue->m.mac_hs_DelQueue_ListPresent) {
      asn1Free_utran_MAC_hs_DelQueue_List (pctxt, &pvalue->mac_hs_DelQueue_List);
   }
}

void asn1Init_utran_HSDSCH_Info (utran_HSDSCH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info (&pvalue->harqInfo);
   asn1Init_utran_AddOrReconfMAC_dFlow (&pvalue->addOrReconfMAC_dFlow);
}

void asn1Free_utran_HSDSCH_Info (OSCTXT *pctxt, utran_HSDSCH_Info* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.addOrReconfMAC_dFlowPresent) {
      asn1Free_utran_AddOrReconfMAC_dFlow (pctxt, &pvalue->addOrReconfMAC_dFlow);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            asn1Free_utran_HSDSCH_Info (pctxt, pvalue->u.hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r5 (
   utran_DL_AddReconfTransChInformation_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TrCH_TypeId1_r5 (&pvalue->dl_TransportChannelType);
   asn1Init_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r5 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r5_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r5 (
   utran_DL_AddReconfTransChInfoList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r5 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r5*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_fdd (
   utran_UL_DPCH_PowerControlInfo_r5_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd (
   utran_UL_DPCH_PowerControlInfo_r5_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r5 (
   utran_UL_DPCH_PowerControlInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r5 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r5_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_r5_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_r4 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList_r4 (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo (
   utran_UL_DPCH_Info_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r5_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_r5_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r5 (utran_UL_DPCH_Info_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r5 (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_r5_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info_r5 (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_r5 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_UL_ChannelRequirement_r5 (
   utran_UL_ChannelRequirement_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_ChannelRequirement_r5 (OSCTXT *pctxt, 
   utran_UL_ChannelRequirement_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ul_DPCH_Info) {
            asn1Free_utran_UL_DPCH_Info_r5 (pctxt, pvalue->u.ul_DPCH_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ul_DPCH_Info);
         }
         break;

      case 2:
         if (0 != pvalue->u.dummy) {
            asn1Free_utran_CPCH_SetInfo (pctxt, pvalue->u.dummy);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dummy);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r5_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo (&pvalue->dpch_CompressedModeInfo);
   asn1Init_utran_SSDT_Information_r4 (&pvalue->dummy);
}

void asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r5_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r5_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r5_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo (
   utran_DL_CommonInformation_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r5_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r5_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r5_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r5_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r5_mac_hsResetIndicator)
         utran_DL_CommonInformation_r5_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r5 (
   utran_DL_CommonInformation_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon_r4 (&pvalue->dl_DPCH_InfoCommon);
   asn1Init_utran_DL_CommonInformation_r5_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r5 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_InfoCommonPresent) {
      asn1Free_utran_DL_DPCH_InfoCommon_r4 (pctxt, &pvalue->dl_DPCH_InfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (
   utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDSCH_SHO_DCH_Info (&pvalue->dummy1);
   asn1Init_utran_PDSCH_CodeMapping (&pvalue->dummy2);
}

void asn1Free_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dummy1Present) {
      asn1Free_utran_PDSCH_SHO_DCH_Info (pctxt, &pvalue->dummy1);
   }
   if (pvalue->m.dummy2Present) {
      asn1Free_utran_PDSCH_CodeMapping (pctxt, &pvalue->dummy2);
   }
}

void asn1Init_utran_DL_InformationPerRL_r5_modeSpecificInfo (
   utran_DL_InformationPerRL_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r5_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r5_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r5_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r5 (
   utran_DL_InformationPerRL_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r5_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_DPCH_InfoPerRL_r5 (&pvalue->dl_DPCH_InfoPerRL);
   asn1Init_utran_SCCPCH_InfoForFACH_r4 (&pvalue->dummy);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r5 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r5_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_DPCH_InfoPerRLPresent) {
      asn1Free_utran_DL_DPCH_InfoPerRL_r5 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
   }
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_SCCPCH_InfoForFACH_r4 (pctxt, &pvalue->dummy);
   }
}

void asn1Init_utran_DL_InformationPerRL_List_r5 (
   utran_DL_InformationPerRL_List_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r5 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r5*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_DL_Reception_Window_Size_r6_ENUMTAB[] = {
   { OSUTF8("size112"), 5, 7, 1 },
   { OSUTF8("size32"), 0, 6, 2 },
   { OSUTF8("size48"), 1, 6, 3 },
   { OSUTF8("size64"), 2, 6, 4 },
   { OSUTF8("size80"), 3, 6, 5 },
   { OSUTF8("size96"), 4, 6, 0 }
} ;
#define utran_DL_Reception_Window_Size_r6_ENUMTABSIZE 6

const OSUTF8CHAR* utran_DL_Reception_Window_Size_r6_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_Reception_Window_Size_r6_ENUMTABSIZE) {
      return utran_DL_Reception_Window_Size_r6_ENUMTAB
         [utran_DL_Reception_Window_Size_r6_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_Reception_Window_Size_r6_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DL_Reception_Window_Size_r6* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_Reception_Window_Size_r6_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_Reception_Window_Size_r6_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_Reception_Window_Size_r6* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_Reception_Window_Size_r6_ENUMTAB, 
      utran_DL_Reception_Window_Size_r6_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_Reception_Window_Size_r6)
         utran_DL_Reception_Window_Size_r6_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_UM_RLC_Mode_r6 (utran_DL_UM_RLC_Mode_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_RLC_Mode_r6 (utran_DL_RLC_Mode_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_RLC_Mode_r6 (OSCTXT *pctxt, 
   utran_DL_RLC_Mode_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_AM_RLC_Mode) {
            asn1Free_utran_DL_AM_RLC_Mode_r5 (pctxt, pvalue->u.dl_AM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_AM_RLC_Mode);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_UM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_UM_RLC_Mode);
         }
         break;

      case 3:
         if (0 != pvalue->u.dl_TM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_TM_RLC_Mode);
         }
         break;

   }
}

static const OSEnumItem utran_RLC_Info_r6_altE_bitInterpretation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_RLC_Info_r6_altE_bitInterpretation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_RLC_Info_r6_altE_bitInterpretation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_RLC_Info_r6_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r6_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_RLC_Info_r6_altE_bitInterpretation_ENUMTABSIZE) {
      return utran_RLC_Info_r6_altE_bitInterpretation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_Info_r6_altE_bitInterpretation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RLC_Info_r6_altE_bitInterpretation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_Info_r6_altE_bitInterpretation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_Info_r6_altE_bitInterpretation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_Info_r6_altE_bitInterpretation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_Info_r6_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r6_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_Info_r6_altE_bitInterpretation)
         utran_RLC_Info_r6_altE_bitInterpretation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RLC_Info_r6 (utran_RLC_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_RLC_Mode (&pvalue->ul_RLC_Mode);
   asn1Init_utran_DL_RLC_Mode_r6 (&pvalue->dl_RLC_Mode);
}

void asn1Free_utran_RLC_Info_r6 (OSCTXT *pctxt, utran_RLC_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_RLC_ModePresent) {
      asn1Free_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
   }
   if (pvalue->m.dl_RLC_ModePresent) {
      asn1Free_utran_DL_RLC_Mode_r6 (pctxt, &pvalue->dl_RLC_Mode);
   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.explicitList) {
            asn1Free_utran_RLC_SizeExplicitList (pctxt, pvalue->u.explicitList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicitList);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TransportChannelType (&pvalue->ul_TransportChannelType);
   asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (&pvalue->rlc_SizeList);
}

void asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (pctxt, &pvalue->rlc_SizeList);
}

void asn1Init_utran_RLC_PDU_Size (utran_RLC_PDU_Size* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_OctetModeRLC_SizeInfoType1 (pvalue);
}

void asn1Free_utran_RLC_PDU_Size (OSCTXT *pctxt, utran_RLC_PDU_Size* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue);
}

void asn1Init_utran_RLC_PDU_SizeList (utran_RLC_PDU_SizeList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RLC_PDU_SizeList (OSCTXT *pctxt, 
   utran_RLC_PDU_SizeList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RLC_PDU_Size* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RLC_PDU_Size*)pnode->data;
      asn1Free_utran_RLC_PDU_Size (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RLC_PDU_SizeList (&pvalue->rlc_PDU_SizeList);
}

void asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_PDU_SizeList (pctxt, &pvalue->rlc_PDU_SizeList);
}

void asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_rach_usch) {
            asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_dch_rach_usch (pctxt, pvalue->u.dch_rach_usch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_rach_usch);
         }
         break;

      case 2:
         if (0 != pvalue->u.e_dch) {
            asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type_e_dch (pctxt, pvalue->u.e_dch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_dch);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r6 (
   utran_UL_LogicalChannelMapping_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (&pvalue->ul_TrCH_Type);
}

void asn1Free_utran_UL_LogicalChannelMapping_r6 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_r6_ul_TrCH_Type (pctxt, &pvalue->ul_TrCH_Type);
}

void asn1Init_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (
   utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_LogicalChannelMapping_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_LogicalChannelMapping_r6*)pnode->data;
      asn1Free_utran_UL_LogicalChannelMapping_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_LogicalChannelMappingList_r6 (
   utran_UL_LogicalChannelMappingList_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (&pvalue->ul_LogicalChannelMapping);
}

void asn1Free_utran_UL_LogicalChannelMappingList_r6 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMappingList_r6_ul_LogicalChannelMapping (pctxt, &pvalue->ul_LogicalChannelMapping);
}

void asn1Init_utran_UL_LogicalChannelMappings_r6 (
   utran_UL_LogicalChannelMappings_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMappings_r6 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappings_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.oneLogicalChannel) {
            asn1Free_utran_UL_LogicalChannelMapping_r6 (pctxt, pvalue->u.oneLogicalChannel);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.oneLogicalChannel);
         }
         break;

      case 2:
         if (0 != pvalue->u.twoLogicalChannels) {
            asn1Free_utran_UL_LogicalChannelMappingList_r6 (pctxt, pvalue->u.twoLogicalChannels);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.twoLogicalChannels);
         }
         break;

   }
}

void asn1Init_utran_RB_MappingOption_r6 (utran_RB_MappingOption_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_LogicalChannelMappings_r6 (&pvalue->ul_LogicalChannelMappings);
   asn1Init_utran_DL_LogicalChannelMappingList_r5 (&pvalue->dl_LogicalChannelMappingList);
}

void asn1Free_utran_RB_MappingOption_r6 (OSCTXT *pctxt, 
   utran_RB_MappingOption_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_LogicalChannelMappingsPresent) {
      asn1Free_utran_UL_LogicalChannelMappings_r6 (pctxt, &pvalue->ul_LogicalChannelMappings);
   }
   if (pvalue->m.dl_LogicalChannelMappingListPresent) {
      asn1Free_utran_DL_LogicalChannelMappingList_r5 (pctxt, &pvalue->dl_LogicalChannelMappingList);
   }
}

void asn1Init_utran_RB_MappingInfo_r6 (utran_RB_MappingInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_MappingInfo_r6 (OSCTXT *pctxt, 
   utran_RB_MappingInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_MappingOption_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_MappingOption_r6*)pnode->data;
      asn1Free_utran_RB_MappingOption_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationReconfig_r6 (
   utran_RB_InformationReconfig_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info_r6 (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo_r6 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r6 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info_r6 (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r6 (
   utran_RB_InformationReconfigList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r6 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r6*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationAffected_r6 (
   utran_RB_InformationAffected_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RB_MappingInfo_r6 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationAffected_r6 (OSCTXT *pctxt, 
   utran_RB_InformationAffected_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationAffectedList_r6 (
   utran_RB_InformationAffectedList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationAffectedList_r6 (OSCTXT *pctxt, 
   utran_RB_InformationAffectedList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationAffected_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationAffected_r6*)pnode->data;
      asn1Free_utran_RB_InformationAffected_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_TransportChannelIdentity_r6 (
   utran_UL_TransportChannelIdentity_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TransportChannelIdentity_r6 (OSCTXT *pctxt, 
   utran_UL_TransportChannelIdentity_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_usch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_usch);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_UL_DeletedTransChInfoList_r6 (
   utran_UL_DeletedTransChInfoList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_DeletedTransChInfoList_r6 (OSCTXT *pctxt, 
   utran_UL_DeletedTransChInfoList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_TransportChannelIdentity_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_TransportChannelIdentity_r6*)pnode->data;
      asn1Free_utran_UL_TransportChannelIdentity_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r6_dch_usch (
   utran_UL_AddReconfTransChInformation_r6_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r6_dch_usch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r6_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
}

static const OSEnumItem utran_E_DCH_TTI_ENUMTAB[] = {
   { OSUTF8("tti10"), 1, 5, 1 },
   { OSUTF8("tti2"), 0, 4, 0 }
} ;
#define utran_E_DCH_TTI_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_DCH_TTI_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DCH_TTI_ENUMTABSIZE) {
      return utran_E_DCH_TTI_ENUMTAB
         [utran_E_DCH_TTI_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DCH_TTI_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_E_DCH_TTI* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DCH_TTI_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DCH_TTI_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_E_DCH_TTI* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_E_DCH_TTI_ENUMTAB, 
      utran_E_DCH_TTI_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_DCH_TTI)utran_E_DCH_TTI_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTAB[] = {
   { OSUTF8("rv0"), 0, 3, 0 },
   { OSUTF8("rvtable"), 1, 7, 1 }
} ;
#define utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTABSIZE) {
      return utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTAB
         [utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTAB, 
      utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info)
         utran_UL_AddReconfTransChInformation_r6_e_dch_harq_Info_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DCH_MAC_d_FlowMultiplexingList (
   utran_E_DCH_MAC_d_FlowMultiplexingList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo (
   utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType_non_ScheduledTransGrantInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ms2_NonSchedTransmGrantHARQAlloc.numbits = 0;
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (
   utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.non_ScheduledTransGrantInfo) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.non_ScheduledTransGrantInfo);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow (
   utran_E_DCH_AddReconf_MAC_d_Flow* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_MAC_d_FlowMultiplexingList (&pvalue->mac_d_FlowMultiplexingList);
   asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (&pvalue->transmissionGrantType);
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transmissionGrantTypePresent) {
      asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_transmissionGrantType (pctxt, &pvalue->transmissionGrantType);
   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_FlowList (
   utran_E_DCH_AddReconf_MAC_d_FlowList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_FlowList (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_FlowList* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_AddReconf_MAC_d_Flow* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_AddReconf_MAC_d_Flow*)pnode->data;
      asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r6_e_dch (
   utran_UL_AddReconfTransChInformation_r6_e_dch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_AddReconf_MAC_d_FlowList (&pvalue->addReconf_MAC_d_FlowList);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r6_e_dch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r6_e_dch* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.addReconf_MAC_d_FlowListPresent) {
      asn1Free_utran_E_DCH_AddReconf_MAC_d_FlowList (pctxt, &pvalue->addReconf_MAC_d_FlowList);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r6 (
   utran_UL_AddReconfTransChInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_AddReconfTransChInformation_r6 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_usch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r6_dch_usch (pctxt, pvalue->u.dch_usch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_usch);
         }
         break;

      case 2:
         if (0 != pvalue->u.e_dch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r6_e_dch (pctxt, pvalue->u.e_dch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_dch);
         }
         break;

   }
}

void asn1Init_utran_UL_AddReconfTransChInfoList_r6 (
   utran_UL_AddReconfTransChInfoList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_AddReconfTransChInfoList_r6 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInfoList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_AddReconfTransChInformation_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_AddReconfTransChInformation_r6*)pnode->data;
      asn1Free_utran_UL_AddReconfTransChInformation_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_fdd (
   utran_UL_DPCH_PowerControlInfo_r6_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd (
   utran_UL_DPCH_PowerControlInfo_r6_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r6 (
   utran_UL_DPCH_PowerControlInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r6 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r6_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present (
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent (
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.present) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.present);
         }
         break;

      case 2:
         if (0 != pvalue->u.notPresent) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.notPresent);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (&pvalue->dpdchPresence);
}

void asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_r4 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList_r4 (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_r4 (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList_r4 (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo (
   utran_UL_DPCH_Info_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r6 (utran_UL_DPCH_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r6 (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info_r6 (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_r6 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator)
         utran_UL_EDCH_Information_r6_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_HappyBit_DelayCondition_ENUMTAB[] = {
   { OSUTF8("ms10"), 1, 4, 3 },
   { OSUTF8("ms100"), 4, 5, 0 },
   { OSUTF8("ms1000"), 7, 6, 4 },
   { OSUTF8("ms2"), 0, 3, 6 },
   { OSUTF8("ms20"), 2, 4, 1 },
   { OSUTF8("ms200"), 5, 5, 5 },
   { OSUTF8("ms50"), 3, 4, 7 },
   { OSUTF8("ms500"), 6, 5, 2 }
} ;
#define utran_HappyBit_DelayCondition_ENUMTABSIZE 8

const OSUTF8CHAR* utran_HappyBit_DelayCondition_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HappyBit_DelayCondition_ENUMTABSIZE) {
      return utran_HappyBit_DelayCondition_ENUMTAB
         [utran_HappyBit_DelayCondition_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HappyBit_DelayCondition_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HappyBit_DelayCondition* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HappyBit_DelayCondition_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HappyBit_DelayCondition_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HappyBit_DelayCondition* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HappyBit_DelayCondition_ENUMTAB, 
      utran_HappyBit_DelayCondition_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HappyBit_DelayCondition)
         utran_HappyBit_DelayCondition_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_DPDCH_MaxChannelisationCodes_ENUMTAB[] = {
   { OSUTF8("sf128"), 1, 5, 2 },
   { OSUTF8("sf16"), 4, 4, 0 },
   { OSUTF8("sf256"), 0, 5, 8 },
   { OSUTF8("sf2x2"), 8, 5, 4 },
   { OSUTF8("sf32"), 3, 4, 1 },
   { OSUTF8("sf4"), 6, 3, 9 },
   { OSUTF8("sf4x2"), 7, 5, 5 },
   { OSUTF8("sf4x2-and-sf2x2"), 9, 15, 6 },
   { OSUTF8("sf64"), 2, 4, 3 },
   { OSUTF8("sf8"), 5, 3, 7 }
} ;
#define utran_E_DPDCH_MaxChannelisationCodes_ENUMTABSIZE 10

const OSUTF8CHAR* utran_E_DPDCH_MaxChannelisationCodes_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DPDCH_MaxChannelisationCodes_ENUMTABSIZE) {
      return utran_E_DPDCH_MaxChannelisationCodes_ENUMTAB
         [utran_E_DPDCH_MaxChannelisationCodes_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DPDCH_MaxChannelisationCodes_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_E_DPDCH_MaxChannelisationCodes* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DPDCH_MaxChannelisationCodes_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DPDCH_MaxChannelisationCodes_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DPDCH_MaxChannelisationCodes* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DPDCH_MaxChannelisationCodes_ENUMTAB, 
      utran_E_DPDCH_MaxChannelisationCodes_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_DPDCH_MaxChannelisationCodes)
         utran_E_DPDCH_MaxChannelisationCodes_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTAB[] = {
   { OSUTF8("everyEDCHTTI"), 0, 12, 0 },
   { OSUTF8("ms10"), 2, 4, 6 },
   { OSUTF8("ms100"), 5, 5, 1 },
   { OSUTF8("ms1000"), 8, 6, 4 },
   { OSUTF8("ms20"), 3, 4, 7 },
   { OSUTF8("ms200"), 6, 5, 2 },
   { OSUTF8("ms4"), 1, 3, 5 },
   { OSUTF8("ms50"), 4, 4, 8 },
   { OSUTF8("ms500"), 7, 5, 3 }
} ;
#define utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTABSIZE 9

const OSUTF8CHAR* utran_E_DPDCH_PeriodicyOfSchedInfo_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTABSIZE) {
      return utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTAB
         [utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DPDCH_PeriodicyOfSchedInfo_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_E_DPDCH_PeriodicyOfSchedInfo* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DPDCH_PeriodicyOfSchedInfo_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DPDCH_PeriodicyOfSchedInfo_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DPDCH_PeriodicyOfSchedInfo* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTAB, 
      utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_DPDCH_PeriodicyOfSchedInfo)
         utran_E_DPDCH_PeriodicyOfSchedInfo_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DPDCH_SchedulingInfoConfiguration (
   utran_E_DPDCH_SchedulingInfoConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_DPDCH_Info (utran_E_DPDCH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_DPDCH_SchedulingInfoConfiguration (&pvalue->schedulingInfoConfiguration);
}

void asn1Free_utran_E_DPDCH_Info (OSCTXT *pctxt, utran_E_DPDCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_DPDCH_Reference_E_TFCIList (pctxt, &pvalue->reference_E_TFCIs);
}

static const OSEnumItem utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[] = {
   { OSUTF8("primary"), 0, 7, 0 },
   { OSUTF8("secondary"), 1, 9, 1 }
} ;
#define utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE) {
      return utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTAB
         [utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTAB, 
      utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector)
         utran_E_DPDCH_SchedulingTransmConfiguration_servingGrant_primary_Secondary_GrantSelector_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (
   utran_E_DPDCH_SchedulingTransmConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ms2_SchedTransmGrantHARQAlloc.numbits = 0;
}

void asn1Init_utran_UL_EDCH_Information_r6 (
   utran_UL_EDCH_Information_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPDCH_Info (&pvalue->e_DPDCH_Info);
   asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (&pvalue->schedulingTransmConfiguration);
}

void asn1Free_utran_UL_EDCH_Information_r6 (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DPDCH_InfoPresent) {
      asn1Free_utran_E_DPDCH_Info (pctxt, &pvalue->e_DPDCH_Info);
   }
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_fdd_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD384_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD384_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD384_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

static const OSEnumItem utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB
         [utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB, 
      utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size)
         utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SCCH_TDD128_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SCCH_TDD128_r6*)pnode->data;
      asn1Free_utran_HS_SCCH_TDD128_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (&pvalue->hS_SCCH_SetConfiguration);
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128_hS_SCCH_SetConfiguration (pctxt, &pvalue->hS_SCCH_SetConfiguration);
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo (
   utran_HS_SCCH_Info_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r6 (utran_HS_SCCH_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_HS_SCCH_Info_r6 (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_HSPDSCH_TS_Configuration (&pvalue->dl_HSPDSCH_TS_Configuration);
}

void asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_HSPDSCH_TS_ConfigurationPresent) {
      asn1Free_utran_DL_HSPDSCH_TS_Configuration (pctxt, &pvalue->dl_HSPDSCH_TS_Configuration);
   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_PDSCH_Midamble_Configuration_TDD128 (&pvalue->hs_PDSCH_Midamble_Configuration_tdd128);
}

void asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r6 (
   utran_DL_HSPDSCH_Information_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r6 (&pvalue->hs_scch_Info);
   asn1Init_utran_Measurement_Feedback_Info (&pvalue->measurement_feedback_Info);
   asn1Init_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r6 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r6 (pctxt, &pvalue->hs_scch_Info);
   }
   if (pvalue->m.measurement_feedback_InfoPresent) {
      asn1Free_utran_Measurement_Feedback_Info (pctxt, &pvalue->measurement_feedback_Info);
   }
   asn1Free_utran_DL_HSPDSCH_Information_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_TimingMaintainedSynchInd_ENUMTAB[] = {
   { OSUTF8("false"), 0, 5, 0 }
} ;
#define utran_TimingMaintainedSynchInd_ENUMTABSIZE 1

const OSUTF8CHAR* utran_TimingMaintainedSynchInd_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_TimingMaintainedSynchInd_ENUMTAB, 
      utran_TimingMaintainedSynchInd_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_TimingMaintainedSynchInd_ENUMTABSIZE) {
      return utran_TimingMaintainedSynchInd_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimingMaintainedSynchInd_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimingMaintainedSynchInd* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimingMaintainedSynchInd_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimingMaintainedSynchInd_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TimingMaintainedSynchInd* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimingMaintainedSynchInd_ENUMTAB, 
      utran_TimingMaintainedSynchInd_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimingMaintainedSynchInd)
         utran_TimingMaintainedSynchInd_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain (
   utran_DL_DPCH_InfoCommon_r6_cfnHandling_maintain* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6_cfnHandling (
   utran_DL_DPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r6_cfnHandling (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.maintain) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.maintain);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
   asn1Init_utran_Dl_rate_matching_restriction (&pvalue->dl_rate_matching_restriction);
   asn1Init_utran_SF512_AndPilot (&pvalue->spreadingFactorAndPilot);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
   if (pvalue->m.dl_rate_matching_restrictionPresent) {
      asn1Free_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r6 (utran_DL_DPCH_InfoCommon_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon_r6_cfnHandling (&pvalue->cfnHandling);
   asn1Init_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_MAC_d_HFN_initial_value (&pvalue->mac_d_HFN_initial_value);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r6 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoCommon_r6_cfnHandling (pctxt, &pvalue->cfnHandling);
   asn1Free_utran_DL_DPCH_InfoCommon_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain (
   utran_DL_FDPCH_InfoCommon_r6_cfnHandling_maintain* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (
   utran_DL_FDPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (OSCTXT *pctxt, 
   utran_DL_FDPCH_InfoCommon_r6_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.maintain) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.maintain);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_FDPCH_InfoCommon_r6 (
   utran_DL_FDPCH_InfoCommon_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (&pvalue->cfnHandling);
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_FDPCH_PowerControlInfo);
}

void asn1Free_utran_DL_FDPCH_InfoCommon_r6 (OSCTXT *pctxt, 
   utran_DL_FDPCH_InfoCommon_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_FDPCH_InfoCommon_r6_cfnHandling (pctxt, &pvalue->cfnHandling);
   if (pvalue->m.dl_FDPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_FDPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r6_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo (
   utran_DL_CommonInformation_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r6_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r6_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r6_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r6_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r6_mac_hsResetIndicator)
         utran_DL_CommonInformation_r6_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r6_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r6_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r6_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r6_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r6_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r6_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r6_postVerificationPeriod)
         utran_DL_CommonInformation_r6_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r6 (
   utran_DL_CommonInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r6 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r6_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r6_modeSpecificInfo (
   utran_DL_InformationPerRL_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r6_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r6_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r6_fdd (
   utran_DL_DPCH_InfoPerRL_r6_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r6_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r6_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r6_tdd (
   utran_DL_DPCH_InfoPerRL_r6_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r4 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r6_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r6_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r4 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r6 (utran_DL_DPCH_InfoPerRL_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r6 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r6_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r6_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r6_dl_dpchInfo (
   utran_DL_InformationPerRL_r6_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r6_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r6_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r6 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r6_e_HICH_Info (
   utran_DL_InformationPerRL_r6_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r6_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r6_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r6_e_RGCH_Info (
   utran_DL_InformationPerRL_r6_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r6_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r6_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r6 (
   utran_DL_InformationPerRL_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r6_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r6_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_DL_InformationPerRL_r6_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r6_e_RGCH_Info (&pvalue->e_RGCH_Info);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r6 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r6_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r6_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r6_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r6_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_List_r6 (
   utran_DL_InformationPerRL_List_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r6 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r6*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_InformationPerRL_v6b0ext (
   utran_DL_InformationPerRL_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_InformationPerRL_List_v6b0ext (
   utran_DL_InformationPerRL_List_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_v6b0ext (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_v6b0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_IntegrityProtectionAlgorithm_r7_ENUMTAB[] = {
   { OSUTF8("uia1"), 0, 4, 0 },
   { OSUTF8("uia2"), 1, 4, 1 }
} ;
#define utran_IntegrityProtectionAlgorithm_r7_ENUMTABSIZE 2

const OSUTF8CHAR* utran_IntegrityProtectionAlgorithm_r7_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_IntegrityProtectionAlgorithm_r7_ENUMTABSIZE) {
      return utran_IntegrityProtectionAlgorithm_r7_ENUMTAB
         [utran_IntegrityProtectionAlgorithm_r7_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_IntegrityProtectionAlgorithm_r7_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_IntegrityProtectionAlgorithm_r7* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_IntegrityProtectionAlgorithm_r7_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_IntegrityProtectionAlgorithm_r7_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_IntegrityProtectionAlgorithm_r7* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_IntegrityProtectionAlgorithm_r7_ENUMTAB, 
      utran_IntegrityProtectionAlgorithm_r7_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_IntegrityProtectionAlgorithm_r7)
         utran_IntegrityProtectionAlgorithm_r7_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_IntegrityProtectionModeInfo_r7 (
   utran_IntegrityProtectionModeInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IntegrityProtectionModeCommand (&pvalue->integrityProtectionModeCommand);
}

void asn1Free_utran_IntegrityProtectionModeInfo_r7 (OSCTXT *pctxt, 
   utran_IntegrityProtectionModeInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IntegrityProtectionModeCommand (pctxt, &pvalue->integrityProtectionModeCommand);
}

static const OSEnumItem utran_CipheringAlgorithm_r7_ENUMTAB[] = {
   { OSUTF8("uea0"), 0, 4, 0 },
   { OSUTF8("uea1"), 1, 4, 1 },
   { OSUTF8("uea2"), 2, 4, 2 }
} ;
#define utran_CipheringAlgorithm_r7_ENUMTABSIZE 3

const OSUTF8CHAR* utran_CipheringAlgorithm_r7_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CipheringAlgorithm_r7_ENUMTABSIZE) {
      return utran_CipheringAlgorithm_r7_ENUMTAB
         [utran_CipheringAlgorithm_r7_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CipheringAlgorithm_r7_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_CipheringAlgorithm_r7* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CipheringAlgorithm_r7_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CipheringAlgorithm_r7_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CipheringAlgorithm_r7* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CipheringAlgorithm_r7_ENUMTAB, 
      utran_CipheringAlgorithm_r7_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CipheringAlgorithm_r7)
         utran_CipheringAlgorithm_r7_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CipheringModeInfo_r7 (utran_CipheringModeInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RB_ActivationTimeInfoList (&pvalue->rb_DL_CiphActivationTimeInfo);
}

void asn1Free_utran_CipheringModeInfo_r7 (OSCTXT *pctxt, 
   utran_CipheringModeInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.rb_DL_CiphActivationTimeInfoPresent) {
      asn1Free_utran_RB_ActivationTimeInfoList (pctxt, &pvalue->rb_DL_CiphActivationTimeInfo);
   }
}

static const OSEnumItem utran_T_319_ENUMTAB[] = {
   { OSUTF8("ms1280"), 4, 6, 6 },
   { OSUTF8("ms160"), 1, 5, 1 },
   { OSUTF8("ms2560"), 5, 6, 3 },
   { OSUTF8("ms320"), 2, 5, 5 },
   { OSUTF8("ms5120"), 6, 6, 0 },
   { OSUTF8("ms640"), 3, 5, 2 },
   { OSUTF8("ms80"), 0, 4, 4 }
} ;
#define utran_T_319_ENUMTABSIZE 7

const OSUTF8CHAR* utran_T_319_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_T_319_ENUMTABSIZE) {
      return utran_T_319_ENUMTAB[utran_T_319_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_T_319_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_T_319* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_T_319_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_T_319_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_T_319* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_T_319_ENUMTAB, 
      utran_T_319_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_T_319)utran_T_319_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UTRAN_DRX_CycleLengthCoefficient_r7 (
   utran_UTRAN_DRX_CycleLengthCoefficient_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTAB[] = {
   { OSUTF8("size15"), 1, 6, 1 },
   { OSUTF8("size7"), 0, 5, 0 }
} ;
#define utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE) {
      return utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTAB
         [utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTAB, 
      utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize)
         utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size_flexibleSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (
   utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (OSCTXT *pctxt, 
   utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fixedSize) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.fixedSize);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fixedSize);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_AM_RLC_Mode_r7 (utran_DL_AM_RLC_Mode_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (&pvalue->dl_RLC_PDU_size);
   asn1Init_utran_DL_RLC_StatusInfo (&pvalue->dl_RLC_StatusInfo);
}

void asn1Free_utran_DL_AM_RLC_Mode_r7 (OSCTXT *pctxt, 
   utran_DL_AM_RLC_Mode_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AM_RLC_Mode_r7_dl_RLC_PDU_size (pctxt, &pvalue->dl_RLC_PDU_size);
}

void asn1Init_utran_DL_RLC_Mode_r7 (utran_DL_RLC_Mode_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_RLC_Mode_r7 (OSCTXT *pctxt, 
   utran_DL_RLC_Mode_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_AM_RLC_Mode) {
            asn1Free_utran_DL_AM_RLC_Mode_r7 (pctxt, pvalue->u.dl_AM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_AM_RLC_Mode);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_UM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_UM_RLC_Mode);
         }
         break;

      case 3:
         if (0 != pvalue->u.dl_TM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_TM_RLC_Mode);
         }
         break;

   }
}

static const OSEnumItem utran_RLC_Info_r7_altE_bitInterpretation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_RLC_Info_r7_altE_bitInterpretation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_RLC_Info_r7_altE_bitInterpretation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_RLC_Info_r7_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r7_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_RLC_Info_r7_altE_bitInterpretation_ENUMTABSIZE) {
      return utran_RLC_Info_r7_altE_bitInterpretation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_Info_r7_altE_bitInterpretation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RLC_Info_r7_altE_bitInterpretation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_Info_r7_altE_bitInterpretation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_Info_r7_altE_bitInterpretation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_Info_r7_altE_bitInterpretation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_Info_r7_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r7_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_Info_r7_altE_bitInterpretation)
         utran_RLC_Info_r7_altE_bitInterpretation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTABSIZE 1

const OSUTF8CHAR* utran_RLC_Info_r7_useSpecialValueOfHEField_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTAB, 
      utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTABSIZE) {
      return utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_Info_r7_useSpecialValueOfHEField_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RLC_Info_r7_useSpecialValueOfHEField* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_Info_r7_useSpecialValueOfHEField_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_Info_r7_useSpecialValueOfHEField_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_Info_r7_useSpecialValueOfHEField* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTAB, 
      utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_Info_r7_useSpecialValueOfHEField)
         utran_RLC_Info_r7_useSpecialValueOfHEField_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RLC_Info_r7 (utran_RLC_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_RLC_Mode (&pvalue->ul_RLC_Mode);
   asn1Init_utran_DL_RLC_Mode_r7 (&pvalue->dl_RLC_Mode);
}

void asn1Free_utran_RLC_Info_r7 (OSCTXT *pctxt, utran_RLC_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_RLC_ModePresent) {
      asn1Free_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
   }
   if (pvalue->m.dl_RLC_ModePresent) {
      asn1Free_utran_DL_RLC_Mode_r7 (pctxt, &pvalue->dl_RLC_Mode);
   }
}

void asn1Init_utran_DL_TransportChannelType_r7_hsdsch (
   utran_DL_TransportChannelType_r7_hsdsch* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DL_TransportChannelType_r7_dch_and_hsdsch (
   utran_DL_TransportChannelType_r7_dch_and_hsdsch* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TransportChannelType_r7_dch_and_hsdsch (OSCTXT *pctxt, 
   utran_DL_TransportChannelType_r7_dch_and_hsdsch* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mac_hs) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_hs);
         }
         break;

      case 2:
         if (0 != pvalue->u.mac_ehs) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_ehs);
         }
         break;

   }
}

void asn1Init_utran_DL_TransportChannelType_r7 (
   utran_DL_TransportChannelType_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TransportChannelType_r7 (OSCTXT *pctxt, 
   utran_DL_TransportChannelType_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         break;

      case 4:
         if (0 != pvalue->u.dch_and_dsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_and_dsch);
         }
         break;

      case 5:
         if (0 != pvalue->u.hsdsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

      case 6:
         if (0 != pvalue->u.dch_and_hsdsch) {
            asn1Free_utran_DL_TransportChannelType_r7_dch_and_hsdsch (pctxt, pvalue->u.dch_and_hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_and_hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_LogicalChannelMapping_r7 (
   utran_DL_LogicalChannelMapping_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TransportChannelType_r7 (&pvalue->dl_TransportChannelType);
}

void asn1Free_utran_DL_LogicalChannelMapping_r7 (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMapping_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TransportChannelType_r7 (pctxt, &pvalue->dl_TransportChannelType);
}

void asn1Init_utran_DL_LogicalChannelMappingList_r7 (
   utran_DL_LogicalChannelMappingList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_LogicalChannelMappingList_r7 (OSCTXT *pctxt, 
   utran_DL_LogicalChannelMappingList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_LogicalChannelMapping_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_LogicalChannelMapping_r7*)pnode->data;
      asn1Free_utran_DL_LogicalChannelMapping_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_MappingOption_r7 (utran_RB_MappingOption_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_LogicalChannelMappings_r6 (&pvalue->ul_LogicalChannelMappings);
   asn1Init_utran_DL_LogicalChannelMappingList_r7 (&pvalue->dl_LogicalChannelMappingList);
}

void asn1Free_utran_RB_MappingOption_r7 (OSCTXT *pctxt, 
   utran_RB_MappingOption_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_LogicalChannelMappingsPresent) {
      asn1Free_utran_UL_LogicalChannelMappings_r6 (pctxt, &pvalue->ul_LogicalChannelMappings);
   }
   if (pvalue->m.dl_LogicalChannelMappingListPresent) {
      asn1Free_utran_DL_LogicalChannelMappingList_r7 (pctxt, &pvalue->dl_LogicalChannelMappingList);
   }
}

void asn1Init_utran_RB_MappingInfo_r7 (utran_RB_MappingInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_MappingInfo_r7 (OSCTXT *pctxt, 
   utran_RB_MappingInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_MappingOption_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_MappingOption_r7*)pnode->data;
      asn1Free_utran_RB_MappingOption_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationReconfig_r7 (
   utran_RB_InformationReconfig_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info_r7 (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo_r7 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r7 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info_r7 (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r7 (
   utran_RB_InformationReconfigList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r7 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r7*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationAffected_r7 (
   utran_RB_InformationAffected_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RB_MappingInfo_r7 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationAffected_r7 (OSCTXT *pctxt, 
   utran_RB_InformationAffected_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationAffectedList_r7 (
   utran_RB_InformationAffectedList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationAffectedList_r7 (OSCTXT *pctxt, 
   utran_RB_InformationAffectedList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationAffected_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationAffected_r7*)pnode->data;
      asn1Free_utran_RB_InformationAffected_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r7_dch_usch (
   utran_UL_AddReconfTransChInformation_r7_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r7_dch_usch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r7_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
}

void asn1Init_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (
   utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTAB[] = {
   { OSUTF8("rv0"), 0, 3, 0 },
   { OSUTF8("rvtable"), 1, 7, 1 }
} ;
#define utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTABSIZE) {
      return utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTAB
         [utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTAB, 
      utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info)
         utran_UL_AddReconfTransChInformation_r7_e_dch_harq_Info_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTAB[] = {
   { OSUTF8("ms10"), 0, 4, 0 },
   { OSUTF8("ms100"), 18, 5, 5 },
   { OSUTF8("ms110"), 19, 5, 7 },
   { OSUTF8("ms120"), 20, 5, 10 },
   { OSUTF8("ms140"), 21, 5, 12 },
   { OSUTF8("ms15"), 1, 4, 14 },
   { OSUTF8("ms160"), 22, 5, 15 },
   { OSUTF8("ms20"), 2, 4, 17 },
   { OSUTF8("ms200"), 23, 5, 19 },
   { OSUTF8("ms240"), 24, 5, 20 },
   { OSUTF8("ms25"), 3, 4, 22 },
   { OSUTF8("ms280"), 25, 5, 23 },
   { OSUTF8("ms30"), 4, 4, 24 },
   { OSUTF8("ms320"), 26, 5, 25 },
   { OSUTF8("ms35"), 5, 4, 26 },
   { OSUTF8("ms40"), 6, 4, 27 },
   { OSUTF8("ms400"), 27, 5, 28 },
   { OSUTF8("ms45"), 7, 4, 29 },
   { OSUTF8("ms480"), 28, 5, 1 },
   { OSUTF8("ms50"), 8, 4, 2 },
   { OSUTF8("ms55"), 9, 4, 3 },
   { OSUTF8("ms560"), 29, 5, 4 },
   { OSUTF8("ms60"), 10, 4, 6 },
   { OSUTF8("ms65"), 11, 4, 8 },
   { OSUTF8("ms70"), 12, 4, 9 },
   { OSUTF8("ms75"), 13, 4, 11 },
   { OSUTF8("ms80"), 14, 4, 13 },
   { OSUTF8("ms85"), 15, 4, 16 },
   { OSUTF8("ms90"), 16, 4, 18 },
   { OSUTF8("ms95"), 17, 4, 21 }
} ;
#define utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTABSIZE 30

const OSUTF8CHAR* utran_E_DCH_MAC_d_FlowRetransTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTABSIZE) {
      return utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTAB
         [utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_DCH_MAC_d_FlowRetransTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_E_DCH_MAC_d_FlowRetransTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_DCH_MAC_d_FlowRetransTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_DCH_MAC_d_FlowRetransTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_DCH_MAC_d_FlowRetransTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTAB, 
      utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_DCH_MAC_d_FlowRetransTimer)
         utran_E_DCH_MAC_d_FlowRetransTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd (
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->ms2_NonSchedTransmGrantHARQAlloc.numbits = 0;
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.non_ScheduledTransGrantInfo) {
            asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType_non_ScheduledTransGrantInfo (pctxt, pvalue->u.non_ScheduledTransGrantInfo);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.non_ScheduledTransGrantInfo);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (
   utran_E_DCH_AddReconf_MAC_d_Flow_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_MAC_d_FlowMultiplexingList (&pvalue->mac_d_FlowMultiplexingList);
   asn1Init_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (&pvalue->transmissionGrantType);
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_Flow_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.transmissionGrantTypePresent) {
      asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7_transmissionGrantType (pctxt, &pvalue->transmissionGrantType);
   }
}

void asn1Init_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (
   utran_E_DCH_AddReconf_MAC_d_FlowList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (OSCTXT *pctxt, 
   utran_E_DCH_AddReconf_MAC_d_FlowList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_DCH_AddReconf_MAC_d_Flow_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_DCH_AddReconf_MAC_d_Flow_r7*)pnode->data;
      asn1Free_utran_E_DCH_AddReconf_MAC_d_Flow_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r7_e_dch (
   utran_UL_AddReconfTransChInformation_r7_e_dch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (&pvalue->modeSpecific);
   asn1Init_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (&pvalue->addReconf_MAC_d_FlowList);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r7_e_dch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r7_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_AddReconfTransChInformation_r7_e_dch_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (pvalue->m.addReconf_MAC_d_FlowListPresent) {
      asn1Free_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (pctxt, &pvalue->addReconf_MAC_d_FlowList);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r7 (
   utran_UL_AddReconfTransChInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_AddReconfTransChInformation_r7 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_usch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r7_dch_usch (pctxt, pvalue->u.dch_usch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_usch);
         }
         break;

      case 2:
         if (0 != pvalue->u.e_dch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r7_e_dch (pctxt, pvalue->u.e_dch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_dch);
         }
         break;

   }
}

void asn1Init_utran_UL_AddReconfTransChInfoList_r7 (
   utran_UL_AddReconfTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_AddReconfTransChInfoList_r7 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_AddReconfTransChInformation_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_AddReconfTransChInformation_r7*)pnode->data;
      asn1Free_utran_UL_AddReconfTransChInformation_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_TrCH_TypeId2_r7_hsdsch (
   utran_DL_TrCH_TypeId2_r7_hsdsch* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DL_TrCH_TypeId2_r7 (utran_DL_TrCH_TypeId2_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TrCH_TypeId2_r7 (OSCTXT *pctxt, 
   utran_DL_TrCH_TypeId2_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_TransportChannelIdentity_r7 (
   utran_DL_TransportChannelIdentity_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_TrCH_TypeId2_r7 (&pvalue->dl_TransportChannelType);
}

void asn1Free_utran_DL_TransportChannelIdentity_r7 (OSCTXT *pctxt, 
   utran_DL_TransportChannelIdentity_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TrCH_TypeId2_r7 (pctxt, &pvalue->dl_TransportChannelType);
}

void asn1Init_utran_DL_DeletedTransChInfoList_r7 (
   utran_DL_DeletedTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_DeletedTransChInfoList_r7 (OSCTXT *pctxt, 
   utran_DL_DeletedTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_TransportChannelIdentity_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_TransportChannelIdentity_r7*)pnode->data;
      asn1Free_utran_DL_TransportChannelIdentity_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_Treset_ResetTimer_ENUMTAB[] = {
   { OSUTF8("rt1"), 0, 3, 0 },
   { OSUTF8("rt2"), 1, 3, 1 },
   { OSUTF8("rt3"), 2, 3, 2 },
   { OSUTF8("rt4"), 3, 3, 3 }
} ;
#define utran_Treset_ResetTimer_ENUMTABSIZE 4

const OSUTF8CHAR* utran_Treset_ResetTimer_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Treset_ResetTimer_ENUMTABSIZE) {
      return utran_Treset_ResetTimer_ENUMTAB
         [utran_Treset_ResetTimer_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Treset_ResetTimer_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Treset_ResetTimer* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Treset_ResetTimer_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Treset_ResetTimer_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_Treset_ResetTimer* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Treset_ResetTimer_ENUMTAB, utran_Treset_ResetTimer_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Treset_ResetTimer)
         utran_Treset_ResetTimer_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ (
   utran_MAC_ehs_AddReconfReordQ* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_List (
   utran_MAC_ehs_AddReconfReordQ_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_ehs_AddReconfReordQ_List (OSCTXT *pctxt, 
   utran_MAC_ehs_AddReconfReordQ_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MAC_ehs_DelReordQ_List (
   utran_MAC_ehs_DelReordQ_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_ehs_DelReordQ_List (OSCTXT *pctxt, 
   utran_MAC_ehs_DelReordQ_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AddOrReconfMAC_ehs_ReordQ (
   utran_AddOrReconfMAC_ehs_ReordQ* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_ehs_AddReconfReordQ_List (&pvalue->mac_ehs_AddReconfQueue_List);
   asn1Init_utran_MAC_ehs_DelReordQ_List (&pvalue->dummy);
}

void asn1Free_utran_AddOrReconfMAC_ehs_ReordQ (OSCTXT *pctxt, 
   utran_AddOrReconfMAC_ehs_ReordQ* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_ehs_AddReconfQueue_ListPresent) {
      asn1Free_utran_MAC_ehs_AddReconfReordQ_List (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
   }
   if (pvalue->m.dummyPresent) {
      asn1Free_utran_MAC_ehs_DelReordQ_List (pctxt, &pvalue->dummy);
   }
}

void asn1Init_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (
   utran_HSDSCH_Info_r7_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r7_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mac_hs) {
            asn1Free_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_hs);
         }
         break;

      case 2:
         if (0 != pvalue->u.mac_ehs) {
            asn1Free_utran_AddOrReconfMAC_ehs_ReordQ (pctxt, pvalue->u.mac_ehs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_ehs);
         }
         break;

   }
}

void asn1Init_utran_HSDSCH_Info_r7 (utran_HSDSCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r7 (&pvalue->harqInfo);
   asn1Init_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (&pvalue->dl_MAC_HeaderType);
}

void asn1Free_utran_HSDSCH_Info_r7 (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.dl_MAC_HeaderTypePresent) {
      asn1Free_utran_HSDSCH_Info_r7_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            asn1Free_utran_HSDSCH_Info_r7 (pctxt, pvalue->u.hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r7 (
   utran_DL_AddReconfTransChInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TrCH_TypeId1_r5 (&pvalue->dl_TransportChannelType);
   asn1Init_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r7 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r7_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r7 (
   utran_DL_AddReconfTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r7 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r7*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_Multi_frequencyInfo_LCR_r7 (
   utran_Multi_frequencyInfo_LCR_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_fdd (
   utran_UL_DPCH_PowerControlInfo_r7_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd (
   utran_UL_DPCH_PowerControlInfo_r7_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r7 (
   utran_UL_DPCH_PowerControlInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r7 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r7_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_NumberOfTPC_Bits_ENUMTAB[] = {
   { OSUTF8("tpc4"), 0, 4, 0 }
} ;
#define utran_NumberOfTPC_Bits_ENUMTABSIZE 1

const OSUTF8CHAR* utran_NumberOfTPC_Bits_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, utran_NumberOfTPC_Bits_ENUMTAB, 
      utran_NumberOfTPC_Bits_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_NumberOfTPC_Bits_ENUMTABSIZE) {
      return utran_NumberOfTPC_Bits_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_NumberOfTPC_Bits_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_NumberOfTPC_Bits* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_NumberOfTPC_Bits_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_NumberOfTPC_Bits_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_NumberOfTPC_Bits* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_NumberOfTPC_Bits_ENUMTAB, utran_NumberOfTPC_Bits_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_NumberOfTPC_Bits)
         utran_NumberOfTPC_Bits_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present (
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent (
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.present) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.present);
         }
         break;

      case 2:
         if (0 != pvalue->u.notPresent) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.notPresent);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (&pvalue->dpdchPresence);
}

void asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
}

void asn1Init_utran_EXT_UL_TimingAdvance_modeSpecificInfo (
   utran_EXT_UL_TimingAdvance_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_EXT_UL_TimingAdvance_modeSpecificInfo (OSCTXT *pctxt, 
   utran_EXT_UL_TimingAdvance_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

   }
}

void asn1Init_utran_EXT_UL_TimingAdvance (utran_EXT_UL_TimingAdvance* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_EXT_UL_TimingAdvance_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_EXT_UL_TimingAdvance (OSCTXT *pctxt, 
   utran_EXT_UL_TimingAdvance* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_EXT_UL_TimingAdvance_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_EXT_UL_TimingAdvance (&pvalue->ext_UL_TimingAdvance);
}

void asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ext_UL_TimingAdvancePresent) {
      asn1Free_utran_EXT_UL_TimingAdvance (pctxt, &pvalue->ext_UL_TimingAdvance);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_EXT_UL_TimingAdvance (&pvalue->ext_UL_TimingAdvance);
}

void asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ext_UL_TimingAdvancePresent) {
      asn1Free_utran_EXT_UL_TimingAdvance (pctxt, &pvalue->ext_UL_TimingAdvance);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SynchronisationParameters_r4 (&pvalue->synchronisationParameters);
}

void asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.synchronisationParametersPresent) {
      asn1Free_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7_enabled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_TimingAdvanceControl_r7_enabled (
   utran_UL_TimingAdvanceControl_r7_enabled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_TimingAdvanceControl_r7_enabled (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7_enabled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_TimingAdvanceControl_r7_enabled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_TimingAdvanceControl_r7 (
   utran_UL_TimingAdvanceControl_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl_r7 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.enabled) {
            asn1Free_utran_UL_TimingAdvanceControl_r7_enabled (pctxt, pvalue->u.enabled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enabled);
         }
         break;

   }
}

void asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd384 (
   utran_UL_CCTrCH_r7_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UplinkTimeslotsCodes (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r7_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (
   utran_MidambleShiftAndBurstType_VHCR_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType (
   utran_MidambleShiftAndBurstType_VHCR_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

      case 3:
         if (0 != pvalue->u.type3) {
            asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType_type3 (pctxt, pvalue->u.type3);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type3);
         }
         break;

      case 4:
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_VHCR (
   utran_MidambleShiftAndBurstType_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_VHCR_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType_VHCR (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_VHCR_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_IndividualTimeslotInfo_VHCR (
   utran_IndividualTimeslotInfo_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_VHCR (&pvalue->midambleShiftAndBurstType_VHCR);
}

void asn1Free_utran_IndividualTimeslotInfo_VHCR (OSCTXT *pctxt, 
   utran_IndividualTimeslotInfo_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_VHCR (pctxt, &pvalue->midambleShiftAndBurstType_VHCR);
}

static const OSEnumItem utran_UL_TS_ChannelisationCode_VHCR_ENUMTAB[] = {
   { OSUTF8("cc1-1"), 0, 5, 0 },
   { OSUTF8("cc16-1"), 15, 6, 17 },
   { OSUTF8("cc16-10"), 24, 7, 18 },
   { OSUTF8("cc16-11"), 25, 7, 51 },
   { OSUTF8("cc16-12"), 26, 7, 52 },
   { OSUTF8("cc16-13"), 27, 7, 53 },
   { OSUTF8("cc16-14"), 28, 7, 54 },
   { OSUTF8("cc16-15"), 29, 7, 55 },
   { OSUTF8("cc16-16"), 30, 7, 56 },
   { OSUTF8("cc16-2"), 16, 6, 57 },
   { OSUTF8("cc16-3"), 17, 6, 58 },
   { OSUTF8("cc16-4"), 18, 6, 59 },
   { OSUTF8("cc16-5"), 19, 6, 60 },
   { OSUTF8("cc16-6"), 20, 6, 61 },
   { OSUTF8("cc16-7"), 21, 6, 62 },
   { OSUTF8("cc16-8"), 22, 6, 1 },
   { OSUTF8("cc16-9"), 23, 6, 9 },
   { OSUTF8("cc2-1"), 1, 5, 10 },
   { OSUTF8("cc2-2"), 2, 5, 11 },
   { OSUTF8("cc32-1"), 31, 6, 12 },
   { OSUTF8("cc32-10"), 40, 7, 13 },
   { OSUTF8("cc32-11"), 41, 7, 14 },
   { OSUTF8("cc32-12"), 42, 7, 15 },
   { OSUTF8("cc32-13"), 43, 7, 16 },
   { OSUTF8("cc32-14"), 44, 7, 2 },
   { OSUTF8("cc32-15"), 45, 7, 3 },
   { OSUTF8("cc32-16"), 46, 7, 4 },
   { OSUTF8("cc32-17"), 47, 7, 5 },
   { OSUTF8("cc32-18"), 48, 7, 6 },
   { OSUTF8("cc32-19"), 49, 7, 7 },
   { OSUTF8("cc32-2"), 32, 6, 8 },
   { OSUTF8("cc32-20"), 50, 7, 19 },
   { OSUTF8("cc32-21"), 51, 7, 30 },
   { OSUTF8("cc32-22"), 52, 7, 41 },
   { OSUTF8("cc32-23"), 53, 7, 45 },
   { OSUTF8("cc32-24"), 54, 7, 46 },
   { OSUTF8("cc32-25"), 55, 7, 47 },
   { OSUTF8("cc32-26"), 56, 7, 48 },
   { OSUTF8("cc32-27"), 57, 7, 49 },
   { OSUTF8("cc32-28"), 58, 7, 50 },
   { OSUTF8("cc32-29"), 59, 7, 20 },
   { OSUTF8("cc32-3"), 33, 6, 21 },
   { OSUTF8("cc32-30"), 60, 7, 22 },
   { OSUTF8("cc32-31"), 61, 7, 23 },
   { OSUTF8("cc32-32"), 62, 7, 24 },
   { OSUTF8("cc32-4"), 34, 6, 25 },
   { OSUTF8("cc32-5"), 35, 6, 26 },
   { OSUTF8("cc32-6"), 36, 6, 27 },
   { OSUTF8("cc32-7"), 37, 6, 28 },
   { OSUTF8("cc32-8"), 38, 6, 29 },
   { OSUTF8("cc32-9"), 39, 6, 31 },
   { OSUTF8("cc4-1"), 3, 5, 32 },
   { OSUTF8("cc4-2"), 4, 5, 33 },
   { OSUTF8("cc4-3"), 5, 5, 34 },
   { OSUTF8("cc4-4"), 6, 5, 35 },
   { OSUTF8("cc8-1"), 7, 5, 36 },
   { OSUTF8("cc8-2"), 8, 5, 37 },
   { OSUTF8("cc8-3"), 9, 5, 38 },
   { OSUTF8("cc8-4"), 10, 5, 39 },
   { OSUTF8("cc8-5"), 11, 5, 40 },
   { OSUTF8("cc8-6"), 12, 5, 42 },
   { OSUTF8("cc8-7"), 13, 5, 43 },
   { OSUTF8("cc8-8"), 14, 5, 44 }
} ;
#define utran_UL_TS_ChannelisationCode_VHCR_ENUMTABSIZE 63

const OSUTF8CHAR* utran_UL_TS_ChannelisationCode_VHCR_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_TS_ChannelisationCode_VHCR_ENUMTABSIZE) {
      return utran_UL_TS_ChannelisationCode_VHCR_ENUMTAB
         [utran_UL_TS_ChannelisationCode_VHCR_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_TS_ChannelisationCode_VHCR_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_TS_ChannelisationCode_VHCR* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_TS_ChannelisationCode_VHCR_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_TS_ChannelisationCode_VHCR_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_TS_ChannelisationCode_VHCR* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_TS_ChannelisationCode_VHCR_ENUMTAB, 
      utran_UL_TS_ChannelisationCode_VHCR_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_TS_ChannelisationCode_VHCR)
         utran_UL_TS_ChannelisationCode_VHCR_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_TS_ChannelisationCodeList_VHCR (
   utran_UL_TS_ChannelisationCodeList_VHCR* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (
   utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_VHCR (&pvalue->individualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList (&pvalue->ul_TS_ChannelisationCodeList);
}

void asn1Free_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->individualTimeslotInfo);
}

void asn1Init_utran_UplinkAdditionalTimeslots_VHCR_parameters (
   utran_UplinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkAdditionalTimeslots_VHCR_parameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_UplinkAdditionalTimeslots_VHCR_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_UplinkAdditionalTimeslots_VHCR (
   utran_UplinkAdditionalTimeslots_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UplinkAdditionalTimeslots_VHCR_parameters (&pvalue->parameters);
}

void asn1Free_utran_UplinkAdditionalTimeslots_VHCR (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UplinkAdditionalTimeslots_VHCR_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UplinkAdditionalTimeslots_VHCR* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UplinkAdditionalTimeslots_VHCR*)pnode->data;
      asn1Free_utran_UplinkAdditionalTimeslots_VHCR (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_VHCR (
   utran_UplinkTimeslotsCodes_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_VHCR (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList_VHCR (&pvalue->ul_TS_ChannelisationCodeList);
   asn1Init_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_UplinkTimeslotsCodes_VHCR (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_UplinkTimeslotsCodes_VHCR_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd768 (
   utran_UL_CCTrCH_r7_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UplinkTimeslotsCodes_VHCR (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd768 (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r7_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes_VHCR (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_UL_TS_ChannelisationCodeList_r7_element (
   utran_UL_TS_ChannelisationCodeList_r7_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_TS_ChannelisationCodeList_r7 (
   utran_UL_TS_ChannelisationCodeList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_TS_ChannelisationCodeList_r7 (OSCTXT *pctxt, 
   utran_UL_TS_ChannelisationCodeList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (
   utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->individualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList_r7 (&pvalue->ul_TS_ChannelisationCodeList);
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->individualTimeslotInfo);
   asn1Free_utran_UL_TS_ChannelisationCodeList_r7 (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (
   utran_UplinkAdditionalTimeslots_LCR_r7_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r7_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7 (
   utran_UplinkAdditionalTimeslots_LCR_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (&pvalue->parameters);
}

void asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7 (OSCTXT *pctxt, 
   utran_UplinkAdditionalTimeslots_LCR_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_UplinkAdditionalTimeslots_LCR_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UplinkAdditionalTimeslots_LCR_r7*)pnode->data;
      asn1Free_utran_UplinkAdditionalTimeslots_LCR_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_UplinkTimeslotsCodes_LCR_r7 (
   utran_UplinkTimeslotsCodes_LCR_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_LCR_r4 (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_UL_TS_ChannelisationCodeList_r7 (&pvalue->ul_TS_ChannelisationCodeList);
   asn1Init_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_UplinkTimeslotsCodes_LCR_r7 (OSCTXT *pctxt, 
   utran_UplinkTimeslotsCodes_LCR_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_LCR_r4 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_UL_TS_ChannelisationCodeList_r7 (pctxt, &pvalue->ul_TS_ChannelisationCodeList);
   asn1Free_utran_UplinkTimeslotsCodes_LCR_r7_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_UL_CCTrCH_r7_tddOption_tdd128 (
   utran_UL_CCTrCH_r7_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UplinkTimeslotsCodes_LCR_r7 (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r7_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_UplinkTimeslotsCodes_LCR_r7 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_UL_CCTrCH_r7_tddOption (
   utran_UL_CCTrCH_r7_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CCTrCH_r7_tddOption (OSCTXT *pctxt, 
   utran_UL_CCTrCH_r7_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_UL_CCTrCH_r7_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_CCTrCH_r7 (utran_UL_CCTrCH_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_UL_CCTrCH_r7_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_CCTrCH_r7 (OSCTXT *pctxt, utran_UL_CCTrCH_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_CCTrCH_r7_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_CCTrCHList_r7 (utran_UL_CCTrCHList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_CCTrCHList_r7 (OSCTXT *pctxt, 
   utran_UL_CCTrCHList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_CCTrCH_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_CCTrCH_r7*)pnode->data;
      asn1Free_utran_UL_CCTrCH_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_r7 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList_r7 (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_r7 (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList_r7 (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo (
   utran_UL_DPCH_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r7 (utran_UL_DPCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r7 (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info_r7 (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_r7 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator)
         utran_UL_EDCH_Information_r7_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DPCCH_Info_r7 (utran_E_DPCCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_TFC_Boost_Info_r7 (&pvalue->e_TFC_Boost_Info);
}

void asn1Init_utran_E_DPDCH_Info_r7 (utran_E_DPDCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_DPDCH_SchedulingInfoConfiguration (&pvalue->schedulingInfoConfiguration);
}

void asn1Free_utran_E_DPDCH_Info_r7 (OSCTXT *pctxt, 
   utran_E_DPDCH_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
}

void asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (
   utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPCCH_Info_r7 (&pvalue->e_DPCCH_Info);
   asn1Init_utran_E_DPDCH_Info_r7 (&pvalue->e_DPDCH_Info);
   asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (&pvalue->schedulingTransmConfiguration);
}

void asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DPDCH_InfoPresent) {
      asn1Free_utran_E_DPDCH_Info_r7 (pctxt, &pvalue->e_DPDCH_Info);
   }
}

static const OSEnumItem utran_PersistenceScalingFactor_ENUMTAB[] = {
   { OSUTF8("psf0-2"), 7, 6, 7 },
   { OSUTF8("psf0-3"), 6, 6, 6 },
   { OSUTF8("psf0-4"), 5, 6, 5 },
   { OSUTF8("psf0-5"), 4, 6, 4 },
   { OSUTF8("psf0-6"), 3, 6, 3 },
   { OSUTF8("psf0-7"), 2, 6, 2 },
   { OSUTF8("psf0-8"), 1, 6, 1 },
   { OSUTF8("psf0-9"), 0, 6, 0 }
} ;
#define utran_PersistenceScalingFactor_ENUMTABSIZE 8

const OSUTF8CHAR* utran_PersistenceScalingFactor_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PersistenceScalingFactor_ENUMTABSIZE) {
      return utran_PersistenceScalingFactor_ENUMTAB
         [utran_PersistenceScalingFactor_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PersistenceScalingFactor_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PersistenceScalingFactor* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PersistenceScalingFactor_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PersistenceScalingFactor_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PersistenceScalingFactor* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PersistenceScalingFactor_ENUMTAB, 
      utran_PersistenceScalingFactor_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PersistenceScalingFactor)
         utran_PersistenceScalingFactor_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTAB[] = {
   { OSUTF8("ms120"), 2, 5, 6 },
   { OSUTF8("ms160"), 3, 5, 7 },
   { OSUTF8("ms200"), 4, 5, 0 },
   { OSUTF8("ms240"), 5, 5, 1 },
   { OSUTF8("ms280"), 6, 5, 2 },
   { OSUTF8("ms320"), 7, 5, 3 },
   { OSUTF8("ms40"), 0, 4, 4 },
   { OSUTF8("ms80"), 1, 4, 5 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTABSIZE 8

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_RUCCH_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTAB[] = {
   { OSUTF8("direct"), 0, 6, 0 },
   { OSUTF8("direct-Inverted"), 1, 15, 1 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_e_RUCCH_Midamble_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTAB[] = {
   { OSUTF8("infinity"), 7, 8, 1 },
   { OSUTF8("sec1"), 0, 4, 4 },
   { OSUTF8("sec128"), 6, 6, 6 },
   { OSUTF8("sec16"), 4, 5, 7 },
   { OSUTF8("sec2"), 1, 4, 3 },
   { OSUTF8("sec32"), 5, 5, 5 },
   { OSUTF8("sec4"), 2, 4, 2 },
   { OSUTF8("sec8"), 3, 4, 0 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTABSIZE 8

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_adv_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTAB[] = {
   { OSUTF8("ms160"), 3, 5, 7 },
   { OSUTF8("ms250"), 4, 5, 2 },
   { OSUTF8("ms40"), 1, 4, 3 },
   { OSUTF8("ms80"), 2, 4, 0 },
   { OSUTF8("sec1"), 5, 4, 1 },
   { OSUTF8("sec2"), 6, 4, 4 },
   { OSUTF8("sec4"), 7, 4, 5 },
   { OSUTF8("zero"), 0, 4, 6 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTABSIZE 8

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_t_SCHED_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_SF16Codes_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-2"), 1, 6, 1 },
   { OSUTF8("cc16-3"), 2, 6, 2 },
   { OSUTF8("cc16-4"), 3, 6, 3 },
   { OSUTF8("cc16-5"), 4, 6, 4 },
   { OSUTF8("cc16-6"), 5, 6, 5 },
   { OSUTF8("cc16-7"), 6, 6, 6 },
   { OSUTF8("cc16-8"), 7, 6, 7 }
} ;
#define utran_SF16Codes_ENUMTABSIZE 8

const OSUTF8CHAR* utran_SF16Codes_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SF16Codes_ENUMTABSIZE) {
      return utran_SF16Codes_ENUMTAB
         [utran_SF16Codes_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SF16Codes_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SF16Codes* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SF16Codes_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SF16Codes_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SF16Codes* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SF16Codes_ENUMTAB, 
      utran_SF16Codes_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SF16Codes)utran_SF16Codes_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF16* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_SF8Codes_ENUMTAB[] = {
   { OSUTF8("cc8-1"), 0, 5, 0 },
   { OSUTF8("cc8-2"), 1, 5, 1 },
   { OSUTF8("cc8-3"), 2, 5, 2 },
   { OSUTF8("cc8-4"), 3, 5, 3 },
   { OSUTF8("cc8-5"), 4, 5, 4 },
   { OSUTF8("cc8-6"), 5, 5, 5 },
   { OSUTF8("cc8-7"), 6, 5, 6 },
   { OSUTF8("cc8-8"), 7, 5, 7 }
} ;
#define utran_SF8Codes_ENUMTABSIZE 8

const OSUTF8CHAR* utran_SF8Codes_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SF8Codes_ENUMTABSIZE) {
      return utran_SF8Codes_ENUMTAB
         [utran_SF8Codes_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SF8Codes_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SF8Codes* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SF8Codes_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SF8Codes_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SF8Codes* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SF8Codes_ENUMTAB, 
      utran_SF8Codes_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SF8Codes)utran_SF8Codes_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384_sF8* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sF16) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sF16);
         }
         break;

      case 2:
         if (0 != pvalue->u.sF8) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sF8);
         }
         break;

   }
}

static const OSEnumItem utran_SF32Codes_ENUMTAB[] = {
   { OSUTF8("cc32-1"), 0, 6, 0 },
   { OSUTF8("cc32-10"), 9, 7, 8 },
   { OSUTF8("cc32-11"), 10, 7, 9 },
   { OSUTF8("cc32-12"), 11, 7, 10 },
   { OSUTF8("cc32-13"), 12, 7, 11 },
   { OSUTF8("cc32-14"), 13, 7, 12 },
   { OSUTF8("cc32-15"), 14, 7, 13 },
   { OSUTF8("cc32-16"), 15, 7, 14 },
   { OSUTF8("cc32-2"), 1, 6, 15 },
   { OSUTF8("cc32-3"), 2, 6, 1 },
   { OSUTF8("cc32-4"), 3, 6, 2 },
   { OSUTF8("cc32-5"), 4, 6, 3 },
   { OSUTF8("cc32-6"), 5, 6, 4 },
   { OSUTF8("cc32-7"), 6, 6, 5 },
   { OSUTF8("cc32-8"), 7, 6, 6 },
   { OSUTF8("cc32-9"), 8, 6, 7 }
} ;
#define utran_SF32Codes_ENUMTABSIZE 16

const OSUTF8CHAR* utran_SF32Codes_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SF32Codes_ENUMTABSIZE) {
      return utran_SF32Codes_ENUMTAB
         [utran_SF32Codes_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SF32Codes_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SF32Codes* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SF32Codes_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SF32Codes_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SF32Codes* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SF32Codes_ENUMTAB, 
      utran_SF32Codes_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SF32Codes)utran_SF32Codes_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF32* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_SF16Codes2_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 0, 6, 0 },
   { OSUTF8("cc16-10"), 9, 7, 8 },
   { OSUTF8("cc16-11"), 10, 7, 9 },
   { OSUTF8("cc16-12"), 11, 7, 10 },
   { OSUTF8("cc16-13"), 12, 7, 11 },
   { OSUTF8("cc16-14"), 13, 7, 12 },
   { OSUTF8("cc16-15"), 14, 7, 13 },
   { OSUTF8("cc16-16"), 15, 7, 14 },
   { OSUTF8("cc16-2"), 1, 6, 15 },
   { OSUTF8("cc16-3"), 2, 6, 1 },
   { OSUTF8("cc16-4"), 3, 6, 2 },
   { OSUTF8("cc16-5"), 4, 6, 3 },
   { OSUTF8("cc16-6"), 5, 6, 4 },
   { OSUTF8("cc16-7"), 6, 6, 5 },
   { OSUTF8("cc16-8"), 7, 6, 6 },
   { OSUTF8("cc16-9"), 8, 6, 7 }
} ;
#define utran_SF16Codes2_ENUMTABSIZE 16

const OSUTF8CHAR* utran_SF16Codes2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SF16Codes2_ENUMTABSIZE) {
      return utran_SF16Codes2_ENUMTAB
         [utran_SF16Codes2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SF16Codes2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_SF16Codes2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SF16Codes2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SF16Codes2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_SF16Codes2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_SF16Codes2_ENUMTAB, 
      utran_SF16Codes2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SF16Codes2)utran_SF16Codes2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768_sF816* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sF32) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sF32);
         }
         break;

      case 2:
         if (0 != pvalue->u.sF816) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sF816);
         }
         break;

   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTAB[] = {
   { OSUTF8("ms1000"), 14, 6, 3 },
   { OSUTF8("ms120"), 4, 5, 9 },
   { OSUTF8("ms160"), 5, 5, 12 },
   { OSUTF8("ms20"), 0, 4, 14 },
   { OSUTF8("ms200"), 6, 5, 1 },
   { OSUTF8("ms2000"), 15, 6, 2 },
   { OSUTF8("ms240"), 7, 5, 4 },
   { OSUTF8("ms280"), 8, 5, 6 },
   { OSUTF8("ms320"), 9, 5, 7 },
   { OSUTF8("ms40"), 1, 4, 8 },
   { OSUTF8("ms400"), 10, 5, 10 },
   { OSUTF8("ms500"), 11, 5, 11 },
   { OSUTF8("ms60"), 2, 4, 13 },
   { OSUTF8("ms600"), 12, 5, 15 },
   { OSUTF8("ms80"), 3, 4, 0 },
   { OSUTF8("ms800"), 13, 5, 5 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTABSIZE 16

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_RUCCH_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTAB[] = {
   { OSUTF8("everyEDCHTTI"), 0, 12, 0 },
   { OSUTF8("ms1000"), 6, 6, 5 },
   { OSUTF8("ms160"), 3, 5, 7 },
   { OSUTF8("ms2000"), 7, 6, 2 },
   { OSUTF8("ms320"), 4, 5, 4 },
   { OSUTF8("ms40"), 1, 4, 6 },
   { OSUTF8("ms640"), 5, 5, 1 },
   { OSUTF8("ms80"), 2, 4, 3 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTABSIZE 8

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_WAIT_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTAB[] = {
   { OSUTF8("everyEDCHTTI"), 0, 12, 0 },
   { OSUTF8("ms160"), 5, 5, 2 },
   { OSUTF8("ms20"), 1, 4, 4 },
   { OSUTF8("ms200"), 6, 5, 5 },
   { OSUTF8("ms40"), 2, 4, 6 },
   { OSUTF8("ms60"), 3, 4, 1 },
   { OSUTF8("ms80"), 4, 4, 3 }
} ;
#define utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTABSIZE 7

const OSUTF8CHAR* utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTABSIZE) {
      return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTAB
         [utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTAB, 
      utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI)
         utran_E_RUCCH_Info_modeSpecificInfo_tdd128_t_SI_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics (
   utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

static const OSEnumItem utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTAB[] = {
   { OSUTF8("subch0"), 0, 6, 0 },
   { OSUTF8("subch1"), 1, 6, 1 }
} ;
#define utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTABSIZE 2

const OSUTF8CHAR* utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTABSIZE) {
      return utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTAB
         [utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTAB, 
      utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels)
         utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2_subchannels_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2 (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4 (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size4_subchannels (&pvalue->subchannels);
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8 (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize_size8_subchannels (&pvalue->subchannels);
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (OSCTXT *pctxt, 
   utran_AccessServiceClass_TDD_LCR_r4_subchannelSize* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.size2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.size2);
         }
         break;

      case 3:
         if (0 != pvalue->u.size4) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.size4);
         }
         break;

      case 4:
         if (0 != pvalue->u.size8) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.size8);
         }
         break;

   }
}

void asn1Init_utran_AccessServiceClass_TDD_LCR_r4 (
   utran_AccessServiceClass_TDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AccessServiceClass_TDD_LCR_r4_availableSYNC_UlCodesIndics (&pvalue->availableSYNC_UlCodesIndics);
   asn1Init_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (&pvalue->subchannelSize);
}

void asn1Free_utran_AccessServiceClass_TDD_LCR_r4 (OSCTXT *pctxt, 
   utran_AccessServiceClass_TDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_AccessServiceClass_TDD_LCR_r4_subchannelSize (pctxt, &pvalue->subchannelSize);
}

void asn1Init_utran_ASCSetting_TDD_LCR_r4 (utran_ASCSetting_TDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AccessServiceClass_TDD_LCR_r4 (&pvalue->accessServiceClass_TDD_LCR);
}

void asn1Free_utran_ASCSetting_TDD_LCR_r4 (OSCTXT *pctxt, 
   utran_ASCSetting_TDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.accessServiceClass_TDD_LCRPresent) {
      asn1Free_utran_AccessServiceClass_TDD_LCR_r4 (pctxt, &pvalue->accessServiceClass_TDD_LCR);
   }
}

void asn1Init_utran_PRACH_Partitioning_LCR_r4 (
   utran_PRACH_Partitioning_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PRACH_Partitioning_LCR_r4 (OSCTXT *pctxt, 
   utran_PRACH_Partitioning_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_ASCSetting_TDD_LCR_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_ASCSetting_TDD_LCR_r4*)pnode->data;
      asn1Free_utran_ASCSetting_TDD_LCR_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_RUCCH_AccessServiceClass (
   utran_E_RUCCH_AccessServiceClass* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PRACH_Partitioning_LCR_r4 (pvalue);
}

void asn1Free_utran_E_RUCCH_AccessServiceClass (OSCTXT *pctxt, 
   utran_E_RUCCH_AccessServiceClass* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PRACH_Partitioning_LCR_r4 (pctxt, pvalue);
}

void asn1Init_utran_PersistenceScalingFactorList (
   utran_PersistenceScalingFactorList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTAB[] = {
   { OSUTF8("tr1"), 0, 3, 0 },
   { OSUTF8("tr2"), 1, 3, 1 },
   { OSUTF8("tr4"), 2, 3, 2 },
   { OSUTF8("tr8"), 3, 3, 3 }
} ;
#define utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTABSIZE 4

const OSUTF8CHAR* utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTABSIZE) {
      return utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTAB
         [utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTAB, 
      utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions)
         utran_SYNC_UL_InfoForE_RUCCH_max_SYNC_UL_Transmissions_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Sync_UL_Codes_Bitmap (utran_Sync_UL_Codes_Bitmap* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

void asn1Init_utran_SYNC_UL_InfoForE_RUCCH (
   utran_SYNC_UL_InfoForE_RUCCH* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_Sync_UL_Codes_Bitmap (&pvalue->e_RUCCH_Sync_UL_Codes_Bitmap);
}

static const OSEnumItem utran_TDD_PRACH_CCode_LCR_r4_ENUMTAB[] = {
   { OSUTF8("cc16-1"), 12, 6, 16 },
   { OSUTF8("cc16-10"), 21, 7, 17 },
   { OSUTF8("cc16-11"), 22, 7, 18 },
   { OSUTF8("cc16-12"), 23, 7, 19 },
   { OSUTF8("cc16-13"), 24, 7, 20 },
   { OSUTF8("cc16-14"), 25, 7, 21 },
   { OSUTF8("cc16-15"), 26, 7, 22 },
   { OSUTF8("cc16-16"), 27, 7, 23 },
   { OSUTF8("cc16-2"), 13, 6, 24 },
   { OSUTF8("cc16-3"), 14, 6, 25 },
   { OSUTF8("cc16-4"), 15, 6, 26 },
   { OSUTF8("cc16-5"), 16, 6, 27 },
   { OSUTF8("cc16-6"), 17, 6, 0 },
   { OSUTF8("cc16-7"), 18, 6, 8 },
   { OSUTF8("cc16-8"), 19, 6, 9 },
   { OSUTF8("cc16-9"), 20, 6, 10 },
   { OSUTF8("cc4-1"), 0, 5, 11 },
   { OSUTF8("cc4-2"), 1, 5, 12 },
   { OSUTF8("cc4-3"), 2, 5, 13 },
   { OSUTF8("cc4-4"), 3, 5, 14 },
   { OSUTF8("cc8-1"), 4, 5, 15 },
   { OSUTF8("cc8-2"), 5, 5, 1 },
   { OSUTF8("cc8-3"), 6, 5, 2 },
   { OSUTF8("cc8-4"), 7, 5, 3 },
   { OSUTF8("cc8-5"), 8, 5, 4 },
   { OSUTF8("cc8-6"), 9, 5, 5 },
   { OSUTF8("cc8-7"), 10, 5, 6 },
   { OSUTF8("cc8-8"), 11, 5, 7 }
} ;
#define utran_TDD_PRACH_CCode_LCR_r4_ENUMTABSIZE 28

const OSUTF8CHAR* utran_TDD_PRACH_CCode_LCR_r4_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TDD_PRACH_CCode_LCR_r4_ENUMTABSIZE) {
      return utran_TDD_PRACH_CCode_LCR_r4_ENUMTAB
         [utran_TDD_PRACH_CCode_LCR_r4_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TDD_PRACH_CCode_LCR_r4_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TDD_PRACH_CCode_LCR_r4* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TDD_PRACH_CCode_LCR_r4_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TDD_PRACH_CCode_LCR_r4_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TDD_PRACH_CCode_LCR_r4* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TDD_PRACH_CCode_LCR_r4_ENUMTAB, 
      utran_TDD_PRACH_CCode_LCR_r4_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TDD_PRACH_CCode_LCR_r4)
         utran_TDD_PRACH_CCode_LCR_r4_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PRACH_ChanCodes_List_LCR (
   utran_PRACH_ChanCodes_List_LCR* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_PRACH_Information_LCR (utran_PRACH_Information_LCR* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PRACH_ChanCodes_List_LCR (&pvalue->prach_ChanCodes_list_LCR);
   asn1Init_utran_MidambleShiftAndBurstType_LCR_r4 (&pvalue->midambleShiftAndBurstType);
   asn1Init_utran_FPACH_Info_r4 (&pvalue->fpach_Info);
}

void asn1Free_utran_PRACH_Information_LCR (OSCTXT *pctxt, 
   utran_PRACH_Information_LCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_LCR_r4 (pctxt, &pvalue->midambleShiftAndBurstType);
   if (pvalue->m.fpach_InfoPresent) {
      asn1Free_utran_FPACH_Info_r4 (pctxt, &pvalue->fpach_Info);
   }
}

void asn1Init_utran_PRACH_Information_LCR_List (
   utran_PRACH_Information_LCR_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PRACH_Information_LCR_List (OSCTXT *pctxt, 
   utran_PRACH_Information_LCR_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_PRACH_Information_LCR* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_PRACH_Information_LCR*)pnode->data;
      asn1Free_utran_PRACH_Information_LCR (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (
   utran_E_RUCCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_AccessServiceClass (&pvalue->e_RUCCH_AccessServiceClass);
   asn1Init_utran_PersistenceScalingFactorList (&pvalue->e_RUCCH_PersistenceScalingFactor);
   asn1Init_utran_SYNC_UL_InfoForE_RUCCH (&pvalue->sync_UL_InfoForE_RUCCH);
   asn1Init_utran_PRACH_Information_LCR_List (&pvalue->prach_information);
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RUCCH_AccessServiceClassPresent) {
      asn1Free_utran_E_RUCCH_AccessServiceClass (pctxt, &pvalue->e_RUCCH_AccessServiceClass);
   }
   if (pvalue->m.prach_informationPresent) {
      asn1Free_utran_PRACH_Information_LCR_List (pctxt, &pvalue->prach_information);
   }
}

void asn1Init_utran_E_RUCCH_Info_modeSpecificInfo (
   utran_E_RUCCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_RUCCH_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_E_RUCCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd384_tdd768 (pctxt, pvalue->u.tdd384_tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_E_RUCCH_Info_modeSpecificInfo_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_E_RUCCH_Info (utran_E_RUCCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_RUCCH_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_E_RUCCH_Info (OSCTXT *pctxt, utran_E_RUCCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_RUCCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_E_TFCS_Info_reference_Beta_QPSK_List (
   utran_E_TFCS_Info_reference_Beta_QPSK_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_TFCS_Info_reference_Beta_QPSK_List (OSCTXT *pctxt, 
   utran_E_TFCS_Info_reference_Beta_QPSK_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_TFCS_Info_reference_Beta_16QAM_List (
   utran_E_TFCS_Info_reference_Beta_16QAM_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_TFCS_Info_reference_Beta_16QAM_List (OSCTXT *pctxt, 
   utran_E_TFCS_Info_reference_Beta_16QAM_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_TFCS_Info (utran_E_TFCS_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_TFCS_Info_reference_Beta_QPSK_List (&pvalue->reference_Beta_QPSK_List);
   asn1Init_utran_E_TFCS_Info_reference_Beta_16QAM_List (&pvalue->reference_Beta_16QAM_List);
}

void asn1Free_utran_E_TFCS_Info (OSCTXT *pctxt, utran_E_TFCS_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_TFCS_Info_reference_Beta_QPSK_List (pctxt, &pvalue->reference_Beta_QPSK_List);
   asn1Free_utran_E_TFCS_Info_reference_Beta_16QAM_List (pctxt, &pvalue->reference_Beta_16QAM_List);
}

static const OSEnumItem utran_MidambleConfigurationBurstType1_ENUMTAB[] = {
   { OSUTF8("ms16"), 2, 4, 1 },
   { OSUTF8("ms4"), 0, 3, 2 },
   { OSUTF8("ms8"), 1, 3, 0 }
} ;
#define utran_MidambleConfigurationBurstType1_ENUMTABSIZE 3

const OSUTF8CHAR* utran_MidambleConfigurationBurstType1_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MidambleConfigurationBurstType1_ENUMTABSIZE) {
      return utran_MidambleConfigurationBurstType1_ENUMTAB
         [utran_MidambleConfigurationBurstType1_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MidambleConfigurationBurstType1_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MidambleConfigurationBurstType1* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MidambleConfigurationBurstType1_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MidambleConfigurationBurstType1_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MidambleConfigurationBurstType1* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MidambleConfigurationBurstType1_ENUMTAB, 
      utran_MidambleConfigurationBurstType1_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MidambleConfigurationBurstType1)
         utran_MidambleConfigurationBurstType1_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (
   utran_MidambleShiftAndBurstType_EDCH_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (
   utran_MidambleShiftAndBurstType_EDCH_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType (
   utran_MidambleShiftAndBurstType_EDCH_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_EDCH (
   utran_MidambleShiftAndBurstType_EDCH* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType_EDCH (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_EDCH* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_E_PUCH_TS_Slots (utran_E_PUCH_TS_Slots* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_E_PUCH_TS_Slots (OSCTXT *pctxt, 
   utran_E_PUCH_TS_Slots* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (
   utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (OSCTXT *pctxt, 
   utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_PUCH_TS_Slots* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_PUCH_TS_Slots*)pnode->data;
      asn1Free_utran_E_PUCH_TS_Slots (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (
   utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (&pvalue->e_PUCH_TS_ConfigurationList);
}

void asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (OSCTXT *pctxt, 
   utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
}

static const OSEnumItem utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTAB[] = {
   { OSUTF8("type1"), 0, 5, 0 },
   { OSUTF8("type2"), 1, 5, 1 }
} ;
#define utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTABSIZE) {
      return utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTAB
         [utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTAB, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType)
         utran_E_PUCH_Info_modeSpecificInfo_tdd128_snpl_ReportType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode (
   utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_E_PUCH_TS_Slots_LCR (utran_E_PUCH_TS_Slots_LCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_PUCH_TS_Slots_LCR_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (
   utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (OSCTXT *pctxt, 
   utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTAB[] = {
   { OSUTF8("ms10"), 0, 4, 0 },
   { OSUTF8("ms100"), 18, 5, 5 },
   { OSUTF8("ms110"), 19, 5, 7 },
   { OSUTF8("ms120"), 20, 5, 10 },
   { OSUTF8("ms140"), 21, 5, 12 },
   { OSUTF8("ms15"), 1, 4, 14 },
   { OSUTF8("ms160"), 22, 5, 15 },
   { OSUTF8("ms20"), 2, 4, 17 },
   { OSUTF8("ms200"), 23, 5, 19 },
   { OSUTF8("ms240"), 24, 5, 20 },
   { OSUTF8("ms25"), 3, 4, 22 },
   { OSUTF8("ms280"), 25, 5, 23 },
   { OSUTF8("ms30"), 4, 4, 24 },
   { OSUTF8("ms320"), 26, 5, 25 },
   { OSUTF8("ms35"), 5, 4, 26 },
   { OSUTF8("ms40"), 6, 4, 27 },
   { OSUTF8("ms400"), 27, 5, 28 },
   { OSUTF8("ms45"), 7, 4, 29 },
   { OSUTF8("ms480"), 28, 5, 1 },
   { OSUTF8("ms50"), 8, 4, 2 },
   { OSUTF8("ms55"), 9, 4, 3 },
   { OSUTF8("ms560"), 29, 5, 4 },
   { OSUTF8("ms60"), 10, 4, 6 },
   { OSUTF8("ms65"), 11, 4, 8 },
   { OSUTF8("ms70"), 12, 4, 9 },
   { OSUTF8("ms75"), 13, 4, 11 },
   { OSUTF8("ms80"), 14, 4, 13 },
   { OSUTF8("ms85"), 15, 4, 16 },
   { OSUTF8("ms90"), 16, 4, 18 },
   { OSUTF8("ms95"), 17, 4, 21 }
} ;
#define utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTABSIZE 30

const OSUTF8CHAR* utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTABSIZE) {
      return utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTAB
         [utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTAB, 
      utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo)
         utran_E_PUCH_Info_modeSpecificInfo_tdd128_retransTimerForSchedInfo_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (
   utran_E_PUCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (&pvalue->e_PUCH_TS_ConfigurationList);
}

void asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (OSCTXT *pctxt, 
   utran_E_PUCH_Info_modeSpecificInfo_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd128_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
}

void asn1Init_utran_E_PUCH_Info_modeSpecificInfo (
   utran_E_PUCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_PUCH_Info_modeSpecificInfo (OSCTXT *pctxt, 
   utran_E_PUCH_Info_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd348_tdd768) {
            asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd348_tdd768 (pctxt, pvalue->u.tdd348_tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd348_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_E_PUCH_Info_modeSpecificInfo_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_E_PUCH_Info (utran_E_PUCH_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_TFCS_Info (&pvalue->e_TFCS_Info);
   asn1Init_utran_E_PUCH_Info_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_E_PUCH_Info (OSCTXT *pctxt, utran_E_PUCH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_TFCS_Info (pctxt, &pvalue->e_TFCS_Info);
   asn1Free_utran_E_PUCH_Info_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd384_768 (
   utran_Non_ScheduledTransGrantInfoTDD_tdd384_768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeslotResourceRelatedInfo.numbits = 0;
   asn1Init_utran_RepetitionPeriodAndLength (&pvalue->repetitionPeriodAndLength);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode (
   utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info (
   utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128 (
   utran_Non_ScheduledTransGrantInfoTDD_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeslotResourceRelatedInfo.numbits = 0;
   asn1Init_utran_RepetitionPeriodAndLength (&pvalue->repetitionPeriodAndLength);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_tdd128_e_HICH_Info (&pvalue->e_HICH_Info);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD (
   utran_Non_ScheduledTransGrantInfoTDD* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Non_ScheduledTransGrantInfoTDD (OSCTXT *pctxt, 
   utran_Non_ScheduledTransGrantInfoTDD* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (
   utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_Info (&pvalue->e_RUCCH_Info);
   asn1Init_utran_E_PUCH_Info (&pvalue->e_PUCH_Info);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD (&pvalue->non_ScheduledTransGrantInfo);
}

void asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RUCCH_InfoPresent) {
      asn1Free_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
   }
   if (pvalue->m.e_PUCH_InfoPresent) {
      asn1Free_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
   }
   if (pvalue->m.non_ScheduledTransGrantInfoPresent) {
      asn1Free_utran_Non_ScheduledTransGrantInfoTDD (pctxt, &pvalue->non_ScheduledTransGrantInfo);
   }
}

void asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo (
   utran_UL_EDCH_Information_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r7 (
   utran_UL_EDCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_EDCH_Information_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_EDCH_Information_r7 (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r7_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo (
   utran_DL_CommonInformation_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r7_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r7_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r7_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r7_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r7_mac_hsResetIndicator)
         utran_DL_CommonInformation_r7_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r7_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r7_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r7_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r7_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r7_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r7_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r7_postVerificationPeriod)
         utran_DL_CommonInformation_r7_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r7 (
   utran_DL_CommonInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r7 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r7_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo (
   utran_DL_InformationPerRL_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r7_fdd (
   utran_DL_DPCH_InfoPerRL_r7_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r7_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r7_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type1 (
   utran_MidambleShiftAndBurstType_r7_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type1 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type1_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type2 (
   utran_MidambleShiftAndBurstType_r7_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type2 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type2_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (
   utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.ueSpecificMidamble) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ueSpecificMidamble);
         }
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type3 (
   utran_MidambleShiftAndBurstType_r7_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type3 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType_type3* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type3_midambleAllocationMode (pctxt, &pvalue->midambleAllocationMode);
}

void asn1Init_utran_MidambleShiftAndBurstType_r7_burstType (
   utran_MidambleShiftAndBurstType_r7_burstType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MidambleShiftAndBurstType_r7_burstType (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7_burstType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.type1) {
            asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type1 (pctxt, pvalue->u.type1);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type1);
         }
         break;

      case 2:
         if (0 != pvalue->u.type2) {
            asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type2 (pctxt, pvalue->u.type2);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type2);
         }
         break;

      case 3:
         if (0 != pvalue->u.type3) {
            asn1Free_utran_MidambleShiftAndBurstType_r7_burstType_type3 (pctxt, pvalue->u.type3);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.type3);
         }
         break;

      case 4:
         break;

   }
}

void asn1Init_utran_MidambleShiftAndBurstType_r7 (
   utran_MidambleShiftAndBurstType_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_r7_burstType (&pvalue->burstType);
}

void asn1Free_utran_MidambleShiftAndBurstType_r7 (OSCTXT *pctxt, 
   utran_MidambleShiftAndBurstType_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_r7_burstType (pctxt, &pvalue->burstType);
}

void asn1Init_utran_IndividualTimeslotInfo_r7 (
   utran_IndividualTimeslotInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_r7 (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_IndividualTimeslotInfo_r7 (OSCTXT *pctxt, 
   utran_IndividualTimeslotInfo_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_r7 (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (
   utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_r7 (&pvalue->individualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_r7 (pctxt, &pvalue->individualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_r7_parameters (
   utran_DownlinkAdditionalTimeslots_r7_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkAdditionalTimeslots_r7_parameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_r7_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_DownlinkAdditionalTimeslots_r7_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_DownlinkAdditionalTimeslots_r7 (
   utran_DownlinkAdditionalTimeslots_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkAdditionalTimeslots_r7_parameters (&pvalue->parameters);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_r7 (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkAdditionalTimeslots_r7_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DownlinkAdditionalTimeslots_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DownlinkAdditionalTimeslots_r7*)pnode->data;
      asn1Free_utran_DownlinkAdditionalTimeslots_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_r7_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_r7 (
   utran_DownlinkTimeslotsCodes_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_r7 (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort (&pvalue->dl_TS_ChannelisationCodesShort);
   asn1Init_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_DownlinkTimeslotsCodes_r7 (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_r7 (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   asn1Free_utran_DownlinkTimeslotsCodes_r7_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd384 (
   utran_DL_CCTrCh_r7_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DownlinkTimeslotsCodes_r7 (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r7_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes_r7 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap (
   utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation_bitmap* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
   OSCRTLMEMSET (pvalue->data, 0, sizeof (pvalue->data));
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (
   utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (OSCTXT *pctxt, 
   utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.consecutive) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.consecutive);
         }
         break;

      case 2:
         if (0 != pvalue->u.bitmap) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bitmap);
         }
         break;

   }
}

void asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR (
   utran_DL_TS_ChannelisationCodesShort_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (&pvalue->codesRepresentation);
}

void asn1Free_utran_DL_TS_ChannelisationCodesShort_VHCR (OSCTXT *pctxt, 
   utran_DL_TS_ChannelisationCodesShort_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_TS_ChannelisationCodesShort_VHCR_codesRepresentation (pctxt, &pvalue->codesRepresentation);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (
   utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_VHCR (&pvalue->individualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR (&pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->individualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort_VHCR (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
}

void asn1Init_utran_DownlinkAdditionalTimeslots_VHCR_parameters (
   utran_DownlinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkAdditionalTimeslots_VHCR_parameters (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_VHCR_parameters* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.sameAsLast) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsLast);
         }
         break;

      case 2:
         if (0 != pvalue->u.newParameters) {
            asn1Free_utran_DownlinkAdditionalTimeslots_VHCR_parameters_newParameters (pctxt, pvalue->u.newParameters);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newParameters);
         }
         break;

   }
}

void asn1Init_utran_DownlinkAdditionalTimeslots_VHCR (
   utran_DownlinkAdditionalTimeslots_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkAdditionalTimeslots_VHCR_parameters (&pvalue->parameters);
}

void asn1Free_utran_DownlinkAdditionalTimeslots_VHCR (OSCTXT *pctxt, 
   utran_DownlinkAdditionalTimeslots_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkAdditionalTimeslots_VHCR_parameters (pctxt, &pvalue->parameters);
}

void asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList* pvalue)
{
   if (0 == pvalue) return;
   { utran_DownlinkAdditionalTimeslots_VHCR* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DownlinkAdditionalTimeslots_VHCR*)pnode->data;
      asn1Free_utran_DownlinkAdditionalTimeslots_VHCR (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.timeslotList) {
            asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots_timeslotList (pctxt, pvalue->u.timeslotList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.timeslotList);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.additionalTimeslots) {
            asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots_additionalTimeslots (pctxt, pvalue->u.additionalTimeslots);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.additionalTimeslots);
         }
         break;

   }
}

void asn1Init_utran_DownlinkTimeslotsCodes_VHCR (
   utran_DownlinkTimeslotsCodes_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTimeslotInfo_VHCR (&pvalue->firstIndividualTimeslotInfo);
   asn1Init_utran_DL_TS_ChannelisationCodesShort_VHCR (&pvalue->dl_TS_ChannelisationCodesShort);
   asn1Init_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (&pvalue->moreTimeslots);
}

void asn1Free_utran_DownlinkTimeslotsCodes_VHCR (OSCTXT *pctxt, 
   utran_DownlinkTimeslotsCodes_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTimeslotInfo_VHCR (pctxt, &pvalue->firstIndividualTimeslotInfo);
   asn1Free_utran_DL_TS_ChannelisationCodesShort_VHCR (pctxt, &pvalue->dl_TS_ChannelisationCodesShort);
   asn1Free_utran_DownlinkTimeslotsCodes_VHCR_moreTimeslots (pctxt, &pvalue->moreTimeslots);
}

void asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd768 (
   utran_DL_CCTrCh_r7_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DownlinkTimeslotsCodes_VHCR (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd768 (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r7_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes_VHCR (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_DL_CCTrCh_r7_tddOption_tdd128 (
   utran_DL_CCTrCh_r7_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4 (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd128 (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r7_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrCH_TimeslotsCodesPresent) {
      asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
   }
}

void asn1Init_utran_DL_CCTrCh_r7_tddOption (
   utran_DL_CCTrCh_r7_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CCTrCh_r7_tddOption (OSCTXT *pctxt, 
   utran_DL_CCTrCh_r7_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_CCTrCh_r7_tddOption_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CCTrCh_r7 (utran_DL_CCTrCh_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->tfcs_ID = 1;
   asn1Init_utran_TimeInfo (&pvalue->timeInfo);
   asn1Init_utran_CommonTimeslotInfo (&pvalue->commonTimeslotInfo);
   asn1Init_utran_DL_CCTrCh_r7_tddOption (&pvalue->tddOption);
   asn1Init_utran_UL_CCTrChTPCList (&pvalue->ul_CCTrChTPCList);
}

void asn1Free_utran_DL_CCTrCh_r7 (OSCTXT *pctxt, utran_DL_CCTrCh_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CCTrCh_r7_tddOption (pctxt, &pvalue->tddOption);
   if (pvalue->m.ul_CCTrChTPCListPresent) {
      asn1Free_utran_UL_CCTrChTPCList (pctxt, &pvalue->ul_CCTrChTPCList);
   }
}

void asn1Init_utran_DL_CCTrChList_r7 (utran_DL_CCTrChList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_CCTrChList_r7 (OSCTXT *pctxt, 
   utran_DL_CCTrChList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_CCTrCh_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_CCTrCh_r7*)pnode->data;
      asn1Free_utran_DL_CCTrCh_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r7_tdd (
   utran_DL_DPCH_InfoPerRL_r7_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r7 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r7_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r7_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r7 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r7 (utran_DL_DPCH_InfoPerRL_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r7 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r7_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r7_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r7_dl_dpchInfo (
   utran_DL_InformationPerRL_r7_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Individual (utran_E_AGCH_Individual* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_E_AGCH_Individual (OSCTXT *pctxt, 
   utran_E_AGCH_Individual* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_E_AGCH_Set_Config (utran_E_AGCH_Set_Config* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_AGCH_Set_Config (OSCTXT *pctxt, 
   utran_E_AGCH_Set_Config* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_AGCH_Individual* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_AGCH_Individual*)pnode->data;
      asn1Free_utran_E_AGCH_Individual (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_AGCH_Set_Config (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_E_AGCH_Individual_VHCR (
   utran_E_AGCH_Individual_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_MidambleShiftAndBurstType_EDCH (&pvalue->midambleShiftAndBurstType);
}

void asn1Free_utran_E_AGCH_Individual_VHCR (OSCTXT *pctxt, 
   utran_E_AGCH_Individual_VHCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MidambleShiftAndBurstType_EDCH (pctxt, &pvalue->midambleShiftAndBurstType);
}

void asn1Init_utran_E_AGCH_Set_Config_VHCR (
   utran_E_AGCH_Set_Config_VHCR* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_AGCH_Set_Config_VHCR (OSCTXT *pctxt, 
   utran_E_AGCH_Set_Config_VHCR* pvalue)
{
   if (0 == pvalue) return;
   { utran_E_AGCH_Individual_VHCR* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_E_AGCH_Individual_VHCR*)pnode->data;
      asn1Free_utran_E_AGCH_Individual_VHCR (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_AGCH_Set_Config_VHCR (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config_VHCR (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_E_AGCH_Individual_LCR_midambleAllocationMode (
   utran_E_AGCH_Individual_LCR_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_E_AGCH_Individual_LCR (utran_E_AGCH_Individual_LCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_Individual_LCR_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_E_AGCH_Set_Config_LCR (utran_E_AGCH_Set_Config_LCR* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_AGCH_Set_Config_LCR (OSCTXT *pctxt, 
   utran_E_AGCH_Set_Config_LCR* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_Set_Config_LCR (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_E_AGCH_Information_r7_modeSpecific_tdd (
   utran_E_AGCH_Information_r7_modeSpecific_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7_modeSpecific_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Information_r7_modeSpecific (
   utran_E_AGCH_Information_r7_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_AGCH_Information_r7_modeSpecific (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_E_AGCH_Information_r7_modeSpecific_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Information_r7 (utran_E_AGCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_Information_r7_modeSpecific (&pvalue->modeSpecific);
}

void asn1Free_utran_E_AGCH_Information_r7 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Information_r7_modeSpecific (pctxt, &pvalue->modeSpecific);
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_E_HICH_Information_TDD384_768_modeSpecificInfo (
   utran_E_HICH_Information_TDD384_768_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

static const OSEnumItem utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTAB[] = {
   { OSUTF8("type1"), 0, 5, 0 },
   { OSUTF8("type2"), 1, 5, 1 }
} ;
#define utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_HICH_Information_TDD384_768_burst_Type_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTABSIZE) {
      return utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTAB
         [utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_HICH_Information_TDD384_768_burst_Type_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_HICH_Information_TDD384_768_burst_Type* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_HICH_Information_TDD384_768_burst_Type_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_HICH_Information_TDD384_768_burst_Type_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_HICH_Information_TDD384_768_burst_Type* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTAB, 
      utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_HICH_Information_TDD384_768_burst_Type)
         utran_E_HICH_Information_TDD384_768_burst_Type_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTAB[] = {
   { OSUTF8("common"), 1, 6, 1 },
   { OSUTF8("default"), 0, 7, 0 }
} ;
#define utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTABSIZE) {
      return utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTAB
         [utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTAB, 
      utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode)
         utran_E_HICH_Information_TDD384_768_midamble_Allocation_Mode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_HICH_Information_TDD384_768 (
   utran_E_HICH_Information_TDD384_768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_HICH_Information_TDD384_768_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768 (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD384_768 (&pvalue->e_HICH_Info);
}

void asn1Init_utran_E_HICH_Information_LCR_midambleAllocationMode (
   utran_E_HICH_Information_LCR_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_E_HICH_Information_LCR (
   utran_E_HICH_Information_LCR* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_HICH_Information_LCR_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_E_HICH_Information_LCR_List (
   utran_E_HICH_Information_LCR_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_HICH_Information_LCR_List (OSCTXT *pctxt, 
   utran_E_HICH_Information_LCR_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_HICH_Information_TDD128 (
   utran_E_HICH_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_HICH_Information_LCR_List (&pvalue->e_HICH_InfoList);
}

void asn1Free_utran_E_HICH_Information_TDD128 (OSCTXT *pctxt, 
   utran_E_HICH_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_HICH_Information_LCR_List (pctxt, &pvalue->e_HICH_InfoList);
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (
   utran_DL_InformationPerRL_r7_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r7 (
   utran_DL_InformationPerRL_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r7_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_AGCH_Information_r7 (&pvalue->e_AGCH_Information);
   asn1Init_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (&pvalue->modeSpecificInfo2);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r7 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r7_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_AGCH_InformationPresent) {
      asn1Free_utran_E_AGCH_Information_r7 (pctxt, &pvalue->e_AGCH_Information);
   }
   asn1Free_utran_DL_InformationPerRL_r7_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
}

void asn1Init_utran_DL_InformationPerRL_List_r7 (
   utran_DL_InformationPerRL_List_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r7 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r7*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_MBMS_SessionIdentity (utran_MBMS_SessionIdentity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_RAB_Info_r7_mbms_ServiceIdentity (
   utran_RAB_Info_r7_mbms_ServiceIdentity* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_RAB_Info_r7 (utran_RAB_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Identity (&pvalue->rab_Identity);
   asn1Init_utran_MBMS_SessionIdentity (&pvalue->mbms_SessionIdentity);
   asn1Init_utran_RAB_Info_r7_mbms_ServiceIdentity (&pvalue->mbms_ServiceIdentity);
   asn1Init_utran_NAS_Synchronisation_Indicator (&pvalue->nas_Synchronisation_Indicator);
}

void asn1Free_utran_RAB_Info_r7 (OSCTXT *pctxt, utran_RAB_Info_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
}

void asn1Init_utran_RLC_InfoChoice_r7 (utran_RLC_InfoChoice_r7* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RLC_InfoChoice_r7 (OSCTXT *pctxt, 
   utran_RLC_InfoChoice_r7* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rlc_Info) {
            asn1Free_utran_RLC_Info_r7 (pctxt, pvalue->u.rlc_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rlc_Info);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_RB_InformationSetup_r7 (
   utran_RB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice_r7 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r7 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r7 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r7 (
   utran_RB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r7 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r7*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r7 (
   utran_RAB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Info_r7 (&pvalue->rab_Info);
   asn1Init_utran_RB_InformationSetupList_r7 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r7 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   asn1Free_utran_RB_InformationSetupList_r7 (pctxt, &pvalue->rb_InformationSetupList);
}

static const OSEnumItem utran_UL_AMR_Rate_ENUMTAB[] = {
   { OSUTF8("spare1"), 15, 6, 7 },
   { OSUTF8("spare2"), 14, 6, 8 },
   { OSUTF8("spare3"), 13, 6, 9 },
   { OSUTF8("spare4"), 12, 6, 10 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 12 },
   { OSUTF8("spare7"), 9, 6, 13 },
   { OSUTF8("t0"), 0, 2, 14 },
   { OSUTF8("t1"), 1, 2, 15 },
   { OSUTF8("t2"), 2, 2, 6 },
   { OSUTF8("t3"), 3, 2, 5 },
   { OSUTF8("t4"), 4, 2, 4 },
   { OSUTF8("t5"), 5, 2, 3 },
   { OSUTF8("t6"), 6, 2, 2 },
   { OSUTF8("t7"), 7, 2, 1 },
   { OSUTF8("t8"), 8, 2, 0 }
} ;
#define utran_UL_AMR_Rate_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UL_AMR_Rate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_AMR_Rate_ENUMTABSIZE) {
      return utran_UL_AMR_Rate_ENUMTAB
         [utran_UL_AMR_Rate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_AMR_Rate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_UL_AMR_Rate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_AMR_Rate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_AMR_Rate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_UL_AMR_Rate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_UL_AMR_Rate_ENUMTAB, 
      utran_UL_AMR_Rate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_AMR_Rate)utran_UL_AMR_Rate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CS_HSPA_Information (utran_CS_HSPA_Information* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_RAB_InformationSetup_v820ext (
   utran_RAB_InformationSetup_v820ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CS_HSPA_Information (&pvalue->cs_HSPA_Information);
}

static const OSEnumItem utran_DefaultConfigMode_ENUMTAB[] = {
   { OSUTF8("fdd"), 0, 3, 0 },
   { OSUTF8("tdd"), 1, 3, 1 }
} ;
#define utran_DefaultConfigMode_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DefaultConfigMode_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DefaultConfigMode_ENUMTABSIZE) {
      return utran_DefaultConfigMode_ENUMTAB
         [utran_DefaultConfigMode_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DefaultConfigMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_DefaultConfigMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DefaultConfigMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DefaultConfigMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_DefaultConfigMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DefaultConfigMode_ENUMTAB, utran_DefaultConfigMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DefaultConfigMode)
         utran_DefaultConfigMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RAB_InfoReplace (utran_RAB_InfoReplace* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Identity (&pvalue->rab_Identity);
}

void asn1Free_utran_RAB_InfoReplace (OSCTXT *pctxt, 
   utran_RAB_InfoReplace* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.explicitList) {
            asn1Free_utran_RLC_SizeExplicitList (pctxt, pvalue->u.explicitList);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicitList);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TransportChannelType (&pvalue->ul_TransportChannelType);
   asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (&pvalue->rlc_SizeList);
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch_rlc_SizeList (pctxt, &pvalue->rlc_SizeList);
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RLC_PDU_SizeList (&pvalue->rlc_PDU_SizeList);
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_PDU_SizeList (pctxt, &pvalue->rlc_PDU_SizeList);
}

static const OSEnumItem utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTAB[] = {
   { OSUTF8("size15"), 1, 6, 1 },
   { OSUTF8("size7"), 0, 5, 0 }
} ;
#define utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTABSIZE 2

const OSUTF8CHAR* utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTABSIZE) {
      return utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTAB
         [utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_RLC_PDU_SizeConstraint_lengthIndicatorSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_PDU_SizeConstraint_lengthIndicatorSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTAB, 
      utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_PDU_SizeConstraint_lengthIndicatorSize)
         utran_RLC_PDU_SizeConstraint_lengthIndicatorSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RLC_PDU_SizeConstraint (
   utran_RLC_PDU_SizeConstraint* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fixedSize) {
            asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size_fixedSize (pctxt, pvalue->u.fixedSize);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fixedSize);
         }
         break;

      case 2:
         if (0 != pvalue->u.flexibleSize) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.flexibleSize);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (&pvalue->rlc_PDU_Size);
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch_rlc_PDU_Size (pctxt, &pvalue->rlc_PDU_Size);
}

void asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_rach_usch) {
            asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_dch_rach_usch (pctxt, pvalue->u.dch_rach_usch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_rach_usch);
         }
         break;

      case 2:
         if (0 != pvalue->u.e_dch) {
            asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type_e_dch (pctxt, pvalue->u.e_dch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_dch);
         }
         break;

   }
}

void asn1Init_utran_UL_LogicalChannelMapping_r8 (
   utran_UL_LogicalChannelMapping_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (&pvalue->ul_TrCH_Type);
}

void asn1Free_utran_UL_LogicalChannelMapping_r8 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMapping_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMapping_r8_ul_TrCH_Type (pctxt, &pvalue->ul_TrCH_Type);
}

void asn1Init_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (
   utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_LogicalChannelMapping_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_LogicalChannelMapping_r8*)pnode->data;
      asn1Free_utran_UL_LogicalChannelMapping_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_LogicalChannelMappingList_r8 (
   utran_UL_LogicalChannelMappingList_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (&pvalue->ul_LogicalChannelMapping);
}

void asn1Free_utran_UL_LogicalChannelMappingList_r8 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappingList_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_LogicalChannelMappingList_r8_ul_LogicalChannelMapping (pctxt, &pvalue->ul_LogicalChannelMapping);
}

void asn1Init_utran_UL_LogicalChannelMappings_r8 (
   utran_UL_LogicalChannelMappings_r8* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_LogicalChannelMappings_r8 (OSCTXT *pctxt, 
   utran_UL_LogicalChannelMappings_r8* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.oneLogicalChannel) {
            asn1Free_utran_UL_LogicalChannelMapping_r8 (pctxt, pvalue->u.oneLogicalChannel);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.oneLogicalChannel);
         }
         break;

      case 2:
         if (0 != pvalue->u.twoLogicalChannels) {
            asn1Free_utran_UL_LogicalChannelMappingList_r8 (pctxt, pvalue->u.twoLogicalChannels);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.twoLogicalChannels);
         }
         break;

   }
}

void asn1Init_utran_RB_MappingOption_r8 (utran_RB_MappingOption_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_LogicalChannelMappings_r8 (&pvalue->ul_LogicalChannelMappings);
   asn1Init_utran_DL_LogicalChannelMappingList_r7 (&pvalue->dl_LogicalChannelMappingList);
}

void asn1Free_utran_RB_MappingOption_r8 (OSCTXT *pctxt, 
   utran_RB_MappingOption_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_LogicalChannelMappingsPresent) {
      asn1Free_utran_UL_LogicalChannelMappings_r8 (pctxt, &pvalue->ul_LogicalChannelMappings);
   }
   if (pvalue->m.dl_LogicalChannelMappingListPresent) {
      asn1Free_utran_DL_LogicalChannelMappingList_r7 (pctxt, &pvalue->dl_LogicalChannelMappingList);
   }
}

void asn1Init_utran_RB_MappingInfo_r8 (utran_RB_MappingInfo_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_MappingInfo_r8 (OSCTXT *pctxt, 
   utran_RB_MappingInfo_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_MappingOption_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_MappingOption_r8*)pnode->data;
      asn1Free_utran_RB_MappingOption_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationSetup_r8 (
   utran_RB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice_r7 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r8 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r8 (
   utran_RB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r8 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r8*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r8 (
   utran_RAB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Info_r7 (&pvalue->rab_Info);
   asn1Init_utran_CS_HSPA_Information (&pvalue->cs_HSPA_Information);
   asn1Init_utran_RAB_InfoReplace (&pvalue->rab_InfoReplace);
   asn1Init_utran_RB_InformationSetupList_r8 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r8 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   if (pvalue->m.rab_InfoReplacePresent) {
      asn1Free_utran_RAB_InfoReplace (pctxt, &pvalue->rab_InfoReplace);
   }
   asn1Free_utran_RB_InformationSetupList_r8 (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RB_InformationReconfig_r8 (
   utran_RB_InformationReconfig_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info_r7 (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r8 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info_r7 (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r8 (
   utran_RB_InformationReconfigList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r8 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r8*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationAffected_r8 (
   utran_RB_InformationAffected_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationAffected_r8 (OSCTXT *pctxt, 
   utran_RB_InformationAffected_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationAffectedList_r8 (
   utran_RB_InformationAffectedList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationAffectedList_r8 (OSCTXT *pctxt, 
   utran_RB_InformationAffectedList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationAffected_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationAffected_r8*)pnode->data;
      asn1Free_utran_RB_InformationAffected_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r8_dch_usch (
   utran_UL_AddReconfTransChInformation_r8_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TransportFormatSet (&pvalue->transportFormatSet);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r8_dch_usch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r8_dch_usch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TransportFormatSet (pctxt, &pvalue->transportFormatSet);
}

static const OSEnumItem utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTAB[] = {
   { OSUTF8("mac-iis"), 0, 7, 0 }
} ;
#define utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTAB, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTABSIZE) {
      return utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTAB, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType)
         utran_UL_AddReconfTransChInformation_r8_e_dch_ul_MAC_HeaderType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (
   utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTAB[] = {
   { OSUTF8("rv0"), 0, 3, 0 },
   { OSUTF8("rvtable"), 1, 7, 1 }
} ;
#define utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTABSIZE 2

const OSUTF8CHAR* utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTABSIZE) {
      return utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTAB
         [utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTAB, 
      utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info)
         utran_UL_AddReconfTransChInformation_r8_e_dch_harq_Info_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r8_e_dch (
   utran_UL_AddReconfTransChInformation_r8_e_dch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (&pvalue->modeSpecific);
   asn1Init_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (&pvalue->addReconf_MAC_d_FlowList);
}

void asn1Free_utran_UL_AddReconfTransChInformation_r8_e_dch (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r8_e_dch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_AddReconfTransChInformation_r8_e_dch_modeSpecific (pctxt, &pvalue->modeSpecific);
   if (pvalue->m.addReconf_MAC_d_FlowListPresent) {
      asn1Free_utran_E_DCH_AddReconf_MAC_d_FlowList_r7 (pctxt, &pvalue->addReconf_MAC_d_FlowList);
   }
}

void asn1Init_utran_UL_AddReconfTransChInformation_r8 (
   utran_UL_AddReconfTransChInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_AddReconfTransChInformation_r8 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dch_usch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r8_dch_usch (pctxt, pvalue->u.dch_usch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dch_usch);
         }
         break;

      case 2:
         if (0 != pvalue->u.e_dch) {
            asn1Free_utran_UL_AddReconfTransChInformation_r8_e_dch (pctxt, pvalue->u.e_dch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_dch);
         }
         break;

   }
}

void asn1Init_utran_UL_AddReconfTransChInfoList_r8 (
   utran_UL_AddReconfTransChInfoList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_AddReconfTransChInfoList_r8 (OSCTXT *pctxt, 
   utran_UL_AddReconfTransChInfoList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_AddReconfTransChInformation_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_AddReconfTransChInformation_r8*)pnode->data;
      asn1Free_utran_UL_AddReconfTransChInformation_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator)
         utran_UL_EDCH_Information_r8_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_DPDCH_Info_r8 (utran_E_DPDCH_Info_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPDCH_Reference_E_TFCIList_r7 (&pvalue->reference_E_TFCIs);
   asn1Init_utran_E_DPDCH_SchedulingInfoConfiguration (&pvalue->schedulingInfoConfiguration);
}

void asn1Free_utran_E_DPDCH_Info_r8 (OSCTXT *pctxt, 
   utran_E_DPDCH_Info_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_DPDCH_Reference_E_TFCIList_r7 (pctxt, &pvalue->reference_E_TFCIs);
}

void asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (
   utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPCCH_Info_r7 (&pvalue->e_DPCCH_Info);
   asn1Init_utran_E_DPDCH_Info_r8 (&pvalue->e_DPDCH_Info);
   asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (&pvalue->schedulingTransmConfiguration);
}

void asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DPDCH_InfoPresent) {
      asn1Free_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
   }
}

void asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (
   utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_Info (&pvalue->e_RUCCH_Info);
   asn1Init_utran_E_PUCH_Info (&pvalue->e_PUCH_Info);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD (&pvalue->non_ScheduledTransGrantInfo);
}

void asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RUCCH_InfoPresent) {
      asn1Free_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
   }
   if (pvalue->m.e_PUCH_InfoPresent) {
      asn1Free_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
   }
   if (pvalue->m.non_ScheduledTransGrantInfoPresent) {
      asn1Free_utran_Non_ScheduledTransGrantInfoTDD (pctxt, &pvalue->non_ScheduledTransGrantInfo);
   }
}

void asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo (
   utran_UL_EDCH_Information_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r8 (
   utran_UL_EDCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_EDCH_Information_r8_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_EDCH_Information_r8 (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r8_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_TGP_Sequence_r8_tgps_Status (
   utran_TGP_Sequence_r8_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TGP_Sequence_r8_tgps_Status (OSCTXT *pctxt, 
   utran_TGP_Sequence_r8_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.activate) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.activate);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_TGMP_r8_ENUMTAB[] = {
   { OSUTF8("e-UTRA"), 6, 6, 7 },
   { OSUTF8("fdd-Measurement"), 1, 15, 1 },
   { OSUTF8("gsm-CarrierRSSIMeasurement"), 2, 26, 2 },
   { OSUTF8("gsm-initialBSICIdentification"), 3, 29, 3 },
   { OSUTF8("gsmBSICReconfirmation"), 4, 21, 4 },
   { OSUTF8("multi-carrier"), 5, 13, 5 },
   { OSUTF8("spare"), 7, 5, 0 },
   { OSUTF8("tdd-Measurement"), 0, 15, 6 }
} ;
#define utran_TGMP_r8_ENUMTABSIZE 8

const OSUTF8CHAR* utran_TGMP_r8_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TGMP_r8_ENUMTABSIZE) {
      return utran_TGMP_r8_ENUMTAB[utran_TGMP_r8_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TGMP_r8_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TGMP_r8* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TGMP_r8_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TGMP_r8_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TGMP_r8* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TGMP_r8_ENUMTAB, 
      utran_TGMP_r8_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TGMP_r8)utran_TGMP_r8_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TGPS_ConfigurationParams_r8 (
   utran_TGPS_ConfigurationParams_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DL_Mode (&pvalue->ul_DL_Mode);
}

void asn1Free_utran_TGPS_ConfigurationParams_r8 (OSCTXT *pctxt, 
   utran_TGPS_ConfigurationParams_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
}

void asn1Init_utran_TGP_Sequence_r8 (utran_TGP_Sequence_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TGP_Sequence_r8_tgps_Status (&pvalue->tgps_Status);
   asn1Init_utran_TGPS_ConfigurationParams_r8 (&pvalue->tgps_ConfigurationParams);
}

void asn1Free_utran_TGP_Sequence_r8 (OSCTXT *pctxt, 
   utran_TGP_Sequence_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_Sequence_r8_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (pvalue->m.tgps_ConfigurationParamsPresent) {
      asn1Free_utran_TGPS_ConfigurationParams_r8 (pctxt, &pvalue->tgps_ConfigurationParams);
   }
}

void asn1Init_utran_TGP_SequenceList_r8 (utran_TGP_SequenceList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TGP_SequenceList_r8 (OSCTXT *pctxt, 
   utran_TGP_SequenceList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_TGP_Sequence_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TGP_Sequence_r8*)pnode->data;
      asn1Free_utran_TGP_Sequence_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DPCH_CompressedModeInfo_r8 (
   utran_DPCH_CompressedModeInfo_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TGP_SequenceList_r8 (&pvalue->tgp_SequenceList);
}

void asn1Free_utran_DPCH_CompressedModeInfo_r8 (OSCTXT *pctxt, 
   utran_DPCH_CompressedModeInfo_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_SequenceList_r8 (pctxt, &pvalue->tgp_SequenceList);
}

void asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo_r8 (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo_r8 (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo (
   utran_DL_CommonInformation_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r8_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r8_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r8_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r8_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r8_mac_hsResetIndicator)
         utran_DL_CommonInformation_r8_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r8_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r8_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r8_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r8_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r8_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r8_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r8_postVerificationPeriod)
         utran_DL_CommonInformation_r8_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r8 (
   utran_DL_CommonInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r8_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r8 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r8_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo (
   utran_DL_InformationPerRL_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r8_dl_dpchInfo (
   utran_DL_InformationPerRL_r8_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_AGCH_Set_Config (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_AGCH_Set_Config_VHCR (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config_VHCR (pctxt, &pvalue->e_AGCH_Set_Config);
}

static const OSEnumItem utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTAB[] = {
   { OSUTF8("infinity"), 15, 8, 1 },
   { OSUTF8("radio-frames-0"), 0, 14, 2 },
   { OSUTF8("radio-frames-1"), 1, 14, 5 },
   { OSUTF8("radio-frames-128"), 8, 16, 8 },
   { OSUTF8("radio-frames-16"), 5, 15, 11 },
   { OSUTF8("radio-frames-2"), 2, 14, 4 },
   { OSUTF8("radio-frames-256"), 9, 16, 7 },
   { OSUTF8("radio-frames-32"), 6, 15, 10 },
   { OSUTF8("radio-frames-4"), 3, 14, 3 },
   { OSUTF8("radio-frames-512"), 10, 16, 6 },
   { OSUTF8("radio-frames-64"), 7, 15, 9 },
   { OSUTF8("radio-frames-8"), 4, 14, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 0 }
} ;
#define utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTABSIZE 16

const OSUTF8CHAR* utran_E_AGCH_InactivityMonitorThreshold_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTABSIZE) {
      return utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTAB
         [utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_E_AGCH_InactivityMonitorThreshold_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_E_AGCH_InactivityMonitorThreshold_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_E_AGCH_InactivityMonitorThreshold_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_E_AGCH_InactivityMonitorThreshold_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_E_AGCH_InactivityMonitorThreshold_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTAB, 
      utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_E_AGCH_InactivityMonitorThreshold_TDD128)
         utran_E_AGCH_InactivityMonitorThreshold_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_AGCH_Set_Config_LCR (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_E_AGCH_Information_r8_modeSpecific_tdd (
   utran_E_AGCH_Information_r8_modeSpecific_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8_modeSpecific_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Information_r8_modeSpecific (
   utran_E_AGCH_Information_r8_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_AGCH_Information_r8_modeSpecific (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8_modeSpecific* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_E_AGCH_Information_r8_modeSpecific_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_Information_r8 (utran_E_AGCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_Information_r8_modeSpecific (&pvalue->modeSpecific);
}

void asn1Free_utran_E_AGCH_Information_r8 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Information_r8_modeSpecific (pctxt, &pvalue->modeSpecific);
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (&pvalue->e_RGCH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768 (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD384_768 (&pvalue->e_HICH_Info);
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (
   utran_DL_InformationPerRL_r8_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r8 (
   utran_DL_InformationPerRL_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r8_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_AGCH_Information_r8 (&pvalue->e_AGCH_Information);
   asn1Init_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (&pvalue->modeSpecificInfo2);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r8 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r8_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_AGCH_InformationPresent) {
      asn1Free_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
   }
   asn1Free_utran_DL_InformationPerRL_r8_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
}

void asn1Init_utran_DL_InformationPerRL_List_r8 (
   utran_DL_InformationPerRL_List_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r8 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r8*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_EnablingDelay_TDD128_ENUMTAB[] = {
   { OSUTF8("infinity"), 15, 8, 1 },
   { OSUTF8("radio-frames-0"), 0, 14, 2 },
   { OSUTF8("radio-frames-1"), 1, 14, 5 },
   { OSUTF8("radio-frames-128"), 8, 16, 7 },
   { OSUTF8("radio-frames-16"), 5, 15, 9 },
   { OSUTF8("radio-frames-2"), 2, 14, 4 },
   { OSUTF8("radio-frames-32"), 6, 15, 6 },
   { OSUTF8("radio-frames-4"), 3, 14, 8 },
   { OSUTF8("radio-frames-64"), 7, 15, 3 },
   { OSUTF8("radio-frames-8"), 4, 14, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 },
   { OSUTF8("spare7"), 9, 6, 0 }
} ;
#define utran_EnablingDelay_TDD128_ENUMTABSIZE 16

const OSUTF8CHAR* utran_EnablingDelay_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_EnablingDelay_TDD128_ENUMTABSIZE) {
      return utran_EnablingDelay_TDD128_ENUMTAB
         [utran_EnablingDelay_TDD128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_EnablingDelay_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_EnablingDelay_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_EnablingDelay_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_EnablingDelay_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_EnablingDelay_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_EnablingDelay_TDD128_ENUMTAB, 
      utran_EnablingDelay_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_EnablingDelay_TDD128)
         utran_EnablingDelay_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_ (
   utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_continue_* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_ControlChannelDRXCycle_TDD128_ENUMTAB[] = {
   { OSUTF8("spare1"), 7, 6, 1 },
   { OSUTF8("sub-frames-1"), 0, 12, 3 },
   { OSUTF8("sub-frames-16"), 4, 13, 5 },
   { OSUTF8("sub-frames-2"), 1, 12, 7 },
   { OSUTF8("sub-frames-32"), 5, 13, 2 },
   { OSUTF8("sub-frames-4"), 2, 12, 4 },
   { OSUTF8("sub-frames-64"), 6, 13, 6 },
   { OSUTF8("sub-frames-8"), 3, 12, 0 }
} ;
#define utran_ControlChannelDRXCycle_TDD128_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ControlChannelDRXCycle_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ControlChannelDRXCycle_TDD128_ENUMTABSIZE) {
      return utran_ControlChannelDRXCycle_TDD128_ENUMTAB
         [utran_ControlChannelDRXCycle_TDD128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ControlChannelDRXCycle_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ControlChannelDRXCycle_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ControlChannelDRXCycle_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ControlChannelDRXCycle_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_ControlChannelDRXCycle_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ControlChannelDRXCycle_TDD128_ENUMTAB, 
      utran_ControlChannelDRXCycle_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ControlChannelDRXCycle_TDD128)
         utran_ControlChannelDRXCycle_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTAB[] = {
   { OSUTF8("infinity"), 15, 8, 6 },
   { OSUTF8("spare2"), 14, 6, 9 },
   { OSUTF8("spare3"), 13, 6, 12 },
   { OSUTF8("spare4"), 12, 6, 15 },
   { OSUTF8("spare5"), 11, 6, 8 },
   { OSUTF8("spare6"), 10, 6, 11 },
   { OSUTF8("sub-frames-1"), 0, 12, 14 },
   { OSUTF8("sub-frames-128"), 7, 14, 7 },
   { OSUTF8("sub-frames-16"), 4, 13, 10 },
   { OSUTF8("sub-frames-2"), 1, 12, 13 },
   { OSUTF8("sub-frames-256"), 8, 14, 5 },
   { OSUTF8("sub-frames-32"), 5, 13, 4 },
   { OSUTF8("sub-frames-4"), 2, 12, 3 },
   { OSUTF8("sub-frames-512"), 9, 14, 2 },
   { OSUTF8("sub-frames-64"), 6, 13, 1 },
   { OSUTF8("sub-frames-8"), 3, 12, 0 }
} ;
#define utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTABSIZE 16

const OSUTF8CHAR* utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTABSIZE) {
      return utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTAB
         [utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_DRX_InactivityThreshold_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_DRX_InactivityThreshold_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTAB, 
      utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HS_SCCH_DRX_InactivityThreshold_TDD128)
         utran_HS_SCCH_DRX_InactivityThreshold_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_DRX_Info_TDD128 (
   utran_HS_SCCH_DRX_Info_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters (
   utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType_e_AGCH_DRX_Parameters* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (
   utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (OSCTXT *pctxt, 
   utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.e_AGCH_DRX_Parameters) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_AGCH_DRX_Parameters);
         }
         break;

   }
}

void asn1Init_utran_E_AGCH_DRX_Info_TDD128 (
   utran_E_AGCH_DRX_Info_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (&pvalue->e_AGCH_DRX_InfoType);
}

void asn1Free_utran_E_AGCH_DRX_Info_TDD128 (OSCTXT *pctxt, 
   utran_E_AGCH_DRX_Info_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_DRX_Info_TDD128_e_AGCH_DRX_InfoType (pctxt, &pvalue->e_AGCH_DRX_InfoType);
}

void asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (
   utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_DRX_Info_TDD128 (&pvalue->hS_SCCH_Drx_Info);
   asn1Init_utran_E_AGCH_DRX_Info_TDD128 (&pvalue->e_AGCH_Drx_Info);
}

void asn1Free_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (OSCTXT *pctxt, 
   utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_AGCH_Drx_InfoPresent) {
      asn1Free_utran_E_AGCH_DRX_Info_TDD128 (pctxt, &pvalue->e_AGCH_Drx_Info);
   }
}

void asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (
   utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (OSCTXT *pctxt, 
   utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.continue_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.continue_);
         }
         break;

      case 2:
         if (0 != pvalue->u.newOperation) {
            asn1Free_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation_newOperation (pctxt, pvalue->u.newOperation);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newOperation);
         }
         break;

   }
}

void asn1Init_utran_ControlChannelDRXInfo_TDD128_r8 (
   utran_ControlChannelDRXInfo_TDD128_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (&pvalue->controlChannelDrxOperation);
}

void asn1Free_utran_ControlChannelDRXInfo_TDD128_r8 (OSCTXT *pctxt, 
   utran_ControlChannelDRXInfo_TDD128_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_ControlChannelDRXInfo_TDD128_r8_controlChannelDrxOperation (pctxt, &pvalue->controlChannelDrxOperation);
}

void asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit (
   utran_E_HICH_Information_For_SPS_TDD128_configurationmode_implicit* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode (
   utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_ (
   utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit_* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode_explicit__midambleAllocationMode (&pvalue->midambleAllocationMode);
}

void asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (
   utran_E_HICH_Information_For_SPS_TDD128_configurationmode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (OSCTXT *pctxt, 
   utran_E_HICH_Information_For_SPS_TDD128_configurationmode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.implicit) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.implicit);
         }
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

void asn1Init_utran_E_HICH_Information_For_SPS_TDD128 (
   utran_E_HICH_Information_For_SPS_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (&pvalue->configurationmode);
}

void asn1Free_utran_E_HICH_Information_For_SPS_TDD128 (OSCTXT *pctxt, 
   utran_E_HICH_Information_For_SPS_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_HICH_Information_For_SPS_TDD128_configurationmode (pctxt, &pvalue->configurationmode);
}

void asn1Init_utran_RepetitionPeriodAndLengthForSPS (
   utran_RepetitionPeriodAndLengthForSPS* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_E_DCH_TxPatternList_TDD128_element (
   utran_E_DCH_TxPatternList_TDD128_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RepetitionPeriodAndLengthForSPS (&pvalue->repetitionPeriodAndLength);
}

void asn1Init_utran_E_DCH_TxPatternList_TDD128 (
   utran_E_DCH_TxPatternList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_DCH_TxPatternList_TDD128 (OSCTXT *pctxt, 
   utran_E_DCH_TxPatternList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH (
   utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH* pvalue)
{
   if (0 == pvalue) return;
   pvalue->timeslotResourceRelatedInfo.numbits = 0;
}

void asn1Init_utran_E_DCH_SPS_NewOperation_TDD128 (
   utran_E_DCH_SPS_NewOperation_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_For_SPS_TDD128 (&pvalue->e_hich_Info);
   asn1Init_utran_E_DCH_TxPatternList_TDD128 (&pvalue->e_dch_TxPattern);
   asn1Init_utran_E_DCH_SPS_NewOperation_TDD128_initialSPSInfoForEDCH (&pvalue->initialSPSInfoForEDCH);
}

void asn1Free_utran_E_DCH_SPS_NewOperation_TDD128 (OSCTXT *pctxt, 
   utran_E_DCH_SPS_NewOperation_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_HICH_Information_For_SPS_TDD128 (pctxt, &pvalue->e_hich_Info);
   if (pvalue->m.e_dch_TxPatternPresent) {
      asn1Free_utran_E_DCH_TxPatternList_TDD128 (pctxt, &pvalue->e_dch_TxPattern);
   }
}

void asn1Init_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (
   utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (OSCTXT *pctxt, 
   utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newOperation) {
            asn1Free_utran_E_DCH_SPS_NewOperation_TDD128 (pctxt, pvalue->u.newOperation);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newOperation);
         }
         break;

   }
}

void asn1Init_utran_E_DCH_SPS_Information_TDD128 (
   utran_E_DCH_SPS_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (&pvalue->e_dch_SPS_Operation);
}

void asn1Free_utran_E_DCH_SPS_Information_TDD128 (OSCTXT *pctxt, 
   utran_E_DCH_SPS_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_DCH_SPS_Information_TDD128_e_dch_SPS_Operation (pctxt, &pvalue->e_dch_SPS_Operation);
}

void asn1Init_utran_HS_DSCH_TbsList_TDD128 (
   utran_HS_DSCH_TbsList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_DSCH_TbsList_TDD128 (OSCTXT *pctxt, 
   utran_HS_DSCH_TbsList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_HS_DSCH_RxPatternList_TDD128_element (
   utran_HS_DSCH_RxPatternList_TDD128_element* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RepetitionPeriodAndLengthForSPS (&pvalue->repetitionPeriodAndLength);
}

void asn1Init_utran_HS_DSCH_RxPatternList_TDD128 (
   utran_HS_DSCH_RxPatternList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_DSCH_RxPatternList_TDD128 (OSCTXT *pctxt, 
   utran_HS_DSCH_RxPatternList_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_HS_SICH_List_TDD128_element_explicit_ (
   utran_HS_SICH_List_TDD128_element_explicit_* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SICH_Configuration_TDD128_r6 (&pvalue->hS_SICH_Info);
}

void asn1Free_utran_HS_SICH_List_TDD128_element_explicit_ (OSCTXT *pctxt, 
   utran_HS_SICH_List_TDD128_element_explicit_* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SICH_Configuration_TDD128_r6 (pctxt, &pvalue->hS_SICH_Info);
}

void asn1Init_utran_HS_SICH_List_TDD128_element (
   utran_HS_SICH_List_TDD128_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SICH_List_TDD128_element (OSCTXT *pctxt, 
   utran_HS_SICH_List_TDD128_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.implicit) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.implicit);
         }
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            asn1Free_utran_HS_SICH_List_TDD128_element_explicit_ (pctxt, pvalue->u.explicit_);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

void asn1Init_utran_HS_SICH_List_TDD128 (utran_HS_SICH_List_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_HS_SICH_List_TDD128 (OSCTXT *pctxt, 
   utran_HS_SICH_List_TDD128* pvalue)
{
   if (0 == pvalue) return;
   { utran_HS_SICH_List_TDD128_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_HS_SICH_List_TDD128_element*)pnode->data;
      asn1Free_utran_HS_SICH_List_TDD128_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTAB[] = {
   { OSUTF8("mod16QAM"), 1, 8, 1 },
   { OSUTF8("modQPSK"), 0, 7, 0 }
} ;
#define utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTABSIZE 2

const OSUTF8CHAR* utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTABSIZE) {
      return utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTAB
         [utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTAB, 
      utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation)
         utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH_modulation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH (
   utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH* pvalue)
{
   if (0 == pvalue) return;
   pvalue->timeslotInfo.numbits = 0;
}

void asn1Init_utran_HS_DSCH_SPS_NewOperation_TDD128 (
   utran_HS_DSCH_SPS_NewOperation_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_DSCH_TbsList_TDD128 (&pvalue->hs_dsch_TbsList);
   asn1Init_utran_HS_DSCH_RxPatternList_TDD128 (&pvalue->hs_dsch_RxPatternList);
   asn1Init_utran_HS_SICH_List_TDD128 (&pvalue->hs_sich_List);
   asn1Init_utran_HS_DSCH_SPS_NewOperation_TDD128_initialSPSInfoForHSDSCH (&pvalue->initialSPSInfoForHSDSCH);
}

void asn1Free_utran_HS_DSCH_SPS_NewOperation_TDD128 (OSCTXT *pctxt, 
   utran_HS_DSCH_SPS_NewOperation_TDD128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_dsch_TbsListPresent) {
      asn1Free_utran_HS_DSCH_TbsList_TDD128 (pctxt, &pvalue->hs_dsch_TbsList);
   }
   if (pvalue->m.hs_dsch_RxPatternListPresent) {
      asn1Free_utran_HS_DSCH_RxPatternList_TDD128 (pctxt, &pvalue->hs_dsch_RxPatternList);
   }
   asn1Free_utran_HS_SICH_List_TDD128 (pctxt, &pvalue->hs_sich_List);
}

void asn1Init_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (
   utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (OSCTXT *pctxt, 
   utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newOperation) {
            asn1Free_utran_HS_DSCH_SPS_NewOperation_TDD128 (pctxt, pvalue->u.newOperation);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newOperation);
         }
         break;

   }
}

void asn1Init_utran_HS_DSCH_SPS_Information_TDD128 (
   utran_HS_DSCH_SPS_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (&pvalue->hs_dsch_SPS_Operation);
}

void asn1Free_utran_HS_DSCH_SPS_Information_TDD128 (OSCTXT *pctxt, 
   utran_HS_DSCH_SPS_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_DSCH_SPS_Information_TDD128_hs_dsch_SPS_Operation (pctxt, &pvalue->hs_dsch_SPS_Operation);
}

void asn1Init_utran_SPS_Information_TDD128_r8 (
   utran_SPS_Information_TDD128_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DCH_SPS_Information_TDD128 (&pvalue->e_dch_SPS_Info);
   asn1Init_utran_HS_DSCH_SPS_Information_TDD128 (&pvalue->hs_dsch_SPS_Info);
}

void asn1Free_utran_SPS_Information_TDD128_r8 (OSCTXT *pctxt, 
   utran_SPS_Information_TDD128_r8* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_dch_SPS_InfoPresent) {
      asn1Free_utran_E_DCH_SPS_Information_TDD128 (pctxt, &pvalue->e_dch_SPS_Info);
   }
   if (pvalue->m.hs_dsch_SPS_InfoPresent) {
      asn1Free_utran_HS_DSCH_SPS_Information_TDD128 (pctxt, &pvalue->hs_dsch_SPS_Info);
   }
}

static const OSEnumItem utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTAB[] = {
   { OSUTF8("everyEDCHTTI"), 0, 12, 0 },
   { OSUTF8("ms160"), 5, 5, 2 },
   { OSUTF8("ms20"), 1, 4, 4 },
   { OSUTF8("ms200"), 6, 5, 5 },
   { OSUTF8("ms40"), 2, 4, 6 },
   { OSUTF8("ms60"), 3, 4, 1 },
   { OSUTF8("ms80"), 4, 4, 3 }
} ;
#define utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTABSIZE 7

const OSUTF8CHAR* utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTABSIZE) {
      return utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTAB
         [utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTAB, 
      utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst)
         utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128_t_SI_nst_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128 (
   utran_Non_ScheduledTransGrantInfoTDD_ext_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_ext (
   utran_Non_ScheduledTransGrantInfoTDD_ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Non_ScheduledTransGrantInfoTDD_ext (OSCTXT *pctxt, 
   utran_Non_ScheduledTransGrantInfoTDD_ext* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_ext_tdd (
   utran_UL_EDCH_Information_ext_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_ext (&pvalue->non_ScheduledTransGrantInfo);
}

void asn1Free_utran_UL_EDCH_Information_ext_tdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_ext_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.non_ScheduledTransGrantInfoPresent) {
      asn1Free_utran_Non_ScheduledTransGrantInfoTDD_ext (pctxt, &pvalue->non_ScheduledTransGrantInfo);
   }
}

void asn1Init_utran_UL_EDCH_Information_ext (
   utran_UL_EDCH_Information_ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_EDCH_Information_ext (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_ext* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_EDCH_Information_ext_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128 (
   utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (
   utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (
   utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_ext (
   utran_DL_HSPDSCH_Information_r8_ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_ext (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_HSPDSCH_Information_r8_ext_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[] = {
   { OSUTF8("s1"), 0, 2, 0 },
   { OSUTF8("s2"), 1, 2, 1 },
   { OSUTF8("s3"), 2, 2, 2 },
   { OSUTF8("spare1"), 3, 6, 3 }
} ;
#define utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE 4

const OSUTF8CHAR* utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE) {
      return utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB
         [utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB, 
      utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size)
         utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128_hS_SCCH_tpc_step_size_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128 (
   utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (
   utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (
   utran_HS_SCCH_Info_r8_ext_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r8_ext_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_HS_SCCH_Info_r8_ext (utran_HS_SCCH_Info_r8_ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_HS_SCCH_Info_r8_ext (OSCTXT *pctxt, 
   utran_HS_SCCH_Info_r8_ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HS_SCCH_Info_r8_ext_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_HSPDSCH_Information_r8_ext2 (
   utran_DL_HSPDSCH_Information_r8_ext2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HS_SCCH_Info_r8_ext (&pvalue->hs_scch_Info);
}

void asn1Free_utran_DL_HSPDSCH_Information_r8_ext2 (OSCTXT *pctxt, 
   utran_DL_HSPDSCH_Information_r8_ext2* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hs_scch_InfoPresent) {
      asn1Free_utran_HS_SCCH_Info_r8_ext (pctxt, &pvalue->hs_scch_Info);
   }
}

static const OSEnumItem utran_MAC_hs_WindowSize_r9_ENUMTAB[] = {
   { OSUTF8("mw128"), 8, 5, 6 },
   { OSUTF8("mw64"), 7, 4, 7 },
   { OSUTF8("mws12"), 3, 5, 8 },
   { OSUTF8("mws16"), 4, 5, 2 },
   { OSUTF8("mws24"), 5, 5, 3 },
   { OSUTF8("mws32"), 6, 5, 4 },
   { OSUTF8("mws4"), 0, 4, 5 },
   { OSUTF8("mws6"), 1, 4, 1 },
   { OSUTF8("mws8"), 2, 4, 0 }
} ;
#define utran_MAC_hs_WindowSize_r9_ENUMTABSIZE 9

const OSUTF8CHAR* utran_MAC_hs_WindowSize_r9_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_hs_WindowSize_r9_ENUMTABSIZE) {
      return utran_MAC_hs_WindowSize_r9_ENUMTAB
         [utran_MAC_hs_WindowSize_r9_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_hs_WindowSize_r9_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_hs_WindowSize_r9* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_hs_WindowSize_r9_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_hs_WindowSize_r9_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MAC_hs_WindowSize_r9* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_hs_WindowSize_r9_ENUMTAB, 
      utran_MAC_hs_WindowSize_r9_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_hs_WindowSize_r9)
         utran_MAC_hs_WindowSize_r9_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_r9 (
   utran_MAC_ehs_AddReconfReordQ_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_List_r9 (
   utran_MAC_ehs_AddReconfReordQ_List_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_ehs_AddReconfReordQ_List_r9 (OSCTXT *pctxt, 
   utran_MAC_ehs_AddReconfReordQ_List_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_r9 (
   utran_AddOrReconfMAC_ehs_ReordQ_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_ehs_AddReconfReordQ_List_r9 (&pvalue->mac_ehs_AddReconfQueue_List);
}

void asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_r9 (OSCTXT *pctxt, 
   utran_AddOrReconfMAC_ehs_ReordQ_r9* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_ehs_AddReconfQueue_ListPresent) {
      asn1Free_utran_MAC_ehs_AddReconfReordQ_List_r9 (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
   }
}

void asn1Init_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (
   utran_HSDSCH_Info_r9_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r9_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mac_hs) {
            asn1Free_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_hs);
         }
         break;

      case 2:
         if (0 != pvalue->u.mac_ehs) {
            asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_r9 (pctxt, pvalue->u.mac_ehs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_ehs);
         }
         break;

   }
}

void asn1Init_utran_HSDSCH_Info_r9 (utran_HSDSCH_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r7 (&pvalue->harqInfo);
   asn1Init_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (&pvalue->dl_MAC_HeaderType);
}

void asn1Free_utran_HSDSCH_Info_r9 (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r9* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r7 (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.dl_MAC_HeaderTypePresent) {
      asn1Free_utran_HSDSCH_Info_r9_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            asn1Free_utran_HSDSCH_Info_r9 (pctxt, pvalue->u.hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r9 (
   utran_DL_AddReconfTransChInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TrCH_TypeId1_r5 (&pvalue->dl_TransportChannelType);
   asn1Init_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r9 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r9_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r9 (
   utran_DL_AddReconfTransChInfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r9 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r9* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r9* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r9*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r9 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator)
         utran_UL_EDCH_Information_r9_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (
   utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPCCH_Info_r7 (&pvalue->e_DPCCH_Info);
   asn1Init_utran_E_DPDCH_Info_r8 (&pvalue->e_DPDCH_Info);
   asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (&pvalue->schedulingTransmConfiguration);
}

void asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DPDCH_InfoPresent) {
      asn1Free_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
   }
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768 (
   utran_Non_ScheduledTransGrantInfoTDD_r9_tdd384_768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeslotResourceRelatedInfo.numbits = 0;
   asn1Init_utran_RepetitionPeriodAndLength (&pvalue->repetitionPeriodAndLength);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode (
   utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info (
   utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info_midambleAllocationMode (&pvalue->midambleAllocationMode);
}

static const OSEnumItem utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTAB[] = {
   { OSUTF8("everyEDCHTTI"), 0, 12, 0 },
   { OSUTF8("ms160"), 5, 5, 2 },
   { OSUTF8("ms20"), 1, 4, 4 },
   { OSUTF8("ms200"), 6, 5, 5 },
   { OSUTF8("ms40"), 2, 4, 6 },
   { OSUTF8("ms60"), 3, 4, 1 },
   { OSUTF8("ms80"), 4, 4, 3 }
} ;
#define utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTABSIZE 7

const OSUTF8CHAR* utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTABSIZE) {
      return utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTAB
         [utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTAB, 
      utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst)
         utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_t_SI_nst_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128 (
   utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeslotResourceRelatedInfo.numbits = 0;
   asn1Init_utran_RepetitionPeriodAndLength (&pvalue->repetitionPeriodAndLength);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9_tdd128_e_HICH_Info (&pvalue->e_HICH_Info);
}

void asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9 (
   utran_Non_ScheduledTransGrantInfoTDD_r9* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Non_ScheduledTransGrantInfoTDD_r9 (OSCTXT *pctxt, 
   utran_Non_ScheduledTransGrantInfoTDD_r9* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (
   utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_Info (&pvalue->e_RUCCH_Info);
   asn1Init_utran_E_PUCH_Info (&pvalue->e_PUCH_Info);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9 (&pvalue->non_ScheduledTransGrantInfo);
}

void asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RUCCH_InfoPresent) {
      asn1Free_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
   }
   if (pvalue->m.e_PUCH_InfoPresent) {
      asn1Free_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
   }
   if (pvalue->m.non_ScheduledTransGrantInfoPresent) {
      asn1Free_utran_Non_ScheduledTransGrantInfoTDD_r9 (pctxt, &pvalue->non_ScheduledTransGrantInfo);
   }
}

void asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo (
   utran_UL_EDCH_Information_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r9_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r9 (
   utran_UL_EDCH_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_EDCH_Information_r9_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_EDCH_Information_r9 (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r9_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTAB[] = {
   { OSUTF8("activate"), 0, 8, 0 },
   { OSUTF8("deactivate"), 1, 10, 1 }
} ;
#define utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTABSIZE 2

const OSUTF8CHAR* utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTABSIZE) {
      return utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTAB
         [utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_CellDCHMeasOccasionPattern_LCR_statusFlag* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_CellDCHMeasOccasionPattern_LCR_statusFlag* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTAB, 
      utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_CellDCHMeasOccasionPattern_LCR_statusFlag)
         utran_CellDCHMeasOccasionPattern_LCR_statusFlag_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MeasurementOccasionPatternParameter (
   utran_MeasurementOccasionPatternParameter* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeslotBitmap.numbits = 0;
}

void asn1Init_utran_CellDCHMeasOccasionPattern_LCR (
   utran_CellDCHMeasOccasionPattern_LCR* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->measurementPurpose.numbits = 0;
   asn1Init_utran_MeasurementOccasionPatternParameter (&pvalue->measurementOccasionPatternParameter);
}

void asn1Init_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (
   utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (OSCTXT *pctxt, 
   utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_CellDCHMeasOccasionInfo_TDD128_r9 (
   utran_CellDCHMeasOccasionInfo_TDD128_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (&pvalue->cellDCHMeasOccasionSequenceList);
}

void asn1Free_utran_CellDCHMeasOccasionInfo_TDD128_r9 (OSCTXT *pctxt, 
   utran_CellDCHMeasOccasionInfo_TDD128_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CellDCHMeasOccasionInfo_TDD128_r9_cellDCHMeasOccasionSequenceList (pctxt, &pvalue->cellDCHMeasOccasionSequenceList);
}

static const OSEnumItem utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTAB[] = {
   { OSUTF8("mws160"), 1, 6, 3 },
   { OSUTF8("mws192"), 2, 6, 0 },
   { OSUTF8("mws256"), 3, 6, 1 },
   { OSUTF8("mws96"), 0, 5, 2 }
} ;
#define utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTABSIZE 4

const OSUTF8CHAR* utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTABSIZE) {
      return utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTAB
         [utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_ehs_WindowSize_TDD128_v9c0ext* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MAC_ehs_WindowSize_TDD128_v9c0ext* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTAB, 
      utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_ehs_WindowSize_TDD128_v9c0ext)
         utran_MAC_ehs_WindowSize_TDD128_v9c0ext_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext (
   utran_MAC_ehs_AddReconfReordQ_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (
   utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (OSCTXT *pctxt, 
   utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (
   utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (&pvalue->mac_ehs_AddReconfQueue_List);
}

void asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (OSCTXT *pctxt, 
   utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_ehs_AddReconfQueue_ListPresent) {
      asn1Free_utran_MAC_ehs_AddReconfReordQ_List_TDD128_v9c0ext (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
   }
}

void asn1Init_utran_HSDSCH_Info_TDD128_v9c0ext (
   utran_HSDSCH_Info_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (&pvalue->mac_ehs);
}

void asn1Free_utran_HSDSCH_Info_TDD128_v9c0ext (OSCTXT *pctxt, 
   utran_HSDSCH_Info_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_ehsPresent) {
      asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_TDD128_v9c0ext (pctxt, &pvalue->mac_ehs);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (
   utran_DL_AddReconfTransChInformation_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HSDSCH_Info_TDD128_v9c0ext (&pvalue->hsdsch);
}

void asn1Free_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hsdschPresent) {
      asn1Free_utran_HSDSCH_Info_TDD128_v9c0ext (pctxt, &pvalue->hsdsch);
   }
}

void asn1Init_utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext (
   utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_TDD128_v9c0ext* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_TDD128_v9c0ext* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_TDD128_v9c0ext*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_TDD128_v9c0ext (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_SR_VCC_Info_nonce (utran_SR_VCC_Info_nonce* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_SR_VCC_Info (utran_SR_VCC_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SR_VCC_Info_nonce (&pvalue->nonce);
}

static const OSEnumItem utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTAB[] = {
   { OSUTF8("tsn-14bits"), 0, 10, 0 }
} ;
#define utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTAB, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTABSIZE) {
      return utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTAB, 
      utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length)
         utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128_tsn_Length_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (
   utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (OSCTXT *pctxt, 
   utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (
   utran_E_PUCH_Info_MulticarrierEDCH_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (&pvalue->e_PUCH_TS_ConfigurationList);
}

void asn1Free_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (OSCTXT *pctxt, 
   utran_E_PUCH_Info_MulticarrierEDCH_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_PUCH_Info_MulticarrierEDCH_TDD128_e_PUCH_TS_ConfigurationList (pctxt, &pvalue->e_PUCH_TS_ConfigurationList);
}

void asn1Init_utran_E_AGCH_Information_TDD128 (
   utran_E_AGCH_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_E_AGCH_Set_Config_LCR (&pvalue->e_AGCH_Set_Config);
}

void asn1Free_utran_E_AGCH_Information_TDD128 (OSCTXT *pctxt, 
   utran_E_AGCH_Information_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_E_AGCH_Set_Config_LCR (pctxt, &pvalue->e_AGCH_Set_Config);
}

void asn1Init_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (
   utran_UL_MulticarrierEDCH_InfolistItem_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (&pvalue->e_PUCH_info);
   asn1Init_utran_E_AGCH_Information_TDD128 (&pvalue->e_AGCH_info);
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_info);
}

void asn1Free_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (OSCTXT *pctxt, 
   utran_UL_MulticarrierEDCH_InfolistItem_TDD128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_PUCH_infoPresent) {
      asn1Free_utran_E_PUCH_Info_MulticarrierEDCH_TDD128 (pctxt, &pvalue->e_PUCH_info);
   }
   if (pvalue->m.e_AGCH_infoPresent) {
      asn1Free_utran_E_AGCH_Information_TDD128 (pctxt, &pvalue->e_AGCH_info);
   }
   if (pvalue->m.e_HICH_infoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_info);
   }
}

void asn1Init_utran_UL_MulticarrierEDCH_Infolist_TDD128 (
   utran_UL_MulticarrierEDCH_Infolist_TDD128* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UL_MulticarrierEDCH_Infolist_TDD128 (OSCTXT *pctxt, 
   utran_UL_MulticarrierEDCH_Infolist_TDD128* pvalue)
{
   if (0 == pvalue) return;
   { utran_UL_MulticarrierEDCH_InfolistItem_TDD128* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UL_MulticarrierEDCH_InfolistItem_TDD128*)pnode->data;
      asn1Free_utran_UL_MulticarrierEDCH_InfolistItem_TDD128 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_MulticarrierEDCH_Deletelist_TDD128 (
   utran_UL_MulticarrierEDCH_Deletelist_TDD128* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (
   utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_MulticarrierEDCH_Infolist_TDD128 (&pvalue->ul_MulticarrierEDCH_Infolist);
   asn1Init_utran_UL_MulticarrierEDCH_Deletelist_TDD128 (&pvalue->ul_MulticarrierEDCH_Deletelist);
}

void asn1Free_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (OSCTXT *pctxt, 
   utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_MulticarrierEDCH_InfolistPresent) {
      asn1Free_utran_UL_MulticarrierEDCH_Infolist_TDD128 (pctxt, &pvalue->ul_MulticarrierEDCH_Infolist);
   }
}

void asn1Init_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (
   utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (OSCTXT *pctxt, 
   utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_UL_MulticarrierEDCH_NewConfigurationInfo_TDD128 (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_UL_MulticarrierEDCHInfo_TDD128 (
   utran_UL_MulticarrierEDCHInfo_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (&pvalue->configuration_info);
}

void asn1Free_utran_UL_MulticarrierEDCHInfo_TDD128 (OSCTXT *pctxt, 
   utran_UL_MulticarrierEDCHInfo_TDD128* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_MulticarrierEDCHInfo_TDD128_configuration_info (pctxt, &pvalue->configuration_info);
}

void asn1Init_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r10_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_TGP_Sequence_r10_tgps_Status (
   utran_TGP_Sequence_r10_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TGP_Sequence_r10_tgps_Status (OSCTXT *pctxt, 
   utran_TGP_Sequence_r10_tgps_Status* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.activate) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.activate);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTABSIZE 1

const OSUTF8CHAR* utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTAB, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTABSIZE) {
      return utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTAB, 
      utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode)
         utran_TGPS_ConfigurationParams_r10_freqSpecificCompressedMode_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_TGPS_ConfigurationParams_r10 (
   utran_TGPS_ConfigurationParams_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DL_Mode (&pvalue->ul_DL_Mode);
}

void asn1Free_utran_TGPS_ConfigurationParams_r10 (OSCTXT *pctxt, 
   utran_TGPS_ConfigurationParams_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DL_Mode (pctxt, &pvalue->ul_DL_Mode);
}

void asn1Init_utran_TGP_Sequence_r10 (utran_TGP_Sequence_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TGP_Sequence_r10_tgps_Status (&pvalue->tgps_Status);
   asn1Init_utran_TGPS_ConfigurationParams_r10 (&pvalue->tgps_ConfigurationParams);
}

void asn1Free_utran_TGP_Sequence_r10 (OSCTXT *pctxt, 
   utran_TGP_Sequence_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_Sequence_r10_tgps_Status (pctxt, &pvalue->tgps_Status);
   if (pvalue->m.tgps_ConfigurationParamsPresent) {
      asn1Free_utran_TGPS_ConfigurationParams_r10 (pctxt, &pvalue->tgps_ConfigurationParams);
   }
}

void asn1Init_utran_TGP_SequenceList_r10 (utran_TGP_SequenceList_r10* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TGP_SequenceList_r10 (OSCTXT *pctxt, 
   utran_TGP_SequenceList_r10* pvalue)
{
   if (0 == pvalue) return;
   { utran_TGP_Sequence_r10* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TGP_Sequence_r10*)pnode->data;
      asn1Free_utran_TGP_Sequence_r10 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DPCH_CompressedModeInfo_r10 (
   utran_DPCH_CompressedModeInfo_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TGP_SequenceList_r10 (&pvalue->tgp_SequenceList);
}

void asn1Free_utran_DPCH_CompressedModeInfo_r10 (OSCTXT *pctxt, 
   utran_DPCH_CompressedModeInfo_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TGP_SequenceList_r10 (pctxt, &pvalue->tgp_SequenceList);
}

void asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r10_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo_r10 (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r10_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo (
   utran_DL_CommonInformation_r10_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r10_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r10_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r10_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r10_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r10_mac_hsResetIndicator)
         utran_DL_CommonInformation_r10_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r10_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r10_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r10_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r10_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r10_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r10_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r10_postVerificationPeriod)
         utran_DL_CommonInformation_r10_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r10 (
   utran_DL_CommonInformation_r10* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r10_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r10 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r10* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r10_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r10_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_MU_MIMO_Operation_ENUMTAB[] = {
   { OSUTF8("dL"), 1, 2, 2 },
   { OSUTF8("spare"), 3, 5, 0 },
   { OSUTF8("uL"), 0, 2, 3 },
   { OSUTF8("uLandDL"), 2, 7, 1 }
} ;
#define utran_MU_MIMO_Operation_ENUMTABSIZE 4

const OSUTF8CHAR* utran_MU_MIMO_Operation_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MU_MIMO_Operation_ENUMTABSIZE) {
      return utran_MU_MIMO_Operation_ENUMTAB
         [utran_MU_MIMO_Operation_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MU_MIMO_Operation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MU_MIMO_Operation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MU_MIMO_Operation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MU_MIMO_Operation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MU_MIMO_Operation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MU_MIMO_Operation_ENUMTAB, utran_MU_MIMO_Operation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MU_MIMO_Operation)
         utran_MU_MIMO_Operation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTAB[] = {
   { OSUTF8("spare"), 7, 5, 1 },
   { OSUTF8("v1"), 0, 2, 3 },
   { OSUTF8("v16"), 4, 3, 5 },
   { OSUTF8("v2"), 1, 2, 7 },
   { OSUTF8("v32"), 5, 3, 2 },
   { OSUTF8("v4"), 2, 2, 4 },
   { OSUTF8("v64"), 6, 3, 6 },
   { OSUTF8("v8"), 3, 2, 0 }
} ;
#define utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTABSIZE 8

const OSUTF8CHAR* utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTABSIZE) {
      return utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTAB
         [utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_StandaloneMidambleInfo_TDD128_repetitionPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_StandaloneMidambleInfo_TDD128_repetitionPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTAB, 
      utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_StandaloneMidambleInfo_TDD128_repetitionPeriod)
         utran_StandaloneMidambleInfo_TDD128_repetitionPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_StandaloneMidambleInfo_TDD128 (
   utran_StandaloneMidambleInfo_TDD128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->timeSlotInformation.numbits = 0;
}

void asn1Init_utran_MU_MIMO_Info_TDD128_newConfiguration (
   utran_MU_MIMO_Info_TDD128_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_StandaloneMidambleInfo_TDD128 (&pvalue->standaloneMidambleInfo);
}

void asn1Init_utran_MU_MIMO_Info_TDD128 (utran_MU_MIMO_Info_TDD128* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_MU_MIMO_Info_TDD128 (OSCTXT *pctxt, 
   utran_MU_MIMO_Info_TDD128* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

static const OSEnumItem utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTAB[] = {
   { OSUTF8("size15"), 1, 6, 1 },
   { OSUTF8("size7"), 0, 5, 0 }
} ;
#define utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE 2

const OSUTF8CHAR* utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE) {
      return utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTAB
         [utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTAB, 
      utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize)
         utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size_flexibleSize_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (
   utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (OSCTXT *pctxt, 
   utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fixedSize) {
            asn1Free_utran_OctetModeRLC_SizeInfoType1 (pctxt, pvalue->u.fixedSize);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fixedSize);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_TimerReordering_ENUMTAB[] = {
   { OSUTF8("tr100"), 1, 5, 5 },
   { OSUTF8("tr1000"), 7, 6, 0 },
   { OSUTF8("tr150"), 2, 5, 2 },
   { OSUTF8("tr200"), 3, 5, 3 },
   { OSUTF8("tr400"), 4, 5, 4 },
   { OSUTF8("tr50"), 0, 4, 6 },
   { OSUTF8("tr600"), 5, 5, 7 },
   { OSUTF8("tr800"), 6, 5, 1 }
} ;
#define utran_TimerReordering_ENUMTABSIZE 8

const OSUTF8CHAR* utran_TimerReordering_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimerReordering_ENUMTABSIZE) {
      return utran_TimerReordering_ENUMTAB
         [utran_TimerReordering_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimerReordering_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimerReordering* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimerReordering_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimerReordering_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimerReordering* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_TimerReordering_ENUMTAB, utran_TimerReordering_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimerReordering)
         utran_TimerReordering_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_RLC_StatusInfo_r11 (utran_DL_RLC_StatusInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_AM_RLC_Mode_r11 (utran_DL_AM_RLC_Mode_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (&pvalue->dl_RLC_PDU_size);
   asn1Init_utran_DL_RLC_StatusInfo_r11 (&pvalue->dl_RLC_StatusInfo);
}

void asn1Free_utran_DL_AM_RLC_Mode_r11 (OSCTXT *pctxt, 
   utran_DL_AM_RLC_Mode_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AM_RLC_Mode_r11_dl_RLC_PDU_size (pctxt, &pvalue->dl_RLC_PDU_size);
}

void asn1Init_utran_DL_RLC_Mode_r11 (utran_DL_RLC_Mode_r11* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_RLC_Mode_r11 (OSCTXT *pctxt, 
   utran_DL_RLC_Mode_r11* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_AM_RLC_Mode) {
            asn1Free_utran_DL_AM_RLC_Mode_r11 (pctxt, pvalue->u.dl_AM_RLC_Mode);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_AM_RLC_Mode);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_UM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_UM_RLC_Mode);
         }
         break;

      case 3:
         if (0 != pvalue->u.dl_TM_RLC_Mode) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_TM_RLC_Mode);
         }
         break;

   }
}

static const OSEnumItem utran_RLC_Info_r11_altE_bitInterpretation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_RLC_Info_r11_altE_bitInterpretation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_RLC_Info_r11_altE_bitInterpretation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_RLC_Info_r11_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r11_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_RLC_Info_r11_altE_bitInterpretation_ENUMTABSIZE) {
      return utran_RLC_Info_r11_altE_bitInterpretation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_Info_r11_altE_bitInterpretation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RLC_Info_r11_altE_bitInterpretation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_Info_r11_altE_bitInterpretation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_Info_r11_altE_bitInterpretation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_Info_r11_altE_bitInterpretation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_Info_r11_altE_bitInterpretation_ENUMTAB, 
      utran_RLC_Info_r11_altE_bitInterpretation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_Info_r11_altE_bitInterpretation)
         utran_RLC_Info_r11_altE_bitInterpretation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTABSIZE 1

const OSUTF8CHAR* utran_RLC_Info_r11_useSpecialValueOfHEField_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTAB, 
      utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTABSIZE) {
      return utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RLC_Info_r11_useSpecialValueOfHEField_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_RLC_Info_r11_useSpecialValueOfHEField* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RLC_Info_r11_useSpecialValueOfHEField_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RLC_Info_r11_useSpecialValueOfHEField_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RLC_Info_r11_useSpecialValueOfHEField* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTAB, 
      utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RLC_Info_r11_useSpecialValueOfHEField)
         utran_RLC_Info_r11_useSpecialValueOfHEField_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RLC_Info_r11 (utran_RLC_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_RLC_Mode (&pvalue->ul_RLC_Mode);
   asn1Init_utran_DL_RLC_Mode_r11 (&pvalue->dl_RLC_Mode);
}

void asn1Free_utran_RLC_Info_r11 (OSCTXT *pctxt, utran_RLC_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_RLC_ModePresent) {
      asn1Free_utran_UL_RLC_Mode (pctxt, &pvalue->ul_RLC_Mode);
   }
   if (pvalue->m.dl_RLC_ModePresent) {
      asn1Free_utran_DL_RLC_Mode_r11 (pctxt, &pvalue->dl_RLC_Mode);
   }
}

void asn1Init_utran_RB_InformationReconfig_r11 (
   utran_RB_InformationReconfig_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_InfoReconfig_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_Info_r11 (&pvalue->rlc_Info);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationReconfig_r11 (OSCTXT *pctxt, 
   utran_RB_InformationReconfig_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_InfoReconfig_r4 (pctxt, &pvalue->pdcp_Info);
   }
   if (pvalue->m.rlc_InfoPresent) {
      asn1Free_utran_RLC_Info_r11 (pctxt, &pvalue->rlc_Info);
   }
   if (pvalue->m.rb_MappingInfoPresent) {
      asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
   }
}

void asn1Init_utran_RB_InformationReconfigList_r11 (
   utran_RB_InformationReconfigList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationReconfigList_r11 (OSCTXT *pctxt, 
   utran_RB_InformationReconfigList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationReconfig_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationReconfig_r11*)pnode->data;
      asn1Free_utran_RB_InformationReconfig_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_MAC_hs_WindowSize_r11_ENUMTAB[] = {
   { OSUTF8("mws12"), 3, 5, 6 },
   { OSUTF8("mws128"), 8, 6, 7 },
   { OSUTF8("mws16"), 4, 5, 9 },
   { OSUTF8("mws24"), 5, 5, 0 },
   { OSUTF8("mws256"), 9, 6, 2 },
   { OSUTF8("mws32"), 6, 5, 3 },
   { OSUTF8("mws4"), 0, 4, 5 },
   { OSUTF8("mws6"), 1, 4, 8 },
   { OSUTF8("mws64"), 7, 5, 1 },
   { OSUTF8("mws8"), 2, 4, 4 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define utran_MAC_hs_WindowSize_r11_ENUMTABSIZE 16

const OSUTF8CHAR* utran_MAC_hs_WindowSize_r11_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MAC_hs_WindowSize_r11_ENUMTABSIZE) {
      return utran_MAC_hs_WindowSize_r11_ENUMTAB
         [utran_MAC_hs_WindowSize_r11_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MAC_hs_WindowSize_r11_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MAC_hs_WindowSize_r11* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MAC_hs_WindowSize_r11_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MAC_hs_WindowSize_r11_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MAC_hs_WindowSize_r11* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MAC_hs_WindowSize_r11_ENUMTAB, 
      utran_MAC_hs_WindowSize_r11_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MAC_hs_WindowSize_r11)
         utran_MAC_hs_WindowSize_r11_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_r11 (
   utran_MAC_ehs_AddReconfReordQ_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_MAC_ehs_AddReconfReordQ_List_r11 (
   utran_MAC_ehs_AddReconfReordQ_List_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_MAC_ehs_AddReconfReordQ_List_r11 (OSCTXT *pctxt, 
   utran_MAC_ehs_AddReconfReordQ_List_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_AddOrReconfMAC_ehs_ReordQ_r11 (
   utran_AddOrReconfMAC_ehs_ReordQ_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MAC_ehs_AddReconfReordQ_List_r11 (&pvalue->mac_ehs_AddReconfQueue_List);
}

void asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_r11 (OSCTXT *pctxt, 
   utran_AddOrReconfMAC_ehs_ReordQ_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.mac_ehs_AddReconfQueue_ListPresent) {
      asn1Free_utran_MAC_ehs_AddReconfReordQ_List_r11 (pctxt, &pvalue->mac_ehs_AddReconfQueue_List);
   }
}

void asn1Init_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (
   utran_HSDSCH_Info_r11_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r11_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mac_hs) {
            asn1Free_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_hs);
         }
         break;

      case 2:
         if (0 != pvalue->u.mac_ehs) {
            asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pctxt, pvalue->u.mac_ehs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_ehs);
         }
         break;

   }
}

void asn1Init_utran_HSDSCH_Info_r11 (utran_HSDSCH_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r11 (&pvalue->harqInfo);
   asn1Init_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (&pvalue->dl_MAC_HeaderType);
}

void asn1Free_utran_HSDSCH_Info_r11 (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r11 (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.dl_MAC_HeaderTypePresent) {
      asn1Free_utran_HSDSCH_Info_r11_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            asn1Free_utran_HSDSCH_Info_r11 (pctxt, pvalue->u.hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r11 (
   utran_DL_AddReconfTransChInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TrCH_TypeId1_r5 (&pvalue->dl_TransportChannelType);
   asn1Init_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r11 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r11_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r11 (
   utran_DL_AddReconfTransChInfoList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r11 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r11*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_fdd (
   utran_UL_DPCH_PowerControlInfo_r11_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerControlAlgorithm (&pvalue->powerControlAlgorithm);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IndividualTS_InterferenceList (&pvalue->individualTS_InterferenceList);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IndividualTS_InterferenceList (pctxt, &pvalue->individualTS_InterferenceList);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128 (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd384 (pctxt, pvalue->u.tdd384);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd768) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption_tdd768 (pctxt, pvalue->u.tdd768);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd768);
         }
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.individuallySignalled) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling_individuallySignalled (pctxt, pvalue->u.individuallySignalled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.individuallySignalled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd (
   utran_UL_DPCH_PowerControlInfo_r11_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (&pvalue->ul_OL_PC_Signalling);
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd_ul_OL_PC_Signalling (pctxt, &pvalue->ul_OL_PC_Signalling);
}

void asn1Init_utran_UL_DPCH_PowerControlInfo_r11 (
   utran_UL_DPCH_PowerControlInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_PowerControlInfo_r11 (OSCTXT *pctxt, 
   utran_UL_DPCH_PowerControlInfo_r11* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_PowerControlInfo_r11_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present (
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_present* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->numberOfDPDCH = 1;
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent (
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence_notPresent* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.present) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.present);
         }
         break;

      case 2:
         if (0 != pvalue->u.notPresent) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.notPresent);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (&pvalue->dpdchPresence);
}

void asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd_dpdchPresence (pctxt, &pvalue->dpdchPresence);
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (
   utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_r7 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UL_CCTrCHList_r7 (&pvalue->ul_CCTrCHList);
   asn1Init_utran_UL_CCTrCHListToRemove (&pvalue->ul_CCTrCHListToRemove);
}

void asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_r7 (pctxt, &pvalue->ul_TimingAdvance);
   }
   if (pvalue->m.ul_CCTrCHListPresent) {
      asn1Free_utran_UL_CCTrCHList_r7 (pctxt, &pvalue->ul_CCTrCHList);
   }
}

void asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo (
   utran_UL_DPCH_Info_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_Info_r11 (utran_UL_DPCH_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_DPCH_PowerControlInfo_r11 (&pvalue->ul_DPCH_PowerControlInfo);
   asn1Init_utran_UL_DPCH_Info_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_DPCH_Info_r11 (OSCTXT *pctxt, 
   utran_UL_DPCH_Info_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_UL_DPCH_PowerControlInfo_r11 (pctxt, &pvalue->ul_DPCH_PowerControlInfo);
   }
   asn1Free_utran_UL_DPCH_Info_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

static const OSEnumItem utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTABSIZE) {
      return utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTAB, 
      utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator)
         utran_UL_EDCH_Information_r11_mac_es_e_resetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (
   utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_DPCCH_Info_r7 (&pvalue->e_DPCCH_Info);
   asn1Init_utran_E_DPDCH_Info_r8 (&pvalue->e_DPDCH_Info);
   asn1Init_utran_UL_MIMO_InfoFDD (&pvalue->ul_MIMO_Info);
   asn1Init_utran_E_DPDCH_SchedulingTransmConfiguration (&pvalue->schedulingTransmConfiguration);
}

void asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_DPDCH_InfoPresent) {
      asn1Free_utran_E_DPDCH_Info_r8 (pctxt, &pvalue->e_DPDCH_Info);
   }
   if (pvalue->m.ul_MIMO_InfoPresent) {
      asn1Free_utran_UL_MIMO_InfoFDD (pctxt, &pvalue->ul_MIMO_Info);
   }
}

void asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (
   utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_RUCCH_Info (&pvalue->e_RUCCH_Info);
   asn1Init_utran_E_PUCH_Info (&pvalue->e_PUCH_Info);
   asn1Init_utran_Non_ScheduledTransGrantInfoTDD_r9 (&pvalue->non_ScheduledTransGrantInfo);
}

void asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_RUCCH_InfoPresent) {
      asn1Free_utran_E_RUCCH_Info (pctxt, &pvalue->e_RUCCH_Info);
   }
   if (pvalue->m.e_PUCH_InfoPresent) {
      asn1Free_utran_E_PUCH_Info (pctxt, &pvalue->e_PUCH_Info);
   }
   if (pvalue->m.non_ScheduledTransGrantInfoPresent) {
      asn1Free_utran_Non_ScheduledTransGrantInfoTDD_r9 (pctxt, &pvalue->non_ScheduledTransGrantInfo);
   }
}

void asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo (
   utran_UL_EDCH_Information_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_EDCH_Information_r11 (
   utran_UL_EDCH_Information_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_EDCH_Information_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_UL_EDCH_Information_r11 (OSCTXT *pctxt, 
   utran_UL_EDCH_Information_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r11_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo_r10 (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo (
   utran_DL_CommonInformation_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r11_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r11_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r11_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r11_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r11_mac_hsResetIndicator)
         utran_DL_CommonInformation_r11_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r11_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r11_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r11_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r11_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r11_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r11_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r11_postVerificationPeriod)
         utran_DL_CommonInformation_r11_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting)
         utran_DL_CommonInformation_r11_mac_hsResetIndicator_assisting_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r11 (
   utran_DL_CommonInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r11 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r11_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo (
   utran_DL_InformationPerRL_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_dl_dpchInfo (
   utran_DL_InformationPerRL_r11_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r7 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

      case 3:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.f_TPICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.f_TPICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (&pvalue->e_RGCH_Info);
   asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (&pvalue->f_TPICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
   if (pvalue->m.f_TPICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768 (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD384_768 (&pvalue->e_HICH_Info);
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (
   utran_DL_InformationPerRL_r11_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r11 (
   utran_DL_InformationPerRL_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r11_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_AGCH_Information_r8 (&pvalue->e_AGCH_Information);
   asn1Init_utran_E_ROCH_Information (&pvalue->e_ROCH_Information);
   asn1Init_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (&pvalue->modeSpecificInfo2);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r11 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r11_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_AGCH_InformationPresent) {
      asn1Free_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
   }
   asn1Free_utran_DL_InformationPerRL_r11_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
}

void asn1Init_utran_DL_InformationPerRL_List_r11 (
   utran_DL_InformationPerRL_List_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r11 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r11*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_CommonERGCHChannelConfig (
   utran_CommonERGCHChannelConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (
   utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (OSCTXT *pctxt, 
   utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

static const OSEnumItem utran_FilterCoefficient_ENUMTAB[] = {
   { OSUTF8("fc0"), 0, 3, 0 },
   { OSUTF8("fc1"), 1, 3, 1 },
   { OSUTF8("fc11"), 10, 4, 7 },
   { OSUTF8("fc13"), 11, 4, 8 },
   { OSUTF8("fc15"), 12, 4, 9 },
   { OSUTF8("fc17"), 13, 4, 10 },
   { OSUTF8("fc19"), 14, 4, 11 },
   { OSUTF8("fc2"), 2, 3, 12 },
   { OSUTF8("fc3"), 3, 3, 13 },
   { OSUTF8("fc4"), 4, 3, 14 },
   { OSUTF8("fc5"), 5, 3, 2 },
   { OSUTF8("fc6"), 6, 3, 3 },
   { OSUTF8("fc7"), 7, 3, 4 },
   { OSUTF8("fc8"), 8, 3, 5 },
   { OSUTF8("fc9"), 9, 3, 6 },
   { OSUTF8("spare1"), 15, 6, 15 }
} ;
#define utran_FilterCoefficient_ENUMTABSIZE 16

const OSUTF8CHAR* utran_FilterCoefficient_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_FilterCoefficient_ENUMTABSIZE) {
      return utran_FilterCoefficient_ENUMTAB
         [utran_FilterCoefficient_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_FilterCoefficient_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_FilterCoefficient* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_FilterCoefficient_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_FilterCoefficient_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_FilterCoefficient* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_FilterCoefficient_ENUMTAB, utran_FilterCoefficient_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_FilterCoefficient)
         utran_FilterCoefficient_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (
   utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->eRGCHNeighbourCellList.numbits = 0;
   asn1Init_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (&pvalue->commonERGCHChannelConfigList);
   pvalue->filterCoefficient = utran_fc0_3;
}

void asn1Free_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration_commonERGCHChannelConfigList (pctxt, &pvalue->commonERGCHChannelConfigList);
}

void asn1Init_utran_CommonERGCHInfoFDD_configurationInfo (
   utran_CommonERGCHInfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_CommonERGCHInfoFDD_configurationInfo (OSCTXT *pctxt, 
   utran_CommonERGCHInfoFDD_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_CommonERGCHInfoFDD_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_CommonERGCHInfoFDD (utran_CommonERGCHInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_CommonERGCHInfoFDD_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_CommonERGCHInfoFDD (OSCTXT *pctxt, 
   utran_CommonERGCHInfoFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_CommonERGCHInfoFDD_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_GainFactorInformation_10msMode_signalledGainFactors (
   utran_GainFactorInformation_10msMode_signalledGainFactors* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_GainFactorInformation_10msMode (
   utran_GainFactorInformation_10msMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_GainFactorInformation_10msMode (OSCTXT *pctxt, 
   utran_GainFactorInformation_10msMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.signalledGainFactors) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.signalledGainFactors);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_PowerOffsetInformation_10msMode (
   utran_PowerOffsetInformation_10msMode* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_GainFactorInformation_10msMode (&pvalue->gainFactorInformation);
}

void asn1Free_utran_PowerOffsetInformation_10msMode (OSCTXT *pctxt, 
   utran_PowerOffsetInformation_10msMode* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_GainFactorInformation_10msMode (pctxt, &pvalue->gainFactorInformation);
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PowerOffsetInformation (&pvalue->powerOffsetInformation);
   asn1Init_utran_PowerOffsetInformation_10msMode (&pvalue->powerOffsetInformation_10msMode);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.powerOffsetInformationPresent) {
      asn1Free_utran_PowerOffsetInformation (pctxt, &pvalue->powerOffsetInformation);
   }
   if (pvalue->m.powerOffsetInformation_10msModePresent) {
      asn1Free_utran_PowerOffsetInformation_10msMode (pctxt, &pvalue->powerOffsetInformation_10msMode);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit* pvalue)
{
   if (0 == pvalue) return;
   { utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element*)pnode->data;
      asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize (
   utran_TFCS_ReconfAdd_r12_ctfcSize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12_ctfcSize* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ctfc2Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc2Bit (pctxt, pvalue->u.ctfc2Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc2Bit);
         }
         break;

      case 2:
         if (0 != pvalue->u.ctfc4Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc4Bit (pctxt, pvalue->u.ctfc4Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc4Bit);
         }
         break;

      case 3:
         if (0 != pvalue->u.ctfc6Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc6Bit (pctxt, pvalue->u.ctfc6Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc6Bit);
         }
         break;

      case 4:
         if (0 != pvalue->u.ctfc8Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc8Bit (pctxt, pvalue->u.ctfc8Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc8Bit);
         }
         break;

      case 5:
         if (0 != pvalue->u.ctfc12Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc12Bit (pctxt, pvalue->u.ctfc12Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc12Bit);
         }
         break;

      case 6:
         if (0 != pvalue->u.ctfc16Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc16Bit (pctxt, pvalue->u.ctfc16Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc16Bit);
         }
         break;

      case 7:
         if (0 != pvalue->u.ctfc24Bit) {
            asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize_ctfc24Bit (pctxt, pvalue->u.ctfc24Bit);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ctfc24Bit);
         }
         break;

   }
}

void asn1Init_utran_TFCS_ReconfAdd_r12 (utran_TFCS_ReconfAdd_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_ReconfAdd_r12_ctfcSize (&pvalue->ctfcSize);
}

void asn1Free_utran_TFCS_ReconfAdd_r12 (OSCTXT *pctxt, 
   utran_TFCS_ReconfAdd_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS_ReconfAdd_r12_ctfcSize (pctxt, &pvalue->ctfcSize);
}

void asn1Init_utran_ExplicitTFCS_Configuration_r12_replacement (
   utran_ExplicitTFCS_Configuration_r12_replacement* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_RemovalList (&pvalue->tfcsRemoval);
   asn1Init_utran_TFCS_ReconfAdd_r12 (&pvalue->tfcsAdd);
}

void asn1Free_utran_ExplicitTFCS_Configuration_r12_replacement (OSCTXT *pctxt, 
   utran_ExplicitTFCS_Configuration_r12_replacement* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS_RemovalList (pctxt, &pvalue->tfcsRemoval);
   asn1Free_utran_TFCS_ReconfAdd_r12 (pctxt, &pvalue->tfcsAdd);
}

void asn1Init_utran_ExplicitTFCS_Configuration_r12 (
   utran_ExplicitTFCS_Configuration_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_ExplicitTFCS_Configuration_r12 (OSCTXT *pctxt, 
   utran_ExplicitTFCS_Configuration_r12* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.complete) {
            asn1Free_utran_TFCS_ReconfAdd_r12 (pctxt, pvalue->u.complete);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.complete);
         }
         break;

      case 2:
         if (0 != pvalue->u.addition) {
            asn1Free_utran_TFCS_ReconfAdd_r12 (pctxt, pvalue->u.addition);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.addition);
         }
         break;

      case 3:
         if (0 != pvalue->u.removal) {
            asn1Free_utran_TFCS_RemovalList (pctxt, pvalue->u.removal);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.removal);
         }
         break;

      case 4:
         if (0 != pvalue->u.replacement) {
            asn1Free_utran_ExplicitTFCS_Configuration_r12_replacement (pctxt, pvalue->u.replacement);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.replacement);
         }
         break;

   }
}

void asn1Init_utran_TFCS_r12 (utran_TFCS_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_TFCS_r12 (OSCTXT *pctxt, utran_TFCS_r12* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.normalTFCI_Signalling) {
            asn1Free_utran_ExplicitTFCS_Configuration_r12 (pctxt, pvalue->u.normalTFCI_Signalling);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.normalTFCI_Signalling);
         }
         break;

   }
}

void asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_TFCS_r12 (&pvalue->ul_TFCS);
}

void asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_TFCS_r12 (pctxt, &pvalue->ul_TFCS);
}

void asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_IndividualUL_CCTrCH_InfoList (&pvalue->individualUL_CCTrCH_InfoList);
}

void asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.individualUL_CCTrCH_InfoListPresent) {
      asn1Free_utran_IndividualUL_CCTrCH_InfoList (pctxt, &pvalue->individualUL_CCTrCH_InfoList);
   }
}

void asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_UL_CommonTransChInfo_r12 (
   utran_UL_CommonTransChInfo_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_TFC_Subset (&pvalue->tfc_Subset);
   asn1Init_utran_TFCS (&pvalue->prach_TFCS);
   asn1Init_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_TFC_SubsetList (&pvalue->tfc_SubsetList);
}

void asn1Free_utran_UL_CommonTransChInfo_r12 (OSCTXT *pctxt, 
   utran_UL_CommonTransChInfo_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.tfc_SubsetPresent) {
      asn1Free_utran_TFC_Subset (pctxt, &pvalue->tfc_Subset);
   }
   if (pvalue->m.prach_TFCSPresent) {
      asn1Free_utran_TFCS (pctxt, &pvalue->prach_TFCS);
   }
   if (pvalue->m.modeSpecificInfoPresent) {
      asn1Free_utran_UL_CommonTransChInfo_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   }
   if (pvalue->m.tfc_SubsetListPresent) {
      asn1Free_utran_TFC_SubsetList (pctxt, &pvalue->tfc_SubsetList);
   }
}

void asn1Init_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (
   utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_EDCH_Information_r11 (&pvalue->ul_EDCH_Information);
   asn1Init_utran_UL_AddReconfTransChInfoList_r8 (&pvalue->ul_AddReconfTransChInfoList);
   asn1Init_utran_DTX_DRX_TimingInfo_r7 (&pvalue->dtx_drx_TimingInfo);
   asn1Init_utran_DTX_DRX_Info_r12 (&pvalue->dtx_drx_Info);
}

void asn1Free_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r11 (pctxt, &pvalue->ul_EDCH_Information);
   asn1Free_utran_UL_AddReconfTransChInfoList_r8 (pctxt, &pvalue->ul_AddReconfTransChInfoList);
   if (pvalue->m.dtx_drx_TimingInfoPresent) {
      asn1Free_utran_DTX_DRX_TimingInfo_r7 (pctxt, &pvalue->dtx_drx_TimingInfo);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
   }
}

void asn1Init_utran_UL_OtherTTIConfiguration_Information_configurationInfo (
   utran_UL_OtherTTIConfiguration_Information_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_OtherTTIConfiguration_Information_configurationInfo (OSCTXT *pctxt, 
   utran_UL_OtherTTIConfiguration_Information_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_UL_OtherTTIConfiguration_Information_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

static const OSEnumItem utran_ActivationDelay_ENUMTAB[] = {
   { OSUTF8("radio-frames-0"), 0, 14, 0 },
   { OSUTF8("radio-frames-1"), 1, 14, 1 },
   { OSUTF8("radio-frames-2"), 2, 14, 2 },
   { OSUTF8("radio-frames-3"), 3, 14, 3 },
   { OSUTF8("radio-frames-4"), 4, 14, 4 },
   { OSUTF8("radio-frames-5"), 5, 14, 5 },
   { OSUTF8("spare1"), 7, 6, 7 },
   { OSUTF8("spare2"), 6, 6, 6 }
} ;
#define utran_ActivationDelay_ENUMTABSIZE 8

const OSUTF8CHAR* utran_ActivationDelay_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_ActivationDelay_ENUMTABSIZE) {
      return utran_ActivationDelay_ENUMTAB
         [utran_ActivationDelay_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_ActivationDelay_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_ActivationDelay* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_ActivationDelay_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_ActivationDelay_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_ActivationDelay* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_ActivationDelay_ENUMTAB, utran_ActivationDelay_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_ActivationDelay)
         utran_ActivationDelay_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UL_OtherTTIConfiguration_Information (
   utran_UL_OtherTTIConfiguration_Information* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_OtherTTIConfiguration_Information_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_UL_OtherTTIConfiguration_Information (OSCTXT *pctxt, 
   utran_UL_OtherTTIConfiguration_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_OtherTTIConfiguration_Information_configurationInfo (pctxt, &pvalue->configurationInfo);
}

static const OSEnumItem utran_TimeToTrigger_ENUMTAB[] = {
   { OSUTF8("tt320"), 11, 5, 1 },
   { OSUTF8("ttt0"), 0, 4, 2 },
   { OSUTF8("ttt10"), 1, 5, 7 },
   { OSUTF8("ttt100"), 6, 6, 11 },
   { OSUTF8("ttt120"), 7, 6, 13 },
   { OSUTF8("ttt1280"), 13, 7, 15 },
   { OSUTF8("ttt160"), 8, 6, 3 },
   { OSUTF8("ttt20"), 2, 5, 4 },
   { OSUTF8("ttt200"), 9, 6, 6 },
   { OSUTF8("ttt240"), 10, 6, 8 },
   { OSUTF8("ttt2560"), 14, 7, 9 },
   { OSUTF8("ttt40"), 3, 5, 0 },
   { OSUTF8("ttt5000"), 15, 7, 14 },
   { OSUTF8("ttt60"), 4, 5, 5 },
   { OSUTF8("ttt640"), 12, 6, 10 },
   { OSUTF8("ttt80"), 5, 5, 12 }
} ;
#define utran_TimeToTrigger_ENUMTABSIZE 16

const OSUTF8CHAR* utran_TimeToTrigger_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_TimeToTrigger_ENUMTABSIZE) {
      return utran_TimeToTrigger_ENUMTAB
         [utran_TimeToTrigger_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_TimeToTrigger_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_TimeToTrigger* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_TimeToTrigger_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_TimeToTrigger_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_TimeToTrigger* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_TimeToTrigger_ENUMTAB, 
      utran_TimeToTrigger_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_TimeToTrigger)utran_TimeToTrigger_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_FilteredUEPowerHeadroomReportInfo (
   utran_FilteredUEPowerHeadroomReportInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain (
   utran_DL_DPCH_InfoCommon_r12_cfnHandling_maintain* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12_cfnHandling (
   utran_DL_DPCH_InfoCommon_r12_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r12_cfnHandling (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r12_cfnHandling* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.maintain) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.maintain);
         }
         break;

      case 2:
         break;

   }
}

static const OSEnumItem utran_PilotBits128_r12_ENUMTAB[] = {
   { OSUTF8("pb0"), 0, 3, 0 },
   { OSUTF8("pb4"), 1, 3, 1 },
   { OSUTF8("pb8"), 2, 3, 2 }
} ;
#define utran_PilotBits128_r12_ENUMTABSIZE 3

const OSUTF8CHAR* utran_PilotBits128_r12_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PilotBits128_r12_ENUMTABSIZE) {
      return utran_PilotBits128_r12_ENUMTAB
         [utran_PilotBits128_r12_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PilotBits128_r12_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PilotBits128_r12* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PilotBits128_r12_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PilotBits128_r12_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PilotBits128_r12* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PilotBits128_r12_ENUMTAB, utran_PilotBits128_r12_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PilotBits128_r12)
         utran_PilotBits128_r12_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PilotBits256_r12_ENUMTAB[] = {
   { OSUTF8("pb0"), 0, 3, 0 },
   { OSUTF8("pb2"), 1, 3, 1 },
   { OSUTF8("pb4"), 2, 3, 2 },
   { OSUTF8("pb8"), 3, 3, 3 }
} ;
#define utran_PilotBits256_r12_ENUMTABSIZE 4

const OSUTF8CHAR* utran_PilotBits256_r12_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_PilotBits256_r12_ENUMTABSIZE) {
      return utran_PilotBits256_r12_ENUMTAB
         [utran_PilotBits256_r12_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PilotBits256_r12_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_PilotBits256_r12* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PilotBits256_r12_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PilotBits256_r12_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_PilotBits256_r12* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PilotBits256_r12_ENUMTAB, utran_PilotBits256_r12_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PilotBits256_r12)
         utran_PilotBits256_r12_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_SF512_AndPilot_r12 (utran_SF512_AndPilot_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
   asn1Init_utran_Dl_rate_matching_restriction (&pvalue->dl_rate_matching_restriction);
   asn1Init_utran_SF512_AndPilot_r12 (&pvalue->spreadingFactorAndPilot);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
   if (pvalue->m.dl_rate_matching_restrictionPresent) {
      asn1Free_utran_Dl_rate_matching_restriction (pctxt, &pvalue->dl_rate_matching_restriction);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoCommon_r12 (
   utran_DL_DPCH_InfoCommon_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_InfoCommon_r12_cfnHandling (&pvalue->cfnHandling);
   asn1Init_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_MAC_d_HFN_initial_value (&pvalue->mac_d_HFN_initial_value);
}

void asn1Free_utran_DL_DPCH_InfoCommon_r12 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommon_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoCommon_r12_cfnHandling (pctxt, &pvalue->cfnHandling);
   asn1Free_utran_DL_DPCH_InfoCommon_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (
   utran_DL_CommonInformation_r12_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12_dl_dpchInfoCommon* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoCommon) {
            asn1Free_utran_DL_DPCH_InfoCommon_r12 (pctxt, pvalue->u.dl_DPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoCommon);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoCommon) {
            asn1Free_utran_DL_FDPCH_InfoCommon_r6 (pctxt, pvalue->u.dl_FDPCH_InfoCommon);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoCommon);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (
   utran_DL_CommonInformation_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DPCH_CompressedModeInfo_r10 (&pvalue->dpch_CompressedModeInfo);
}

void asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12_modeSpecificInfo_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dpch_CompressedModeInfoPresent) {
      asn1Free_utran_DPCH_CompressedModeInfo_r10 (pctxt, &pvalue->dpch_CompressedModeInfo);
   }
}

void asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (
   utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.tdd128) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (
   utran_DL_CommonInformation_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (&pvalue->tddOption);
}

void asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12_modeSpecificInfo_tdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd_tddOption (pctxt, &pvalue->tddOption);
}

void asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo (
   utran_DL_CommonInformation_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

static const OSEnumItem utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r12_mac_hsResetIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r12_mac_hsResetIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r12_mac_hsResetIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r12_mac_hsResetIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTAB, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r12_mac_hsResetIndicator)
         utran_DL_CommonInformation_r12_mac_hsResetIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r12_postVerificationPeriod_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r12_postVerificationPeriod_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r12_postVerificationPeriod* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r12_postVerificationPeriod_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r12_postVerificationPeriod_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r12_postVerificationPeriod* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTAB, 
      utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r12_postVerificationPeriod)
         utran_DL_CommonInformation_r12_postVerificationPeriod_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE) {
      return utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB, 
      utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting)
         utran_DL_CommonInformation_r12_mac_hsResetIndicator_assisting_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_CommonInformation_r12 (
   utran_DL_CommonInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (&pvalue->dl_dpchInfoCommon);
   asn1Init_utran_DL_CommonInformation_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
}

void asn1Free_utran_DL_CommonInformation_r12 (OSCTXT *pctxt, 
   utran_DL_CommonInformation_r12* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_dpchInfoCommonPresent) {
      asn1Free_utran_DL_CommonInformation_r12_dl_dpchInfoCommon (pctxt, &pvalue->dl_dpchInfoCommon);
   }
   asn1Free_utran_DL_CommonInformation_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo (
   utran_DL_InformationPerRL_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r12_fdd (
   utran_DL_DPCH_InfoPerRL_r12_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SecondaryCPICH_Info (&pvalue->secondaryCPICH_Info);
   asn1Init_utran_DL_ChannelisationCodeList (&pvalue->dl_ChannelisationCodeList);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r12_fdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r12_fdd* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_ChannelisationCodeList (pctxt, &pvalue->dl_ChannelisationCodeList);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r12_tdd (
   utran_DL_DPCH_InfoPerRL_r12_tdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_CCTrChList_r7 (&pvalue->dl_CCTrChListToEstablish);
   asn1Init_utran_DL_CCTrChListToRemove (&pvalue->dl_CCTrChListToRemove);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r12_tdd (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r12_tdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_CCTrChListToEstablishPresent) {
      asn1Free_utran_DL_CCTrChList_r7 (pctxt, &pvalue->dl_CCTrChListToEstablish);
   }
}

void asn1Init_utran_DL_DPCH_InfoPerRL_r12 (utran_DL_DPCH_InfoPerRL_r12* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_DPCH_InfoPerRL_r12 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_r12* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r12_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r12_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_dl_dpchInfo (
   utran_DL_InformationPerRL_r12_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r12 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

      case 3:
         if (0 != pvalue->u.radioLinkswithoutDPCHFDPCHInfo) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

      case 3:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.f_TPICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.f_TPICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (&pvalue->e_RGCH_Info);
   asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (&pvalue->f_TPICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
   if (pvalue->m.f_TPICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768 (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD384_768 (&pvalue->e_HICH_Info);
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (
   utran_DL_InformationPerRL_r12_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r12 (
   utran_DL_InformationPerRL_r12* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r12_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_AGCH_Information_r8 (&pvalue->e_AGCH_Information);
   asn1Init_utran_E_ROCH_Information (&pvalue->e_ROCH_Information);
   asn1Init_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (&pvalue->modeSpecificInfo2);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r12 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r12* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r12_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_AGCH_InformationPresent) {
      asn1Free_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
   }
   asn1Free_utran_DL_InformationPerRL_r12_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
}

void asn1Init_utran_DL_InformationPerRL_List_r12 (
   utran_DL_InformationPerRL_List_r12* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r12 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r12* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r12* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r12*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r12 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_Non_rectResAllocInd_TDD128_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_Non_rectResAllocInd_TDD128_ENUMTABSIZE 1

const OSUTF8CHAR* utran_Non_rectResAllocInd_TDD128_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_Non_rectResAllocInd_TDD128_ENUMTAB, 
      utran_Non_rectResAllocInd_TDD128_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_Non_rectResAllocInd_TDD128_ENUMTABSIZE) {
      return utran_Non_rectResAllocInd_TDD128_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_Non_rectResAllocInd_TDD128_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_Non_rectResAllocInd_TDD128* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_Non_rectResAllocInd_TDD128_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_Non_rectResAllocInd_TDD128_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_Non_rectResAllocInd_TDD128* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_Non_rectResAllocInd_TDD128_ENUMTAB, 
      utran_Non_rectResAllocInd_TDD128_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_Non_rectResAllocInd_TDD128)
         utran_Non_rectResAllocInd_TDD128_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_Non_rectResSpecTSset_TDD128 (
   utran_Non_rectResSpecTSset_TDD128* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem utran_T_330_ENUMTAB[] = {
   { OSUTF8("m10"), 1, 3, 5 },
   { OSUTF8("m120"), 5, 4, 0 },
   { OSUTF8("m180"), 6, 4, 3 },
   { OSUTF8("m20"), 2, 3, 4 },
   { OSUTF8("m30"), 3, 3, 6 },
   { OSUTF8("m5"), 0, 2, 1 },
   { OSUTF8("m60"), 4, 3, 2 },
   { OSUTF8("spare1"), 7, 6, 7 }
} ;
#define utran_T_330_ENUMTABSIZE 8

const OSUTF8CHAR* utran_T_330_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_T_330_ENUMTABSIZE) {
      return utran_T_330_ENUMTAB[utran_T_330_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_T_330_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_T_330* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_T_330_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_T_330_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_T_330* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_T_330_ENUMTAB, 
      utran_T_330_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_T_330)utran_T_330_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_WLANThreshBackhaulRate_ENUMTAB[] = {
   { OSUTF8("r0"), 0, 2, 0 },
   { OSUTF8("r1024"), 9, 5, 19 },
   { OSUTF8("r1048576"), 19, 8, 29 },
   { OSUTF8("r1073741824"), 29, 11, 7 },
   { OSUTF8("r128"), 6, 4, 16 },
   { OSUTF8("r131072"), 16, 7, 26 },
   { OSUTF8("r134217728"), 26, 10, 4 },
   { OSUTF8("r16"), 3, 3, 13 },
   { OSUTF8("r16384"), 13, 6, 23 },
   { OSUTF8("r16777216"), 23, 9, 1 },
   { OSUTF8("r2048"), 10, 5, 10 },
   { OSUTF8("r2097152"), 20, 8, 20 },
   { OSUTF8("r2147483648"), 30, 11, 30 },
   { OSUTF8("r256"), 7, 4, 8 },
   { OSUTF8("r262144"), 17, 7, 17 },
   { OSUTF8("r268435456"), 27, 10, 27 },
   { OSUTF8("r32"), 4, 3, 5 },
   { OSUTF8("r32768"), 14, 6, 14 },
   { OSUTF8("r33554432"), 24, 9, 24 },
   { OSUTF8("r4"), 1, 2, 2 },
   { OSUTF8("r4096"), 11, 5, 11 },
   { OSUTF8("r4194304"), 21, 8, 21 },
   { OSUTF8("r4294967296"), 31, 11, 31 },
   { OSUTF8("r512"), 8, 4, 9 },
   { OSUTF8("r524288"), 18, 7, 18 },
   { OSUTF8("r536870912"), 28, 10, 28 },
   { OSUTF8("r64"), 5, 3, 6 },
   { OSUTF8("r65536"), 15, 6, 15 },
   { OSUTF8("r67108864"), 25, 9, 25 },
   { OSUTF8("r8"), 2, 2, 3 },
   { OSUTF8("r8192"), 12, 5, 12 },
   { OSUTF8("r8388608"), 22, 8, 22 }
} ;
#define utran_WLANThreshBackhaulRate_ENUMTABSIZE 32

const OSUTF8CHAR* utran_WLANThreshBackhaulRate_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_WLANThreshBackhaulRate_ENUMTABSIZE) {
      return utran_WLANThreshBackhaulRate_ENUMTAB
         [utran_WLANThreshBackhaulRate_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_WLANThreshBackhaulRate_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_WLANThreshBackhaulRate* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_WLANThreshBackhaulRate_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_WLANThreshBackhaulRate_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_WLANThreshBackhaulRate* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_WLANThreshBackhaulRate_ENUMTAB, 
      utran_WLANThreshBackhaulRate_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_WLANThreshBackhaulRate)
         utran_WLANThreshBackhaulRate_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_WLANOffloadConfig (utran_WLANOffloadConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   pvalue->offloadPreferenceIndicator.numbits = 0;
}

void asn1Init_utran_WLANIdentifier_ssid (utran_WLANIdentifier_ssid* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_WLANIdentifier_bssid (utran_WLANIdentifier_bssid* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_WLANIdentifier_hessid (utran_WLANIdentifier_hessid* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_WLANIdentifier (utran_WLANIdentifier* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_WLANIdentifier_ssid (&pvalue->ssid);
   asn1Init_utran_WLANIdentifier_bssid (&pvalue->bssid);
   asn1Init_utran_WLANIdentifier_hessid (&pvalue->hessid);
}

void asn1Init_utran_WLANIdentifierList (utran_WLANIdentifierList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_WLANIdentifierList (OSCTXT *pctxt, 
   utran_WLANIdentifierList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_WLANOffloadInformation (
   utran_WLANOffloadInformation* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_WLANOffloadConfig (&pvalue->wlanOffloadConfig);
   asn1Init_utran_WLANIdentifierList (&pvalue->wlanIdentifierList);
}

void asn1Free_utran_WLANOffloadInformation (OSCTXT *pctxt, 
   utran_WLANOffloadInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.wlanIdentifierListPresent) {
      asn1Free_utran_WLANIdentifierList (pctxt, &pvalue->wlanIdentifierList);
   }
}

void asn1Init_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (
   utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_WLANOffloadInformation (&pvalue->wlanOffloadInformation);
}

void asn1Free_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (OSCTXT *pctxt, 
   utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_WLANOffloadInformation (pctxt, &pvalue->wlanOffloadInformation);
}

void asn1Init_utran_DedicatedWLANOffloadInformation_configurationInfo (
   utran_DedicatedWLANOffloadInformation_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DedicatedWLANOffloadInformation_configurationInfo (OSCTXT *pctxt, 
   utran_DedicatedWLANOffloadInformation_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            asn1Free_utran_DedicatedWLANOffloadInformation_configurationInfo_newConfiguration (pctxt, pvalue->u.newConfiguration);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DedicatedWLANOffloadInformation (
   utran_DedicatedWLANOffloadInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DedicatedWLANOffloadInformation_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_DedicatedWLANOffloadInformation (OSCTXT *pctxt, 
   utran_DedicatedWLANOffloadInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DedicatedWLANOffloadInformation_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_RLC_InfoChoice_r11 (utran_RLC_InfoChoice_r11* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RLC_InfoChoice_r11 (OSCTXT *pctxt, 
   utran_RLC_InfoChoice_r11* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rlc_Info) {
            asn1Free_utran_RLC_Info_r11 (pctxt, pvalue->u.rlc_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rlc_Info);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_RB_InformationSetup_r11 (
   utran_RB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice_r11 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r11 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice_r11 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r11 (
   utran_RB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r11 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r11*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r11 (
   utran_RAB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Info_r7 (&pvalue->rab_Info);
   asn1Init_utran_CS_HSPA_Information (&pvalue->cs_HSPA_Information);
   asn1Init_utran_RAB_InfoReplace (&pvalue->rab_InfoReplace);
   asn1Init_utran_RB_InformationSetupList_r11 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r11 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info_r7 (pctxt, &pvalue->rab_Info);
   if (pvalue->m.rab_InfoReplacePresent) {
      asn1Free_utran_RAB_InfoReplace (pctxt, &pvalue->rab_InfoReplace);
   }
   asn1Free_utran_RB_InformationSetupList_r11 (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RetrievableConfigListToRemove (
   utran_RetrievableConfigListToRemove* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_SRB_InformationSetup_r11 (
   utran_SRB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice_r11 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup_r11 (OSCTXT *pctxt, 
   utran_SRB_InformationSetup_r11* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice_r11 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList_r11 (
   utran_SRB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList_r11 (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup_r11*)pnode->data;
      asn1Free_utran_SRB_InformationSetup_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetupList_r11 (
   utran_RAB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r11 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r11* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r11* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r11*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r11 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

static const OSEnumItem utran_HARQ_Info_r13_numberOfProcesses_ENUMTAB[] = {
   { OSUTF8("n1"), 0, 2, 0 },
   { OSUTF8("n12"), 8, 3, 4 },
   { OSUTF8("n14"), 9, 3, 7 },
   { OSUTF8("n16"), 10, 3, 9 },
   { OSUTF8("n2"), 1, 2, 10 },
   { OSUTF8("n24"), 11, 3, 11 },
   { OSUTF8("n28"), 12, 3, 12 },
   { OSUTF8("n3"), 2, 2, 13 },
   { OSUTF8("n32"), 13, 3, 1 },
   { OSUTF8("n4"), 3, 2, 2 },
   { OSUTF8("n5"), 4, 2, 3 },
   { OSUTF8("n6"), 5, 2, 5 },
   { OSUTF8("n7"), 6, 2, 6 },
   { OSUTF8("n8"), 7, 2, 8 }
} ;
#define utran_HARQ_Info_r13_numberOfProcesses_ENUMTABSIZE 14

const OSUTF8CHAR* utran_HARQ_Info_r13_numberOfProcesses_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_HARQ_Info_r13_numberOfProcesses_ENUMTABSIZE) {
      return utran_HARQ_Info_r13_numberOfProcesses_ENUMTAB
         [utran_HARQ_Info_r13_numberOfProcesses_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HARQ_Info_r13_numberOfProcesses_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_HARQ_Info_r13_numberOfProcesses* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HARQ_Info_r13_numberOfProcesses_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HARQ_Info_r13_numberOfProcesses_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HARQ_Info_r13_numberOfProcesses* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HARQ_Info_r13_numberOfProcesses_ENUMTAB, 
      utran_HARQ_Info_r13_numberOfProcesses_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HARQ_Info_r13_numberOfProcesses)
         utran_HARQ_Info_r13_numberOfProcesses_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize (
   utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO (
   utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (
   utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (
   utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit_ (
   utran_HARQ_Info_r13_memoryPartitioning_explicit_* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__memorySize (&pvalue->memorySize);
   asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesForMIMO (&pvalue->additionalMemorySizesForMIMO);
   asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesThirdMIMOStream (&pvalue->additionalMemorySizesThirdMIMOStream);
   asn1Init_utran_HARQ_Info_r13_memoryPartitioning_explicit__additionalMemorySizesFourthMIMOStream (&pvalue->additionalMemorySizesFourthMIMOStream);
}

void asn1Init_utran_HARQ_Info_r13_memoryPartitioning (
   utran_HARQ_Info_r13_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HARQ_Info_r13_memoryPartitioning (OSCTXT *pctxt, 
   utran_HARQ_Info_r13_memoryPartitioning* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.explicit_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_);
         }
         break;

   }
}

static const OSEnumItem utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTABSIZE 1

const OSUTF8CHAR* utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTAB, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTABSIZE) {
      return utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTAB, 
      utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA)
         utran_HARQ_Info_r13_blindHARQRetransmissionsForHSDPA_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_HARQ_Info_r13 (utran_HARQ_Info_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r13_memoryPartitioning (&pvalue->memoryPartitioning);
}

void asn1Free_utran_HARQ_Info_r13 (OSCTXT *pctxt, utran_HARQ_Info_r13* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_HARQ_Info_r13_memoryPartitioning (pctxt, &pvalue->memoryPartitioning);
}

void asn1Init_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (
   utran_HSDSCH_Info_r13_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r13_dl_MAC_HeaderType* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.mac_hs) {
            asn1Free_utran_AddOrReconfMAC_dFlow (pctxt, pvalue->u.mac_hs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_hs);
         }
         break;

      case 2:
         if (0 != pvalue->u.mac_ehs) {
            asn1Free_utran_AddOrReconfMAC_ehs_ReordQ_r11 (pctxt, pvalue->u.mac_ehs);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.mac_ehs);
         }
         break;

   }
}

void asn1Init_utran_HSDSCH_Info_r13 (utran_HSDSCH_Info_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_HARQ_Info_r13 (&pvalue->harqInfo);
   asn1Init_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (&pvalue->dl_MAC_HeaderType);
}

void asn1Free_utran_HSDSCH_Info_r13 (OSCTXT *pctxt, 
   utran_HSDSCH_Info_r13* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.harqInfoPresent) {
      asn1Free_utran_HARQ_Info_r13 (pctxt, &pvalue->harqInfo);
   }
   if (pvalue->m.dl_MAC_HeaderTypePresent) {
      asn1Free_utran_HSDSCH_Info_r13_dl_MAC_HeaderType (pctxt, &pvalue->dl_MAC_HeaderType);
   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (
   utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.explicit_config) {
            asn1Free_utran_TransportFormatSet (pctxt, pvalue->u.explicit_config);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.explicit_config);
         }
         break;

      case 2:
         if (0 != pvalue->u.sameAsULTrCH) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sameAsULTrCH);
         }
         break;

      case 3:
         if (0 != pvalue->u.hsdsch) {
            asn1Free_utran_HSDSCH_Info_r13 (pctxt, pvalue->u.hsdsch);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.hsdsch);
         }
         break;

   }
}

void asn1Init_utran_DL_AddReconfTransChInformation_r13 (
   utran_DL_AddReconfTransChInformation_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_TrCH_TypeId1_r5 (&pvalue->dl_TransportChannelType);
   asn1Init_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (&pvalue->tfs_SignallingMode);
}

void asn1Free_utran_DL_AddReconfTransChInformation_r13 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInformation_r13* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_AddReconfTransChInformation_r13_tfs_SignallingMode (pctxt, &pvalue->tfs_SignallingMode);
}

void asn1Init_utran_DL_AddReconfTransChInfoList_r13 (
   utran_DL_AddReconfTransChInfoList_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_AddReconfTransChInfoList_r13 (OSCTXT *pctxt, 
   utran_DL_AddReconfTransChInfoList_r13* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_AddReconfTransChInformation_r13* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_AddReconfTransChInformation_r13*)pnode->data;
      asn1Free_utran_DL_AddReconfTransChInformation_r13 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RetrievableConfigData (utran_RetrievableConfigData* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SRB_InformationSetupList_r11 (&pvalue->srb_InformationSetupList);
   asn1Init_utran_RAB_InformationSetupList_r11 (&pvalue->rab_InformationSetupList);
   asn1Init_utran_RB_InformationReconfigList_r11 (&pvalue->rb_InformationReconfigList);
   asn1Init_utran_UL_CommonTransChInfo_r12 (&pvalue->ul_CommonTransChInfo);
   asn1Init_utran_UL_AddReconfTransChInfoList_r8 (&pvalue->ul_TransChInfoList);
   asn1Init_utran_DL_CommonTransChInfo_r4 (&pvalue->dl_CommonTransChInfo);
   asn1Init_utran_DL_AddReconfTransChInfoList_r13 (&pvalue->dl_TransChInfoList);
   asn1Init_utran_DTX_DRX_Info_r12 (&pvalue->dtx_drx_Info);
   asn1Init_utran_HS_SCCH_LessInfo_r7 (&pvalue->hs_scch_LessInfo);
   asn1Init_utran_MIMO_Parameters_r9 (&pvalue->mimoParameters);
   asn1Init_utran_MIMO4x4_Parameters (&pvalue->mimo4x4Parameters);
   asn1Init_utran_DCH_Enhancements_Info_FDD (&pvalue->dch_Enhancements_Info_FDD);
   asn1Init_utran_UL_EDCH_Information_r11 (&pvalue->ul_EDCH_Information);
   asn1Init_utran_DL_HSPDSCH_Information_r12 (&pvalue->dl_HSPDSCH_Information);
   asn1Init_utran_DL_SecondaryCellInfoFDD_r11 (&pvalue->dl_SecondaryCellInfoFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD_r11 (&pvalue->additionalDLSecCellInfoListFDD);
   asn1Init_utran_AdditionalDLSecCellInfoListFDD2 (&pvalue->additionalDLSecCellInfoListFDD2);
}

void asn1Free_utran_RetrievableConfigData (OSCTXT *pctxt, 
   utran_RetrievableConfigData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.srb_InformationSetupListPresent) {
      asn1Free_utran_SRB_InformationSetupList_r11 (pctxt, &pvalue->srb_InformationSetupList);
   }
   if (pvalue->m.rab_InformationSetupListPresent) {
      asn1Free_utran_RAB_InformationSetupList_r11 (pctxt, &pvalue->rab_InformationSetupList);
   }
   if (pvalue->m.rb_InformationReconfigListPresent) {
      asn1Free_utran_RB_InformationReconfigList_r11 (pctxt, &pvalue->rb_InformationReconfigList);
   }
   if (pvalue->m.ul_CommonTransChInfoPresent) {
      asn1Free_utran_UL_CommonTransChInfo_r12 (pctxt, &pvalue->ul_CommonTransChInfo);
   }
   if (pvalue->m.ul_TransChInfoListPresent) {
      asn1Free_utran_UL_AddReconfTransChInfoList_r8 (pctxt, &pvalue->ul_TransChInfoList);
   }
   if (pvalue->m.dl_CommonTransChInfoPresent) {
      asn1Free_utran_DL_CommonTransChInfo_r4 (pctxt, &pvalue->dl_CommonTransChInfo);
   }
   if (pvalue->m.dl_TransChInfoListPresent) {
      asn1Free_utran_DL_AddReconfTransChInfoList_r13 (pctxt, &pvalue->dl_TransChInfoList);
   }
   if (pvalue->m.dtx_drx_InfoPresent) {
      asn1Free_utran_DTX_DRX_Info_r12 (pctxt, &pvalue->dtx_drx_Info);
   }
   if (pvalue->m.hs_scch_LessInfoPresent) {
      asn1Free_utran_HS_SCCH_LessInfo_r7 (pctxt, &pvalue->hs_scch_LessInfo);
   }
   if (pvalue->m.mimoParametersPresent) {
      asn1Free_utran_MIMO_Parameters_r9 (pctxt, &pvalue->mimoParameters);
   }
   if (pvalue->m.mimo4x4ParametersPresent) {
      asn1Free_utran_MIMO4x4_Parameters (pctxt, &pvalue->mimo4x4Parameters);
   }
   if (pvalue->m.dch_Enhancements_Info_FDDPresent) {
      asn1Free_utran_DCH_Enhancements_Info_FDD (pctxt, &pvalue->dch_Enhancements_Info_FDD);
   }
   if (pvalue->m.ul_EDCH_InformationPresent) {
      asn1Free_utran_UL_EDCH_Information_r11 (pctxt, &pvalue->ul_EDCH_Information);
   }
   if (pvalue->m.dl_HSPDSCH_InformationPresent) {
      asn1Free_utran_DL_HSPDSCH_Information_r12 (pctxt, &pvalue->dl_HSPDSCH_Information);
   }
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_r11 (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDDPresent) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD_r11 (pctxt, &pvalue->additionalDLSecCellInfoListFDD);
   }
   if (pvalue->m.additionalDLSecCellInfoListFDD2Present) {
      asn1Free_utran_AdditionalDLSecCellInfoListFDD2 (pctxt, &pvalue->additionalDLSecCellInfoListFDD2);
   }
}

void asn1Init_utran_RetrievableConfig (utran_RetrievableConfig* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RetrievableConfigData (&pvalue->retrievableConfigData);
}

void asn1Free_utran_RetrievableConfig (OSCTXT *pctxt, 
   utran_RetrievableConfig* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RetrievableConfigData (pctxt, &pvalue->retrievableConfigData);
}

void asn1Init_utran_RetrievableConfig_List (
   utran_RetrievableConfig_List* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RetrievableConfig_List (OSCTXT *pctxt, 
   utran_RetrievableConfig_List* pvalue)
{
   if (0 == pvalue) return;
   { utran_RetrievableConfig* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RetrievableConfig*)pnode->data;
      asn1Free_utran_RetrievableConfig (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RetrievableConfigInfo (utran_RetrievableConfigInfo* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RetrievableConfigListToRemove (&pvalue->retrievableConfigToBeRemoved);
   asn1Init_utran_RetrievableConfig_List (&pvalue->preconfiguredRetrievableConfig);
}

void asn1Free_utran_RetrievableConfigInfo (OSCTXT *pctxt, 
   utran_RetrievableConfigInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.preconfiguredRetrievableConfigPresent) {
      asn1Free_utran_RetrievableConfig_List (pctxt, &pvalue->preconfiguredRetrievableConfig);
   }
}

void asn1Init_utran_OtherStateConfigData_rntis_new_ (
   utran_OtherStateConfigData_rntis_new_* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_C_RNTI (&pvalue->new_C_RNTI);
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
}

void asn1Init_utran_OtherStateConfigData_rntis (
   utran_OtherStateConfigData_rntis* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_OtherStateConfigData_rntis (OSCTXT *pctxt, 
   utran_OtherStateConfigData_rntis* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.new_) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.new_);
         }
         break;

   }
}

void asn1Init_utran_OtherStateConfigData_configuration (
   utran_OtherStateConfigData_configuration* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_OtherStateConfigData_configuration (OSCTXT *pctxt, 
   utran_OtherStateConfigData_configuration* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.full) {
            asn1Free_utran_RetrievableConfigData (pctxt, pvalue->u.full);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.full);
         }
         break;

   }
}

void asn1Init_utran_OtherStateConfigData (utran_OtherStateConfigData* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_URA_Identity (&pvalue->ura_Identity);
   asn1Init_utran_OtherStateConfigData_rntis (&pvalue->rntis);
   asn1Init_utran_OtherStateConfigData_configuration (&pvalue->configuration);
}

void asn1Free_utran_OtherStateConfigData (OSCTXT *pctxt, 
   utran_OtherStateConfigData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_OtherStateConfigData_rntis (pctxt, &pvalue->rntis);
   if (pvalue->m.configurationPresent) {
      asn1Free_utran_OtherStateConfigData_configuration (pctxt, &pvalue->configuration);
   }
}

void asn1Init_utran_OtherStateConfigList (utran_OtherStateConfigList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_OtherStateConfigList (OSCTXT *pctxt, 
   utran_OtherStateConfigList* pvalue)
{
   if (0 == pvalue) return;
   { utran_OtherStateConfigData* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_OtherStateConfigData*)pnode->data;
      asn1Free_utran_OtherStateConfigData (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_OtherStateRemoveList (utran_OtherStateRemoveList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_OtherStateConfig (utran_OtherStateConfig* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_OtherStateConfigList (&pvalue->otherStateConfigList);
   asn1Init_utran_OtherStateRemoveList (&pvalue->otherStateRemoveList);
}

void asn1Free_utran_OtherStateConfig (OSCTXT *pctxt, 
   utran_OtherStateConfig* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.otherStateConfigListPresent) {
      asn1Free_utran_OtherStateConfigList (pctxt, &pvalue->otherStateConfigList);
   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo (
   utran_DL_InformationPerRL_r13_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_PrimaryCCPCH_Info_r4 (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_dl_dpchInfo (
   utran_DL_InformationPerRL_r13_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_dl_dpchInfo (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_dl_dpchInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.dl_DPCH_InfoPerRL) {
            asn1Free_utran_DL_DPCH_InfoPerRL_r12 (pctxt, pvalue->u.dl_DPCH_InfoPerRL);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_DPCH_InfoPerRL);
         }
         break;

      case 2:
         if (0 != pvalue->u.dl_FDPCH_InfoPerRL) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dl_FDPCH_InfoPerRL);
         }
         break;

      case 3:
         if (0 != pvalue->u.radioLinkswithoutDPCHFDPCHInfo) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.radioLinkswithoutDPCHFDPCHInfo);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_HICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_HICH_Information);
         }
         break;

      case 2:
         break;

      case 3:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.e_RGCH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.e_RGCH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.f_TPICH_Information) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.f_TPICH_Information);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (&pvalue->e_HICH_Info);
   asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (&pvalue->e_RGCH_Info);
   asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (&pvalue->f_TPICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_HICH_Info (pctxt, &pvalue->e_HICH_Info);
   }
   if (pvalue->m.e_RGCH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_e_RGCH_Info (pctxt, &pvalue->e_RGCH_Info);
   }
   if (pvalue->m.f_TPICH_InfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd_f_TPICH_Info (pctxt, &pvalue->f_TPICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768 (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd384_tdd768* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD384_768 (&pvalue->e_HICH_Info);
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_E_HICH_Information_TDD128 (&pvalue->e_HICH_Info);
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.e_HICH_InfoPresent) {
      asn1Free_utran_E_HICH_Information_TDD128 (pctxt, &pvalue->e_HICH_Info);
   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.tdd384_tdd768) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd384_tdd768);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd128) {
            asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd_tdd128 (pctxt, pvalue->u.tdd128);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd128);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (
   utran_DL_InformationPerRL_r13_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13_modeSpecificInfo2* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fdd) {
            asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_fdd (pctxt, pvalue->u.fdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fdd);
         }
         break;

      case 2:
         if (0 != pvalue->u.tdd) {
            asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2_tdd (pctxt, pvalue->u.tdd);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tdd);
         }
         break;

   }
}

void asn1Init_utran_DL_InformationPerRL_r13 (
   utran_DL_InformationPerRL_r13* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo (&pvalue->modeSpecificInfo);
   asn1Init_utran_DL_InformationPerRL_r13_dl_dpchInfo (&pvalue->dl_dpchInfo);
   asn1Init_utran_E_AGCH_Information_r8 (&pvalue->e_AGCH_Information);
   asn1Init_utran_E_ROCH_Information (&pvalue->e_ROCH_Information);
   asn1Init_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (&pvalue->modeSpecificInfo2);
   asn1Init_utran_CellIdentity (&pvalue->cell_id);
}

void asn1Free_utran_DL_InformationPerRL_r13 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_r13* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo (pctxt, &pvalue->modeSpecificInfo);
   if (pvalue->m.dl_dpchInfoPresent) {
      asn1Free_utran_DL_InformationPerRL_r13_dl_dpchInfo (pctxt, &pvalue->dl_dpchInfo);
   }
   if (pvalue->m.e_AGCH_InformationPresent) {
      asn1Free_utran_E_AGCH_Information_r8 (pctxt, &pvalue->e_AGCH_Information);
   }
   asn1Free_utran_DL_InformationPerRL_r13_modeSpecificInfo2 (pctxt, &pvalue->modeSpecificInfo2);
}

void asn1Init_utran_DL_InformationPerRL_List_r13 (
   utran_DL_InformationPerRL_List_r13* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_List_r13 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_List_r13* pvalue)
{
   if (0 == pvalue) return;
   { utran_DL_InformationPerRL_r13* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_DL_InformationPerRL_r13*)pnode->data;
      asn1Free_utran_DL_InformationPerRL_r13 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_COUNT_C_MSB_InformationList (
   utran_RB_COUNT_C_MSB_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_COUNT_C_MSB_InformationList (OSCTXT *pctxt, 
   utran_RB_COUNT_C_MSB_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_RB_COUNT_C_InformationList (
   utran_RB_COUNT_C_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_COUNT_C_InformationList (OSCTXT *pctxt, 
   utran_RB_COUNT_C_InformationList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_NAS_Message (utran_NAS_Message* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_ETWS_Information_warningType (
   utran_ETWS_Information_warningType* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_ETWS_Information_messageIdentifier (
   utran_ETWS_Information_messageIdentifier* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_ETWS_Information_serialNumber (
   utran_ETWS_Information_serialNumber* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_ETWS_Information (utran_ETWS_Information* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_ETWS_Information_warningType (&pvalue->warningType);
   asn1Init_utran_ETWS_Information_messageIdentifier (&pvalue->messageIdentifier);
   asn1Init_utran_ETWS_Information_serialNumber (&pvalue->serialNumber);
}

void asn1Init_utran_ETWS_WarningSecurityInfo (
   utran_ETWS_WarningSecurityInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
   pvalue->data = 0;
}

void asn1Free_utran_ETWS_WarningSecurityInfo (OSCTXT *pctxt, 
   utran_ETWS_WarningSecurityInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void asn1Init_utran_S_RNTI_2 (utran_S_RNTI_2* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_U_RNTI_Short (utran_U_RNTI_Short* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SRNC_Identity (&pvalue->srnc_Identity);
   asn1Init_utran_S_RNTI_2 (&pvalue->s_RNTI_2);
}

void asn1Init_utran_RLC_InfoChoice (utran_RLC_InfoChoice* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RLC_InfoChoice (OSCTXT *pctxt, 
   utran_RLC_InfoChoice* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rlc_Info) {
            asn1Free_utran_RLC_Info (pctxt, pvalue->u.rlc_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rlc_Info);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_SRB_InformationSetup (utran_SRB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup (OSCTXT *pctxt, 
   utran_SRB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList (
   utran_SRB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup*)pnode->data;
      asn1Free_utran_SRB_InformationSetup (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationSetup (utran_RB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup (OSCTXT *pctxt, 
   utran_RB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList (
   utran_RB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList (OSCTXT *pctxt, 
   utran_RB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup*)pnode->data;
      asn1Free_utran_RB_InformationSetup (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup (utran_RAB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Info (&pvalue->rab_Info);
   asn1Init_utran_RB_InformationSetupList (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup (OSCTXT *pctxt, 
   utran_RAB_InformationSetup* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   asn1Free_utran_RB_InformationSetupList (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RAB_InformationSetupList (
   utran_RAB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup*)pnode->data;
      asn1Free_utran_RAB_InformationSetup (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_Info_Post (utran_RAB_Info_Post* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Identity (&pvalue->rab_Identity);
   asn1Init_utran_NAS_Synchronisation_Indicator (&pvalue->nas_Synchronisation_Indicator);
}

void asn1Free_utran_RAB_Info_Post (OSCTXT *pctxt, utran_RAB_Info_Post* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
}

void asn1Init_utran_DL_DPCH_InfoCommonPost (
   utran_DL_DPCH_InfoCommonPost* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_DPCH_PowerControlInfo (&pvalue->dl_DPCH_PowerControlInfo);
}

void asn1Free_utran_DL_DPCH_InfoCommonPost (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoCommonPost* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_DPCH_PowerControlInfoPresent) {
      asn1Free_utran_DL_DPCH_PowerControlInfo (pctxt, &pvalue->dl_DPCH_PowerControlInfo);
   }
}

void asn1Init_utran_DL_CommonInformationPost (
   utran_DL_CommonInformationPost* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_DPCH_InfoCommonPost (&pvalue->dl_DPCH_InfoCommon);
}

void asn1Free_utran_DL_CommonInformationPost (OSCTXT *pctxt, 
   utran_DL_CommonInformationPost* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoCommonPost (pctxt, &pvalue->dl_DPCH_InfoCommon);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_PostFDD (
   utran_DL_DPCH_InfoPerRL_PostFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_ChannelisationCode (&pvalue->dl_ChannelisationCode);
}

void asn1Init_utran_DL_InformationPerRL_PostFDD (
   utran_DL_InformationPerRL_PostFDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_DPCH_InfoPerRL_PostFDD (&pvalue->dl_DPCH_InfoPerRL);
}

void asn1Init_utran_DL_InformationPerRL_ListPostFDD (
   utran_DL_InformationPerRL_ListPostFDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_DL_InformationPerRL_ListPostFDD (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_ListPostFDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_UL_DPCH_InfoPostTDD (utran_UL_DPCH_InfoPostTDD* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UplinkTimeslotsCodes (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_DPCH_InfoPostTDD (OSCTXT *pctxt, 
   utran_UL_DPCH_InfoPostTDD* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl (pctxt, &pvalue->ul_TimingAdvance);
   }
   asn1Free_utran_UplinkTimeslotsCodes (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Init_utran_PrimaryCCPCH_InfoPost_syncCase (
   utran_PrimaryCCPCH_InfoPost_syncCase* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PrimaryCCPCH_InfoPost_syncCase (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_InfoPost_syncCase* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.syncCase1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase1);
         }
         break;

      case 2:
         if (0 != pvalue->u.syncCase2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.syncCase2);
         }
         break;

   }
}

void asn1Init_utran_PrimaryCCPCH_InfoPost (utran_PrimaryCCPCH_InfoPost* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PrimaryCCPCH_InfoPost_syncCase (&pvalue->syncCase);
}

void asn1Free_utran_PrimaryCCPCH_InfoPost (OSCTXT *pctxt, 
   utran_PrimaryCCPCH_InfoPost* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PrimaryCCPCH_InfoPost_syncCase (pctxt, &pvalue->syncCase);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_PostTDD (
   utran_DL_DPCH_InfoPerRL_PostTDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkTimeslotsCodes (&pvalue->dl_DPCH_TimeslotsCodes);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_PostTDD (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_PostTDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkTimeslotsCodes (pctxt, &pvalue->dl_DPCH_TimeslotsCodes);
}

void asn1Init_utran_DL_InformationPerRL_PostTDD (
   utran_DL_InformationPerRL_PostTDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PrimaryCCPCH_InfoPost (&pvalue->primaryCCPCH_Info);
   asn1Init_utran_DL_DPCH_InfoPerRL_PostTDD (&pvalue->dl_DPCH_InfoPerRL);
}

void asn1Free_utran_DL_InformationPerRL_PostTDD (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_PostTDD* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PrimaryCCPCH_InfoPost (pctxt, &pvalue->primaryCCPCH_Info);
   asn1Free_utran_DL_DPCH_InfoPerRL_PostTDD (pctxt, &pvalue->dl_DPCH_InfoPerRL);
}

void asn1Init_utran_RB_InformationSetup_r4 (
   utran_RB_InformationSetup_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r4 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r4 (
   utran_RB_InformationSetupList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r4 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r4*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r4 (
   utran_RAB_InformationSetup_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Info (&pvalue->rab_Info);
   asn1Init_utran_RB_InformationSetupList_r4 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r4 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   asn1Free_utran_RB_InformationSetupList_r4 (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RAB_InformationSetupList_r4 (
   utran_RAB_InformationSetupList_r4* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r4 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r4* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r4* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r4*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r4 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_LCR_r4_enabled (
   utran_UL_TimingAdvanceControl_LCR_r4_enabled* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_SynchronisationParameters_r4 (&pvalue->synchronisationParameters);
}

void asn1Free_utran_UL_TimingAdvanceControl_LCR_r4_enabled (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_LCR_r4_enabled* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.synchronisationParametersPresent) {
      asn1Free_utran_SynchronisationParameters_r4 (pctxt, &pvalue->synchronisationParameters);
   }
}

void asn1Init_utran_UL_TimingAdvanceControl_LCR_r4 (
   utran_UL_TimingAdvanceControl_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_UL_TimingAdvanceControl_LCR_r4 (OSCTXT *pctxt, 
   utran_UL_TimingAdvanceControl_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.enabled) {
            asn1Free_utran_UL_TimingAdvanceControl_LCR_r4_enabled (pctxt, pvalue->u.enabled);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.enabled);
         }
         break;

   }
}

void asn1Init_utran_UL_DPCH_InfoPostTDD_LCR_r4 (
   utran_UL_DPCH_InfoPostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UL_TimingAdvanceControl_LCR_r4 (&pvalue->ul_TimingAdvance);
   asn1Init_utran_UplinkTimeslotsCodes_LCR_r4 (&pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_UL_DPCH_InfoPostTDD_LCR_r4 (OSCTXT *pctxt, 
   utran_UL_DPCH_InfoPostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.ul_TimingAdvancePresent) {
      asn1Free_utran_UL_TimingAdvanceControl_LCR_r4 (pctxt, &pvalue->ul_TimingAdvance);
   }
   asn1Free_utran_UplinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->ul_CCTrCH_TimeslotsCodes);
}

void asn1Init_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (
   utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DownlinkTimeslotsCodes_LCR_r4 (&pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Free_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (OSCTXT *pctxt, 
   utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DownlinkTimeslotsCodes_LCR_r4 (pctxt, &pvalue->dl_CCTrCH_TimeslotsCodes);
}

void asn1Init_utran_DL_InformationPerRL_PostTDD_LCR_r4 (
   utran_DL_InformationPerRL_PostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (&pvalue->dl_DPCH_InfoPerRL);
}

void asn1Free_utran_DL_InformationPerRL_PostTDD_LCR_r4 (OSCTXT *pctxt, 
   utran_DL_InformationPerRL_PostTDD_LCR_r4* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_DPCH_InfoPerRL_PostTDD_LCR_r4 (pctxt, &pvalue->dl_DPCH_InfoPerRL);
}

void asn1Init_utran_RLC_InfoChoice_r5 (utran_RLC_InfoChoice_r5* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RLC_InfoChoice_r5 (OSCTXT *pctxt, 
   utran_RLC_InfoChoice_r5* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rlc_Info) {
            asn1Free_utran_RLC_Info_r5 (pctxt, pvalue->u.rlc_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rlc_Info);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_SRB_InformationSetup_r5 (
   utran_SRB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice_r5 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r5 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup_r5 (OSCTXT *pctxt, 
   utran_SRB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice_r5 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList_r5 (
   utran_SRB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList_r5 (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup_r5*)pnode->data;
      asn1Free_utran_SRB_InformationSetup_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RB_InformationSetup_r5 (
   utran_RB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice_r5 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r5 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r5 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice_r5 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r5 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r5 (
   utran_RB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r5 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r5*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r5 (
   utran_RAB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Info (&pvalue->rab_Info);
   asn1Init_utran_RB_InformationSetupList_r5 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r5 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r5* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info (pctxt, &pvalue->rab_Info);
   asn1Free_utran_RB_InformationSetupList_r5 (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RAB_InformationSetupList_r5 (
   utran_RAB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r5 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r5* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r5* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r5*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r5 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RLC_InfoChoice_r6 (utran_RLC_InfoChoice_r6* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RLC_InfoChoice_r6 (OSCTXT *pctxt, 
   utran_RLC_InfoChoice_r6* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.rlc_Info) {
            asn1Free_utran_RLC_Info_r6 (pctxt, pvalue->u.rlc_Info);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rlc_Info);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_SRB_InformationSetup_r6 (
   utran_SRB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice_r6 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r6 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup_r6 (OSCTXT *pctxt, 
   utran_SRB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice_r6 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList_r6 (
   utran_SRB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList_r6 (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup_r6*)pnode->data;
      asn1Free_utran_SRB_InformationSetup_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_Info_r6 (utran_RAB_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RAB_Identity (&pvalue->rab_Identity);
   asn1Init_utran_MBMS_SessionIdentity (&pvalue->mbms_SessionIdentity);
   asn1Init_utran_NAS_Synchronisation_Indicator (&pvalue->nas_Synchronisation_Indicator);
}

void asn1Free_utran_RAB_Info_r6 (OSCTXT *pctxt, utran_RAB_Info_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Identity (pctxt, &pvalue->rab_Identity);
}

void asn1Init_utran_RB_InformationSetup_r6 (
   utran_RB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Info_r4 (&pvalue->pdcp_Info);
   asn1Init_utran_RLC_InfoChoice_r6 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r6 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_RB_InformationSetup_r6 (OSCTXT *pctxt, 
   utran_RB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pdcp_InfoPresent) {
      asn1Free_utran_PDCP_Info_r4 (pctxt, &pvalue->pdcp_Info);
   }
   asn1Free_utran_RLC_InfoChoice_r6 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r6 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_RB_InformationSetupList_r6 (
   utran_RB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RB_InformationSetupList_r6 (OSCTXT *pctxt, 
   utran_RB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RB_InformationSetup_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RB_InformationSetup_r6*)pnode->data;
      asn1Free_utran_RB_InformationSetup_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetup_r6 (
   utran_RAB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RAB_Info_r6 (&pvalue->rab_Info);
   asn1Init_utran_RB_InformationSetupList_r6 (&pvalue->rb_InformationSetupList);
}

void asn1Free_utran_RAB_InformationSetup_r6 (OSCTXT *pctxt, 
   utran_RAB_InformationSetup_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_Info_r6 (pctxt, &pvalue->rab_Info);
   asn1Free_utran_RB_InformationSetupList_r6 (pctxt, &pvalue->rb_InformationSetupList);
}

void asn1Init_utran_RAB_InformationSetupList_r6 (
   utran_RAB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r6 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r6*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_HSPA_Identities_r6 (utran_UE_HSPA_Identities_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newPrimary_E_RNTI);
   asn1Init_utran_E_RNTI (&pvalue->newSecondary_E_RNTI);
}

void asn1Init_utran_SRB_InformationSetup_r7 (
   utran_SRB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice_r7 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r7 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup_r7 (OSCTXT *pctxt, 
   utran_SRB_InformationSetup_r7* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r7 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList_r7 (
   utran_SRB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList_r7 (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup_r7*)pnode->data;
      asn1Free_utran_SRB_InformationSetup_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetupList_r7 (
   utran_RAB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r7 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r7* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r7* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r7*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r7 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetupList_v820ext (
   utran_RAB_InformationSetupList_v820ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_v820ext (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_v820ext* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_SRB_InformationSetup_r8 (
   utran_SRB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RLC_InfoChoice_r7 (&pvalue->rlc_InfoChoice);
   asn1Init_utran_RB_MappingInfo_r8 (&pvalue->rb_MappingInfo);
}

void asn1Free_utran_SRB_InformationSetup_r8 (OSCTXT *pctxt, 
   utran_SRB_InformationSetup_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RLC_InfoChoice_r7 (pctxt, &pvalue->rlc_InfoChoice);
   asn1Free_utran_RB_MappingInfo_r8 (pctxt, &pvalue->rb_MappingInfo);
}

void asn1Init_utran_SRB_InformationSetupList_r8 (
   utran_SRB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_SRB_InformationSetupList_r8 (OSCTXT *pctxt, 
   utran_SRB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_SRB_InformationSetup_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_SRB_InformationSetup_r8*)pnode->data;
      asn1Free_utran_SRB_InformationSetup_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RAB_InformationSetupList_r8 (
   utran_RAB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationSetupList_r8 (OSCTXT *pctxt, 
   utran_RAB_InformationSetupList_r8* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_InformationSetup_r8* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_InformationSetup_r8*)pnode->data;
      asn1Free_utran_RAB_InformationSetup_r8 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_DLUL_HSPA_Information_r8 (
   utran_DLUL_HSPA_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_EDCH_Information_r8 (&pvalue->ul_EDCH_Information);
   asn1Init_utran_DL_CommonInformation_r8 (&pvalue->dl_CommonInformation);
   asn1Init_utran_DL_InformationPerRL_List_r7 (&pvalue->dl_InformationPerRL_List);
   asn1Init_utran_DL_HSPDSCH_Information_r8 (&pvalue->dl_HSPDSCH_Information);
}

void asn1Free_utran_DLUL_HSPA_Information_r8 (OSCTXT *pctxt, 
   utran_DLUL_HSPA_Information_r8* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r8 (pctxt, &pvalue->ul_EDCH_Information);
   asn1Free_utran_DL_CommonInformation_r8 (pctxt, &pvalue->dl_CommonInformation);
   asn1Free_utran_DL_InformationPerRL_List_r7 (pctxt, &pvalue->dl_InformationPerRL_List);
   asn1Free_utran_DL_HSPDSCH_Information_r8 (pctxt, &pvalue->dl_HSPDSCH_Information);
}

void asn1Init_utran_DLUL_HSPA_Information_r9 (
   utran_DLUL_HSPA_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_EDCH_Information_r9 (&pvalue->ul_EDCH_Information);
   asn1Init_utran_DL_CommonInformation_r8 (&pvalue->dl_CommonInformation);
   asn1Init_utran_DL_InformationPerRL_List_r7 (&pvalue->dl_InformationPerRL_List);
   asn1Init_utran_DL_HSPDSCH_Information_r9 (&pvalue->dl_HSPDSCH_Information);
}

void asn1Free_utran_DLUL_HSPA_Information_r9 (OSCTXT *pctxt, 
   utran_DLUL_HSPA_Information_r9* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r9 (pctxt, &pvalue->ul_EDCH_Information);
   asn1Free_utran_DL_CommonInformation_r8 (pctxt, &pvalue->dl_CommonInformation);
   asn1Free_utran_DL_InformationPerRL_List_r7 (pctxt, &pvalue->dl_InformationPerRL_List);
   asn1Free_utran_DL_HSPDSCH_Information_r9 (pctxt, &pvalue->dl_HSPDSCH_Information);
}

void asn1Init_utran_DLUL_HSPA_Information_r10 (
   utran_DLUL_HSPA_Information_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UL_EDCH_Information_r9 (&pvalue->ul_EDCH_Information);
   asn1Init_utran_DL_CommonInformation_r10 (&pvalue->dl_CommonInformation);
   asn1Init_utran_DL_InformationPerRL_List_r7 (&pvalue->dl_InformationPerRL_List);
   asn1Init_utran_DL_HSPDSCH_Information_r9 (&pvalue->dl_HSPDSCH_Information);
}

void asn1Free_utran_DLUL_HSPA_Information_r10 (OSCTXT *pctxt, 
   utran_DLUL_HSPA_Information_r10* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UL_EDCH_Information_r9 (pctxt, &pvalue->ul_EDCH_Information);
   asn1Free_utran_DL_CommonInformation_r10 (pctxt, &pvalue->dl_CommonInformation);
   asn1Free_utran_DL_InformationPerRL_List_r7 (pctxt, &pvalue->dl_InformationPerRL_List);
   asn1Free_utran_DL_HSPDSCH_Information_r9 (pctxt, &pvalue->dl_HSPDSCH_Information);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

static const OSEnumItem utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[] = {
   { OSUTF8("different"), 0, 9, 0 }
} ;
#define utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE 1

const OSUTF8CHAR* utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE) {
      return utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB, 
      utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell)
         utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_differentTxModeFromServingHS_DSCHCell_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration (
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_H_RNTI (&pvalue->new_H_RNTI);
   asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo_newConfiguration_hS_SCCHChannelisationCodeInfo (&pvalue->hS_SCCHChannelisationCodeInfo);
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo (
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.newConfiguration) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.newConfiguration);
         }
         break;

   }
}

void asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran (
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo (&pvalue->configurationInfo);
}

void asn1Free_utran_DL_SecondaryCellInfoFDD_HandoverToUtran (OSCTXT *pctxt, 
   utran_DL_SecondaryCellInfoFDD_HandoverToUtran* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_DL_SecondaryCellInfoFDD_HandoverToUtran_configurationInfo (pctxt, &pvalue->configurationInfo);
}

void asn1Init_utran_AdditionalDLSecCellInfoFDD_HandoverToUtran (
   utran_AdditionalDLSecCellInfoFDD_HandoverToUtran* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_DL_SecondaryCellInfoFDD_HandoverToUtran (&pvalue->dl_SecondaryCellInfoFDD);
}

void asn1Free_utran_AdditionalDLSecCellInfoFDD_HandoverToUtran (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoFDD_HandoverToUtran* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.dl_SecondaryCellInfoFDDPresent) {
      asn1Free_utran_DL_SecondaryCellInfoFDD_HandoverToUtran (pctxt, &pvalue->dl_SecondaryCellInfoFDD);
   }
}

void asn1Init_utran_AdditionalDLSecCellInfoHandoverToUtranListFDD (
   utran_AdditionalDLSecCellInfoHandoverToUtranListFDD* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_AdditionalDLSecCellInfoHandoverToUtranListFDD (OSCTXT *pctxt, 
   utran_AdditionalDLSecCellInfoHandoverToUtranListFDD* pvalue)
{
   if (0 == pvalue) return;
   { utran_AdditionalDLSecCellInfoFDD_HandoverToUtran* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_AdditionalDLSecCellInfoFDD_HandoverToUtran*)pnode->data;
      asn1Free_utran_AdditionalDLSecCellInfoFDD_HandoverToUtran (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_RoutingParameter (utran_RoutingParameter* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_localPTMSI (
   utran_Gsm_map_IDNNS_routingbasis_localPTMSI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN (
   utran_Gsm_map_IDNNS_routingbasis_tMSIofsamePLMN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN (
   utran_Gsm_map_IDNNS_routingbasis_tMSIofdifferentPLMN* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging (
   utran_Gsm_map_IDNNS_routingbasis_iMSIresponsetopaging* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent (
   utran_Gsm_map_IDNNS_routingbasis_iMSIcauseUEinitiatedEvent* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_iMEI (
   utran_Gsm_map_IDNNS_routingbasis_iMEI* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_spare2 (
   utran_Gsm_map_IDNNS_routingbasis_spare2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis_spare1 (
   utran_Gsm_map_IDNNS_routingbasis_spare1* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RoutingParameter (&pvalue->routingparameter);
}

void asn1Init_utran_Gsm_map_IDNNS_routingbasis (
   utran_Gsm_map_IDNNS_routingbasis* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_Gsm_map_IDNNS_routingbasis (OSCTXT *pctxt, 
   utran_Gsm_map_IDNNS_routingbasis* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.localPTMSI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.localPTMSI);
         }
         break;

      case 2:
         if (0 != pvalue->u.tMSIofsamePLMN) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tMSIofsamePLMN);
         }
         break;

      case 3:
         if (0 != pvalue->u.tMSIofdifferentPLMN) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.tMSIofdifferentPLMN);
         }
         break;

      case 4:
         if (0 != pvalue->u.iMSIresponsetopaging) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMSIresponsetopaging);
         }
         break;

      case 5:
         if (0 != pvalue->u.iMSIcauseUEinitiatedEvent) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMSIcauseUEinitiatedEvent);
         }
         break;

      case 6:
         if (0 != pvalue->u.iMEI) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iMEI);
         }
         break;

      case 7:
         if (0 != pvalue->u.spare2) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.spare2);
         }
         break;

      case 8:
         if (0 != pvalue->u.spare1) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.spare1);
         }
         break;

   }
}

void asn1Init_utran_Gsm_map_IDNNS (utran_Gsm_map_IDNNS* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_Gsm_map_IDNNS_routingbasis (&pvalue->routingbasis);
}

void asn1Free_utran_Gsm_map_IDNNS (OSCTXT *pctxt, utran_Gsm_map_IDNNS* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_Gsm_map_IDNNS_routingbasis (pctxt, &pvalue->routingbasis);
}

void asn1Init_utran_Ansi_41_IDNNS (utran_Ansi_41_IDNNS* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_IntraDomainNasNodeSelector_version_release99_cn_Type (
   utran_IntraDomainNasNodeSelector_version_release99_cn_Type* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_IntraDomainNasNodeSelector_version_release99_cn_Type (OSCTXT *pctxt, 
   utran_IntraDomainNasNodeSelector_version_release99_cn_Type* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.gsm_Map_IDNNS) {
            asn1Free_utran_Gsm_map_IDNNS (pctxt, pvalue->u.gsm_Map_IDNNS);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.gsm_Map_IDNNS);
         }
         break;

      case 2:
         if (0 != pvalue->u.ansi_41_IDNNS) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ansi_41_IDNNS);
         }
         break;

   }
}

void asn1Init_utran_IntraDomainNasNodeSelector_version_release99 (
   utran_IntraDomainNasNodeSelector_version_release99* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IntraDomainNasNodeSelector_version_release99_cn_Type (&pvalue->cn_Type);
}

void asn1Free_utran_IntraDomainNasNodeSelector_version_release99 (OSCTXT *pctxt, 
   utran_IntraDomainNasNodeSelector_version_release99* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IntraDomainNasNodeSelector_version_release99_cn_Type (pctxt, &pvalue->cn_Type);
}

void asn1Init_utran_IntraDomainNasNodeSelector_version_later (
   utran_IntraDomainNasNodeSelector_version_later* pvalue)
{
   if (0 == pvalue) return;
   pvalue->futurecoding.numbits = 0;
}

void asn1Init_utran_IntraDomainNasNodeSelector_version (
   utran_IntraDomainNasNodeSelector_version* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_IntraDomainNasNodeSelector_version (OSCTXT *pctxt, 
   utran_IntraDomainNasNodeSelector_version* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.release99) {
            asn1Free_utran_IntraDomainNasNodeSelector_version_release99 (pctxt, pvalue->u.release99);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.release99);
         }
         break;

      case 2:
         if (0 != pvalue->u.later) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.later);
         }
         break;

   }
}

void asn1Init_utran_IntraDomainNasNodeSelector (
   utran_IntraDomainNasNodeSelector* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_IntraDomainNasNodeSelector_version (&pvalue->version);
}

void asn1Free_utran_IntraDomainNasNodeSelector (OSCTXT *pctxt, 
   utran_IntraDomainNasNodeSelector* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_IntraDomainNasNodeSelector_version (pctxt, &pvalue->version);
}

void asn1Init_utran_P_TMSI_GSM_MAP (utran_P_TMSI_GSM_MAP* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_MBMS_JoinedInformation_r6 (
   utran_MBMS_JoinedInformation_r6* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_P_TMSI_GSM_MAP (&pvalue->p_TMSI);
}

void asn1Init_utran_GSM_MessageList_element (
   utran_GSM_MessageList_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_GSM_MessageList (utran_GSM_MessageList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_SR_VCC_SecurityRABInfo_v860ext (
   utran_SR_VCC_SecurityRABInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_SR_VCC_Info (&pvalue->sr_vcc_Info);
   asn1Init_utran_RAB_InfoReplace (&pvalue->rab_InfoReplace);
}

void asn1Free_utran_SR_VCC_SecurityRABInfo_v860ext (OSCTXT *pctxt, 
   utran_SR_VCC_SecurityRABInfo_v860ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RAB_InfoReplace (pctxt, &pvalue->rab_InfoReplace);
}

void asn1Init_utran_RAB_InformationList_r6 (
   utran_RAB_InformationList_r6* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_RAB_InformationList_r6 (OSCTXT *pctxt, 
   utran_RAB_InformationList_r6* pvalue)
{
   if (0 == pvalue) return;
   { utran_RAB_Info_r6* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_RAB_Info_r6*)pnode->data;
      asn1Free_utran_RAB_Info_r6 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_GERANIu_MessageList_element (
   utran_GERANIu_MessageList_element* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_GERANIu_MessageList (utran_GERANIu_MessageList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_CDMA2000_Message_payload (
   utran_CDMA2000_Message_payload* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_CDMA2000_Message (utran_CDMA2000_Message* pvalue)
{
   if (0 == pvalue) return;
   pvalue->msg_Type.numbits = 0;
   asn1Init_utran_CDMA2000_Message_payload (&pvalue->payload);
}

void asn1Init_utran_CDMA2000_MessageList (utran_CDMA2000_MessageList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CDMA2000_MessageList (OSCTXT *pctxt, 
   utran_CDMA2000_MessageList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_RSR_VCC_Info_nonce (utran_RSR_VCC_Info_nonce* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

void asn1Init_utran_RSR_VCC_Info_ims_Information (
   utran_RSR_VCC_Info_ims_Information* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numocts = 0;
}

void asn1Init_utran_RSR_VCC_Info (utran_RSR_VCC_Info* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RSR_VCC_Info_nonce (&pvalue->nonce);
   asn1Init_utran_RSR_VCC_Info_ims_Information (&pvalue->ims_Information);
}

void asn1Init_utran_InterRAT_HO_FailureCause (
   utran_InterRAT_HO_FailureCause* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_InterRAT_HO_FailureCause (OSCTXT *pctxt, 
   utran_InterRAT_HO_FailureCause* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.protocolError) {
            asn1Free_utran_ProtocolErrorInformation (pctxt, pvalue->u.protocolError);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.protocolError);
         }
         break;

      case 4:
         break;

      case 5:
         break;

      case 6:
         break;

      case 7:
         break;

      case 8:
         break;

      case 9:
         break;

      case 10:
         break;

      case 11:
         break;

      case 12:
         break;

      case 13:
         break;

      case 14:
         break;

      case 15:
         break;

      case 16:
         break;

   }
}

void asn1Init_utran_PredefinedConfigStatusInfo_other (
   utran_PredefinedConfigStatusInfo_other* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_PredefinedConfigStatusInfo (
   utran_PredefinedConfigStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PredefinedConfigStatusInfo (OSCTXT *pctxt, 
   utran_PredefinedConfigStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.other) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.other);
         }
         break;

   }
}

void asn1Init_utran_PredefinedConfigStatusList (
   utran_PredefinedConfigStatusList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PredefinedConfigStatusList (OSCTXT *pctxt, 
   utran_PredefinedConfigStatusList* pvalue)
{
   if (0 == pvalue) return;
   { utran_PredefinedConfigStatusInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_PredefinedConfigStatusInfo*)pnode->data;
      asn1Free_utran_PredefinedConfigStatusInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_SecurityInformation (
   utran_UE_SecurityInformation* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_START_Value (&pvalue->start_CS);
}

static const OSEnumItem utran_SupportOfDedicatedPilotsForChEstimation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_SupportOfDedicatedPilotsForChEstimation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_SupportOfDedicatedPilotsForChEstimation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_SupportOfDedicatedPilotsForChEstimation_ENUMTAB, 
      utran_SupportOfDedicatedPilotsForChEstimation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_SupportOfDedicatedPilotsForChEstimation_ENUMTABSIZE) {
      return utran_SupportOfDedicatedPilotsForChEstimation_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_SupportOfDedicatedPilotsForChEstimation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_SupportOfDedicatedPilotsForChEstimation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_SupportOfDedicatedPilotsForChEstimation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_SupportOfDedicatedPilotsForChEstimation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_SupportOfDedicatedPilotsForChEstimation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_SupportOfDedicatedPilotsForChEstimation_ENUMTAB, 
      utran_SupportOfDedicatedPilotsForChEstimation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_SupportOfDedicatedPilotsForChEstimation)
         utran_SupportOfDedicatedPilotsForChEstimation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_DL_PhysChCapabilityFDD_v380ext (
   utran_DL_PhysChCapabilityFDD_v380ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTAB, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTABSIZE) {
      return utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTAB, 
      utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH)
         utran_UE_PositioningCapabilityExt_v3a0_validity_CellPCH_UraPCH_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UESpecificBehaviourInformation1interRAT (
   utran_UESpecificBehaviourInformation1interRAT* pvalue)
{
   if (0 == pvalue) return;
   pvalue->numbits = 0;
}

static const OSEnumItem utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTAB, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTABSIZE) {
      return utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTAB, 
      utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability)
         utran_UE_PositioningCapabilityExt_v3g0_sfn_sfnType2Capability_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_AccessStratumReleaseIndicator_ENUMTAB[] = {
   { OSUTF8("rel-10"), 6, 6, 4 },
   { OSUTF8("rel-11"), 7, 6, 5 },
   { OSUTF8("rel-12"), 8, 6, 6 },
   { OSUTF8("rel-13"), 9, 6, 7 },
   { OSUTF8("rel-4"), 0, 5, 8 },
   { OSUTF8("rel-5"), 1, 5, 9 },
   { OSUTF8("rel-6"), 2, 5, 0 },
   { OSUTF8("rel-7"), 3, 5, 1 },
   { OSUTF8("rel-8"), 4, 5, 2 },
   { OSUTF8("rel-9"), 5, 5, 3 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define utran_AccessStratumReleaseIndicator_ENUMTABSIZE 16

const OSUTF8CHAR* utran_AccessStratumReleaseIndicator_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_AccessStratumReleaseIndicator_ENUMTABSIZE) {
      return utran_AccessStratumReleaseIndicator_ENUMTAB
         [utran_AccessStratumReleaseIndicator_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_AccessStratumReleaseIndicator_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_AccessStratumReleaseIndicator* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_AccessStratumReleaseIndicator_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_AccessStratumReleaseIndicator_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_AccessStratumReleaseIndicator* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_AccessStratumReleaseIndicator_ENUMTAB, 
      utran_AccessStratumReleaseIndicator_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_AccessStratumReleaseIndicator)
         utran_AccessStratumReleaseIndicator_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_RadioFrequencyBandTDDList_ENUMTAB[] = {
   { OSUTF8("a"), 0, 1, 0 },
   { OSUTF8("ab"), 3, 2, 4 },
   { OSUTF8("abc"), 6, 3, 6 },
   { OSUTF8("ac"), 4, 2, 1 },
   { OSUTF8("b"), 1, 1, 3 },
   { OSUTF8("bc"), 5, 2, 5 },
   { OSUTF8("c"), 2, 1, 2 },
   { OSUTF8("spare"), 7, 5, 7 }
} ;
#define utran_RadioFrequencyBandTDDList_ENUMTABSIZE 8

const OSUTF8CHAR* utran_RadioFrequencyBandTDDList_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RadioFrequencyBandTDDList_ENUMTABSIZE) {
      return utran_RadioFrequencyBandTDDList_ENUMTAB
         [utran_RadioFrequencyBandTDDList_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RadioFrequencyBandTDDList_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RadioFrequencyBandTDDList* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RadioFrequencyBandTDDList_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RadioFrequencyBandTDDList_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RadioFrequencyBandTDDList* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RadioFrequencyBandTDDList_ENUMTAB, 
      utran_RadioFrequencyBandTDDList_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RadioFrequencyBandTDDList)
         utran_RadioFrequencyBandTDDList_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PredefinedConfigValueTagList (
   utran_PredefinedConfigValueTagList* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_PredefinedConfigSetWithDifferentValueTag (
   utran_PredefinedConfigSetWithDifferentValueTag* pvalue)
{
   if (0 == pvalue) return;
   pvalue->startPosition = 0;
   asn1Init_utran_PredefinedConfigValueTagList (&pvalue->valueTagList);
}

void asn1Init_utran_PredefinedConfigSetsWithDifferentValueTag (
   utran_PredefinedConfigSetsWithDifferentValueTag* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PredefinedConfigSetsWithDifferentValueTag (OSCTXT *pctxt, 
   utran_PredefinedConfigSetsWithDifferentValueTag* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_PredefinedConfigStatusListVarSz (
   utran_PredefinedConfigStatusListVarSz* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_PredefinedConfigStatusListVarSz (OSCTXT *pctxt, 
   utran_PredefinedConfigStatusListVarSz* pvalue)
{
   if (0 == pvalue) return;
   { utran_PredefinedConfigStatusInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_PredefinedConfigStatusInfo*)pnode->data;
      asn1Free_utran_PredefinedConfigStatusInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_PredefinedConfigStatusListComp (
   utran_PredefinedConfigStatusListComp* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PredefinedConfigSetsWithDifferentValueTag (&pvalue->setsWithDifferentValueTag);
   asn1Init_utran_PredefinedConfigStatusListVarSz (&pvalue->otherEntries);
}

void asn1Free_utran_PredefinedConfigStatusListComp (OSCTXT *pctxt, 
   utran_PredefinedConfigStatusListComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PredefinedConfigSetsWithDifferentValueTag (pctxt, &pvalue->setsWithDifferentValueTag);
   if (pvalue->m.otherEntriesPresent) {
      asn1Free_utran_PredefinedConfigStatusListVarSz (pctxt, &pvalue->otherEntries);
   }
}

static const OSEnumItem utran_RF_CapabBandFDDComp_ENUMTAB[] = {
   { OSUTF8("default-TxRx-separation"), 1, 23, 1 },
   { OSUTF8("notSupported"), 0, 12, 0 },
   { OSUTF8("spare1"), 3, 6, 3 },
   { OSUTF8("spare2"), 2, 6, 2 }
} ;
#define utran_RF_CapabBandFDDComp_ENUMTABSIZE 4

const OSUTF8CHAR* utran_RF_CapabBandFDDComp_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RF_CapabBandFDDComp_ENUMTABSIZE) {
      return utran_RF_CapabBandFDDComp_ENUMTAB
         [utran_RF_CapabBandFDDComp_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RF_CapabBandFDDComp_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RF_CapabBandFDDComp* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RF_CapabBandFDDComp_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RF_CapabBandFDDComp_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_RF_CapabBandFDDComp* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RF_CapabBandFDDComp_ENUMTAB, 
      utran_RF_CapabBandFDDComp_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RF_CapabBandFDDComp)
         utran_RF_CapabBandFDDComp_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RF_CapabBandListFDDComp (
   utran_RF_CapabBandListFDDComp* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_RF_CapabilityComp_fdd (utran_RF_CapabilityComp_fdd* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_RF_CapabilityComp_fdd (OSCTXT *pctxt, 
   utran_RF_CapabilityComp_fdd* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.supported) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.supported);
         }
         break;

   }
}

void asn1Init_utran_RF_CapabilityComp_tdd384_RF_Capability (
   utran_RF_CapabilityComp_tdd384_RF_Capability* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_RF_CapabilityComp_tdd128_RF_Capability (
   utran_RF_CapabilityComp_tdd128_RF_Capability* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_RF_CapabilityComp (utran_RF_CapabilityComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RF_CapabilityComp_fdd (&pvalue->fdd);
   asn1Init_utran_RF_CapabilityComp_tdd384_RF_Capability (&pvalue->tdd384_RF_Capability);
   asn1Init_utran_RF_CapabilityComp_tdd128_RF_Capability (&pvalue->tdd128_RF_Capability);
}

void asn1Free_utran_RF_CapabilityComp (OSCTXT *pctxt, 
   utran_RF_CapabilityComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RF_CapabilityComp_fdd (pctxt, &pvalue->fdd);
}

void asn1Init_utran_UE_RadioAccessCapabilityComp (
   utran_UE_RadioAccessCapabilityComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RF_CapabilityComp (&pvalue->rf_CapabilityComp);
}

void asn1Free_utran_UE_RadioAccessCapabilityComp (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapabilityComp* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_RF_CapabilityComp (pctxt, &pvalue->rf_CapabilityComp);
}

void asn1Init_utran_UE_SecurityInformation2 (
   utran_UE_SecurityInformation2* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_START_Value (&pvalue->start_PS);
}

void asn1Init_utran_RF_CapabBandListFDDComp_ext (
   utran_RF_CapabBandListFDDComp_ext* pvalue)
{
   if (0 == pvalue) return;
   pvalue->n = 0;
}

void asn1Init_utran_UE_RadioAccessCapabilityComp_ext (
   utran_UE_RadioAccessCapabilityComp_ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_RF_CapabBandListFDDComp_ext (&pvalue->rf_CapabilityFDDComp);
}

static const OSEnumItem utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTAB[] = {
   { OSUTF8("kbps128"), 2, 7, 1 },
   { OSUTF8("kbps32"), 0, 6, 3 },
   { OSUTF8("kbps384"), 3, 7, 0 },
   { OSUTF8("kbps64"), 1, 6, 2 }
} ;
#define utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTABSIZE 4

const OSUTF8CHAR* utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTABSIZE) {
      return utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTAB
         [utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_DL_CapabilityWithSimultaneousHS_DSCHConfig* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_DL_CapabilityWithSimultaneousHS_DSCHConfig* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTAB, 
      utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_DL_CapabilityWithSimultaneousHS_DSCHConfig)
         utran_DL_CapabilityWithSimultaneousHS_DSCHConfig_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PhysicalChannelCapability_edch_r6_fdd_edch (
   utran_PhysicalChannelCapability_edch_r6_fdd_edch* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Free_utran_PhysicalChannelCapability_edch_r6_fdd_edch (OSCTXT *pctxt, 
   utran_PhysicalChannelCapability_edch_r6_fdd_edch* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.supported) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.supported);
         }
         break;

      case 2:
         break;

   }
}

void asn1Init_utran_PhysicalChannelCapability_edch_r6 (
   utran_PhysicalChannelCapability_edch_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_PhysicalChannelCapability_edch_r6_fdd_edch (&pvalue->fdd_edch);
}

void asn1Free_utran_PhysicalChannelCapability_edch_r6 (OSCTXT *pctxt, 
   utran_PhysicalChannelCapability_edch_r6* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PhysicalChannelCapability_edch_r6_fdd_edch (pctxt, &pvalue->fdd_edch);
}

void asn1Init_utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch (
   utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PhysicalChannelCapability_edch_r6 (&pvalue->physicalChannelCapability_edch_r6);
}

void asn1Free_utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_PhysicalChannelCapability_edch_r6 (pctxt, &pvalue->physicalChannelCapability_edch_r6);
}

void asn1Init_utran_UE_RadioAccessCapabilityComp2 (
   utran_UE_RadioAccessCapabilityComp2* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch (&pvalue->fddPhysicalChannelCapab_hspdsch_edch);
}

void asn1Free_utran_UE_RadioAccessCapabilityComp2 (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapabilityComp2* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.fddPhysicalChannelCapab_hspdsch_edchPresent) {
      asn1Free_utran_UE_RadioAccessCapabilityComp2_fddPhysicalChannelCapab_hspdsch_edch (pctxt, &pvalue->fddPhysicalChannelCapab_hspdsch_edch);
   }
}

static const OSEnumItem utran_RadioFrequencyBandTDDList_r7_ENUMTAB[] = {
   { OSUTF8("a"), 0, 1, 0 },
   { OSUTF8("ab"), 4, 2, 8 },
   { OSUTF8("abc"), 10, 3, 12 },
   { OSUTF8("abcd"), 14, 4, 14 },
   { OSUTF8("abd"), 11, 3, 1 },
   { OSUTF8("ac"), 5, 2, 5 },
   { OSUTF8("acd"), 12, 3, 7 },
   { OSUTF8("ad"), 6, 2, 9 },
   { OSUTF8("b"), 1, 1, 11 },
   { OSUTF8("bc"), 7, 2, 13 },
   { OSUTF8("bcd"), 13, 3, 2 },
   { OSUTF8("bd"), 8, 2, 4 },
   { OSUTF8("c"), 2, 1, 6 },
   { OSUTF8("cd"), 9, 2, 10 },
   { OSUTF8("d"), 3, 1, 3 },
   { OSUTF8("notabcd"), 15, 7, 15 }
} ;
#define utran_RadioFrequencyBandTDDList_r7_ENUMTABSIZE 16

const OSUTF8CHAR* utran_RadioFrequencyBandTDDList_r7_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RadioFrequencyBandTDDList_r7_ENUMTABSIZE) {
      return utran_RadioFrequencyBandTDDList_r7_ENUMTAB
         [utran_RadioFrequencyBandTDDList_r7_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RadioFrequencyBandTDDList_r7_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RadioFrequencyBandTDDList_r7* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RadioFrequencyBandTDDList_r7_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RadioFrequencyBandTDDList_r7_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RadioFrequencyBandTDDList_r7* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RadioFrequencyBandTDDList_r7_ENUMTAB, 
      utran_RadioFrequencyBandTDDList_r7_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RadioFrequencyBandTDDList_r7)
         utran_RadioFrequencyBandTDDList_r7_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_RF_Capability_v770ext (utran_RF_Capability_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_MinimumSF_DL_768_ENUMTAB[] = {
   { OSUTF8("sf1"), 0, 3, 0 },
   { OSUTF8("sf32"), 1, 4, 1 }
} ;
#define utran_MinimumSF_DL_768_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MinimumSF_DL_768_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MinimumSF_DL_768_ENUMTABSIZE) {
      return utran_MinimumSF_DL_768_ENUMTAB
         [utran_MinimumSF_DL_768_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MinimumSF_DL_768_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MinimumSF_DL_768* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MinimumSF_DL_768_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MinimumSF_DL_768_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MinimumSF_DL_768* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MinimumSF_DL_768_ENUMTAB, utran_MinimumSF_DL_768_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MinimumSF_DL_768)
         utran_MinimumSF_DL_768_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MaxPhysChPerTimeslot_ENUMTAB[] = {
   { OSUTF8("ts1"), 0, 3, 0 },
   { OSUTF8("ts2"), 1, 3, 1 }
} ;
#define utran_MaxPhysChPerTimeslot_ENUMTABSIZE 2

const OSUTF8CHAR* utran_MaxPhysChPerTimeslot_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MaxPhysChPerTimeslot_ENUMTABSIZE) {
      return utran_MaxPhysChPerTimeslot_ENUMTAB
         [utran_MaxPhysChPerTimeslot_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MaxPhysChPerTimeslot_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MaxPhysChPerTimeslot* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MaxPhysChPerTimeslot_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MaxPhysChPerTimeslot_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_MaxPhysChPerTimeslot* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_MaxPhysChPerTimeslot_ENUMTAB, 
      utran_MaxPhysChPerTimeslot_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MaxPhysChPerTimeslot)
         utran_MaxPhysChPerTimeslot_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_MinimumSF_UL_ENUMTAB[] = {
   { OSUTF8("dummy"), 4, 5, 1 },
   { OSUTF8("sf1"), 0, 3, 2 },
   { OSUTF8("sf2"), 1, 3, 3 },
   { OSUTF8("sf4"), 2, 3, 4 },
   { OSUTF8("sf8"), 3, 3, 0 }
} ;
#define utran_MinimumSF_UL_ENUMTABSIZE 5

const OSUTF8CHAR* utran_MinimumSF_UL_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_MinimumSF_UL_ENUMTABSIZE) {
      return utran_MinimumSF_UL_ENUMTAB
         [utran_MinimumSF_UL_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_MinimumSF_UL_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_MinimumSF_UL* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_MinimumSF_UL_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_MinimumSF_UL_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, utran_MinimumSF_UL* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, utran_MinimumSF_UL_ENUMTAB, 
      utran_MinimumSF_UL_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_MinimumSF_UL)utran_MinimumSF_UL_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PhysicalChannelCapabilityInfo_v770ext (
   utran_PhysicalChannelCapabilityInfo_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

static const OSEnumItem utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication)
         utran_UE_RadioAccessCapabilityInfo_v770ext_ganssSupportIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTAB, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTAB, 
      utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport)
         utran_UE_RadioAccessCapabilityInfo_v770ext_mac_ehsSupport_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTAB[] = {
   { OSUTF8("nF"), 0, 2, 0 },
   { OSUTF8("nFMc-HexRx-HexTx"), 5, 16, 5 },
   { OSUTF8("nFMc-HexRx-TriTx"), 4, 16, 4 },
   { OSUTF8("nFMc-HexRx-UniTx"), 3, 16, 3 },
   { OSUTF8("nFMc-TriRx-TriTx"), 2, 16, 2 },
   { OSUTF8("nFMc-TriRx-UniTx"), 1, 16, 1 },
   { OSUTF8("nFMc-TwoRx-TwoTx-Contiguous"), 9, 27, 9 },
   { OSUTF8("nFMc-TwoRx-TwoTx-Discontiguous"), 7, 30, 7 },
   { OSUTF8("nFMc-TwoRx-UniTx-Contiguous"), 8, 27, 8 },
   { OSUTF8("nFMc-TwoRx-UniTx-Discontiguous"), 6, 30, 6 },
   { OSUTF8("spare1"), 15, 6, 15 },
   { OSUTF8("spare2"), 14, 6, 14 },
   { OSUTF8("spare3"), 13, 6, 13 },
   { OSUTF8("spare4"), 12, 6, 12 },
   { OSUTF8("spare5"), 11, 6, 11 },
   { OSUTF8("spare6"), 10, 6, 10 }
} ;
#define utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTABSIZE 16

const OSUTF8CHAR* utran_UE_SpecificCapabilityInformation_LCRTDD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTABSIZE) {
      return utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTAB
         [utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_SpecificCapabilityInformation_LCRTDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_SpecificCapabilityInformation_LCRTDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_SpecificCapabilityInformation_LCRTDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_SpecificCapabilityInformation_LCRTDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_SpecificCapabilityInformation_LCRTDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTAB, 
      utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_SpecificCapabilityInformation_LCRTDD)
         utran_UE_SpecificCapabilityInformation_LCRTDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_RadioAccessCapabilityInfo_v770ext (
   utran_UE_RadioAccessCapabilityInfo_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RF_Capability_v770ext (&pvalue->rf_Capability);
   asn1Init_utran_PhysicalChannelCapabilityInfo_v770ext (&pvalue->physicalChannelCapability);
}

void asn1Init_utran_RF_CapabilityComp_v770ext_tdd768_RF_Capability (
   utran_RF_CapabilityComp_v770ext_tdd768_RF_Capability* pvalue)
{
   if (0 == pvalue) return;
   pvalue->t = 0;
   OSCRTLMEMSET (&pvalue->u, 0, sizeof(pvalue->u));
}

void asn1Init_utran_RF_CapabilityComp_v770ext (
   utran_RF_CapabilityComp_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RF_CapabilityComp_v770ext_tdd768_RF_Capability (&pvalue->tdd768_RF_Capability);
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication)
         utran_UE_RadioAccessCapabilityComp_v770ext_securityCapabilityIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication)
         utran_UE_RadioAccessCapabilityComp_v770ext_ganssSupportIndication_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport)
         utran_UE_RadioAccessCapabilityComp_v770ext_mac_ehsSupport_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_UE_RadioAccessCapabilityComp_v770ext (
   utran_UE_RadioAccessCapabilityComp_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_RF_CapabilityComp_v770ext (&pvalue->rf_CapabilityComp);
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation)
         utran_UE_RadioAccessCapabilityComp2_v770ext_hsscchlessHsdschOperation_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch)
         utran_UE_RadioAccessCapabilityComp2_v770ext_enhancedFdpch_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach)
         utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellFach_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch)
         utran_UE_RadioAccessCapabilityComp2_v770ext_hsdschReception_CellUraPch_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = 
         (utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission)
         utran_UE_RadioAccessCapabilityComp2_v770ext_discontinuousDpcchTransmission_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4)
         utran_UE_RadioAccessCapabilityComp2_v770ext_slotFormat4_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTABSIZE 1

const OSUTF8CHAR* utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTAB, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTABSIZE) {
      return utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTAB, 
      utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA)
         utran_PDCP_Capability_v770ext_supportForCSVoiceoverHSPA_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_PDCP_Capability_v770ext (
   utran_PDCP_Capability_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
}

void asn1Init_utran_UE_RadioAccessCapabilityComp2_v770ext (
   utran_UE_RadioAccessCapabilityComp2_v770ext* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_PDCP_Capability_v770ext (&pvalue->pdcp_Capability);
}

static const OSEnumItem utran_RadioFrequencyBandFDD_ENUMTAB[] = {
   { OSUTF8("bandIV"), 4, 6, 7 },
   { OSUTF8("bandV"), 5, 5, 6 },
   { OSUTF8("bandVI"), 3, 6, 5 },
   { OSUTF8("bandVII"), 6, 7, 2 },
   { OSUTF8("extension-indicator"), 7, 19, 0 },
   { OSUTF8("fdd1800"), 2, 7, 1 },
   { OSUTF8("fdd1900"), 1, 7, 3 },
   { OSUTF8("fdd2100"), 0, 7, 4 }
} ;
#define utran_RadioFrequencyBandFDD_ENUMTABSIZE 8

const OSUTF8CHAR* utran_RadioFrequencyBandFDD_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RadioFrequencyBandFDD_ENUMTABSIZE) {
      return utran_RadioFrequencyBandFDD_ENUMTAB
         [utran_RadioFrequencyBandFDD_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RadioFrequencyBandFDD_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RadioFrequencyBandFDD* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RadioFrequencyBandFDD_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RadioFrequencyBandFDD_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RadioFrequencyBandFDD* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RadioFrequencyBandFDD_ENUMTAB, 
      utran_RadioFrequencyBandFDD_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RadioFrequencyBandFDD)
         utran_RadioFrequencyBandFDD_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

static const OSEnumItem utran_RadioFrequencyBandFDD2_ENUMTAB[] = {
   { OSUTF8("bandIX"), 1, 6, 1 },
   { OSUTF8("bandVIII"), 0, 8, 0 },
   { OSUTF8("bandX"), 2, 5, 2 },
   { OSUTF8("bandXI"), 3, 6, 3 },
   { OSUTF8("bandXII"), 4, 7, 4 },
   { OSUTF8("bandXIII"), 5, 8, 5 },
   { OSUTF8("bandXIV"), 6, 7, 6 },
   { OSUTF8("bandXIX"), 11, 7, 8 },
   { OSUTF8("bandXV"), 7, 6, 9 },
   { OSUTF8("bandXVI"), 8, 7, 10 },
   { OSUTF8("bandXVII"), 9, 8, 11 },
   { OSUTF8("bandXVIII"), 10, 9, 7 },
   { OSUTF8("bandXX"), 12, 6, 12 },
   { OSUTF8("bandXXI"), 13, 7, 13 },
   { OSUTF8("bandXXII"), 14, 8, 14 },
   { OSUTF8("extension-indicator"), 15, 19, 15 }
} ;
#define utran_RadioFrequencyBandFDD2_ENUMTABSIZE 16

const OSUTF8CHAR* utran_RadioFrequencyBandFDD2_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < utran_RadioFrequencyBandFDD2_ENUMTABSIZE) {
      return utran_RadioFrequencyBandFDD2_ENUMTAB
         [utran_RadioFrequencyBandFDD2_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_RadioFrequencyBandFDD2_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, utran_RadioFrequencyBandFDD2* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_RadioFrequencyBandFDD2_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_RadioFrequencyBandFDD2_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_RadioFrequencyBandFDD2* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_RadioFrequencyBandFDD2_ENUMTAB, 
      utran_RadioFrequencyBandFDD2_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_RadioFrequencyBandFDD2)
         utran_RadioFrequencyBandFDD2_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

void asn1Init_utran_CompressedModeMeasCapabEUTRAList (
   utran_CompressedModeMeasCapabEUTRAList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_CompressedModeMeasCapabEUTRAList (OSCTXT *pctxt, 
   utran_CompressedModeMeasCapabEUTRAList* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void asn1Init_utran_MeasurementCapabilityExt3 (
   utran_MeasurementCapabilityExt3* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_CompressedModeMeasCapabEUTRAList (&pvalue->compressedModeMeasCapabEUTRAList);
}

void asn1Free_utran_MeasurementCapabilityExt3 (OSCTXT *pctxt, 
   utran_MeasurementCapabilityExt3* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.compressedModeMeasCapabEUTRAListPresent) {
      asn1Free_utran_CompressedModeMeasCapabEUTRAList (pctxt, &pvalue->compressedModeMeasCapabEUTRAList);
   }
}

void asn1Init_utran_UE_RadioAccessCapabBandFDD3 (
   utran_UE_RadioAccessCapabBandFDD3* pvalue)
{
   if (0 == pvalue) return;
   OSCRTLMEMSET (&pvalue->m, 0, sizeof (pvalue->m));
   asn1Init_utran_MeasurementCapabilityExt3 (&pvalue->measurementCapability3);
}

void asn1Free_utran_UE_RadioAccessCapabBandFDD3 (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapabBandFDD3* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_MeasurementCapabilityExt3 (pctxt, &pvalue->measurementCapability3);
}

void asn1Init_utran_UE_RadioAccessCapabBandFDDList3 (
   utran_UE_RadioAccessCapabBandFDDList3* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFastInit (pvalue);
}

void asn1Free_utran_UE_RadioAccessCapabBandFDDList3 (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapabBandFDDList3* pvalue)
{
   if (0 == pvalue) return;
   { utran_UE_RadioAccessCapabBandFDD3* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (utran_UE_RadioAccessCapabBandFDD3*)pnode->data;
      asn1Free_utran_UE_RadioAccessCapabBandFDD3 (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void asn1Init_utran_UE_RadioAccessCapability_v860ext (
   utran_UE_RadioAccessCapability_v860ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Init_utran_UE_RadioAccessCapabBandFDDList3 (&pvalue->ue_RadioAccessCapabBandFDDList3);
}

void asn1Free_utran_UE_RadioAccessCapability_v860ext (OSCTXT *pctxt, 
   utran_UE_RadioAccessCapability_v860ext* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_utran_UE_RadioAccessCapabBandFDDList3 (pctxt, &pvalue->ue_RadioAccessCapabBandFDDList3);
}

static const OSEnumItem utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTAB[] = {
   { OSUTF8("true"), 0, 4, 0 }
} ;
#define utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTABSIZE 1

const OSUTF8CHAR* utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTABSIZE);

   if (idx >= 0 && idx < utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTABSIZE) {
      return utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTAB
         [idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTAB, 
      utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis)
         utran_UE_RadioAccessCapabilityComp2_v860ext_supportOfMACiis_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

